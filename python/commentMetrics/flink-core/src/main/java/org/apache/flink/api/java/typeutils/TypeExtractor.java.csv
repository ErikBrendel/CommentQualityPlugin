# id;timestamp;commentText;codeText;commentWords;codeWords
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1459358321;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1460741894;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1463093178;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1463730991;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1465391830;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1470647505;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1470775474;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1474459924;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1476262965;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1479218219;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1480354098;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1484056358;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1484078188;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1484924697;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1485118420;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1494349925;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1494363409;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterable, 		boolean hasCollector, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1494598316;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterable True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterable,_		boolean hasCollector,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {__		return getUnaryOperatorReturnType(_			function,_			baseClass,_			hasIterable ? 0 : -1,_			hasCollector ? 0 : -1,_			inType,_			functionName,_			allowMissing)__	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterable,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,boolean,has,iterable,boolean,has,collector,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,base,class,has,iterable,0,1,has,collector,0,1,in,type,function,name,allow,missing
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1474459924;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1476262965;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1479218219;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1480354098;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1484056358;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1484078188;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1484924697;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1485118420;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1494349925;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1494363409;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1494598316;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1496911361;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1509723634;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1509723634;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1511902791;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1515177485;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1517320791;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1528874321;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory);1532066767;Registers a type information factory globally for a certain type. Every following type extraction_operation will use the provided factory for this type. The factory will have highest precedence_for this type. In a hierarchy of types the registered factory has higher precedence than annotations_at the same level but lower precedence than factories defined down the hierarchy.__@param t type for which a new factory is registered_@param factory type information factory that will produce {@link TypeInformation};private static void registerFactory(Type t, Class<? extends TypeInfoFactory> factory) {_		Preconditions.checkNotNull(t, "Type parameter must not be null.")__		Preconditions.checkNotNull(factory, "Factory parameter must not be null.")___		if (!TypeInfoFactory.class.isAssignableFrom(factory)) {_			throw new IllegalArgumentException("Class is not a TypeInfoFactory.")__		}_		if (registeredTypeInfoFactories.containsKey(t)) {_			throw new InvalidTypesException("A TypeInfoFactory for type '" + t + "' is already registered.")__		}_		registeredTypeInfoFactories.put(t, factory)__	};registers,a,type,information,factory,globally,for,a,certain,type,every,following,type,extraction,operation,will,use,the,provided,factory,for,this,type,the,factory,will,have,highest,precedence,for,this,type,in,a,hierarchy,of,types,the,registered,factory,has,higher,precedence,than,annotations,at,the,same,level,but,lower,precedence,than,factories,defined,down,the,hierarchy,param,t,type,for,which,a,new,factory,is,registered,param,factory,type,information,factory,that,will,produce,link,type,information;private,static,void,register,factory,type,t,class,extends,type,info,factory,factory,preconditions,check,not,null,t,type,parameter,must,not,be,null,preconditions,check,not,null,factory,factory,parameter,must,not,be,null,if,type,info,factory,class,is,assignable,from,factory,throw,new,illegal,argument,exception,class,is,not,a,type,info,factory,if,registered,type,info,factories,contains,key,t,throw,new,invalid,types,exception,a,type,info,factory,for,type,t,is,already,registered,registered,type,info,factories,put,t,factory
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1459358321;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final Method m = FunctionUtils.checkAndExtractLambdaMethod(function)__			if (m != null) {_				_				validateLambdaGenericParameters(m)__				_				_				final int paramLen = m.getGenericParameterTypes().length - 1__				final Type input = (outputTypeArgumentIndex >= 0) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(m.getGenericParameterTypes()[paramLen], outputTypeArgumentIndex) : m.getGenericReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,method,m,function,utils,check,and,extract,lambda,method,function,if,m,null,validate,lambda,generic,parameters,m,final,int,param,len,m,get,generic,parameter,types,length,1,final,type,input,output,type,argument,index,0,m,get,generic,parameter,types,param,len,1,m,get,generic,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,m,get,generic,parameter,types,param,len,output,type,argument,index,m,get,generic,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1460741894;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final Method m = FunctionUtils.checkAndExtractLambdaMethod(function)__			if (m != null) {_				_				validateLambdaGenericParameters(m)__				_				_				final int paramLen = m.getGenericParameterTypes().length - 1__				final Type input = (outputTypeArgumentIndex >= 0) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(m.getGenericParameterTypes()[paramLen], outputTypeArgumentIndex) : m.getGenericReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,method,m,function,utils,check,and,extract,lambda,method,function,if,m,null,validate,lambda,generic,parameters,m,final,int,param,len,m,get,generic,parameter,types,length,1,final,type,input,output,type,argument,index,0,m,get,generic,parameter,types,param,len,1,m,get,generic,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,m,get,generic,parameter,types,param,len,output,type,argument,index,m,get,generic,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1463093178;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final Method m = FunctionUtils.checkAndExtractLambdaMethod(function)__			if (m != null) {_				_				validateLambdaGenericParameters(m)__				_				_				final int paramLen = m.getGenericParameterTypes().length - 1__				final Type input = (outputTypeArgumentIndex >= 0) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(m.getGenericParameterTypes()[paramLen], outputTypeArgumentIndex) : m.getGenericReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,method,m,function,utils,check,and,extract,lambda,method,function,if,m,null,validate,lambda,generic,parameters,m,final,int,param,len,m,get,generic,parameter,types,length,1,final,type,input,output,type,argument,index,0,m,get,generic,parameter,types,param,len,1,m,get,generic,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,m,get,generic,parameter,types,param,len,output,type,argument,index,m,get,generic,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1463730991;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final Method m = FunctionUtils.checkAndExtractLambdaMethod(function)__			if (m != null) {_				_				validateLambdaGenericParameters(m)__				_				_				final int paramLen = m.getGenericParameterTypes().length - 1__				final Type input = (outputTypeArgumentIndex >= 0) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(m.getGenericParameterTypes()[paramLen], outputTypeArgumentIndex) : m.getGenericReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,method,m,function,utils,check,and,extract,lambda,method,function,if,m,null,validate,lambda,generic,parameters,m,final,int,param,len,m,get,generic,parameter,types,length,1,final,type,input,output,type,argument,index,0,m,get,generic,parameter,types,param,len,1,m,get,generic,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,m,get,generic,parameter,types,param,len,output,type,argument,index,m,get,generic,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1465391830;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final Method m = FunctionUtils.checkAndExtractLambdaMethod(function)__			if (m != null) {_				_				validateLambdaGenericParameters(m)__				_				_				final int paramLen = m.getGenericParameterTypes().length - 1__				final Type input = (outputTypeArgumentIndex >= 0) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(m.getGenericParameterTypes()[paramLen], outputTypeArgumentIndex) : m.getGenericReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,method,m,function,utils,check,and,extract,lambda,method,function,if,m,null,validate,lambda,generic,parameters,m,final,int,param,len,m,get,generic,parameter,types,length,1,final,type,input,output,type,argument,index,0,m,get,generic,parameter,types,param,len,1,m,get,generic,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,m,get,generic,parameter,types,param,len,output,type,argument,index,m,get,generic,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1470647505;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final Method m = FunctionUtils.checkAndExtractLambdaMethod(function)__			if (m != null) {_				_				validateLambdaGenericParameters(m)___				_				final int paramLen = m.getGenericParameterTypes().length - 1___				_				if (paramLen < 0) {_					_					_					validateInputContainsMethod(m, inType)__				}_				else {_					final Type input = (outputTypeArgumentIndex >= 0) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen]__					validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(m.getGenericParameterTypes()[paramLen], outputTypeArgumentIndex) : m.getGenericReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,method,m,function,utils,check,and,extract,lambda,method,function,if,m,null,validate,lambda,generic,parameters,m,final,int,param,len,m,get,generic,parameter,types,length,1,if,param,len,0,validate,input,contains,method,m,in,type,else,final,type,input,output,type,argument,index,0,m,get,generic,parameter,types,param,len,1,m,get,generic,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,m,get,generic,parameter,types,param,len,output,type,argument,index,m,get,generic,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1470775474;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final Method m = FunctionUtils.checkAndExtractLambdaMethod(function)__			if (m != null) {_				_				validateLambdaGenericParameters(m)___				_				final int paramLen = m.getGenericParameterTypes().length - 1___				_				if (paramLen < 0) {_					_					_					validateInputContainsMethod(m, inType)__				}_				else {_					final Type input = (outputTypeArgumentIndex >= 0) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen]__					validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(m.getGenericParameterTypes()[paramLen], outputTypeArgumentIndex) : m.getGenericReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,method,m,function,utils,check,and,extract,lambda,method,function,if,m,null,validate,lambda,generic,parameters,m,final,int,param,len,m,get,generic,parameter,types,length,1,if,param,len,0,validate,input,contains,method,m,in,type,else,final,type,input,output,type,argument,index,0,m,get,generic,parameter,types,param,len,1,m,get,generic,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,m,get,generic,parameter,types,param,len,output,type,argument,index,m,get,generic,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1474459924;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final Method m = FunctionUtils.checkAndExtractLambdaMethod(function)__			if (m != null) {_				_				validateLambdaGenericParameters(m)___				_				final int paramLen = m.getGenericParameterTypes().length - 1___				_				if (paramLen < 0) {_					_					_					validateInputContainsMethod(m, inType)__				}_				else {_					final Type input = (outputTypeArgumentIndex >= 0) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen]__					validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(m.getGenericParameterTypes()[paramLen], outputTypeArgumentIndex) : m.getGenericReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,method,m,function,utils,check,and,extract,lambda,method,function,if,m,null,validate,lambda,generic,parameters,m,final,int,param,len,m,get,generic,parameter,types,length,1,if,param,len,0,validate,input,contains,method,m,in,type,else,final,type,input,output,type,argument,index,0,m,get,generic,parameter,types,param,len,1,m,get,generic,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,m,get,generic,parameter,types,param,len,output,type,argument,index,m,get,generic,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1476262965;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)___				_				final int paramLen = exec.getParameterTypes().length - 1___				_				if (paramLen < 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__					validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1479218219;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)___				_				final int paramLen = exec.getParameterTypes().length - 1___				_				if (paramLen < 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__					validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1480354098;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)___				_				final int paramLen = exec.getParameterTypes().length - 1___				_				if (paramLen < 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__					validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1484056358;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)___				_				final int paramLen = exec.getParameterTypes().length - 1___				_				if (paramLen < 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__					validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1484078188;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)___				_				final int paramLen = exec.getParameterTypes().length - 1___				_				if (paramLen < 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__					validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1484924697;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)___				_				final int paramLen = exec.getParameterTypes().length - 1___				_				if (paramLen < 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__					validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1485118420;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)___				_				final int paramLen = exec.getParameterTypes().length - 1___				_				if (paramLen < 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__					validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1494349925;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)___				_				final int paramLen = exec.getParameterTypes().length - 1___				_				if (paramLen < 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__					validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1494363409;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)___				_				final int paramLen = exec.getParameterTypes().length - 1___				_				if (paramLen < 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__					validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1494598316;Returns the unary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of function's second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)___				_				final int paramLen = exec.getParameterTypes().length - 1___				_				if (paramLen < 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__					validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input, inputTypeArgumentIndex) : input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					inType,_					null)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,function,s,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input,input,type,argument,index,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in,type,null,else,validate,input,type,base,class,function,get,class,0,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,1,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1474459924;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1476262965;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1479218219;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1480354098;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1484056358;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1484078188;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1484924697;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1485118420;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1494349925;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1494363409;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1494598316;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1496911361;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1509723634;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1509723634;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1511902791;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1515177485;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1517320791;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1528874321;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> @SuppressWarnings("unchecked") 	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory( 			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1532066767;Creates type information using a factory if for this type or super types. Returns null otherwise.;@SuppressWarnings("unchecked")_	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoFromFactory(_			Type t, ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {__		final ArrayList<Type> factoryHierarchy = new ArrayList<>(typeHierarchy)__		final TypeInfoFactory<? super OUT> factory = getClosestFactory(factoryHierarchy, t)__		if (factory == null) {_			return null__		}_		final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)___		_		final Map<String, TypeInformation<?>> genericParams__		if (factoryDefiningType instanceof ParameterizedType) {_			genericParams = new HashMap<>()__			final ParameterizedType paramDefiningType = (ParameterizedType) factoryDefiningType__			final Type[] args = typeToClass(paramDefiningType).getTypeParameters()___			final TypeInformation<?>[] subtypeInfo = createSubTypesInfo(t, paramDefiningType, factoryHierarchy, in1Type, in2Type, true)__			assert subtypeInfo != null__			for (int i = 0_ i < subtypeInfo.length_ i++) {_				genericParams.put(args[i].toString(), subtypeInfo[i])__			}_		} else {_			genericParams = Collections.emptyMap()__		}__		final TypeInformation<OUT> createdTypeInfo = (TypeInformation<OUT>) factory.createTypeInfo(t, genericParams)__		if (createdTypeInfo == null) {_			throw new InvalidTypesException("TypeInfoFactory returned invalid TypeInformation 'null'")__		}_		return createdTypeInfo__	};creates,type,information,using,a,factory,if,for,this,type,or,super,types,returns,null,otherwise;suppress,warnings,unchecked,private,in1,in2,out,type,information,out,create,type,info,from,factory,type,t,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,final,array,list,type,factory,hierarchy,new,array,list,type,hierarchy,final,type,info,factory,super,out,factory,get,closest,factory,factory,hierarchy,t,if,factory,null,return,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,final,map,string,type,information,generic,params,if,factory,defining,type,instanceof,parameterized,type,generic,params,new,hash,map,final,parameterized,type,param,defining,type,parameterized,type,factory,defining,type,final,type,args,type,to,class,param,defining,type,get,type,parameters,final,type,information,subtype,info,create,sub,types,info,t,param,defining,type,factory,hierarchy,in1type,in2type,true,assert,subtype,info,null,for,int,i,0,i,subtype,info,length,i,generic,params,put,args,i,to,string,subtype,info,i,else,generic,params,collections,empty,map,final,type,information,out,created,type,info,type,information,out,factory,create,type,info,t,generic,params,if,created,type,info,null,throw,new,invalid,types,exception,type,info,factory,returned,invalid,type,information,null,return,created,type,info
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1459358321;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1460741894;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1463093178;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1463730991;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1465391830;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1470647505;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1470775474;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1474459924;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1476262965;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1479218219;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1480354098;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1484056358;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1484078188;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1484924697;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1485118420;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1494349925;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1494363409;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1494598316;* This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;private static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if(t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_					index + " because the type has only " + actualTypeArguments.length +_					" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;private,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1479218219;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass__			_			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)__			_			_			_			tupleBaseClass = (ParameterizedType) inType__			_			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType))__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1480354098;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass__			_			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)__			_			_			_			tupleBaseClass = (ParameterizedType) inType__			_			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType))__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1484056358;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass__			_			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)__			_			_			_			tupleBaseClass = (ParameterizedType) inType__			_			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType))__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1484078188;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass__			_			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)__			_			_			_			tupleBaseClass = (ParameterizedType) inType__			_			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType))__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1484924697;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass__			_			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)__			_			_			_			tupleBaseClass = (ParameterizedType) inType__			_			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType), false)__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,false,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1485118420;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass__			_			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)__			_			_			_			tupleBaseClass = (ParameterizedType) inType__			_			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType), false)__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,false,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1494349925;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass__			_			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)__			_			_			_			tupleBaseClass = (ParameterizedType) inType__			_			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType), false)__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,false,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1494363409;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass__			_			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)__			_			_			_			tupleBaseClass = (ParameterizedType) inType__			_			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType), false)__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,false,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1494598316;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass__			_			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)__			_			_			_			tupleBaseClass = (ParameterizedType) inType__			_			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType), false)__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,false,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1496911361;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass___			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)___			_			_			tupleBaseClass = (ParameterizedType) inType___			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType), false)__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,false,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1509723634;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass___			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)___			_			_			tupleBaseClass = (ParameterizedType) inType___			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType), false)__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,false,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1509723634;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass___			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)___			_			_			tupleBaseClass = (ParameterizedType) inType___			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType), false)__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,false,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1511902791;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass___			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)___			_			_			tupleBaseClass = (ParameterizedType) inType___			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType), false)__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,false,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1515177485;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass___			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)___			_			_			tupleBaseClass = (ParameterizedType) inType___			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType), false)__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,false,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1517320791;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass___			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)___			_			_			tupleBaseClass = (ParameterizedType) inType___			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType), false)__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,false,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1528874321;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass___			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)___			_			_			tupleBaseClass = (ParameterizedType) inType___			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType), false)__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,false,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> @SuppressWarnings({"unchecked", "rawtypes"}) 	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo);1532066767;Finds the type information to a type variable.__It solve the following:__Return the type information for "returnTypeVar" given that "inType" has type information "inTypeInfo"._Thus "inType" must contain "returnTypeVar" in a "inputTypeHierarchy", otherwise null is returned.;@SuppressWarnings({"unchecked", "rawtypes"})_	private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> inputTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {_		TypeInformation<?> info = null___		_		final ArrayList<Type> factoryHierarchy = new ArrayList<>(inputTypeHierarchy)__		final TypeInfoFactory<?> factory = getClosestFactory(factoryHierarchy, inType)__		if (factory != null) {_			_			final Type factoryDefiningType = factoryHierarchy.get(factoryHierarchy.size() - 1)__			_			if (factoryDefiningType instanceof ParameterizedType) {_				final Type[] typeParams = typeToClass(factoryDefiningType).getTypeParameters()__				final Type[] actualParams = ((ParameterizedType) factoryDefiningType).getActualTypeArguments()__				_				for (int i = 0_ i < actualParams.length_ i++) {_					final Map<String, TypeInformation<?>> componentInfo = inTypeInfo.getGenericParameters()__					final String typeParamName = typeParams[i].toString()__					if (!componentInfo.containsKey(typeParamName) || componentInfo.get(typeParamName) == null) {_						throw new InvalidTypesException("TypeInformation '" + inTypeInfo.getClass().getSimpleName() +_							"' does not supply a mapping of TypeVariable '" + typeParamName + "' to corresponding TypeInformation. " +_							"Input type inference can only produce a result with this information. " +_							"Please implement method 'TypeInformation.getGenericParameters()' for this.")__					}_					info = createTypeInfoFromInput(returnTypeVar, factoryHierarchy, actualParams[i], componentInfo.get(typeParamName))__					if (info != null) {_						break__					}_				}_			}_		}_		_		else if (sameTypeVars(inType, returnTypeVar)) {_			return inTypeInfo__		}_		else if (inType instanceof TypeVariable) {_			Type resolvedInType = materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) inType)__			if (resolvedInType != inType) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, resolvedInType, inTypeInfo)__			}_		}_		_		else if (inType instanceof GenericArrayType) {_			TypeInformation<?> componentInfo = null__			if (inTypeInfo instanceof BasicArrayTypeInfo) {_				componentInfo = ((BasicArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			else if (inTypeInfo instanceof PrimitiveArrayTypeInfo) {_				componentInfo = BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType())__			}_			else if (inTypeInfo instanceof ObjectArrayTypeInfo) {_				componentInfo = ((ObjectArrayTypeInfo<?,?>) inTypeInfo).getComponentInfo()__			}_			info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((GenericArrayType) inType).getGenericComponentType(), componentInfo)__		}_		_		else if (inTypeInfo instanceof TupleTypeInfo && isClassType(inType) && Tuple.class.isAssignableFrom(typeToClass(inType))) {_			ParameterizedType tupleBaseClass___			_			while (!(isClassType(inType) && typeToClass(inType).getSuperclass().equals(Tuple.class))) {_				inputTypeHierarchy.add(inType)__				inType = typeToClass(inType).getGenericSuperclass()__			}_			inputTypeHierarchy.add(inType)___			_			_			tupleBaseClass = (ParameterizedType) inType___			Type[] tupleElements = tupleBaseClass.getActualTypeArguments()__			_			for (int i = 0_ i < tupleElements.length_ i++) {_				info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i))__				if(info != null) {_					break__				}_			}_		}_		_		else if (inTypeInfo instanceof PojoTypeInfo && isClassType(inType)) {_			_			getTypeHierarchy(inputTypeHierarchy, inType, Object.class)__			_			List<Field> fields = getAllDeclaredFields(typeToClass(inType), false)__			for (Field field : fields) {_				Type fieldType = field.getGenericType()__				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {_					return getTypeOfPojoField(inTypeInfo, field)__				}_				else if (fieldType instanceof ParameterizedType || fieldType instanceof GenericArrayType) {_					ArrayList<Type> typeHierarchyWithFieldType = new ArrayList<>(inputTypeHierarchy)__					typeHierarchyWithFieldType.add(fieldType)__					TypeInformation<?> foundInfo = createTypeInfoFromInput(returnTypeVar, typeHierarchyWithFieldType, fieldType, getTypeOfPojoField(inTypeInfo, field))__					if (foundInfo != null) {_						return foundInfo__					}_				}_			}_		}_		return info__	};finds,the,type,information,to,a,type,variable,it,solve,the,following,return,the,type,information,for,return,type,var,given,that,in,type,has,type,information,in,type,info,thus,in,type,must,contain,return,type,var,in,a,input,type,hierarchy,otherwise,null,is,returned;suppress,warnings,unchecked,rawtypes,private,in1,type,information,create,type,info,from,input,type,variable,return,type,var,array,list,type,input,type,hierarchy,type,in,type,type,information,in1,in,type,info,type,information,info,null,final,array,list,type,factory,hierarchy,new,array,list,input,type,hierarchy,final,type,info,factory,factory,get,closest,factory,factory,hierarchy,in,type,if,factory,null,final,type,factory,defining,type,factory,hierarchy,get,factory,hierarchy,size,1,if,factory,defining,type,instanceof,parameterized,type,final,type,type,params,type,to,class,factory,defining,type,get,type,parameters,final,type,actual,params,parameterized,type,factory,defining,type,get,actual,type,arguments,for,int,i,0,i,actual,params,length,i,final,map,string,type,information,component,info,in,type,info,get,generic,parameters,final,string,type,param,name,type,params,i,to,string,if,component,info,contains,key,type,param,name,component,info,get,type,param,name,null,throw,new,invalid,types,exception,type,information,in,type,info,get,class,get,simple,name,does,not,supply,a,mapping,of,type,variable,type,param,name,to,corresponding,type,information,input,type,inference,can,only,produce,a,result,with,this,information,please,implement,method,type,information,get,generic,parameters,for,this,info,create,type,info,from,input,return,type,var,factory,hierarchy,actual,params,i,component,info,get,type,param,name,if,info,null,break,else,if,same,type,vars,in,type,return,type,var,return,in,type,info,else,if,in,type,instanceof,type,variable,type,resolved,in,type,materialize,type,variable,input,type,hierarchy,type,variable,in,type,if,resolved,in,type,in,type,info,create,type,info,from,input,return,type,var,input,type,hierarchy,resolved,in,type,in,type,info,else,if,in,type,instanceof,generic,array,type,type,information,component,info,null,if,in,type,info,instanceof,basic,array,type,info,component,info,basic,array,type,info,in,type,info,get,component,info,else,if,in,type,info,instanceof,primitive,array,type,info,component,info,basic,type,info,get,info,for,in,type,info,get,type,class,get,component,type,else,if,in,type,info,instanceof,object,array,type,info,component,info,object,array,type,info,in,type,info,get,component,info,info,create,type,info,from,input,return,type,var,input,type,hierarchy,generic,array,type,in,type,get,generic,component,type,component,info,else,if,in,type,info,instanceof,tuple,type,info,is,class,type,in,type,tuple,class,is,assignable,from,type,to,class,in,type,parameterized,type,tuple,base,class,while,is,class,type,in,type,type,to,class,in,type,get,superclass,equals,tuple,class,input,type,hierarchy,add,in,type,in,type,type,to,class,in,type,get,generic,superclass,input,type,hierarchy,add,in,type,tuple,base,class,parameterized,type,in,type,type,tuple,elements,tuple,base,class,get,actual,type,arguments,for,int,i,0,i,tuple,elements,length,i,info,create,type,info,from,input,return,type,var,input,type,hierarchy,tuple,elements,i,tuple,type,info,in,type,info,get,type,at,i,if,info,null,break,else,if,in,type,info,instanceof,pojo,type,info,is,class,type,in,type,get,type,hierarchy,input,type,hierarchy,in,type,object,class,list,field,fields,get,all,declared,fields,type,to,class,in,type,false,for,field,field,fields,type,field,type,field,get,generic,type,if,field,type,instanceof,type,variable,same,type,vars,return,type,var,materialize,type,variable,input,type,hierarchy,type,variable,field,type,return,get,type,of,pojo,field,in,type,info,field,else,if,field,type,instanceof,parameterized,type,field,type,instanceof,generic,array,type,array,list,type,type,hierarchy,with,field,type,new,array,list,input,type,hierarchy,type,hierarchy,with,field,type,add,field,type,type,information,found,info,create,type,info,from,input,return,type,var,type,hierarchy,with,field,type,field,type,get,type,of,pojo,field,in,type,info,field,if,found,info,null,return,found,info,return,info
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1454428544;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1454679829;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1455101486;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1457121513;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1458651238;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1459358321;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1460741894;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1463093178;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1463730991;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1465391830;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1470647505;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1470775474;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1474459924;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1476262965;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1479218219;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1480354098;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1484056358;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1484078188;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1484924697;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1485118420;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					if(hasGetter) {_						throw new IllegalStateException("Detected more than one getter")__					}_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					if(hasSetter) {_						throw new IllegalStateException("Detected more than one setter")__					}_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.debug(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.debug(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,if,has,getter,throw,new,illegal,state,exception,detected,more,than,one,getter,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,if,has,setter,throw,new,illegal,state,exception,detected,more,than,one,setter,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,debug,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,debug,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1494349925;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.info(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.info(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,info,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,info,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1494363409;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.info(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.info(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,info,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,info,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1494598316;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.info(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.info(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,info,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,info,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1496911361;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.info(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.info(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,info,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,info,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1509723634;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.info(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.info(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,info,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,info,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1509723634;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.info(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.info(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,info,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,info,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1511902791;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.info(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.info(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,info,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,info,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1515177485;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.info(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.info(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,info,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,info,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1517320791;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.info(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.info(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,info,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,info,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1528874321;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.info(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.info(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,info,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,info,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy);1532066767;Checks if the given field is a valid pojo field:_- it is public__- there are getter and setter methods for the field.__@param f field to check_@param clazz class of field_@param typeHierarchy type hierarchy for materializing generic types;private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {_		if(Modifier.isPublic(f.getModifiers())) {_			return true__		} else {_			boolean hasGetter = false, hasSetter = false__			final String fieldNameLow = f.getName().toLowerCase().replaceAll("_", "")___			Type fieldType = f.getGenericType()__			Class<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType())___			TypeVariable<?> fieldTypeGeneric = null__			if(fieldType instanceof TypeVariable) {_				fieldTypeGeneric = (TypeVariable<?>) fieldType__				fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType)__			}_			for(Method m : clazz.getMethods()) {_				final String methodNameLow = m.getName().endsWith("_$eq") ?_						m.getName().toLowerCase().replaceAll("_", "").replaceFirst("\\$eq$", "_\\$eq") :_						m.getName().toLowerCase().replaceAll("_", "")___				_				if(	_					(methodNameLow.equals("get"+fieldNameLow) || methodNameLow.equals("is"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&_					_					m.getParameterTypes().length == 0 &&_					_					(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )_				) {_					hasGetter = true__				}_				_				if((methodNameLow.equals("set"+fieldNameLow) || methodNameLow.equals(fieldNameLow+"_$eq")) &&_					m.getParameterTypes().length == 1 && _					(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&_					_					m.getReturnType().equals(Void.TYPE)_				) {_					hasSetter = true__				}_			}_			if(hasGetter && hasSetter) {_				return true__			} else {_				if(!hasGetter) {_					LOG.info(clazz+" does not contain a getter for field "+f.getName() )__				}_				if(!hasSetter) {_					LOG.info(clazz+" does not contain a setter for field "+f.getName() )__				}_				return false__			}_		}_	};checks,if,the,given,field,is,a,valid,pojo,field,it,is,public,there,are,getter,and,setter,methods,for,the,field,param,f,field,to,check,param,clazz,class,of,field,param,type,hierarchy,type,hierarchy,for,materializing,generic,types;private,boolean,is,valid,pojo,field,field,f,class,clazz,array,list,type,type,hierarchy,if,modifier,is,public,f,get,modifiers,return,true,else,boolean,has,getter,false,has,setter,false,final,string,field,name,low,f,get,name,to,lower,case,replace,all,type,field,type,f,get,generic,type,class,field,type,wrapper,class,utils,primitive,to,wrapper,f,get,type,type,variable,field,type,generic,null,if,field,type,instanceof,type,variable,field,type,generic,type,variable,field,type,field,type,materialize,type,variable,type,hierarchy,type,variable,field,type,for,method,m,clazz,get,methods,final,string,method,name,low,m,get,name,ends,with,eq,m,get,name,to,lower,case,replace,all,replace,first,eq,eq,m,get,name,to,lower,case,replace,all,if,method,name,low,equals,get,field,name,low,method,name,low,equals,is,field,name,low,method,name,low,equals,field,name,low,m,get,parameter,types,length,0,m,get,generic,return,type,equals,field,type,field,type,wrapper,null,m,get,return,type,equals,field,type,wrapper,field,type,generic,null,m,get,generic,return,type,equals,field,type,generic,has,getter,true,if,method,name,low,equals,set,field,name,low,method,name,low,equals,field,name,low,eq,m,get,parameter,types,length,1,m,get,generic,parameter,types,0,equals,field,type,field,type,wrapper,null,m,get,parameter,types,0,equals,field,type,wrapper,field,type,generic,null,m,get,generic,parameter,types,0,equals,field,type,generic,m,get,return,type,equals,void,type,has,setter,true,if,has,getter,has,setter,return,true,else,if,has,getter,log,info,clazz,does,not,contain,a,getter,for,field,f,get,name,if,has,setter,log,info,clazz,does,not,contain,a,setter,for,field,f,get,name,return,false
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType);1494363409;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType)_	{_		return getFoldReturnTypes(foldInterface, inType, null, false)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,return,get,fold,return,types,fold,interface,in,type,null,false
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType);1494598316;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType)_	{_		return getFoldReturnTypes(foldInterface, inType, null, false)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,return,get,fold,return,types,fold,interface,in,type,null,false
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType);1496911361;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType)_	{_		return getFoldReturnTypes(foldInterface, inType, null, false)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,return,get,fold,return,types,fold,interface,in,type,null,false
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType);1509723634;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType)_	{_		return getFoldReturnTypes(foldInterface, inType, null, false)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,return,get,fold,return,types,fold,interface,in,type,null,false
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType);1509723634;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType)_	{_		return getFoldReturnTypes(foldInterface, inType, null, false)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,return,get,fold,return,types,fold,interface,in,type,null,false
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType);1511902791;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType)_	{_		return getFoldReturnTypes(foldInterface, inType, null, false)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,return,get,fold,return,types,fold,interface,in,type,null,false
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType);1515177485;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType)_	{_		return getFoldReturnTypes(foldInterface, inType, null, false)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,return,get,fold,return,types,fold,interface,in,type,null,false
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType);1517320791;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType)_	{_		return getFoldReturnTypes(foldInterface, inType, null, false)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,return,get,fold,return,types,fold,interface,in,type,null,false
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType);1528874321;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType)_	{_		return getFoldReturnTypes(foldInterface, inType, null, false)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,return,get,fold,return,types,fold,interface,in,type,null,false
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType);1532066767;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType)_	{_		return getFoldReturnTypes(foldInterface, inType, null, false)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,return,get,fold,return,types,fold,interface,in,type,null,false
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1474459924;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX or Either).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,or,either,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1476262965;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX or Either).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,or,either,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1479218219;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX or Either).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,or,either,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1480354098;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX or Either).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,or,either,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1484056358;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1484078188;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1484924697;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1485118420;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1494349925;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1494363409;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1494598316;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1496911361;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1509723634;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1509723634;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1511902791;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1515177485;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1517320791;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1528874321;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient);1532066767;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@param lenient decides whether exceptions should be thrown if a subtype can not be determined_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type, boolean lenient) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			final Type actualTypeArg = definingType.getActualTypeArguments()[i]__			_			if (actualTypeArg instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) actualTypeArg)__			}_			_			else {_				subtypes[i] = actualTypeArg__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			final ArrayList<Type> subTypeHierarchy = new ArrayList<>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null && !lenient) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_						+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_						+ "' could not be determined. This is most likely a type erasure problem. "_						+ "The type extraction currently supports types with generic variables only in cases where "_						+ "all variables in the return type can be deduced from the input type(s). "_						+ "Otherwise the type has to be specified explicitly using type information.")__				}_			} else {_				_				try {_					subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__				} catch (InvalidTypesException e) {_					if (lenient) {_						subTypesInfo[i] = null__					} else {_						throw e__					}_				}_			}_		}__		_		if (!lenient) {_			Class<?> originalTypeAsClass = null__			if (isClassType(originalType)) {_				originalTypeAsClass = typeToClass(originalType)__			}_			checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__			_			_			_			int fieldCount = countFieldsInClass(originalTypeAsClass)__			if(fieldCount > subTypesInfo.length) {_				return null__			}_		}__		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,param,lenient,decides,whether,exceptions,should,be,thrown,if,a,subtype,can,not,be,determined,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,boolean,lenient,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,final,type,actual,type,arg,defining,type,get,actual,type,arguments,i,if,actual,type,arg,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,actual,type,arg,else,subtypes,i,actual,type,arg,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,final,array,list,type,sub,type,hierarchy,new,array,list,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,lenient,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,otherwise,the,type,has,to,be,specified,explicitly,using,type,information,else,try,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,catch,invalid,types,exception,e,if,lenient,sub,types,info,i,null,else,throw,e,if,lenient,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass);1454428544;@param curT : start type_@return Type The immediate child of the top class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass) {_		_		if (typeHierarchy.size() > 0 && typeHierarchy.get(0) == curT && isClassType(curT)) {_			curT = typeToClass(curT).getGenericSuperclass()__		}_		while (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {_			typeHierarchy.add(curT)__			curT = typeToClass(curT).getGenericSuperclass()___			if (curT == null) {_				break__			}_		}_		return curT__	};param,cur,t,start,type,return,type,the,immediate,child,of,the,top,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,cur,t,class,stop,at,class,if,type,hierarchy,size,0,type,hierarchy,get,0,cur,t,is,class,type,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,while,is,class,type,cur,t,type,to,class,cur,t,equals,stop,at,class,type,hierarchy,add,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,if,cur,t,null,break,return,cur,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass);1454679829;@param curT : start type_@return Type The immediate child of the top class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass) {_		_		if (typeHierarchy.size() > 0 && typeHierarchy.get(0) == curT && isClassType(curT)) {_			curT = typeToClass(curT).getGenericSuperclass()__		}_		while (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {_			typeHierarchy.add(curT)__			curT = typeToClass(curT).getGenericSuperclass()___			if (curT == null) {_				break__			}_		}_		return curT__	};param,cur,t,start,type,return,type,the,immediate,child,of,the,top,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,cur,t,class,stop,at,class,if,type,hierarchy,size,0,type,hierarchy,get,0,cur,t,is,class,type,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,while,is,class,type,cur,t,type,to,class,cur,t,equals,stop,at,class,type,hierarchy,add,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,if,cur,t,null,break,return,cur,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass);1455101486;@param curT : start type_@return Type The immediate child of the top class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass) {_		_		if (typeHierarchy.size() > 0 && typeHierarchy.get(0) == curT && isClassType(curT)) {_			curT = typeToClass(curT).getGenericSuperclass()__		}_		while (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {_			typeHierarchy.add(curT)__			curT = typeToClass(curT).getGenericSuperclass()___			if (curT == null) {_				break__			}_		}_		return curT__	};param,cur,t,start,type,return,type,the,immediate,child,of,the,top,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,cur,t,class,stop,at,class,if,type,hierarchy,size,0,type,hierarchy,get,0,cur,t,is,class,type,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,while,is,class,type,cur,t,type,to,class,cur,t,equals,stop,at,class,type,hierarchy,add,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,if,cur,t,null,break,return,cur,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass);1457121513;@param curT : start type_@return Type The immediate child of the top class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass) {_		_		if (typeHierarchy.size() > 0 && typeHierarchy.get(0) == curT && isClassType(curT)) {_			curT = typeToClass(curT).getGenericSuperclass()__		}_		while (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {_			typeHierarchy.add(curT)__			curT = typeToClass(curT).getGenericSuperclass()___			if (curT == null) {_				break__			}_		}_		return curT__	};param,cur,t,start,type,return,type,the,immediate,child,of,the,top,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,cur,t,class,stop,at,class,if,type,hierarchy,size,0,type,hierarchy,get,0,cur,t,is,class,type,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,while,is,class,type,cur,t,type,to,class,cur,t,equals,stop,at,class,type,hierarchy,add,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,if,cur,t,null,break,return,cur,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass);1458651238;@param curT : start type_@return Type The immediate child of the top class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass) {_		_		if (typeHierarchy.size() > 0 && typeHierarchy.get(0) == curT && isClassType(curT)) {_			curT = typeToClass(curT).getGenericSuperclass()__		}_		while (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {_			typeHierarchy.add(curT)__			curT = typeToClass(curT).getGenericSuperclass()___			if (curT == null) {_				break__			}_		}_		return curT__	};param,cur,t,start,type,return,type,the,immediate,child,of,the,top,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,cur,t,class,stop,at,class,if,type,hierarchy,size,0,type,hierarchy,get,0,cur,t,is,class,type,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,while,is,class,type,cur,t,type,to,class,cur,t,equals,stop,at,class,type,hierarchy,add,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,if,cur,t,null,break,return,cur,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass);1459358321;@param curT : start type_@return Type The immediate child of the top class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass) {_		_		if (typeHierarchy.size() > 0 && typeHierarchy.get(0) == curT && isClassType(curT)) {_			curT = typeToClass(curT).getGenericSuperclass()__		}_		while (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {_			typeHierarchy.add(curT)__			curT = typeToClass(curT).getGenericSuperclass()___			if (curT == null) {_				break__			}_		}_		return curT__	};param,cur,t,start,type,return,type,the,immediate,child,of,the,top,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,cur,t,class,stop,at,class,if,type,hierarchy,size,0,type,hierarchy,get,0,cur,t,is,class,type,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,while,is,class,type,cur,t,type,to,class,cur,t,equals,stop,at,class,type,hierarchy,add,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,if,cur,t,null,break,return,cur,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass);1460741894;@param curT : start type_@return Type The immediate child of the top class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass) {_		_		if (typeHierarchy.size() > 0 && typeHierarchy.get(0) == curT && isClassType(curT)) {_			curT = typeToClass(curT).getGenericSuperclass()__		}_		while (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {_			typeHierarchy.add(curT)__			curT = typeToClass(curT).getGenericSuperclass()___			if (curT == null) {_				break__			}_		}_		return curT__	};param,cur,t,start,type,return,type,the,immediate,child,of,the,top,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,cur,t,class,stop,at,class,if,type,hierarchy,size,0,type,hierarchy,get,0,cur,t,is,class,type,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,while,is,class,type,cur,t,type,to,class,cur,t,equals,stop,at,class,type,hierarchy,add,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,if,cur,t,null,break,return,cur,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass);1463093178;@param curT : start type_@return Type The immediate child of the top class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass) {_		_		if (typeHierarchy.size() > 0 && typeHierarchy.get(0) == curT && isClassType(curT)) {_			curT = typeToClass(curT).getGenericSuperclass()__		}_		while (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {_			typeHierarchy.add(curT)__			curT = typeToClass(curT).getGenericSuperclass()___			if (curT == null) {_				break__			}_		}_		return curT__	};param,cur,t,start,type,return,type,the,immediate,child,of,the,top,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,cur,t,class,stop,at,class,if,type,hierarchy,size,0,type,hierarchy,get,0,cur,t,is,class,type,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,while,is,class,type,cur,t,type,to,class,cur,t,equals,stop,at,class,type,hierarchy,add,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,if,cur,t,null,break,return,cur,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass);1463730991;@param curT : start type_@return Type The immediate child of the top class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass) {_		_		if (typeHierarchy.size() > 0 && typeHierarchy.get(0) == curT && isClassType(curT)) {_			curT = typeToClass(curT).getGenericSuperclass()__		}_		while (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {_			typeHierarchy.add(curT)__			curT = typeToClass(curT).getGenericSuperclass()___			if (curT == null) {_				break__			}_		}_		return curT__	};param,cur,t,start,type,return,type,the,immediate,child,of,the,top,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,cur,t,class,stop,at,class,if,type,hierarchy,size,0,type,hierarchy,get,0,cur,t,is,class,type,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,while,is,class,type,cur,t,type,to,class,cur,t,equals,stop,at,class,type,hierarchy,add,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,if,cur,t,null,break,return,cur,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass);1465391830;@param curT : start type_@return Type The immediate child of the top class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass) {_		_		if (typeHierarchy.size() > 0 && typeHierarchy.get(0) == curT && isClassType(curT)) {_			curT = typeToClass(curT).getGenericSuperclass()__		}_		while (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {_			typeHierarchy.add(curT)__			curT = typeToClass(curT).getGenericSuperclass()___			if (curT == null) {_				break__			}_		}_		return curT__	};param,cur,t,start,type,return,type,the,immediate,child,of,the,top,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,cur,t,class,stop,at,class,if,type,hierarchy,size,0,type,hierarchy,get,0,cur,t,is,class,type,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,while,is,class,type,cur,t,type,to,class,cur,t,equals,stop,at,class,type,hierarchy,add,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,if,cur,t,null,break,return,cur,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass);1470647505;@param curT : start type_@return Type The immediate child of the top class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass) {_		_		if (typeHierarchy.size() > 0 && typeHierarchy.get(0) == curT && isClassType(curT)) {_			curT = typeToClass(curT).getGenericSuperclass()__		}_		while (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {_			typeHierarchy.add(curT)__			curT = typeToClass(curT).getGenericSuperclass()___			if (curT == null) {_				break__			}_		}_		return curT__	};param,cur,t,start,type,return,type,the,immediate,child,of,the,top,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,cur,t,class,stop,at,class,if,type,hierarchy,size,0,type,hierarchy,get,0,cur,t,is,class,type,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,while,is,class,type,cur,t,type,to,class,cur,t,equals,stop,at,class,type,hierarchy,add,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,if,cur,t,null,break,return,cur,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass);1470775474;@param curT : start type_@return Type The immediate child of the top class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, Class<?> stopAtClass) {_		_		if (typeHierarchy.size() > 0 && typeHierarchy.get(0) == curT && isClassType(curT)) {_			curT = typeToClass(curT).getGenericSuperclass()__		}_		while (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {_			typeHierarchy.add(curT)__			curT = typeToClass(curT).getGenericSuperclass()___			if (curT == null) {_				break__			}_		}_		return curT__	};param,cur,t,start,type,return,type,the,immediate,child,of,the,top,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,cur,t,class,stop,at,class,if,type,hierarchy,size,0,type,hierarchy,get,0,cur,t,is,class,type,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,while,is,class,type,cur,t,type,to,class,cur,t,equals,stop,at,class,type,hierarchy,add,cur,t,cur,t,type,to,class,cur,t,get,generic,superclass,if,cur,t,null,break,return,cur,t
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1455101486;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1457121513;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1458651238;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1459358321;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1460741894;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1463093178;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1463730991;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1465391830;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1470647505;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1470775474;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1474459924;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1476262965;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1479218219;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1480354098;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1484056358;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1484078188;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1484924697;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1485118420;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1494349925;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1494363409;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1494598316;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1496911361;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1509723634;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1509723634;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1511902791;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1515177485;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1517320791;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1528874321;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos);1532066767;Creates a {@link TypeInformation} from the given parameters.__If the given {@code instance} implements {@link ResultTypeQueryable}, its information_is used to determine the type information. Otherwise, the type information is derived_based on the given class information.__@param instance			instance to determine type information for_@param baseClass			base class of {@code instance}_@param clazz				class of {@code instance}_@param returnParamPos	index of the return type in the type arguments of {@code clazz}_@param <OUT>				output type_@return type information;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {_		if (instance instanceof ResultTypeQueryable) {_			return ((ResultTypeQueryable<OUT>) instance).getProducedType()__		} else {_			return createTypeInfo(baseClass, clazz, returnParamPos, null, null)__		}_	};creates,a,link,type,information,from,the,given,parameters,if,the,given,code,instance,implements,link,result,type,queryable,its,information,is,used,to,determine,the,type,information,otherwise,the,type,information,is,derived,based,on,the,given,class,information,param,instance,instance,to,determine,type,information,for,param,base,class,base,class,of,code,instance,param,clazz,class,of,code,instance,param,return,param,pos,index,of,the,return,type,in,the,type,arguments,of,code,clazz,param,out,output,type,return,type,information;suppress,warnings,unchecked,public,evolving,public,static,out,type,information,out,create,type,info,object,instance,class,base,class,class,clazz,int,return,param,pos,if,instance,instanceof,result,type,queryable,return,result,type,queryable,out,instance,get,produced,type,else,return,create,type,info,base,class,clazz,return,param,pos,null,null
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing);1494363409;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing)_	{_		return getUnaryOperatorReturnType((Function) foldInterface, FoldFunction.class, false, false, inType, functionName, allowMissing)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,fold,interface,fold,function,class,false,false,in,type,function,name,allow,missing
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing);1494598316;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing)_	{_		return getUnaryOperatorReturnType((Function) foldInterface, FoldFunction.class, false, false, inType, functionName, allowMissing)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,fold,interface,fold,function,class,false,false,in,type,function,name,allow,missing
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing);1496911361;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing)_	{_		return getUnaryOperatorReturnType(_			(Function) foldInterface,_			FoldFunction.class,_			0,_			1,_			new int[]{1},_			NO_INDEX,_			inType,_			functionName,_			allowMissing)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,fold,interface,fold,function,class,0,1,new,int,1,in,type,function,name,allow,missing
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing);1509723634;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing)_	{_		return getUnaryOperatorReturnType(_			(Function) foldInterface,_			FoldFunction.class,_			0,_			1,_			new int[]{1},_			NO_INDEX,_			inType,_			functionName,_			allowMissing)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,fold,interface,fold,function,class,0,1,new,int,1,in,type,function,name,allow,missing
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing);1509723634;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing)_	{_		return getUnaryOperatorReturnType(_			(Function) foldInterface,_			FoldFunction.class,_			0,_			1,_			new int[]{1},_			NO_INDEX,_			inType,_			functionName,_			allowMissing)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,fold,interface,fold,function,class,0,1,new,int,1,in,type,function,name,allow,missing
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing);1511902791;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing)_	{_		return getUnaryOperatorReturnType(_			(Function) foldInterface,_			FoldFunction.class,_			0,_			1,_			new int[]{1},_			NO_INDEX,_			inType,_			functionName,_			allowMissing)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,fold,interface,fold,function,class,0,1,new,int,1,in,type,function,name,allow,missing
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing);1515177485;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing)_	{_		return getUnaryOperatorReturnType(_			(Function) foldInterface,_			FoldFunction.class,_			0,_			1,_			new int[]{1},_			NO_INDEX,_			inType,_			functionName,_			allowMissing)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,fold,interface,fold,function,class,0,1,new,int,1,in,type,function,name,allow,missing
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing);1517320791;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing)_	{_		return getUnaryOperatorReturnType(_			(Function) foldInterface,_			FoldFunction.class,_			0,_			1,_			new int[]{1},_			NO_INDEX,_			inType,_			functionName,_			allowMissing)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,fold,interface,fold,function,class,0,1,new,int,1,in,type,function,name,allow,missing
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing);1528874321;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing)_	{_		return getUnaryOperatorReturnType(_			(Function) foldInterface,_			FoldFunction.class,_			0,_			1,_			new int[]{1},_			NO_INDEX,_			inType,_			functionName,_			allowMissing)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,fold,interface,fold,function,class,0,1,new,int,1,in,type,function,name,allow,missing
TypeExtractor -> @PublicEvolving 	@Deprecated 	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing);1532066767;@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	public static <IN, OUT> TypeInformation<OUT> getFoldReturnTypes(FoldFunction<IN, OUT> foldInterface, TypeInformation<IN> inType, String functionName, boolean allowMissing)_	{_		return getUnaryOperatorReturnType(_			(Function) foldInterface,_			FoldFunction.class,_			0,_			1,_			NO_INDEX,_			inType,_			functionName,_			allowMissing)__	};deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,public,static,in,out,type,information,out,get,fold,return,types,fold,function,in,out,fold,interface,type,information,in,in,type,string,function,name,boolean,allow,missing,return,get,unary,operator,return,type,function,fold,interface,fold,function,class,0,1,in,type,function,name,allow,missing
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1454428544;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		return new TypeExtractor().privateGetForClass(clazz, new ArrayList<Type>())__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,return,new,type,extractor,private,get,for,class,clazz,new,array,list,type
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1454679829;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		return new TypeExtractor().privateGetForClass(clazz, new ArrayList<Type>())__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,return,new,type,extractor,private,get,for,class,clazz,new,array,list,type
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1455101486;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		return new TypeExtractor().privateGetForClass(clazz, new ArrayList<Type>())__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,return,new,type,extractor,private,get,for,class,clazz,new,array,list,type
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1457121513;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		return new TypeExtractor().privateGetForClass(clazz, new ArrayList<Type>())__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,return,new,type,extractor,private,get,for,class,clazz,new,array,list,type
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1458651238;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		return new TypeExtractor().privateGetForClass(clazz, new ArrayList<Type>())__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,return,new,type,extractor,private,get,for,class,clazz,new,array,list,type
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1459358321;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		return new TypeExtractor().privateGetForClass(clazz, new ArrayList<Type>())__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,return,new,type,extractor,private,get,for,class,clazz,new,array,list,type
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1460741894;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		return new TypeExtractor().privateGetForClass(clazz, new ArrayList<Type>())__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,return,new,type,extractor,private,get,for,class,clazz,new,array,list,type
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1463093178;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		return new TypeExtractor().privateGetForClass(clazz, new ArrayList<Type>())__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,return,new,type,extractor,private,get,for,class,clazz,new,array,list,type
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1463730991;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		return new TypeExtractor().privateGetForClass(clazz, new ArrayList<Type>())__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,return,new,type,extractor,private,get,for,class,clazz,new,array,list,type
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1465391830;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		return new TypeExtractor().privateGetForClass(clazz, new ArrayList<Type>())__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,return,new,type,extractor,private,get,for,class,clazz,new,array,list,type
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1470647505;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		return new TypeExtractor().privateGetForClass(clazz, new ArrayList<Type>())__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,return,new,type,extractor,private,get,for,class,clazz,new,array,list,type
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1470775474;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		return new TypeExtractor().privateGetForClass(clazz, new ArrayList<Type>())__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,return,new,type,extractor,private,get,for,class,clazz,new,array,list,type
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1474459924;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1476262965;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1479218219;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1480354098;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1484056358;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1484078188;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1484924697;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1485118420;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1494349925;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1494363409;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1494598316;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1496911361;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1509723634;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1509723634;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1511902791;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1515177485;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1517320791;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1528874321;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> public static <X> TypeInformation<X> getForClass(Class<X> clazz);1532066767;Creates type information from a given Class such as Integer, String[] or POJOs.__This method does not support ParameterizedTypes such as Tuples or complex type hierarchies._In most cases {@link TypeExtractor#createTypeInfo(Type)} is the recommended method for type extraction_(a Class is a child of Type).__@param clazz a Class to create TypeInformation for_@return TypeInformation that describes the passed Class;public static <X> TypeInformation<X> getForClass(Class<X> clazz) {_		final ArrayList<Type> typeHierarchy = new ArrayList<>()__		typeHierarchy.add(clazz)__		return new TypeExtractor().privateGetForClass(clazz, typeHierarchy)__	};creates,type,information,from,a,given,class,such,as,integer,string,or,pojos,this,method,does,not,support,parameterized,types,such,as,tuples,or,complex,type,hierarchies,in,most,cases,link,type,extractor,create,type,info,type,is,the,recommended,method,for,type,extraction,a,class,is,a,child,of,type,param,clazz,a,class,to,create,type,information,for,return,type,information,that,describes,the,passed,class;public,static,x,type,information,x,get,for,class,class,x,clazz,final,array,list,type,type,hierarchy,new,array,list,type,hierarchy,add,clazz,return,new,type,extractor,private,get,for,class,clazz,type,hierarchy
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1474459924;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1476262965;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1479218219;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1480354098;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1484056358;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1484078188;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1484924697;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1485118420;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1494349925;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1494363409;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1494598316;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1496911361;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1509723634;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1509723634;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1511902791;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1515177485;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1517320791;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1528874321;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @Internal 	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t);1532066767;Returns the type information factory for a type using the factory registry or annotations.;@Internal_	public static <OUT> TypeInfoFactory<OUT> getTypeInfoFactory(Type t) {_		final Class<?> factoryClass__		if (registeredTypeInfoFactories.containsKey(t)) {_			factoryClass = registeredTypeInfoFactories.get(t)__		}_		else {_			if (!isClassType(t) || !typeToClass(t).isAnnotationPresent(TypeInfo.class)) {_				return null__			}_			final TypeInfo typeInfoAnnotation = typeToClass(t).getAnnotation(TypeInfo.class)__			factoryClass = typeInfoAnnotation.value()__			_			if (!TypeInfoFactory.class.isAssignableFrom(factoryClass)) {_				throw new InvalidTypesException("TypeInfo annotation does not specify a valid TypeInfoFactory.")__			}_		}__		_		return (TypeInfoFactory<OUT>) InstantiationUtil.instantiate(factoryClass)__	};returns,the,type,information,factory,for,a,type,using,the,factory,registry,or,annotations;internal,public,static,out,type,info,factory,out,get,type,info,factory,type,t,final,class,factory,class,if,registered,type,info,factories,contains,key,t,factory,class,registered,type,info,factories,get,t,else,if,is,class,type,t,type,to,class,t,is,annotation,present,type,info,class,return,null,final,type,info,type,info,annotation,type,to,class,t,get,annotation,type,info,class,factory,class,type,info,annotation,value,if,type,info,factory,class,is,assignable,from,factory,class,throw,new,invalid,types,exception,type,info,annotation,does,not,specify,a,valid,type,info,factory,return,type,info,factory,out,instantiation,util,instantiate,factory,class
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates);1484924697;Recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.__@param clazz class to be analyzed_@param ignoreDuplicates if true, in case of duplicate field names only the lowest one_in a hierarchy will be returned_ throws an exception otherwise_@return list of fields;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					if (ignoreDuplicates) {_						continue__					} else {_						throw new InvalidTypesException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__					}_				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes,param,clazz,class,to,be,analyzed,param,ignore,duplicates,if,true,in,case,of,duplicate,field,names,only,the,lowest,one,in,a,hierarchy,will,be,returned,throws,an,exception,otherwise,return,list,of,fields;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,boolean,ignore,duplicates,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,if,ignore,duplicates,continue,else,throw,new,invalid,types,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates);1485118420;Recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.__@param clazz class to be analyzed_@param ignoreDuplicates if true, in case of duplicate field names only the lowest one_in a hierarchy will be returned_ throws an exception otherwise_@return list of fields;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					if (ignoreDuplicates) {_						continue__					} else {_						throw new InvalidTypesException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__					}_				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes,param,clazz,class,to,be,analyzed,param,ignore,duplicates,if,true,in,case,of,duplicate,field,names,only,the,lowest,one,in,a,hierarchy,will,be,returned,throws,an,exception,otherwise,return,list,of,fields;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,boolean,ignore,duplicates,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,if,ignore,duplicates,continue,else,throw,new,invalid,types,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates);1494349925;Recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.__@param clazz class to be analyzed_@param ignoreDuplicates if true, in case of duplicate field names only the lowest one_in a hierarchy will be returned_ throws an exception otherwise_@return list of fields;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					if (ignoreDuplicates) {_						continue__					} else {_						throw new InvalidTypesException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__					}_				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes,param,clazz,class,to,be,analyzed,param,ignore,duplicates,if,true,in,case,of,duplicate,field,names,only,the,lowest,one,in,a,hierarchy,will,be,returned,throws,an,exception,otherwise,return,list,of,fields;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,boolean,ignore,duplicates,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,if,ignore,duplicates,continue,else,throw,new,invalid,types,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates);1494363409;Recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.__@param clazz class to be analyzed_@param ignoreDuplicates if true, in case of duplicate field names only the lowest one_in a hierarchy will be returned_ throws an exception otherwise_@return list of fields;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					if (ignoreDuplicates) {_						continue__					} else {_						throw new InvalidTypesException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__					}_				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes,param,clazz,class,to,be,analyzed,param,ignore,duplicates,if,true,in,case,of,duplicate,field,names,only,the,lowest,one,in,a,hierarchy,will,be,returned,throws,an,exception,otherwise,return,list,of,fields;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,boolean,ignore,duplicates,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,if,ignore,duplicates,continue,else,throw,new,invalid,types,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates);1494598316;Recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.__@param clazz class to be analyzed_@param ignoreDuplicates if true, in case of duplicate field names only the lowest one_in a hierarchy will be returned_ throws an exception otherwise_@return list of fields;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					if (ignoreDuplicates) {_						continue__					} else {_						throw new InvalidTypesException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__					}_				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes,param,clazz,class,to,be,analyzed,param,ignore,duplicates,if,true,in,case,of,duplicate,field,names,only,the,lowest,one,in,a,hierarchy,will,be,returned,throws,an,exception,otherwise,return,list,of,fields;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,boolean,ignore,duplicates,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,if,ignore,duplicates,continue,else,throw,new,invalid,types,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates);1496911361;Recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.__@param clazz class to be analyzed_@param ignoreDuplicates if true, in case of duplicate field names only the lowest one_in a hierarchy will be returned_ throws an exception otherwise_@return list of fields;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					if (ignoreDuplicates) {_						continue__					} else {_						throw new InvalidTypesException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__					}_				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes,param,clazz,class,to,be,analyzed,param,ignore,duplicates,if,true,in,case,of,duplicate,field,names,only,the,lowest,one,in,a,hierarchy,will,be,returned,throws,an,exception,otherwise,return,list,of,fields;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,boolean,ignore,duplicates,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,if,ignore,duplicates,continue,else,throw,new,invalid,types,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates);1509723634;Recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.__@param clazz class to be analyzed_@param ignoreDuplicates if true, in case of duplicate field names only the lowest one_in a hierarchy will be returned_ throws an exception otherwise_@return list of fields;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					if (ignoreDuplicates) {_						continue__					} else {_						throw new InvalidTypesException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__					}_				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes,param,clazz,class,to,be,analyzed,param,ignore,duplicates,if,true,in,case,of,duplicate,field,names,only,the,lowest,one,in,a,hierarchy,will,be,returned,throws,an,exception,otherwise,return,list,of,fields;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,boolean,ignore,duplicates,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,if,ignore,duplicates,continue,else,throw,new,invalid,types,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates);1509723634;Recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.__@param clazz class to be analyzed_@param ignoreDuplicates if true, in case of duplicate field names only the lowest one_in a hierarchy will be returned_ throws an exception otherwise_@return list of fields;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					if (ignoreDuplicates) {_						continue__					} else {_						throw new InvalidTypesException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__					}_				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes,param,clazz,class,to,be,analyzed,param,ignore,duplicates,if,true,in,case,of,duplicate,field,names,only,the,lowest,one,in,a,hierarchy,will,be,returned,throws,an,exception,otherwise,return,list,of,fields;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,boolean,ignore,duplicates,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,if,ignore,duplicates,continue,else,throw,new,invalid,types,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates);1511902791;Recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.__@param clazz class to be analyzed_@param ignoreDuplicates if true, in case of duplicate field names only the lowest one_in a hierarchy will be returned_ throws an exception otherwise_@return list of fields;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					if (ignoreDuplicates) {_						continue__					} else {_						throw new InvalidTypesException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__					}_				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes,param,clazz,class,to,be,analyzed,param,ignore,duplicates,if,true,in,case,of,duplicate,field,names,only,the,lowest,one,in,a,hierarchy,will,be,returned,throws,an,exception,otherwise,return,list,of,fields;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,boolean,ignore,duplicates,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,if,ignore,duplicates,continue,else,throw,new,invalid,types,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates);1515177485;Recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.__@param clazz class to be analyzed_@param ignoreDuplicates if true, in case of duplicate field names only the lowest one_in a hierarchy will be returned_ throws an exception otherwise_@return list of fields;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					if (ignoreDuplicates) {_						continue__					} else {_						throw new InvalidTypesException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__					}_				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes,param,clazz,class,to,be,analyzed,param,ignore,duplicates,if,true,in,case,of,duplicate,field,names,only,the,lowest,one,in,a,hierarchy,will,be,returned,throws,an,exception,otherwise,return,list,of,fields;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,boolean,ignore,duplicates,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,if,ignore,duplicates,continue,else,throw,new,invalid,types,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates);1517320791;Recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.__@param clazz class to be analyzed_@param ignoreDuplicates if true, in case of duplicate field names only the lowest one_in a hierarchy will be returned_ throws an exception otherwise_@return list of fields;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					if (ignoreDuplicates) {_						continue__					} else {_						throw new InvalidTypesException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__					}_				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes,param,clazz,class,to,be,analyzed,param,ignore,duplicates,if,true,in,case,of,duplicate,field,names,only,the,lowest,one,in,a,hierarchy,will,be,returned,throws,an,exception,otherwise,return,list,of,fields;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,boolean,ignore,duplicates,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,if,ignore,duplicates,continue,else,throw,new,invalid,types,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates);1528874321;Recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.__@param clazz class to be analyzed_@param ignoreDuplicates if true, in case of duplicate field names only the lowest one_in a hierarchy will be returned_ throws an exception otherwise_@return list of fields;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					if (ignoreDuplicates) {_						continue__					} else {_						throw new InvalidTypesException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__					}_				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes,param,clazz,class,to,be,analyzed,param,ignore,duplicates,if,true,in,case,of,duplicate,field,names,only,the,lowest,one,in,a,hierarchy,will,be,returned,throws,an,exception,otherwise,return,list,of,fields;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,boolean,ignore,duplicates,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,if,ignore,duplicates,continue,else,throw,new,invalid,types,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates);1532066767;Recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.__@param clazz class to be analyzed_@param ignoreDuplicates if true, in case of duplicate field names only the lowest one_in a hierarchy will be returned_ throws an exception otherwise_@return list of fields;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					if (ignoreDuplicates) {_						continue__					} else {_						throw new InvalidTypesException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__					}_				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes,param,clazz,class,to,be,analyzed,param,ignore,duplicates,if,true,in,case,of,duplicate,field,names,only,the,lowest,one,in,a,hierarchy,will,be,returned,throws,an,exception,otherwise,return,list,of,fields;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,boolean,ignore,duplicates,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,if,ignore,duplicates,continue,else,throw,new,invalid,types,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1459358321;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final Method m = FunctionUtils.checkAndExtractLambdaMethod(function)__			if (m != null) {_				_				validateLambdaGenericParameters(m)__				_				_				final int paramLen = m.getGenericParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? m.getGenericParameterTypes()[paramLen - 2] : m.getGenericParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(m.getGenericParameterTypes()[paramLen], outputTypeArgumentIndex) : m.getGenericReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,method,m,function,utils,check,and,extract,lambda,method,function,if,m,null,validate,lambda,generic,parameters,m,final,int,param,len,m,get,generic,parameter,types,length,1,final,type,input1,output,type,argument,index,0,m,get,generic,parameter,types,param,len,2,m,get,generic,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,m,get,generic,parameter,types,param,len,1,m,get,generic,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,m,get,generic,parameter,types,param,len,output,type,argument,index,m,get,generic,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1460741894;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final Method m = FunctionUtils.checkAndExtractLambdaMethod(function)__			if (m != null) {_				_				validateLambdaGenericParameters(m)__				_				_				final int paramLen = m.getGenericParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? m.getGenericParameterTypes()[paramLen - 2] : m.getGenericParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(m.getGenericParameterTypes()[paramLen], outputTypeArgumentIndex) : m.getGenericReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,method,m,function,utils,check,and,extract,lambda,method,function,if,m,null,validate,lambda,generic,parameters,m,final,int,param,len,m,get,generic,parameter,types,length,1,final,type,input1,output,type,argument,index,0,m,get,generic,parameter,types,param,len,2,m,get,generic,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,m,get,generic,parameter,types,param,len,1,m,get,generic,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,m,get,generic,parameter,types,param,len,output,type,argument,index,m,get,generic,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1463093178;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final Method m = FunctionUtils.checkAndExtractLambdaMethod(function)__			if (m != null) {_				_				validateLambdaGenericParameters(m)__				_				_				final int paramLen = m.getGenericParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? m.getGenericParameterTypes()[paramLen - 2] : m.getGenericParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(m.getGenericParameterTypes()[paramLen], outputTypeArgumentIndex) : m.getGenericReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,method,m,function,utils,check,and,extract,lambda,method,function,if,m,null,validate,lambda,generic,parameters,m,final,int,param,len,m,get,generic,parameter,types,length,1,final,type,input1,output,type,argument,index,0,m,get,generic,parameter,types,param,len,2,m,get,generic,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,m,get,generic,parameter,types,param,len,1,m,get,generic,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,m,get,generic,parameter,types,param,len,output,type,argument,index,m,get,generic,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1463730991;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final Method m = FunctionUtils.checkAndExtractLambdaMethod(function)__			if (m != null) {_				_				validateLambdaGenericParameters(m)__				_				_				final int paramLen = m.getGenericParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? m.getGenericParameterTypes()[paramLen - 2] : m.getGenericParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(m.getGenericParameterTypes()[paramLen], outputTypeArgumentIndex) : m.getGenericReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,method,m,function,utils,check,and,extract,lambda,method,function,if,m,null,validate,lambda,generic,parameters,m,final,int,param,len,m,get,generic,parameter,types,length,1,final,type,input1,output,type,argument,index,0,m,get,generic,parameter,types,param,len,2,m,get,generic,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,m,get,generic,parameter,types,param,len,1,m,get,generic,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,m,get,generic,parameter,types,param,len,output,type,argument,index,m,get,generic,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1465391830;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final Method m = FunctionUtils.checkAndExtractLambdaMethod(function)__			if (m != null) {_				_				validateLambdaGenericParameters(m)__				_				_				final int paramLen = m.getGenericParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? m.getGenericParameterTypes()[paramLen - 2] : m.getGenericParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(m.getGenericParameterTypes()[paramLen], outputTypeArgumentIndex) : m.getGenericReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,method,m,function,utils,check,and,extract,lambda,method,function,if,m,null,validate,lambda,generic,parameters,m,final,int,param,len,m,get,generic,parameter,types,length,1,final,type,input1,output,type,argument,index,0,m,get,generic,parameter,types,param,len,2,m,get,generic,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,m,get,generic,parameter,types,param,len,1,m,get,generic,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,m,get,generic,parameter,types,param,len,output,type,argument,index,m,get,generic,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1470647505;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final Method m = FunctionUtils.checkAndExtractLambdaMethod(function)__			if (m != null) {_				_				validateLambdaGenericParameters(m)__				_				_				final int paramLen = m.getGenericParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? m.getGenericParameterTypes()[paramLen - 2] : m.getGenericParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(m.getGenericParameterTypes()[paramLen], outputTypeArgumentIndex) : m.getGenericReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,method,m,function,utils,check,and,extract,lambda,method,function,if,m,null,validate,lambda,generic,parameters,m,final,int,param,len,m,get,generic,parameter,types,length,1,final,type,input1,output,type,argument,index,0,m,get,generic,parameter,types,param,len,2,m,get,generic,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,m,get,generic,parameter,types,param,len,1,m,get,generic,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,m,get,generic,parameter,types,param,len,output,type,argument,index,m,get,generic,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1470775474;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final Method m = FunctionUtils.checkAndExtractLambdaMethod(function)__			if (m != null) {_				_				validateLambdaGenericParameters(m)__				_				_				final int paramLen = m.getGenericParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? m.getGenericParameterTypes()[paramLen - 2] : m.getGenericParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(m.getGenericParameterTypes()[paramLen], outputTypeArgumentIndex) : m.getGenericReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,method,m,function,utils,check,and,extract,lambda,method,function,if,m,null,validate,lambda,generic,parameters,m,final,int,param,len,m,get,generic,parameter,types,length,1,final,type,input1,output,type,argument,index,0,m,get,generic,parameter,types,param,len,2,m,get,generic,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,m,get,generic,parameter,types,param,len,1,m,get,generic,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,m,get,generic,parameter,types,param,len,output,type,argument,index,m,get,generic,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1474459924;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final Method m = FunctionUtils.checkAndExtractLambdaMethod(function)__			if (m != null) {_				_				validateLambdaGenericParameters(m)__				_				_				final int paramLen = m.getGenericParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? m.getGenericParameterTypes()[paramLen - 2] : m.getGenericParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(m.getGenericParameterTypes()[paramLen], outputTypeArgumentIndex) : m.getGenericReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,method,m,function,utils,check,and,extract,lambda,method,function,if,m,null,validate,lambda,generic,parameters,m,final,int,param,len,m,get,generic,parameter,types,length,1,final,type,input1,output,type,argument,index,0,m,get,generic,parameter,types,param,len,2,m,get,generic,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,m,get,generic,parameter,types,param,len,1,m,get,generic,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,m,get,generic,parameter,types,param,len,output,type,argument,index,m,get,generic,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1476262965;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)__				_				_				final int paramLen = exec.getParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 2] : exec.getParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,final,type,input1,output,type,argument,index,0,exec,get,parameter,types,param,len,2,exec,get,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1479218219;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)__				_				_				final int paramLen = exec.getParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 2] : exec.getParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,final,type,input1,output,type,argument,index,0,exec,get,parameter,types,param,len,2,exec,get,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1480354098;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)__				_				_				final int paramLen = exec.getParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 2] : exec.getParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,final,type,input1,output,type,argument,index,0,exec,get,parameter,types,param,len,2,exec,get,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1484056358;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)__				_				_				final int paramLen = exec.getParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 2] : exec.getParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,final,type,input1,output,type,argument,index,0,exec,get,parameter,types,param,len,2,exec,get,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1484078188;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)__				_				_				final int paramLen = exec.getParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 2] : exec.getParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,final,type,input1,output,type,argument,index,0,exec,get,parameter,types,param,len,2,exec,get,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1484924697;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)__				_				_				final int paramLen = exec.getParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 2] : exec.getParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,final,type,input1,output,type,argument,index,0,exec,get,parameter,types,param,len,2,exec,get,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1485118420;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)__				_				_				final int paramLen = exec.getParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 2] : exec.getParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,final,type,input1,output,type,argument,index,0,exec,get,parameter,types,param,len,2,exec,get,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1494349925;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)__				_				_				final int paramLen = exec.getParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 2] : exec.getParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,final,type,input1,output,type,argument,index,0,exec,get,parameter,types,param,len,2,exec,get,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1494363409;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)__				_				_				final int paramLen = exec.getParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 2] : exec.getParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,final,type,input1,output,type,argument,index,0,exec,get,parameter,types,param,len,2,exec,get,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1494598316;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of the type argument of function's first parameter_specifying the input type if it is wrapped (Iterable, Map,_etc.). Otherwise -1._@param outputTypeArgumentIndex Index of the type argument of functions second parameter_specifying the output type if it is wrapped in a Collector._Otherwise -1._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				_				validateLambdaGenericParameters(exec)__				_				_				final int paramLen = exec.getParameterTypes().length - 1__				final Type input1 = (outputTypeArgumentIndex >= 0) ? exec.getParameterTypes()[paramLen - 2] : exec.getParameterTypes()[paramLen - 1]__				final Type input2 = (outputTypeArgumentIndex >= 0 ) ? exec.getParameterTypes()[paramLen - 1] : exec.getParameterTypes()[paramLen]__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input1, inputTypeArgumentIndex) : input1, in1Type)__				validateInputType((inputTypeArgumentIndex >= 0) ? extractTypeArgument(input2, inputTypeArgumentIndex) : input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(_					(outputTypeArgumentIndex >= 0) ? extractTypeArgument(exec.getParameterTypes()[paramLen], outputTypeArgumentIndex) : exec.getReturnType(),_					in1Type,_					in2Type)__			}_			else {_				validateInputType(baseClass, function.getClass(), 0, in1Type)__				validateInputType(baseClass, function.getClass(), 1, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,the,type,argument,of,function,s,first,parameter,specifying,the,input,type,if,it,is,wrapped,iterable,map,etc,otherwise,1,param,output,type,argument,index,index,of,the,type,argument,of,functions,second,parameter,specifying,the,output,type,if,it,is,wrapped,in,a,collector,otherwise,1,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,1,final,type,input1,output,type,argument,index,0,exec,get,parameter,types,param,len,2,exec,get,parameter,types,param,len,1,final,type,input2,output,type,argument,index,0,exec,get,parameter,types,param,len,1,exec,get,parameter,types,param,len,validate,input,type,input,type,argument,index,0,extract,type,argument,input1,input,type,argument,index,input1,in1type,validate,input,type,input,type,argument,index,0,extract,type,argument,input2,input,type,argument,index,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,output,type,argument,index,0,extract,type,argument,exec,get,parameter,types,param,len,output,type,argument,index,exec,get,return,type,in1type,in2type,else,validate,input,type,base,class,function,get,class,0,in1type,validate,input,type,base,class,function,get,class,1,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,2,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int input1TypeArgumentIndex, 		int input2TypeArgumentIndex, 		int outputTypeArgumentIndex, 		int[] lambdaInput1TypeArgumentIndices, 		int[] lambdaInput2TypeArgumentIndices, 		int[] lambdaOutputTypeArgumentIndices, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1496911361;Returns the binary operator's return type.__<p><b>NOTE:</b> lambda type indices allows extraction of Type from lambdas. To extract input type <b>IN1</b>_from the function given below one should pass {@code new int[] {0,1,0}} as lambdaInput1TypeArgumentIndices.__<pre>_<code>_OUT apply(Map<String, List<IN1>> value1, List<IN2> value2)_</code>_</pre>__@param function Function to extract the return type from_@param baseClass Base class of the function_@param input1TypeArgumentIndex Index of first input type in the class specification_@param input2TypeArgumentIndex Index of second input type in the class specification_@param outputTypeArgumentIndex Index of output type in the class specification_@param lambdaInput1TypeArgumentIndices Table of indices of the type argument specifying the first input type. See example._@param lambdaInput2TypeArgumentIndices Table of indices of the type argument specifying the second input type. See example._@param lambdaOutputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int input1TypeArgumentIndex,_		int input2TypeArgumentIndex,_		int outputTypeArgumentIndex,_		int[] lambdaInput1TypeArgumentIndices,_		int[] lambdaInput2TypeArgumentIndices,_		int[] lambdaOutputTypeArgumentIndices,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				Preconditions.checkArgument(_					lambdaInput1TypeArgumentIndices != null && lambdaInput1TypeArgumentIndices.length >= 1,_					"Indices for first input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaInput2TypeArgumentIndices != null && lambdaInput1TypeArgumentIndices.length >= 1,_					"Indices for second input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaOutputTypeArgumentIndices != null,_					"Indices for output type arguments within lambda not provided")__				_				validateLambdaGenericParameters(exec)___				final Method sam = TypeExtractionUtils.getSingleAbstractMethod(baseClass)__				final int baseParametersLen = sam.getParameterTypes().length___				_				final int paramLen = exec.getParameterTypes().length___				final Type input1 = TypeExtractionUtils.extractTypeFromLambda(_					exec,_					lambdaInput1TypeArgumentIndices,_					paramLen,_					baseParametersLen)__				final Type input2 = TypeExtractionUtils.extractTypeFromLambda(_					exec,_					lambdaInput2TypeArgumentIndices,_					paramLen,_					baseParametersLen)___				validateInputType(input1, in1Type)__				validateInputType(input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}__				final Type output__				if (lambdaOutputTypeArgumentIndices.length > 0) {_					output = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaOutputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__				} else {_					output = exec.getReturnType()__				}__				return new TypeExtractor().privateCreateTypeInfo(_					output,_					in1Type,_					in2Type)__			}_			else {_				Preconditions.checkArgument(input1TypeArgumentIndex >= 0, "Input 1 type argument index was not provided")__				Preconditions.checkArgument(input2TypeArgumentIndex >= 0, "Input 2 type argument index was not provided")__				Preconditions.checkArgument(outputTypeArgumentIndex >= 0, "Output type argument index was not provided")__				validateInputType(baseClass, function.getClass(), input1TypeArgumentIndex, in1Type)__				validateInputType(baseClass, function.getClass(), input2TypeArgumentIndex, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), outputTypeArgumentIndex, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,p,b,note,b,lambda,type,indices,allows,extraction,of,type,from,lambdas,to,extract,input,type,b,in1,b,from,the,function,given,below,one,should,pass,code,new,int,0,1,0,as,lambda,input1type,argument,indices,pre,code,out,apply,map,string,list,in1,value1,list,in2,value2,code,pre,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input1type,argument,index,index,of,first,input,type,in,the,class,specification,param,input2type,argument,index,index,of,second,input,type,in,the,class,specification,param,output,type,argument,index,index,of,output,type,in,the,class,specification,param,lambda,input1type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,first,input,type,see,example,param,lambda,input2type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,second,input,type,see,example,param,lambda,output,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input1type,argument,index,int,input2type,argument,index,int,output,type,argument,index,int,lambda,input1type,argument,indices,int,lambda,input2type,argument,indices,int,lambda,output,type,argument,indices,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,preconditions,check,argument,lambda,input1type,argument,indices,null,lambda,input1type,argument,indices,length,1,indices,for,first,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,input2type,argument,indices,null,lambda,input1type,argument,indices,length,1,indices,for,second,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,output,type,argument,indices,null,indices,for,output,type,arguments,within,lambda,not,provided,validate,lambda,generic,parameters,exec,final,method,sam,type,extraction,utils,get,single,abstract,method,base,class,final,int,base,parameters,len,sam,get,parameter,types,length,final,int,param,len,exec,get,parameter,types,length,final,type,input1,type,extraction,utils,extract,type,from,lambda,exec,lambda,input1type,argument,indices,param,len,base,parameters,len,final,type,input2,type,extraction,utils,extract,type,from,lambda,exec,lambda,input2type,argument,indices,param,len,base,parameters,len,validate,input,type,input1,in1type,validate,input,type,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,final,type,output,if,lambda,output,type,argument,indices,length,0,output,type,extraction,utils,extract,type,from,lambda,exec,lambda,output,type,argument,indices,param,len,base,parameters,len,else,output,exec,get,return,type,return,new,type,extractor,private,create,type,info,output,in1type,in2type,else,preconditions,check,argument,input1type,argument,index,0,input,1,type,argument,index,was,not,provided,preconditions,check,argument,input2type,argument,index,0,input,2,type,argument,index,was,not,provided,preconditions,check,argument,output,type,argument,index,0,output,type,argument,index,was,not,provided,validate,input,type,base,class,function,get,class,input1type,argument,index,in1type,validate,input,type,base,class,function,get,class,input2type,argument,index,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,output,type,argument,index,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int input1TypeArgumentIndex, 		int input2TypeArgumentIndex, 		int outputTypeArgumentIndex, 		int[] lambdaInput1TypeArgumentIndices, 		int[] lambdaInput2TypeArgumentIndices, 		int[] lambdaOutputTypeArgumentIndices, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1509723634;Returns the binary operator's return type.__<p><b>NOTE:</b> lambda type indices allows extraction of Type from lambdas. To extract input type <b>IN1</b>_from the function given below one should pass {@code new int[] {0,1,0}} as lambdaInput1TypeArgumentIndices.__<pre>_<code>_OUT apply(Map<String, List<IN1>> value1, List<IN2> value2)_</code>_</pre>__@param function Function to extract the return type from_@param baseClass Base class of the function_@param input1TypeArgumentIndex Index of first input type in the class specification_@param input2TypeArgumentIndex Index of second input type in the class specification_@param outputTypeArgumentIndex Index of output type in the class specification_@param lambdaInput1TypeArgumentIndices Table of indices of the type argument specifying the first input type. See example._@param lambdaInput2TypeArgumentIndices Table of indices of the type argument specifying the second input type. See example._@param lambdaOutputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int input1TypeArgumentIndex,_		int input2TypeArgumentIndex,_		int outputTypeArgumentIndex,_		int[] lambdaInput1TypeArgumentIndices,_		int[] lambdaInput2TypeArgumentIndices,_		int[] lambdaOutputTypeArgumentIndices,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				Preconditions.checkArgument(_					lambdaInput1TypeArgumentIndices != null && lambdaInput1TypeArgumentIndices.length >= 1,_					"Indices for first input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaInput2TypeArgumentIndices != null && lambdaInput1TypeArgumentIndices.length >= 1,_					"Indices for second input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaOutputTypeArgumentIndices != null,_					"Indices for output type arguments within lambda not provided")__				_				validateLambdaGenericParameters(exec)___				final Method sam = TypeExtractionUtils.getSingleAbstractMethod(baseClass)__				final int baseParametersLen = sam.getParameterTypes().length___				_				final int paramLen = exec.getParameterTypes().length___				final Type input1 = TypeExtractionUtils.extractTypeFromLambda(_					exec,_					lambdaInput1TypeArgumentIndices,_					paramLen,_					baseParametersLen)__				final Type input2 = TypeExtractionUtils.extractTypeFromLambda(_					exec,_					lambdaInput2TypeArgumentIndices,_					paramLen,_					baseParametersLen)___				validateInputType(input1, in1Type)__				validateInputType(input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}__				final Type output__				if (lambdaOutputTypeArgumentIndices.length > 0) {_					output = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaOutputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__				} else {_					output = exec.getReturnType()__				}__				return new TypeExtractor().privateCreateTypeInfo(_					output,_					in1Type,_					in2Type)__			}_			else {_				Preconditions.checkArgument(input1TypeArgumentIndex >= 0, "Input 1 type argument index was not provided")__				Preconditions.checkArgument(input2TypeArgumentIndex >= 0, "Input 2 type argument index was not provided")__				Preconditions.checkArgument(outputTypeArgumentIndex >= 0, "Output type argument index was not provided")__				validateInputType(baseClass, function.getClass(), input1TypeArgumentIndex, in1Type)__				validateInputType(baseClass, function.getClass(), input2TypeArgumentIndex, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), outputTypeArgumentIndex, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,p,b,note,b,lambda,type,indices,allows,extraction,of,type,from,lambdas,to,extract,input,type,b,in1,b,from,the,function,given,below,one,should,pass,code,new,int,0,1,0,as,lambda,input1type,argument,indices,pre,code,out,apply,map,string,list,in1,value1,list,in2,value2,code,pre,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input1type,argument,index,index,of,first,input,type,in,the,class,specification,param,input2type,argument,index,index,of,second,input,type,in,the,class,specification,param,output,type,argument,index,index,of,output,type,in,the,class,specification,param,lambda,input1type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,first,input,type,see,example,param,lambda,input2type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,second,input,type,see,example,param,lambda,output,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input1type,argument,index,int,input2type,argument,index,int,output,type,argument,index,int,lambda,input1type,argument,indices,int,lambda,input2type,argument,indices,int,lambda,output,type,argument,indices,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,preconditions,check,argument,lambda,input1type,argument,indices,null,lambda,input1type,argument,indices,length,1,indices,for,first,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,input2type,argument,indices,null,lambda,input1type,argument,indices,length,1,indices,for,second,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,output,type,argument,indices,null,indices,for,output,type,arguments,within,lambda,not,provided,validate,lambda,generic,parameters,exec,final,method,sam,type,extraction,utils,get,single,abstract,method,base,class,final,int,base,parameters,len,sam,get,parameter,types,length,final,int,param,len,exec,get,parameter,types,length,final,type,input1,type,extraction,utils,extract,type,from,lambda,exec,lambda,input1type,argument,indices,param,len,base,parameters,len,final,type,input2,type,extraction,utils,extract,type,from,lambda,exec,lambda,input2type,argument,indices,param,len,base,parameters,len,validate,input,type,input1,in1type,validate,input,type,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,final,type,output,if,lambda,output,type,argument,indices,length,0,output,type,extraction,utils,extract,type,from,lambda,exec,lambda,output,type,argument,indices,param,len,base,parameters,len,else,output,exec,get,return,type,return,new,type,extractor,private,create,type,info,output,in1type,in2type,else,preconditions,check,argument,input1type,argument,index,0,input,1,type,argument,index,was,not,provided,preconditions,check,argument,input2type,argument,index,0,input,2,type,argument,index,was,not,provided,preconditions,check,argument,output,type,argument,index,0,output,type,argument,index,was,not,provided,validate,input,type,base,class,function,get,class,input1type,argument,index,in1type,validate,input,type,base,class,function,get,class,input2type,argument,index,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,output,type,argument,index,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int input1TypeArgumentIndex, 		int input2TypeArgumentIndex, 		int outputTypeArgumentIndex, 		int[] lambdaInput1TypeArgumentIndices, 		int[] lambdaInput2TypeArgumentIndices, 		int[] lambdaOutputTypeArgumentIndices, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1509723634;Returns the binary operator's return type.__<p><b>NOTE:</b> lambda type indices allows extraction of Type from lambdas. To extract input type <b>IN1</b>_from the function given below one should pass {@code new int[] {0,1,0}} as lambdaInput1TypeArgumentIndices.__<pre>_<code>_OUT apply(Map<String, List<IN1>> value1, List<IN2> value2)_</code>_</pre>__@param function Function to extract the return type from_@param baseClass Base class of the function_@param input1TypeArgumentIndex Index of first input type in the class specification_@param input2TypeArgumentIndex Index of second input type in the class specification_@param outputTypeArgumentIndex Index of output type in the class specification_@param lambdaInput1TypeArgumentIndices Table of indices of the type argument specifying the first input type. See example._@param lambdaInput2TypeArgumentIndices Table of indices of the type argument specifying the second input type. See example._@param lambdaOutputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int input1TypeArgumentIndex,_		int input2TypeArgumentIndex,_		int outputTypeArgumentIndex,_		int[] lambdaInput1TypeArgumentIndices,_		int[] lambdaInput2TypeArgumentIndices,_		int[] lambdaOutputTypeArgumentIndices,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				Preconditions.checkArgument(_					lambdaInput1TypeArgumentIndices != null && lambdaInput1TypeArgumentIndices.length >= 1,_					"Indices for first input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaInput2TypeArgumentIndices != null && lambdaInput1TypeArgumentIndices.length >= 1,_					"Indices for second input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaOutputTypeArgumentIndices != null,_					"Indices for output type arguments within lambda not provided")__				_				validateLambdaGenericParameters(exec)___				final Method sam = TypeExtractionUtils.getSingleAbstractMethod(baseClass)__				final int baseParametersLen = sam.getParameterTypes().length___				_				final int paramLen = exec.getParameterTypes().length___				final Type input1 = TypeExtractionUtils.extractTypeFromLambda(_					exec,_					lambdaInput1TypeArgumentIndices,_					paramLen,_					baseParametersLen)__				final Type input2 = TypeExtractionUtils.extractTypeFromLambda(_					exec,_					lambdaInput2TypeArgumentIndices,_					paramLen,_					baseParametersLen)___				validateInputType(input1, in1Type)__				validateInputType(input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}__				final Type output__				if (lambdaOutputTypeArgumentIndices.length > 0) {_					output = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaOutputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__				} else {_					output = exec.getReturnType()__				}__				return new TypeExtractor().privateCreateTypeInfo(_					output,_					in1Type,_					in2Type)__			}_			else {_				Preconditions.checkArgument(input1TypeArgumentIndex >= 0, "Input 1 type argument index was not provided")__				Preconditions.checkArgument(input2TypeArgumentIndex >= 0, "Input 2 type argument index was not provided")__				Preconditions.checkArgument(outputTypeArgumentIndex >= 0, "Output type argument index was not provided")__				validateInputType(baseClass, function.getClass(), input1TypeArgumentIndex, in1Type)__				validateInputType(baseClass, function.getClass(), input2TypeArgumentIndex, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), outputTypeArgumentIndex, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,p,b,note,b,lambda,type,indices,allows,extraction,of,type,from,lambdas,to,extract,input,type,b,in1,b,from,the,function,given,below,one,should,pass,code,new,int,0,1,0,as,lambda,input1type,argument,indices,pre,code,out,apply,map,string,list,in1,value1,list,in2,value2,code,pre,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input1type,argument,index,index,of,first,input,type,in,the,class,specification,param,input2type,argument,index,index,of,second,input,type,in,the,class,specification,param,output,type,argument,index,index,of,output,type,in,the,class,specification,param,lambda,input1type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,first,input,type,see,example,param,lambda,input2type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,second,input,type,see,example,param,lambda,output,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input1type,argument,index,int,input2type,argument,index,int,output,type,argument,index,int,lambda,input1type,argument,indices,int,lambda,input2type,argument,indices,int,lambda,output,type,argument,indices,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,preconditions,check,argument,lambda,input1type,argument,indices,null,lambda,input1type,argument,indices,length,1,indices,for,first,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,input2type,argument,indices,null,lambda,input1type,argument,indices,length,1,indices,for,second,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,output,type,argument,indices,null,indices,for,output,type,arguments,within,lambda,not,provided,validate,lambda,generic,parameters,exec,final,method,sam,type,extraction,utils,get,single,abstract,method,base,class,final,int,base,parameters,len,sam,get,parameter,types,length,final,int,param,len,exec,get,parameter,types,length,final,type,input1,type,extraction,utils,extract,type,from,lambda,exec,lambda,input1type,argument,indices,param,len,base,parameters,len,final,type,input2,type,extraction,utils,extract,type,from,lambda,exec,lambda,input2type,argument,indices,param,len,base,parameters,len,validate,input,type,input1,in1type,validate,input,type,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,final,type,output,if,lambda,output,type,argument,indices,length,0,output,type,extraction,utils,extract,type,from,lambda,exec,lambda,output,type,argument,indices,param,len,base,parameters,len,else,output,exec,get,return,type,return,new,type,extractor,private,create,type,info,output,in1type,in2type,else,preconditions,check,argument,input1type,argument,index,0,input,1,type,argument,index,was,not,provided,preconditions,check,argument,input2type,argument,index,0,input,2,type,argument,index,was,not,provided,preconditions,check,argument,output,type,argument,index,0,output,type,argument,index,was,not,provided,validate,input,type,base,class,function,get,class,input1type,argument,index,in1type,validate,input,type,base,class,function,get,class,input2type,argument,index,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,output,type,argument,index,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int input1TypeArgumentIndex, 		int input2TypeArgumentIndex, 		int outputTypeArgumentIndex, 		int[] lambdaInput1TypeArgumentIndices, 		int[] lambdaInput2TypeArgumentIndices, 		int[] lambdaOutputTypeArgumentIndices, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1511902791;Returns the binary operator's return type.__<p><b>NOTE:</b> lambda type indices allows extraction of Type from lambdas. To extract input type <b>IN1</b>_from the function given below one should pass {@code new int[] {0,1,0}} as lambdaInput1TypeArgumentIndices.__<pre>_<code>_OUT apply(Map<String, List<IN1>> value1, List<IN2> value2)_</code>_</pre>__@param function Function to extract the return type from_@param baseClass Base class of the function_@param input1TypeArgumentIndex Index of first input type in the class specification_@param input2TypeArgumentIndex Index of second input type in the class specification_@param outputTypeArgumentIndex Index of output type in the class specification_@param lambdaInput1TypeArgumentIndices Table of indices of the type argument specifying the first input type. See example._@param lambdaInput2TypeArgumentIndices Table of indices of the type argument specifying the second input type. See example._@param lambdaOutputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int input1TypeArgumentIndex,_		int input2TypeArgumentIndex,_		int outputTypeArgumentIndex,_		int[] lambdaInput1TypeArgumentIndices,_		int[] lambdaInput2TypeArgumentIndices,_		int[] lambdaOutputTypeArgumentIndices,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				Preconditions.checkArgument(_					lambdaInput1TypeArgumentIndices != null && lambdaInput1TypeArgumentIndices.length >= 1,_					"Indices for first input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaInput2TypeArgumentIndices != null && lambdaInput1TypeArgumentIndices.length >= 1,_					"Indices for second input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaOutputTypeArgumentIndices != null,_					"Indices for output type arguments within lambda not provided")__				_				validateLambdaGenericParameters(exec)___				final Method sam = TypeExtractionUtils.getSingleAbstractMethod(baseClass)__				final int baseParametersLen = sam.getParameterTypes().length___				_				final int paramLen = exec.getParameterTypes().length___				final Type input1 = TypeExtractionUtils.extractTypeFromLambda(_					exec,_					lambdaInput1TypeArgumentIndices,_					paramLen,_					baseParametersLen)__				final Type input2 = TypeExtractionUtils.extractTypeFromLambda(_					exec,_					lambdaInput2TypeArgumentIndices,_					paramLen,_					baseParametersLen)___				validateInputType(input1, in1Type)__				validateInputType(input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}__				final Type output__				if (lambdaOutputTypeArgumentIndices.length > 0) {_					output = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaOutputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__				} else {_					output = exec.getReturnType()__				}__				return new TypeExtractor().privateCreateTypeInfo(_					output,_					in1Type,_					in2Type)__			}_			else {_				Preconditions.checkArgument(input1TypeArgumentIndex >= 0, "Input 1 type argument index was not provided")__				Preconditions.checkArgument(input2TypeArgumentIndex >= 0, "Input 2 type argument index was not provided")__				Preconditions.checkArgument(outputTypeArgumentIndex >= 0, "Output type argument index was not provided")__				validateInputType(baseClass, function.getClass(), input1TypeArgumentIndex, in1Type)__				validateInputType(baseClass, function.getClass(), input2TypeArgumentIndex, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), outputTypeArgumentIndex, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,p,b,note,b,lambda,type,indices,allows,extraction,of,type,from,lambdas,to,extract,input,type,b,in1,b,from,the,function,given,below,one,should,pass,code,new,int,0,1,0,as,lambda,input1type,argument,indices,pre,code,out,apply,map,string,list,in1,value1,list,in2,value2,code,pre,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input1type,argument,index,index,of,first,input,type,in,the,class,specification,param,input2type,argument,index,index,of,second,input,type,in,the,class,specification,param,output,type,argument,index,index,of,output,type,in,the,class,specification,param,lambda,input1type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,first,input,type,see,example,param,lambda,input2type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,second,input,type,see,example,param,lambda,output,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input1type,argument,index,int,input2type,argument,index,int,output,type,argument,index,int,lambda,input1type,argument,indices,int,lambda,input2type,argument,indices,int,lambda,output,type,argument,indices,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,preconditions,check,argument,lambda,input1type,argument,indices,null,lambda,input1type,argument,indices,length,1,indices,for,first,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,input2type,argument,indices,null,lambda,input1type,argument,indices,length,1,indices,for,second,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,output,type,argument,indices,null,indices,for,output,type,arguments,within,lambda,not,provided,validate,lambda,generic,parameters,exec,final,method,sam,type,extraction,utils,get,single,abstract,method,base,class,final,int,base,parameters,len,sam,get,parameter,types,length,final,int,param,len,exec,get,parameter,types,length,final,type,input1,type,extraction,utils,extract,type,from,lambda,exec,lambda,input1type,argument,indices,param,len,base,parameters,len,final,type,input2,type,extraction,utils,extract,type,from,lambda,exec,lambda,input2type,argument,indices,param,len,base,parameters,len,validate,input,type,input1,in1type,validate,input,type,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,final,type,output,if,lambda,output,type,argument,indices,length,0,output,type,extraction,utils,extract,type,from,lambda,exec,lambda,output,type,argument,indices,param,len,base,parameters,len,else,output,exec,get,return,type,return,new,type,extractor,private,create,type,info,output,in1type,in2type,else,preconditions,check,argument,input1type,argument,index,0,input,1,type,argument,index,was,not,provided,preconditions,check,argument,input2type,argument,index,0,input,2,type,argument,index,was,not,provided,preconditions,check,argument,output,type,argument,index,0,output,type,argument,index,was,not,provided,validate,input,type,base,class,function,get,class,input1type,argument,index,in1type,validate,input,type,base,class,function,get,class,input2type,argument,index,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,output,type,argument,index,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int input1TypeArgumentIndex, 		int input2TypeArgumentIndex, 		int outputTypeArgumentIndex, 		int[] lambdaInput1TypeArgumentIndices, 		int[] lambdaInput2TypeArgumentIndices, 		int[] lambdaOutputTypeArgumentIndices, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1515177485;Returns the binary operator's return type.__<p><b>NOTE:</b> lambda type indices allows extraction of Type from lambdas. To extract input type <b>IN1</b>_from the function given below one should pass {@code new int[] {0,1,0}} as lambdaInput1TypeArgumentIndices.__<pre>_<code>_OUT apply(Map<String, List<IN1>> value1, List<IN2> value2)_</code>_</pre>__@param function Function to extract the return type from_@param baseClass Base class of the function_@param input1TypeArgumentIndex Index of first input type in the class specification_@param input2TypeArgumentIndex Index of second input type in the class specification_@param outputTypeArgumentIndex Index of output type in the class specification_@param lambdaInput1TypeArgumentIndices Table of indices of the type argument specifying the first input type. See example._@param lambdaInput2TypeArgumentIndices Table of indices of the type argument specifying the second input type. See example._@param lambdaOutputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int input1TypeArgumentIndex,_		int input2TypeArgumentIndex,_		int outputTypeArgumentIndex,_		int[] lambdaInput1TypeArgumentIndices,_		int[] lambdaInput2TypeArgumentIndices,_		int[] lambdaOutputTypeArgumentIndices,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				Preconditions.checkArgument(_					lambdaInput1TypeArgumentIndices != null && lambdaInput1TypeArgumentIndices.length >= 1,_					"Indices for first input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaInput2TypeArgumentIndices != null && lambdaInput1TypeArgumentIndices.length >= 1,_					"Indices for second input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaOutputTypeArgumentIndices != null,_					"Indices for output type arguments within lambda not provided")__				_				validateLambdaGenericParameters(exec)___				final Method sam = TypeExtractionUtils.getSingleAbstractMethod(baseClass)__				final int baseParametersLen = sam.getParameterTypes().length___				_				final int paramLen = exec.getParameterTypes().length___				final Type input1 = TypeExtractionUtils.extractTypeFromLambda(_					exec,_					lambdaInput1TypeArgumentIndices,_					paramLen,_					baseParametersLen)__				final Type input2 = TypeExtractionUtils.extractTypeFromLambda(_					exec,_					lambdaInput2TypeArgumentIndices,_					paramLen,_					baseParametersLen)___				validateInputType(input1, in1Type)__				validateInputType(input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}__				final Type output__				if (lambdaOutputTypeArgumentIndices.length > 0) {_					output = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaOutputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__				} else {_					output = exec.getReturnType()__				}__				return new TypeExtractor().privateCreateTypeInfo(_					output,_					in1Type,_					in2Type)__			}_			else {_				Preconditions.checkArgument(input1TypeArgumentIndex >= 0, "Input 1 type argument index was not provided")__				Preconditions.checkArgument(input2TypeArgumentIndex >= 0, "Input 2 type argument index was not provided")__				Preconditions.checkArgument(outputTypeArgumentIndex >= 0, "Output type argument index was not provided")__				validateInputType(baseClass, function.getClass(), input1TypeArgumentIndex, in1Type)__				validateInputType(baseClass, function.getClass(), input2TypeArgumentIndex, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), outputTypeArgumentIndex, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,p,b,note,b,lambda,type,indices,allows,extraction,of,type,from,lambdas,to,extract,input,type,b,in1,b,from,the,function,given,below,one,should,pass,code,new,int,0,1,0,as,lambda,input1type,argument,indices,pre,code,out,apply,map,string,list,in1,value1,list,in2,value2,code,pre,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input1type,argument,index,index,of,first,input,type,in,the,class,specification,param,input2type,argument,index,index,of,second,input,type,in,the,class,specification,param,output,type,argument,index,index,of,output,type,in,the,class,specification,param,lambda,input1type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,first,input,type,see,example,param,lambda,input2type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,second,input,type,see,example,param,lambda,output,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input1type,argument,index,int,input2type,argument,index,int,output,type,argument,index,int,lambda,input1type,argument,indices,int,lambda,input2type,argument,indices,int,lambda,output,type,argument,indices,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,preconditions,check,argument,lambda,input1type,argument,indices,null,lambda,input1type,argument,indices,length,1,indices,for,first,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,input2type,argument,indices,null,lambda,input1type,argument,indices,length,1,indices,for,second,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,output,type,argument,indices,null,indices,for,output,type,arguments,within,lambda,not,provided,validate,lambda,generic,parameters,exec,final,method,sam,type,extraction,utils,get,single,abstract,method,base,class,final,int,base,parameters,len,sam,get,parameter,types,length,final,int,param,len,exec,get,parameter,types,length,final,type,input1,type,extraction,utils,extract,type,from,lambda,exec,lambda,input1type,argument,indices,param,len,base,parameters,len,final,type,input2,type,extraction,utils,extract,type,from,lambda,exec,lambda,input2type,argument,indices,param,len,base,parameters,len,validate,input,type,input1,in1type,validate,input,type,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,final,type,output,if,lambda,output,type,argument,indices,length,0,output,type,extraction,utils,extract,type,from,lambda,exec,lambda,output,type,argument,indices,param,len,base,parameters,len,else,output,exec,get,return,type,return,new,type,extractor,private,create,type,info,output,in1type,in2type,else,preconditions,check,argument,input1type,argument,index,0,input,1,type,argument,index,was,not,provided,preconditions,check,argument,input2type,argument,index,0,input,2,type,argument,index,was,not,provided,preconditions,check,argument,output,type,argument,index,0,output,type,argument,index,was,not,provided,validate,input,type,base,class,function,get,class,input1type,argument,index,in1type,validate,input,type,base,class,function,get,class,input2type,argument,index,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,output,type,argument,index,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int input1TypeArgumentIndex, 		int input2TypeArgumentIndex, 		int outputTypeArgumentIndex, 		int[] lambdaInput1TypeArgumentIndices, 		int[] lambdaInput2TypeArgumentIndices, 		int[] lambdaOutputTypeArgumentIndices, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1517320791;Returns the binary operator's return type.__<p><b>NOTE:</b> lambda type indices allows extraction of Type from lambdas. To extract input type <b>IN1</b>_from the function given below one should pass {@code new int[] {0,1,0}} as lambdaInput1TypeArgumentIndices.__<pre>_<code>_OUT apply(Map<String, List<IN1>> value1, List<IN2> value2)_</code>_</pre>__@param function Function to extract the return type from_@param baseClass Base class of the function_@param input1TypeArgumentIndex Index of first input type in the class specification_@param input2TypeArgumentIndex Index of second input type in the class specification_@param outputTypeArgumentIndex Index of output type in the class specification_@param lambdaInput1TypeArgumentIndices Table of indices of the type argument specifying the first input type. See example._@param lambdaInput2TypeArgumentIndices Table of indices of the type argument specifying the second input type. See example._@param lambdaOutputTypeArgumentIndices Table of indices of the type argument specifying the output type. See example._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int input1TypeArgumentIndex,_		int input2TypeArgumentIndex,_		int outputTypeArgumentIndex,_		int[] lambdaInput1TypeArgumentIndices,_		int[] lambdaInput2TypeArgumentIndices,_		int[] lambdaOutputTypeArgumentIndices,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				Preconditions.checkArgument(_					lambdaInput1TypeArgumentIndices != null && lambdaInput1TypeArgumentIndices.length >= 1,_					"Indices for first input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaInput2TypeArgumentIndices != null && lambdaInput1TypeArgumentIndices.length >= 1,_					"Indices for second input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaOutputTypeArgumentIndices != null,_					"Indices for output type arguments within lambda not provided")__				_				validateLambdaGenericParameters(exec)___				final Method sam = TypeExtractionUtils.getSingleAbstractMethod(baseClass)__				final int baseParametersLen = sam.getParameterTypes().length___				_				final int paramLen = exec.getParameterTypes().length___				final Type input1 = TypeExtractionUtils.extractTypeFromLambda(_					exec,_					lambdaInput1TypeArgumentIndices,_					paramLen,_					baseParametersLen)__				final Type input2 = TypeExtractionUtils.extractTypeFromLambda(_					exec,_					lambdaInput2TypeArgumentIndices,_					paramLen,_					baseParametersLen)___				validateInputType(input1, in1Type)__				validateInputType(input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}__				final Type output__				if (lambdaOutputTypeArgumentIndices.length > 0) {_					output = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaOutputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__				} else {_					output = exec.getReturnType()__				}__				return new TypeExtractor().privateCreateTypeInfo(_					output,_					in1Type,_					in2Type)__			}_			else {_				Preconditions.checkArgument(input1TypeArgumentIndex >= 0, "Input 1 type argument index was not provided")__				Preconditions.checkArgument(input2TypeArgumentIndex >= 0, "Input 2 type argument index was not provided")__				Preconditions.checkArgument(outputTypeArgumentIndex >= 0, "Output type argument index was not provided")__				validateInputType(baseClass, function.getClass(), input1TypeArgumentIndex, in1Type)__				validateInputType(baseClass, function.getClass(), input2TypeArgumentIndex, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), outputTypeArgumentIndex, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,p,b,note,b,lambda,type,indices,allows,extraction,of,type,from,lambdas,to,extract,input,type,b,in1,b,from,the,function,given,below,one,should,pass,code,new,int,0,1,0,as,lambda,input1type,argument,indices,pre,code,out,apply,map,string,list,in1,value1,list,in2,value2,code,pre,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input1type,argument,index,index,of,first,input,type,in,the,class,specification,param,input2type,argument,index,index,of,second,input,type,in,the,class,specification,param,output,type,argument,index,index,of,output,type,in,the,class,specification,param,lambda,input1type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,first,input,type,see,example,param,lambda,input2type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,second,input,type,see,example,param,lambda,output,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,output,type,see,example,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input1type,argument,index,int,input2type,argument,index,int,output,type,argument,index,int,lambda,input1type,argument,indices,int,lambda,input2type,argument,indices,int,lambda,output,type,argument,indices,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,preconditions,check,argument,lambda,input1type,argument,indices,null,lambda,input1type,argument,indices,length,1,indices,for,first,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,input2type,argument,indices,null,lambda,input1type,argument,indices,length,1,indices,for,second,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,output,type,argument,indices,null,indices,for,output,type,arguments,within,lambda,not,provided,validate,lambda,generic,parameters,exec,final,method,sam,type,extraction,utils,get,single,abstract,method,base,class,final,int,base,parameters,len,sam,get,parameter,types,length,final,int,param,len,exec,get,parameter,types,length,final,type,input1,type,extraction,utils,extract,type,from,lambda,exec,lambda,input1type,argument,indices,param,len,base,parameters,len,final,type,input2,type,extraction,utils,extract,type,from,lambda,exec,lambda,input2type,argument,indices,param,len,base,parameters,len,validate,input,type,input1,in1type,validate,input,type,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,final,type,output,if,lambda,output,type,argument,indices,length,0,output,type,extraction,utils,extract,type,from,lambda,exec,lambda,output,type,argument,indices,param,len,base,parameters,len,else,output,exec,get,return,type,return,new,type,extractor,private,create,type,info,output,in1type,in2type,else,preconditions,check,argument,input1type,argument,index,0,input,1,type,argument,index,was,not,provided,preconditions,check,argument,input2type,argument,index,0,input,2,type,argument,index,was,not,provided,preconditions,check,argument,output,type,argument,index,0,output,type,argument,index,was,not,provided,validate,input,type,base,class,function,get,class,input1type,argument,index,in1type,validate,input,type,base,class,function,get,class,input2type,argument,index,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,output,type,argument,index,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int input1TypeArgumentIndex, 		int input2TypeArgumentIndex, 		int outputTypeArgumentIndex, 		int[] lambdaInput1TypeArgumentIndices, 		int[] lambdaInput2TypeArgumentIndices, 		int[] lambdaOutputTypeArgumentIndices, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1528874321;Returns the binary operator's return type.__<p><b>NOTE:</b> lambda type indices allows extraction of Type from lambdas. To extract input type <b>IN1</b>_from the function given below one should pass {@code new int[] {0,1,0}} as lambdaInput1TypeArgumentIndices.__<pre>_<code>_OUT apply(Map<String, List<IN1>> value1, List<IN2> value2)_</code>_</pre>__@param function Function to extract the return type from_@param baseClass Base class of the function_@param input1TypeArgumentIndex Index of first input type in the class specification_@param input2TypeArgumentIndex Index of second input type in the class specification_@param outputTypeArgumentIndex Index of output type in the class specification_@param lambdaInput1TypeArgumentIndices Table of indices of the type argument specifying the first input type. See example._@param lambdaInput2TypeArgumentIndices Table of indices of the type argument specifying the second input type. See example._@param lambdaOutputTypeArgumentIndices Table of indices of the type argument specifying the output type. See example._@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int input1TypeArgumentIndex,_		int input2TypeArgumentIndex,_		int outputTypeArgumentIndex,_		int[] lambdaInput1TypeArgumentIndices,_		int[] lambdaInput2TypeArgumentIndices,_		int[] lambdaOutputTypeArgumentIndices,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				Preconditions.checkArgument(_					lambdaInput1TypeArgumentIndices != null && lambdaInput1TypeArgumentIndices.length >= 1,_					"Indices for first input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaInput2TypeArgumentIndices != null && lambdaInput2TypeArgumentIndices.length >= 1,_					"Indices for second input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaOutputTypeArgumentIndices != null,_					"Indices for output type arguments within lambda not provided")__				_				validateLambdaGenericParameters(exec)___				final Method sam = TypeExtractionUtils.getSingleAbstractMethod(baseClass)__				final int baseParametersLen = sam.getParameterTypes().length___				_				final int paramLen = exec.getParameterTypes().length___				final Type input1 = TypeExtractionUtils.extractTypeFromLambda(_					exec,_					lambdaInput1TypeArgumentIndices,_					paramLen,_					baseParametersLen)__				final Type input2 = TypeExtractionUtils.extractTypeFromLambda(_					exec,_					lambdaInput2TypeArgumentIndices,_					paramLen,_					baseParametersLen)___				validateInputType(input1, in1Type)__				validateInputType(input2, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}__				final Type output__				if (lambdaOutputTypeArgumentIndices.length > 0) {_					output = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaOutputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__				} else {_					output = exec.getReturnType()__				}__				return new TypeExtractor().privateCreateTypeInfo(_					output,_					in1Type,_					in2Type)__			}_			else {_				Preconditions.checkArgument(input1TypeArgumentIndex >= 0, "Input 1 type argument index was not provided")__				Preconditions.checkArgument(input2TypeArgumentIndex >= 0, "Input 2 type argument index was not provided")__				Preconditions.checkArgument(outputTypeArgumentIndex >= 0, "Output type argument index was not provided")__				validateInputType(baseClass, function.getClass(), input1TypeArgumentIndex, in1Type)__				validateInputType(baseClass, function.getClass(), input2TypeArgumentIndex, in2Type)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), outputTypeArgumentIndex, in1Type, in2Type)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,binary,operator,s,return,type,p,b,note,b,lambda,type,indices,allows,extraction,of,type,from,lambdas,to,extract,input,type,b,in1,b,from,the,function,given,below,one,should,pass,code,new,int,0,1,0,as,lambda,input1type,argument,indices,pre,code,out,apply,map,string,list,in1,value1,list,in2,value2,code,pre,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input1type,argument,index,index,of,first,input,type,in,the,class,specification,param,input2type,argument,index,index,of,second,input,type,in,the,class,specification,param,output,type,argument,index,index,of,output,type,in,the,class,specification,param,lambda,input1type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,first,input,type,see,example,param,lambda,input2type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,second,input,type,see,example,param,lambda,output,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,output,type,see,example,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,int,input1type,argument,index,int,input2type,argument,index,int,output,type,argument,index,int,lambda,input1type,argument,indices,int,lambda,input2type,argument,indices,int,lambda,output,type,argument,indices,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,preconditions,check,argument,lambda,input1type,argument,indices,null,lambda,input1type,argument,indices,length,1,indices,for,first,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,input2type,argument,indices,null,lambda,input2type,argument,indices,length,1,indices,for,second,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,output,type,argument,indices,null,indices,for,output,type,arguments,within,lambda,not,provided,validate,lambda,generic,parameters,exec,final,method,sam,type,extraction,utils,get,single,abstract,method,base,class,final,int,base,parameters,len,sam,get,parameter,types,length,final,int,param,len,exec,get,parameter,types,length,final,type,input1,type,extraction,utils,extract,type,from,lambda,exec,lambda,input1type,argument,indices,param,len,base,parameters,len,final,type,input2,type,extraction,utils,extract,type,from,lambda,exec,lambda,input2type,argument,indices,param,len,base,parameters,len,validate,input,type,input1,in1type,validate,input,type,input2,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,final,type,output,if,lambda,output,type,argument,indices,length,0,output,type,extraction,utils,extract,type,from,lambda,exec,lambda,output,type,argument,indices,param,len,base,parameters,len,else,output,exec,get,return,type,return,new,type,extractor,private,create,type,info,output,in1type,in2type,else,preconditions,check,argument,input1type,argument,index,0,input,1,type,argument,index,was,not,provided,preconditions,check,argument,input2type,argument,index,0,input,2,type,argument,index,was,not,provided,preconditions,check,argument,output,type,argument,index,0,output,type,argument,index,was,not,provided,validate,input,type,base,class,function,get,class,input1type,argument,index,in1type,validate,input,type,base,class,function,get,class,input2type,argument,index,in2type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,output,type,argument,index,in1type,in2type,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		int[] lambdaInputTypeArgumentIndices, 		int[] lambdaOutputTypeArgumentIndices, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1496911361;Returns the unary operator's return type.__<p><b>NOTE:</b> lambda type indices allow extraction of Type from lambdas. To extract input type <b>IN</b>_from the function given below one should pass {@code new int[] {0,1,0}} as lambdaInputTypeArgumentIndices.__<pre>_<code>_OUT apply(Map<String, List<IN>> value)_</code>_</pre>__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of input type in the class specification_@param outputTypeArgumentIndex Index of output type in the class specification_@param lambdaInputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param lambdaOutputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		int[] lambdaInputTypeArgumentIndices,_		int[] lambdaOutputTypeArgumentIndices,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				Preconditions.checkArgument(_					lambdaInputTypeArgumentIndices != null && lambdaInputTypeArgumentIndices.length >= 1,_					"Indices for input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaOutputTypeArgumentIndices != null,_					"Indices for output type arguments within lambda not provided")__				_				validateLambdaGenericParameters(exec)___				_				_				final int paramLen = exec.getParameterTypes().length___				final Method sam = TypeExtractionUtils.getSingleAbstractMethod(baseClass)___				_				final int baseParametersLen = sam.getParameterTypes().length___				_				if (paramLen <= 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaInputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__					validateInputType(input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}__				final Type output__				if (lambdaOutputTypeArgumentIndices.length > 0) {_					output = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaOutputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__				} else {_					output = exec.getReturnType()__				}__				return new TypeExtractor().privateCreateTypeInfo(output, inType, null)__			} else {_				Preconditions.checkArgument(inputTypeArgumentIndex >= 0, "Input type argument index was not provided")__				Preconditions.checkArgument(outputTypeArgumentIndex >= 0, "Output type argument index was not provided")__				validateInputType(baseClass, function.getClass(), inputTypeArgumentIndex, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), outputTypeArgumentIndex, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,p,b,note,b,lambda,type,indices,allow,extraction,of,type,from,lambdas,to,extract,input,type,b,in,b,from,the,function,given,below,one,should,pass,code,new,int,0,1,0,as,lambda,input,type,argument,indices,pre,code,out,apply,map,string,list,in,value,code,pre,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,input,type,in,the,class,specification,param,output,type,argument,index,index,of,output,type,in,the,class,specification,param,lambda,input,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,lambda,output,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,int,lambda,input,type,argument,indices,int,lambda,output,type,argument,indices,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,preconditions,check,argument,lambda,input,type,argument,indices,null,lambda,input,type,argument,indices,length,1,indices,for,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,output,type,argument,indices,null,indices,for,output,type,arguments,within,lambda,not,provided,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,final,method,sam,type,extraction,utils,get,single,abstract,method,base,class,final,int,base,parameters,len,sam,get,parameter,types,length,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,type,extraction,utils,extract,type,from,lambda,exec,lambda,input,type,argument,indices,param,len,base,parameters,len,validate,input,type,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,final,type,output,if,lambda,output,type,argument,indices,length,0,output,type,extraction,utils,extract,type,from,lambda,exec,lambda,output,type,argument,indices,param,len,base,parameters,len,else,output,exec,get,return,type,return,new,type,extractor,private,create,type,info,output,in,type,null,else,preconditions,check,argument,input,type,argument,index,0,input,type,argument,index,was,not,provided,preconditions,check,argument,output,type,argument,index,0,output,type,argument,index,was,not,provided,validate,input,type,base,class,function,get,class,input,type,argument,index,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,output,type,argument,index,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		int[] lambdaInputTypeArgumentIndices, 		int[] lambdaOutputTypeArgumentIndices, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1509723634;Returns the unary operator's return type.__<p><b>NOTE:</b> lambda type indices allow extraction of Type from lambdas. To extract input type <b>IN</b>_from the function given below one should pass {@code new int[] {0,1,0}} as lambdaInputTypeArgumentIndices.__<pre>_<code>_OUT apply(Map<String, List<IN>> value)_</code>_</pre>__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of input type in the class specification_@param outputTypeArgumentIndex Index of output type in the class specification_@param lambdaInputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param lambdaOutputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		int[] lambdaInputTypeArgumentIndices,_		int[] lambdaOutputTypeArgumentIndices,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				Preconditions.checkArgument(_					lambdaInputTypeArgumentIndices != null && lambdaInputTypeArgumentIndices.length >= 1,_					"Indices for input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaOutputTypeArgumentIndices != null,_					"Indices for output type arguments within lambda not provided")__				_				validateLambdaGenericParameters(exec)___				_				_				final int paramLen = exec.getParameterTypes().length___				final Method sam = TypeExtractionUtils.getSingleAbstractMethod(baseClass)___				_				final int baseParametersLen = sam.getParameterTypes().length___				_				if (paramLen <= 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaInputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__					validateInputType(input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}__				final Type output__				if (lambdaOutputTypeArgumentIndices.length > 0) {_					output = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaOutputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__				} else {_					output = exec.getReturnType()__				}__				return new TypeExtractor().privateCreateTypeInfo(output, inType, null)__			} else {_				Preconditions.checkArgument(inputTypeArgumentIndex >= 0, "Input type argument index was not provided")__				Preconditions.checkArgument(outputTypeArgumentIndex >= 0, "Output type argument index was not provided")__				validateInputType(baseClass, function.getClass(), inputTypeArgumentIndex, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), outputTypeArgumentIndex, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,p,b,note,b,lambda,type,indices,allow,extraction,of,type,from,lambdas,to,extract,input,type,b,in,b,from,the,function,given,below,one,should,pass,code,new,int,0,1,0,as,lambda,input,type,argument,indices,pre,code,out,apply,map,string,list,in,value,code,pre,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,input,type,in,the,class,specification,param,output,type,argument,index,index,of,output,type,in,the,class,specification,param,lambda,input,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,lambda,output,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,int,lambda,input,type,argument,indices,int,lambda,output,type,argument,indices,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,preconditions,check,argument,lambda,input,type,argument,indices,null,lambda,input,type,argument,indices,length,1,indices,for,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,output,type,argument,indices,null,indices,for,output,type,arguments,within,lambda,not,provided,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,final,method,sam,type,extraction,utils,get,single,abstract,method,base,class,final,int,base,parameters,len,sam,get,parameter,types,length,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,type,extraction,utils,extract,type,from,lambda,exec,lambda,input,type,argument,indices,param,len,base,parameters,len,validate,input,type,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,final,type,output,if,lambda,output,type,argument,indices,length,0,output,type,extraction,utils,extract,type,from,lambda,exec,lambda,output,type,argument,indices,param,len,base,parameters,len,else,output,exec,get,return,type,return,new,type,extractor,private,create,type,info,output,in,type,null,else,preconditions,check,argument,input,type,argument,index,0,input,type,argument,index,was,not,provided,preconditions,check,argument,output,type,argument,index,0,output,type,argument,index,was,not,provided,validate,input,type,base,class,function,get,class,input,type,argument,index,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,output,type,argument,index,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		int[] lambdaInputTypeArgumentIndices, 		int[] lambdaOutputTypeArgumentIndices, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1509723634;Returns the unary operator's return type.__<p><b>NOTE:</b> lambda type indices allow extraction of Type from lambdas. To extract input type <b>IN</b>_from the function given below one should pass {@code new int[] {0,1,0}} as lambdaInputTypeArgumentIndices.__<pre>_<code>_OUT apply(Map<String, List<IN>> value)_</code>_</pre>__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of input type in the class specification_@param outputTypeArgumentIndex Index of output type in the class specification_@param lambdaInputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param lambdaOutputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		int[] lambdaInputTypeArgumentIndices,_		int[] lambdaOutputTypeArgumentIndices,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				Preconditions.checkArgument(_					lambdaInputTypeArgumentIndices != null && lambdaInputTypeArgumentIndices.length >= 1,_					"Indices for input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaOutputTypeArgumentIndices != null,_					"Indices for output type arguments within lambda not provided")__				_				validateLambdaGenericParameters(exec)___				_				_				final int paramLen = exec.getParameterTypes().length___				final Method sam = TypeExtractionUtils.getSingleAbstractMethod(baseClass)___				_				final int baseParametersLen = sam.getParameterTypes().length___				_				if (paramLen <= 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaInputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__					validateInputType(input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}__				final Type output__				if (lambdaOutputTypeArgumentIndices.length > 0) {_					output = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaOutputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__				} else {_					output = exec.getReturnType()__				}__				return new TypeExtractor().privateCreateTypeInfo(output, inType, null)__			} else {_				Preconditions.checkArgument(inputTypeArgumentIndex >= 0, "Input type argument index was not provided")__				Preconditions.checkArgument(outputTypeArgumentIndex >= 0, "Output type argument index was not provided")__				validateInputType(baseClass, function.getClass(), inputTypeArgumentIndex, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), outputTypeArgumentIndex, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,p,b,note,b,lambda,type,indices,allow,extraction,of,type,from,lambdas,to,extract,input,type,b,in,b,from,the,function,given,below,one,should,pass,code,new,int,0,1,0,as,lambda,input,type,argument,indices,pre,code,out,apply,map,string,list,in,value,code,pre,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,input,type,in,the,class,specification,param,output,type,argument,index,index,of,output,type,in,the,class,specification,param,lambda,input,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,lambda,output,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,int,lambda,input,type,argument,indices,int,lambda,output,type,argument,indices,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,preconditions,check,argument,lambda,input,type,argument,indices,null,lambda,input,type,argument,indices,length,1,indices,for,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,output,type,argument,indices,null,indices,for,output,type,arguments,within,lambda,not,provided,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,final,method,sam,type,extraction,utils,get,single,abstract,method,base,class,final,int,base,parameters,len,sam,get,parameter,types,length,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,type,extraction,utils,extract,type,from,lambda,exec,lambda,input,type,argument,indices,param,len,base,parameters,len,validate,input,type,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,final,type,output,if,lambda,output,type,argument,indices,length,0,output,type,extraction,utils,extract,type,from,lambda,exec,lambda,output,type,argument,indices,param,len,base,parameters,len,else,output,exec,get,return,type,return,new,type,extractor,private,create,type,info,output,in,type,null,else,preconditions,check,argument,input,type,argument,index,0,input,type,argument,index,was,not,provided,preconditions,check,argument,output,type,argument,index,0,output,type,argument,index,was,not,provided,validate,input,type,base,class,function,get,class,input,type,argument,index,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,output,type,argument,index,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		int[] lambdaInputTypeArgumentIndices, 		int[] lambdaOutputTypeArgumentIndices, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1511902791;Returns the unary operator's return type.__<p><b>NOTE:</b> lambda type indices allow extraction of Type from lambdas. To extract input type <b>IN</b>_from the function given below one should pass {@code new int[] {0,1,0}} as lambdaInputTypeArgumentIndices.__<pre>_<code>_OUT apply(Map<String, List<IN>> value)_</code>_</pre>__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of input type in the class specification_@param outputTypeArgumentIndex Index of output type in the class specification_@param lambdaInputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param lambdaOutputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		int[] lambdaInputTypeArgumentIndices,_		int[] lambdaOutputTypeArgumentIndices,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				Preconditions.checkArgument(_					lambdaInputTypeArgumentIndices != null && lambdaInputTypeArgumentIndices.length >= 1,_					"Indices for input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaOutputTypeArgumentIndices != null,_					"Indices for output type arguments within lambda not provided")__				_				validateLambdaGenericParameters(exec)___				_				_				final int paramLen = exec.getParameterTypes().length___				final Method sam = TypeExtractionUtils.getSingleAbstractMethod(baseClass)___				_				final int baseParametersLen = sam.getParameterTypes().length___				_				if (paramLen <= 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaInputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__					validateInputType(input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}__				final Type output__				if (lambdaOutputTypeArgumentIndices.length > 0) {_					output = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaOutputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__				} else {_					output = exec.getReturnType()__				}__				return new TypeExtractor().privateCreateTypeInfo(output, inType, null)__			} else {_				Preconditions.checkArgument(inputTypeArgumentIndex >= 0, "Input type argument index was not provided")__				Preconditions.checkArgument(outputTypeArgumentIndex >= 0, "Output type argument index was not provided")__				validateInputType(baseClass, function.getClass(), inputTypeArgumentIndex, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), outputTypeArgumentIndex, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,p,b,note,b,lambda,type,indices,allow,extraction,of,type,from,lambdas,to,extract,input,type,b,in,b,from,the,function,given,below,one,should,pass,code,new,int,0,1,0,as,lambda,input,type,argument,indices,pre,code,out,apply,map,string,list,in,value,code,pre,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,input,type,in,the,class,specification,param,output,type,argument,index,index,of,output,type,in,the,class,specification,param,lambda,input,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,lambda,output,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,int,lambda,input,type,argument,indices,int,lambda,output,type,argument,indices,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,preconditions,check,argument,lambda,input,type,argument,indices,null,lambda,input,type,argument,indices,length,1,indices,for,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,output,type,argument,indices,null,indices,for,output,type,arguments,within,lambda,not,provided,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,final,method,sam,type,extraction,utils,get,single,abstract,method,base,class,final,int,base,parameters,len,sam,get,parameter,types,length,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,type,extraction,utils,extract,type,from,lambda,exec,lambda,input,type,argument,indices,param,len,base,parameters,len,validate,input,type,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,final,type,output,if,lambda,output,type,argument,indices,length,0,output,type,extraction,utils,extract,type,from,lambda,exec,lambda,output,type,argument,indices,param,len,base,parameters,len,else,output,exec,get,return,type,return,new,type,extractor,private,create,type,info,output,in,type,null,else,preconditions,check,argument,input,type,argument,index,0,input,type,argument,index,was,not,provided,preconditions,check,argument,output,type,argument,index,0,output,type,argument,index,was,not,provided,validate,input,type,base,class,function,get,class,input,type,argument,index,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,output,type,argument,index,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		int[] lambdaInputTypeArgumentIndices, 		int[] lambdaOutputTypeArgumentIndices, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1515177485;Returns the unary operator's return type.__<p><b>NOTE:</b> lambda type indices allow extraction of Type from lambdas. To extract input type <b>IN</b>_from the function given below one should pass {@code new int[] {0,1,0}} as lambdaInputTypeArgumentIndices.__<pre>_<code>_OUT apply(Map<String, List<IN>> value)_</code>_</pre>__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of input type in the class specification_@param outputTypeArgumentIndex Index of output type in the class specification_@param lambdaInputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param lambdaOutputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		int[] lambdaInputTypeArgumentIndices,_		int[] lambdaOutputTypeArgumentIndices,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				Preconditions.checkArgument(_					lambdaInputTypeArgumentIndices != null && lambdaInputTypeArgumentIndices.length >= 1,_					"Indices for input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaOutputTypeArgumentIndices != null,_					"Indices for output type arguments within lambda not provided")__				_				validateLambdaGenericParameters(exec)___				_				_				final int paramLen = exec.getParameterTypes().length___				final Method sam = TypeExtractionUtils.getSingleAbstractMethod(baseClass)___				_				final int baseParametersLen = sam.getParameterTypes().length___				_				if (paramLen <= 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaInputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__					validateInputType(input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}__				final Type output__				if (lambdaOutputTypeArgumentIndices.length > 0) {_					output = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaOutputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__				} else {_					output = exec.getReturnType()__				}__				return new TypeExtractor().privateCreateTypeInfo(output, inType, null)__			} else {_				Preconditions.checkArgument(inputTypeArgumentIndex >= 0, "Input type argument index was not provided")__				Preconditions.checkArgument(outputTypeArgumentIndex >= 0, "Output type argument index was not provided")__				validateInputType(baseClass, function.getClass(), inputTypeArgumentIndex, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), outputTypeArgumentIndex, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,p,b,note,b,lambda,type,indices,allow,extraction,of,type,from,lambdas,to,extract,input,type,b,in,b,from,the,function,given,below,one,should,pass,code,new,int,0,1,0,as,lambda,input,type,argument,indices,pre,code,out,apply,map,string,list,in,value,code,pre,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,input,type,in,the,class,specification,param,output,type,argument,index,index,of,output,type,in,the,class,specification,param,lambda,input,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,lambda,output,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,int,lambda,input,type,argument,indices,int,lambda,output,type,argument,indices,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,preconditions,check,argument,lambda,input,type,argument,indices,null,lambda,input,type,argument,indices,length,1,indices,for,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,output,type,argument,indices,null,indices,for,output,type,arguments,within,lambda,not,provided,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,final,method,sam,type,extraction,utils,get,single,abstract,method,base,class,final,int,base,parameters,len,sam,get,parameter,types,length,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,type,extraction,utils,extract,type,from,lambda,exec,lambda,input,type,argument,indices,param,len,base,parameters,len,validate,input,type,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,final,type,output,if,lambda,output,type,argument,indices,length,0,output,type,extraction,utils,extract,type,from,lambda,exec,lambda,output,type,argument,indices,param,len,base,parameters,len,else,output,exec,get,return,type,return,new,type,extractor,private,create,type,info,output,in,type,null,else,preconditions,check,argument,input,type,argument,index,0,input,type,argument,index,was,not,provided,preconditions,check,argument,output,type,argument,index,0,output,type,argument,index,was,not,provided,validate,input,type,base,class,function,get,class,input,type,argument,index,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,output,type,argument,index,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		int[] lambdaInputTypeArgumentIndices, 		int[] lambdaOutputTypeArgumentIndices, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1517320791;Returns the unary operator's return type.__<p><b>NOTE:</b> lambda type indices allow extraction of Type from lambdas. To extract input type <b>IN</b>_from the function given below one should pass {@code new int[] {0,1,0}} as lambdaInputTypeArgumentIndices.__<pre>_<code>_OUT apply(Map<String, List<IN>> value)_</code>_</pre>__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of input type in the class specification_@param outputTypeArgumentIndex Index of output type in the class specification_@param lambdaInputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param lambdaOutputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		int[] lambdaInputTypeArgumentIndices,_		int[] lambdaOutputTypeArgumentIndices,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				Preconditions.checkArgument(_					lambdaInputTypeArgumentIndices != null && lambdaInputTypeArgumentIndices.length >= 1,_					"Indices for input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaOutputTypeArgumentIndices != null,_					"Indices for output type arguments within lambda not provided")__				_				validateLambdaGenericParameters(exec)___				_				_				final int paramLen = exec.getParameterTypes().length___				final Method sam = TypeExtractionUtils.getSingleAbstractMethod(baseClass)___				_				final int baseParametersLen = sam.getParameterTypes().length___				_				if (paramLen <= 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaInputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__					validateInputType(input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}__				final Type output__				if (lambdaOutputTypeArgumentIndices.length > 0) {_					output = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaOutputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__				} else {_					output = exec.getReturnType()__				}__				return new TypeExtractor().privateCreateTypeInfo(output, inType, null)__			} else {_				Preconditions.checkArgument(inputTypeArgumentIndex >= 0, "Input type argument index was not provided")__				Preconditions.checkArgument(outputTypeArgumentIndex >= 0, "Output type argument index was not provided")__				validateInputType(baseClass, function.getClass(), inputTypeArgumentIndex, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), outputTypeArgumentIndex, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,p,b,note,b,lambda,type,indices,allow,extraction,of,type,from,lambdas,to,extract,input,type,b,in,b,from,the,function,given,below,one,should,pass,code,new,int,0,1,0,as,lambda,input,type,argument,indices,pre,code,out,apply,map,string,list,in,value,code,pre,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,input,type,in,the,class,specification,param,output,type,argument,index,index,of,output,type,in,the,class,specification,param,lambda,input,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,lambda,output,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,int,lambda,input,type,argument,indices,int,lambda,output,type,argument,indices,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,preconditions,check,argument,lambda,input,type,argument,indices,null,lambda,input,type,argument,indices,length,1,indices,for,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,output,type,argument,indices,null,indices,for,output,type,arguments,within,lambda,not,provided,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,final,method,sam,type,extraction,utils,get,single,abstract,method,base,class,final,int,base,parameters,len,sam,get,parameter,types,length,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,type,extraction,utils,extract,type,from,lambda,exec,lambda,input,type,argument,indices,param,len,base,parameters,len,validate,input,type,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,final,type,output,if,lambda,output,type,argument,indices,length,0,output,type,extraction,utils,extract,type,from,lambda,exec,lambda,output,type,argument,indices,param,len,base,parameters,len,else,output,exec,get,return,type,return,new,type,extractor,private,create,type,info,output,in,type,null,else,preconditions,check,argument,input,type,argument,index,0,input,type,argument,index,was,not,provided,preconditions,check,argument,output,type,argument,index,0,output,type,argument,index,was,not,provided,validate,input,type,base,class,function,get,class,input,type,argument,index,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,output,type,argument,index,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		int inputTypeArgumentIndex, 		int outputTypeArgumentIndex, 		int[] lambdaInputTypeArgumentIndices, 		int[] lambdaOutputTypeArgumentIndices, 		TypeInformation<IN> inType, 		String functionName, 		boolean allowMissing);1528874321;Returns the unary operator's return type.__<p><b>NOTE:</b> lambda type indices allow extraction of Type from lambdas. To extract input type <b>IN</b>_from the function given below one should pass {@code new int[] {0,1,0}} as lambdaInputTypeArgumentIndices.__<pre>_<code>_OUT apply(Map<String, List<IN>> value)_</code>_</pre>__@param function Function to extract the return type from_@param baseClass Base class of the function_@param inputTypeArgumentIndex Index of input type in the class specification_@param outputTypeArgumentIndex Index of output type in the class specification_@param lambdaInputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param lambdaOutputTypeArgumentIndices Table of indices of the type argument specifying the input type. See example._@param inType Type of the input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN> Input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN, OUT> TypeInformation<OUT> getUnaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		int inputTypeArgumentIndex,_		int outputTypeArgumentIndex,_		int[] lambdaInputTypeArgumentIndices,_		int[] lambdaOutputTypeArgumentIndices,_		TypeInformation<IN> inType,_		String functionName,_		boolean allowMissing) {_		try {_			final LambdaExecutable exec__			try {_				exec = checkAndExtractLambda(function)__			} catch (TypeExtractionException e) {_				throw new InvalidTypesException("Internal error occurred.", e)__			}_			if (exec != null) {_				Preconditions.checkArgument(_					lambdaInputTypeArgumentIndices != null && lambdaInputTypeArgumentIndices.length >= 1,_					"Indices for input type arguments within lambda not provided")__				Preconditions.checkArgument(_					lambdaOutputTypeArgumentIndices != null,_					"Indices for output type arguments within lambda not provided")__				_				validateLambdaGenericParameters(exec)___				_				_				final int paramLen = exec.getParameterTypes().length___				final Method sam = TypeExtractionUtils.getSingleAbstractMethod(baseClass)___				_				final int baseParametersLen = sam.getParameterTypes().length___				_				if (paramLen <= 0) {_					_					_					validateInputContainsExecutable(exec, inType)__				}_				else {_					final Type input = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaInputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__					validateInputType(input, inType)__				}__				if (function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}__				final Type output__				if (lambdaOutputTypeArgumentIndices.length > 0) {_					output = TypeExtractionUtils.extractTypeFromLambda(_						exec,_						lambdaOutputTypeArgumentIndices,_						paramLen,_						baseParametersLen)__				} else {_					output = exec.getReturnType()__				}__				return new TypeExtractor().privateCreateTypeInfo(output, inType, null)__			} else {_				Preconditions.checkArgument(inputTypeArgumentIndex >= 0, "Input type argument index was not provided")__				Preconditions.checkArgument(outputTypeArgumentIndex >= 0, "Output type argument index was not provided")__				validateInputType(baseClass, function.getClass(), inputTypeArgumentIndex, inType)__				if(function instanceof ResultTypeQueryable) {_					return ((ResultTypeQueryable<OUT>) function).getProducedType()__				}_				return new TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), outputTypeArgumentIndex, inType, null)__			}_		}_		catch (InvalidTypesException e) {_			if (allowMissing) {_				return (TypeInformation<OUT>) new MissingTypeInfo(functionName != null ? functionName : function.toString(), e)__			} else {_				throw e__			}_		}_	};returns,the,unary,operator,s,return,type,p,b,note,b,lambda,type,indices,allow,extraction,of,type,from,lambdas,to,extract,input,type,b,in,b,from,the,function,given,below,one,should,pass,code,new,int,0,1,0,as,lambda,input,type,argument,indices,pre,code,out,apply,map,string,list,in,value,code,pre,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,input,type,argument,index,index,of,input,type,in,the,class,specification,param,output,type,argument,index,index,of,output,type,in,the,class,specification,param,lambda,input,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,lambda,output,type,argument,indices,table,of,indices,of,the,type,argument,specifying,the,input,type,see,example,param,in,type,type,of,the,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in,out,type,information,out,get,unary,operator,return,type,function,function,class,base,class,int,input,type,argument,index,int,output,type,argument,index,int,lambda,input,type,argument,indices,int,lambda,output,type,argument,indices,type,information,in,in,type,string,function,name,boolean,allow,missing,try,final,lambda,executable,exec,try,exec,check,and,extract,lambda,function,catch,type,extraction,exception,e,throw,new,invalid,types,exception,internal,error,occurred,e,if,exec,null,preconditions,check,argument,lambda,input,type,argument,indices,null,lambda,input,type,argument,indices,length,1,indices,for,input,type,arguments,within,lambda,not,provided,preconditions,check,argument,lambda,output,type,argument,indices,null,indices,for,output,type,arguments,within,lambda,not,provided,validate,lambda,generic,parameters,exec,final,int,param,len,exec,get,parameter,types,length,final,method,sam,type,extraction,utils,get,single,abstract,method,base,class,final,int,base,parameters,len,sam,get,parameter,types,length,if,param,len,0,validate,input,contains,executable,exec,in,type,else,final,type,input,type,extraction,utils,extract,type,from,lambda,exec,lambda,input,type,argument,indices,param,len,base,parameters,len,validate,input,type,input,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,final,type,output,if,lambda,output,type,argument,indices,length,0,output,type,extraction,utils,extract,type,from,lambda,exec,lambda,output,type,argument,indices,param,len,base,parameters,len,else,output,exec,get,return,type,return,new,type,extractor,private,create,type,info,output,in,type,null,else,preconditions,check,argument,input,type,argument,index,0,input,type,argument,index,was,not,provided,preconditions,check,argument,output,type,argument,index,0,output,type,argument,index,was,not,provided,validate,input,type,base,class,function,get,class,input,type,argument,index,in,type,if,function,instanceof,result,type,queryable,return,result,type,queryable,out,function,get,produced,type,return,new,type,extractor,private,create,type,info,base,class,function,get,class,output,type,argument,index,in,type,null,catch,invalid,types,exception,e,if,allow,missing,return,type,information,out,new,missing,type,info,function,name,null,function,name,function,to,string,e,else,throw,e
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1454428544;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX or Either).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			_			if (definingType.getActualTypeArguments()[i] instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) definingType.getActualTypeArguments()[i])__			}_			_			else {_				subtypes[i] = definingType.getActualTypeArguments()[i]__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			ArrayList<Type> subTypeHierarchy = new ArrayList<Type>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__			}_		}__		Class<?> originalTypeAsClass = null__		if (isClassType(originalType)) {_			originalTypeAsClass = typeToClass(originalType)__		}_		Preconditions.checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__		_		_		_		int fieldCount = countFieldsInClass(originalTypeAsClass)__		if(fieldCount > subTypesInfo.length) {_			return null__		}_		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,or,either,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,if,defining,type,get,actual,type,arguments,i,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,defining,type,get,actual,type,arguments,i,else,subtypes,i,defining,type,get,actual,type,arguments,i,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,array,list,type,sub,type,hierarchy,new,array,list,type,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,preconditions,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1454679829;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX or Either).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			_			if (definingType.getActualTypeArguments()[i] instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) definingType.getActualTypeArguments()[i])__			}_			_			else {_				subtypes[i] = definingType.getActualTypeArguments()[i]__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			ArrayList<Type> subTypeHierarchy = new ArrayList<Type>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__			}_		}__		Class<?> originalTypeAsClass = null__		if (isClassType(originalType)) {_			originalTypeAsClass = typeToClass(originalType)__		}_		Preconditions.checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__		_		_		_		int fieldCount = countFieldsInClass(originalTypeAsClass)__		if(fieldCount > subTypesInfo.length) {_			return null__		}_		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,or,either,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,if,defining,type,get,actual,type,arguments,i,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,defining,type,get,actual,type,arguments,i,else,subtypes,i,defining,type,get,actual,type,arguments,i,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,array,list,type,sub,type,hierarchy,new,array,list,type,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,preconditions,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1455101486;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX or Either).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			_			if (definingType.getActualTypeArguments()[i] instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) definingType.getActualTypeArguments()[i])__			}_			_			else {_				subtypes[i] = definingType.getActualTypeArguments()[i]__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			ArrayList<Type> subTypeHierarchy = new ArrayList<Type>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__			}_		}__		Class<?> originalTypeAsClass = null__		if (isClassType(originalType)) {_			originalTypeAsClass = typeToClass(originalType)__		}_		Preconditions.checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__		_		_		_		int fieldCount = countFieldsInClass(originalTypeAsClass)__		if(fieldCount > subTypesInfo.length) {_			return null__		}_		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,or,either,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,if,defining,type,get,actual,type,arguments,i,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,defining,type,get,actual,type,arguments,i,else,subtypes,i,defining,type,get,actual,type,arguments,i,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,array,list,type,sub,type,hierarchy,new,array,list,type,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,preconditions,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1457121513;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX or Either).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			_			if (definingType.getActualTypeArguments()[i] instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) definingType.getActualTypeArguments()[i])__			}_			_			else {_				subtypes[i] = definingType.getActualTypeArguments()[i]__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			ArrayList<Type> subTypeHierarchy = new ArrayList<Type>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__			}_		}__		Class<?> originalTypeAsClass = null__		if (isClassType(originalType)) {_			originalTypeAsClass = typeToClass(originalType)__		}_		Preconditions.checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__		_		_		_		int fieldCount = countFieldsInClass(originalTypeAsClass)__		if(fieldCount > subTypesInfo.length) {_			return null__		}_		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,or,either,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,if,defining,type,get,actual,type,arguments,i,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,defining,type,get,actual,type,arguments,i,else,subtypes,i,defining,type,get,actual,type,arguments,i,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,array,list,type,sub,type,hierarchy,new,array,list,type,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,preconditions,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1458651238;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX or Either).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			_			if (definingType.getActualTypeArguments()[i] instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) definingType.getActualTypeArguments()[i])__			}_			_			else {_				subtypes[i] = definingType.getActualTypeArguments()[i]__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			ArrayList<Type> subTypeHierarchy = new ArrayList<Type>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__			}_		}__		Class<?> originalTypeAsClass = null__		if (isClassType(originalType)) {_			originalTypeAsClass = typeToClass(originalType)__		}_		Preconditions.checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__		_		_		_		int fieldCount = countFieldsInClass(originalTypeAsClass)__		if(fieldCount > subTypesInfo.length) {_			return null__		}_		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,or,either,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,if,defining,type,get,actual,type,arguments,i,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,defining,type,get,actual,type,arguments,i,else,subtypes,i,defining,type,get,actual,type,arguments,i,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,array,list,type,sub,type,hierarchy,new,array,list,type,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,preconditions,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1459358321;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX or Either).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			_			if (definingType.getActualTypeArguments()[i] instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) definingType.getActualTypeArguments()[i])__			}_			_			else {_				subtypes[i] = definingType.getActualTypeArguments()[i]__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			ArrayList<Type> subTypeHierarchy = new ArrayList<Type>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__			}_		}__		Class<?> originalTypeAsClass = null__		if (isClassType(originalType)) {_			originalTypeAsClass = typeToClass(originalType)__		}_		Preconditions.checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__		_		_		_		int fieldCount = countFieldsInClass(originalTypeAsClass)__		if(fieldCount > subTypesInfo.length) {_			return null__		}_		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,or,either,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,if,defining,type,get,actual,type,arguments,i,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,defining,type,get,actual,type,arguments,i,else,subtypes,i,defining,type,get,actual,type,arguments,i,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,array,list,type,sub,type,hierarchy,new,array,list,type,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,preconditions,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1460741894;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX or Either).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			_			if (definingType.getActualTypeArguments()[i] instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) definingType.getActualTypeArguments()[i])__			}_			_			else {_				subtypes[i] = definingType.getActualTypeArguments()[i]__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			ArrayList<Type> subTypeHierarchy = new ArrayList<Type>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__			}_		}__		Class<?> originalTypeAsClass = null__		if (isClassType(originalType)) {_			originalTypeAsClass = typeToClass(originalType)__		}_		checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__		_		_		_		int fieldCount = countFieldsInClass(originalTypeAsClass)__		if(fieldCount > subTypesInfo.length) {_			return null__		}_		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,or,either,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,if,defining,type,get,actual,type,arguments,i,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,defining,type,get,actual,type,arguments,i,else,subtypes,i,defining,type,get,actual,type,arguments,i,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,array,list,type,sub,type,hierarchy,new,array,list,type,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1463093178;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX or Either).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			_			if (definingType.getActualTypeArguments()[i] instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) definingType.getActualTypeArguments()[i])__			}_			_			else {_				subtypes[i] = definingType.getActualTypeArguments()[i]__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			ArrayList<Type> subTypeHierarchy = new ArrayList<Type>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__			}_		}__		Class<?> originalTypeAsClass = null__		if (isClassType(originalType)) {_			originalTypeAsClass = typeToClass(originalType)__		}_		checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__		_		_		_		int fieldCount = countFieldsInClass(originalTypeAsClass)__		if(fieldCount > subTypesInfo.length) {_			return null__		}_		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,or,either,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,if,defining,type,get,actual,type,arguments,i,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,defining,type,get,actual,type,arguments,i,else,subtypes,i,defining,type,get,actual,type,arguments,i,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,array,list,type,sub,type,hierarchy,new,array,list,type,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1463730991;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX or Either).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			_			if (definingType.getActualTypeArguments()[i] instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) definingType.getActualTypeArguments()[i])__			}_			_			else {_				subtypes[i] = definingType.getActualTypeArguments()[i]__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			ArrayList<Type> subTypeHierarchy = new ArrayList<Type>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__			}_		}__		Class<?> originalTypeAsClass = null__		if (isClassType(originalType)) {_			originalTypeAsClass = typeToClass(originalType)__		}_		checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__		_		_		_		int fieldCount = countFieldsInClass(originalTypeAsClass)__		if(fieldCount > subTypesInfo.length) {_			return null__		}_		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,or,either,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,if,defining,type,get,actual,type,arguments,i,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,defining,type,get,actual,type,arguments,i,else,subtypes,i,defining,type,get,actual,type,arguments,i,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,array,list,type,sub,type,hierarchy,new,array,list,type,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1465391830;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX or Either).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			_			if (definingType.getActualTypeArguments()[i] instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) definingType.getActualTypeArguments()[i])__			}_			_			else {_				subtypes[i] = definingType.getActualTypeArguments()[i]__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			ArrayList<Type> subTypeHierarchy = new ArrayList<Type>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__			}_		}__		Class<?> originalTypeAsClass = null__		if (isClassType(originalType)) {_			originalTypeAsClass = typeToClass(originalType)__		}_		checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__		_		_		_		int fieldCount = countFieldsInClass(originalTypeAsClass)__		if(fieldCount > subTypesInfo.length) {_			return null__		}_		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,or,either,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,if,defining,type,get,actual,type,arguments,i,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,defining,type,get,actual,type,arguments,i,else,subtypes,i,defining,type,get,actual,type,arguments,i,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,array,list,type,sub,type,hierarchy,new,array,list,type,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1470647505;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX or Either).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			_			if (definingType.getActualTypeArguments()[i] instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) definingType.getActualTypeArguments()[i])__			}_			_			else {_				subtypes[i] = definingType.getActualTypeArguments()[i]__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			ArrayList<Type> subTypeHierarchy = new ArrayList<Type>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__			}_		}__		Class<?> originalTypeAsClass = null__		if (isClassType(originalType)) {_			originalTypeAsClass = typeToClass(originalType)__		}_		checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__		_		_		_		int fieldCount = countFieldsInClass(originalTypeAsClass)__		if(fieldCount > subTypesInfo.length) {_			return null__		}_		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,or,either,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,if,defining,type,get,actual,type,arguments,i,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,defining,type,get,actual,type,arguments,i,else,subtypes,i,defining,type,get,actual,type,arguments,i,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,array,list,type,sub,type,hierarchy,new,array,list,type,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType, 			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type);1470775474;Creates the TypeInformation for all elements of a type that expects a certain number of_subtypes (e.g. TupleXX or Either).__@param originalType most concrete subclass_@param definingType type that defines the number of subtypes (e.g. Tuple2 -> 2 subtypes)_@param typeHierarchy necessary for type inference_@param in1Type necessary for type inference_@param in2Type necessary for type inference_@return array containing TypeInformation of sub types or null if definingType contains_more subtypes (fields) that defined;private <IN1, IN2> TypeInformation<?>[] createSubTypesInfo(Type originalType, ParameterizedType definingType,_			ArrayList<Type> typeHierarchy, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {_		Type[] subtypes = new Type[definingType.getActualTypeArguments().length]___		_		for (int i = 0_ i < subtypes.length_ i++) {_			_			if (definingType.getActualTypeArguments()[i] instanceof TypeVariable<?>) {_				subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) definingType.getActualTypeArguments()[i])__			}_			_			else {_				subtypes[i] = definingType.getActualTypeArguments()[i]__			}_		}__		TypeInformation<?>[] subTypesInfo = new TypeInformation<?>[subtypes.length]__		for (int i = 0_ i < subtypes.length_ i++) {_			ArrayList<Type> subTypeHierarchy = new ArrayList<Type>(typeHierarchy)__			subTypeHierarchy.add(subtypes[i])__			_			_			if (subtypes[i] instanceof TypeVariable<?>) {_				subTypesInfo[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type)___				_				if (subTypesInfo[i] == null) {_					throw new InvalidTypesException("Type of TypeVariable '" + ((TypeVariable<?>) subtypes[i]).getName() + "' in '"_							+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()_							+ "' could not be determined. This is most likely a type erasure problem. "_							+ "The type extraction currently supports types with generic variables only in cases where "_							+ "all variables in the return type can be deduced from the input type(s).")__				}_			} else {_				subTypesInfo[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)__			}_		}__		Class<?> originalTypeAsClass = null__		if (isClassType(originalType)) {_			originalTypeAsClass = typeToClass(originalType)__		}_		checkNotNull(originalTypeAsClass, "originalType has an unexpected type")__		_		_		_		int fieldCount = countFieldsInClass(originalTypeAsClass)__		if(fieldCount > subTypesInfo.length) {_			return null__		}_		return subTypesInfo__	};creates,the,type,information,for,all,elements,of,a,type,that,expects,a,certain,number,of,subtypes,e,g,tuple,xx,or,either,param,original,type,most,concrete,subclass,param,defining,type,type,that,defines,the,number,of,subtypes,e,g,tuple2,2,subtypes,param,type,hierarchy,necessary,for,type,inference,param,in1type,necessary,for,type,inference,param,in2type,necessary,for,type,inference,return,array,containing,type,information,of,sub,types,or,null,if,defining,type,contains,more,subtypes,fields,that,defined;private,in1,in2,type,information,create,sub,types,info,type,original,type,parameterized,type,defining,type,array,list,type,type,hierarchy,type,information,in1,in1type,type,information,in2,in2type,type,subtypes,new,type,defining,type,get,actual,type,arguments,length,for,int,i,0,i,subtypes,length,i,if,defining,type,get,actual,type,arguments,i,instanceof,type,variable,subtypes,i,materialize,type,variable,type,hierarchy,type,variable,defining,type,get,actual,type,arguments,i,else,subtypes,i,defining,type,get,actual,type,arguments,i,type,information,sub,types,info,new,type,information,subtypes,length,for,int,i,0,i,subtypes,length,i,array,list,type,sub,type,hierarchy,new,array,list,type,type,hierarchy,sub,type,hierarchy,add,subtypes,i,if,subtypes,i,instanceof,type,variable,sub,types,info,i,create,type,info,from,inputs,type,variable,subtypes,i,sub,type,hierarchy,in1type,in2type,if,sub,types,info,i,null,throw,new,invalid,types,exception,type,of,type,variable,type,variable,subtypes,i,get,name,in,type,variable,subtypes,i,get,generic,declaration,could,not,be,determined,this,is,most,likely,a,type,erasure,problem,the,type,extraction,currently,supports,types,with,generic,variables,only,in,cases,where,all,variables,in,the,return,type,can,be,deduced,from,the,input,type,s,else,sub,types,info,i,create,type,info,with,type,hierarchy,sub,type,hierarchy,subtypes,i,in1type,in2type,class,original,type,as,class,null,if,is,class,type,original,type,original,type,as,class,type,to,class,original,type,check,not,null,original,type,as,class,original,type,has,an,unexpected,type,int,field,count,count,fields,in,class,original,type,as,class,if,field,count,sub,types,info,length,return,null,return,sub,types,info
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1459358321;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1460741894;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1463093178;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1463730991;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1465391830;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1470647505;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1470775474;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1474459924;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1476262965;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1479218219;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1480354098;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1484056358;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1484078188;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1484924697;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1485118420;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1494349925;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1494363409;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> @SuppressWarnings("unchecked") 	@PublicEvolving 	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType( 		Function function, 		Class<?> baseClass, 		boolean hasIterables, 		boolean hasCollector, 		TypeInformation<IN1> in1Type, 		TypeInformation<IN2> in2Type, 		String functionName, 		boolean allowMissing);1494598316;Returns the binary operator's return type.__@param function Function to extract the return type from_@param baseClass Base class of the function_@param hasIterables True if the first function parameter is an iterable, otherwise false_@param hasCollector True if the function has an additional collector parameter, otherwise false_@param in1Type Type of the left side input elements (In case of an iterable, it is the element type)_@param in2Type Type of the right side input elements (In case of an iterable, it is the element type)_@param functionName Function name_@param allowMissing Can the type information be missing_@param <IN1> Left side input type_@param <IN2> Right side input type_@param <OUT> Output type_@return TypeInformation of the return type of the function;@SuppressWarnings("unchecked")_	@PublicEvolving_	public static <IN1, IN2, OUT> TypeInformation<OUT> getBinaryOperatorReturnType(_		Function function,_		Class<?> baseClass,_		boolean hasIterables,_		boolean hasCollector,_		TypeInformation<IN1> in1Type,_		TypeInformation<IN2> in2Type,_		String functionName,_		boolean allowMissing) {__		return getBinaryOperatorReturnType(_			function,_			baseClass,_			hasIterables ? 0 : -1,_			hasCollector ? 0 : -1,_			in1Type,_			in2Type,_			functionName,_			allowMissing_		)__	};returns,the,binary,operator,s,return,type,param,function,function,to,extract,the,return,type,from,param,base,class,base,class,of,the,function,param,has,iterables,true,if,the,first,function,parameter,is,an,iterable,otherwise,false,param,has,collector,true,if,the,function,has,an,additional,collector,parameter,otherwise,false,param,in1type,type,of,the,left,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,in2type,type,of,the,right,side,input,elements,in,case,of,an,iterable,it,is,the,element,type,param,function,name,function,name,param,allow,missing,can,the,type,information,be,missing,param,in1,left,side,input,type,param,in2,right,side,input,type,param,out,output,type,return,type,information,of,the,return,type,of,the,function;suppress,warnings,unchecked,public,evolving,public,static,in1,in2,out,type,information,out,get,binary,operator,return,type,function,function,class,base,class,boolean,has,iterables,boolean,has,collector,type,information,in1,in1type,type,information,in2,in2type,string,function,name,boolean,allow,missing,return,get,binary,operator,return,type,function,base,class,has,iterables,0,1,has,collector,0,1,in1type,in2type,function,name,allow,missing
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1474459924;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1476262965;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1479218219;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1480354098;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1484056358;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1484078188;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1484924697;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1485118420;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1494349925;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1494363409;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1494598316;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1496911361;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1509723634;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1509723634;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1511902791;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1515177485;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1517320791;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1528874321;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t);1532066767;Traverses the type hierarchy up until a type information factory can be found.__@param typeHierarchy hierarchy to be filled while traversing up_@param t type for which a factory needs to be found_@return closest type information factory or null if there is no factory in the type hierarchy;private static <OUT> TypeInfoFactory<? super OUT> getClosestFactory(ArrayList<Type> typeHierarchy, Type t) {_		TypeInfoFactory factory = null__		while (factory == null && isClassType(t) && !(typeToClass(t).equals(Object.class))) {_			typeHierarchy.add(t)__			factory = getTypeInfoFactory(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return factory__	};traverses,the,type,hierarchy,up,until,a,type,information,factory,can,be,found,param,type,hierarchy,hierarchy,to,be,filled,while,traversing,up,param,t,type,for,which,a,factory,needs,to,be,found,return,closest,type,information,factory,or,null,if,there,is,no,factory,in,the,type,hierarchy;private,static,out,type,info,factory,super,out,get,closest,factory,array,list,type,type,hierarchy,type,t,type,info,factory,factory,null,while,factory,null,is,class,type,t,type,to,class,t,equals,object,class,type,hierarchy,add,t,factory,get,type,info,factory,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,factory
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz);1455101486;recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,throw,new,runtime,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz);1457121513;recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,throw,new,runtime,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz);1458651238;recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,throw,new,runtime,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz);1459358321;recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,throw,new,runtime,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz);1460741894;recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,throw,new,runtime,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz);1463093178;recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,throw,new,runtime,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz);1463730991;recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,throw,new,runtime,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz);1465391830;recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,throw,new,runtime,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz);1470647505;recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,throw,new,runtime,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz);1470775474;recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,throw,new,runtime,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz);1474459924;recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,throw,new,runtime,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz);1476262965;recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,throw,new,runtime,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz);1479218219;recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,throw,new,runtime,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz);1480354098;recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,throw,new,runtime,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz);1484056358;recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,throw,new,runtime,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> @PublicEvolving 	public static List<Field> getAllDeclaredFields(Class<?> clazz);1484078188;recursively determine all declared fields_This is required because class.getFields() is not returning fields defined_in parent classes.;@PublicEvolving_	public static List<Field> getAllDeclaredFields(Class<?> clazz) {_		List<Field> result = new ArrayList<Field>()__		while (clazz != null) {_			Field[] fields = clazz.getDeclaredFields()__			for (Field field : fields) {_				if(Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {_					continue_ _				}_				if(hasFieldWithSameName(field.getName(), result)) {_					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."_							+ "Please use unique field names through your classes hierarchy")__				}_				result.add(field)__			}_			clazz = clazz.getSuperclass()__		}_		return result__	};recursively,determine,all,declared,fields,this,is,required,because,class,get,fields,is,not,returning,fields,defined,in,parent,classes;public,evolving,public,static,list,field,get,all,declared,fields,class,clazz,list,field,result,new,array,list,field,while,clazz,null,field,fields,clazz,get,declared,fields,for,field,field,fields,if,modifier,is,transient,field,get,modifiers,modifier,is,static,field,get,modifiers,continue,if,has,field,with,same,name,field,get,name,result,throw,new,runtime,exception,the,field,field,is,already,contained,in,the,hierarchy,of,the,clazz,please,use,unique,field,names,through,your,classes,hierarchy,result,add,field,clazz,clazz,get,superclass,return,result
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1454428544;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1454679829;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1455101486;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1457121513;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1458651238;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1459358321;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1460741894;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1463093178;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1463730991;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1465391830;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1470647505;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1470775474;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1474459924;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1476262965;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1479218219;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1480354098;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1484056358;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1484078188;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1484924697;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1485118420;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1494349925;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1494363409;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1494598316;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)__			_			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())__				_				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {_					_					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]__					_					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]__						_						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1496911361;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)___			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())___				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {__					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]___					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]___						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1509723634;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)___			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())___				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {__					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]___					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]___						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1509723634;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)___			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())___				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {__					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]___					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]___						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1511902791;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)___			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())___				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {__					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]___					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]___						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1515177485;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)___			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())___				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {__					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]___					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]___						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1517320791;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)___			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())___				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {__					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]___					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]___						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1528874321;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)___			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())___				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {__					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]___					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]___						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar);1532066767;Tries to find a concrete value (Class, ParameterizedType etc. ) for a TypeVariable by traversing the type hierarchy downwards._If a value could not be found it will return the most bottom type variable in the hierarchy.;private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeVariable<?> typeVar) {_		TypeVariable<?> inTypeTypeVar = typeVar__		_		for (int i = typeHierarchy.size() - 1_ i >= 0_ i--) {_			Type curT = typeHierarchy.get(i)___			_			if (curT instanceof ParameterizedType) {_				Class<?> rawType = ((Class<?>) ((ParameterizedType) curT).getRawType())___				for (int paramIndex = 0_ paramIndex < rawType.getTypeParameters().length_ paramIndex++) {__					TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex]___					_					if (sameTypeVars(curVarOfCurT, inTypeTypeVar)) {_						Type curVarType = ((ParameterizedType) curT).getActualTypeArguments()[paramIndex]___						_						if (curVarType instanceof TypeVariable<?>) {_							inTypeTypeVar = (TypeVariable<?>) curVarType__						}_						_						else {_							return curVarType__						}_					}_				}_			}_		}_		_		_		return inTypeTypeVar__	};tries,to,find,a,concrete,value,class,parameterized,type,etc,for,a,type,variable,by,traversing,the,type,hierarchy,downwards,if,a,value,could,not,be,found,it,will,return,the,most,bottom,type,variable,in,the,hierarchy;private,static,type,materialize,type,variable,array,list,type,type,hierarchy,type,variable,type,var,type,variable,in,type,type,var,type,var,for,int,i,type,hierarchy,size,1,i,0,i,type,cur,t,type,hierarchy,get,i,if,cur,t,instanceof,parameterized,type,class,raw,type,class,parameterized,type,cur,t,get,raw,type,for,int,param,index,0,param,index,raw,type,get,type,parameters,length,param,index,type,variable,cur,var,of,cur,t,raw,type,get,type,parameters,param,index,if,same,type,vars,cur,var,of,cur,t,in,type,type,var,type,cur,var,type,parameterized,type,cur,t,get,actual,type,arguments,param,index,if,cur,var,type,instanceof,type,variable,in,type,type,var,type,variable,cur,var,type,else,return,cur,var,type,return,in,type,type,var
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1454428544;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type))) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1454679829;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type))) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1455101486;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type))) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1457121513;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type))) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1458651238;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type))) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1459358321;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type))) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1460741894;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type))) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1463093178;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type))) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1463730991;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type))) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1465391830;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1470647505;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1470775474;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1474459924;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1476262965;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1479218219;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1480354098;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1484056358;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1484078188;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1484924697;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1485118420;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1494349925;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1494363409;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1494598316;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1496911361;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1509723634;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1509723634;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1511902791;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1515177485;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1517320791;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1528874321;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type);1532066767;@return number of items with equal type or same raw type;private static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {_		int count = 0__		for (Type t : typeHierarchy) {_			if (t == type || (isClassType(type) && t == typeToClass(type)) || (isClassType(t) && typeToClass(t) == type)) {_				count++__			}_		}_		return count__	};return,number,of,items,with,equal,type,or,same,raw,type;private,static,int,count,type,in,hierarchy,array,list,type,type,hierarchy,type,type,int,count,0,for,type,t,type,hierarchy,if,t,type,is,class,type,type,t,type,to,class,type,is,class,type,t,type,to,class,t,type,count,return,count
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass);1474459924;Traverses the type hierarchy of a type up until a certain stop class is found.__@param t type for which a hierarchy need to be created_@return type of the immediate child of the stop class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass) {_		while (!(isClassType(t) && typeToClass(t).equals(stopAtClass))) {_			typeHierarchy.add(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return t__	};traverses,the,type,hierarchy,of,a,type,up,until,a,certain,stop,class,is,found,param,t,type,for,which,a,hierarchy,need,to,be,created,return,type,of,the,immediate,child,of,the,stop,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,t,class,stop,at,class,while,is,class,type,t,type,to,class,t,equals,stop,at,class,type,hierarchy,add,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass);1476262965;Traverses the type hierarchy of a type up until a certain stop class is found.__@param t type for which a hierarchy need to be created_@return type of the immediate child of the stop class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass) {_		while (!(isClassType(t) && typeToClass(t).equals(stopAtClass))) {_			typeHierarchy.add(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return t__	};traverses,the,type,hierarchy,of,a,type,up,until,a,certain,stop,class,is,found,param,t,type,for,which,a,hierarchy,need,to,be,created,return,type,of,the,immediate,child,of,the,stop,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,t,class,stop,at,class,while,is,class,type,t,type,to,class,t,equals,stop,at,class,type,hierarchy,add,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass);1479218219;Traverses the type hierarchy of a type up until a certain stop class is found.__@param t type for which a hierarchy need to be created_@return type of the immediate child of the stop class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass) {_		while (!(isClassType(t) && typeToClass(t).equals(stopAtClass))) {_			typeHierarchy.add(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return t__	};traverses,the,type,hierarchy,of,a,type,up,until,a,certain,stop,class,is,found,param,t,type,for,which,a,hierarchy,need,to,be,created,return,type,of,the,immediate,child,of,the,stop,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,t,class,stop,at,class,while,is,class,type,t,type,to,class,t,equals,stop,at,class,type,hierarchy,add,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass);1480354098;Traverses the type hierarchy of a type up until a certain stop class is found.__@param t type for which a hierarchy need to be created_@return type of the immediate child of the stop class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass) {_		while (!(isClassType(t) && typeToClass(t).equals(stopAtClass))) {_			typeHierarchy.add(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return t__	};traverses,the,type,hierarchy,of,a,type,up,until,a,certain,stop,class,is,found,param,t,type,for,which,a,hierarchy,need,to,be,created,return,type,of,the,immediate,child,of,the,stop,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,t,class,stop,at,class,while,is,class,type,t,type,to,class,t,equals,stop,at,class,type,hierarchy,add,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass);1484056358;Traverses the type hierarchy of a type up until a certain stop class is found.__@param t type for which a hierarchy need to be created_@return type of the immediate child of the stop class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass) {_		while (!(isClassType(t) && typeToClass(t).equals(stopAtClass))) {_			typeHierarchy.add(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return t__	};traverses,the,type,hierarchy,of,a,type,up,until,a,certain,stop,class,is,found,param,t,type,for,which,a,hierarchy,need,to,be,created,return,type,of,the,immediate,child,of,the,stop,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,t,class,stop,at,class,while,is,class,type,t,type,to,class,t,equals,stop,at,class,type,hierarchy,add,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass);1484078188;Traverses the type hierarchy of a type up until a certain stop class is found.__@param t type for which a hierarchy need to be created_@return type of the immediate child of the stop class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass) {_		while (!(isClassType(t) && typeToClass(t).equals(stopAtClass))) {_			typeHierarchy.add(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return t__	};traverses,the,type,hierarchy,of,a,type,up,until,a,certain,stop,class,is,found,param,t,type,for,which,a,hierarchy,need,to,be,created,return,type,of,the,immediate,child,of,the,stop,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,t,class,stop,at,class,while,is,class,type,t,type,to,class,t,equals,stop,at,class,type,hierarchy,add,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass);1484924697;Traverses the type hierarchy of a type up until a certain stop class is found.__@param t type for which a hierarchy need to be created_@return type of the immediate child of the stop class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass) {_		while (!(isClassType(t) && typeToClass(t).equals(stopAtClass))) {_			typeHierarchy.add(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return t__	};traverses,the,type,hierarchy,of,a,type,up,until,a,certain,stop,class,is,found,param,t,type,for,which,a,hierarchy,need,to,be,created,return,type,of,the,immediate,child,of,the,stop,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,t,class,stop,at,class,while,is,class,type,t,type,to,class,t,equals,stop,at,class,type,hierarchy,add,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass);1485118420;Traverses the type hierarchy of a type up until a certain stop class is found.__@param t type for which a hierarchy need to be created_@return type of the immediate child of the stop class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass) {_		while (!(isClassType(t) && typeToClass(t).equals(stopAtClass))) {_			typeHierarchy.add(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return t__	};traverses,the,type,hierarchy,of,a,type,up,until,a,certain,stop,class,is,found,param,t,type,for,which,a,hierarchy,need,to,be,created,return,type,of,the,immediate,child,of,the,stop,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,t,class,stop,at,class,while,is,class,type,t,type,to,class,t,equals,stop,at,class,type,hierarchy,add,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass);1494349925;Traverses the type hierarchy of a type up until a certain stop class is found.__@param t type for which a hierarchy need to be created_@return type of the immediate child of the stop class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass) {_		while (!(isClassType(t) && typeToClass(t).equals(stopAtClass))) {_			typeHierarchy.add(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return t__	};traverses,the,type,hierarchy,of,a,type,up,until,a,certain,stop,class,is,found,param,t,type,for,which,a,hierarchy,need,to,be,created,return,type,of,the,immediate,child,of,the,stop,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,t,class,stop,at,class,while,is,class,type,t,type,to,class,t,equals,stop,at,class,type,hierarchy,add,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass);1494363409;Traverses the type hierarchy of a type up until a certain stop class is found.__@param t type for which a hierarchy need to be created_@return type of the immediate child of the stop class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass) {_		while (!(isClassType(t) && typeToClass(t).equals(stopAtClass))) {_			typeHierarchy.add(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return t__	};traverses,the,type,hierarchy,of,a,type,up,until,a,certain,stop,class,is,found,param,t,type,for,which,a,hierarchy,need,to,be,created,return,type,of,the,immediate,child,of,the,stop,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,t,class,stop,at,class,while,is,class,type,t,type,to,class,t,equals,stop,at,class,type,hierarchy,add,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass);1494598316;Traverses the type hierarchy of a type up until a certain stop class is found.__@param t type for which a hierarchy need to be created_@return type of the immediate child of the stop class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass) {_		while (!(isClassType(t) && typeToClass(t).equals(stopAtClass))) {_			typeHierarchy.add(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return t__	};traverses,the,type,hierarchy,of,a,type,up,until,a,certain,stop,class,is,found,param,t,type,for,which,a,hierarchy,need,to,be,created,return,type,of,the,immediate,child,of,the,stop,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,t,class,stop,at,class,while,is,class,type,t,type,to,class,t,equals,stop,at,class,type,hierarchy,add,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,t
TypeExtractor -> private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass);1496911361;Traverses the type hierarchy of a type up until a certain stop class is found.__@param t type for which a hierarchy need to be created_@return type of the immediate child of the stop class;private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, Class<?> stopAtClass) {_		while (!(isClassType(t) && typeToClass(t).equals(stopAtClass))) {_			typeHierarchy.add(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return t__	};traverses,the,type,hierarchy,of,a,type,up,until,a,certain,stop,class,is,found,param,t,type,for,which,a,hierarchy,need,to,be,created,return,type,of,the,immediate,child,of,the,stop,class;private,static,type,get,type,hierarchy,array,list,type,type,hierarchy,type,t,class,stop,at,class,while,is,class,type,t,type,to,class,t,equals,stop,at,class,type,hierarchy,add,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,t
