# id;timestamp;commentText;codeText;commentWords;codeWords
KeyedStateStore -> @PublicEvolving 	<UK, UV> MapState<UK,UV> getMapState(MapStateDescriptor<UK, UV> stateProperties)_;1487865389;Gets a handle to the system's key/value map state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_is composed of user-defined key-value pairs__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private MapState<MyType, Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getMapState(_new MapStateDescriptor<>("sum", MyType.class, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_return new Tuple2<>(value, state.get(value))___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <UK> The type of the user keys stored in the state._@param <UV> The type of the user values stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<UK, UV> MapState<UK,UV> getMapState(MapStateDescriptor<UK, UV> stateProperties)_;gets,a,handle,to,the,system,s,key,value,map,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,is,composed,of,user,defined,key,value,pairs,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,map,state,my,type,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,map,state,new,map,state,descriptor,sum,my,type,class,long,class,public,tuple2,my,type,long,map,my,type,value,return,new,tuple2,value,state,get,value,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,uk,the,type,of,the,user,keys,stored,in,the,state,param,uv,the,type,of,the,user,values,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,uk,uv,map,state,uk,uv,get,map,state,map,state,descriptor,uk,uv,state,properties
KeyedStateStore -> @PublicEvolving 	<UK, UV> MapState<UK,UV> getMapState(MapStateDescriptor<UK, UV> stateProperties)_;1494363409;Gets a handle to the system's key/value map state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_is composed of user-defined key-value pairs__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private MapState<MyType, Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getMapState(_new MapStateDescriptor<>("sum", MyType.class, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_return new Tuple2<>(value, state.get(value))___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <UK> The type of the user keys stored in the state._@param <UV> The type of the user values stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<UK, UV> MapState<UK,UV> getMapState(MapStateDescriptor<UK, UV> stateProperties)_;gets,a,handle,to,the,system,s,key,value,map,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,is,composed,of,user,defined,key,value,pairs,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,map,state,my,type,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,map,state,new,map,state,descriptor,sum,my,type,class,long,class,public,tuple2,my,type,long,map,my,type,value,return,new,tuple2,value,state,get,value,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,uk,the,type,of,the,user,keys,stored,in,the,state,param,uv,the,type,of,the,user,values,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,uk,uv,map,state,uk,uv,get,map,state,map,state,descriptor,uk,uv,state,properties
KeyedStateStore -> @PublicEvolving 	<UK, UV> MapState<UK,UV> getMapState(MapStateDescriptor<UK, UV> stateProperties)_;1508481109;Gets a handle to the system's key/value map state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_is composed of user-defined key-value pairs__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private MapState<MyType, Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getMapState(_new MapStateDescriptor<>("sum", MyType.class, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_return new Tuple2<>(value, state.get(value))___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <UK> The type of the user keys stored in the state._@param <UV> The type of the user values stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<UK, UV> MapState<UK,UV> getMapState(MapStateDescriptor<UK, UV> stateProperties)_;gets,a,handle,to,the,system,s,key,value,map,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,is,composed,of,user,defined,key,value,pairs,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,map,state,my,type,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,map,state,new,map,state,descriptor,sum,my,type,class,long,class,public,tuple2,my,type,long,map,my,type,value,return,new,tuple2,value,state,get,value,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,uk,the,type,of,the,user,keys,stored,in,the,state,param,uv,the,type,of,the,user,values,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,uk,uv,map,state,uk,uv,get,map,state,map,state,descriptor,uk,uv,state,properties
KeyedStateStore -> @PublicEvolving 	<UK, UV> MapState<UK,UV> getMapState(MapStateDescriptor<UK, UV> stateProperties)_;1509016418;Gets a handle to the system's key/value map state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_is composed of user-defined key-value pairs__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private MapState<MyType, Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getMapState(_new MapStateDescriptor<>("sum", MyType.class, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_return new Tuple2<>(value, state.get(value))___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <UK> The type of the user keys stored in the state._@param <UV> The type of the user values stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<UK, UV> MapState<UK,UV> getMapState(MapStateDescriptor<UK, UV> stateProperties)_;gets,a,handle,to,the,system,s,key,value,map,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,is,composed,of,user,defined,key,value,pairs,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,map,state,my,type,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,map,state,new,map,state,descriptor,sum,my,type,class,long,class,public,tuple2,my,type,long,map,my,type,value,return,new,tuple2,value,state,get,value,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,uk,the,type,of,the,user,keys,stored,in,the,state,param,uv,the,type,of,the,user,values,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,uk,uv,map,state,uk,uv,get,map,state,map,state,descriptor,uk,uv,state,properties
KeyedStateStore -> @PublicEvolving 	<UK, UV> MapState<UK,UV> getMapState(MapStateDescriptor<UK, UV> stateProperties)_;1513160461;Gets a handle to the system's key/value map state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_is composed of user-defined key-value pairs__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private MapState<MyType, Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getMapState(_new MapStateDescriptor<>("sum", MyType.class, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_return new Tuple2<>(value, state.get(value))___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <UK> The type of the user keys stored in the state._@param <UV> The type of the user values stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<UK, UV> MapState<UK,UV> getMapState(MapStateDescriptor<UK, UV> stateProperties)_;gets,a,handle,to,the,system,s,key,value,map,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,is,composed,of,user,defined,key,value,pairs,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,map,state,my,type,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,map,state,new,map,state,descriptor,sum,my,type,class,long,class,public,tuple2,my,type,long,map,my,type,value,return,new,tuple2,value,state,get,value,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,uk,the,type,of,the,user,keys,stored,in,the,state,param,uv,the,type,of,the,user,values,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,uk,uv,map,state,uk,uv,get,map,state,map,state,descriptor,uk,uv,state,properties
KeyedStateStore -> @PublicEvolving 	@Deprecated 	<T, ACC> FoldingState<T, ACC> getFoldingState(FoldingStateDescriptor<T, ACC> stateProperties)_;1494363409;Gets a handle to the system's key/value folding state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values with different types.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private FoldingState<MyType, Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getReducingState(_new FoldingStateDescriptor<>("sum", 0L, (a, b) -> a.count() + b, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value)__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).__@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	<T, ACC> FoldingState<T, ACC> getFoldingState(FoldingStateDescriptor<T, ACC> stateProperties)_;gets,a,handle,to,the,system,s,key,value,folding,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,with,different,types,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,folding,state,my,type,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,reducing,state,new,folding,state,descriptor,sum,0l,a,b,a,count,b,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream,deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,t,acc,folding,state,t,acc,get,folding,state,folding,state,descriptor,t,acc,state,properties
KeyedStateStore -> @PublicEvolving 	@Deprecated 	<T, ACC> FoldingState<T, ACC> getFoldingState(FoldingStateDescriptor<T, ACC> stateProperties)_;1508481109;Gets a handle to the system's key/value folding state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values with different types.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private FoldingState<MyType, Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getReducingState(_new FoldingStateDescriptor<>("sum", 0L, (a, b) -> a.count() + b, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value)__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).__@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	<T, ACC> FoldingState<T, ACC> getFoldingState(FoldingStateDescriptor<T, ACC> stateProperties)_;gets,a,handle,to,the,system,s,key,value,folding,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,with,different,types,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,folding,state,my,type,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,reducing,state,new,folding,state,descriptor,sum,0l,a,b,a,count,b,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream,deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,t,acc,folding,state,t,acc,get,folding,state,folding,state,descriptor,t,acc,state,properties
KeyedStateStore -> @PublicEvolving 	@Deprecated 	<T, ACC> FoldingState<T, ACC> getFoldingState(FoldingStateDescriptor<T, ACC> stateProperties)_;1509016418;Gets a handle to the system's key/value folding state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values with different types.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private FoldingState<MyType, Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getReducingState(_new FoldingStateDescriptor<>("sum", 0L, (a, b) -> a.count() + b, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value)__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).__@deprecated will be removed in a future version;@PublicEvolving_	@Deprecated_	<T, ACC> FoldingState<T, ACC> getFoldingState(FoldingStateDescriptor<T, ACC> stateProperties)_;gets,a,handle,to,the,system,s,key,value,folding,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,with,different,types,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,folding,state,my,type,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,reducing,state,new,folding,state,descriptor,sum,0l,a,b,a,count,b,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream,deprecated,will,be,removed,in,a,future,version;public,evolving,deprecated,t,acc,folding,state,t,acc,get,folding,state,folding,state,descriptor,t,acc,state,properties
KeyedStateStore -> @PublicEvolving 	@Deprecated 	<T, ACC> FoldingState<T, ACC> getFoldingState(FoldingStateDescriptor<T, ACC> stateProperties)_;1513160461;Gets a handle to the system's key/value folding state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values with different types.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private FoldingState<MyType, Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getReducingState(_new FoldingStateDescriptor<>("sum", 0L, (a, b) -> a.count() + b, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value)__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).__@deprecated will be removed in a future version in favor of {@link AggregatingState};@PublicEvolving_	@Deprecated_	<T, ACC> FoldingState<T, ACC> getFoldingState(FoldingStateDescriptor<T, ACC> stateProperties)_;gets,a,handle,to,the,system,s,key,value,folding,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,with,different,types,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,folding,state,my,type,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,reducing,state,new,folding,state,descriptor,sum,0l,a,b,a,count,b,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream,deprecated,will,be,removed,in,a,future,version,in,favor,of,link,aggregating,state;public,evolving,deprecated,t,acc,folding,state,t,acc,get,folding,state,folding,state,descriptor,t,acc,state,properties
KeyedStateStore -> @PublicEvolving 	@Deprecated 	<T, ACC> FoldingState<T, ACC> getFoldingState(FoldingStateDescriptor<T, ACC> stateProperties)_;1521628649;Gets a handle to the system's key/value folding state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values with different types.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private FoldingState<MyType, Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getReducingState(_new FoldingStateDescriptor<>("sum", 0L, (a, b) -> a.count() + b, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value)__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).__@deprecated will be removed in a future version in favor of {@link AggregatingState};@PublicEvolving_	@Deprecated_	<T, ACC> FoldingState<T, ACC> getFoldingState(FoldingStateDescriptor<T, ACC> stateProperties)_;gets,a,handle,to,the,system,s,key,value,folding,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,with,different,types,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,folding,state,my,type,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,reducing,state,new,folding,state,descriptor,sum,0l,a,b,a,count,b,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream,deprecated,will,be,removed,in,a,future,version,in,favor,of,link,aggregating,state;public,evolving,deprecated,t,acc,folding,state,t,acc,get,folding,state,folding,state,descriptor,t,acc,state,properties
KeyedStateStore -> @PublicEvolving 	<IN, ACC, OUT> AggregatingState<IN, OUT> getAggregatingState(AggregatingStateDescriptor<IN, ACC, OUT> stateProperties)_;1509016418;Gets a handle to the system's key/value folding state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values with different types.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")__AggregateFunction<...> aggregateFunction = ...__keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private AggregatingState<MyType, Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getAggregatingState(_new AggregatingStateDescriptor<>("sum", aggregateFunction, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value)__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <IN> The type of the values that are added to the state._@param <ACC> The type of the accumulator (intermediate aggregation state)._@param <OUT> The type of the values that are returned from the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<IN, ACC, OUT> AggregatingState<IN, OUT> getAggregatingState(AggregatingStateDescriptor<IN, ACC, OUT> stateProperties)_;gets,a,handle,to,the,system,s,key,value,folding,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,with,different,types,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,aggregate,function,aggregate,function,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,aggregating,state,my,type,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,aggregating,state,new,aggregating,state,descriptor,sum,aggregate,function,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,in,the,type,of,the,values,that,are,added,to,the,state,param,acc,the,type,of,the,accumulator,intermediate,aggregation,state,param,out,the,type,of,the,values,that,are,returned,from,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,in,acc,out,aggregating,state,in,out,get,aggregating,state,aggregating,state,descriptor,in,acc,out,state,properties
KeyedStateStore -> @PublicEvolving 	<IN, ACC, OUT> AggregatingState<IN, OUT> getAggregatingState(AggregatingStateDescriptor<IN, ACC, OUT> stateProperties)_;1513160461;Gets a handle to the system's key/value folding state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values with different types.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")__AggregateFunction<...> aggregateFunction = ...__keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private AggregatingState<MyType, Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getAggregatingState(_new AggregatingStateDescriptor<>("sum", aggregateFunction, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value)__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <IN> The type of the values that are added to the state._@param <ACC> The type of the accumulator (intermediate aggregation state)._@param <OUT> The type of the values that are returned from the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<IN, ACC, OUT> AggregatingState<IN, OUT> getAggregatingState(AggregatingStateDescriptor<IN, ACC, OUT> stateProperties)_;gets,a,handle,to,the,system,s,key,value,folding,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,with,different,types,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,aggregate,function,aggregate,function,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,aggregating,state,my,type,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,aggregating,state,new,aggregating,state,descriptor,sum,aggregate,function,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,in,the,type,of,the,values,that,are,added,to,the,state,param,acc,the,type,of,the,accumulator,intermediate,aggregation,state,param,out,the,type,of,the,values,that,are,returned,from,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,in,acc,out,aggregating,state,in,out,get,aggregating,state,aggregating,state,descriptor,in,acc,out,state,properties
KeyedStateStore -> @PublicEvolving 	<IN, ACC, OUT> AggregatingState<IN, OUT> getAggregatingState(AggregatingStateDescriptor<IN, ACC, OUT> stateProperties)_;1521628649;Gets a handle to the system's key/value folding state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values with different types.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")__AggregateFunction<...> aggregateFunction = ...__keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private AggregatingState<MyType, Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getAggregatingState(_new AggregatingStateDescriptor<>("sum", aggregateFunction, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value)__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <IN> The type of the values that are added to the state._@param <ACC> The type of the accumulator (intermediate aggregation state)._@param <OUT> The type of the values that are returned from the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<IN, ACC, OUT> AggregatingState<IN, OUT> getAggregatingState(AggregatingStateDescriptor<IN, ACC, OUT> stateProperties)_;gets,a,handle,to,the,system,s,key,value,folding,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,with,different,types,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,aggregate,function,aggregate,function,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,aggregating,state,my,type,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,aggregating,state,new,aggregating,state,descriptor,sum,aggregate,function,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,in,the,type,of,the,values,that,are,added,to,the,state,param,acc,the,type,of,the,accumulator,intermediate,aggregation,state,param,out,the,type,of,the,values,that,are,returned,from,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,in,acc,out,aggregating,state,in,out,get,aggregating,state,aggregating,state,descriptor,in,acc,out,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ListState<T> getListState(ListStateDescriptor<T> stateProperties)_;1476972861;Gets a handle to the system's key/value list state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_holds lists. One can adds elements to the list, or retrieve the list as a whole.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichFlatMapFunction<MyType, List<MyType>>() {__private ListState<MyType> state___public void open(Configuration cfg) {_state = getRuntimeContext().getListState(_new ListStateDescriptor<>("myState", MyType.class))____public void flatMap(MyType value, Collector<MyType> out) {_if (value.isDivider()) {_for (MyType t : state.get()) {_out.collect(t)___} else {_state.add(value)____})__}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part os a KeyedStream).;@PublicEvolving_	<T> ListState<T> getListState(ListStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,list,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,holds,lists,one,can,adds,elements,to,the,list,or,retrieve,the,list,as,a,whole,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,flat,map,function,my,type,list,my,type,private,list,state,my,type,state,public,void,open,configuration,cfg,state,get,runtime,context,get,list,state,new,list,state,descriptor,my,state,my,type,class,public,void,flat,map,my,type,value,collector,my,type,out,if,value,is,divider,for,my,type,t,state,get,out,collect,t,else,state,add,value,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,os,a,keyed,stream;public,evolving,t,list,state,t,get,list,state,list,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ListState<T> getListState(ListStateDescriptor<T> stateProperties)_;1483645612;Gets a handle to the system's key/value list state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_holds lists. One can adds elements to the list, or retrieve the list as a whole.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichFlatMapFunction<MyType, List<MyType>>() {__private ListState<MyType> state___public void open(Configuration cfg) {_state = getRuntimeContext().getListState(_new ListStateDescriptor<>("myState", MyType.class))____public void flatMap(MyType value, Collector<MyType> out) {_if (value.isDivider()) {_for (MyType t : state.get()) {_out.collect(t)___} else {_state.add(value)____})__}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part os a KeyedStream).;@PublicEvolving_	<T> ListState<T> getListState(ListStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,list,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,holds,lists,one,can,adds,elements,to,the,list,or,retrieve,the,list,as,a,whole,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,flat,map,function,my,type,list,my,type,private,list,state,my,type,state,public,void,open,configuration,cfg,state,get,runtime,context,get,list,state,new,list,state,descriptor,my,state,my,type,class,public,void,flat,map,my,type,value,collector,my,type,out,if,value,is,divider,for,my,type,t,state,get,out,collect,t,else,state,add,value,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,os,a,keyed,stream;public,evolving,t,list,state,t,get,list,state,list,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ListState<T> getListState(ListStateDescriptor<T> stateProperties)_;1487865389;Gets a handle to the system's key/value list state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_holds lists. One can adds elements to the list, or retrieve the list as a whole.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichFlatMapFunction<MyType, List<MyType>>() {__private ListState<MyType> state___public void open(Configuration cfg) {_state = getRuntimeContext().getListState(_new ListStateDescriptor<>("myState", MyType.class))____public void flatMap(MyType value, Collector<MyType> out) {_if (value.isDivider()) {_for (MyType t : state.get()) {_out.collect(t)___} else {_state.add(value)____})__}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part os a KeyedStream).;@PublicEvolving_	<T> ListState<T> getListState(ListStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,list,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,holds,lists,one,can,adds,elements,to,the,list,or,retrieve,the,list,as,a,whole,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,flat,map,function,my,type,list,my,type,private,list,state,my,type,state,public,void,open,configuration,cfg,state,get,runtime,context,get,list,state,new,list,state,descriptor,my,state,my,type,class,public,void,flat,map,my,type,value,collector,my,type,out,if,value,is,divider,for,my,type,t,state,get,out,collect,t,else,state,add,value,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,os,a,keyed,stream;public,evolving,t,list,state,t,get,list,state,list,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ListState<T> getListState(ListStateDescriptor<T> stateProperties)_;1494363409;Gets a handle to the system's key/value list state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_holds lists. One can adds elements to the list, or retrieve the list as a whole.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichFlatMapFunction<MyType, List<MyType>>() {__private ListState<MyType> state___public void open(Configuration cfg) {_state = getRuntimeContext().getListState(_new ListStateDescriptor<>("myState", MyType.class))____public void flatMap(MyType value, Collector<MyType> out) {_if (value.isDivider()) {_for (MyType t : state.get()) {_out.collect(t)___} else {_state.add(value)____})__}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part os a KeyedStream).;@PublicEvolving_	<T> ListState<T> getListState(ListStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,list,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,holds,lists,one,can,adds,elements,to,the,list,or,retrieve,the,list,as,a,whole,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,flat,map,function,my,type,list,my,type,private,list,state,my,type,state,public,void,open,configuration,cfg,state,get,runtime,context,get,list,state,new,list,state,descriptor,my,state,my,type,class,public,void,flat,map,my,type,value,collector,my,type,out,if,value,is,divider,for,my,type,t,state,get,out,collect,t,else,state,add,value,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,os,a,keyed,stream;public,evolving,t,list,state,t,get,list,state,list,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ListState<T> getListState(ListStateDescriptor<T> stateProperties)_;1508481109;Gets a handle to the system's key/value list state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_holds lists. One can adds elements to the list, or retrieve the list as a whole.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichFlatMapFunction<MyType, List<MyType>>() {__private ListState<MyType> state___public void open(Configuration cfg) {_state = getRuntimeContext().getListState(_new ListStateDescriptor<>("myState", MyType.class))____public void flatMap(MyType value, Collector<MyType> out) {_if (value.isDivider()) {_for (MyType t : state.get()) {_out.collect(t)___} else {_state.add(value)____})__}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part os a KeyedStream).;@PublicEvolving_	<T> ListState<T> getListState(ListStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,list,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,holds,lists,one,can,adds,elements,to,the,list,or,retrieve,the,list,as,a,whole,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,flat,map,function,my,type,list,my,type,private,list,state,my,type,state,public,void,open,configuration,cfg,state,get,runtime,context,get,list,state,new,list,state,descriptor,my,state,my,type,class,public,void,flat,map,my,type,value,collector,my,type,out,if,value,is,divider,for,my,type,t,state,get,out,collect,t,else,state,add,value,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,os,a,keyed,stream;public,evolving,t,list,state,t,get,list,state,list,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ListState<T> getListState(ListStateDescriptor<T> stateProperties)_;1509016418;Gets a handle to the system's key/value list state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_holds lists. One can adds elements to the list, or retrieve the list as a whole.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichFlatMapFunction<MyType, List<MyType>>() {__private ListState<MyType> state___public void open(Configuration cfg) {_state = getRuntimeContext().getListState(_new ListStateDescriptor<>("myState", MyType.class))____public void flatMap(MyType value, Collector<MyType> out) {_if (value.isDivider()) {_for (MyType t : state.get()) {_out.collect(t)___} else {_state.add(value)____})__}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part os a KeyedStream).;@PublicEvolving_	<T> ListState<T> getListState(ListStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,list,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,holds,lists,one,can,adds,elements,to,the,list,or,retrieve,the,list,as,a,whole,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,flat,map,function,my,type,list,my,type,private,list,state,my,type,state,public,void,open,configuration,cfg,state,get,runtime,context,get,list,state,new,list,state,descriptor,my,state,my,type,class,public,void,flat,map,my,type,value,collector,my,type,out,if,value,is,divider,for,my,type,t,state,get,out,collect,t,else,state,add,value,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,os,a,keyed,stream;public,evolving,t,list,state,t,get,list,state,list,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ListState<T> getListState(ListStateDescriptor<T> stateProperties)_;1513160461;Gets a handle to the system's key/value list state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_holds lists. One can adds elements to the list, or retrieve the list as a whole.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichFlatMapFunction<MyType, List<MyType>>() {__private ListState<MyType> state___public void open(Configuration cfg) {_state = getRuntimeContext().getListState(_new ListStateDescriptor<>("myState", MyType.class))____public void flatMap(MyType value, Collector<MyType> out) {_if (value.isDivider()) {_for (MyType t : state.get()) {_out.collect(t)___} else {_state.add(value)____})__}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part os a KeyedStream).;@PublicEvolving_	<T> ListState<T> getListState(ListStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,list,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,holds,lists,one,can,adds,elements,to,the,list,or,retrieve,the,list,as,a,whole,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,flat,map,function,my,type,list,my,type,private,list,state,my,type,state,public,void,open,configuration,cfg,state,get,runtime,context,get,list,state,new,list,state,descriptor,my,state,my,type,class,public,void,flat,map,my,type,value,collector,my,type,out,if,value,is,divider,for,my,type,t,state,get,out,collect,t,else,state,add,value,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,os,a,keyed,stream;public,evolving,t,list,state,t,get,list,state,list,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ListState<T> getListState(ListStateDescriptor<T> stateProperties)_;1521628649;Gets a handle to the system's key/value list state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_holds lists. One can adds elements to the list, or retrieve the list as a whole.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichFlatMapFunction<MyType, List<MyType>>() {__private ListState<MyType> state___public void open(Configuration cfg) {_state = getRuntimeContext().getListState(_new ListStateDescriptor<>("myState", MyType.class))____public void flatMap(MyType value, Collector<MyType> out) {_if (value.isDivider()) {_for (MyType t : state.get()) {_out.collect(t)___} else {_state.add(value)____})__}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part os a KeyedStream).;@PublicEvolving_	<T> ListState<T> getListState(ListStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,list,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,holds,lists,one,can,adds,elements,to,the,list,or,retrieve,the,list,as,a,whole,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,flat,map,function,my,type,list,my,type,private,list,state,my,type,state,public,void,open,configuration,cfg,state,get,runtime,context,get,list,state,new,list,state,descriptor,my,state,my,type,class,public,void,flat,map,my,type,value,collector,my,type,out,if,value,is,divider,for,my,type,t,state,get,out,collect,t,else,state,add,value,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,os,a,keyed,stream;public,evolving,t,list,state,t,get,list,state,list,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties)_;1476972861;Gets a handle to the system's key/value state. The key/value state is only accessible_if the function is executed on a KeyedStream. On each access, the state exposes the value_for the the key of the element currently processed by the function._Each function may have multiple partitioned states, addressed with different names.__<p>Because the scope of each value is the key of the currently processed element,_and the elements are distributed by the Flink runtime, the system can transparently_scale out and redistribute the state and KeyedStream.__<p>The following code example shows how to implement a continuous counter that counts_how many times elements of a certain key occur, and emits an updated count for that_element on each occurrence.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, Tuple2<MyType, Long>>() {__private ValueState<Long> count___public void open(Configuration cfg) {_state = getRuntimeContext().getState(_new ValueStateDescriptor<Long>("count", LongSerializer.INSTANCE, 0L))____public Tuple2<MyType, Long> map(MyType value) {_long count = state.value() + 1__state.update(value)__return new Tuple2<>(value, count)___})__}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,state,the,key,value,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,on,each,access,the,state,exposes,the,value,for,the,the,key,of,the,element,currently,processed,by,the,function,each,function,may,have,multiple,partitioned,states,addressed,with,different,names,p,because,the,scope,of,each,value,is,the,key,of,the,currently,processed,element,and,the,elements,are,distributed,by,the,flink,runtime,the,system,can,transparently,scale,out,and,redistribute,the,state,and,keyed,stream,p,the,following,code,example,shows,how,to,implement,a,continuous,counter,that,counts,how,many,times,elements,of,a,certain,key,occur,and,emits,an,updated,count,for,that,element,on,each,occurrence,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,tuple2,my,type,long,private,value,state,long,count,public,void,open,configuration,cfg,state,get,runtime,context,get,state,new,value,state,descriptor,long,count,long,serializer,instance,0l,public,tuple2,my,type,long,map,my,type,value,long,count,state,value,1,state,update,value,return,new,tuple2,value,count,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,value,state,t,get,state,value,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties)_;1483645612;Gets a handle to the system's key/value state. The key/value state is only accessible_if the function is executed on a KeyedStream. On each access, the state exposes the value_for the the key of the element currently processed by the function._Each function may have multiple partitioned states, addressed with different names.__<p>Because the scope of each value is the key of the currently processed element,_and the elements are distributed by the Flink runtime, the system can transparently_scale out and redistribute the state and KeyedStream.__<p>The following code example shows how to implement a continuous counter that counts_how many times elements of a certain key occur, and emits an updated count for that_element on each occurrence.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, Tuple2<MyType, Long>>() {__private ValueState<Long> count___public void open(Configuration cfg) {_state = getRuntimeContext().getState(_new ValueStateDescriptor<Long>("count", LongSerializer.INSTANCE, 0L))____public Tuple2<MyType, Long> map(MyType value) {_long count = state.value() + 1__state.update(value)__return new Tuple2<>(value, count)___})__}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,state,the,key,value,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,on,each,access,the,state,exposes,the,value,for,the,the,key,of,the,element,currently,processed,by,the,function,each,function,may,have,multiple,partitioned,states,addressed,with,different,names,p,because,the,scope,of,each,value,is,the,key,of,the,currently,processed,element,and,the,elements,are,distributed,by,the,flink,runtime,the,system,can,transparently,scale,out,and,redistribute,the,state,and,keyed,stream,p,the,following,code,example,shows,how,to,implement,a,continuous,counter,that,counts,how,many,times,elements,of,a,certain,key,occur,and,emits,an,updated,count,for,that,element,on,each,occurrence,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,tuple2,my,type,long,private,value,state,long,count,public,void,open,configuration,cfg,state,get,runtime,context,get,state,new,value,state,descriptor,long,count,long,serializer,instance,0l,public,tuple2,my,type,long,map,my,type,value,long,count,state,value,1,state,update,value,return,new,tuple2,value,count,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,value,state,t,get,state,value,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties)_;1487865389;Gets a handle to the system's key/value state. The key/value state is only accessible_if the function is executed on a KeyedStream. On each access, the state exposes the value_for the the key of the element currently processed by the function._Each function may have multiple partitioned states, addressed with different names.__<p>Because the scope of each value is the key of the currently processed element,_and the elements are distributed by the Flink runtime, the system can transparently_scale out and redistribute the state and KeyedStream.__<p>The following code example shows how to implement a continuous counter that counts_how many times elements of a certain key occur, and emits an updated count for that_element on each occurrence.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, Tuple2<MyType, Long>>() {__private ValueState<Long> count___public void open(Configuration cfg) {_state = getRuntimeContext().getState(_new ValueStateDescriptor<Long>("count", LongSerializer.INSTANCE, 0L))____public Tuple2<MyType, Long> map(MyType value) {_long count = state.value() + 1__state.update(value)__return new Tuple2<>(value, count)___})__}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,state,the,key,value,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,on,each,access,the,state,exposes,the,value,for,the,the,key,of,the,element,currently,processed,by,the,function,each,function,may,have,multiple,partitioned,states,addressed,with,different,names,p,because,the,scope,of,each,value,is,the,key,of,the,currently,processed,element,and,the,elements,are,distributed,by,the,flink,runtime,the,system,can,transparently,scale,out,and,redistribute,the,state,and,keyed,stream,p,the,following,code,example,shows,how,to,implement,a,continuous,counter,that,counts,how,many,times,elements,of,a,certain,key,occur,and,emits,an,updated,count,for,that,element,on,each,occurrence,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,tuple2,my,type,long,private,value,state,long,count,public,void,open,configuration,cfg,state,get,runtime,context,get,state,new,value,state,descriptor,long,count,long,serializer,instance,0l,public,tuple2,my,type,long,map,my,type,value,long,count,state,value,1,state,update,value,return,new,tuple2,value,count,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,value,state,t,get,state,value,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties)_;1494363409;Gets a handle to the system's key/value state. The key/value state is only accessible_if the function is executed on a KeyedStream. On each access, the state exposes the value_for the the key of the element currently processed by the function._Each function may have multiple partitioned states, addressed with different names.__<p>Because the scope of each value is the key of the currently processed element,_and the elements are distributed by the Flink runtime, the system can transparently_scale out and redistribute the state and KeyedStream.__<p>The following code example shows how to implement a continuous counter that counts_how many times elements of a certain key occur, and emits an updated count for that_element on each occurrence.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, Tuple2<MyType, Long>>() {__private ValueState<Long> count___public void open(Configuration cfg) {_state = getRuntimeContext().getState(_new ValueStateDescriptor<Long>("count", LongSerializer.INSTANCE, 0L))____public Tuple2<MyType, Long> map(MyType value) {_long count = state.value() + 1__state.update(value)__return new Tuple2<>(value, count)___})__}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,state,the,key,value,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,on,each,access,the,state,exposes,the,value,for,the,the,key,of,the,element,currently,processed,by,the,function,each,function,may,have,multiple,partitioned,states,addressed,with,different,names,p,because,the,scope,of,each,value,is,the,key,of,the,currently,processed,element,and,the,elements,are,distributed,by,the,flink,runtime,the,system,can,transparently,scale,out,and,redistribute,the,state,and,keyed,stream,p,the,following,code,example,shows,how,to,implement,a,continuous,counter,that,counts,how,many,times,elements,of,a,certain,key,occur,and,emits,an,updated,count,for,that,element,on,each,occurrence,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,tuple2,my,type,long,private,value,state,long,count,public,void,open,configuration,cfg,state,get,runtime,context,get,state,new,value,state,descriptor,long,count,long,serializer,instance,0l,public,tuple2,my,type,long,map,my,type,value,long,count,state,value,1,state,update,value,return,new,tuple2,value,count,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,value,state,t,get,state,value,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties)_;1508481109;Gets a handle to the system's key/value state. The key/value state is only accessible_if the function is executed on a KeyedStream. On each access, the state exposes the value_for the key of the element currently processed by the function._Each function may have multiple partitioned states, addressed with different names.__<p>Because the scope of each value is the key of the currently processed element,_and the elements are distributed by the Flink runtime, the system can transparently_scale out and redistribute the state and KeyedStream.__<p>The following code example shows how to implement a continuous counter that counts_how many times elements of a certain key occur, and emits an updated count for that_element on each occurrence.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, Tuple2<MyType, Long>>() {__private ValueState<Long> count___public void open(Configuration cfg) {_state = getRuntimeContext().getState(_new ValueStateDescriptor<Long>("count", LongSerializer.INSTANCE, 0L))____public Tuple2<MyType, Long> map(MyType value) {_long count = state.value() + 1__state.update(value)__return new Tuple2<>(value, count)___})__}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,state,the,key,value,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,on,each,access,the,state,exposes,the,value,for,the,key,of,the,element,currently,processed,by,the,function,each,function,may,have,multiple,partitioned,states,addressed,with,different,names,p,because,the,scope,of,each,value,is,the,key,of,the,currently,processed,element,and,the,elements,are,distributed,by,the,flink,runtime,the,system,can,transparently,scale,out,and,redistribute,the,state,and,keyed,stream,p,the,following,code,example,shows,how,to,implement,a,continuous,counter,that,counts,how,many,times,elements,of,a,certain,key,occur,and,emits,an,updated,count,for,that,element,on,each,occurrence,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,tuple2,my,type,long,private,value,state,long,count,public,void,open,configuration,cfg,state,get,runtime,context,get,state,new,value,state,descriptor,long,count,long,serializer,instance,0l,public,tuple2,my,type,long,map,my,type,value,long,count,state,value,1,state,update,value,return,new,tuple2,value,count,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,value,state,t,get,state,value,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties)_;1509016418;Gets a handle to the system's key/value state. The key/value state is only accessible_if the function is executed on a KeyedStream. On each access, the state exposes the value_for the key of the element currently processed by the function._Each function may have multiple partitioned states, addressed with different names.__<p>Because the scope of each value is the key of the currently processed element,_and the elements are distributed by the Flink runtime, the system can transparently_scale out and redistribute the state and KeyedStream.__<p>The following code example shows how to implement a continuous counter that counts_how many times elements of a certain key occur, and emits an updated count for that_element on each occurrence.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, Tuple2<MyType, Long>>() {__private ValueState<Long> count___public void open(Configuration cfg) {_state = getRuntimeContext().getState(_new ValueStateDescriptor<Long>("count", LongSerializer.INSTANCE, 0L))____public Tuple2<MyType, Long> map(MyType value) {_long count = state.value() + 1__state.update(value)__return new Tuple2<>(value, count)___})__}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,state,the,key,value,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,on,each,access,the,state,exposes,the,value,for,the,key,of,the,element,currently,processed,by,the,function,each,function,may,have,multiple,partitioned,states,addressed,with,different,names,p,because,the,scope,of,each,value,is,the,key,of,the,currently,processed,element,and,the,elements,are,distributed,by,the,flink,runtime,the,system,can,transparently,scale,out,and,redistribute,the,state,and,keyed,stream,p,the,following,code,example,shows,how,to,implement,a,continuous,counter,that,counts,how,many,times,elements,of,a,certain,key,occur,and,emits,an,updated,count,for,that,element,on,each,occurrence,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,tuple2,my,type,long,private,value,state,long,count,public,void,open,configuration,cfg,state,get,runtime,context,get,state,new,value,state,descriptor,long,count,long,serializer,instance,0l,public,tuple2,my,type,long,map,my,type,value,long,count,state,value,1,state,update,value,return,new,tuple2,value,count,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,value,state,t,get,state,value,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties)_;1513160461;Gets a handle to the system's key/value state. The key/value state is only accessible_if the function is executed on a KeyedStream. On each access, the state exposes the value_for the key of the element currently processed by the function._Each function may have multiple partitioned states, addressed with different names.__<p>Because the scope of each value is the key of the currently processed element,_and the elements are distributed by the Flink runtime, the system can transparently_scale out and redistribute the state and KeyedStream.__<p>The following code example shows how to implement a continuous counter that counts_how many times elements of a certain key occur, and emits an updated count for that_element on each occurrence.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, Tuple2<MyType, Long>>() {__private ValueState<Long> count___public void open(Configuration cfg) {_state = getRuntimeContext().getState(_new ValueStateDescriptor<Long>("count", LongSerializer.INSTANCE, 0L))____public Tuple2<MyType, Long> map(MyType value) {_long count = state.value() + 1__state.update(value)__return new Tuple2<>(value, count)___})__}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,state,the,key,value,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,on,each,access,the,state,exposes,the,value,for,the,key,of,the,element,currently,processed,by,the,function,each,function,may,have,multiple,partitioned,states,addressed,with,different,names,p,because,the,scope,of,each,value,is,the,key,of,the,currently,processed,element,and,the,elements,are,distributed,by,the,flink,runtime,the,system,can,transparently,scale,out,and,redistribute,the,state,and,keyed,stream,p,the,following,code,example,shows,how,to,implement,a,continuous,counter,that,counts,how,many,times,elements,of,a,certain,key,occur,and,emits,an,updated,count,for,that,element,on,each,occurrence,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,tuple2,my,type,long,private,value,state,long,count,public,void,open,configuration,cfg,state,get,runtime,context,get,state,new,value,state,descriptor,long,count,long,serializer,instance,0l,public,tuple2,my,type,long,map,my,type,value,long,count,state,value,1,state,update,value,return,new,tuple2,value,count,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,value,state,t,get,state,value,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties)_;1521628649;Gets a handle to the system's key/value state. The key/value state is only accessible_if the function is executed on a KeyedStream. On each access, the state exposes the value_for the key of the element currently processed by the function._Each function may have multiple partitioned states, addressed with different names.__<p>Because the scope of each value is the key of the currently processed element,_and the elements are distributed by the Flink runtime, the system can transparently_scale out and redistribute the state and KeyedStream.__<p>The following code example shows how to implement a continuous counter that counts_how many times elements of a certain key occur, and emits an updated count for that_element on each occurrence.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, Tuple2<MyType, Long>>() {__private ValueState<Long> count___public void open(Configuration cfg) {_state = getRuntimeContext().getState(_new ValueStateDescriptor<Long>("count", LongSerializer.INSTANCE, 0L))____public Tuple2<MyType, Long> map(MyType value) {_long count = state.value() + 1__state.update(value)__return new Tuple2<>(value, count)___})__}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T> ValueState<T> getState(ValueStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,state,the,key,value,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,on,each,access,the,state,exposes,the,value,for,the,key,of,the,element,currently,processed,by,the,function,each,function,may,have,multiple,partitioned,states,addressed,with,different,names,p,because,the,scope,of,each,value,is,the,key,of,the,currently,processed,element,and,the,elements,are,distributed,by,the,flink,runtime,the,system,can,transparently,scale,out,and,redistribute,the,state,and,keyed,stream,p,the,following,code,example,shows,how,to,implement,a,continuous,counter,that,counts,how,many,times,elements,of,a,certain,key,occur,and,emits,an,updated,count,for,that,element,on,each,occurrence,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,tuple2,my,type,long,private,value,state,long,count,public,void,open,configuration,cfg,state,get,runtime,context,get,state,new,value,state,descriptor,long,count,long,serializer,instance,0l,public,tuple2,my,type,long,map,my,type,value,long,count,state,value,1,state,update,value,return,new,tuple2,value,count,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,value,state,t,get,state,value,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties)_;1476972861;Gets a handle to the system's key/value list state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private ReducingState<Long> sum___public void open(Configuration cfg) {_state = getRuntimeContext().getReducingState(_new ReducingStateDescriptor<>("sum", MyType.class, 0L, (a, b) -> a + b))____public Tuple2<MyType, Long> map(MyType value) {_sum.add(value.count())__return new Tuple2<>(value, sum.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,list,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,reducing,state,long,sum,public,void,open,configuration,cfg,state,get,runtime,context,get,reducing,state,new,reducing,state,descriptor,sum,my,type,class,0l,a,b,a,b,public,tuple2,my,type,long,map,my,type,value,sum,add,value,count,return,new,tuple2,value,sum,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,reducing,state,t,get,reducing,state,reducing,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties)_;1483645612;Gets a handle to the system's key/value reducing state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private ReducingState<Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getReducingState(_new ReducingStateDescriptor<>("sum", (a, b) -> a + b, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value.count())__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,reducing,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,reducing,state,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,reducing,state,new,reducing,state,descriptor,sum,a,b,a,b,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,count,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,reducing,state,t,get,reducing,state,reducing,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties)_;1487865389;Gets a handle to the system's key/value reducing state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private ReducingState<Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getReducingState(_new ReducingStateDescriptor<>("sum", (a, b) -> a + b, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value.count())__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,reducing,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,reducing,state,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,reducing,state,new,reducing,state,descriptor,sum,a,b,a,b,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,count,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,reducing,state,t,get,reducing,state,reducing,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties)_;1494363409;Gets a handle to the system's key/value reducing state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private ReducingState<Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getReducingState(_new ReducingStateDescriptor<>("sum", (a, b) -> a + b, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value.count())__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,reducing,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,reducing,state,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,reducing,state,new,reducing,state,descriptor,sum,a,b,a,b,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,count,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,reducing,state,t,get,reducing,state,reducing,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties)_;1508481109;Gets a handle to the system's key/value reducing state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private ReducingState<Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getReducingState(_new ReducingStateDescriptor<>("sum", (a, b) -> a + b, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value.count())__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,reducing,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,reducing,state,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,reducing,state,new,reducing,state,descriptor,sum,a,b,a,b,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,count,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,reducing,state,t,get,reducing,state,reducing,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties)_;1509016418;Gets a handle to the system's key/value reducing state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private ReducingState<Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getReducingState(_new ReducingStateDescriptor<>("sum", (a, b) -> a + b, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value.count())__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,reducing,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,reducing,state,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,reducing,state,new,reducing,state,descriptor,sum,a,b,a,b,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,count,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,reducing,state,t,get,reducing,state,reducing,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties)_;1513160461;Gets a handle to the system's key/value reducing state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private ReducingState<Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getReducingState(_new ReducingStateDescriptor<>("sum", (a, b) -> a + b, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value.count())__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,reducing,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,reducing,state,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,reducing,state,new,reducing,state,descriptor,sum,a,b,a,b,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,count,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,reducing,state,t,get,reducing,state,reducing,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties)_;1521628649;Gets a handle to the system's key/value reducing state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private ReducingState<Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getReducingState(_new ReducingStateDescriptor<>("sum", (a, b) -> a + b, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value.count())__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T> ReducingState<T> getReducingState(ReducingStateDescriptor<T> stateProperties)_;gets,a,handle,to,the,system,s,key,value,reducing,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,reducing,state,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,reducing,state,new,reducing,state,descriptor,sum,a,b,a,b,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,count,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,reducing,state,t,get,reducing,state,reducing,state,descriptor,t,state,properties
KeyedStateStore -> @PublicEvolving 	<T, ACC> FoldingState<T, ACC> getFoldingState(FoldingStateDescriptor<T, ACC> stateProperties)_;1483645612;Gets a handle to the system's key/value folding state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values with different types.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private FoldingState<MyType, Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getReducingState(_new FoldingStateDescriptor<>("sum", 0L, (a, b) -> a.count() + b, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value)__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T, ACC> FoldingState<T, ACC> getFoldingState(FoldingStateDescriptor<T, ACC> stateProperties)_;gets,a,handle,to,the,system,s,key,value,folding,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,with,different,types,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,folding,state,my,type,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,reducing,state,new,folding,state,descriptor,sum,0l,a,b,a,count,b,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,acc,folding,state,t,acc,get,folding,state,folding,state,descriptor,t,acc,state,properties
KeyedStateStore -> @PublicEvolving 	<T, ACC> FoldingState<T, ACC> getFoldingState(FoldingStateDescriptor<T, ACC> stateProperties)_;1487865389;Gets a handle to the system's key/value folding state. This state is similar to the state_accessed via {@link #getState(ValueStateDescriptor)}, but is optimized for state that_aggregates values with different types.__<p>This state is only accessible if the function is executed on a KeyedStream.__<pre>{@code_DataStream<MyType> stream = ...__KeyedStream<MyType> keyedStream = stream.keyBy("id")___keyedStream.map(new RichMapFunction<MyType, List<MyType>>() {__private FoldingState<MyType, Long> state___public void open(Configuration cfg) {_state = getRuntimeContext().getReducingState(_new FoldingStateDescriptor<>("sum", 0L, (a, b) -> a.count() + b, Long.class))____public Tuple2<MyType, Long> map(MyType value) {_state.add(value)__return new Tuple2<>(value, state.get())___})___}</pre>__@param stateProperties The descriptor defining the properties of the stats.__@param <T> The type of value stored in the state.__@return The partitioned state object.__@throws UnsupportedOperationException Thrown, if no partitioned state is available for the_function (function is not part of a KeyedStream).;@PublicEvolving_	<T, ACC> FoldingState<T, ACC> getFoldingState(FoldingStateDescriptor<T, ACC> stateProperties)_;gets,a,handle,to,the,system,s,key,value,folding,state,this,state,is,similar,to,the,state,accessed,via,link,get,state,value,state,descriptor,but,is,optimized,for,state,that,aggregates,values,with,different,types,p,this,state,is,only,accessible,if,the,function,is,executed,on,a,keyed,stream,pre,code,data,stream,my,type,stream,keyed,stream,my,type,keyed,stream,stream,key,by,id,keyed,stream,map,new,rich,map,function,my,type,list,my,type,private,folding,state,my,type,long,state,public,void,open,configuration,cfg,state,get,runtime,context,get,reducing,state,new,folding,state,descriptor,sum,0l,a,b,a,count,b,long,class,public,tuple2,my,type,long,map,my,type,value,state,add,value,return,new,tuple2,value,state,get,pre,param,state,properties,the,descriptor,defining,the,properties,of,the,stats,param,t,the,type,of,value,stored,in,the,state,return,the,partitioned,state,object,throws,unsupported,operation,exception,thrown,if,no,partitioned,state,is,available,for,the,function,function,is,not,part,of,a,keyed,stream;public,evolving,t,acc,folding,state,t,acc,get,folding,state,folding,state,descriptor,t,acc,state,properties
