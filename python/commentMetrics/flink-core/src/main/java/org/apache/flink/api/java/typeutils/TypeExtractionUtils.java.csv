# id;timestamp;commentText;codeText;commentWords;codeWords
TypeExtractionUtils -> public static Class<?> getRawClass(Type t);1510755099;Returns the raw class of both parameterized types and generic arrays._Returns java.lang.Object for all other types.;public static Class<?> getRawClass(Type t) {_		if (isClassType(t)) {_			return typeToClass(t)__		} else if (t instanceof GenericArrayType) {_			Type component = ((GenericArrayType)t).getGenericComponentType()__			return Array.newInstance(getRawClass(component), 0).getClass()__		}_		return Object.class__	};returns,the,raw,class,of,both,parameterized,types,and,generic,arrays,returns,java,lang,object,for,all,other,types;public,static,class,get,raw,class,type,t,if,is,class,type,t,return,type,to,class,t,else,if,t,instanceof,generic,array,type,type,component,generic,array,type,t,get,generic,component,type,return,array,new,instance,get,raw,class,component,0,get,class,return,object,class
TypeExtractionUtils -> public static Class<?> getRawClass(Type t);1518989074;Returns the raw class of both parameterized types and generic arrays._Returns java.lang.Object for all other types.;public static Class<?> getRawClass(Type t) {_		if (isClassType(t)) {_			return typeToClass(t)__		} else if (t instanceof GenericArrayType) {_			Type component = ((GenericArrayType) t).getGenericComponentType()__			return Array.newInstance(getRawClass(component), 0).getClass()__		}_		return Object.class__	};returns,the,raw,class,of,both,parameterized,types,and,generic,arrays,returns,java,lang,object,for,all,other,types;public,static,class,get,raw,class,type,t,if,is,class,type,t,return,type,to,class,t,else,if,t,instanceof,generic,array,type,type,component,generic,array,type,t,get,generic,component,type,return,array,new,instance,get,raw,class,component,0,get,class,return,object,class
TypeExtractionUtils -> public static Class<?> getRawClass(Type t);1532066767;Returns the raw class of both parameterized types and generic arrays._Returns java.lang.Object for all other types.;public static Class<?> getRawClass(Type t) {_		if (isClassType(t)) {_			return typeToClass(t)__		} else if (t instanceof GenericArrayType) {_			Type component = ((GenericArrayType) t).getGenericComponentType()__			return Array.newInstance(getRawClass(component), 0).getClass()__		}_		return Object.class__	};returns,the,raw,class,of,both,parameterized,types,and,generic,arrays,returns,java,lang,object,for,all,other,types;public,static,class,get,raw,class,type,t,if,is,class,type,t,return,type,to,class,t,else,if,t,instanceof,generic,array,type,type,component,generic,array,type,t,get,generic,component,type,return,array,new,instance,get,raw,class,component,0,get,class,return,object,class
TypeExtractionUtils -> public static LambdaExecutable checkAndExtractLambda(Function function) throws TypeExtractionException;1479218219;Checks if the given function has been implemented using a Java 8 lambda. If yes, a LambdaExecutable_is returned describing the method/constructor. Otherwise null.__@throws TypeExtractionException lambda extraction is pretty hacky, it might fail for unknown JVM issues.;public static LambdaExecutable checkAndExtractLambda(Function function) throws TypeExtractionException {_		try {_			_			Object serializedLambda = null__			for (Class<?> clazz = function.getClass()_ clazz != null_ clazz = clazz.getSuperclass()) {_				try {_					Method replaceMethod = clazz.getDeclaredMethod("writeReplace")__					replaceMethod.setAccessible(true)__					Object serialVersion = replaceMethod.invoke(function)___					_					if (serialVersion.getClass().getName().equals("java.lang.invoke.SerializedLambda")) {__						_						try {_							Class.forName("java.lang.invoke.SerializedLambda")__						}_						catch (Exception e) {_							throw new TypeExtractionException("User code tries to use lambdas, but framework is running with a Java version < 8")__						}_						serializedLambda = serialVersion__						break__					}_				}_				catch (NoSuchMethodException e) {_					_				}_			}__			_			if (serializedLambda == null) {_				return null__			}__			_			Method implClassMethod = serializedLambda.getClass().getDeclaredMethod("getImplClass")__			Method implMethodNameMethod = serializedLambda.getClass().getDeclaredMethod("getImplMethodName")__			Method implMethodSig = serializedLambda.getClass().getDeclaredMethod("getImplMethodSignature")___			String className = (String) implClassMethod.invoke(serializedLambda)__			String methodName = (String) implMethodNameMethod.invoke(serializedLambda)__			String methodSig = (String) implMethodSig.invoke(serializedLambda)___			Class<?> implClass = Class.forName(className.replace('/', '.'), true, Thread.currentThread().getContextClassLoader())___			_			if (methodName.equals("<init>")) {_				Constructor<?>[] constructors = implClass.getDeclaredConstructors()__				for (Constructor<?> constructor : constructors) {_					if(getConstructorDescriptor(constructor).equals(methodSig)) {_						return new LambdaExecutable(constructor)__					}_				}_			}_			_			else {_				List<Method> methods = getAllDeclaredMethods(implClass)__				for (Method method : methods) {_					if(method.getName().equals(methodName) && getMethodDescriptor(method).equals(methodSig)) {_						return new LambdaExecutable(method)__					}_				}_			}_			throw new TypeExtractionException("No lambda method found.")__		}_		catch (Exception e) {_			throw new TypeExtractionException("Could not extract lambda method out of function: " +_				e.getClass().getSimpleName() + " - " + e.getMessage(), e)__		}_	};checks,if,the,given,function,has,been,implemented,using,a,java,8,lambda,if,yes,a,lambda,executable,is,returned,describing,the,method,constructor,otherwise,null,throws,type,extraction,exception,lambda,extraction,is,pretty,hacky,it,might,fail,for,unknown,jvm,issues;public,static,lambda,executable,check,and,extract,lambda,function,function,throws,type,extraction,exception,try,object,serialized,lambda,null,for,class,clazz,function,get,class,clazz,null,clazz,clazz,get,superclass,try,method,replace,method,clazz,get,declared,method,write,replace,replace,method,set,accessible,true,object,serial,version,replace,method,invoke,function,if,serial,version,get,class,get,name,equals,java,lang,invoke,serialized,lambda,try,class,for,name,java,lang,invoke,serialized,lambda,catch,exception,e,throw,new,type,extraction,exception,user,code,tries,to,use,lambdas,but,framework,is,running,with,a,java,version,8,serialized,lambda,serial,version,break,catch,no,such,method,exception,e,if,serialized,lambda,null,return,null,method,impl,class,method,serialized,lambda,get,class,get,declared,method,get,impl,class,method,impl,method,name,method,serialized,lambda,get,class,get,declared,method,get,impl,method,name,method,impl,method,sig,serialized,lambda,get,class,get,declared,method,get,impl,method,signature,string,class,name,string,impl,class,method,invoke,serialized,lambda,string,method,name,string,impl,method,name,method,invoke,serialized,lambda,string,method,sig,string,impl,method,sig,invoke,serialized,lambda,class,impl,class,class,for,name,class,name,replace,true,thread,current,thread,get,context,class,loader,if,method,name,equals,init,constructor,constructors,impl,class,get,declared,constructors,for,constructor,constructor,constructors,if,get,constructor,descriptor,constructor,equals,method,sig,return,new,lambda,executable,constructor,else,list,method,methods,get,all,declared,methods,impl,class,for,method,method,methods,if,method,get,name,equals,method,name,get,method,descriptor,method,equals,method,sig,return,new,lambda,executable,method,throw,new,type,extraction,exception,no,lambda,method,found,catch,exception,e,throw,new,type,extraction,exception,could,not,extract,lambda,method,out,of,function,e,get,class,get,simple,name,e,get,message,e
TypeExtractionUtils -> public static LambdaExecutable checkAndExtractLambda(Function function) throws TypeExtractionException;1496911361;Checks if the given function has been implemented using a Java 8 lambda. If yes, a LambdaExecutable_is returned describing the method/constructor. Otherwise null.__@throws TypeExtractionException lambda extraction is pretty hacky, it might fail for unknown JVM issues.;public static LambdaExecutable checkAndExtractLambda(Function function) throws TypeExtractionException {_		try {_			_			Object serializedLambda = null__			for (Class<?> clazz = function.getClass()_ clazz != null_ clazz = clazz.getSuperclass()) {_				try {_					Method replaceMethod = clazz.getDeclaredMethod("writeReplace")__					replaceMethod.setAccessible(true)__					Object serialVersion = replaceMethod.invoke(function)___					_					if (serialVersion.getClass().getName().equals("java.lang.invoke.SerializedLambda")) {__						_						try {_							Class.forName("java.lang.invoke.SerializedLambda")__						}_						catch (Exception e) {_							throw new TypeExtractionException("User code tries to use lambdas, but framework is running with a Java version < 8")__						}_						serializedLambda = serialVersion__						break__					}_				}_				catch (NoSuchMethodException e) {_					_				}_			}__			_			if (serializedLambda == null) {_				return null__			}__			_			Method implClassMethod = serializedLambda.getClass().getDeclaredMethod("getImplClass")__			Method implMethodNameMethod = serializedLambda.getClass().getDeclaredMethod("getImplMethodName")__			Method implMethodSig = serializedLambda.getClass().getDeclaredMethod("getImplMethodSignature")___			String className = (String) implClassMethod.invoke(serializedLambda)__			String methodName = (String) implMethodNameMethod.invoke(serializedLambda)__			String methodSig = (String) implMethodSig.invoke(serializedLambda)___			Class<?> implClass = Class.forName(className.replace('/', '.'), true, Thread.currentThread().getContextClassLoader())___			_			if (methodName.equals("<init>")) {_				Constructor<?>[] constructors = implClass.getDeclaredConstructors()__				for (Constructor<?> constructor : constructors) {_					if(getConstructorDescriptor(constructor).equals(methodSig)) {_						return new LambdaExecutable(constructor)__					}_				}_			}_			_			else {_				List<Method> methods = getAllDeclaredMethods(implClass)__				for (Method method : methods) {_					if(method.getName().equals(methodName) && getMethodDescriptor(method).equals(methodSig)) {_						return new LambdaExecutable(method)__					}_				}_			}_			throw new TypeExtractionException("No lambda method found.")__		}_		catch (Exception e) {_			throw new TypeExtractionException("Could not extract lambda method out of function: " +_				e.getClass().getSimpleName() + " - " + e.getMessage(), e)__		}_	};checks,if,the,given,function,has,been,implemented,using,a,java,8,lambda,if,yes,a,lambda,executable,is,returned,describing,the,method,constructor,otherwise,null,throws,type,extraction,exception,lambda,extraction,is,pretty,hacky,it,might,fail,for,unknown,jvm,issues;public,static,lambda,executable,check,and,extract,lambda,function,function,throws,type,extraction,exception,try,object,serialized,lambda,null,for,class,clazz,function,get,class,clazz,null,clazz,clazz,get,superclass,try,method,replace,method,clazz,get,declared,method,write,replace,replace,method,set,accessible,true,object,serial,version,replace,method,invoke,function,if,serial,version,get,class,get,name,equals,java,lang,invoke,serialized,lambda,try,class,for,name,java,lang,invoke,serialized,lambda,catch,exception,e,throw,new,type,extraction,exception,user,code,tries,to,use,lambdas,but,framework,is,running,with,a,java,version,8,serialized,lambda,serial,version,break,catch,no,such,method,exception,e,if,serialized,lambda,null,return,null,method,impl,class,method,serialized,lambda,get,class,get,declared,method,get,impl,class,method,impl,method,name,method,serialized,lambda,get,class,get,declared,method,get,impl,method,name,method,impl,method,sig,serialized,lambda,get,class,get,declared,method,get,impl,method,signature,string,class,name,string,impl,class,method,invoke,serialized,lambda,string,method,name,string,impl,method,name,method,invoke,serialized,lambda,string,method,sig,string,impl,method,sig,invoke,serialized,lambda,class,impl,class,class,for,name,class,name,replace,true,thread,current,thread,get,context,class,loader,if,method,name,equals,init,constructor,constructors,impl,class,get,declared,constructors,for,constructor,constructor,constructors,if,get,constructor,descriptor,constructor,equals,method,sig,return,new,lambda,executable,constructor,else,list,method,methods,get,all,declared,methods,impl,class,for,method,method,methods,if,method,get,name,equals,method,name,get,method,descriptor,method,equals,method,sig,return,new,lambda,executable,method,throw,new,type,extraction,exception,no,lambda,method,found,catch,exception,e,throw,new,type,extraction,exception,could,not,extract,lambda,method,out,of,function,e,get,class,get,simple,name,e,get,message,e
TypeExtractionUtils -> public static LambdaExecutable checkAndExtractLambda(Function function) throws TypeExtractionException;1498220070;Checks if the given function has been implemented using a Java 8 lambda. If yes, a LambdaExecutable_is returned describing the method/constructor. Otherwise null.__@throws TypeExtractionException lambda extraction is pretty hacky, it might fail for unknown JVM issues.;public static LambdaExecutable checkAndExtractLambda(Function function) throws TypeExtractionException {_		try {_			_			Object serializedLambda = null__			for (Class<?> clazz = function.getClass()_ clazz != null_ clazz = clazz.getSuperclass()) {_				try {_					Method replaceMethod = clazz.getDeclaredMethod("writeReplace")__					replaceMethod.setAccessible(true)__					Object serialVersion = replaceMethod.invoke(function)___					_					if (serialVersion.getClass().getName().equals("java.lang.invoke.SerializedLambda")) {__						_						try {_							Class.forName("java.lang.invoke.SerializedLambda")__						}_						catch (Exception e) {_							throw new TypeExtractionException("User code tries to use lambdas, but framework is running with a Java version < 8")__						}_						serializedLambda = serialVersion__						break__					}_				}_				catch (NoSuchMethodException e) {_					_				}_			}__			_			if (serializedLambda == null) {_				return null__			}__			_			Method implClassMethod = serializedLambda.getClass().getDeclaredMethod("getImplClass")__			Method implMethodNameMethod = serializedLambda.getClass().getDeclaredMethod("getImplMethodName")__			Method implMethodSig = serializedLambda.getClass().getDeclaredMethod("getImplMethodSignature")___			String className = (String) implClassMethod.invoke(serializedLambda)__			String methodName = (String) implMethodNameMethod.invoke(serializedLambda)__			String methodSig = (String) implMethodSig.invoke(serializedLambda)___			Class<?> implClass = Class.forName(className.replace('/', '.'), true, Thread.currentThread().getContextClassLoader())___			_			if (methodName.equals("<init>")) {_				Constructor<?>[] constructors = implClass.getDeclaredConstructors()__				for (Constructor<?> constructor : constructors) {_					if(getConstructorDescriptor(constructor).equals(methodSig)) {_						return new LambdaExecutable(constructor)__					}_				}_			}_			_			else {_				List<Method> methods = getAllDeclaredMethods(implClass)__				for (Method method : methods) {_					if(method.getName().equals(methodName) && getMethodDescriptor(method).equals(methodSig)) {_						return new LambdaExecutable(method)__					}_				}_			}_			throw new TypeExtractionException("No lambda method found.")__		}_		catch (Exception e) {_			throw new TypeExtractionException("Could not extract lambda method out of function: " +_				e.getClass().getSimpleName() + " - " + e.getMessage(), e)__		}_	};checks,if,the,given,function,has,been,implemented,using,a,java,8,lambda,if,yes,a,lambda,executable,is,returned,describing,the,method,constructor,otherwise,null,throws,type,extraction,exception,lambda,extraction,is,pretty,hacky,it,might,fail,for,unknown,jvm,issues;public,static,lambda,executable,check,and,extract,lambda,function,function,throws,type,extraction,exception,try,object,serialized,lambda,null,for,class,clazz,function,get,class,clazz,null,clazz,clazz,get,superclass,try,method,replace,method,clazz,get,declared,method,write,replace,replace,method,set,accessible,true,object,serial,version,replace,method,invoke,function,if,serial,version,get,class,get,name,equals,java,lang,invoke,serialized,lambda,try,class,for,name,java,lang,invoke,serialized,lambda,catch,exception,e,throw,new,type,extraction,exception,user,code,tries,to,use,lambdas,but,framework,is,running,with,a,java,version,8,serialized,lambda,serial,version,break,catch,no,such,method,exception,e,if,serialized,lambda,null,return,null,method,impl,class,method,serialized,lambda,get,class,get,declared,method,get,impl,class,method,impl,method,name,method,serialized,lambda,get,class,get,declared,method,get,impl,method,name,method,impl,method,sig,serialized,lambda,get,class,get,declared,method,get,impl,method,signature,string,class,name,string,impl,class,method,invoke,serialized,lambda,string,method,name,string,impl,method,name,method,invoke,serialized,lambda,string,method,sig,string,impl,method,sig,invoke,serialized,lambda,class,impl,class,class,for,name,class,name,replace,true,thread,current,thread,get,context,class,loader,if,method,name,equals,init,constructor,constructors,impl,class,get,declared,constructors,for,constructor,constructor,constructors,if,get,constructor,descriptor,constructor,equals,method,sig,return,new,lambda,executable,constructor,else,list,method,methods,get,all,declared,methods,impl,class,for,method,method,methods,if,method,get,name,equals,method,name,get,method,descriptor,method,equals,method,sig,return,new,lambda,executable,method,throw,new,type,extraction,exception,no,lambda,method,found,catch,exception,e,throw,new,type,extraction,exception,could,not,extract,lambda,method,out,of,function,e,get,class,get,simple,name,e,get,message,e
TypeExtractionUtils -> public static LambdaExecutable checkAndExtractLambda(Function function) throws TypeExtractionException;1502357786;Checks if the given function has been implemented using a Java 8 lambda. If yes, a LambdaExecutable_is returned describing the method/constructor. Otherwise null.__@throws TypeExtractionException lambda extraction is pretty hacky, it might fail for unknown JVM issues.;public static LambdaExecutable checkAndExtractLambda(Function function) throws TypeExtractionException {_		try {_			_			Object serializedLambda = null__			for (Class<?> clazz = function.getClass()_ clazz != null_ clazz = clazz.getSuperclass()) {_				try {_					Method replaceMethod = clazz.getDeclaredMethod("writeReplace")__					replaceMethod.setAccessible(true)__					Object serialVersion = replaceMethod.invoke(function)___					_					if (serialVersion.getClass().getName().equals("java.lang.invoke.SerializedLambda")) {__						_						try {_							Class.forName("java.lang.invoke.SerializedLambda")__						}_						catch (Exception e) {_							throw new TypeExtractionException("User code tries to use lambdas, but framework is running with a Java version < 8")__						}_						serializedLambda = serialVersion__						break__					}_				}_				catch (NoSuchMethodException e) {_					_				}_			}__			_			if (serializedLambda == null) {_				return null__			}__			_			Method implClassMethod = serializedLambda.getClass().getDeclaredMethod("getImplClass")__			Method implMethodNameMethod = serializedLambda.getClass().getDeclaredMethod("getImplMethodName")__			Method implMethodSig = serializedLambda.getClass().getDeclaredMethod("getImplMethodSignature")___			String className = (String) implClassMethod.invoke(serializedLambda)__			String methodName = (String) implMethodNameMethod.invoke(serializedLambda)__			String methodSig = (String) implMethodSig.invoke(serializedLambda)___			Class<?> implClass = Class.forName(className.replace('/', '.'), true, Thread.currentThread().getContextClassLoader())___			_			if (methodName.equals("<init>")) {_				Constructor<?>[] constructors = implClass.getDeclaredConstructors()__				for (Constructor<?> constructor : constructors) {_					if(getConstructorDescriptor(constructor).equals(methodSig)) {_						return new LambdaExecutable(constructor)__					}_				}_			}_			_			else {_				List<Method> methods = getAllDeclaredMethods(implClass)__				for (Method method : methods) {_					if(method.getName().equals(methodName) && getMethodDescriptor(method).equals(methodSig)) {_						return new LambdaExecutable(method)__					}_				}_			}_			throw new TypeExtractionException("No lambda method found.")__		}_		catch (Exception e) {_			throw new TypeExtractionException("Could not extract lambda method out of function: " +_				e.getClass().getSimpleName() + " - " + e.getMessage(), e)__		}_	};checks,if,the,given,function,has,been,implemented,using,a,java,8,lambda,if,yes,a,lambda,executable,is,returned,describing,the,method,constructor,otherwise,null,throws,type,extraction,exception,lambda,extraction,is,pretty,hacky,it,might,fail,for,unknown,jvm,issues;public,static,lambda,executable,check,and,extract,lambda,function,function,throws,type,extraction,exception,try,object,serialized,lambda,null,for,class,clazz,function,get,class,clazz,null,clazz,clazz,get,superclass,try,method,replace,method,clazz,get,declared,method,write,replace,replace,method,set,accessible,true,object,serial,version,replace,method,invoke,function,if,serial,version,get,class,get,name,equals,java,lang,invoke,serialized,lambda,try,class,for,name,java,lang,invoke,serialized,lambda,catch,exception,e,throw,new,type,extraction,exception,user,code,tries,to,use,lambdas,but,framework,is,running,with,a,java,version,8,serialized,lambda,serial,version,break,catch,no,such,method,exception,e,if,serialized,lambda,null,return,null,method,impl,class,method,serialized,lambda,get,class,get,declared,method,get,impl,class,method,impl,method,name,method,serialized,lambda,get,class,get,declared,method,get,impl,method,name,method,impl,method,sig,serialized,lambda,get,class,get,declared,method,get,impl,method,signature,string,class,name,string,impl,class,method,invoke,serialized,lambda,string,method,name,string,impl,method,name,method,invoke,serialized,lambda,string,method,sig,string,impl,method,sig,invoke,serialized,lambda,class,impl,class,class,for,name,class,name,replace,true,thread,current,thread,get,context,class,loader,if,method,name,equals,init,constructor,constructors,impl,class,get,declared,constructors,for,constructor,constructor,constructors,if,get,constructor,descriptor,constructor,equals,method,sig,return,new,lambda,executable,constructor,else,list,method,methods,get,all,declared,methods,impl,class,for,method,method,methods,if,method,get,name,equals,method,name,get,method,descriptor,method,equals,method,sig,return,new,lambda,executable,method,throw,new,type,extraction,exception,no,lambda,method,found,catch,exception,e,throw,new,type,extraction,exception,could,not,extract,lambda,method,out,of,function,e,get,class,get,simple,name,e,get,message,e
TypeExtractionUtils -> public static LambdaExecutable checkAndExtractLambda(Function function) throws TypeExtractionException;1509723634;Checks if the given function has been implemented using a Java 8 lambda. If yes, a LambdaExecutable_is returned describing the method/constructor. Otherwise null.__@throws TypeExtractionException lambda extraction is pretty hacky, it might fail for unknown JVM issues.;public static LambdaExecutable checkAndExtractLambda(Function function) throws TypeExtractionException {_		try {_			_			Object serializedLambda = null__			for (Class<?> clazz = function.getClass()_ clazz != null_ clazz = clazz.getSuperclass()) {_				try {_					Method replaceMethod = clazz.getDeclaredMethod("writeReplace")__					replaceMethod.setAccessible(true)__					Object serialVersion = replaceMethod.invoke(function)___					_					if (serialVersion.getClass().getName().equals("java.lang.invoke.SerializedLambda")) {__						_						try {_							Class.forName("java.lang.invoke.SerializedLambda")__						}_						catch (Exception e) {_							throw new TypeExtractionException("User code tries to use lambdas, but framework is running with a Java version < 8")__						}_						serializedLambda = serialVersion__						break__					}_				}_				catch (NoSuchMethodException e) {_					_				}_			}__			_			if (serializedLambda == null) {_				return null__			}__			_			Method implClassMethod = serializedLambda.getClass().getDeclaredMethod("getImplClass")__			Method implMethodNameMethod = serializedLambda.getClass().getDeclaredMethod("getImplMethodName")__			Method implMethodSig = serializedLambda.getClass().getDeclaredMethod("getImplMethodSignature")___			String className = (String) implClassMethod.invoke(serializedLambda)__			String methodName = (String) implMethodNameMethod.invoke(serializedLambda)__			String methodSig = (String) implMethodSig.invoke(serializedLambda)___			Class<?> implClass = Class.forName(className.replace('/', '.'), true, Thread.currentThread().getContextClassLoader())___			_			if (methodName.equals("<init>")) {_				Constructor<?>[] constructors = implClass.getDeclaredConstructors()__				for (Constructor<?> constructor : constructors) {_					if(getConstructorDescriptor(constructor).equals(methodSig)) {_						return new LambdaExecutable(constructor)__					}_				}_			}_			_			else {_				List<Method> methods = getAllDeclaredMethods(implClass)__				for (Method method : methods) {_					if(method.getName().equals(methodName) && getMethodDescriptor(method).equals(methodSig)) {_						return new LambdaExecutable(method)__					}_				}_			}_			throw new TypeExtractionException("No lambda method found.")__		}_		catch (Exception e) {_			throw new TypeExtractionException("Could not extract lambda method out of function: " +_				e.getClass().getSimpleName() + " - " + e.getMessage(), e)__		}_	};checks,if,the,given,function,has,been,implemented,using,a,java,8,lambda,if,yes,a,lambda,executable,is,returned,describing,the,method,constructor,otherwise,null,throws,type,extraction,exception,lambda,extraction,is,pretty,hacky,it,might,fail,for,unknown,jvm,issues;public,static,lambda,executable,check,and,extract,lambda,function,function,throws,type,extraction,exception,try,object,serialized,lambda,null,for,class,clazz,function,get,class,clazz,null,clazz,clazz,get,superclass,try,method,replace,method,clazz,get,declared,method,write,replace,replace,method,set,accessible,true,object,serial,version,replace,method,invoke,function,if,serial,version,get,class,get,name,equals,java,lang,invoke,serialized,lambda,try,class,for,name,java,lang,invoke,serialized,lambda,catch,exception,e,throw,new,type,extraction,exception,user,code,tries,to,use,lambdas,but,framework,is,running,with,a,java,version,8,serialized,lambda,serial,version,break,catch,no,such,method,exception,e,if,serialized,lambda,null,return,null,method,impl,class,method,serialized,lambda,get,class,get,declared,method,get,impl,class,method,impl,method,name,method,serialized,lambda,get,class,get,declared,method,get,impl,method,name,method,impl,method,sig,serialized,lambda,get,class,get,declared,method,get,impl,method,signature,string,class,name,string,impl,class,method,invoke,serialized,lambda,string,method,name,string,impl,method,name,method,invoke,serialized,lambda,string,method,sig,string,impl,method,sig,invoke,serialized,lambda,class,impl,class,class,for,name,class,name,replace,true,thread,current,thread,get,context,class,loader,if,method,name,equals,init,constructor,constructors,impl,class,get,declared,constructors,for,constructor,constructor,constructors,if,get,constructor,descriptor,constructor,equals,method,sig,return,new,lambda,executable,constructor,else,list,method,methods,get,all,declared,methods,impl,class,for,method,method,methods,if,method,get,name,equals,method,name,get,method,descriptor,method,equals,method,sig,return,new,lambda,executable,method,throw,new,type,extraction,exception,no,lambda,method,found,catch,exception,e,throw,new,type,extraction,exception,could,not,extract,lambda,method,out,of,function,e,get,class,get,simple,name,e,get,message,e
TypeExtractionUtils -> public static LambdaExecutable checkAndExtractLambda(Function function) throws TypeExtractionException;1510755099;Checks if the given function has been implemented using a Java 8 lambda. If yes, a LambdaExecutable_is returned describing the method/constructor. Otherwise null.__@throws TypeExtractionException lambda extraction is pretty hacky, it might fail for unknown JVM issues.;public static LambdaExecutable checkAndExtractLambda(Function function) throws TypeExtractionException {_		try {_			_			Object serializedLambda = null__			for (Class<?> clazz = function.getClass()_ clazz != null_ clazz = clazz.getSuperclass()) {_				try {_					Method replaceMethod = clazz.getDeclaredMethod("writeReplace")__					replaceMethod.setAccessible(true)__					Object serialVersion = replaceMethod.invoke(function)___					_					if (serialVersion.getClass().getName().equals("java.lang.invoke.SerializedLambda")) {__						_						try {_							Class.forName("java.lang.invoke.SerializedLambda")__						}_						catch (Exception e) {_							throw new TypeExtractionException("User code tries to use lambdas, but framework is running with a Java version < 8")__						}_						serializedLambda = serialVersion__						break__					}_				}_				catch (NoSuchMethodException e) {_					_				}_			}__			_			if (serializedLambda == null) {_				return null__			}__			_			Method implClassMethod = serializedLambda.getClass().getDeclaredMethod("getImplClass")__			Method implMethodNameMethod = serializedLambda.getClass().getDeclaredMethod("getImplMethodName")__			Method implMethodSig = serializedLambda.getClass().getDeclaredMethod("getImplMethodSignature")___			String className = (String) implClassMethod.invoke(serializedLambda)__			String methodName = (String) implMethodNameMethod.invoke(serializedLambda)__			String methodSig = (String) implMethodSig.invoke(serializedLambda)___			Class<?> implClass = Class.forName(className.replace('/', '.'), true, Thread.currentThread().getContextClassLoader())___			_			if (methodName.equals("<init>")) {_				Constructor<?>[] constructors = implClass.getDeclaredConstructors()__				for (Constructor<?> constructor : constructors) {_					if(getConstructorDescriptor(constructor).equals(methodSig)) {_						return new LambdaExecutable(constructor)__					}_				}_			}_			_			else {_				List<Method> methods = getAllDeclaredMethods(implClass)__				for (Method method : methods) {_					if(method.getName().equals(methodName) && getMethodDescriptor(method).equals(methodSig)) {_						return new LambdaExecutable(method)__					}_				}_			}_			throw new TypeExtractionException("No lambda method found.")__		}_		catch (Exception e) {_			throw new TypeExtractionException("Could not extract lambda method out of function: " +_				e.getClass().getSimpleName() + " - " + e.getMessage(), e)__		}_	};checks,if,the,given,function,has,been,implemented,using,a,java,8,lambda,if,yes,a,lambda,executable,is,returned,describing,the,method,constructor,otherwise,null,throws,type,extraction,exception,lambda,extraction,is,pretty,hacky,it,might,fail,for,unknown,jvm,issues;public,static,lambda,executable,check,and,extract,lambda,function,function,throws,type,extraction,exception,try,object,serialized,lambda,null,for,class,clazz,function,get,class,clazz,null,clazz,clazz,get,superclass,try,method,replace,method,clazz,get,declared,method,write,replace,replace,method,set,accessible,true,object,serial,version,replace,method,invoke,function,if,serial,version,get,class,get,name,equals,java,lang,invoke,serialized,lambda,try,class,for,name,java,lang,invoke,serialized,lambda,catch,exception,e,throw,new,type,extraction,exception,user,code,tries,to,use,lambdas,but,framework,is,running,with,a,java,version,8,serialized,lambda,serial,version,break,catch,no,such,method,exception,e,if,serialized,lambda,null,return,null,method,impl,class,method,serialized,lambda,get,class,get,declared,method,get,impl,class,method,impl,method,name,method,serialized,lambda,get,class,get,declared,method,get,impl,method,name,method,impl,method,sig,serialized,lambda,get,class,get,declared,method,get,impl,method,signature,string,class,name,string,impl,class,method,invoke,serialized,lambda,string,method,name,string,impl,method,name,method,invoke,serialized,lambda,string,method,sig,string,impl,method,sig,invoke,serialized,lambda,class,impl,class,class,for,name,class,name,replace,true,thread,current,thread,get,context,class,loader,if,method,name,equals,init,constructor,constructors,impl,class,get,declared,constructors,for,constructor,constructor,constructors,if,get,constructor,descriptor,constructor,equals,method,sig,return,new,lambda,executable,constructor,else,list,method,methods,get,all,declared,methods,impl,class,for,method,method,methods,if,method,get,name,equals,method,name,get,method,descriptor,method,equals,method,sig,return,new,lambda,executable,method,throw,new,type,extraction,exception,no,lambda,method,found,catch,exception,e,throw,new,type,extraction,exception,could,not,extract,lambda,method,out,of,function,e,get,class,get,simple,name,e,get,message,e
TypeExtractionUtils -> public static LambdaExecutable checkAndExtractLambda(Function function) throws TypeExtractionException;1518989074;Checks if the given function has been implemented using a Java 8 lambda. If yes, a LambdaExecutable_is returned describing the method/constructor. Otherwise null.__@throws TypeExtractionException lambda extraction is pretty hacky, it might fail for unknown JVM issues.;public static LambdaExecutable checkAndExtractLambda(Function function) throws TypeExtractionException {_		try {_			_			SerializedLambda serializedLambda = null__			for (Class<?> clazz = function.getClass()_ clazz != null_ clazz = clazz.getSuperclass()) {_				try {_					Method replaceMethod = clazz.getDeclaredMethod("writeReplace")__					replaceMethod.setAccessible(true)__					Object serialVersion = replaceMethod.invoke(function)___					_					if (serialVersion != null && serialVersion.getClass() == SerializedLambda.class) {_						serializedLambda = (SerializedLambda) serialVersion__						break__					}_				}_				catch (NoSuchMethodException e) {_					_				}_			}__			_			if (serializedLambda == null) {_				return null__			}__			_			String className = serializedLambda.getImplClass()__			String methodName = serializedLambda.getImplMethodName()__			String methodSig = serializedLambda.getImplMethodSignature()___			Class<?> implClass = Class.forName(className.replace('/', '.'), true, Thread.currentThread().getContextClassLoader())___			_			if (methodName.equals("<init>")) {_				Constructor<?>[] constructors = implClass.getDeclaredConstructors()__				for (Constructor<?> constructor : constructors) {_					if (getConstructorDescriptor(constructor).equals(methodSig)) {_						return new LambdaExecutable(constructor)__					}_				}_			}_			_			else {_				List<Method> methods = getAllDeclaredMethods(implClass)__				for (Method method : methods) {_					if (method.getName().equals(methodName) && getMethodDescriptor(method).equals(methodSig)) {_						return new LambdaExecutable(method)__					}_				}_			}_			throw new TypeExtractionException("No lambda method found.")__		}_		catch (Exception e) {_			throw new TypeExtractionException("Could not extract lambda method out of function: " +_				e.getClass().getSimpleName() + " - " + e.getMessage(), e)__		}_	};checks,if,the,given,function,has,been,implemented,using,a,java,8,lambda,if,yes,a,lambda,executable,is,returned,describing,the,method,constructor,otherwise,null,throws,type,extraction,exception,lambda,extraction,is,pretty,hacky,it,might,fail,for,unknown,jvm,issues;public,static,lambda,executable,check,and,extract,lambda,function,function,throws,type,extraction,exception,try,serialized,lambda,serialized,lambda,null,for,class,clazz,function,get,class,clazz,null,clazz,clazz,get,superclass,try,method,replace,method,clazz,get,declared,method,write,replace,replace,method,set,accessible,true,object,serial,version,replace,method,invoke,function,if,serial,version,null,serial,version,get,class,serialized,lambda,class,serialized,lambda,serialized,lambda,serial,version,break,catch,no,such,method,exception,e,if,serialized,lambda,null,return,null,string,class,name,serialized,lambda,get,impl,class,string,method,name,serialized,lambda,get,impl,method,name,string,method,sig,serialized,lambda,get,impl,method,signature,class,impl,class,class,for,name,class,name,replace,true,thread,current,thread,get,context,class,loader,if,method,name,equals,init,constructor,constructors,impl,class,get,declared,constructors,for,constructor,constructor,constructors,if,get,constructor,descriptor,constructor,equals,method,sig,return,new,lambda,executable,constructor,else,list,method,methods,get,all,declared,methods,impl,class,for,method,method,methods,if,method,get,name,equals,method,name,get,method,descriptor,method,equals,method,sig,return,new,lambda,executable,method,throw,new,type,extraction,exception,no,lambda,method,found,catch,exception,e,throw,new,type,extraction,exception,could,not,extract,lambda,method,out,of,function,e,get,class,get,simple,name,e,get,message,e
TypeExtractionUtils -> public static LambdaExecutable checkAndExtractLambda(Function function) throws TypeExtractionException;1532066767;Checks if the given function has been implemented using a Java 8 lambda. If yes, a LambdaExecutable_is returned describing the method/constructor. Otherwise null.__@throws TypeExtractionException lambda extraction is pretty hacky, it might fail for unknown JVM issues.;public static LambdaExecutable checkAndExtractLambda(Function function) throws TypeExtractionException {_		try {_			_			SerializedLambda serializedLambda = null__			for (Class<?> clazz = function.getClass()_ clazz != null_ clazz = clazz.getSuperclass()) {_				try {_					Method replaceMethod = clazz.getDeclaredMethod("writeReplace")__					replaceMethod.setAccessible(true)__					Object serialVersion = replaceMethod.invoke(function)___					_					if (serialVersion != null && serialVersion.getClass() == SerializedLambda.class) {_						serializedLambda = (SerializedLambda) serialVersion__						break__					}_				}_				catch (NoSuchMethodException e) {_					_				}_			}__			_			if (serializedLambda == null) {_				return null__			}__			_			String className = serializedLambda.getImplClass()__			String methodName = serializedLambda.getImplMethodName()__			String methodSig = serializedLambda.getImplMethodSignature()___			Class<?> implClass = Class.forName(className.replace('/', '.'), true, Thread.currentThread().getContextClassLoader())___			_			if (methodName.equals("<init>")) {_				Constructor<?>[] constructors = implClass.getDeclaredConstructors()__				for (Constructor<?> constructor : constructors) {_					if (getConstructorDescriptor(constructor).equals(methodSig)) {_						return new LambdaExecutable(constructor)__					}_				}_			}_			_			else {_				List<Method> methods = getAllDeclaredMethods(implClass)__				for (Method method : methods) {_					if (method.getName().equals(methodName) && getMethodDescriptor(method).equals(methodSig)) {_						return new LambdaExecutable(method)__					}_				}_			}_			throw new TypeExtractionException("No lambda method found.")__		}_		catch (Exception e) {_			throw new TypeExtractionException("Could not extract lambda method out of function: " +_				e.getClass().getSimpleName() + " - " + e.getMessage(), e)__		}_	};checks,if,the,given,function,has,been,implemented,using,a,java,8,lambda,if,yes,a,lambda,executable,is,returned,describing,the,method,constructor,otherwise,null,throws,type,extraction,exception,lambda,extraction,is,pretty,hacky,it,might,fail,for,unknown,jvm,issues;public,static,lambda,executable,check,and,extract,lambda,function,function,throws,type,extraction,exception,try,serialized,lambda,serialized,lambda,null,for,class,clazz,function,get,class,clazz,null,clazz,clazz,get,superclass,try,method,replace,method,clazz,get,declared,method,write,replace,replace,method,set,accessible,true,object,serial,version,replace,method,invoke,function,if,serial,version,null,serial,version,get,class,serialized,lambda,class,serialized,lambda,serialized,lambda,serial,version,break,catch,no,such,method,exception,e,if,serialized,lambda,null,return,null,string,class,name,serialized,lambda,get,impl,class,string,method,name,serialized,lambda,get,impl,method,name,string,method,sig,serialized,lambda,get,impl,method,signature,class,impl,class,class,for,name,class,name,replace,true,thread,current,thread,get,context,class,loader,if,method,name,equals,init,constructor,constructors,impl,class,get,declared,constructors,for,constructor,constructor,constructors,if,get,constructor,descriptor,constructor,equals,method,sig,return,new,lambda,executable,constructor,else,list,method,methods,get,all,declared,methods,impl,class,for,method,method,methods,if,method,get,name,equals,method,name,get,method,descriptor,method,equals,method,sig,return,new,lambda,executable,method,throw,new,type,extraction,exception,no,lambda,method,found,catch,exception,e,throw,new,type,extraction,exception,could,not,extract,lambda,method,out,of,function,e,get,class,get,simple,name,e,get,message,e
TypeExtractionUtils -> public static Type extractTypeFromLambda( 		LambdaExecutable exec, 		int[] lambdaTypeArgumentIndices, 		int paramLen, 		int baseParametersLen);1496911361;Extracts type from given index from lambda. It supports nested types.__@param exec lambda function to extract the type from_@param lambdaTypeArgumentIndices position of type to extract in type hierarchy_@param paramLen count of total parameters of the lambda (including closure parameters)_@param baseParametersLen count of lambda interface parameters (without closure parameters)_@return extracted type;public static Type extractTypeFromLambda(_		LambdaExecutable exec,_		int[] lambdaTypeArgumentIndices,_		int paramLen,_		int baseParametersLen) {_		Type output = exec.getParameterTypes()[paramLen - baseParametersLen + lambdaTypeArgumentIndices[0]]__		for (int i = 1_ i < lambdaTypeArgumentIndices.length_ i++) {_			output = extractTypeArgument(output, lambdaTypeArgumentIndices[i])__		}_		return output__	};extracts,type,from,given,index,from,lambda,it,supports,nested,types,param,exec,lambda,function,to,extract,the,type,from,param,lambda,type,argument,indices,position,of,type,to,extract,in,type,hierarchy,param,param,len,count,of,total,parameters,of,the,lambda,including,closure,parameters,param,base,parameters,len,count,of,lambda,interface,parameters,without,closure,parameters,return,extracted,type;public,static,type,extract,type,from,lambda,lambda,executable,exec,int,lambda,type,argument,indices,int,param,len,int,base,parameters,len,type,output,exec,get,parameter,types,param,len,base,parameters,len,lambda,type,argument,indices,0,for,int,i,1,i,lambda,type,argument,indices,length,i,output,extract,type,argument,output,lambda,type,argument,indices,i,return,output
TypeExtractionUtils -> public static Type extractTypeFromLambda( 		LambdaExecutable exec, 		int[] lambdaTypeArgumentIndices, 		int paramLen, 		int baseParametersLen);1498220070;Extracts type from given index from lambda. It supports nested types.__@param exec lambda function to extract the type from_@param lambdaTypeArgumentIndices position of type to extract in type hierarchy_@param paramLen count of total parameters of the lambda (including closure parameters)_@param baseParametersLen count of lambda interface parameters (without closure parameters)_@return extracted type;public static Type extractTypeFromLambda(_		LambdaExecutable exec,_		int[] lambdaTypeArgumentIndices,_		int paramLen,_		int baseParametersLen) {_		Type output = exec.getParameterTypes()[paramLen - baseParametersLen + lambdaTypeArgumentIndices[0]]__		for (int i = 1_ i < lambdaTypeArgumentIndices.length_ i++) {_			output = extractTypeArgument(output, lambdaTypeArgumentIndices[i])__		}_		return output__	};extracts,type,from,given,index,from,lambda,it,supports,nested,types,param,exec,lambda,function,to,extract,the,type,from,param,lambda,type,argument,indices,position,of,type,to,extract,in,type,hierarchy,param,param,len,count,of,total,parameters,of,the,lambda,including,closure,parameters,param,base,parameters,len,count,of,lambda,interface,parameters,without,closure,parameters,return,extracted,type;public,static,type,extract,type,from,lambda,lambda,executable,exec,int,lambda,type,argument,indices,int,param,len,int,base,parameters,len,type,output,exec,get,parameter,types,param,len,base,parameters,len,lambda,type,argument,indices,0,for,int,i,1,i,lambda,type,argument,indices,length,i,output,extract,type,argument,output,lambda,type,argument,indices,i,return,output
TypeExtractionUtils -> public static Type extractTypeFromLambda( 		LambdaExecutable exec, 		int[] lambdaTypeArgumentIndices, 		int paramLen, 		int baseParametersLen);1502357786;Extracts type from given index from lambda. It supports nested types.__@param exec lambda function to extract the type from_@param lambdaTypeArgumentIndices position of type to extract in type hierarchy_@param paramLen count of total parameters of the lambda (including closure parameters)_@param baseParametersLen count of lambda interface parameters (without closure parameters)_@return extracted type;public static Type extractTypeFromLambda(_		LambdaExecutable exec,_		int[] lambdaTypeArgumentIndices,_		int paramLen,_		int baseParametersLen) {_		Type output = exec.getParameterTypes()[paramLen - baseParametersLen + lambdaTypeArgumentIndices[0]]__		for (int i = 1_ i < lambdaTypeArgumentIndices.length_ i++) {_			output = extractTypeArgument(output, lambdaTypeArgumentIndices[i])__		}_		return output__	};extracts,type,from,given,index,from,lambda,it,supports,nested,types,param,exec,lambda,function,to,extract,the,type,from,param,lambda,type,argument,indices,position,of,type,to,extract,in,type,hierarchy,param,param,len,count,of,total,parameters,of,the,lambda,including,closure,parameters,param,base,parameters,len,count,of,lambda,interface,parameters,without,closure,parameters,return,extracted,type;public,static,type,extract,type,from,lambda,lambda,executable,exec,int,lambda,type,argument,indices,int,param,len,int,base,parameters,len,type,output,exec,get,parameter,types,param,len,base,parameters,len,lambda,type,argument,indices,0,for,int,i,1,i,lambda,type,argument,indices,length,i,output,extract,type,argument,output,lambda,type,argument,indices,i,return,output
TypeExtractionUtils -> public static Type extractTypeFromLambda( 		LambdaExecutable exec, 		int[] lambdaTypeArgumentIndices, 		int paramLen, 		int baseParametersLen);1509723634;Extracts type from given index from lambda. It supports nested types.__@param exec lambda function to extract the type from_@param lambdaTypeArgumentIndices position of type to extract in type hierarchy_@param paramLen count of total parameters of the lambda (including closure parameters)_@param baseParametersLen count of lambda interface parameters (without closure parameters)_@return extracted type;public static Type extractTypeFromLambda(_		LambdaExecutable exec,_		int[] lambdaTypeArgumentIndices,_		int paramLen,_		int baseParametersLen) {_		Type output = exec.getParameterTypes()[paramLen - baseParametersLen + lambdaTypeArgumentIndices[0]]__		for (int i = 1_ i < lambdaTypeArgumentIndices.length_ i++) {_			output = extractTypeArgument(output, lambdaTypeArgumentIndices[i])__		}_		return output__	};extracts,type,from,given,index,from,lambda,it,supports,nested,types,param,exec,lambda,function,to,extract,the,type,from,param,lambda,type,argument,indices,position,of,type,to,extract,in,type,hierarchy,param,param,len,count,of,total,parameters,of,the,lambda,including,closure,parameters,param,base,parameters,len,count,of,lambda,interface,parameters,without,closure,parameters,return,extracted,type;public,static,type,extract,type,from,lambda,lambda,executable,exec,int,lambda,type,argument,indices,int,param,len,int,base,parameters,len,type,output,exec,get,parameter,types,param,len,base,parameters,len,lambda,type,argument,indices,0,for,int,i,1,i,lambda,type,argument,indices,length,i,output,extract,type,argument,output,lambda,type,argument,indices,i,return,output
TypeExtractionUtils -> public static Type extractTypeFromLambda( 		LambdaExecutable exec, 		int[] lambdaTypeArgumentIndices, 		int paramLen, 		int baseParametersLen);1510755099;Extracts type from given index from lambda. It supports nested types.__@param exec lambda function to extract the type from_@param lambdaTypeArgumentIndices position of type to extract in type hierarchy_@param paramLen count of total parameters of the lambda (including closure parameters)_@param baseParametersLen count of lambda interface parameters (without closure parameters)_@return extracted type;public static Type extractTypeFromLambda(_		LambdaExecutable exec,_		int[] lambdaTypeArgumentIndices,_		int paramLen,_		int baseParametersLen) {_		Type output = exec.getParameterTypes()[paramLen - baseParametersLen + lambdaTypeArgumentIndices[0]]__		for (int i = 1_ i < lambdaTypeArgumentIndices.length_ i++) {_			output = extractTypeArgument(output, lambdaTypeArgumentIndices[i])__		}_		return output__	};extracts,type,from,given,index,from,lambda,it,supports,nested,types,param,exec,lambda,function,to,extract,the,type,from,param,lambda,type,argument,indices,position,of,type,to,extract,in,type,hierarchy,param,param,len,count,of,total,parameters,of,the,lambda,including,closure,parameters,param,base,parameters,len,count,of,lambda,interface,parameters,without,closure,parameters,return,extracted,type;public,static,type,extract,type,from,lambda,lambda,executable,exec,int,lambda,type,argument,indices,int,param,len,int,base,parameters,len,type,output,exec,get,parameter,types,param,len,base,parameters,len,lambda,type,argument,indices,0,for,int,i,1,i,lambda,type,argument,indices,length,i,output,extract,type,argument,output,lambda,type,argument,indices,i,return,output
TypeExtractionUtils -> public static Type extractTypeFromLambda( 		LambdaExecutable exec, 		int[] lambdaTypeArgumentIndices, 		int paramLen, 		int baseParametersLen);1518989074;Extracts type from given index from lambda. It supports nested types.__@param exec lambda function to extract the type from_@param lambdaTypeArgumentIndices position of type to extract in type hierarchy_@param paramLen count of total parameters of the lambda (including closure parameters)_@param baseParametersLen count of lambda interface parameters (without closure parameters)_@return extracted type;public static Type extractTypeFromLambda(_		LambdaExecutable exec,_		int[] lambdaTypeArgumentIndices,_		int paramLen,_		int baseParametersLen) {_		Type output = exec.getParameterTypes()[paramLen - baseParametersLen + lambdaTypeArgumentIndices[0]]__		for (int i = 1_ i < lambdaTypeArgumentIndices.length_ i++) {_			output = extractTypeArgument(output, lambdaTypeArgumentIndices[i])__		}_		return output__	};extracts,type,from,given,index,from,lambda,it,supports,nested,types,param,exec,lambda,function,to,extract,the,type,from,param,lambda,type,argument,indices,position,of,type,to,extract,in,type,hierarchy,param,param,len,count,of,total,parameters,of,the,lambda,including,closure,parameters,param,base,parameters,len,count,of,lambda,interface,parameters,without,closure,parameters,return,extracted,type;public,static,type,extract,type,from,lambda,lambda,executable,exec,int,lambda,type,argument,indices,int,param,len,int,base,parameters,len,type,output,exec,get,parameter,types,param,len,base,parameters,len,lambda,type,argument,indices,0,for,int,i,1,i,lambda,type,argument,indices,length,i,output,extract,type,argument,output,lambda,type,argument,indices,i,return,output
TypeExtractionUtils -> public static boolean sameTypeVars(Type t1, Type t2);1479218219;Checks whether two types are type variables describing the same.;public static boolean sameTypeVars(Type t1, Type t2) {_		return t1 instanceof TypeVariable &&_			t2 instanceof TypeVariable &&_			((TypeVariable<?>) t1).getName().equals(((TypeVariable<?>) t2).getName()) &&_			((TypeVariable<?>) t1).getGenericDeclaration().equals(((TypeVariable<?>) t2).getGenericDeclaration())__	};checks,whether,two,types,are,type,variables,describing,the,same;public,static,boolean,same,type,vars,type,t1,type,t2,return,t1,instanceof,type,variable,t2,instanceof,type,variable,type,variable,t1,get,name,equals,type,variable,t2,get,name,type,variable,t1,get,generic,declaration,equals,type,variable,t2,get,generic,declaration
TypeExtractionUtils -> public static boolean sameTypeVars(Type t1, Type t2);1496911361;Checks whether two types are type variables describing the same.;public static boolean sameTypeVars(Type t1, Type t2) {_		return t1 instanceof TypeVariable &&_			t2 instanceof TypeVariable &&_			((TypeVariable<?>) t1).getName().equals(((TypeVariable<?>) t2).getName()) &&_			((TypeVariable<?>) t1).getGenericDeclaration().equals(((TypeVariable<?>) t2).getGenericDeclaration())__	};checks,whether,two,types,are,type,variables,describing,the,same;public,static,boolean,same,type,vars,type,t1,type,t2,return,t1,instanceof,type,variable,t2,instanceof,type,variable,type,variable,t1,get,name,equals,type,variable,t2,get,name,type,variable,t1,get,generic,declaration,equals,type,variable,t2,get,generic,declaration
TypeExtractionUtils -> public static boolean sameTypeVars(Type t1, Type t2);1498220070;Checks whether two types are type variables describing the same.;public static boolean sameTypeVars(Type t1, Type t2) {_		return t1 instanceof TypeVariable &&_			t2 instanceof TypeVariable &&_			((TypeVariable<?>) t1).getName().equals(((TypeVariable<?>) t2).getName()) &&_			((TypeVariable<?>) t1).getGenericDeclaration().equals(((TypeVariable<?>) t2).getGenericDeclaration())__	};checks,whether,two,types,are,type,variables,describing,the,same;public,static,boolean,same,type,vars,type,t1,type,t2,return,t1,instanceof,type,variable,t2,instanceof,type,variable,type,variable,t1,get,name,equals,type,variable,t2,get,name,type,variable,t1,get,generic,declaration,equals,type,variable,t2,get,generic,declaration
TypeExtractionUtils -> public static boolean sameTypeVars(Type t1, Type t2);1502357786;Checks whether two types are type variables describing the same.;public static boolean sameTypeVars(Type t1, Type t2) {_		return t1 instanceof TypeVariable &&_			t2 instanceof TypeVariable &&_			((TypeVariable<?>) t1).getName().equals(((TypeVariable<?>) t2).getName()) &&_			((TypeVariable<?>) t1).getGenericDeclaration().equals(((TypeVariable<?>) t2).getGenericDeclaration())__	};checks,whether,two,types,are,type,variables,describing,the,same;public,static,boolean,same,type,vars,type,t1,type,t2,return,t1,instanceof,type,variable,t2,instanceof,type,variable,type,variable,t1,get,name,equals,type,variable,t2,get,name,type,variable,t1,get,generic,declaration,equals,type,variable,t2,get,generic,declaration
TypeExtractionUtils -> public static boolean sameTypeVars(Type t1, Type t2);1509723634;Checks whether two types are type variables describing the same.;public static boolean sameTypeVars(Type t1, Type t2) {_		return t1 instanceof TypeVariable &&_			t2 instanceof TypeVariable &&_			((TypeVariable<?>) t1).getName().equals(((TypeVariable<?>) t2).getName()) &&_			((TypeVariable<?>) t1).getGenericDeclaration().equals(((TypeVariable<?>) t2).getGenericDeclaration())__	};checks,whether,two,types,are,type,variables,describing,the,same;public,static,boolean,same,type,vars,type,t1,type,t2,return,t1,instanceof,type,variable,t2,instanceof,type,variable,type,variable,t1,get,name,equals,type,variable,t2,get,name,type,variable,t1,get,generic,declaration,equals,type,variable,t2,get,generic,declaration
TypeExtractionUtils -> public static boolean sameTypeVars(Type t1, Type t2);1510755099;Checks whether two types are type variables describing the same.;public static boolean sameTypeVars(Type t1, Type t2) {_		return t1 instanceof TypeVariable &&_			t2 instanceof TypeVariable &&_			((TypeVariable<?>) t1).getName().equals(((TypeVariable<?>) t2).getName()) &&_			((TypeVariable<?>) t1).getGenericDeclaration().equals(((TypeVariable<?>) t2).getGenericDeclaration())__	};checks,whether,two,types,are,type,variables,describing,the,same;public,static,boolean,same,type,vars,type,t1,type,t2,return,t1,instanceof,type,variable,t2,instanceof,type,variable,type,variable,t1,get,name,equals,type,variable,t2,get,name,type,variable,t1,get,generic,declaration,equals,type,variable,t2,get,generic,declaration
TypeExtractionUtils -> public static boolean sameTypeVars(Type t1, Type t2);1518989074;Checks whether two types are type variables describing the same.;public static boolean sameTypeVars(Type t1, Type t2) {_		return t1 instanceof TypeVariable &&_			t2 instanceof TypeVariable &&_			((TypeVariable<?>) t1).getName().equals(((TypeVariable<?>) t2).getName()) &&_			((TypeVariable<?>) t1).getGenericDeclaration().equals(((TypeVariable<?>) t2).getGenericDeclaration())__	};checks,whether,two,types,are,type,variables,describing,the,same;public,static,boolean,same,type,vars,type,t1,type,t2,return,t1,instanceof,type,variable,t2,instanceof,type,variable,type,variable,t1,get,name,equals,type,variable,t2,get,name,type,variable,t1,get,generic,declaration,equals,type,variable,t2,get,generic,declaration
TypeExtractionUtils -> public static boolean sameTypeVars(Type t1, Type t2);1532066767;Checks whether two types are type variables describing the same.;public static boolean sameTypeVars(Type t1, Type t2) {_		return t1 instanceof TypeVariable &&_			t2 instanceof TypeVariable &&_			((TypeVariable<?>) t1).getName().equals(((TypeVariable<?>) t2).getName()) &&_			((TypeVariable<?>) t1).getGenericDeclaration().equals(((TypeVariable<?>) t2).getGenericDeclaration())__	};checks,whether,two,types,are,type,variables,describing,the,same;public,static,boolean,same,type,vars,type,t1,type,t2,return,t1,instanceof,type,variable,t2,instanceof,type,variable,type,variable,t1,get,name,equals,type,variable,t2,get,name,type,variable,t1,get,generic,declaration,equals,type,variable,t2,get,generic,declaration
TypeExtractionUtils -> public static Class<?> typeToClass(Type t);1479218219;Convert ParameterizedType or Class to a Class.;public static Class<?> typeToClass(Type t) {_		if (t instanceof Class) {_			return (Class<?>)t__		}_		else if (t instanceof ParameterizedType) {_			return ((Class<?>)((ParameterizedType) t).getRawType())__		}_		throw new IllegalArgumentException("Cannot convert type to class")__	};convert,parameterized,type,or,class,to,a,class;public,static,class,type,to,class,type,t,if,t,instanceof,class,return,class,t,else,if,t,instanceof,parameterized,type,return,class,parameterized,type,t,get,raw,type,throw,new,illegal,argument,exception,cannot,convert,type,to,class
TypeExtractionUtils -> public static Class<?> typeToClass(Type t);1496911361;Convert ParameterizedType or Class to a Class.;public static Class<?> typeToClass(Type t) {_		if (t instanceof Class) {_			return (Class<?>)t__		}_		else if (t instanceof ParameterizedType) {_			return ((Class<?>)((ParameterizedType) t).getRawType())__		}_		throw new IllegalArgumentException("Cannot convert type to class")__	};convert,parameterized,type,or,class,to,a,class;public,static,class,type,to,class,type,t,if,t,instanceof,class,return,class,t,else,if,t,instanceof,parameterized,type,return,class,parameterized,type,t,get,raw,type,throw,new,illegal,argument,exception,cannot,convert,type,to,class
TypeExtractionUtils -> public static Class<?> typeToClass(Type t);1498220070;Convert ParameterizedType or Class to a Class.;public static Class<?> typeToClass(Type t) {_		if (t instanceof Class) {_			return (Class<?>)t__		}_		else if (t instanceof ParameterizedType) {_			return ((Class<?>)((ParameterizedType) t).getRawType())__		}_		throw new IllegalArgumentException("Cannot convert type to class")__	};convert,parameterized,type,or,class,to,a,class;public,static,class,type,to,class,type,t,if,t,instanceof,class,return,class,t,else,if,t,instanceof,parameterized,type,return,class,parameterized,type,t,get,raw,type,throw,new,illegal,argument,exception,cannot,convert,type,to,class
TypeExtractionUtils -> public static Class<?> typeToClass(Type t);1502357786;Convert ParameterizedType or Class to a Class.;public static Class<?> typeToClass(Type t) {_		if (t instanceof Class) {_			return (Class<?>)t__		}_		else if (t instanceof ParameterizedType) {_			return ((Class<?>)((ParameterizedType) t).getRawType())__		}_		throw new IllegalArgumentException("Cannot convert type to class")__	};convert,parameterized,type,or,class,to,a,class;public,static,class,type,to,class,type,t,if,t,instanceof,class,return,class,t,else,if,t,instanceof,parameterized,type,return,class,parameterized,type,t,get,raw,type,throw,new,illegal,argument,exception,cannot,convert,type,to,class
TypeExtractionUtils -> public static Class<?> typeToClass(Type t);1509723634;Convert ParameterizedType or Class to a Class.;public static Class<?> typeToClass(Type t) {_		if (t instanceof Class) {_			return (Class<?>)t__		}_		else if (t instanceof ParameterizedType) {_			return ((Class<?>)((ParameterizedType) t).getRawType())__		}_		throw new IllegalArgumentException("Cannot convert type to class")__	};convert,parameterized,type,or,class,to,a,class;public,static,class,type,to,class,type,t,if,t,instanceof,class,return,class,t,else,if,t,instanceof,parameterized,type,return,class,parameterized,type,t,get,raw,type,throw,new,illegal,argument,exception,cannot,convert,type,to,class
TypeExtractionUtils -> public static Class<?> typeToClass(Type t);1510755099;Convert ParameterizedType or Class to a Class.;public static Class<?> typeToClass(Type t) {_		if (t instanceof Class) {_			return (Class<?>)t__		}_		else if (t instanceof ParameterizedType) {_			return ((Class<?>)((ParameterizedType) t).getRawType())__		}_		throw new IllegalArgumentException("Cannot convert type to class")__	};convert,parameterized,type,or,class,to,a,class;public,static,class,type,to,class,type,t,if,t,instanceof,class,return,class,t,else,if,t,instanceof,parameterized,type,return,class,parameterized,type,t,get,raw,type,throw,new,illegal,argument,exception,cannot,convert,type,to,class
TypeExtractionUtils -> public static Class<?> typeToClass(Type t);1518989074;Convert ParameterizedType or Class to a Class.;public static Class<?> typeToClass(Type t) {_		if (t instanceof Class) {_			return (Class<?>)t__		}_		else if (t instanceof ParameterizedType) {_			return ((Class<?>) ((ParameterizedType) t).getRawType())__		}_		throw new IllegalArgumentException("Cannot convert type to class")__	};convert,parameterized,type,or,class,to,a,class;public,static,class,type,to,class,type,t,if,t,instanceof,class,return,class,t,else,if,t,instanceof,parameterized,type,return,class,parameterized,type,t,get,raw,type,throw,new,illegal,argument,exception,cannot,convert,type,to,class
TypeExtractionUtils -> public static Class<?> typeToClass(Type t);1532066767;Convert ParameterizedType or Class to a Class.;public static Class<?> typeToClass(Type t) {_		if (t instanceof Class) {_			return (Class<?>)t__		}_		else if (t instanceof ParameterizedType) {_			return ((Class<?>) ((ParameterizedType) t).getRawType())__		}_		throw new IllegalArgumentException("Cannot convert type to class")__	};convert,parameterized,type,or,class,to,a,class;public,static,class,type,to,class,type,t,if,t,instanceof,class,return,class,t,else,if,t,instanceof,parameterized,type,return,class,parameterized,type,t,get,raw,type,throw,new,illegal,argument,exception,cannot,convert,type,to,class
TypeExtractionUtils -> public static Type getTypeHierarchy(List<Type> typeHierarchy, Type t, Class<?> stopAtClass);1509723634;Traverses the type hierarchy of a type up until a certain stop class is found.__@param t type for which a hierarchy need to be created_@return type of the immediate child of the stop class;public static Type getTypeHierarchy(List<Type> typeHierarchy, Type t, Class<?> stopAtClass) {_		while (!(isClassType(t) && typeToClass(t).equals(stopAtClass))) {_			typeHierarchy.add(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return t__	};traverses,the,type,hierarchy,of,a,type,up,until,a,certain,stop,class,is,found,param,t,type,for,which,a,hierarchy,need,to,be,created,return,type,of,the,immediate,child,of,the,stop,class;public,static,type,get,type,hierarchy,list,type,type,hierarchy,type,t,class,stop,at,class,while,is,class,type,t,type,to,class,t,equals,stop,at,class,type,hierarchy,add,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,t
TypeExtractionUtils -> public static Type getTypeHierarchy(List<Type> typeHierarchy, Type t, Class<?> stopAtClass);1510755099;Traverses the type hierarchy of a type up until a certain stop class is found.__@param t type for which a hierarchy need to be created_@return type of the immediate child of the stop class;public static Type getTypeHierarchy(List<Type> typeHierarchy, Type t, Class<?> stopAtClass) {_		while (!(isClassType(t) && typeToClass(t).equals(stopAtClass))) {_			typeHierarchy.add(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return t__	};traverses,the,type,hierarchy,of,a,type,up,until,a,certain,stop,class,is,found,param,t,type,for,which,a,hierarchy,need,to,be,created,return,type,of,the,immediate,child,of,the,stop,class;public,static,type,get,type,hierarchy,list,type,type,hierarchy,type,t,class,stop,at,class,while,is,class,type,t,type,to,class,t,equals,stop,at,class,type,hierarchy,add,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,t
TypeExtractionUtils -> public static Type getTypeHierarchy(List<Type> typeHierarchy, Type t, Class<?> stopAtClass);1518989074;Traverses the type hierarchy of a type up until a certain stop class is found.__@param t type for which a hierarchy need to be created_@return type of the immediate child of the stop class;public static Type getTypeHierarchy(List<Type> typeHierarchy, Type t, Class<?> stopAtClass) {_		while (!(isClassType(t) && typeToClass(t).equals(stopAtClass))) {_			typeHierarchy.add(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return t__	};traverses,the,type,hierarchy,of,a,type,up,until,a,certain,stop,class,is,found,param,t,type,for,which,a,hierarchy,need,to,be,created,return,type,of,the,immediate,child,of,the,stop,class;public,static,type,get,type,hierarchy,list,type,type,hierarchy,type,t,class,stop,at,class,while,is,class,type,t,type,to,class,t,equals,stop,at,class,type,hierarchy,add,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,t
TypeExtractionUtils -> public static Type getTypeHierarchy(List<Type> typeHierarchy, Type t, Class<?> stopAtClass);1532066767;Traverses the type hierarchy of a type up until a certain stop class is found.__@param t type for which a hierarchy need to be created_@return type of the immediate child of the stop class;public static Type getTypeHierarchy(List<Type> typeHierarchy, Type t, Class<?> stopAtClass) {_		while (!(isClassType(t) && typeToClass(t).equals(stopAtClass))) {_			typeHierarchy.add(t)__			t = typeToClass(t).getGenericSuperclass()___			if (t == null) {_				break__			}_		}_		return t__	};traverses,the,type,hierarchy,of,a,type,up,until,a,certain,stop,class,is,found,param,t,type,for,which,a,hierarchy,need,to,be,created,return,type,of,the,immediate,child,of,the,stop,class;public,static,type,get,type,hierarchy,list,type,type,hierarchy,type,t,class,stop,at,class,while,is,class,type,t,type,to,class,t,equals,stop,at,class,type,hierarchy,add,t,t,type,to,class,t,get,generic,superclass,if,t,null,break,return,t
TypeExtractionUtils -> public static List<Method> getAllDeclaredMethods(Class<?> clazz);1476262965;Returns all declared methods of a class including methods of superclasses.;public static List<Method> getAllDeclaredMethods(Class<?> clazz) {_		List<Method> result = new ArrayList<>()__		while (clazz != null) {_			Method[] methods = clazz.getDeclaredMethods()__			Collections.addAll(result, methods)__			clazz = clazz.getSuperclass()__		}_		return result__	};returns,all,declared,methods,of,a,class,including,methods,of,superclasses;public,static,list,method,get,all,declared,methods,class,clazz,list,method,result,new,array,list,while,clazz,null,method,methods,clazz,get,declared,methods,collections,add,all,result,methods,clazz,clazz,get,superclass,return,result
TypeExtractionUtils -> public static List<Method> getAllDeclaredMethods(Class<?> clazz);1479218219;Returns all declared methods of a class including methods of superclasses.;public static List<Method> getAllDeclaredMethods(Class<?> clazz) {_		List<Method> result = new ArrayList<>()__		while (clazz != null) {_			Method[] methods = clazz.getDeclaredMethods()__			Collections.addAll(result, methods)__			clazz = clazz.getSuperclass()__		}_		return result__	};returns,all,declared,methods,of,a,class,including,methods,of,superclasses;public,static,list,method,get,all,declared,methods,class,clazz,list,method,result,new,array,list,while,clazz,null,method,methods,clazz,get,declared,methods,collections,add,all,result,methods,clazz,clazz,get,superclass,return,result
TypeExtractionUtils -> public static List<Method> getAllDeclaredMethods(Class<?> clazz);1496911361;Returns all declared methods of a class including methods of superclasses.;public static List<Method> getAllDeclaredMethods(Class<?> clazz) {_		List<Method> result = new ArrayList<>()__		while (clazz != null) {_			Method[] methods = clazz.getDeclaredMethods()__			Collections.addAll(result, methods)__			clazz = clazz.getSuperclass()__		}_		return result__	};returns,all,declared,methods,of,a,class,including,methods,of,superclasses;public,static,list,method,get,all,declared,methods,class,clazz,list,method,result,new,array,list,while,clazz,null,method,methods,clazz,get,declared,methods,collections,add,all,result,methods,clazz,clazz,get,superclass,return,result
TypeExtractionUtils -> public static List<Method> getAllDeclaredMethods(Class<?> clazz);1498220070;Returns all declared methods of a class including methods of superclasses.;public static List<Method> getAllDeclaredMethods(Class<?> clazz) {_		List<Method> result = new ArrayList<>()__		while (clazz != null) {_			Method[] methods = clazz.getDeclaredMethods()__			Collections.addAll(result, methods)__			clazz = clazz.getSuperclass()__		}_		return result__	};returns,all,declared,methods,of,a,class,including,methods,of,superclasses;public,static,list,method,get,all,declared,methods,class,clazz,list,method,result,new,array,list,while,clazz,null,method,methods,clazz,get,declared,methods,collections,add,all,result,methods,clazz,clazz,get,superclass,return,result
TypeExtractionUtils -> public static List<Method> getAllDeclaredMethods(Class<?> clazz);1502357786;Returns all declared methods of a class including methods of superclasses.;public static List<Method> getAllDeclaredMethods(Class<?> clazz) {_		List<Method> result = new ArrayList<>()__		while (clazz != null) {_			Method[] methods = clazz.getDeclaredMethods()__			Collections.addAll(result, methods)__			clazz = clazz.getSuperclass()__		}_		return result__	};returns,all,declared,methods,of,a,class,including,methods,of,superclasses;public,static,list,method,get,all,declared,methods,class,clazz,list,method,result,new,array,list,while,clazz,null,method,methods,clazz,get,declared,methods,collections,add,all,result,methods,clazz,clazz,get,superclass,return,result
TypeExtractionUtils -> public static List<Method> getAllDeclaredMethods(Class<?> clazz);1509723634;Returns all declared methods of a class including methods of superclasses.;public static List<Method> getAllDeclaredMethods(Class<?> clazz) {_		List<Method> result = new ArrayList<>()__		while (clazz != null) {_			Method[] methods = clazz.getDeclaredMethods()__			Collections.addAll(result, methods)__			clazz = clazz.getSuperclass()__		}_		return result__	};returns,all,declared,methods,of,a,class,including,methods,of,superclasses;public,static,list,method,get,all,declared,methods,class,clazz,list,method,result,new,array,list,while,clazz,null,method,methods,clazz,get,declared,methods,collections,add,all,result,methods,clazz,clazz,get,superclass,return,result
TypeExtractionUtils -> public static List<Method> getAllDeclaredMethods(Class<?> clazz);1510755099;Returns all declared methods of a class including methods of superclasses.;public static List<Method> getAllDeclaredMethods(Class<?> clazz) {_		List<Method> result = new ArrayList<>()__		while (clazz != null) {_			Method[] methods = clazz.getDeclaredMethods()__			Collections.addAll(result, methods)__			clazz = clazz.getSuperclass()__		}_		return result__	};returns,all,declared,methods,of,a,class,including,methods,of,superclasses;public,static,list,method,get,all,declared,methods,class,clazz,list,method,result,new,array,list,while,clazz,null,method,methods,clazz,get,declared,methods,collections,add,all,result,methods,clazz,clazz,get,superclass,return,result
TypeExtractionUtils -> public static List<Method> getAllDeclaredMethods(Class<?> clazz);1518989074;Returns all declared methods of a class including methods of superclasses.;public static List<Method> getAllDeclaredMethods(Class<?> clazz) {_		List<Method> result = new ArrayList<>()__		while (clazz != null) {_			Method[] methods = clazz.getDeclaredMethods()__			Collections.addAll(result, methods)__			clazz = clazz.getSuperclass()__		}_		return result__	};returns,all,declared,methods,of,a,class,including,methods,of,superclasses;public,static,list,method,get,all,declared,methods,class,clazz,list,method,result,new,array,list,while,clazz,null,method,methods,clazz,get,declared,methods,collections,add,all,result,methods,clazz,clazz,get,superclass,return,result
TypeExtractionUtils -> public static List<Method> getAllDeclaredMethods(Class<?> clazz);1532066767;Returns all declared methods of a class including methods of superclasses.;public static List<Method> getAllDeclaredMethods(Class<?> clazz) {_		List<Method> result = new ArrayList<>()__		while (clazz != null) {_			Method[] methods = clazz.getDeclaredMethods()__			Collections.addAll(result, methods)__			clazz = clazz.getSuperclass()__		}_		return result__	};returns,all,declared,methods,of,a,class,including,methods,of,superclasses;public,static,list,method,get,all,declared,methods,class,clazz,list,method,result,new,array,list,while,clazz,null,method,methods,clazz,get,declared,methods,collections,add,all,result,methods,clazz,clazz,get,superclass,return,result
TypeExtractionUtils -> public static boolean isClassType(Type t);1479218219;Checks if a type can be converted to a Class. This is true for ParameterizedType and Class.;public static boolean isClassType(Type t) {_		return t instanceof Class<?> || t instanceof ParameterizedType__	};checks,if,a,type,can,be,converted,to,a,class,this,is,true,for,parameterized,type,and,class;public,static,boolean,is,class,type,type,t,return,t,instanceof,class,t,instanceof,parameterized,type
TypeExtractionUtils -> public static boolean isClassType(Type t);1496911361;Checks if a type can be converted to a Class. This is true for ParameterizedType and Class.;public static boolean isClassType(Type t) {_		return t instanceof Class<?> || t instanceof ParameterizedType__	};checks,if,a,type,can,be,converted,to,a,class,this,is,true,for,parameterized,type,and,class;public,static,boolean,is,class,type,type,t,return,t,instanceof,class,t,instanceof,parameterized,type
TypeExtractionUtils -> public static boolean isClassType(Type t);1498220070;Checks if a type can be converted to a Class. This is true for ParameterizedType and Class.;public static boolean isClassType(Type t) {_		return t instanceof Class<?> || t instanceof ParameterizedType__	};checks,if,a,type,can,be,converted,to,a,class,this,is,true,for,parameterized,type,and,class;public,static,boolean,is,class,type,type,t,return,t,instanceof,class,t,instanceof,parameterized,type
TypeExtractionUtils -> public static boolean isClassType(Type t);1502357786;Checks if a type can be converted to a Class. This is true for ParameterizedType and Class.;public static boolean isClassType(Type t) {_		return t instanceof Class<?> || t instanceof ParameterizedType__	};checks,if,a,type,can,be,converted,to,a,class,this,is,true,for,parameterized,type,and,class;public,static,boolean,is,class,type,type,t,return,t,instanceof,class,t,instanceof,parameterized,type
TypeExtractionUtils -> public static boolean isClassType(Type t);1509723634;Checks if a type can be converted to a Class. This is true for ParameterizedType and Class.;public static boolean isClassType(Type t) {_		return t instanceof Class<?> || t instanceof ParameterizedType__	};checks,if,a,type,can,be,converted,to,a,class,this,is,true,for,parameterized,type,and,class;public,static,boolean,is,class,type,type,t,return,t,instanceof,class,t,instanceof,parameterized,type
TypeExtractionUtils -> public static boolean isClassType(Type t);1510755099;Checks if a type can be converted to a Class. This is true for ParameterizedType and Class.;public static boolean isClassType(Type t) {_		return t instanceof Class<?> || t instanceof ParameterizedType__	};checks,if,a,type,can,be,converted,to,a,class,this,is,true,for,parameterized,type,and,class;public,static,boolean,is,class,type,type,t,return,t,instanceof,class,t,instanceof,parameterized,type
TypeExtractionUtils -> public static boolean isClassType(Type t);1518989074;Checks if a type can be converted to a Class. This is true for ParameterizedType and Class.;public static boolean isClassType(Type t) {_		return t instanceof Class<?> || t instanceof ParameterizedType__	};checks,if,a,type,can,be,converted,to,a,class,this,is,true,for,parameterized,type,and,class;public,static,boolean,is,class,type,type,t,return,t,instanceof,class,t,instanceof,parameterized,type
TypeExtractionUtils -> public static boolean isClassType(Type t);1532066767;Checks if a type can be converted to a Class. This is true for ParameterizedType and Class.;public static boolean isClassType(Type t) {_		return t instanceof Class<?> || t instanceof ParameterizedType__	};checks,if,a,type,can,be,converted,to,a,class,this,is,true,for,parameterized,type,and,class;public,static,boolean,is,class,type,type,t,return,t,instanceof,class,t,instanceof,parameterized,type
TypeExtractionUtils -> public static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1496911361;This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;public static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if (t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_												index + " because the type has only " + actualTypeArguments.length +_												" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;public,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractionUtils -> public static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1498220070;This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;public static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if (t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_												index + " because the type has only " + actualTypeArguments.length +_												" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;public,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractionUtils -> public static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1502357786;This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;public static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if (t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_												index + " because the type has only " + actualTypeArguments.length +_												" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;public,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractionUtils -> public static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1509723634;This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;public static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if (t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_												index + " because the type has only " + actualTypeArguments.length +_												" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;public,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractionUtils -> public static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1510755099;This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;public static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if (t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_												index + " because the type has only " + actualTypeArguments.length +_												" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;public,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractionUtils -> public static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1518989074;This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;public static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if (t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_												index + " because the type has only " + actualTypeArguments.length +_												" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;public,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractionUtils -> public static Type extractTypeArgument(Type t, int index) throws InvalidTypesException;1532066767;This method extracts the n-th type argument from the given type. An InvalidTypesException_is thrown if the type does not have any type arguments or if the index exceeds the number_of type arguments.__@param t Type to extract the type arguments from_@param index Index of the type argument to extract_@return The extracted type argument_@throws InvalidTypesException if the given type does not have any type arguments or if the_index exceeds the number of type arguments.;public static Type extractTypeArgument(Type t, int index) throws InvalidTypesException {_		if (t instanceof ParameterizedType) {_			Type[] actualTypeArguments = ((ParameterizedType) t).getActualTypeArguments()___			if (index < 0 || index >= actualTypeArguments.length) {_				throw new InvalidTypesException("Cannot extract the type argument with index " +_												index + " because the type has only " + actualTypeArguments.length +_												" type arguments.")__			} else {_				return actualTypeArguments[index]__			}_		} else {_			throw new InvalidTypesException("The given type " + t + " is not a parameterized type.")__		}_	};this,method,extracts,the,n,th,type,argument,from,the,given,type,an,invalid,types,exception,is,thrown,if,the,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments,param,t,type,to,extract,the,type,arguments,from,param,index,index,of,the,type,argument,to,extract,return,the,extracted,type,argument,throws,invalid,types,exception,if,the,given,type,does,not,have,any,type,arguments,or,if,the,index,exceeds,the,number,of,type,arguments;public,static,type,extract,type,argument,type,t,int,index,throws,invalid,types,exception,if,t,instanceof,parameterized,type,type,actual,type,arguments,parameterized,type,t,get,actual,type,arguments,if,index,0,index,actual,type,arguments,length,throw,new,invalid,types,exception,cannot,extract,the,type,argument,with,index,index,because,the,type,has,only,actual,type,arguments,length,type,arguments,else,return,actual,type,arguments,index,else,throw,new,invalid,types,exception,the,given,type,t,is,not,a,parameterized,type
TypeExtractionUtils -> public static Method getSingleAbstractMethod(Class<?> baseClass);1496911361;Extracts a Single Abstract Method (SAM) as defined in Java Specification (4.3.2. The Class Object,_9.8 Functional Interfaces, 9.4.3 Interface Method Body) from given class.__@param baseClass_@throws InvalidTypesException if the given class does not implement_@return;public static Method getSingleAbstractMethod(Class<?> baseClass) {_		Method sam = null__		for (Method method : baseClass.getMethods()) {_			if (Modifier.isAbstract(method.getModifiers())) {_				if (sam == null) {_					sam = method__				} else {_					throw new InvalidTypesException(_						"Given class: " + baseClass + " is not a FunctionalInterface. It does not have a SAM.")__				}_			}_		}_		return sam__	};extracts,a,single,abstract,method,sam,as,defined,in,java,specification,4,3,2,the,class,object,9,8,functional,interfaces,9,4,3,interface,method,body,from,given,class,param,base,class,throws,invalid,types,exception,if,the,given,class,does,not,implement,return;public,static,method,get,single,abstract,method,class,base,class,method,sam,null,for,method,method,base,class,get,methods,if,modifier,is,abstract,method,get,modifiers,if,sam,null,sam,method,else,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,it,does,not,have,a,sam,return,sam
TypeExtractionUtils -> public static Method getSingleAbstractMethod(Class<?> baseClass);1498220070;Extracts a Single Abstract Method (SAM) as defined in Java Specification (4.3.2. The Class Object,_9.8 Functional Interfaces, 9.4.3 Interface Method Body) from given class.__@param baseClass a class that is a FunctionalInterface to retrieve a SAM from_@throws InvalidTypesException if the given class does not implement FunctionalInterface_@return single abstract method of the given class;public static Method getSingleAbstractMethod(Class<?> baseClass) {__		if (!baseClass.isInterface()) {_			throw new InvalidTypesException("Given class: " + baseClass + "is not a FunctionalInterface.")__		}__		Method sam = null__		for (Method method : baseClass.getMethods()) {_			if (Modifier.isAbstract(method.getModifiers())) {_				if (sam == null) {_					sam = method__				} else {_					throw new InvalidTypesException("Given class: " + baseClass +_						" is not a FunctionalInterface. It has more than one abstract method.")__				}_			}_		}__		if (sam == null) {_			throw new InvalidTypesException(_				"Given class: " + baseClass + " is not a FunctionalInterface. It does not have any abstract methods.")__		}__		return sam__	};extracts,a,single,abstract,method,sam,as,defined,in,java,specification,4,3,2,the,class,object,9,8,functional,interfaces,9,4,3,interface,method,body,from,given,class,param,base,class,a,class,that,is,a,functional,interface,to,retrieve,a,sam,from,throws,invalid,types,exception,if,the,given,class,does,not,implement,functional,interface,return,single,abstract,method,of,the,given,class;public,static,method,get,single,abstract,method,class,base,class,if,base,class,is,interface,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,method,sam,null,for,method,method,base,class,get,methods,if,modifier,is,abstract,method,get,modifiers,if,sam,null,sam,method,else,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,it,has,more,than,one,abstract,method,if,sam,null,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,it,does,not,have,any,abstract,methods,return,sam
TypeExtractionUtils -> public static Method getSingleAbstractMethod(Class<?> baseClass);1502357786;Extracts a Single Abstract Method (SAM) as defined in Java Specification (4.3.2. The Class Object,_9.8 Functional Interfaces, 9.4.3 Interface Method Body) from given class.__@param baseClass a class that is a FunctionalInterface to retrieve a SAM from_@throws InvalidTypesException if the given class does not implement FunctionalInterface_@return single abstract method of the given class;public static Method getSingleAbstractMethod(Class<?> baseClass) {__		if (!baseClass.isInterface()) {_			throw new InvalidTypesException("Given class: " + baseClass + "is not a FunctionalInterface.")__		}__		Method sam = null__		for (Method method : baseClass.getMethods()) {_			if (Modifier.isAbstract(method.getModifiers())) {_				if (sam == null) {_					sam = method__				} else {_					throw new InvalidTypesException("Given class: " + baseClass +_						" is not a FunctionalInterface. It has more than one abstract method.")__				}_			}_		}__		if (sam == null) {_			throw new InvalidTypesException(_				"Given class: " + baseClass + " is not a FunctionalInterface. It does not have any abstract methods.")__		}__		return sam__	};extracts,a,single,abstract,method,sam,as,defined,in,java,specification,4,3,2,the,class,object,9,8,functional,interfaces,9,4,3,interface,method,body,from,given,class,param,base,class,a,class,that,is,a,functional,interface,to,retrieve,a,sam,from,throws,invalid,types,exception,if,the,given,class,does,not,implement,functional,interface,return,single,abstract,method,of,the,given,class;public,static,method,get,single,abstract,method,class,base,class,if,base,class,is,interface,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,method,sam,null,for,method,method,base,class,get,methods,if,modifier,is,abstract,method,get,modifiers,if,sam,null,sam,method,else,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,it,has,more,than,one,abstract,method,if,sam,null,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,it,does,not,have,any,abstract,methods,return,sam
TypeExtractionUtils -> public static Method getSingleAbstractMethod(Class<?> baseClass);1509723634;Extracts a Single Abstract Method (SAM) as defined in Java Specification (4.3.2. The Class Object,_9.8 Functional Interfaces, 9.4.3 Interface Method Body) from given class.__@param baseClass a class that is a FunctionalInterface to retrieve a SAM from_@throws InvalidTypesException if the given class does not implement FunctionalInterface_@return single abstract method of the given class;public static Method getSingleAbstractMethod(Class<?> baseClass) {__		if (!baseClass.isInterface()) {_			throw new InvalidTypesException("Given class: " + baseClass + "is not a FunctionalInterface.")__		}__		Method sam = null__		for (Method method : baseClass.getMethods()) {_			if (Modifier.isAbstract(method.getModifiers())) {_				if (sam == null) {_					sam = method__				} else {_					throw new InvalidTypesException("Given class: " + baseClass +_						" is not a FunctionalInterface. It has more than one abstract method.")__				}_			}_		}__		if (sam == null) {_			throw new InvalidTypesException(_				"Given class: " + baseClass + " is not a FunctionalInterface. It does not have any abstract methods.")__		}__		return sam__	};extracts,a,single,abstract,method,sam,as,defined,in,java,specification,4,3,2,the,class,object,9,8,functional,interfaces,9,4,3,interface,method,body,from,given,class,param,base,class,a,class,that,is,a,functional,interface,to,retrieve,a,sam,from,throws,invalid,types,exception,if,the,given,class,does,not,implement,functional,interface,return,single,abstract,method,of,the,given,class;public,static,method,get,single,abstract,method,class,base,class,if,base,class,is,interface,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,method,sam,null,for,method,method,base,class,get,methods,if,modifier,is,abstract,method,get,modifiers,if,sam,null,sam,method,else,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,it,has,more,than,one,abstract,method,if,sam,null,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,it,does,not,have,any,abstract,methods,return,sam
TypeExtractionUtils -> public static Method getSingleAbstractMethod(Class<?> baseClass);1510755099;Extracts a Single Abstract Method (SAM) as defined in Java Specification (4.3.2. The Class Object,_9.8 Functional Interfaces, 9.4.3 Interface Method Body) from given class.__@param baseClass a class that is a FunctionalInterface to retrieve a SAM from_@throws InvalidTypesException if the given class does not implement FunctionalInterface_@return single abstract method of the given class;public static Method getSingleAbstractMethod(Class<?> baseClass) {__		if (!baseClass.isInterface()) {_			throw new InvalidTypesException("Given class: " + baseClass + "is not a FunctionalInterface.")__		}__		Method sam = null__		for (Method method : baseClass.getMethods()) {_			if (Modifier.isAbstract(method.getModifiers())) {_				if (sam == null) {_					sam = method__				} else {_					throw new InvalidTypesException("Given class: " + baseClass +_						" is not a FunctionalInterface. It has more than one abstract method.")__				}_			}_		}__		if (sam == null) {_			throw new InvalidTypesException(_				"Given class: " + baseClass + " is not a FunctionalInterface. It does not have any abstract methods.")__		}__		return sam__	};extracts,a,single,abstract,method,sam,as,defined,in,java,specification,4,3,2,the,class,object,9,8,functional,interfaces,9,4,3,interface,method,body,from,given,class,param,base,class,a,class,that,is,a,functional,interface,to,retrieve,a,sam,from,throws,invalid,types,exception,if,the,given,class,does,not,implement,functional,interface,return,single,abstract,method,of,the,given,class;public,static,method,get,single,abstract,method,class,base,class,if,base,class,is,interface,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,method,sam,null,for,method,method,base,class,get,methods,if,modifier,is,abstract,method,get,modifiers,if,sam,null,sam,method,else,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,it,has,more,than,one,abstract,method,if,sam,null,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,it,does,not,have,any,abstract,methods,return,sam
TypeExtractionUtils -> public static Method getSingleAbstractMethod(Class<?> baseClass);1518989074;Extracts a Single Abstract Method (SAM) as defined in Java Specification (4.3.2. The Class Object,_9.8 Functional Interfaces, 9.4.3 Interface Method Body) from given class.__@param baseClass a class that is a FunctionalInterface to retrieve a SAM from_@throws InvalidTypesException if the given class does not implement FunctionalInterface_@return single abstract method of the given class;public static Method getSingleAbstractMethod(Class<?> baseClass) {__		if (!baseClass.isInterface()) {_			throw new InvalidTypesException("Given class: " + baseClass + "is not a FunctionalInterface.")__		}__		Method sam = null__		for (Method method : baseClass.getMethods()) {_			if (Modifier.isAbstract(method.getModifiers())) {_				if (sam == null) {_					sam = method__				} else {_					throw new InvalidTypesException("Given class: " + baseClass +_						" is not a FunctionalInterface. It has more than one abstract method.")__				}_			}_		}__		if (sam == null) {_			throw new InvalidTypesException(_				"Given class: " + baseClass + " is not a FunctionalInterface. It does not have any abstract methods.")__		}__		return sam__	};extracts,a,single,abstract,method,sam,as,defined,in,java,specification,4,3,2,the,class,object,9,8,functional,interfaces,9,4,3,interface,method,body,from,given,class,param,base,class,a,class,that,is,a,functional,interface,to,retrieve,a,sam,from,throws,invalid,types,exception,if,the,given,class,does,not,implement,functional,interface,return,single,abstract,method,of,the,given,class;public,static,method,get,single,abstract,method,class,base,class,if,base,class,is,interface,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,method,sam,null,for,method,method,base,class,get,methods,if,modifier,is,abstract,method,get,modifiers,if,sam,null,sam,method,else,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,it,has,more,than,one,abstract,method,if,sam,null,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,it,does,not,have,any,abstract,methods,return,sam
TypeExtractionUtils -> public static Method getSingleAbstractMethod(Class<?> baseClass);1532066767;Extracts a Single Abstract Method (SAM) as defined in Java Specification (4.3.2. The Class Object,_9.8 Functional Interfaces, 9.4.3 Interface Method Body) from given class.__@param baseClass a class that is a FunctionalInterface to retrieve a SAM from_@throws InvalidTypesException if the given class does not implement FunctionalInterface_@return single abstract method of the given class;public static Method getSingleAbstractMethod(Class<?> baseClass) {__		if (!baseClass.isInterface()) {_			throw new InvalidTypesException("Given class: " + baseClass + "is not a FunctionalInterface.")__		}__		Method sam = null__		for (Method method : baseClass.getMethods()) {_			if (Modifier.isAbstract(method.getModifiers())) {_				if (sam == null) {_					sam = method__				} else {_					throw new InvalidTypesException("Given class: " + baseClass +_						" is not a FunctionalInterface. It has more than one abstract method.")__				}_			}_		}__		if (sam == null) {_			throw new InvalidTypesException(_				"Given class: " + baseClass + " is not a FunctionalInterface. It does not have any abstract methods.")__		}__		return sam__	};extracts,a,single,abstract,method,sam,as,defined,in,java,specification,4,3,2,the,class,object,9,8,functional,interfaces,9,4,3,interface,method,body,from,given,class,param,base,class,a,class,that,is,a,functional,interface,to,retrieve,a,sam,from,throws,invalid,types,exception,if,the,given,class,does,not,implement,functional,interface,return,single,abstract,method,of,the,given,class;public,static,method,get,single,abstract,method,class,base,class,if,base,class,is,interface,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,method,sam,null,for,method,method,base,class,get,methods,if,modifier,is,abstract,method,get,modifiers,if,sam,null,sam,method,else,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,it,has,more,than,one,abstract,method,if,sam,null,throw,new,invalid,types,exception,given,class,base,class,is,not,a,functional,interface,it,does,not,have,any,abstract,methods,return,sam
TypeExtractionUtils -> public static boolean hasSuperclass(Class<?> clazz, String superClassName);1509723634;Returns true if the given class has a superclass of given name.__@param clazz class to be analyzed_@param superClassName class name of the super class;public static boolean hasSuperclass(Class<?> clazz, String superClassName) {_		List<Type> hierarchy = new ArrayList<>()__		getTypeHierarchy(hierarchy, clazz, Object.class)__		for (Type t : hierarchy) {_			if (isClassType(t) && typeToClass(t).getName().equals(superClassName)) {_				return true__			}_		}_		return false__	};returns,true,if,the,given,class,has,a,superclass,of,given,name,param,clazz,class,to,be,analyzed,param,super,class,name,class,name,of,the,super,class;public,static,boolean,has,superclass,class,clazz,string,super,class,name,list,type,hierarchy,new,array,list,get,type,hierarchy,hierarchy,clazz,object,class,for,type,t,hierarchy,if,is,class,type,t,type,to,class,t,get,name,equals,super,class,name,return,true,return,false
TypeExtractionUtils -> public static boolean hasSuperclass(Class<?> clazz, String superClassName);1510755099;Returns true if the given class has a superclass of given name.__@param clazz class to be analyzed_@param superClassName class name of the super class;public static boolean hasSuperclass(Class<?> clazz, String superClassName) {_		List<Type> hierarchy = new ArrayList<>()__		getTypeHierarchy(hierarchy, clazz, Object.class)__		for (Type t : hierarchy) {_			if (isClassType(t) && typeToClass(t).getName().equals(superClassName)) {_				return true__			}_		}_		return false__	};returns,true,if,the,given,class,has,a,superclass,of,given,name,param,clazz,class,to,be,analyzed,param,super,class,name,class,name,of,the,super,class;public,static,boolean,has,superclass,class,clazz,string,super,class,name,list,type,hierarchy,new,array,list,get,type,hierarchy,hierarchy,clazz,object,class,for,type,t,hierarchy,if,is,class,type,t,type,to,class,t,get,name,equals,super,class,name,return,true,return,false
TypeExtractionUtils -> public static boolean hasSuperclass(Class<?> clazz, String superClassName);1518989074;Returns true if the given class has a superclass of given name.__@param clazz class to be analyzed_@param superClassName class name of the super class;public static boolean hasSuperclass(Class<?> clazz, String superClassName) {_		List<Type> hierarchy = new ArrayList<>()__		getTypeHierarchy(hierarchy, clazz, Object.class)__		for (Type t : hierarchy) {_			if (isClassType(t) && typeToClass(t).getName().equals(superClassName)) {_				return true__			}_		}_		return false__	};returns,true,if,the,given,class,has,a,superclass,of,given,name,param,clazz,class,to,be,analyzed,param,super,class,name,class,name,of,the,super,class;public,static,boolean,has,superclass,class,clazz,string,super,class,name,list,type,hierarchy,new,array,list,get,type,hierarchy,hierarchy,clazz,object,class,for,type,t,hierarchy,if,is,class,type,t,type,to,class,t,get,name,equals,super,class,name,return,true,return,false
TypeExtractionUtils -> public static boolean hasSuperclass(Class<?> clazz, String superClassName);1532066767;Returns true if the given class has a superclass of given name.__@param clazz class to be analyzed_@param superClassName class name of the super class;public static boolean hasSuperclass(Class<?> clazz, String superClassName) {_		List<Type> hierarchy = new ArrayList<>()__		getTypeHierarchy(hierarchy, clazz, Object.class)__		for (Type t : hierarchy) {_			if (isClassType(t) && typeToClass(t).getName().equals(superClassName)) {_				return true__			}_		}_		return false__	};returns,true,if,the,given,class,has,a,superclass,of,given,name,param,clazz,class,to,be,analyzed,param,super,class,name,class,name,of,the,super,class;public,static,boolean,has,superclass,class,clazz,string,super,class,name,list,type,hierarchy,new,array,list,get,type,hierarchy,hierarchy,clazz,object,class,for,type,t,hierarchy,if,is,class,type,t,type,to,class,t,get,name,equals,super,class,name,return,true,return,false
