# id;timestamp;commentText;codeText;commentWords;codeWords
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentFieldOrder() throws Exception;1494180263;Verifies that reconfiguration reorders the fields of the new Pojo serializer to remain the same.;@Test_	public void testReconfigureWithDifferentFieldOrder() throws Exception {_		Field[] mockOriginalFieldOrder = {_			TestUserClass.class.getField("dumm4"),_			TestUserClass.class.getField("dumm3"),_			TestUserClass.class.getField("nestedClass"),_			TestUserClass.class.getField("dumm1"),_			TestUserClass.class.getField("dumm2"),_			TestUserClass.class.getField("dumm5"),_		}___		_		PojoSerializer<TestUserClass> ser = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		LinkedHashMap<Field, TypeSerializerConfigSnapshot> mockOriginalFieldToSerializerConfigSnapshot =_			new LinkedHashMap<>(mockOriginalFieldOrder.length)__		mockOriginalFieldToSerializerConfigSnapshot.put(mockOriginalFieldOrder[0], ser.getFieldSerializers()[3].snapshotConfiguration())__		mockOriginalFieldToSerializerConfigSnapshot.put(mockOriginalFieldOrder[1], ser.getFieldSerializers()[2].snapshotConfiguration())__		mockOriginalFieldToSerializerConfigSnapshot.put(mockOriginalFieldOrder[2], ser.getFieldSerializers()[5].snapshotConfiguration())__		mockOriginalFieldToSerializerConfigSnapshot.put(mockOriginalFieldOrder[3], ser.getFieldSerializers()[0].snapshotConfiguration())__		mockOriginalFieldToSerializerConfigSnapshot.put(mockOriginalFieldOrder[4], ser.getFieldSerializers()[1].snapshotConfiguration())__		mockOriginalFieldToSerializerConfigSnapshot.put(mockOriginalFieldOrder[5], ser.getFieldSerializers()[4].snapshotConfiguration())___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		assertEquals(TestUserClass.class.getField("dumm1"), pojoSerializer.getFields()[0])__		assertEquals(TestUserClass.class.getField("dumm2"), pojoSerializer.getFields()[1])__		assertEquals(TestUserClass.class.getField("dumm3"), pojoSerializer.getFields()[2])__		assertEquals(TestUserClass.class.getField("dumm4"), pojoSerializer.getFields()[3])__		assertEquals(TestUserClass.class.getField("dumm5"), pojoSerializer.getFields()[4])__		assertEquals(TestUserClass.class.getField("nestedClass"), pojoSerializer.getFields()[5])___		PojoSerializer.PojoSerializerConfigSnapshot<TestUserClass> mockPreviousConfigSnapshot =_			new PojoSerializer.PojoSerializerConfigSnapshot<>(_				TestUserClass.class,_				mockOriginalFieldToSerializerConfigSnapshot, _				new LinkedHashMap<Class<?>, TypeSerializerConfigSnapshot>(), _				new HashMap<Class<?>, TypeSerializerConfigSnapshot>())_ __		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(__			mockPreviousConfigSnapshot)__		assertFalse(compatResult.requiresMigration())__		int i = 0__		for (Field field : mockOriginalFieldOrder) {_			assertEquals(field, pojoSerializer.getFields()[i])__			i++__		}_	};verifies,that,reconfiguration,reorders,the,fields,of,the,new,pojo,serializer,to,remain,the,same;test,public,void,test,reconfigure,with,different,field,order,throws,exception,field,mock,original,field,order,test,user,class,class,get,field,dumm4,test,user,class,class,get,field,dumm3,test,user,class,class,get,field,nested,class,test,user,class,class,get,field,dumm1,test,user,class,class,get,field,dumm2,test,user,class,class,get,field,dumm5,pojo,serializer,test,user,class,ser,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,linked,hash,map,field,type,serializer,config,snapshot,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,mock,original,field,order,length,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,0,ser,get,field,serializers,3,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,1,ser,get,field,serializers,2,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,2,ser,get,field,serializers,5,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,3,ser,get,field,serializers,0,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,4,ser,get,field,serializers,1,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,5,ser,get,field,serializers,4,snapshot,configuration,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,assert,equals,test,user,class,class,get,field,dumm1,pojo,serializer,get,fields,0,assert,equals,test,user,class,class,get,field,dumm2,pojo,serializer,get,fields,1,assert,equals,test,user,class,class,get,field,dumm3,pojo,serializer,get,fields,2,assert,equals,test,user,class,class,get,field,dumm4,pojo,serializer,get,fields,3,assert,equals,test,user,class,class,get,field,dumm5,pojo,serializer,get,fields,4,assert,equals,test,user,class,class,get,field,nested,class,pojo,serializer,get,fields,5,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,mock,previous,config,snapshot,new,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,class,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,class,type,serializer,config,snapshot,new,hash,map,class,type,serializer,config,snapshot,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,mock,previous,config,snapshot,assert,false,compat,result,requires,migration,int,i,0,for,field,field,mock,original,field,order,assert,equals,field,pojo,serializer,get,fields,i,i
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentFieldOrder() throws Exception;1494658833;Verifies that reconfiguration reorders the fields of the new Pojo serializer to remain the same.;@Test_	public void testReconfigureWithDifferentFieldOrder() throws Exception {_		Field[] mockOriginalFieldOrder = {_			TestUserClass.class.getField("dumm4"),_			TestUserClass.class.getField("dumm3"),_			TestUserClass.class.getField("nestedClass"),_			TestUserClass.class.getField("dumm1"),_			TestUserClass.class.getField("dumm2"),_			TestUserClass.class.getField("dumm5"),_		}___		_		PojoSerializer<TestUserClass> ser = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		LinkedHashMap<Field, TypeSerializerConfigSnapshot> mockOriginalFieldToSerializerConfigSnapshot =_			new LinkedHashMap<>(mockOriginalFieldOrder.length)__		mockOriginalFieldToSerializerConfigSnapshot.put(mockOriginalFieldOrder[0], ser.getFieldSerializers()[3].snapshotConfiguration())__		mockOriginalFieldToSerializerConfigSnapshot.put(mockOriginalFieldOrder[1], ser.getFieldSerializers()[2].snapshotConfiguration())__		mockOriginalFieldToSerializerConfigSnapshot.put(mockOriginalFieldOrder[2], ser.getFieldSerializers()[5].snapshotConfiguration())__		mockOriginalFieldToSerializerConfigSnapshot.put(mockOriginalFieldOrder[3], ser.getFieldSerializers()[0].snapshotConfiguration())__		mockOriginalFieldToSerializerConfigSnapshot.put(mockOriginalFieldOrder[4], ser.getFieldSerializers()[1].snapshotConfiguration())__		mockOriginalFieldToSerializerConfigSnapshot.put(mockOriginalFieldOrder[5], ser.getFieldSerializers()[4].snapshotConfiguration())___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		assertEquals(TestUserClass.class.getField("dumm1"), pojoSerializer.getFields()[0])__		assertEquals(TestUserClass.class.getField("dumm2"), pojoSerializer.getFields()[1])__		assertEquals(TestUserClass.class.getField("dumm3"), pojoSerializer.getFields()[2])__		assertEquals(TestUserClass.class.getField("dumm4"), pojoSerializer.getFields()[3])__		assertEquals(TestUserClass.class.getField("dumm5"), pojoSerializer.getFields()[4])__		assertEquals(TestUserClass.class.getField("nestedClass"), pojoSerializer.getFields()[5])___		PojoSerializer.PojoSerializerConfigSnapshot<TestUserClass> mockPreviousConfigSnapshot =_			new PojoSerializer.PojoSerializerConfigSnapshot<>(_				TestUserClass.class,_				mockOriginalFieldToSerializerConfigSnapshot, _				new LinkedHashMap<Class<?>, TypeSerializerConfigSnapshot>(), _				new HashMap<Class<?>, TypeSerializerConfigSnapshot>())_ __		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(__			mockPreviousConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		int i = 0__		for (Field field : mockOriginalFieldOrder) {_			assertEquals(field, pojoSerializer.getFields()[i])__			i++__		}_	};verifies,that,reconfiguration,reorders,the,fields,of,the,new,pojo,serializer,to,remain,the,same;test,public,void,test,reconfigure,with,different,field,order,throws,exception,field,mock,original,field,order,test,user,class,class,get,field,dumm4,test,user,class,class,get,field,dumm3,test,user,class,class,get,field,nested,class,test,user,class,class,get,field,dumm1,test,user,class,class,get,field,dumm2,test,user,class,class,get,field,dumm5,pojo,serializer,test,user,class,ser,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,linked,hash,map,field,type,serializer,config,snapshot,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,mock,original,field,order,length,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,0,ser,get,field,serializers,3,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,1,ser,get,field,serializers,2,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,2,ser,get,field,serializers,5,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,3,ser,get,field,serializers,0,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,4,ser,get,field,serializers,1,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,5,ser,get,field,serializers,4,snapshot,configuration,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,assert,equals,test,user,class,class,get,field,dumm1,pojo,serializer,get,fields,0,assert,equals,test,user,class,class,get,field,dumm2,pojo,serializer,get,fields,1,assert,equals,test,user,class,class,get,field,dumm3,pojo,serializer,get,fields,2,assert,equals,test,user,class,class,get,field,dumm4,pojo,serializer,get,fields,3,assert,equals,test,user,class,class,get,field,dumm5,pojo,serializer,get,fields,4,assert,equals,test,user,class,class,get,field,nested,class,pojo,serializer,get,fields,5,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,mock,previous,config,snapshot,new,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,class,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,class,type,serializer,config,snapshot,new,hash,map,class,type,serializer,config,snapshot,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,mock,previous,config,snapshot,assert,false,compat,result,is,requires,migration,int,i,0,for,field,field,mock,original,field,order,assert,equals,field,pojo,serializer,get,fields,i,i
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentFieldOrder() throws Exception;1495466666;Verifies that reconfiguration reorders the fields of the new Pojo serializer to remain the same.;@Test_	public void testReconfigureWithDifferentFieldOrder() throws Exception {_		Field[] mockOriginalFieldOrder = {_			TestUserClass.class.getField("dumm4"),_			TestUserClass.class.getField("dumm3"),_			TestUserClass.class.getField("nestedClass"),_			TestUserClass.class.getField("dumm1"),_			TestUserClass.class.getField("dumm2"),_			TestUserClass.class.getField("dumm5"),_		}___		_		PojoSerializer<TestUserClass> ser = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		LinkedHashMap<Field, Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>> mockOriginalFieldToSerializerConfigSnapshot =_			new LinkedHashMap<>(mockOriginalFieldOrder.length)__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[0],_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[3],_				ser.getFieldSerializers()[3].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[1],_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[2],_				ser.getFieldSerializers()[2].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[2],_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[5],_				ser.getFieldSerializers()[5].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[3],_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[0],_				ser.getFieldSerializers()[0].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[4],_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[1],_				ser.getFieldSerializers()[1].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[5],_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[4],_				ser.getFieldSerializers()[4].snapshotConfiguration()))___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		assertEquals(TestUserClass.class.getField("dumm1"), pojoSerializer.getFields()[0])__		assertEquals(TestUserClass.class.getField("dumm2"), pojoSerializer.getFields()[1])__		assertEquals(TestUserClass.class.getField("dumm3"), pojoSerializer.getFields()[2])__		assertEquals(TestUserClass.class.getField("dumm4"), pojoSerializer.getFields()[3])__		assertEquals(TestUserClass.class.getField("dumm5"), pojoSerializer.getFields()[4])__		assertEquals(TestUserClass.class.getField("nestedClass"), pojoSerializer.getFields()[5])___		PojoSerializer.PojoSerializerConfigSnapshot<TestUserClass> mockPreviousConfigSnapshot =_			new PojoSerializer.PojoSerializerConfigSnapshot<>(_				TestUserClass.class,_				mockOriginalFieldToSerializerConfigSnapshot, _				new LinkedHashMap<Class<?>, Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>>(), _				new HashMap<Class<?>, Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>>())_ __		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(mockPreviousConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		int i = 0__		for (Field field : mockOriginalFieldOrder) {_			assertEquals(field, pojoSerializer.getFields()[i])__			i++__		}_	};verifies,that,reconfiguration,reorders,the,fields,of,the,new,pojo,serializer,to,remain,the,same;test,public,void,test,reconfigure,with,different,field,order,throws,exception,field,mock,original,field,order,test,user,class,class,get,field,dumm4,test,user,class,class,get,field,dumm3,test,user,class,class,get,field,nested,class,test,user,class,class,get,field,dumm1,test,user,class,class,get,field,dumm2,test,user,class,class,get,field,dumm5,pojo,serializer,test,user,class,ser,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,linked,hash,map,field,tuple2,type,serializer,type,serializer,config,snapshot,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,mock,original,field,order,length,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,0,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,3,ser,get,field,serializers,3,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,1,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,2,ser,get,field,serializers,2,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,2,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,5,ser,get,field,serializers,5,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,3,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,0,ser,get,field,serializers,0,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,4,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,1,ser,get,field,serializers,1,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,5,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,4,ser,get,field,serializers,4,snapshot,configuration,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,assert,equals,test,user,class,class,get,field,dumm1,pojo,serializer,get,fields,0,assert,equals,test,user,class,class,get,field,dumm2,pojo,serializer,get,fields,1,assert,equals,test,user,class,class,get,field,dumm3,pojo,serializer,get,fields,2,assert,equals,test,user,class,class,get,field,dumm4,pojo,serializer,get,fields,3,assert,equals,test,user,class,class,get,field,dumm5,pojo,serializer,get,fields,4,assert,equals,test,user,class,class,get,field,nested,class,pojo,serializer,get,fields,5,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,mock,previous,config,snapshot,new,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,class,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,class,tuple2,type,serializer,type,serializer,config,snapshot,new,hash,map,class,tuple2,type,serializer,type,serializer,config,snapshot,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,mock,previous,config,snapshot,assert,false,compat,result,is,requires,migration,int,i,0,for,field,field,mock,original,field,order,assert,equals,field,pojo,serializer,get,fields,i,i
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentFieldOrder() throws Exception;1497328697;Verifies that reconfiguration reorders the fields of the new Pojo serializer to remain the same.;@Test_	public void testReconfigureWithDifferentFieldOrder() throws Exception {_		Field[] mockOriginalFieldOrder = {_			TestUserClass.class.getField("dumm4"),_			TestUserClass.class.getField("dumm3"),_			TestUserClass.class.getField("nestedClass"),_			TestUserClass.class.getField("dumm1"),_			TestUserClass.class.getField("dumm2"),_			TestUserClass.class.getField("dumm5"),_		}___		_		PojoSerializer<TestUserClass> ser = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		LinkedHashMap<String, Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>> mockOriginalFieldToSerializerConfigSnapshot =_			new LinkedHashMap<>(mockOriginalFieldOrder.length)__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[0].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[3],_				ser.getFieldSerializers()[3].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[1].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[2],_				ser.getFieldSerializers()[2].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[2].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[5],_				ser.getFieldSerializers()[5].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[3].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[0],_				ser.getFieldSerializers()[0].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[4].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[1],_				ser.getFieldSerializers()[1].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[5].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[4],_				ser.getFieldSerializers()[4].snapshotConfiguration()))___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		assertEquals(TestUserClass.class.getField("dumm1"), pojoSerializer.getFields()[0])__		assertEquals(TestUserClass.class.getField("dumm2"), pojoSerializer.getFields()[1])__		assertEquals(TestUserClass.class.getField("dumm3"), pojoSerializer.getFields()[2])__		assertEquals(TestUserClass.class.getField("dumm4"), pojoSerializer.getFields()[3])__		assertEquals(TestUserClass.class.getField("dumm5"), pojoSerializer.getFields()[4])__		assertEquals(TestUserClass.class.getField("nestedClass"), pojoSerializer.getFields()[5])___		PojoSerializer.PojoSerializerConfigSnapshot<TestUserClass> mockPreviousConfigSnapshot =_			new PojoSerializer.PojoSerializerConfigSnapshot<>(_				TestUserClass.class,_				mockOriginalFieldToSerializerConfigSnapshot, _				new LinkedHashMap<Class<?>, Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>>(), _				new HashMap<Class<?>, Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>>())_ __		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(mockPreviousConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		int i = 0__		for (Field field : mockOriginalFieldOrder) {_			assertEquals(field, pojoSerializer.getFields()[i])__			i++__		}_	};verifies,that,reconfiguration,reorders,the,fields,of,the,new,pojo,serializer,to,remain,the,same;test,public,void,test,reconfigure,with,different,field,order,throws,exception,field,mock,original,field,order,test,user,class,class,get,field,dumm4,test,user,class,class,get,field,dumm3,test,user,class,class,get,field,nested,class,test,user,class,class,get,field,dumm1,test,user,class,class,get,field,dumm2,test,user,class,class,get,field,dumm5,pojo,serializer,test,user,class,ser,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,linked,hash,map,string,tuple2,type,serializer,type,serializer,config,snapshot,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,mock,original,field,order,length,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,0,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,3,ser,get,field,serializers,3,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,1,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,2,ser,get,field,serializers,2,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,2,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,5,ser,get,field,serializers,5,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,3,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,0,ser,get,field,serializers,0,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,4,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,1,ser,get,field,serializers,1,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,5,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,4,ser,get,field,serializers,4,snapshot,configuration,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,assert,equals,test,user,class,class,get,field,dumm1,pojo,serializer,get,fields,0,assert,equals,test,user,class,class,get,field,dumm2,pojo,serializer,get,fields,1,assert,equals,test,user,class,class,get,field,dumm3,pojo,serializer,get,fields,2,assert,equals,test,user,class,class,get,field,dumm4,pojo,serializer,get,fields,3,assert,equals,test,user,class,class,get,field,dumm5,pojo,serializer,get,fields,4,assert,equals,test,user,class,class,get,field,nested,class,pojo,serializer,get,fields,5,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,mock,previous,config,snapshot,new,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,class,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,class,tuple2,type,serializer,type,serializer,config,snapshot,new,hash,map,class,tuple2,type,serializer,type,serializer,config,snapshot,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,mock,previous,config,snapshot,assert,false,compat,result,is,requires,migration,int,i,0,for,field,field,mock,original,field,order,assert,equals,field,pojo,serializer,get,fields,i,i
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentFieldOrder() throws Exception;1525657109;Verifies that reconfiguration reorders the fields of the new Pojo serializer to remain the same.;@Test_	public void testReconfigureWithDifferentFieldOrder() throws Exception {_		Field[] mockOriginalFieldOrder = {_			TestUserClass.class.getField("dumm4"),_			TestUserClass.class.getField("dumm3"),_			TestUserClass.class.getField("nestedClass"),_			TestUserClass.class.getField("dumm1"),_			TestUserClass.class.getField("dumm2"),_			TestUserClass.class.getField("dumm5"),_		}___		_		PojoSerializer<TestUserClass> ser = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		LinkedHashMap<String, Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>> mockOriginalFieldToSerializerConfigSnapshot =_			new LinkedHashMap<>(mockOriginalFieldOrder.length)__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[0].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[3],_				ser.getFieldSerializers()[3].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[1].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[2],_				ser.getFieldSerializers()[2].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[2].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[5],_				ser.getFieldSerializers()[5].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[3].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[0],_				ser.getFieldSerializers()[0].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[4].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[1],_				ser.getFieldSerializers()[1].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[5].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[4],_				ser.getFieldSerializers()[4].snapshotConfiguration()))___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		assertEquals(TestUserClass.class.getField("dumm1"), pojoSerializer.getFields()[0])__		assertEquals(TestUserClass.class.getField("dumm2"), pojoSerializer.getFields()[1])__		assertEquals(TestUserClass.class.getField("dumm3"), pojoSerializer.getFields()[2])__		assertEquals(TestUserClass.class.getField("dumm4"), pojoSerializer.getFields()[3])__		assertEquals(TestUserClass.class.getField("dumm5"), pojoSerializer.getFields()[4])__		assertEquals(TestUserClass.class.getField("nestedClass"), pojoSerializer.getFields()[5])___		PojoSerializer.PojoSerializerConfigSnapshot<TestUserClass> mockPreviousConfigSnapshot =_			new PojoSerializer.PojoSerializerConfigSnapshot<>(_				TestUserClass.class,_				mockOriginalFieldToSerializerConfigSnapshot, _				new LinkedHashMap<Class<?>, Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>>(), _				new HashMap<Class<?>, Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>>())_ __		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(mockPreviousConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		int i = 0__		for (Field field : mockOriginalFieldOrder) {_			assertEquals(field, pojoSerializer.getFields()[i])__			i++__		}_	};verifies,that,reconfiguration,reorders,the,fields,of,the,new,pojo,serializer,to,remain,the,same;test,public,void,test,reconfigure,with,different,field,order,throws,exception,field,mock,original,field,order,test,user,class,class,get,field,dumm4,test,user,class,class,get,field,dumm3,test,user,class,class,get,field,nested,class,test,user,class,class,get,field,dumm1,test,user,class,class,get,field,dumm2,test,user,class,class,get,field,dumm5,pojo,serializer,test,user,class,ser,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,linked,hash,map,string,tuple2,type,serializer,type,serializer,config,snapshot,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,mock,original,field,order,length,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,0,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,3,ser,get,field,serializers,3,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,1,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,2,ser,get,field,serializers,2,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,2,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,5,ser,get,field,serializers,5,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,3,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,0,ser,get,field,serializers,0,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,4,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,1,ser,get,field,serializers,1,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,5,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,4,ser,get,field,serializers,4,snapshot,configuration,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,assert,equals,test,user,class,class,get,field,dumm1,pojo,serializer,get,fields,0,assert,equals,test,user,class,class,get,field,dumm2,pojo,serializer,get,fields,1,assert,equals,test,user,class,class,get,field,dumm3,pojo,serializer,get,fields,2,assert,equals,test,user,class,class,get,field,dumm4,pojo,serializer,get,fields,3,assert,equals,test,user,class,class,get,field,dumm5,pojo,serializer,get,fields,4,assert,equals,test,user,class,class,get,field,nested,class,pojo,serializer,get,fields,5,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,mock,previous,config,snapshot,new,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,class,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,class,tuple2,type,serializer,type,serializer,config,snapshot,new,hash,map,class,tuple2,type,serializer,type,serializer,config,snapshot,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,mock,previous,config,snapshot,assert,false,compat,result,is,requires,migration,int,i,0,for,field,field,mock,original,field,order,assert,equals,field,pojo,serializer,get,fields,i,i
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentFieldOrder() throws Exception;1539149027;Verifies that reconfiguration reorders the fields of the new Pojo serializer to remain the same.;@Test_	public void testReconfigureWithDifferentFieldOrder() throws Exception {_		Field[] mockOriginalFieldOrder = {_			TestUserClass.class.getField("dumm4"),_			TestUserClass.class.getField("dumm3"),_			TestUserClass.class.getField("nestedClass"),_			TestUserClass.class.getField("dumm1"),_			TestUserClass.class.getField("dumm2"),_			TestUserClass.class.getField("dumm5"),_		}___		_		PojoSerializer<TestUserClass> ser = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		LinkedHashMap<String, Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>> mockOriginalFieldToSerializerConfigSnapshot =_			new LinkedHashMap<>(mockOriginalFieldOrder.length)__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[0].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[3],_				ser.getFieldSerializers()[3].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[1].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[2],_				ser.getFieldSerializers()[2].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[2].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[5],_				ser.getFieldSerializers()[5].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[3].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[0],_				ser.getFieldSerializers()[0].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[4].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[1],_				ser.getFieldSerializers()[1].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[5].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[4],_				ser.getFieldSerializers()[4].snapshotConfiguration()))___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		assertEquals(TestUserClass.class.getField("dumm1"), pojoSerializer.getFields()[0])__		assertEquals(TestUserClass.class.getField("dumm2"), pojoSerializer.getFields()[1])__		assertEquals(TestUserClass.class.getField("dumm3"), pojoSerializer.getFields()[2])__		assertEquals(TestUserClass.class.getField("dumm4"), pojoSerializer.getFields()[3])__		assertEquals(TestUserClass.class.getField("dumm5"), pojoSerializer.getFields()[4])__		assertEquals(TestUserClass.class.getField("nestedClass"), pojoSerializer.getFields()[5])___		PojoSerializer.PojoSerializerConfigSnapshot<TestUserClass> mockPreviousConfigSnapshot =_			new PojoSerializer.PojoSerializerConfigSnapshot<>(_				TestUserClass.class,_				mockOriginalFieldToSerializerConfigSnapshot, _				new LinkedHashMap<Class<?>, Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>>(), _				new HashMap<Class<?>, Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>>())_ __		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(mockPreviousConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		int i = 0__		for (Field field : mockOriginalFieldOrder) {_			assertEquals(field, pojoSerializer.getFields()[i])__			i++__		}_	};verifies,that,reconfiguration,reorders,the,fields,of,the,new,pojo,serializer,to,remain,the,same;test,public,void,test,reconfigure,with,different,field,order,throws,exception,field,mock,original,field,order,test,user,class,class,get,field,dumm4,test,user,class,class,get,field,dumm3,test,user,class,class,get,field,nested,class,test,user,class,class,get,field,dumm1,test,user,class,class,get,field,dumm2,test,user,class,class,get,field,dumm5,pojo,serializer,test,user,class,ser,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,linked,hash,map,string,tuple2,type,serializer,type,serializer,config,snapshot,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,mock,original,field,order,length,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,0,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,3,ser,get,field,serializers,3,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,1,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,2,ser,get,field,serializers,2,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,2,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,5,ser,get,field,serializers,5,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,3,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,0,ser,get,field,serializers,0,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,4,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,1,ser,get,field,serializers,1,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,5,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,4,ser,get,field,serializers,4,snapshot,configuration,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,assert,equals,test,user,class,class,get,field,dumm1,pojo,serializer,get,fields,0,assert,equals,test,user,class,class,get,field,dumm2,pojo,serializer,get,fields,1,assert,equals,test,user,class,class,get,field,dumm3,pojo,serializer,get,fields,2,assert,equals,test,user,class,class,get,field,dumm4,pojo,serializer,get,fields,3,assert,equals,test,user,class,class,get,field,dumm5,pojo,serializer,get,fields,4,assert,equals,test,user,class,class,get,field,nested,class,pojo,serializer,get,fields,5,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,mock,previous,config,snapshot,new,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,class,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,class,tuple2,type,serializer,type,serializer,config,snapshot,new,hash,map,class,tuple2,type,serializer,type,serializer,config,snapshot,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,mock,previous,config,snapshot,assert,false,compat,result,is,requires,migration,int,i,0,for,field,field,mock,original,field,order,assert,equals,field,pojo,serializer,get,fields,i,i
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentFieldOrder() throws Exception;1539149040;Verifies that reconfiguration reorders the fields of the new Pojo serializer to remain the same.;@Test_	public void testReconfigureWithDifferentFieldOrder() throws Exception {_		Field[] mockOriginalFieldOrder = {_			TestUserClass.class.getField("dumm4"),_			TestUserClass.class.getField("dumm3"),_			TestUserClass.class.getField("nestedClass"),_			TestUserClass.class.getField("dumm1"),_			TestUserClass.class.getField("dumm2"),_			TestUserClass.class.getField("dumm5"),_		}___		_		PojoSerializer<TestUserClass> ser = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		LinkedHashMap<String, Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>> mockOriginalFieldToSerializerConfigSnapshot =_			new LinkedHashMap<>(mockOriginalFieldOrder.length)__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[0].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[3],_				ser.getFieldSerializers()[3].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[1].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[2],_				ser.getFieldSerializers()[2].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[2].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[5],_				ser.getFieldSerializers()[5].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[3].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[0],_				ser.getFieldSerializers()[0].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[4].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[1],_				ser.getFieldSerializers()[1].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[5].getName(),_			new Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>(_				ser.getFieldSerializers()[4],_				ser.getFieldSerializers()[4].snapshotConfiguration()))___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		assertEquals(TestUserClass.class.getField("dumm1"), pojoSerializer.getFields()[0])__		assertEquals(TestUserClass.class.getField("dumm2"), pojoSerializer.getFields()[1])__		assertEquals(TestUserClass.class.getField("dumm3"), pojoSerializer.getFields()[2])__		assertEquals(TestUserClass.class.getField("dumm4"), pojoSerializer.getFields()[3])__		assertEquals(TestUserClass.class.getField("dumm5"), pojoSerializer.getFields()[4])__		assertEquals(TestUserClass.class.getField("nestedClass"), pojoSerializer.getFields()[5])___		PojoSerializer.PojoSerializerConfigSnapshot<TestUserClass> mockPreviousConfigSnapshot =_			new PojoSerializer.PojoSerializerConfigSnapshot<>(_				TestUserClass.class,_				mockOriginalFieldToSerializerConfigSnapshot, _				new LinkedHashMap<Class<?>, Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>>(), _				new HashMap<Class<?>, Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>>())_ __		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(mockPreviousConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		int i = 0__		for (Field field : mockOriginalFieldOrder) {_			assertEquals(field, pojoSerializer.getFields()[i])__			i++__		}_	};verifies,that,reconfiguration,reorders,the,fields,of,the,new,pojo,serializer,to,remain,the,same;test,public,void,test,reconfigure,with,different,field,order,throws,exception,field,mock,original,field,order,test,user,class,class,get,field,dumm4,test,user,class,class,get,field,dumm3,test,user,class,class,get,field,nested,class,test,user,class,class,get,field,dumm1,test,user,class,class,get,field,dumm2,test,user,class,class,get,field,dumm5,pojo,serializer,test,user,class,ser,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,linked,hash,map,string,tuple2,type,serializer,type,serializer,config,snapshot,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,mock,original,field,order,length,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,0,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,3,ser,get,field,serializers,3,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,1,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,2,ser,get,field,serializers,2,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,2,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,5,ser,get,field,serializers,5,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,3,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,0,ser,get,field,serializers,0,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,4,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,1,ser,get,field,serializers,1,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,5,get,name,new,tuple2,type,serializer,type,serializer,config,snapshot,ser,get,field,serializers,4,ser,get,field,serializers,4,snapshot,configuration,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,assert,equals,test,user,class,class,get,field,dumm1,pojo,serializer,get,fields,0,assert,equals,test,user,class,class,get,field,dumm2,pojo,serializer,get,fields,1,assert,equals,test,user,class,class,get,field,dumm3,pojo,serializer,get,fields,2,assert,equals,test,user,class,class,get,field,dumm4,pojo,serializer,get,fields,3,assert,equals,test,user,class,class,get,field,dumm5,pojo,serializer,get,fields,4,assert,equals,test,user,class,class,get,field,nested,class,pojo,serializer,get,fields,5,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,mock,previous,config,snapshot,new,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,class,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,class,tuple2,type,serializer,type,serializer,config,snapshot,new,hash,map,class,tuple2,type,serializer,type,serializer,config,snapshot,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,mock,previous,config,snapshot,assert,false,compat,result,is,requires,migration,int,i,0,for,field,field,mock,original,field,order,assert,equals,field,pojo,serializer,get,fields,i,i
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentFieldOrder() throws Exception;1539149114;Verifies that reconfiguration reorders the fields of the new Pojo serializer to remain the same.;@Test_	public void testReconfigureWithDifferentFieldOrder() throws Exception {_		Field[] mockOriginalFieldOrder = {_			TestUserClass.class.getField("dumm4"),_			TestUserClass.class.getField("dumm3"),_			TestUserClass.class.getField("nestedClass"),_			TestUserClass.class.getField("dumm1"),_			TestUserClass.class.getField("dumm2"),_			TestUserClass.class.getField("dumm5"),_		}___		_		PojoSerializer<TestUserClass> ser = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		LinkedHashMap<String, Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> mockOriginalFieldToSerializerConfigSnapshot =_			new LinkedHashMap<>(mockOriginalFieldOrder.length)__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[0].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[3],_				ser.getFieldSerializers()[3].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[1].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[2],_				ser.getFieldSerializers()[2].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[2].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[5],_				ser.getFieldSerializers()[5].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[3].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[0],_				ser.getFieldSerializers()[0].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[4].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[1],_				ser.getFieldSerializers()[1].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[5].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[4],_				ser.getFieldSerializers()[4].snapshotConfiguration()))___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		assertEquals(TestUserClass.class.getField("dumm1"), pojoSerializer.getFields()[0])__		assertEquals(TestUserClass.class.getField("dumm2"), pojoSerializer.getFields()[1])__		assertEquals(TestUserClass.class.getField("dumm3"), pojoSerializer.getFields()[2])__		assertEquals(TestUserClass.class.getField("dumm4"), pojoSerializer.getFields()[3])__		assertEquals(TestUserClass.class.getField("dumm5"), pojoSerializer.getFields()[4])__		assertEquals(TestUserClass.class.getField("nestedClass"), pojoSerializer.getFields()[5])___		PojoSerializer.PojoSerializerConfigSnapshot<TestUserClass> mockPreviousConfigSnapshot =_			new PojoSerializer.PojoSerializerConfigSnapshot<>(_				TestUserClass.class,_				mockOriginalFieldToSerializerConfigSnapshot, _				new LinkedHashMap<>(), _				new HashMap<>())_ __		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(mockPreviousConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		int i = 0__		for (Field field : mockOriginalFieldOrder) {_			assertEquals(field, pojoSerializer.getFields()[i])__			i++__		}_	};verifies,that,reconfiguration,reorders,the,fields,of,the,new,pojo,serializer,to,remain,the,same;test,public,void,test,reconfigure,with,different,field,order,throws,exception,field,mock,original,field,order,test,user,class,class,get,field,dumm4,test,user,class,class,get,field,dumm3,test,user,class,class,get,field,nested,class,test,user,class,class,get,field,dumm1,test,user,class,class,get,field,dumm2,test,user,class,class,get,field,dumm5,pojo,serializer,test,user,class,ser,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,linked,hash,map,string,tuple2,type,serializer,type,serializer,snapshot,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,mock,original,field,order,length,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,0,get,name,new,tuple2,ser,get,field,serializers,3,ser,get,field,serializers,3,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,1,get,name,new,tuple2,ser,get,field,serializers,2,ser,get,field,serializers,2,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,2,get,name,new,tuple2,ser,get,field,serializers,5,ser,get,field,serializers,5,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,3,get,name,new,tuple2,ser,get,field,serializers,0,ser,get,field,serializers,0,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,4,get,name,new,tuple2,ser,get,field,serializers,1,ser,get,field,serializers,1,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,5,get,name,new,tuple2,ser,get,field,serializers,4,ser,get,field,serializers,4,snapshot,configuration,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,assert,equals,test,user,class,class,get,field,dumm1,pojo,serializer,get,fields,0,assert,equals,test,user,class,class,get,field,dumm2,pojo,serializer,get,fields,1,assert,equals,test,user,class,class,get,field,dumm3,pojo,serializer,get,fields,2,assert,equals,test,user,class,class,get,field,dumm4,pojo,serializer,get,fields,3,assert,equals,test,user,class,class,get,field,dumm5,pojo,serializer,get,fields,4,assert,equals,test,user,class,class,get,field,nested,class,pojo,serializer,get,fields,5,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,mock,previous,config,snapshot,new,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,class,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,new,hash,map,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,mock,previous,config,snapshot,assert,false,compat,result,is,requires,migration,int,i,0,for,field,field,mock,original,field,order,assert,equals,field,pojo,serializer,get,fields,i,i
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentFieldOrder() throws Exception;1540907751;Verifies that reconfiguration reorders the fields of the new Pojo serializer to remain the same.;@Test_	public void testReconfigureWithDifferentFieldOrder() throws Exception {_		Field[] mockOriginalFieldOrder = {_			TestUserClass.class.getField("dumm4"),_			TestUserClass.class.getField("dumm3"),_			TestUserClass.class.getField("nestedClass"),_			TestUserClass.class.getField("dumm1"),_			TestUserClass.class.getField("dumm2"),_			TestUserClass.class.getField("dumm5"),_		}___		_		PojoSerializer<TestUserClass> ser = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		LinkedHashMap<String, Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> mockOriginalFieldToSerializerConfigSnapshot =_			new LinkedHashMap<>(mockOriginalFieldOrder.length)__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[0].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[3],_				ser.getFieldSerializers()[3].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[1].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[2],_				ser.getFieldSerializers()[2].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[2].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[5],_				ser.getFieldSerializers()[5].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[3].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[0],_				ser.getFieldSerializers()[0].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[4].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[1],_				ser.getFieldSerializers()[1].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[5].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[4],_				ser.getFieldSerializers()[4].snapshotConfiguration()))___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		assertEquals(TestUserClass.class.getField("dumm1"), pojoSerializer.getFields()[0])__		assertEquals(TestUserClass.class.getField("dumm2"), pojoSerializer.getFields()[1])__		assertEquals(TestUserClass.class.getField("dumm3"), pojoSerializer.getFields()[2])__		assertEquals(TestUserClass.class.getField("dumm4"), pojoSerializer.getFields()[3])__		assertEquals(TestUserClass.class.getField("dumm5"), pojoSerializer.getFields()[4])__		assertEquals(TestUserClass.class.getField("nestedClass"), pojoSerializer.getFields()[5])___		PojoSerializer.PojoSerializerConfigSnapshot<TestUserClass> mockPreviousConfigSnapshot =_			new PojoSerializer.PojoSerializerConfigSnapshot<>(_				TestUserClass.class,_				mockOriginalFieldToSerializerConfigSnapshot, _				new LinkedHashMap<>(), _				new HashMap<>())_ __		_		TypeSerializerSchemaCompatibility<TestUserClass, ?> compatResult =_			mockPreviousConfigSnapshot.resolveSchemaCompatibility(pojoSerializer)__		assertTrue(compatResult.isCompatibleAsIs())__		int i = 0__		for (Field field : mockOriginalFieldOrder) {_			assertEquals(field, pojoSerializer.getFields()[i])__			i++__		}_	};verifies,that,reconfiguration,reorders,the,fields,of,the,new,pojo,serializer,to,remain,the,same;test,public,void,test,reconfigure,with,different,field,order,throws,exception,field,mock,original,field,order,test,user,class,class,get,field,dumm4,test,user,class,class,get,field,dumm3,test,user,class,class,get,field,nested,class,test,user,class,class,get,field,dumm1,test,user,class,class,get,field,dumm2,test,user,class,class,get,field,dumm5,pojo,serializer,test,user,class,ser,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,linked,hash,map,string,tuple2,type,serializer,type,serializer,snapshot,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,mock,original,field,order,length,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,0,get,name,new,tuple2,ser,get,field,serializers,3,ser,get,field,serializers,3,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,1,get,name,new,tuple2,ser,get,field,serializers,2,ser,get,field,serializers,2,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,2,get,name,new,tuple2,ser,get,field,serializers,5,ser,get,field,serializers,5,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,3,get,name,new,tuple2,ser,get,field,serializers,0,ser,get,field,serializers,0,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,4,get,name,new,tuple2,ser,get,field,serializers,1,ser,get,field,serializers,1,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,5,get,name,new,tuple2,ser,get,field,serializers,4,ser,get,field,serializers,4,snapshot,configuration,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,assert,equals,test,user,class,class,get,field,dumm1,pojo,serializer,get,fields,0,assert,equals,test,user,class,class,get,field,dumm2,pojo,serializer,get,fields,1,assert,equals,test,user,class,class,get,field,dumm3,pojo,serializer,get,fields,2,assert,equals,test,user,class,class,get,field,dumm4,pojo,serializer,get,fields,3,assert,equals,test,user,class,class,get,field,dumm5,pojo,serializer,get,fields,4,assert,equals,test,user,class,class,get,field,nested,class,pojo,serializer,get,fields,5,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,mock,previous,config,snapshot,new,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,class,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,new,hash,map,type,serializer,schema,compatibility,test,user,class,compat,result,mock,previous,config,snapshot,resolve,schema,compatibility,pojo,serializer,assert,true,compat,result,is,compatible,as,is,int,i,0,for,field,field,mock,original,field,order,assert,equals,field,pojo,serializer,get,fields,i,i
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentFieldOrder() throws Exception;1540907751;Verifies that reconfiguration reorders the fields of the new Pojo serializer to remain the same.;@Test_	public void testReconfigureWithDifferentFieldOrder() throws Exception {_		Field[] mockOriginalFieldOrder = {_			TestUserClass.class.getField("dumm4"),_			TestUserClass.class.getField("dumm3"),_			TestUserClass.class.getField("nestedClass"),_			TestUserClass.class.getField("dumm1"),_			TestUserClass.class.getField("dumm2"),_			TestUserClass.class.getField("dumm5"),_		}___		_		PojoSerializer<TestUserClass> ser = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		LinkedHashMap<String, Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> mockOriginalFieldToSerializerConfigSnapshot =_			new LinkedHashMap<>(mockOriginalFieldOrder.length)__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[0].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[3],_				ser.getFieldSerializers()[3].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[1].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[2],_				ser.getFieldSerializers()[2].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[2].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[5],_				ser.getFieldSerializers()[5].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[3].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[0],_				ser.getFieldSerializers()[0].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[4].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[1],_				ser.getFieldSerializers()[1].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[5].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[4],_				ser.getFieldSerializers()[4].snapshotConfiguration()))___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		assertEquals(TestUserClass.class.getField("dumm1"), pojoSerializer.getFields()[0])__		assertEquals(TestUserClass.class.getField("dumm2"), pojoSerializer.getFields()[1])__		assertEquals(TestUserClass.class.getField("dumm3"), pojoSerializer.getFields()[2])__		assertEquals(TestUserClass.class.getField("dumm4"), pojoSerializer.getFields()[3])__		assertEquals(TestUserClass.class.getField("dumm5"), pojoSerializer.getFields()[4])__		assertEquals(TestUserClass.class.getField("nestedClass"), pojoSerializer.getFields()[5])___		PojoSerializer.PojoSerializerConfigSnapshot<TestUserClass> mockPreviousConfigSnapshot =_			new PojoSerializer.PojoSerializerConfigSnapshot<>(_				TestUserClass.class,_				mockOriginalFieldToSerializerConfigSnapshot, _				new LinkedHashMap<>(), _				new HashMap<>())_ __		_		TypeSerializerSchemaCompatibility<TestUserClass, ?> compatResult =_			mockPreviousConfigSnapshot.resolveSchemaCompatibility(pojoSerializer)__		assertTrue(compatResult.isCompatibleAsIs())__		int i = 0__		for (Field field : mockOriginalFieldOrder) {_			assertEquals(field, pojoSerializer.getFields()[i])__			i++__		}_	};verifies,that,reconfiguration,reorders,the,fields,of,the,new,pojo,serializer,to,remain,the,same;test,public,void,test,reconfigure,with,different,field,order,throws,exception,field,mock,original,field,order,test,user,class,class,get,field,dumm4,test,user,class,class,get,field,dumm3,test,user,class,class,get,field,nested,class,test,user,class,class,get,field,dumm1,test,user,class,class,get,field,dumm2,test,user,class,class,get,field,dumm5,pojo,serializer,test,user,class,ser,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,linked,hash,map,string,tuple2,type,serializer,type,serializer,snapshot,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,mock,original,field,order,length,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,0,get,name,new,tuple2,ser,get,field,serializers,3,ser,get,field,serializers,3,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,1,get,name,new,tuple2,ser,get,field,serializers,2,ser,get,field,serializers,2,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,2,get,name,new,tuple2,ser,get,field,serializers,5,ser,get,field,serializers,5,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,3,get,name,new,tuple2,ser,get,field,serializers,0,ser,get,field,serializers,0,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,4,get,name,new,tuple2,ser,get,field,serializers,1,ser,get,field,serializers,1,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,5,get,name,new,tuple2,ser,get,field,serializers,4,ser,get,field,serializers,4,snapshot,configuration,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,assert,equals,test,user,class,class,get,field,dumm1,pojo,serializer,get,fields,0,assert,equals,test,user,class,class,get,field,dumm2,pojo,serializer,get,fields,1,assert,equals,test,user,class,class,get,field,dumm3,pojo,serializer,get,fields,2,assert,equals,test,user,class,class,get,field,dumm4,pojo,serializer,get,fields,3,assert,equals,test,user,class,class,get,field,dumm5,pojo,serializer,get,fields,4,assert,equals,test,user,class,class,get,field,nested,class,pojo,serializer,get,fields,5,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,mock,previous,config,snapshot,new,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,class,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,new,hash,map,type,serializer,schema,compatibility,test,user,class,compat,result,mock,previous,config,snapshot,resolve,schema,compatibility,pojo,serializer,assert,true,compat,result,is,compatible,as,is,int,i,0,for,field,field,mock,original,field,order,assert,equals,field,pojo,serializer,get,fields,i,i
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentFieldOrder() throws Exception;1540907751;Verifies that reconfiguration reorders the fields of the new Pojo serializer to remain the same.;@Test_	public void testReconfigureWithDifferentFieldOrder() throws Exception {_		Field[] mockOriginalFieldOrder = {_			TestUserClass.class.getField("dumm4"),_			TestUserClass.class.getField("dumm3"),_			TestUserClass.class.getField("nestedClass"),_			TestUserClass.class.getField("dumm1"),_			TestUserClass.class.getField("dumm2"),_			TestUserClass.class.getField("dumm5"),_		}___		_		PojoSerializer<TestUserClass> ser = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		LinkedHashMap<String, Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> mockOriginalFieldToSerializerConfigSnapshot =_			new LinkedHashMap<>(mockOriginalFieldOrder.length)__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[0].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[3],_				ser.getFieldSerializers()[3].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[1].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[2],_				ser.getFieldSerializers()[2].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[2].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[5],_				ser.getFieldSerializers()[5].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[3].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[0],_				ser.getFieldSerializers()[0].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[4].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[1],_				ser.getFieldSerializers()[1].snapshotConfiguration()))__		mockOriginalFieldToSerializerConfigSnapshot.put(_			mockOriginalFieldOrder[5].getName(),_			new Tuple2<>(_				ser.getFieldSerializers()[4],_				ser.getFieldSerializers()[4].snapshotConfiguration()))___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		assertEquals(TestUserClass.class.getField("dumm1"), pojoSerializer.getFields()[0])__		assertEquals(TestUserClass.class.getField("dumm2"), pojoSerializer.getFields()[1])__		assertEquals(TestUserClass.class.getField("dumm3"), pojoSerializer.getFields()[2])__		assertEquals(TestUserClass.class.getField("dumm4"), pojoSerializer.getFields()[3])__		assertEquals(TestUserClass.class.getField("dumm5"), pojoSerializer.getFields()[4])__		assertEquals(TestUserClass.class.getField("nestedClass"), pojoSerializer.getFields()[5])___		PojoSerializer.PojoSerializerConfigSnapshot<TestUserClass> mockPreviousConfigSnapshot =_			new PojoSerializer.PojoSerializerConfigSnapshot<>(_				TestUserClass.class,_				mockOriginalFieldToSerializerConfigSnapshot, _				new LinkedHashMap<>(), _				new HashMap<>())_ __		_		TypeSerializerSchemaCompatibility<TestUserClass> compatResult =_			mockPreviousConfigSnapshot.resolveSchemaCompatibility(pojoSerializer)__		assertTrue(compatResult.isCompatibleAsIs())__		int i = 0__		for (Field field : mockOriginalFieldOrder) {_			assertEquals(field, pojoSerializer.getFields()[i])__			i++__		}_	};verifies,that,reconfiguration,reorders,the,fields,of,the,new,pojo,serializer,to,remain,the,same;test,public,void,test,reconfigure,with,different,field,order,throws,exception,field,mock,original,field,order,test,user,class,class,get,field,dumm4,test,user,class,class,get,field,dumm3,test,user,class,class,get,field,nested,class,test,user,class,class,get,field,dumm1,test,user,class,class,get,field,dumm2,test,user,class,class,get,field,dumm5,pojo,serializer,test,user,class,ser,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,linked,hash,map,string,tuple2,type,serializer,type,serializer,snapshot,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,mock,original,field,order,length,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,0,get,name,new,tuple2,ser,get,field,serializers,3,ser,get,field,serializers,3,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,1,get,name,new,tuple2,ser,get,field,serializers,2,ser,get,field,serializers,2,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,2,get,name,new,tuple2,ser,get,field,serializers,5,ser,get,field,serializers,5,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,3,get,name,new,tuple2,ser,get,field,serializers,0,ser,get,field,serializers,0,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,4,get,name,new,tuple2,ser,get,field,serializers,1,ser,get,field,serializers,1,snapshot,configuration,mock,original,field,to,serializer,config,snapshot,put,mock,original,field,order,5,get,name,new,tuple2,ser,get,field,serializers,4,ser,get,field,serializers,4,snapshot,configuration,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,assert,equals,test,user,class,class,get,field,dumm1,pojo,serializer,get,fields,0,assert,equals,test,user,class,class,get,field,dumm2,pojo,serializer,get,fields,1,assert,equals,test,user,class,class,get,field,dumm3,pojo,serializer,get,fields,2,assert,equals,test,user,class,class,get,field,dumm4,pojo,serializer,get,fields,3,assert,equals,test,user,class,class,get,field,dumm5,pojo,serializer,get,fields,4,assert,equals,test,user,class,class,get,field,nested,class,pojo,serializer,get,fields,5,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,mock,previous,config,snapshot,new,pojo,serializer,pojo,serializer,config,snapshot,test,user,class,class,mock,original,field,to,serializer,config,snapshot,new,linked,hash,map,new,hash,map,type,serializer,schema,compatibility,test,user,class,compat,result,mock,previous,config,snapshot,resolve,schema,compatibility,pojo,serializer,assert,true,compat,result,is,compatible,as,is,int,i,0,for,field,field,mock,original,field,order,assert,equals,field,pojo,serializer,get,fields,i,i
PojoSerializerTest -> @Test 	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception;1494180263;Tests that reconfiguration repopulates previously cached subclass serializers.;@Test_	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertFalse(compatResult.requiresMigration())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__	};tests,that,reconfiguration,repopulates,previously,cached,subclass,serializers;test,public,void,test,reconfigure,repopulate,nonregistered,subclass,serializer,cache,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,false,compat,result,requires,migration,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception;1494658833;Tests that reconfiguration repopulates previously cached subclass serializers.;@Test_	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__	};tests,that,reconfiguration,repopulates,previously,cached,subclass,serializers;test,public,void,test,reconfigure,repopulate,nonregistered,subclass,serializer,cache,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,false,compat,result,is,requires,migration,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception;1495466666;Tests that reconfiguration repopulates previously cached subclass serializers.;@Test_	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__	};tests,that,reconfiguration,repopulates,previously,cached,subclass,serializers;test,public,void,test,reconfigure,repopulate,nonregistered,subclass,serializer,cache,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,false,compat,result,is,requires,migration,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception;1497328697;Tests that reconfiguration repopulates previously cached subclass serializers.;@Test_	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__	};tests,that,reconfiguration,repopulates,previously,cached,subclass,serializers;test,public,void,test,reconfigure,repopulate,nonregistered,subclass,serializer,cache,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,false,compat,result,is,requires,migration,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception;1525657109;Tests that reconfiguration repopulates previously cached subclass serializers.;@Test_	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__	};tests,that,reconfiguration,repopulates,previously,cached,subclass,serializers;test,public,void,test,reconfigure,repopulate,nonregistered,subclass,serializer,cache,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,false,compat,result,is,requires,migration,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception;1539149027;Tests that reconfiguration repopulates previously cached subclass serializers.;@Test_	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__	};tests,that,reconfiguration,repopulates,previously,cached,subclass,serializers;test,public,void,test,reconfigure,repopulate,nonregistered,subclass,serializer,cache,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,false,compat,result,is,requires,migration,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception;1539149040;Tests that reconfiguration repopulates previously cached subclass serializers.;@Test_	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerConfigSnapshotSerializationUtil.writeSerializerConfigSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerConfigSnapshotSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__	};tests,that,reconfiguration,repopulates,previously,cached,subclass,serializers;test,public,void,test,reconfigure,repopulate,nonregistered,subclass,serializer,cache,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,config,snapshot,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,config,snapshot,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,false,compat,result,is,requires,migration,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception;1539149114;Tests that reconfiguration repopulates previously cached subclass serializers.;@Test_	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer)__		}__		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__	};tests,that,reconfiguration,repopulates,previously,cached,subclass,serializers;test,public,void,test,reconfigure,repopulate,nonregistered,subclass,serializer,cache,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,false,compat,result,is,requires,migration,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception;1540907751;Tests that reconfiguration repopulates previously cached subclass serializers.;@Test_	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer)__		}__		_		@SuppressWarnings("unchecked")_		TypeSerializerSchemaCompatibility<TestUserClass, ?> compatResult =_			pojoSerializerConfigSnapshot.resolveSchemaCompatibility(pojoSerializer)__		assertTrue(compatResult.isCompatibleAsIs())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__	};tests,that,reconfiguration,repopulates,previously,cached,subclass,serializers;test,public,void,test,reconfigure,repopulate,nonregistered,subclass,serializer,cache,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer,suppress,warnings,unchecked,type,serializer,schema,compatibility,test,user,class,compat,result,pojo,serializer,config,snapshot,resolve,schema,compatibility,pojo,serializer,assert,true,compat,result,is,compatible,as,is,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception;1540907751;Tests that reconfiguration repopulates previously cached subclass serializers.;@Test_	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer)__		}__		_		@SuppressWarnings("unchecked")_		TypeSerializerSchemaCompatibility<TestUserClass, ?> compatResult =_			pojoSerializerConfigSnapshot.resolveSchemaCompatibility(pojoSerializer)__		assertTrue(compatResult.isCompatibleAsIs())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__	};tests,that,reconfiguration,repopulates,previously,cached,subclass,serializers;test,public,void,test,reconfigure,repopulate,nonregistered,subclass,serializer,cache,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer,suppress,warnings,unchecked,type,serializer,schema,compatibility,test,user,class,compat,result,pojo,serializer,config,snapshot,resolve,schema,compatibility,pojo,serializer,assert,true,compat,result,is,compatible,as,is,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception;1540907751;Tests that reconfiguration repopulates previously cached subclass serializers.;@Test_	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer)__		}__		_		@SuppressWarnings("unchecked")_		TypeSerializerSchemaCompatibility<TestUserClass> compatResult =_			pojoSerializerConfigSnapshot.resolveSchemaCompatibility(pojoSerializer)__		assertTrue(compatResult.isCompatibleAsIs())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__	};tests,that,reconfiguration,repopulates,previously,cached,subclass,serializers;test,public,void,test,reconfigure,repopulate,nonregistered,subclass,serializer,cache,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer,suppress,warnings,unchecked,type,serializer,schema,compatibility,test,user,class,compat,result,pojo,serializer,config,snapshot,resolve,schema,compatibility,pojo,serializer,assert,true,compat,result,is,compatible,as,is,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception;1550821417;Tests that reconfiguration repopulates previously cached subclass serializers.;@Test_	public void testReconfigureRepopulateNonregisteredSubclassSerializerCache() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer)__		}__		_		@SuppressWarnings("unchecked")_		TypeSerializerSchemaCompatibility<TestUserClass> compatResult =_			pojoSerializerConfigSnapshot.resolveSchemaCompatibility(pojoSerializer)__		assertTrue(compatResult.isCompatibleWithReconfiguredSerializer())__		assertTrue(compatResult.getReconfiguredSerializer() instanceof PojoSerializer)___		PojoSerializer<TestUserClass> reconfiguredPojoSerializer = (PojoSerializer<TestUserClass>) compatResult.getReconfiguredSerializer()__		assertEquals(2, reconfiguredPojoSerializer.getSubclassSerializerCache().size())__		assertTrue(reconfiguredPojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(reconfiguredPojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__	};tests,that,reconfiguration,repopulates,previously,cached,subclass,serializers;test,public,void,test,reconfigure,repopulate,nonregistered,subclass,serializer,cache,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer,suppress,warnings,unchecked,type,serializer,schema,compatibility,test,user,class,compat,result,pojo,serializer,config,snapshot,resolve,schema,compatibility,pojo,serializer,assert,true,compat,result,is,compatible,with,reconfigured,serializer,assert,true,compat,result,get,reconfigured,serializer,instanceof,pojo,serializer,pojo,serializer,test,user,class,reconfigured,pojo,serializer,pojo,serializer,test,user,class,compat,result,get,reconfigured,serializer,assert,equals,2,reconfigured,pojo,serializer,get,subclass,serializer,cache,size,assert,true,reconfigured,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,reconfigured,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception;1494180263;Tests that:_- Previous Pojo serializer did not have registrations, and created cached serializers for subclasses_- On restore, it had those subclasses registered__In this case, after reconfiguration, the cache should be repopulated, and registrations should_also exist for the subclasses.__Note: the cache still needs to be repopulated because previous data of those subclasses were_written with the cached serializers. In this case, the repopulated cache has reconfigured serializers_for the subclasses so that previous written data can be read, but the registered serializers_for the subclasses do not necessarily need to be reconfigured since they will only be used to_write new data.;@Test_	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		_		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		assertTrue(pojoSerializer.getRegisteredClasses().isEmpty())__		assertEquals(0, pojoSerializer.getRegisteredSerializers().length)___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		_		ExecutionConfig newExecutionConfig = new ExecutionConfig()__		newExecutionConfig.registerPojoType(SubTestUserClassA.class)__		newExecutionConfig.registerPojoType(SubTestUserClassB.class)__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(newExecutionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		_		_		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertFalse(compatResult.requiresMigration())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__		assertEquals(2, pojoSerializer.getRegisteredClasses().size())__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassB.class))__	};tests,that,previous,pojo,serializer,did,not,have,registrations,and,created,cached,serializers,for,subclasses,on,restore,it,had,those,subclasses,registered,in,this,case,after,reconfiguration,the,cache,should,be,repopulated,and,registrations,should,also,exist,for,the,subclasses,note,the,cache,still,needs,to,be,repopulated,because,previous,data,of,those,subclasses,were,written,with,the,cached,serializers,in,this,case,the,repopulated,cache,has,reconfigured,serializers,for,the,subclasses,so,that,previous,written,data,can,be,read,but,the,registered,serializers,for,the,subclasses,do,not,necessarily,need,to,be,reconfigured,since,they,will,only,be,used,to,write,new,data;test,public,void,test,reconfigure,with,previously,nonregistered,subclasses,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,true,pojo,serializer,get,registered,classes,is,empty,assert,equals,0,pojo,serializer,get,registered,serializers,length,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,execution,config,new,execution,config,new,execution,config,new,execution,config,register,pojo,type,sub,test,user,class,a,class,new,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,false,compat,result,requires,migration,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,registered,classes,size,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception;1494658833;Tests that:_- Previous Pojo serializer did not have registrations, and created cached serializers for subclasses_- On restore, it had those subclasses registered__In this case, after reconfiguration, the cache should be repopulated, and registrations should_also exist for the subclasses.__Note: the cache still needs to be repopulated because previous data of those subclasses were_written with the cached serializers. In this case, the repopulated cache has reconfigured serializers_for the subclasses so that previous written data can be read, but the registered serializers_for the subclasses do not necessarily need to be reconfigured since they will only be used to_write new data.;@Test_	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		_		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		assertTrue(pojoSerializer.getRegisteredClasses().isEmpty())__		assertEquals(0, pojoSerializer.getRegisteredSerializers().length)___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		_		ExecutionConfig newExecutionConfig = new ExecutionConfig()__		newExecutionConfig.registerPojoType(SubTestUserClassA.class)__		newExecutionConfig.registerPojoType(SubTestUserClassB.class)__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(newExecutionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		_		_		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__		assertEquals(2, pojoSerializer.getRegisteredClasses().size())__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassB.class))__	};tests,that,previous,pojo,serializer,did,not,have,registrations,and,created,cached,serializers,for,subclasses,on,restore,it,had,those,subclasses,registered,in,this,case,after,reconfiguration,the,cache,should,be,repopulated,and,registrations,should,also,exist,for,the,subclasses,note,the,cache,still,needs,to,be,repopulated,because,previous,data,of,those,subclasses,were,written,with,the,cached,serializers,in,this,case,the,repopulated,cache,has,reconfigured,serializers,for,the,subclasses,so,that,previous,written,data,can,be,read,but,the,registered,serializers,for,the,subclasses,do,not,necessarily,need,to,be,reconfigured,since,they,will,only,be,used,to,write,new,data;test,public,void,test,reconfigure,with,previously,nonregistered,subclasses,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,true,pojo,serializer,get,registered,classes,is,empty,assert,equals,0,pojo,serializer,get,registered,serializers,length,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,execution,config,new,execution,config,new,execution,config,new,execution,config,register,pojo,type,sub,test,user,class,a,class,new,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,false,compat,result,is,requires,migration,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,registered,classes,size,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception;1495466666;Tests that:_- Previous Pojo serializer did not have registrations, and created cached serializers for subclasses_- On restore, it had those subclasses registered__In this case, after reconfiguration, the cache should be repopulated, and registrations should_also exist for the subclasses.__Note: the cache still needs to be repopulated because previous data of those subclasses were_written with the cached serializers. In this case, the repopulated cache has reconfigured serializers_for the subclasses so that previous written data can be read, but the registered serializers_for the subclasses do not necessarily need to be reconfigured since they will only be used to_write new data.;@Test_	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		_		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		assertTrue(pojoSerializer.getRegisteredClasses().isEmpty())__		assertEquals(0, pojoSerializer.getRegisteredSerializers().length)___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		_		ExecutionConfig newExecutionConfig = new ExecutionConfig()__		newExecutionConfig.registerPojoType(SubTestUserClassA.class)__		newExecutionConfig.registerPojoType(SubTestUserClassB.class)__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(newExecutionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		_		_		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__		assertEquals(2, pojoSerializer.getRegisteredClasses().size())__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassB.class))__	};tests,that,previous,pojo,serializer,did,not,have,registrations,and,created,cached,serializers,for,subclasses,on,restore,it,had,those,subclasses,registered,in,this,case,after,reconfiguration,the,cache,should,be,repopulated,and,registrations,should,also,exist,for,the,subclasses,note,the,cache,still,needs,to,be,repopulated,because,previous,data,of,those,subclasses,were,written,with,the,cached,serializers,in,this,case,the,repopulated,cache,has,reconfigured,serializers,for,the,subclasses,so,that,previous,written,data,can,be,read,but,the,registered,serializers,for,the,subclasses,do,not,necessarily,need,to,be,reconfigured,since,they,will,only,be,used,to,write,new,data;test,public,void,test,reconfigure,with,previously,nonregistered,subclasses,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,true,pojo,serializer,get,registered,classes,is,empty,assert,equals,0,pojo,serializer,get,registered,serializers,length,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,execution,config,new,execution,config,new,execution,config,new,execution,config,register,pojo,type,sub,test,user,class,a,class,new,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,false,compat,result,is,requires,migration,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,registered,classes,size,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception;1497328697;Tests that:_- Previous Pojo serializer did not have registrations, and created cached serializers for subclasses_- On restore, it had those subclasses registered__In this case, after reconfiguration, the cache should be repopulated, and registrations should_also exist for the subclasses.__Note: the cache still needs to be repopulated because previous data of those subclasses were_written with the cached serializers. In this case, the repopulated cache has reconfigured serializers_for the subclasses so that previous written data can be read, but the registered serializers_for the subclasses do not necessarily need to be reconfigured since they will only be used to_write new data.;@Test_	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		_		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		assertTrue(pojoSerializer.getRegisteredClasses().isEmpty())__		assertEquals(0, pojoSerializer.getRegisteredSerializers().length)___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		_		ExecutionConfig newExecutionConfig = new ExecutionConfig()__		newExecutionConfig.registerPojoType(SubTestUserClassA.class)__		newExecutionConfig.registerPojoType(SubTestUserClassB.class)__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(newExecutionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		_		_		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__		assertEquals(2, pojoSerializer.getRegisteredClasses().size())__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassB.class))__	};tests,that,previous,pojo,serializer,did,not,have,registrations,and,created,cached,serializers,for,subclasses,on,restore,it,had,those,subclasses,registered,in,this,case,after,reconfiguration,the,cache,should,be,repopulated,and,registrations,should,also,exist,for,the,subclasses,note,the,cache,still,needs,to,be,repopulated,because,previous,data,of,those,subclasses,were,written,with,the,cached,serializers,in,this,case,the,repopulated,cache,has,reconfigured,serializers,for,the,subclasses,so,that,previous,written,data,can,be,read,but,the,registered,serializers,for,the,subclasses,do,not,necessarily,need,to,be,reconfigured,since,they,will,only,be,used,to,write,new,data;test,public,void,test,reconfigure,with,previously,nonregistered,subclasses,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,true,pojo,serializer,get,registered,classes,is,empty,assert,equals,0,pojo,serializer,get,registered,serializers,length,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,execution,config,new,execution,config,new,execution,config,new,execution,config,register,pojo,type,sub,test,user,class,a,class,new,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,false,compat,result,is,requires,migration,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,registered,classes,size,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception;1525657109;Tests that:_- Previous Pojo serializer did not have registrations, and created cached serializers for subclasses_- On restore, it had those subclasses registered__In this case, after reconfiguration, the cache should be repopulated, and registrations should_also exist for the subclasses.__Note: the cache still needs to be repopulated because previous data of those subclasses were_written with the cached serializers. In this case, the repopulated cache has reconfigured serializers_for the subclasses so that previous written data can be read, but the registered serializers_for the subclasses do not necessarily need to be reconfigured since they will only be used to_write new data.;@Test_	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		_		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		assertTrue(pojoSerializer.getRegisteredClasses().isEmpty())__		assertEquals(0, pojoSerializer.getRegisteredSerializers().length)___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		_		ExecutionConfig newExecutionConfig = new ExecutionConfig()__		newExecutionConfig.registerPojoType(SubTestUserClassA.class)__		newExecutionConfig.registerPojoType(SubTestUserClassB.class)__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(newExecutionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		_		_		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__		assertEquals(2, pojoSerializer.getRegisteredClasses().size())__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassB.class))__	};tests,that,previous,pojo,serializer,did,not,have,registrations,and,created,cached,serializers,for,subclasses,on,restore,it,had,those,subclasses,registered,in,this,case,after,reconfiguration,the,cache,should,be,repopulated,and,registrations,should,also,exist,for,the,subclasses,note,the,cache,still,needs,to,be,repopulated,because,previous,data,of,those,subclasses,were,written,with,the,cached,serializers,in,this,case,the,repopulated,cache,has,reconfigured,serializers,for,the,subclasses,so,that,previous,written,data,can,be,read,but,the,registered,serializers,for,the,subclasses,do,not,necessarily,need,to,be,reconfigured,since,they,will,only,be,used,to,write,new,data;test,public,void,test,reconfigure,with,previously,nonregistered,subclasses,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,true,pojo,serializer,get,registered,classes,is,empty,assert,equals,0,pojo,serializer,get,registered,serializers,length,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,execution,config,new,execution,config,new,execution,config,new,execution,config,register,pojo,type,sub,test,user,class,a,class,new,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,false,compat,result,is,requires,migration,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,registered,classes,size,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception;1539149027;Tests that:_- Previous Pojo serializer did not have registrations, and created cached serializers for subclasses_- On restore, it had those subclasses registered__In this case, after reconfiguration, the cache should be repopulated, and registrations should_also exist for the subclasses.__Note: the cache still needs to be repopulated because previous data of those subclasses were_written with the cached serializers. In this case, the repopulated cache has reconfigured serializers_for the subclasses so that previous written data can be read, but the registered serializers_for the subclasses do not necessarily need to be reconfigured since they will only be used to_write new data.;@Test_	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		_		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		assertTrue(pojoSerializer.getRegisteredClasses().isEmpty())__		assertEquals(0, pojoSerializer.getRegisteredSerializers().length)___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		_		ExecutionConfig newExecutionConfig = new ExecutionConfig()__		newExecutionConfig.registerPojoType(SubTestUserClassA.class)__		newExecutionConfig.registerPojoType(SubTestUserClassB.class)__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(newExecutionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		_		_		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__		assertEquals(2, pojoSerializer.getRegisteredClasses().size())__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassB.class))__	};tests,that,previous,pojo,serializer,did,not,have,registrations,and,created,cached,serializers,for,subclasses,on,restore,it,had,those,subclasses,registered,in,this,case,after,reconfiguration,the,cache,should,be,repopulated,and,registrations,should,also,exist,for,the,subclasses,note,the,cache,still,needs,to,be,repopulated,because,previous,data,of,those,subclasses,were,written,with,the,cached,serializers,in,this,case,the,repopulated,cache,has,reconfigured,serializers,for,the,subclasses,so,that,previous,written,data,can,be,read,but,the,registered,serializers,for,the,subclasses,do,not,necessarily,need,to,be,reconfigured,since,they,will,only,be,used,to,write,new,data;test,public,void,test,reconfigure,with,previously,nonregistered,subclasses,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,true,pojo,serializer,get,registered,classes,is,empty,assert,equals,0,pojo,serializer,get,registered,serializers,length,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,execution,config,new,execution,config,new,execution,config,new,execution,config,register,pojo,type,sub,test,user,class,a,class,new,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,false,compat,result,is,requires,migration,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,registered,classes,size,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception;1539149040;Tests that:_- Previous Pojo serializer did not have registrations, and created cached serializers for subclasses_- On restore, it had those subclasses registered__In this case, after reconfiguration, the cache should be repopulated, and registrations should_also exist for the subclasses.__Note: the cache still needs to be repopulated because previous data of those subclasses were_written with the cached serializers. In this case, the repopulated cache has reconfigured serializers_for the subclasses so that previous written data can be read, but the registered serializers_for the subclasses do not necessarily need to be reconfigured since they will only be used to_write new data.;@Test_	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		_		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		assertTrue(pojoSerializer.getRegisteredClasses().isEmpty())__		assertEquals(0, pojoSerializer.getRegisteredSerializers().length)___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerConfigSnapshotSerializationUtil.writeSerializerConfigSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		_		ExecutionConfig newExecutionConfig = new ExecutionConfig()__		newExecutionConfig.registerPojoType(SubTestUserClassA.class)__		newExecutionConfig.registerPojoType(SubTestUserClassB.class)__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(newExecutionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerConfigSnapshotSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		_		_		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__		assertEquals(2, pojoSerializer.getRegisteredClasses().size())__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassB.class))__	};tests,that,previous,pojo,serializer,did,not,have,registrations,and,created,cached,serializers,for,subclasses,on,restore,it,had,those,subclasses,registered,in,this,case,after,reconfiguration,the,cache,should,be,repopulated,and,registrations,should,also,exist,for,the,subclasses,note,the,cache,still,needs,to,be,repopulated,because,previous,data,of,those,subclasses,were,written,with,the,cached,serializers,in,this,case,the,repopulated,cache,has,reconfigured,serializers,for,the,subclasses,so,that,previous,written,data,can,be,read,but,the,registered,serializers,for,the,subclasses,do,not,necessarily,need,to,be,reconfigured,since,they,will,only,be,used,to,write,new,data;test,public,void,test,reconfigure,with,previously,nonregistered,subclasses,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,true,pojo,serializer,get,registered,classes,is,empty,assert,equals,0,pojo,serializer,get,registered,serializers,length,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,config,snapshot,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,execution,config,new,execution,config,new,execution,config,new,execution,config,register,pojo,type,sub,test,user,class,a,class,new,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,config,snapshot,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,false,compat,result,is,requires,migration,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,registered,classes,size,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception;1539149114;Tests that:_- Previous Pojo serializer did not have registrations, and created cached serializers for subclasses_- On restore, it had those subclasses registered__In this case, after reconfiguration, the cache should be repopulated, and registrations should_also exist for the subclasses.__Note: the cache still needs to be repopulated because previous data of those subclasses were_written with the cached serializers. In this case, the repopulated cache has reconfigured serializers_for the subclasses so that previous written data can be read, but the registered serializers_for the subclasses do not necessarily need to be reconfigured since they will only be used to_write new data.;@Test_	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		_		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		assertTrue(pojoSerializer.getRegisteredClasses().isEmpty())__		assertEquals(0, pojoSerializer.getRegisteredSerializers().length)___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		_		ExecutionConfig newExecutionConfig = new ExecutionConfig()__		newExecutionConfig.registerPojoType(SubTestUserClassA.class)__		newExecutionConfig.registerPojoType(SubTestUserClassB.class)__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(newExecutionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer)__		}__		_		_		_		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertFalse(compatResult.isRequiresMigration())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__		assertEquals(2, pojoSerializer.getRegisteredClasses().size())__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassB.class))__	};tests,that,previous,pojo,serializer,did,not,have,registrations,and,created,cached,serializers,for,subclasses,on,restore,it,had,those,subclasses,registered,in,this,case,after,reconfiguration,the,cache,should,be,repopulated,and,registrations,should,also,exist,for,the,subclasses,note,the,cache,still,needs,to,be,repopulated,because,previous,data,of,those,subclasses,were,written,with,the,cached,serializers,in,this,case,the,repopulated,cache,has,reconfigured,serializers,for,the,subclasses,so,that,previous,written,data,can,be,read,but,the,registered,serializers,for,the,subclasses,do,not,necessarily,need,to,be,reconfigured,since,they,will,only,be,used,to,write,new,data;test,public,void,test,reconfigure,with,previously,nonregistered,subclasses,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,true,pojo,serializer,get,registered,classes,is,empty,assert,equals,0,pojo,serializer,get,registered,serializers,length,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,execution,config,new,execution,config,new,execution,config,new,execution,config,register,pojo,type,sub,test,user,class,a,class,new,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,false,compat,result,is,requires,migration,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,registered,classes,size,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception;1540907751;Tests that:_- Previous Pojo serializer did not have registrations, and created cached serializers for subclasses_- On restore, it had those subclasses registered__In this case, after reconfiguration, the cache should be repopulated, and registrations should_also exist for the subclasses.__Note: the cache still needs to be repopulated because previous data of those subclasses were_written with the cached serializers. In this case, the repopulated cache has reconfigured serializers_for the subclasses so that previous written data can be read, but the registered serializers_for the subclasses do not necessarily need to be reconfigured since they will only be used to_write new data.;@Test_	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		_		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		assertTrue(pojoSerializer.getRegisteredClasses().isEmpty())__		assertEquals(0, pojoSerializer.getRegisteredSerializers().length)___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		_		ExecutionConfig newExecutionConfig = new ExecutionConfig()__		newExecutionConfig.registerPojoType(SubTestUserClassA.class)__		newExecutionConfig.registerPojoType(SubTestUserClassB.class)__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(newExecutionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer)__		}__		_		_		_		@SuppressWarnings("unchecked")_		TypeSerializerSchemaCompatibility<TestUserClass, ?> compatResult =_			pojoSerializerConfigSnapshot.resolveSchemaCompatibility(pojoSerializer)__		assertTrue(compatResult.isCompatibleAsIs())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__		assertEquals(2, pojoSerializer.getRegisteredClasses().size())__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassB.class))__	};tests,that,previous,pojo,serializer,did,not,have,registrations,and,created,cached,serializers,for,subclasses,on,restore,it,had,those,subclasses,registered,in,this,case,after,reconfiguration,the,cache,should,be,repopulated,and,registrations,should,also,exist,for,the,subclasses,note,the,cache,still,needs,to,be,repopulated,because,previous,data,of,those,subclasses,were,written,with,the,cached,serializers,in,this,case,the,repopulated,cache,has,reconfigured,serializers,for,the,subclasses,so,that,previous,written,data,can,be,read,but,the,registered,serializers,for,the,subclasses,do,not,necessarily,need,to,be,reconfigured,since,they,will,only,be,used,to,write,new,data;test,public,void,test,reconfigure,with,previously,nonregistered,subclasses,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,true,pojo,serializer,get,registered,classes,is,empty,assert,equals,0,pojo,serializer,get,registered,serializers,length,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,execution,config,new,execution,config,new,execution,config,new,execution,config,register,pojo,type,sub,test,user,class,a,class,new,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer,suppress,warnings,unchecked,type,serializer,schema,compatibility,test,user,class,compat,result,pojo,serializer,config,snapshot,resolve,schema,compatibility,pojo,serializer,assert,true,compat,result,is,compatible,as,is,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,registered,classes,size,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception;1540907751;Tests that:_- Previous Pojo serializer did not have registrations, and created cached serializers for subclasses_- On restore, it had those subclasses registered__In this case, after reconfiguration, the cache should be repopulated, and registrations should_also exist for the subclasses.__Note: the cache still needs to be repopulated because previous data of those subclasses were_written with the cached serializers. In this case, the repopulated cache has reconfigured serializers_for the subclasses so that previous written data can be read, but the registered serializers_for the subclasses do not necessarily need to be reconfigured since they will only be used to_write new data.;@Test_	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		_		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		assertTrue(pojoSerializer.getRegisteredClasses().isEmpty())__		assertEquals(0, pojoSerializer.getRegisteredSerializers().length)___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		_		ExecutionConfig newExecutionConfig = new ExecutionConfig()__		newExecutionConfig.registerPojoType(SubTestUserClassA.class)__		newExecutionConfig.registerPojoType(SubTestUserClassB.class)__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(newExecutionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer)__		}__		_		_		_		@SuppressWarnings("unchecked")_		TypeSerializerSchemaCompatibility<TestUserClass, ?> compatResult =_			pojoSerializerConfigSnapshot.resolveSchemaCompatibility(pojoSerializer)__		assertTrue(compatResult.isCompatibleAsIs())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__		assertEquals(2, pojoSerializer.getRegisteredClasses().size())__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassB.class))__	};tests,that,previous,pojo,serializer,did,not,have,registrations,and,created,cached,serializers,for,subclasses,on,restore,it,had,those,subclasses,registered,in,this,case,after,reconfiguration,the,cache,should,be,repopulated,and,registrations,should,also,exist,for,the,subclasses,note,the,cache,still,needs,to,be,repopulated,because,previous,data,of,those,subclasses,were,written,with,the,cached,serializers,in,this,case,the,repopulated,cache,has,reconfigured,serializers,for,the,subclasses,so,that,previous,written,data,can,be,read,but,the,registered,serializers,for,the,subclasses,do,not,necessarily,need,to,be,reconfigured,since,they,will,only,be,used,to,write,new,data;test,public,void,test,reconfigure,with,previously,nonregistered,subclasses,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,true,pojo,serializer,get,registered,classes,is,empty,assert,equals,0,pojo,serializer,get,registered,serializers,length,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,execution,config,new,execution,config,new,execution,config,new,execution,config,register,pojo,type,sub,test,user,class,a,class,new,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer,suppress,warnings,unchecked,type,serializer,schema,compatibility,test,user,class,compat,result,pojo,serializer,config,snapshot,resolve,schema,compatibility,pojo,serializer,assert,true,compat,result,is,compatible,as,is,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,registered,classes,size,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception;1540907751;Tests that:_- Previous Pojo serializer did not have registrations, and created cached serializers for subclasses_- On restore, it had those subclasses registered__In this case, after reconfiguration, the cache should be repopulated, and registrations should_also exist for the subclasses.__Note: the cache still needs to be repopulated because previous data of those subclasses were_written with the cached serializers. In this case, the repopulated cache has reconfigured serializers_for the subclasses so that previous written data can be read, but the registered serializers_for the subclasses do not necessarily need to be reconfigured since they will only be used to_write new data.;@Test_	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		_		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		assertTrue(pojoSerializer.getRegisteredClasses().isEmpty())__		assertEquals(0, pojoSerializer.getRegisteredSerializers().length)___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		_		ExecutionConfig newExecutionConfig = new ExecutionConfig()__		newExecutionConfig.registerPojoType(SubTestUserClassA.class)__		newExecutionConfig.registerPojoType(SubTestUserClassB.class)__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(newExecutionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer)__		}__		_		_		_		@SuppressWarnings("unchecked")_		TypeSerializerSchemaCompatibility<TestUserClass> compatResult =_			pojoSerializerConfigSnapshot.resolveSchemaCompatibility(pojoSerializer)__		assertTrue(compatResult.isCompatibleAsIs())__		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__		assertEquals(2, pojoSerializer.getRegisteredClasses().size())__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassB.class))__	};tests,that,previous,pojo,serializer,did,not,have,registrations,and,created,cached,serializers,for,subclasses,on,restore,it,had,those,subclasses,registered,in,this,case,after,reconfiguration,the,cache,should,be,repopulated,and,registrations,should,also,exist,for,the,subclasses,note,the,cache,still,needs,to,be,repopulated,because,previous,data,of,those,subclasses,were,written,with,the,cached,serializers,in,this,case,the,repopulated,cache,has,reconfigured,serializers,for,the,subclasses,so,that,previous,written,data,can,be,read,but,the,registered,serializers,for,the,subclasses,do,not,necessarily,need,to,be,reconfigured,since,they,will,only,be,used,to,write,new,data;test,public,void,test,reconfigure,with,previously,nonregistered,subclasses,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,true,pojo,serializer,get,registered,classes,is,empty,assert,equals,0,pojo,serializer,get,registered,serializers,length,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,execution,config,new,execution,config,new,execution,config,new,execution,config,register,pojo,type,sub,test,user,class,a,class,new,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer,suppress,warnings,unchecked,type,serializer,schema,compatibility,test,user,class,compat,result,pojo,serializer,config,snapshot,resolve,schema,compatibility,pojo,serializer,assert,true,compat,result,is,compatible,as,is,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,registered,classes,size,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @Test 	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception;1550821417;Tests that:_- Previous Pojo serializer did not have registrations, and created cached serializers for subclasses_- On restore, it had those subclasses registered__In this case, after reconfiguration, the cache should be repopulated, and registrations should_also exist for the subclasses.__Note: the cache still needs to be repopulated because previous data of those subclasses were_written with the cached serializers. In this case, the repopulated cache has reconfigured serializers_for the subclasses so that previous written data can be read, but the registered serializers_for the subclasses do not necessarily need to be reconfigured since they will only be used to_write new data.;@Test_	public void testReconfigureWithPreviouslyNonregisteredSubclasses() throws Exception {_		_		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(new ExecutionConfig())___		_		pojoSerializer.getSubclassSerializer(SubTestUserClassA.class)__		pojoSerializer.getSubclassSerializer(SubTestUserClassB.class)___		_		assertEquals(2, pojoSerializer.getSubclassSerializerCache().size())__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(pojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))___		_		assertTrue(pojoSerializer.getRegisteredClasses().isEmpty())__		assertEquals(0, pojoSerializer.getRegisteredSerializers().length)___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		_		ExecutionConfig newExecutionConfig = new ExecutionConfig()__		newExecutionConfig.registerPojoType(SubTestUserClassA.class)__		newExecutionConfig.registerPojoType(SubTestUserClassB.class)__		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(newExecutionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer)__		}__		_		_		_		@SuppressWarnings("unchecked")_		TypeSerializerSchemaCompatibility<TestUserClass> compatResult =_			pojoSerializerConfigSnapshot.resolveSchemaCompatibility(pojoSerializer)__		assertTrue(compatResult.isCompatibleWithReconfiguredSerializer())__		assertTrue(compatResult.getReconfiguredSerializer() instanceof PojoSerializer)___		PojoSerializer<TestUserClass> reconfiguredPojoSerializer = (PojoSerializer<TestUserClass>) compatResult.getReconfiguredSerializer()__		assertEquals(2, reconfiguredPojoSerializer.getSubclassSerializerCache().size())__		assertTrue(reconfiguredPojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassA.class))__		assertTrue(reconfiguredPojoSerializer.getSubclassSerializerCache().containsKey(SubTestUserClassB.class))__		assertEquals(2, reconfiguredPojoSerializer.getRegisteredClasses().size())__		assertTrue(reconfiguredPojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassA.class))__		assertTrue(reconfiguredPojoSerializer.getRegisteredClasses().containsKey(SubTestUserClassB.class))__	};tests,that,previous,pojo,serializer,did,not,have,registrations,and,created,cached,serializers,for,subclasses,on,restore,it,had,those,subclasses,registered,in,this,case,after,reconfiguration,the,cache,should,be,repopulated,and,registrations,should,also,exist,for,the,subclasses,note,the,cache,still,needs,to,be,repopulated,because,previous,data,of,those,subclasses,were,written,with,the,cached,serializers,in,this,case,the,repopulated,cache,has,reconfigured,serializers,for,the,subclasses,so,that,previous,written,data,can,be,read,but,the,registered,serializers,for,the,subclasses,do,not,necessarily,need,to,be,reconfigured,since,they,will,only,be,used,to,write,new,data;test,public,void,test,reconfigure,with,previously,nonregistered,subclasses,throws,exception,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,pojo,serializer,get,subclass,serializer,sub,test,user,class,a,class,pojo,serializer,get,subclass,serializer,sub,test,user,class,b,class,assert,equals,2,pojo,serializer,get,subclass,serializer,cache,size,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,true,pojo,serializer,get,registered,classes,is,empty,assert,equals,0,pojo,serializer,get,registered,serializers,length,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,execution,config,new,execution,config,new,execution,config,new,execution,config,register,pojo,type,sub,test,user,class,a,class,new,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer,suppress,warnings,unchecked,type,serializer,schema,compatibility,test,user,class,compat,result,pojo,serializer,config,snapshot,resolve,schema,compatibility,pojo,serializer,assert,true,compat,result,is,compatible,with,reconfigured,serializer,assert,true,compat,result,get,reconfigured,serializer,instanceof,pojo,serializer,pojo,serializer,test,user,class,reconfigured,pojo,serializer,pojo,serializer,test,user,class,compat,result,get,reconfigured,serializer,assert,equals,2,reconfigured,pojo,serializer,get,subclass,serializer,cache,size,assert,true,reconfigured,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,a,class,assert,true,reconfigured,pojo,serializer,get,subclass,serializer,cache,contains,key,sub,test,user,class,b,class,assert,equals,2,reconfigured,pojo,serializer,get,registered,classes,size,assert,true,reconfigured,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,a,class,assert,true,reconfigured,pojo,serializer,get,registered,classes,contains,key,sub,test,user,class,b,class
PojoSerializerTest -> @SuppressWarnings({ "rawtypes", "unchecked" }) 	@Test 	public void testTuplePojoTestEquality();1454428544;This tests if the hashes returned by the pojo and tuple comparators are the same;@SuppressWarnings({ "rawtypes", "unchecked" })_	@Test_	public void testTuplePojoTestEquality() {_		_		_		PojoTypeInfo<TestUserClass> pType = (PojoTypeInfo<TestUserClass>) type__		List<FlatFieldDescriptor> result = new ArrayList<FlatFieldDescriptor>()__		pType.getFlatFields("nestedClass.dumm2", 0, result)__		int[] fields = new int[1]_ _		fields[0] = result.get(0).getPosition()__		TypeComparator<TestUserClass> pojoComp = pType.createComparator( fields, new boolean[]{true}, 0, new ExecutionConfig())__		_		TestUserClass pojoTestRecord = new TestUserClass(0, "abc", 3d, new int[] {1,2,3}, new Date(), new NestedTestUserClass(1, "haha", 4d, new int[] {5,4,3}))__		int pHash = pojoComp.hash(pojoTestRecord)__		_		Tuple1<String> tupleTest = new Tuple1<String>("haha")__		TupleTypeInfo<Tuple1<String>> tType = (TupleTypeInfo<Tuple1<String>>)TypeExtractor.getForObject(tupleTest)__		TypeComparator<Tuple1<String>> tupleComp = tType.createComparator(new int[] {0}, new boolean[] {true}, 0, new ExecutionConfig())__		_		int tHash = tupleComp.hash(tupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable", pHash == tHash)__		_		Tuple3<Integer, String, Double> multiTupleTest = new Tuple3<Integer, String, Double>(1, "haha", 4d)_ _		TupleTypeInfo<Tuple3<Integer, String, Double>> multiTupleType = (TupleTypeInfo<Tuple3<Integer, String, Double>>)TypeExtractor.getForObject(multiTupleTest)__		_		ExpressionKeys fieldKey = new ExpressionKeys(new int[]{1,0,2}, multiTupleType)__		ExpressionKeys expressKey = new ExpressionKeys(new String[] {"nestedClass.dumm2", "nestedClass.dumm1", "nestedClass.dumm3"}, pType)__		try {_			Assert.assertTrue("Expecting the keys to be compatible", fieldKey.areCompatible(expressKey))__		} catch (IncompatibleKeysException e) {_			e.printStackTrace()__			Assert.fail("Keys must be compatible: "+e.getMessage())__		}_		TypeComparator<TestUserClass> multiPojoComp = pType.createComparator( expressKey.computeLogicalKeyPositions(), new boolean[]{true, true, true}, 0, new ExecutionConfig())__		int multiPojoHash = multiPojoComp.hash(pojoTestRecord)__		_		_		_		TypeComparator<Tuple3<Integer, String, Double>> multiTupleComp = multiTupleType.createComparator(fieldKey.computeLogicalKeyPositions(), new boolean[] {true, true,true}, 0, new ExecutionConfig())__		int multiTupleHash = multiTupleComp.hash(multiTupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable. Also for those with multiple key fields", multiPojoHash == multiTupleHash)__		_	};this,tests,if,the,hashes,returned,by,the,pojo,and,tuple,comparators,are,the,same;suppress,warnings,rawtypes,unchecked,test,public,void,test,tuple,pojo,test,equality,pojo,type,info,test,user,class,p,type,pojo,type,info,test,user,class,type,list,flat,field,descriptor,result,new,array,list,flat,field,descriptor,p,type,get,flat,fields,nested,class,dumm2,0,result,int,fields,new,int,1,fields,0,result,get,0,get,position,type,comparator,test,user,class,pojo,comp,p,type,create,comparator,fields,new,boolean,true,0,new,execution,config,test,user,class,pojo,test,record,new,test,user,class,0,abc,3d,new,int,1,2,3,new,date,new,nested,test,user,class,1,haha,4d,new,int,5,4,3,int,p,hash,pojo,comp,hash,pojo,test,record,tuple1,string,tuple,test,new,tuple1,string,haha,tuple,type,info,tuple1,string,t,type,tuple,type,info,tuple1,string,type,extractor,get,for,object,tuple,test,type,comparator,tuple1,string,tuple,comp,t,type,create,comparator,new,int,0,new,boolean,true,0,new,execution,config,int,t,hash,tuple,comp,hash,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,p,hash,t,hash,tuple3,integer,string,double,multi,tuple,test,new,tuple3,integer,string,double,1,haha,4d,tuple,type,info,tuple3,integer,string,double,multi,tuple,type,tuple,type,info,tuple3,integer,string,double,type,extractor,get,for,object,multi,tuple,test,expression,keys,field,key,new,expression,keys,new,int,1,0,2,multi,tuple,type,expression,keys,express,key,new,expression,keys,new,string,nested,class,dumm2,nested,class,dumm1,nested,class,dumm3,p,type,try,assert,assert,true,expecting,the,keys,to,be,compatible,field,key,are,compatible,express,key,catch,incompatible,keys,exception,e,e,print,stack,trace,assert,fail,keys,must,be,compatible,e,get,message,type,comparator,test,user,class,multi,pojo,comp,p,type,create,comparator,express,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,pojo,hash,multi,pojo,comp,hash,pojo,test,record,type,comparator,tuple3,integer,string,double,multi,tuple,comp,multi,tuple,type,create,comparator,field,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,tuple,hash,multi,tuple,comp,hash,multi,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,also,for,those,with,multiple,key,fields,multi,pojo,hash,multi,tuple,hash
PojoSerializerTest -> @SuppressWarnings({ "rawtypes", "unchecked" }) 	@Test 	public void testTuplePojoTestEquality();1460741894;This tests if the hashes returned by the pojo and tuple comparators are the same;@SuppressWarnings({ "rawtypes", "unchecked" })_	@Test_	public void testTuplePojoTestEquality() {_		_		_		PojoTypeInfo<TestUserClass> pType = (PojoTypeInfo<TestUserClass>) type__		List<FlatFieldDescriptor> result = new ArrayList<FlatFieldDescriptor>()__		pType.getFlatFields("nestedClass.dumm2", 0, result)__		int[] fields = new int[1]_ _		fields[0] = result.get(0).getPosition()__		TypeComparator<TestUserClass> pojoComp = pType.createComparator( fields, new boolean[]{true}, 0, new ExecutionConfig())__		_		TestUserClass pojoTestRecord = new TestUserClass(0, "abc", 3d, new int[] {1,2,3}, new Date(), new NestedTestUserClass(1, "haha", 4d, new int[] {5,4,3}))__		int pHash = pojoComp.hash(pojoTestRecord)__		_		Tuple1<String> tupleTest = new Tuple1<String>("haha")__		TupleTypeInfo<Tuple1<String>> tType = (TupleTypeInfo<Tuple1<String>>)TypeExtractor.getForObject(tupleTest)__		TypeComparator<Tuple1<String>> tupleComp = tType.createComparator(new int[] {0}, new boolean[] {true}, 0, new ExecutionConfig())__		_		int tHash = tupleComp.hash(tupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable", pHash == tHash)__		_		Tuple3<Integer, String, Double> multiTupleTest = new Tuple3<Integer, String, Double>(1, "haha", 4d)_ _		TupleTypeInfo<Tuple3<Integer, String, Double>> multiTupleType = (TupleTypeInfo<Tuple3<Integer, String, Double>>)TypeExtractor.getForObject(multiTupleTest)__		_		ExpressionKeys fieldKey = new ExpressionKeys(new int[]{1,0,2}, multiTupleType)__		ExpressionKeys expressKey = new ExpressionKeys(new String[] {"nestedClass.dumm2", "nestedClass.dumm1", "nestedClass.dumm3"}, pType)__		try {_			Assert.assertTrue("Expecting the keys to be compatible", fieldKey.areCompatible(expressKey))__		} catch (IncompatibleKeysException e) {_			e.printStackTrace()__			Assert.fail("Keys must be compatible: "+e.getMessage())__		}_		TypeComparator<TestUserClass> multiPojoComp = pType.createComparator( expressKey.computeLogicalKeyPositions(), new boolean[]{true, true, true}, 0, new ExecutionConfig())__		int multiPojoHash = multiPojoComp.hash(pojoTestRecord)__		_		_		_		TypeComparator<Tuple3<Integer, String, Double>> multiTupleComp = multiTupleType.createComparator(fieldKey.computeLogicalKeyPositions(), new boolean[] {true, true,true}, 0, new ExecutionConfig())__		int multiTupleHash = multiTupleComp.hash(multiTupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable. Also for those with multiple key fields", multiPojoHash == multiTupleHash)__		_	};this,tests,if,the,hashes,returned,by,the,pojo,and,tuple,comparators,are,the,same;suppress,warnings,rawtypes,unchecked,test,public,void,test,tuple,pojo,test,equality,pojo,type,info,test,user,class,p,type,pojo,type,info,test,user,class,type,list,flat,field,descriptor,result,new,array,list,flat,field,descriptor,p,type,get,flat,fields,nested,class,dumm2,0,result,int,fields,new,int,1,fields,0,result,get,0,get,position,type,comparator,test,user,class,pojo,comp,p,type,create,comparator,fields,new,boolean,true,0,new,execution,config,test,user,class,pojo,test,record,new,test,user,class,0,abc,3d,new,int,1,2,3,new,date,new,nested,test,user,class,1,haha,4d,new,int,5,4,3,int,p,hash,pojo,comp,hash,pojo,test,record,tuple1,string,tuple,test,new,tuple1,string,haha,tuple,type,info,tuple1,string,t,type,tuple,type,info,tuple1,string,type,extractor,get,for,object,tuple,test,type,comparator,tuple1,string,tuple,comp,t,type,create,comparator,new,int,0,new,boolean,true,0,new,execution,config,int,t,hash,tuple,comp,hash,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,p,hash,t,hash,tuple3,integer,string,double,multi,tuple,test,new,tuple3,integer,string,double,1,haha,4d,tuple,type,info,tuple3,integer,string,double,multi,tuple,type,tuple,type,info,tuple3,integer,string,double,type,extractor,get,for,object,multi,tuple,test,expression,keys,field,key,new,expression,keys,new,int,1,0,2,multi,tuple,type,expression,keys,express,key,new,expression,keys,new,string,nested,class,dumm2,nested,class,dumm1,nested,class,dumm3,p,type,try,assert,assert,true,expecting,the,keys,to,be,compatible,field,key,are,compatible,express,key,catch,incompatible,keys,exception,e,e,print,stack,trace,assert,fail,keys,must,be,compatible,e,get,message,type,comparator,test,user,class,multi,pojo,comp,p,type,create,comparator,express,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,pojo,hash,multi,pojo,comp,hash,pojo,test,record,type,comparator,tuple3,integer,string,double,multi,tuple,comp,multi,tuple,type,create,comparator,field,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,tuple,hash,multi,tuple,comp,hash,multi,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,also,for,those,with,multiple,key,fields,multi,pojo,hash,multi,tuple,hash
PojoSerializerTest -> @SuppressWarnings({ "rawtypes", "unchecked" }) 	@Test 	public void testTuplePojoTestEquality();1494180263;This tests if the hashes returned by the pojo and tuple comparators are the same;@SuppressWarnings({ "rawtypes", "unchecked" })_	@Test_	public void testTuplePojoTestEquality() {_		_		_		PojoTypeInfo<TestUserClass> pType = (PojoTypeInfo<TestUserClass>) type__		List<FlatFieldDescriptor> result = new ArrayList<FlatFieldDescriptor>()__		pType.getFlatFields("nestedClass.dumm2", 0, result)__		int[] fields = new int[1]_ _		fields[0] = result.get(0).getPosition()__		TypeComparator<TestUserClass> pojoComp = pType.createComparator( fields, new boolean[]{true}, 0, new ExecutionConfig())__		_		TestUserClass pojoTestRecord = new TestUserClass(0, "abc", 3d, new int[] {1,2,3}, new Date(), new NestedTestUserClass(1, "haha", 4d, new int[] {5,4,3}))__		int pHash = pojoComp.hash(pojoTestRecord)__		_		Tuple1<String> tupleTest = new Tuple1<String>("haha")__		TupleTypeInfo<Tuple1<String>> tType = (TupleTypeInfo<Tuple1<String>>)TypeExtractor.getForObject(tupleTest)__		TypeComparator<Tuple1<String>> tupleComp = tType.createComparator(new int[] {0}, new boolean[] {true}, 0, new ExecutionConfig())__		_		int tHash = tupleComp.hash(tupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable", pHash == tHash)__		_		Tuple3<Integer, String, Double> multiTupleTest = new Tuple3<Integer, String, Double>(1, "haha", 4d)_ _		TupleTypeInfo<Tuple3<Integer, String, Double>> multiTupleType = (TupleTypeInfo<Tuple3<Integer, String, Double>>)TypeExtractor.getForObject(multiTupleTest)__		_		ExpressionKeys fieldKey = new ExpressionKeys(new int[]{1,0,2}, multiTupleType)__		ExpressionKeys expressKey = new ExpressionKeys(new String[] {"nestedClass.dumm2", "nestedClass.dumm1", "nestedClass.dumm3"}, pType)__		try {_			Assert.assertTrue("Expecting the keys to be compatible", fieldKey.areCompatible(expressKey))__		} catch (IncompatibleKeysException e) {_			e.printStackTrace()__			Assert.fail("Keys must be compatible: "+e.getMessage())__		}_		TypeComparator<TestUserClass> multiPojoComp = pType.createComparator( expressKey.computeLogicalKeyPositions(), new boolean[]{true, true, true}, 0, new ExecutionConfig())__		int multiPojoHash = multiPojoComp.hash(pojoTestRecord)__		_		_		_		TypeComparator<Tuple3<Integer, String, Double>> multiTupleComp = multiTupleType.createComparator(fieldKey.computeLogicalKeyPositions(), new boolean[] {true, true,true}, 0, new ExecutionConfig())__		int multiTupleHash = multiTupleComp.hash(multiTupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable. Also for those with multiple key fields", multiPojoHash == multiTupleHash)__		_	};this,tests,if,the,hashes,returned,by,the,pojo,and,tuple,comparators,are,the,same;suppress,warnings,rawtypes,unchecked,test,public,void,test,tuple,pojo,test,equality,pojo,type,info,test,user,class,p,type,pojo,type,info,test,user,class,type,list,flat,field,descriptor,result,new,array,list,flat,field,descriptor,p,type,get,flat,fields,nested,class,dumm2,0,result,int,fields,new,int,1,fields,0,result,get,0,get,position,type,comparator,test,user,class,pojo,comp,p,type,create,comparator,fields,new,boolean,true,0,new,execution,config,test,user,class,pojo,test,record,new,test,user,class,0,abc,3d,new,int,1,2,3,new,date,new,nested,test,user,class,1,haha,4d,new,int,5,4,3,int,p,hash,pojo,comp,hash,pojo,test,record,tuple1,string,tuple,test,new,tuple1,string,haha,tuple,type,info,tuple1,string,t,type,tuple,type,info,tuple1,string,type,extractor,get,for,object,tuple,test,type,comparator,tuple1,string,tuple,comp,t,type,create,comparator,new,int,0,new,boolean,true,0,new,execution,config,int,t,hash,tuple,comp,hash,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,p,hash,t,hash,tuple3,integer,string,double,multi,tuple,test,new,tuple3,integer,string,double,1,haha,4d,tuple,type,info,tuple3,integer,string,double,multi,tuple,type,tuple,type,info,tuple3,integer,string,double,type,extractor,get,for,object,multi,tuple,test,expression,keys,field,key,new,expression,keys,new,int,1,0,2,multi,tuple,type,expression,keys,express,key,new,expression,keys,new,string,nested,class,dumm2,nested,class,dumm1,nested,class,dumm3,p,type,try,assert,assert,true,expecting,the,keys,to,be,compatible,field,key,are,compatible,express,key,catch,incompatible,keys,exception,e,e,print,stack,trace,assert,fail,keys,must,be,compatible,e,get,message,type,comparator,test,user,class,multi,pojo,comp,p,type,create,comparator,express,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,pojo,hash,multi,pojo,comp,hash,pojo,test,record,type,comparator,tuple3,integer,string,double,multi,tuple,comp,multi,tuple,type,create,comparator,field,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,tuple,hash,multi,tuple,comp,hash,multi,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,also,for,those,with,multiple,key,fields,multi,pojo,hash,multi,tuple,hash
PojoSerializerTest -> @SuppressWarnings({ "rawtypes", "unchecked" }) 	@Test 	public void testTuplePojoTestEquality();1494658833;This tests if the hashes returned by the pojo and tuple comparators are the same;@SuppressWarnings({ "rawtypes", "unchecked" })_	@Test_	public void testTuplePojoTestEquality() {_		_		_		PojoTypeInfo<TestUserClass> pType = (PojoTypeInfo<TestUserClass>) type__		List<FlatFieldDescriptor> result = new ArrayList<FlatFieldDescriptor>()__		pType.getFlatFields("nestedClass.dumm2", 0, result)__		int[] fields = new int[1]_ _		fields[0] = result.get(0).getPosition()__		TypeComparator<TestUserClass> pojoComp = pType.createComparator( fields, new boolean[]{true}, 0, new ExecutionConfig())__		_		TestUserClass pojoTestRecord = new TestUserClass(0, "abc", 3d, new int[] {1,2,3}, new Date(), new NestedTestUserClass(1, "haha", 4d, new int[] {5,4,3}))__		int pHash = pojoComp.hash(pojoTestRecord)__		_		Tuple1<String> tupleTest = new Tuple1<String>("haha")__		TupleTypeInfo<Tuple1<String>> tType = (TupleTypeInfo<Tuple1<String>>)TypeExtractor.getForObject(tupleTest)__		TypeComparator<Tuple1<String>> tupleComp = tType.createComparator(new int[] {0}, new boolean[] {true}, 0, new ExecutionConfig())__		_		int tHash = tupleComp.hash(tupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable", pHash == tHash)__		_		Tuple3<Integer, String, Double> multiTupleTest = new Tuple3<Integer, String, Double>(1, "haha", 4d)_ _		TupleTypeInfo<Tuple3<Integer, String, Double>> multiTupleType = (TupleTypeInfo<Tuple3<Integer, String, Double>>)TypeExtractor.getForObject(multiTupleTest)__		_		ExpressionKeys fieldKey = new ExpressionKeys(new int[]{1,0,2}, multiTupleType)__		ExpressionKeys expressKey = new ExpressionKeys(new String[] {"nestedClass.dumm2", "nestedClass.dumm1", "nestedClass.dumm3"}, pType)__		try {_			Assert.assertTrue("Expecting the keys to be compatible", fieldKey.areCompatible(expressKey))__		} catch (IncompatibleKeysException e) {_			e.printStackTrace()__			Assert.fail("Keys must be compatible: "+e.getMessage())__		}_		TypeComparator<TestUserClass> multiPojoComp = pType.createComparator( expressKey.computeLogicalKeyPositions(), new boolean[]{true, true, true}, 0, new ExecutionConfig())__		int multiPojoHash = multiPojoComp.hash(pojoTestRecord)__		_		_		_		TypeComparator<Tuple3<Integer, String, Double>> multiTupleComp = multiTupleType.createComparator(fieldKey.computeLogicalKeyPositions(), new boolean[] {true, true,true}, 0, new ExecutionConfig())__		int multiTupleHash = multiTupleComp.hash(multiTupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable. Also for those with multiple key fields", multiPojoHash == multiTupleHash)__		_	};this,tests,if,the,hashes,returned,by,the,pojo,and,tuple,comparators,are,the,same;suppress,warnings,rawtypes,unchecked,test,public,void,test,tuple,pojo,test,equality,pojo,type,info,test,user,class,p,type,pojo,type,info,test,user,class,type,list,flat,field,descriptor,result,new,array,list,flat,field,descriptor,p,type,get,flat,fields,nested,class,dumm2,0,result,int,fields,new,int,1,fields,0,result,get,0,get,position,type,comparator,test,user,class,pojo,comp,p,type,create,comparator,fields,new,boolean,true,0,new,execution,config,test,user,class,pojo,test,record,new,test,user,class,0,abc,3d,new,int,1,2,3,new,date,new,nested,test,user,class,1,haha,4d,new,int,5,4,3,int,p,hash,pojo,comp,hash,pojo,test,record,tuple1,string,tuple,test,new,tuple1,string,haha,tuple,type,info,tuple1,string,t,type,tuple,type,info,tuple1,string,type,extractor,get,for,object,tuple,test,type,comparator,tuple1,string,tuple,comp,t,type,create,comparator,new,int,0,new,boolean,true,0,new,execution,config,int,t,hash,tuple,comp,hash,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,p,hash,t,hash,tuple3,integer,string,double,multi,tuple,test,new,tuple3,integer,string,double,1,haha,4d,tuple,type,info,tuple3,integer,string,double,multi,tuple,type,tuple,type,info,tuple3,integer,string,double,type,extractor,get,for,object,multi,tuple,test,expression,keys,field,key,new,expression,keys,new,int,1,0,2,multi,tuple,type,expression,keys,express,key,new,expression,keys,new,string,nested,class,dumm2,nested,class,dumm1,nested,class,dumm3,p,type,try,assert,assert,true,expecting,the,keys,to,be,compatible,field,key,are,compatible,express,key,catch,incompatible,keys,exception,e,e,print,stack,trace,assert,fail,keys,must,be,compatible,e,get,message,type,comparator,test,user,class,multi,pojo,comp,p,type,create,comparator,express,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,pojo,hash,multi,pojo,comp,hash,pojo,test,record,type,comparator,tuple3,integer,string,double,multi,tuple,comp,multi,tuple,type,create,comparator,field,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,tuple,hash,multi,tuple,comp,hash,multi,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,also,for,those,with,multiple,key,fields,multi,pojo,hash,multi,tuple,hash
PojoSerializerTest -> @SuppressWarnings({ "rawtypes", "unchecked" }) 	@Test 	public void testTuplePojoTestEquality();1495466666;This tests if the hashes returned by the pojo and tuple comparators are the same;@SuppressWarnings({ "rawtypes", "unchecked" })_	@Test_	public void testTuplePojoTestEquality() {_		_		_		PojoTypeInfo<TestUserClass> pType = (PojoTypeInfo<TestUserClass>) type__		List<FlatFieldDescriptor> result = new ArrayList<FlatFieldDescriptor>()__		pType.getFlatFields("nestedClass.dumm2", 0, result)__		int[] fields = new int[1]_ _		fields[0] = result.get(0).getPosition()__		TypeComparator<TestUserClass> pojoComp = pType.createComparator( fields, new boolean[]{true}, 0, new ExecutionConfig())__		_		TestUserClass pojoTestRecord = new TestUserClass(0, "abc", 3d, new int[] {1,2,3}, new Date(), new NestedTestUserClass(1, "haha", 4d, new int[] {5,4,3}))__		int pHash = pojoComp.hash(pojoTestRecord)__		_		Tuple1<String> tupleTest = new Tuple1<String>("haha")__		TupleTypeInfo<Tuple1<String>> tType = (TupleTypeInfo<Tuple1<String>>)TypeExtractor.getForObject(tupleTest)__		TypeComparator<Tuple1<String>> tupleComp = tType.createComparator(new int[] {0}, new boolean[] {true}, 0, new ExecutionConfig())__		_		int tHash = tupleComp.hash(tupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable", pHash == tHash)__		_		Tuple3<Integer, String, Double> multiTupleTest = new Tuple3<Integer, String, Double>(1, "haha", 4d)_ _		TupleTypeInfo<Tuple3<Integer, String, Double>> multiTupleType = (TupleTypeInfo<Tuple3<Integer, String, Double>>)TypeExtractor.getForObject(multiTupleTest)__		_		ExpressionKeys fieldKey = new ExpressionKeys(new int[]{1,0,2}, multiTupleType)__		ExpressionKeys expressKey = new ExpressionKeys(new String[] {"nestedClass.dumm2", "nestedClass.dumm1", "nestedClass.dumm3"}, pType)__		try {_			Assert.assertTrue("Expecting the keys to be compatible", fieldKey.areCompatible(expressKey))__		} catch (IncompatibleKeysException e) {_			e.printStackTrace()__			Assert.fail("Keys must be compatible: "+e.getMessage())__		}_		TypeComparator<TestUserClass> multiPojoComp = pType.createComparator( expressKey.computeLogicalKeyPositions(), new boolean[]{true, true, true}, 0, new ExecutionConfig())__		int multiPojoHash = multiPojoComp.hash(pojoTestRecord)__		_		_		_		TypeComparator<Tuple3<Integer, String, Double>> multiTupleComp = multiTupleType.createComparator(fieldKey.computeLogicalKeyPositions(), new boolean[] {true, true,true}, 0, new ExecutionConfig())__		int multiTupleHash = multiTupleComp.hash(multiTupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable. Also for those with multiple key fields", multiPojoHash == multiTupleHash)__		_	};this,tests,if,the,hashes,returned,by,the,pojo,and,tuple,comparators,are,the,same;suppress,warnings,rawtypes,unchecked,test,public,void,test,tuple,pojo,test,equality,pojo,type,info,test,user,class,p,type,pojo,type,info,test,user,class,type,list,flat,field,descriptor,result,new,array,list,flat,field,descriptor,p,type,get,flat,fields,nested,class,dumm2,0,result,int,fields,new,int,1,fields,0,result,get,0,get,position,type,comparator,test,user,class,pojo,comp,p,type,create,comparator,fields,new,boolean,true,0,new,execution,config,test,user,class,pojo,test,record,new,test,user,class,0,abc,3d,new,int,1,2,3,new,date,new,nested,test,user,class,1,haha,4d,new,int,5,4,3,int,p,hash,pojo,comp,hash,pojo,test,record,tuple1,string,tuple,test,new,tuple1,string,haha,tuple,type,info,tuple1,string,t,type,tuple,type,info,tuple1,string,type,extractor,get,for,object,tuple,test,type,comparator,tuple1,string,tuple,comp,t,type,create,comparator,new,int,0,new,boolean,true,0,new,execution,config,int,t,hash,tuple,comp,hash,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,p,hash,t,hash,tuple3,integer,string,double,multi,tuple,test,new,tuple3,integer,string,double,1,haha,4d,tuple,type,info,tuple3,integer,string,double,multi,tuple,type,tuple,type,info,tuple3,integer,string,double,type,extractor,get,for,object,multi,tuple,test,expression,keys,field,key,new,expression,keys,new,int,1,0,2,multi,tuple,type,expression,keys,express,key,new,expression,keys,new,string,nested,class,dumm2,nested,class,dumm1,nested,class,dumm3,p,type,try,assert,assert,true,expecting,the,keys,to,be,compatible,field,key,are,compatible,express,key,catch,incompatible,keys,exception,e,e,print,stack,trace,assert,fail,keys,must,be,compatible,e,get,message,type,comparator,test,user,class,multi,pojo,comp,p,type,create,comparator,express,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,pojo,hash,multi,pojo,comp,hash,pojo,test,record,type,comparator,tuple3,integer,string,double,multi,tuple,comp,multi,tuple,type,create,comparator,field,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,tuple,hash,multi,tuple,comp,hash,multi,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,also,for,those,with,multiple,key,fields,multi,pojo,hash,multi,tuple,hash
PojoSerializerTest -> @SuppressWarnings({ "rawtypes", "unchecked" }) 	@Test 	public void testTuplePojoTestEquality();1497328697;This tests if the hashes returned by the pojo and tuple comparators are the same;@SuppressWarnings({ "rawtypes", "unchecked" })_	@Test_	public void testTuplePojoTestEquality() {_		_		_		PojoTypeInfo<TestUserClass> pType = (PojoTypeInfo<TestUserClass>) type__		List<FlatFieldDescriptor> result = new ArrayList<FlatFieldDescriptor>()__		pType.getFlatFields("nestedClass.dumm2", 0, result)__		int[] fields = new int[1]_ _		fields[0] = result.get(0).getPosition()__		TypeComparator<TestUserClass> pojoComp = pType.createComparator( fields, new boolean[]{true}, 0, new ExecutionConfig())__		_		TestUserClass pojoTestRecord = new TestUserClass(0, "abc", 3d, new int[] {1,2,3}, new Date(), new NestedTestUserClass(1, "haha", 4d, new int[] {5,4,3}))__		int pHash = pojoComp.hash(pojoTestRecord)__		_		Tuple1<String> tupleTest = new Tuple1<String>("haha")__		TupleTypeInfo<Tuple1<String>> tType = (TupleTypeInfo<Tuple1<String>>)TypeExtractor.getForObject(tupleTest)__		TypeComparator<Tuple1<String>> tupleComp = tType.createComparator(new int[] {0}, new boolean[] {true}, 0, new ExecutionConfig())__		_		int tHash = tupleComp.hash(tupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable", pHash == tHash)__		_		Tuple3<Integer, String, Double> multiTupleTest = new Tuple3<Integer, String, Double>(1, "haha", 4d)_ _		TupleTypeInfo<Tuple3<Integer, String, Double>> multiTupleType = (TupleTypeInfo<Tuple3<Integer, String, Double>>)TypeExtractor.getForObject(multiTupleTest)__		_		ExpressionKeys fieldKey = new ExpressionKeys(new int[]{1,0,2}, multiTupleType)__		ExpressionKeys expressKey = new ExpressionKeys(new String[] {"nestedClass.dumm2", "nestedClass.dumm1", "nestedClass.dumm3"}, pType)__		try {_			Assert.assertTrue("Expecting the keys to be compatible", fieldKey.areCompatible(expressKey))__		} catch (IncompatibleKeysException e) {_			e.printStackTrace()__			Assert.fail("Keys must be compatible: "+e.getMessage())__		}_		TypeComparator<TestUserClass> multiPojoComp = pType.createComparator( expressKey.computeLogicalKeyPositions(), new boolean[]{true, true, true}, 0, new ExecutionConfig())__		int multiPojoHash = multiPojoComp.hash(pojoTestRecord)__		_		_		_		TypeComparator<Tuple3<Integer, String, Double>> multiTupleComp = multiTupleType.createComparator(fieldKey.computeLogicalKeyPositions(), new boolean[] {true, true,true}, 0, new ExecutionConfig())__		int multiTupleHash = multiTupleComp.hash(multiTupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable. Also for those with multiple key fields", multiPojoHash == multiTupleHash)__		_	};this,tests,if,the,hashes,returned,by,the,pojo,and,tuple,comparators,are,the,same;suppress,warnings,rawtypes,unchecked,test,public,void,test,tuple,pojo,test,equality,pojo,type,info,test,user,class,p,type,pojo,type,info,test,user,class,type,list,flat,field,descriptor,result,new,array,list,flat,field,descriptor,p,type,get,flat,fields,nested,class,dumm2,0,result,int,fields,new,int,1,fields,0,result,get,0,get,position,type,comparator,test,user,class,pojo,comp,p,type,create,comparator,fields,new,boolean,true,0,new,execution,config,test,user,class,pojo,test,record,new,test,user,class,0,abc,3d,new,int,1,2,3,new,date,new,nested,test,user,class,1,haha,4d,new,int,5,4,3,int,p,hash,pojo,comp,hash,pojo,test,record,tuple1,string,tuple,test,new,tuple1,string,haha,tuple,type,info,tuple1,string,t,type,tuple,type,info,tuple1,string,type,extractor,get,for,object,tuple,test,type,comparator,tuple1,string,tuple,comp,t,type,create,comparator,new,int,0,new,boolean,true,0,new,execution,config,int,t,hash,tuple,comp,hash,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,p,hash,t,hash,tuple3,integer,string,double,multi,tuple,test,new,tuple3,integer,string,double,1,haha,4d,tuple,type,info,tuple3,integer,string,double,multi,tuple,type,tuple,type,info,tuple3,integer,string,double,type,extractor,get,for,object,multi,tuple,test,expression,keys,field,key,new,expression,keys,new,int,1,0,2,multi,tuple,type,expression,keys,express,key,new,expression,keys,new,string,nested,class,dumm2,nested,class,dumm1,nested,class,dumm3,p,type,try,assert,assert,true,expecting,the,keys,to,be,compatible,field,key,are,compatible,express,key,catch,incompatible,keys,exception,e,e,print,stack,trace,assert,fail,keys,must,be,compatible,e,get,message,type,comparator,test,user,class,multi,pojo,comp,p,type,create,comparator,express,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,pojo,hash,multi,pojo,comp,hash,pojo,test,record,type,comparator,tuple3,integer,string,double,multi,tuple,comp,multi,tuple,type,create,comparator,field,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,tuple,hash,multi,tuple,comp,hash,multi,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,also,for,those,with,multiple,key,fields,multi,pojo,hash,multi,tuple,hash
PojoSerializerTest -> @SuppressWarnings({ "rawtypes", "unchecked" }) 	@Test 	public void testTuplePojoTestEquality();1525657109;This tests if the hashes returned by the pojo and tuple comparators are the same;@SuppressWarnings({ "rawtypes", "unchecked" })_	@Test_	public void testTuplePojoTestEquality() {_		_		_		PojoTypeInfo<TestUserClass> pType = (PojoTypeInfo<TestUserClass>) type__		List<FlatFieldDescriptor> result = new ArrayList<FlatFieldDescriptor>()__		pType.getFlatFields("nestedClass.dumm2", 0, result)__		int[] fields = new int[1]_ _		fields[0] = result.get(0).getPosition()__		TypeComparator<TestUserClass> pojoComp = pType.createComparator( fields, new boolean[]{true}, 0, new ExecutionConfig())__		_		TestUserClass pojoTestRecord = new TestUserClass(0, "abc", 3d, new int[] {1,2,3}, new Date(), new NestedTestUserClass(1, "haha", 4d, new int[] {5,4,3}))__		int pHash = pojoComp.hash(pojoTestRecord)__		_		Tuple1<String> tupleTest = new Tuple1<String>("haha")__		TupleTypeInfo<Tuple1<String>> tType = (TupleTypeInfo<Tuple1<String>>)TypeExtractor.getForObject(tupleTest)__		TypeComparator<Tuple1<String>> tupleComp = tType.createComparator(new int[] {0}, new boolean[] {true}, 0, new ExecutionConfig())__		_		int tHash = tupleComp.hash(tupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable", pHash == tHash)__		_		Tuple3<Integer, String, Double> multiTupleTest = new Tuple3<Integer, String, Double>(1, "haha", 4d)_ _		TupleTypeInfo<Tuple3<Integer, String, Double>> multiTupleType = (TupleTypeInfo<Tuple3<Integer, String, Double>>)TypeExtractor.getForObject(multiTupleTest)__		_		ExpressionKeys fieldKey = new ExpressionKeys(new int[]{1,0,2}, multiTupleType)__		ExpressionKeys expressKey = new ExpressionKeys(new String[] {"nestedClass.dumm2", "nestedClass.dumm1", "nestedClass.dumm3"}, pType)__		try {_			Assert.assertTrue("Expecting the keys to be compatible", fieldKey.areCompatible(expressKey))__		} catch (IncompatibleKeysException e) {_			e.printStackTrace()__			Assert.fail("Keys must be compatible: "+e.getMessage())__		}_		TypeComparator<TestUserClass> multiPojoComp = pType.createComparator( expressKey.computeLogicalKeyPositions(), new boolean[]{true, true, true}, 0, new ExecutionConfig())__		int multiPojoHash = multiPojoComp.hash(pojoTestRecord)__		_		_		_		TypeComparator<Tuple3<Integer, String, Double>> multiTupleComp = multiTupleType.createComparator(fieldKey.computeLogicalKeyPositions(), new boolean[] {true, true,true}, 0, new ExecutionConfig())__		int multiTupleHash = multiTupleComp.hash(multiTupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable. Also for those with multiple key fields", multiPojoHash == multiTupleHash)__		_	};this,tests,if,the,hashes,returned,by,the,pojo,and,tuple,comparators,are,the,same;suppress,warnings,rawtypes,unchecked,test,public,void,test,tuple,pojo,test,equality,pojo,type,info,test,user,class,p,type,pojo,type,info,test,user,class,type,list,flat,field,descriptor,result,new,array,list,flat,field,descriptor,p,type,get,flat,fields,nested,class,dumm2,0,result,int,fields,new,int,1,fields,0,result,get,0,get,position,type,comparator,test,user,class,pojo,comp,p,type,create,comparator,fields,new,boolean,true,0,new,execution,config,test,user,class,pojo,test,record,new,test,user,class,0,abc,3d,new,int,1,2,3,new,date,new,nested,test,user,class,1,haha,4d,new,int,5,4,3,int,p,hash,pojo,comp,hash,pojo,test,record,tuple1,string,tuple,test,new,tuple1,string,haha,tuple,type,info,tuple1,string,t,type,tuple,type,info,tuple1,string,type,extractor,get,for,object,tuple,test,type,comparator,tuple1,string,tuple,comp,t,type,create,comparator,new,int,0,new,boolean,true,0,new,execution,config,int,t,hash,tuple,comp,hash,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,p,hash,t,hash,tuple3,integer,string,double,multi,tuple,test,new,tuple3,integer,string,double,1,haha,4d,tuple,type,info,tuple3,integer,string,double,multi,tuple,type,tuple,type,info,tuple3,integer,string,double,type,extractor,get,for,object,multi,tuple,test,expression,keys,field,key,new,expression,keys,new,int,1,0,2,multi,tuple,type,expression,keys,express,key,new,expression,keys,new,string,nested,class,dumm2,nested,class,dumm1,nested,class,dumm3,p,type,try,assert,assert,true,expecting,the,keys,to,be,compatible,field,key,are,compatible,express,key,catch,incompatible,keys,exception,e,e,print,stack,trace,assert,fail,keys,must,be,compatible,e,get,message,type,comparator,test,user,class,multi,pojo,comp,p,type,create,comparator,express,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,pojo,hash,multi,pojo,comp,hash,pojo,test,record,type,comparator,tuple3,integer,string,double,multi,tuple,comp,multi,tuple,type,create,comparator,field,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,tuple,hash,multi,tuple,comp,hash,multi,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,also,for,those,with,multiple,key,fields,multi,pojo,hash,multi,tuple,hash
PojoSerializerTest -> @SuppressWarnings({ "rawtypes", "unchecked" }) 	@Test 	public void testTuplePojoTestEquality();1539149027;This tests if the hashes returned by the pojo and tuple comparators are the same;@SuppressWarnings({ "rawtypes", "unchecked" })_	@Test_	public void testTuplePojoTestEquality() {_		_		_		PojoTypeInfo<TestUserClass> pType = (PojoTypeInfo<TestUserClass>) type__		List<FlatFieldDescriptor> result = new ArrayList<FlatFieldDescriptor>()__		pType.getFlatFields("nestedClass.dumm2", 0, result)__		int[] fields = new int[1]_ _		fields[0] = result.get(0).getPosition()__		TypeComparator<TestUserClass> pojoComp = pType.createComparator( fields, new boolean[]{true}, 0, new ExecutionConfig())__		_		TestUserClass pojoTestRecord = new TestUserClass(0, "abc", 3d, new int[] {1,2,3}, new Date(), new NestedTestUserClass(1, "haha", 4d, new int[] {5,4,3}))__		int pHash = pojoComp.hash(pojoTestRecord)__		_		Tuple1<String> tupleTest = new Tuple1<String>("haha")__		TupleTypeInfo<Tuple1<String>> tType = (TupleTypeInfo<Tuple1<String>>)TypeExtractor.getForObject(tupleTest)__		TypeComparator<Tuple1<String>> tupleComp = tType.createComparator(new int[] {0}, new boolean[] {true}, 0, new ExecutionConfig())__		_		int tHash = tupleComp.hash(tupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable", pHash == tHash)__		_		Tuple3<Integer, String, Double> multiTupleTest = new Tuple3<Integer, String, Double>(1, "haha", 4d)_ _		TupleTypeInfo<Tuple3<Integer, String, Double>> multiTupleType = (TupleTypeInfo<Tuple3<Integer, String, Double>>)TypeExtractor.getForObject(multiTupleTest)__		_		ExpressionKeys fieldKey = new ExpressionKeys(new int[]{1,0,2}, multiTupleType)__		ExpressionKeys expressKey = new ExpressionKeys(new String[] {"nestedClass.dumm2", "nestedClass.dumm1", "nestedClass.dumm3"}, pType)__		try {_			Assert.assertTrue("Expecting the keys to be compatible", fieldKey.areCompatible(expressKey))__		} catch (IncompatibleKeysException e) {_			e.printStackTrace()__			Assert.fail("Keys must be compatible: "+e.getMessage())__		}_		TypeComparator<TestUserClass> multiPojoComp = pType.createComparator( expressKey.computeLogicalKeyPositions(), new boolean[]{true, true, true}, 0, new ExecutionConfig())__		int multiPojoHash = multiPojoComp.hash(pojoTestRecord)__		_		_		_		TypeComparator<Tuple3<Integer, String, Double>> multiTupleComp = multiTupleType.createComparator(fieldKey.computeLogicalKeyPositions(), new boolean[] {true, true,true}, 0, new ExecutionConfig())__		int multiTupleHash = multiTupleComp.hash(multiTupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable. Also for those with multiple key fields", multiPojoHash == multiTupleHash)__		_	};this,tests,if,the,hashes,returned,by,the,pojo,and,tuple,comparators,are,the,same;suppress,warnings,rawtypes,unchecked,test,public,void,test,tuple,pojo,test,equality,pojo,type,info,test,user,class,p,type,pojo,type,info,test,user,class,type,list,flat,field,descriptor,result,new,array,list,flat,field,descriptor,p,type,get,flat,fields,nested,class,dumm2,0,result,int,fields,new,int,1,fields,0,result,get,0,get,position,type,comparator,test,user,class,pojo,comp,p,type,create,comparator,fields,new,boolean,true,0,new,execution,config,test,user,class,pojo,test,record,new,test,user,class,0,abc,3d,new,int,1,2,3,new,date,new,nested,test,user,class,1,haha,4d,new,int,5,4,3,int,p,hash,pojo,comp,hash,pojo,test,record,tuple1,string,tuple,test,new,tuple1,string,haha,tuple,type,info,tuple1,string,t,type,tuple,type,info,tuple1,string,type,extractor,get,for,object,tuple,test,type,comparator,tuple1,string,tuple,comp,t,type,create,comparator,new,int,0,new,boolean,true,0,new,execution,config,int,t,hash,tuple,comp,hash,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,p,hash,t,hash,tuple3,integer,string,double,multi,tuple,test,new,tuple3,integer,string,double,1,haha,4d,tuple,type,info,tuple3,integer,string,double,multi,tuple,type,tuple,type,info,tuple3,integer,string,double,type,extractor,get,for,object,multi,tuple,test,expression,keys,field,key,new,expression,keys,new,int,1,0,2,multi,tuple,type,expression,keys,express,key,new,expression,keys,new,string,nested,class,dumm2,nested,class,dumm1,nested,class,dumm3,p,type,try,assert,assert,true,expecting,the,keys,to,be,compatible,field,key,are,compatible,express,key,catch,incompatible,keys,exception,e,e,print,stack,trace,assert,fail,keys,must,be,compatible,e,get,message,type,comparator,test,user,class,multi,pojo,comp,p,type,create,comparator,express,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,pojo,hash,multi,pojo,comp,hash,pojo,test,record,type,comparator,tuple3,integer,string,double,multi,tuple,comp,multi,tuple,type,create,comparator,field,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,tuple,hash,multi,tuple,comp,hash,multi,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,also,for,those,with,multiple,key,fields,multi,pojo,hash,multi,tuple,hash
PojoSerializerTest -> @SuppressWarnings({ "rawtypes", "unchecked" }) 	@Test 	public void testTuplePojoTestEquality();1539149040;This tests if the hashes returned by the pojo and tuple comparators are the same;@SuppressWarnings({ "rawtypes", "unchecked" })_	@Test_	public void testTuplePojoTestEquality() {_		_		_		PojoTypeInfo<TestUserClass> pType = (PojoTypeInfo<TestUserClass>) type__		List<FlatFieldDescriptor> result = new ArrayList<FlatFieldDescriptor>()__		pType.getFlatFields("nestedClass.dumm2", 0, result)__		int[] fields = new int[1]_ _		fields[0] = result.get(0).getPosition()__		TypeComparator<TestUserClass> pojoComp = pType.createComparator( fields, new boolean[]{true}, 0, new ExecutionConfig())__		_		TestUserClass pojoTestRecord = new TestUserClass(0, "abc", 3d, new int[] {1,2,3}, new Date(), new NestedTestUserClass(1, "haha", 4d, new int[] {5,4,3}))__		int pHash = pojoComp.hash(pojoTestRecord)__		_		Tuple1<String> tupleTest = new Tuple1<String>("haha")__		TupleTypeInfo<Tuple1<String>> tType = (TupleTypeInfo<Tuple1<String>>)TypeExtractor.getForObject(tupleTest)__		TypeComparator<Tuple1<String>> tupleComp = tType.createComparator(new int[] {0}, new boolean[] {true}, 0, new ExecutionConfig())__		_		int tHash = tupleComp.hash(tupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable", pHash == tHash)__		_		Tuple3<Integer, String, Double> multiTupleTest = new Tuple3<Integer, String, Double>(1, "haha", 4d)_ _		TupleTypeInfo<Tuple3<Integer, String, Double>> multiTupleType = (TupleTypeInfo<Tuple3<Integer, String, Double>>)TypeExtractor.getForObject(multiTupleTest)__		_		ExpressionKeys fieldKey = new ExpressionKeys(new int[]{1,0,2}, multiTupleType)__		ExpressionKeys expressKey = new ExpressionKeys(new String[] {"nestedClass.dumm2", "nestedClass.dumm1", "nestedClass.dumm3"}, pType)__		try {_			Assert.assertTrue("Expecting the keys to be compatible", fieldKey.areCompatible(expressKey))__		} catch (IncompatibleKeysException e) {_			e.printStackTrace()__			Assert.fail("Keys must be compatible: "+e.getMessage())__		}_		TypeComparator<TestUserClass> multiPojoComp = pType.createComparator( expressKey.computeLogicalKeyPositions(), new boolean[]{true, true, true}, 0, new ExecutionConfig())__		int multiPojoHash = multiPojoComp.hash(pojoTestRecord)__		_		_		_		TypeComparator<Tuple3<Integer, String, Double>> multiTupleComp = multiTupleType.createComparator(fieldKey.computeLogicalKeyPositions(), new boolean[] {true, true,true}, 0, new ExecutionConfig())__		int multiTupleHash = multiTupleComp.hash(multiTupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable. Also for those with multiple key fields", multiPojoHash == multiTupleHash)__		_	};this,tests,if,the,hashes,returned,by,the,pojo,and,tuple,comparators,are,the,same;suppress,warnings,rawtypes,unchecked,test,public,void,test,tuple,pojo,test,equality,pojo,type,info,test,user,class,p,type,pojo,type,info,test,user,class,type,list,flat,field,descriptor,result,new,array,list,flat,field,descriptor,p,type,get,flat,fields,nested,class,dumm2,0,result,int,fields,new,int,1,fields,0,result,get,0,get,position,type,comparator,test,user,class,pojo,comp,p,type,create,comparator,fields,new,boolean,true,0,new,execution,config,test,user,class,pojo,test,record,new,test,user,class,0,abc,3d,new,int,1,2,3,new,date,new,nested,test,user,class,1,haha,4d,new,int,5,4,3,int,p,hash,pojo,comp,hash,pojo,test,record,tuple1,string,tuple,test,new,tuple1,string,haha,tuple,type,info,tuple1,string,t,type,tuple,type,info,tuple1,string,type,extractor,get,for,object,tuple,test,type,comparator,tuple1,string,tuple,comp,t,type,create,comparator,new,int,0,new,boolean,true,0,new,execution,config,int,t,hash,tuple,comp,hash,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,p,hash,t,hash,tuple3,integer,string,double,multi,tuple,test,new,tuple3,integer,string,double,1,haha,4d,tuple,type,info,tuple3,integer,string,double,multi,tuple,type,tuple,type,info,tuple3,integer,string,double,type,extractor,get,for,object,multi,tuple,test,expression,keys,field,key,new,expression,keys,new,int,1,0,2,multi,tuple,type,expression,keys,express,key,new,expression,keys,new,string,nested,class,dumm2,nested,class,dumm1,nested,class,dumm3,p,type,try,assert,assert,true,expecting,the,keys,to,be,compatible,field,key,are,compatible,express,key,catch,incompatible,keys,exception,e,e,print,stack,trace,assert,fail,keys,must,be,compatible,e,get,message,type,comparator,test,user,class,multi,pojo,comp,p,type,create,comparator,express,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,pojo,hash,multi,pojo,comp,hash,pojo,test,record,type,comparator,tuple3,integer,string,double,multi,tuple,comp,multi,tuple,type,create,comparator,field,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,tuple,hash,multi,tuple,comp,hash,multi,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,also,for,those,with,multiple,key,fields,multi,pojo,hash,multi,tuple,hash
PojoSerializerTest -> @SuppressWarnings({ "rawtypes", "unchecked" }) 	@Test 	public void testTuplePojoTestEquality();1539149114;This tests if the hashes returned by the pojo and tuple comparators are the same;@SuppressWarnings({ "rawtypes", "unchecked" })_	@Test_	public void testTuplePojoTestEquality() {_		_		_		PojoTypeInfo<TestUserClass> pType = (PojoTypeInfo<TestUserClass>) type__		List<FlatFieldDescriptor> result = new ArrayList<FlatFieldDescriptor>()__		pType.getFlatFields("nestedClass.dumm2", 0, result)__		int[] fields = new int[1]_ _		fields[0] = result.get(0).getPosition()__		TypeComparator<TestUserClass> pojoComp = pType.createComparator( fields, new boolean[]{true}, 0, new ExecutionConfig())__		_		TestUserClass pojoTestRecord = new TestUserClass(0, "abc", 3d, new int[] {1,2,3}, new Date(), new NestedTestUserClass(1, "haha", 4d, new int[] {5,4,3}))__		int pHash = pojoComp.hash(pojoTestRecord)__		_		Tuple1<String> tupleTest = new Tuple1<String>("haha")__		TupleTypeInfo<Tuple1<String>> tType = (TupleTypeInfo<Tuple1<String>>)TypeExtractor.getForObject(tupleTest)__		TypeComparator<Tuple1<String>> tupleComp = tType.createComparator(new int[] {0}, new boolean[] {true}, 0, new ExecutionConfig())__		_		int tHash = tupleComp.hash(tupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable", pHash == tHash)__		_		Tuple3<Integer, String, Double> multiTupleTest = new Tuple3<Integer, String, Double>(1, "haha", 4d)_ _		TupleTypeInfo<Tuple3<Integer, String, Double>> multiTupleType = (TupleTypeInfo<Tuple3<Integer, String, Double>>)TypeExtractor.getForObject(multiTupleTest)__		_		ExpressionKeys fieldKey = new ExpressionKeys(new int[]{1,0,2}, multiTupleType)__		ExpressionKeys expressKey = new ExpressionKeys(new String[] {"nestedClass.dumm2", "nestedClass.dumm1", "nestedClass.dumm3"}, pType)__		try {_			Assert.assertTrue("Expecting the keys to be compatible", fieldKey.areCompatible(expressKey))__		} catch (IncompatibleKeysException e) {_			e.printStackTrace()__			Assert.fail("Keys must be compatible: "+e.getMessage())__		}_		TypeComparator<TestUserClass> multiPojoComp = pType.createComparator( expressKey.computeLogicalKeyPositions(), new boolean[]{true, true, true}, 0, new ExecutionConfig())__		int multiPojoHash = multiPojoComp.hash(pojoTestRecord)__		_		_		_		TypeComparator<Tuple3<Integer, String, Double>> multiTupleComp = multiTupleType.createComparator(fieldKey.computeLogicalKeyPositions(), new boolean[] {true, true,true}, 0, new ExecutionConfig())__		int multiTupleHash = multiTupleComp.hash(multiTupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable. Also for those with multiple key fields", multiPojoHash == multiTupleHash)__		_	};this,tests,if,the,hashes,returned,by,the,pojo,and,tuple,comparators,are,the,same;suppress,warnings,rawtypes,unchecked,test,public,void,test,tuple,pojo,test,equality,pojo,type,info,test,user,class,p,type,pojo,type,info,test,user,class,type,list,flat,field,descriptor,result,new,array,list,flat,field,descriptor,p,type,get,flat,fields,nested,class,dumm2,0,result,int,fields,new,int,1,fields,0,result,get,0,get,position,type,comparator,test,user,class,pojo,comp,p,type,create,comparator,fields,new,boolean,true,0,new,execution,config,test,user,class,pojo,test,record,new,test,user,class,0,abc,3d,new,int,1,2,3,new,date,new,nested,test,user,class,1,haha,4d,new,int,5,4,3,int,p,hash,pojo,comp,hash,pojo,test,record,tuple1,string,tuple,test,new,tuple1,string,haha,tuple,type,info,tuple1,string,t,type,tuple,type,info,tuple1,string,type,extractor,get,for,object,tuple,test,type,comparator,tuple1,string,tuple,comp,t,type,create,comparator,new,int,0,new,boolean,true,0,new,execution,config,int,t,hash,tuple,comp,hash,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,p,hash,t,hash,tuple3,integer,string,double,multi,tuple,test,new,tuple3,integer,string,double,1,haha,4d,tuple,type,info,tuple3,integer,string,double,multi,tuple,type,tuple,type,info,tuple3,integer,string,double,type,extractor,get,for,object,multi,tuple,test,expression,keys,field,key,new,expression,keys,new,int,1,0,2,multi,tuple,type,expression,keys,express,key,new,expression,keys,new,string,nested,class,dumm2,nested,class,dumm1,nested,class,dumm3,p,type,try,assert,assert,true,expecting,the,keys,to,be,compatible,field,key,are,compatible,express,key,catch,incompatible,keys,exception,e,e,print,stack,trace,assert,fail,keys,must,be,compatible,e,get,message,type,comparator,test,user,class,multi,pojo,comp,p,type,create,comparator,express,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,pojo,hash,multi,pojo,comp,hash,pojo,test,record,type,comparator,tuple3,integer,string,double,multi,tuple,comp,multi,tuple,type,create,comparator,field,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,tuple,hash,multi,tuple,comp,hash,multi,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,also,for,those,with,multiple,key,fields,multi,pojo,hash,multi,tuple,hash
PojoSerializerTest -> @SuppressWarnings({ "rawtypes", "unchecked" }) 	@Test 	public void testTuplePojoTestEquality();1540907751;This tests if the hashes returned by the pojo and tuple comparators are the same;@SuppressWarnings({ "rawtypes", "unchecked" })_	@Test_	public void testTuplePojoTestEquality() {_		_		_		PojoTypeInfo<TestUserClass> pType = (PojoTypeInfo<TestUserClass>) type__		List<FlatFieldDescriptor> result = new ArrayList<FlatFieldDescriptor>()__		pType.getFlatFields("nestedClass.dumm2", 0, result)__		int[] fields = new int[1]_ _		fields[0] = result.get(0).getPosition()__		TypeComparator<TestUserClass> pojoComp = pType.createComparator( fields, new boolean[]{true}, 0, new ExecutionConfig())__		_		TestUserClass pojoTestRecord = new TestUserClass(0, "abc", 3d, new int[] {1,2,3}, new Date(), new NestedTestUserClass(1, "haha", 4d, new int[] {5,4,3}))__		int pHash = pojoComp.hash(pojoTestRecord)__		_		Tuple1<String> tupleTest = new Tuple1<String>("haha")__		TupleTypeInfo<Tuple1<String>> tType = (TupleTypeInfo<Tuple1<String>>)TypeExtractor.getForObject(tupleTest)__		TypeComparator<Tuple1<String>> tupleComp = tType.createComparator(new int[] {0}, new boolean[] {true}, 0, new ExecutionConfig())__		_		int tHash = tupleComp.hash(tupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable", pHash == tHash)__		_		Tuple3<Integer, String, Double> multiTupleTest = new Tuple3<Integer, String, Double>(1, "haha", 4d)_ _		TupleTypeInfo<Tuple3<Integer, String, Double>> multiTupleType = (TupleTypeInfo<Tuple3<Integer, String, Double>>)TypeExtractor.getForObject(multiTupleTest)__		_		ExpressionKeys fieldKey = new ExpressionKeys(new int[]{1,0,2}, multiTupleType)__		ExpressionKeys expressKey = new ExpressionKeys(new String[] {"nestedClass.dumm2", "nestedClass.dumm1", "nestedClass.dumm3"}, pType)__		try {_			Assert.assertTrue("Expecting the keys to be compatible", fieldKey.areCompatible(expressKey))__		} catch (IncompatibleKeysException e) {_			e.printStackTrace()__			Assert.fail("Keys must be compatible: "+e.getMessage())__		}_		TypeComparator<TestUserClass> multiPojoComp = pType.createComparator( expressKey.computeLogicalKeyPositions(), new boolean[]{true, true, true}, 0, new ExecutionConfig())__		int multiPojoHash = multiPojoComp.hash(pojoTestRecord)__		_		_		_		TypeComparator<Tuple3<Integer, String, Double>> multiTupleComp = multiTupleType.createComparator(fieldKey.computeLogicalKeyPositions(), new boolean[] {true, true,true}, 0, new ExecutionConfig())__		int multiTupleHash = multiTupleComp.hash(multiTupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable. Also for those with multiple key fields", multiPojoHash == multiTupleHash)__		_	};this,tests,if,the,hashes,returned,by,the,pojo,and,tuple,comparators,are,the,same;suppress,warnings,rawtypes,unchecked,test,public,void,test,tuple,pojo,test,equality,pojo,type,info,test,user,class,p,type,pojo,type,info,test,user,class,type,list,flat,field,descriptor,result,new,array,list,flat,field,descriptor,p,type,get,flat,fields,nested,class,dumm2,0,result,int,fields,new,int,1,fields,0,result,get,0,get,position,type,comparator,test,user,class,pojo,comp,p,type,create,comparator,fields,new,boolean,true,0,new,execution,config,test,user,class,pojo,test,record,new,test,user,class,0,abc,3d,new,int,1,2,3,new,date,new,nested,test,user,class,1,haha,4d,new,int,5,4,3,int,p,hash,pojo,comp,hash,pojo,test,record,tuple1,string,tuple,test,new,tuple1,string,haha,tuple,type,info,tuple1,string,t,type,tuple,type,info,tuple1,string,type,extractor,get,for,object,tuple,test,type,comparator,tuple1,string,tuple,comp,t,type,create,comparator,new,int,0,new,boolean,true,0,new,execution,config,int,t,hash,tuple,comp,hash,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,p,hash,t,hash,tuple3,integer,string,double,multi,tuple,test,new,tuple3,integer,string,double,1,haha,4d,tuple,type,info,tuple3,integer,string,double,multi,tuple,type,tuple,type,info,tuple3,integer,string,double,type,extractor,get,for,object,multi,tuple,test,expression,keys,field,key,new,expression,keys,new,int,1,0,2,multi,tuple,type,expression,keys,express,key,new,expression,keys,new,string,nested,class,dumm2,nested,class,dumm1,nested,class,dumm3,p,type,try,assert,assert,true,expecting,the,keys,to,be,compatible,field,key,are,compatible,express,key,catch,incompatible,keys,exception,e,e,print,stack,trace,assert,fail,keys,must,be,compatible,e,get,message,type,comparator,test,user,class,multi,pojo,comp,p,type,create,comparator,express,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,pojo,hash,multi,pojo,comp,hash,pojo,test,record,type,comparator,tuple3,integer,string,double,multi,tuple,comp,multi,tuple,type,create,comparator,field,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,tuple,hash,multi,tuple,comp,hash,multi,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,also,for,those,with,multiple,key,fields,multi,pojo,hash,multi,tuple,hash
PojoSerializerTest -> @SuppressWarnings({ "rawtypes", "unchecked" }) 	@Test 	public void testTuplePojoTestEquality();1540907751;This tests if the hashes returned by the pojo and tuple comparators are the same;@SuppressWarnings({ "rawtypes", "unchecked" })_	@Test_	public void testTuplePojoTestEquality() {_		_		_		PojoTypeInfo<TestUserClass> pType = (PojoTypeInfo<TestUserClass>) type__		List<FlatFieldDescriptor> result = new ArrayList<FlatFieldDescriptor>()__		pType.getFlatFields("nestedClass.dumm2", 0, result)__		int[] fields = new int[1]_ _		fields[0] = result.get(0).getPosition()__		TypeComparator<TestUserClass> pojoComp = pType.createComparator( fields, new boolean[]{true}, 0, new ExecutionConfig())__		_		TestUserClass pojoTestRecord = new TestUserClass(0, "abc", 3d, new int[] {1,2,3}, new Date(), new NestedTestUserClass(1, "haha", 4d, new int[] {5,4,3}))__		int pHash = pojoComp.hash(pojoTestRecord)__		_		Tuple1<String> tupleTest = new Tuple1<String>("haha")__		TupleTypeInfo<Tuple1<String>> tType = (TupleTypeInfo<Tuple1<String>>)TypeExtractor.getForObject(tupleTest)__		TypeComparator<Tuple1<String>> tupleComp = tType.createComparator(new int[] {0}, new boolean[] {true}, 0, new ExecutionConfig())__		_		int tHash = tupleComp.hash(tupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable", pHash == tHash)__		_		Tuple3<Integer, String, Double> multiTupleTest = new Tuple3<Integer, String, Double>(1, "haha", 4d)_ _		TupleTypeInfo<Tuple3<Integer, String, Double>> multiTupleType = (TupleTypeInfo<Tuple3<Integer, String, Double>>)TypeExtractor.getForObject(multiTupleTest)__		_		ExpressionKeys fieldKey = new ExpressionKeys(new int[]{1,0,2}, multiTupleType)__		ExpressionKeys expressKey = new ExpressionKeys(new String[] {"nestedClass.dumm2", "nestedClass.dumm1", "nestedClass.dumm3"}, pType)__		try {_			Assert.assertTrue("Expecting the keys to be compatible", fieldKey.areCompatible(expressKey))__		} catch (IncompatibleKeysException e) {_			e.printStackTrace()__			Assert.fail("Keys must be compatible: "+e.getMessage())__		}_		TypeComparator<TestUserClass> multiPojoComp = pType.createComparator( expressKey.computeLogicalKeyPositions(), new boolean[]{true, true, true}, 0, new ExecutionConfig())__		int multiPojoHash = multiPojoComp.hash(pojoTestRecord)__		_		_		_		TypeComparator<Tuple3<Integer, String, Double>> multiTupleComp = multiTupleType.createComparator(fieldKey.computeLogicalKeyPositions(), new boolean[] {true, true,true}, 0, new ExecutionConfig())__		int multiTupleHash = multiTupleComp.hash(multiTupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable. Also for those with multiple key fields", multiPojoHash == multiTupleHash)__		_	};this,tests,if,the,hashes,returned,by,the,pojo,and,tuple,comparators,are,the,same;suppress,warnings,rawtypes,unchecked,test,public,void,test,tuple,pojo,test,equality,pojo,type,info,test,user,class,p,type,pojo,type,info,test,user,class,type,list,flat,field,descriptor,result,new,array,list,flat,field,descriptor,p,type,get,flat,fields,nested,class,dumm2,0,result,int,fields,new,int,1,fields,0,result,get,0,get,position,type,comparator,test,user,class,pojo,comp,p,type,create,comparator,fields,new,boolean,true,0,new,execution,config,test,user,class,pojo,test,record,new,test,user,class,0,abc,3d,new,int,1,2,3,new,date,new,nested,test,user,class,1,haha,4d,new,int,5,4,3,int,p,hash,pojo,comp,hash,pojo,test,record,tuple1,string,tuple,test,new,tuple1,string,haha,tuple,type,info,tuple1,string,t,type,tuple,type,info,tuple1,string,type,extractor,get,for,object,tuple,test,type,comparator,tuple1,string,tuple,comp,t,type,create,comparator,new,int,0,new,boolean,true,0,new,execution,config,int,t,hash,tuple,comp,hash,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,p,hash,t,hash,tuple3,integer,string,double,multi,tuple,test,new,tuple3,integer,string,double,1,haha,4d,tuple,type,info,tuple3,integer,string,double,multi,tuple,type,tuple,type,info,tuple3,integer,string,double,type,extractor,get,for,object,multi,tuple,test,expression,keys,field,key,new,expression,keys,new,int,1,0,2,multi,tuple,type,expression,keys,express,key,new,expression,keys,new,string,nested,class,dumm2,nested,class,dumm1,nested,class,dumm3,p,type,try,assert,assert,true,expecting,the,keys,to,be,compatible,field,key,are,compatible,express,key,catch,incompatible,keys,exception,e,e,print,stack,trace,assert,fail,keys,must,be,compatible,e,get,message,type,comparator,test,user,class,multi,pojo,comp,p,type,create,comparator,express,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,pojo,hash,multi,pojo,comp,hash,pojo,test,record,type,comparator,tuple3,integer,string,double,multi,tuple,comp,multi,tuple,type,create,comparator,field,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,tuple,hash,multi,tuple,comp,hash,multi,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,also,for,those,with,multiple,key,fields,multi,pojo,hash,multi,tuple,hash
PojoSerializerTest -> @SuppressWarnings({ "rawtypes", "unchecked" }) 	@Test 	public void testTuplePojoTestEquality();1540907751;This tests if the hashes returned by the pojo and tuple comparators are the same;@SuppressWarnings({ "rawtypes", "unchecked" })_	@Test_	public void testTuplePojoTestEquality() {_		_		_		PojoTypeInfo<TestUserClass> pType = (PojoTypeInfo<TestUserClass>) type__		List<FlatFieldDescriptor> result = new ArrayList<FlatFieldDescriptor>()__		pType.getFlatFields("nestedClass.dumm2", 0, result)__		int[] fields = new int[1]_ _		fields[0] = result.get(0).getPosition()__		TypeComparator<TestUserClass> pojoComp = pType.createComparator( fields, new boolean[]{true}, 0, new ExecutionConfig())__		_		TestUserClass pojoTestRecord = new TestUserClass(0, "abc", 3d, new int[] {1,2,3}, new Date(), new NestedTestUserClass(1, "haha", 4d, new int[] {5,4,3}))__		int pHash = pojoComp.hash(pojoTestRecord)__		_		Tuple1<String> tupleTest = new Tuple1<String>("haha")__		TupleTypeInfo<Tuple1<String>> tType = (TupleTypeInfo<Tuple1<String>>)TypeExtractor.getForObject(tupleTest)__		TypeComparator<Tuple1<String>> tupleComp = tType.createComparator(new int[] {0}, new boolean[] {true}, 0, new ExecutionConfig())__		_		int tHash = tupleComp.hash(tupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable", pHash == tHash)__		_		Tuple3<Integer, String, Double> multiTupleTest = new Tuple3<Integer, String, Double>(1, "haha", 4d)_ _		TupleTypeInfo<Tuple3<Integer, String, Double>> multiTupleType = (TupleTypeInfo<Tuple3<Integer, String, Double>>)TypeExtractor.getForObject(multiTupleTest)__		_		ExpressionKeys fieldKey = new ExpressionKeys(new int[]{1,0,2}, multiTupleType)__		ExpressionKeys expressKey = new ExpressionKeys(new String[] {"nestedClass.dumm2", "nestedClass.dumm1", "nestedClass.dumm3"}, pType)__		try {_			Assert.assertTrue("Expecting the keys to be compatible", fieldKey.areCompatible(expressKey))__		} catch (IncompatibleKeysException e) {_			e.printStackTrace()__			Assert.fail("Keys must be compatible: "+e.getMessage())__		}_		TypeComparator<TestUserClass> multiPojoComp = pType.createComparator( expressKey.computeLogicalKeyPositions(), new boolean[]{true, true, true}, 0, new ExecutionConfig())__		int multiPojoHash = multiPojoComp.hash(pojoTestRecord)__		_		_		_		TypeComparator<Tuple3<Integer, String, Double>> multiTupleComp = multiTupleType.createComparator(fieldKey.computeLogicalKeyPositions(), new boolean[] {true, true,true}, 0, new ExecutionConfig())__		int multiTupleHash = multiTupleComp.hash(multiTupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable. Also for those with multiple key fields", multiPojoHash == multiTupleHash)__		_	};this,tests,if,the,hashes,returned,by,the,pojo,and,tuple,comparators,are,the,same;suppress,warnings,rawtypes,unchecked,test,public,void,test,tuple,pojo,test,equality,pojo,type,info,test,user,class,p,type,pojo,type,info,test,user,class,type,list,flat,field,descriptor,result,new,array,list,flat,field,descriptor,p,type,get,flat,fields,nested,class,dumm2,0,result,int,fields,new,int,1,fields,0,result,get,0,get,position,type,comparator,test,user,class,pojo,comp,p,type,create,comparator,fields,new,boolean,true,0,new,execution,config,test,user,class,pojo,test,record,new,test,user,class,0,abc,3d,new,int,1,2,3,new,date,new,nested,test,user,class,1,haha,4d,new,int,5,4,3,int,p,hash,pojo,comp,hash,pojo,test,record,tuple1,string,tuple,test,new,tuple1,string,haha,tuple,type,info,tuple1,string,t,type,tuple,type,info,tuple1,string,type,extractor,get,for,object,tuple,test,type,comparator,tuple1,string,tuple,comp,t,type,create,comparator,new,int,0,new,boolean,true,0,new,execution,config,int,t,hash,tuple,comp,hash,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,p,hash,t,hash,tuple3,integer,string,double,multi,tuple,test,new,tuple3,integer,string,double,1,haha,4d,tuple,type,info,tuple3,integer,string,double,multi,tuple,type,tuple,type,info,tuple3,integer,string,double,type,extractor,get,for,object,multi,tuple,test,expression,keys,field,key,new,expression,keys,new,int,1,0,2,multi,tuple,type,expression,keys,express,key,new,expression,keys,new,string,nested,class,dumm2,nested,class,dumm1,nested,class,dumm3,p,type,try,assert,assert,true,expecting,the,keys,to,be,compatible,field,key,are,compatible,express,key,catch,incompatible,keys,exception,e,e,print,stack,trace,assert,fail,keys,must,be,compatible,e,get,message,type,comparator,test,user,class,multi,pojo,comp,p,type,create,comparator,express,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,pojo,hash,multi,pojo,comp,hash,pojo,test,record,type,comparator,tuple3,integer,string,double,multi,tuple,comp,multi,tuple,type,create,comparator,field,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,tuple,hash,multi,tuple,comp,hash,multi,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,also,for,those,with,multiple,key,fields,multi,pojo,hash,multi,tuple,hash
PojoSerializerTest -> @SuppressWarnings({ "rawtypes", "unchecked" }) 	@Test 	public void testTuplePojoTestEquality();1550821417;This tests if the hashes returned by the pojo and tuple comparators are the same;@SuppressWarnings({ "rawtypes", "unchecked" })_	@Test_	public void testTuplePojoTestEquality() {_		_		_		PojoTypeInfo<TestUserClass> pType = (PojoTypeInfo<TestUserClass>) type__		List<FlatFieldDescriptor> result = new ArrayList<FlatFieldDescriptor>()__		pType.getFlatFields("nestedClass.dumm2", 0, result)__		int[] fields = new int[1]_ _		fields[0] = result.get(0).getPosition()__		TypeComparator<TestUserClass> pojoComp = pType.createComparator( fields, new boolean[]{true}, 0, new ExecutionConfig())__		_		TestUserClass pojoTestRecord = new TestUserClass(0, "abc", 3d, new int[] {1,2,3}, new Date(), new NestedTestUserClass(1, "haha", 4d, new int[] {5,4,3}))__		int pHash = pojoComp.hash(pojoTestRecord)__		_		Tuple1<String> tupleTest = new Tuple1<String>("haha")__		TupleTypeInfo<Tuple1<String>> tType = (TupleTypeInfo<Tuple1<String>>)TypeExtractor.getForObject(tupleTest)__		TypeComparator<Tuple1<String>> tupleComp = tType.createComparator(new int[] {0}, new boolean[] {true}, 0, new ExecutionConfig())__		_		int tHash = tupleComp.hash(tupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable", pHash == tHash)__		_		Tuple3<Integer, String, Double> multiTupleTest = new Tuple3<Integer, String, Double>(1, "haha", 4d)_ _		TupleTypeInfo<Tuple3<Integer, String, Double>> multiTupleType = (TupleTypeInfo<Tuple3<Integer, String, Double>>)TypeExtractor.getForObject(multiTupleTest)__		_		ExpressionKeys fieldKey = new ExpressionKeys(new int[]{1,0,2}, multiTupleType)__		ExpressionKeys expressKey = new ExpressionKeys(new String[] {"nestedClass.dumm2", "nestedClass.dumm1", "nestedClass.dumm3"}, pType)__		try {_			Assert.assertTrue("Expecting the keys to be compatible", fieldKey.areCompatible(expressKey))__		} catch (IncompatibleKeysException e) {_			e.printStackTrace()__			Assert.fail("Keys must be compatible: "+e.getMessage())__		}_		TypeComparator<TestUserClass> multiPojoComp = pType.createComparator( expressKey.computeLogicalKeyPositions(), new boolean[]{true, true, true}, 0, new ExecutionConfig())__		int multiPojoHash = multiPojoComp.hash(pojoTestRecord)__		_		_		_		TypeComparator<Tuple3<Integer, String, Double>> multiTupleComp = multiTupleType.createComparator(fieldKey.computeLogicalKeyPositions(), new boolean[] {true, true,true}, 0, new ExecutionConfig())__		int multiTupleHash = multiTupleComp.hash(multiTupleTest)__		_		Assert.assertTrue("The hashing for tuples and pojos must be the same, so that they are mixable. Also for those with multiple key fields", multiPojoHash == multiTupleHash)__		_	};this,tests,if,the,hashes,returned,by,the,pojo,and,tuple,comparators,are,the,same;suppress,warnings,rawtypes,unchecked,test,public,void,test,tuple,pojo,test,equality,pojo,type,info,test,user,class,p,type,pojo,type,info,test,user,class,type,list,flat,field,descriptor,result,new,array,list,flat,field,descriptor,p,type,get,flat,fields,nested,class,dumm2,0,result,int,fields,new,int,1,fields,0,result,get,0,get,position,type,comparator,test,user,class,pojo,comp,p,type,create,comparator,fields,new,boolean,true,0,new,execution,config,test,user,class,pojo,test,record,new,test,user,class,0,abc,3d,new,int,1,2,3,new,date,new,nested,test,user,class,1,haha,4d,new,int,5,4,3,int,p,hash,pojo,comp,hash,pojo,test,record,tuple1,string,tuple,test,new,tuple1,string,haha,tuple,type,info,tuple1,string,t,type,tuple,type,info,tuple1,string,type,extractor,get,for,object,tuple,test,type,comparator,tuple1,string,tuple,comp,t,type,create,comparator,new,int,0,new,boolean,true,0,new,execution,config,int,t,hash,tuple,comp,hash,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,p,hash,t,hash,tuple3,integer,string,double,multi,tuple,test,new,tuple3,integer,string,double,1,haha,4d,tuple,type,info,tuple3,integer,string,double,multi,tuple,type,tuple,type,info,tuple3,integer,string,double,type,extractor,get,for,object,multi,tuple,test,expression,keys,field,key,new,expression,keys,new,int,1,0,2,multi,tuple,type,expression,keys,express,key,new,expression,keys,new,string,nested,class,dumm2,nested,class,dumm1,nested,class,dumm3,p,type,try,assert,assert,true,expecting,the,keys,to,be,compatible,field,key,are,compatible,express,key,catch,incompatible,keys,exception,e,e,print,stack,trace,assert,fail,keys,must,be,compatible,e,get,message,type,comparator,test,user,class,multi,pojo,comp,p,type,create,comparator,express,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,pojo,hash,multi,pojo,comp,hash,pojo,test,record,type,comparator,tuple3,integer,string,double,multi,tuple,comp,multi,tuple,type,create,comparator,field,key,compute,logical,key,positions,new,boolean,true,true,true,0,new,execution,config,int,multi,tuple,hash,multi,tuple,comp,hash,multi,tuple,test,assert,assert,true,the,hashing,for,tuples,and,pojos,must,be,the,same,so,that,they,are,mixable,also,for,those,with,multiple,key,fields,multi,pojo,hash,multi,tuple,hash
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentPojoType() throws Exception;1494180263;Verifies that reconfiguring with a config snapshot of a preceding POJO serializer_with different POJO type will result in INCOMPATIBLE.;@Test_	public void testReconfigureWithDifferentPojoType() throws Exception {_		PojoSerializer<SubTestUserClassB> pojoSerializer1 = (PojoSerializer<SubTestUserClassB>)_			TypeExtractor.getForClass(SubTestUserClassB.class).createSerializer(new ExecutionConfig())___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer1.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		PojoSerializer<SubTestUserClassA> pojoSerializer2 = (PojoSerializer<SubTestUserClassA>)_			TypeExtractor.getForClass(SubTestUserClassA.class).createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		CompatibilityResult<SubTestUserClassA> compatResult = pojoSerializer2.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertTrue(compatResult.requiresMigration())__	};verifies,that,reconfiguring,with,a,config,snapshot,of,a,preceding,pojo,serializer,with,different,pojo,type,will,result,in,incompatible;test,public,void,test,reconfigure,with,different,pojo,type,throws,exception,pojo,serializer,sub,test,user,class,b,pojo,serializer1,pojo,serializer,sub,test,user,class,b,type,extractor,get,for,class,sub,test,user,class,b,class,create,serializer,new,execution,config,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer1,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,pojo,serializer,sub,test,user,class,a,pojo,serializer2,pojo,serializer,sub,test,user,class,a,type,extractor,get,for,class,sub,test,user,class,a,class,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,sub,test,user,class,a,compat,result,pojo,serializer2,ensure,compatibility,pojo,serializer,config,snapshot,assert,true,compat,result,requires,migration
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentPojoType() throws Exception;1494658833;Verifies that reconfiguring with a config snapshot of a preceding POJO serializer_with different POJO type will result in INCOMPATIBLE.;@Test_	public void testReconfigureWithDifferentPojoType() throws Exception {_		PojoSerializer<SubTestUserClassB> pojoSerializer1 = (PojoSerializer<SubTestUserClassB>)_			TypeExtractor.getForClass(SubTestUserClassB.class).createSerializer(new ExecutionConfig())___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer1.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		PojoSerializer<SubTestUserClassA> pojoSerializer2 = (PojoSerializer<SubTestUserClassA>)_			TypeExtractor.getForClass(SubTestUserClassA.class).createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		CompatibilityResult<SubTestUserClassA> compatResult = pojoSerializer2.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertTrue(compatResult.isRequiresMigration())__	};verifies,that,reconfiguring,with,a,config,snapshot,of,a,preceding,pojo,serializer,with,different,pojo,type,will,result,in,incompatible;test,public,void,test,reconfigure,with,different,pojo,type,throws,exception,pojo,serializer,sub,test,user,class,b,pojo,serializer1,pojo,serializer,sub,test,user,class,b,type,extractor,get,for,class,sub,test,user,class,b,class,create,serializer,new,execution,config,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer1,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,pojo,serializer,sub,test,user,class,a,pojo,serializer2,pojo,serializer,sub,test,user,class,a,type,extractor,get,for,class,sub,test,user,class,a,class,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,sub,test,user,class,a,compat,result,pojo,serializer2,ensure,compatibility,pojo,serializer,config,snapshot,assert,true,compat,result,is,requires,migration
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentPojoType() throws Exception;1495466666;Verifies that reconfiguring with a config snapshot of a preceding POJO serializer_with different POJO type will result in INCOMPATIBLE.;@Test_	public void testReconfigureWithDifferentPojoType() throws Exception {_		PojoSerializer<SubTestUserClassB> pojoSerializer1 = (PojoSerializer<SubTestUserClassB>)_			TypeExtractor.getForClass(SubTestUserClassB.class).createSerializer(new ExecutionConfig())___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer1.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		PojoSerializer<SubTestUserClassA> pojoSerializer2 = (PojoSerializer<SubTestUserClassA>)_			TypeExtractor.getForClass(SubTestUserClassA.class).createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		CompatibilityResult<SubTestUserClassA> compatResult = pojoSerializer2.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertTrue(compatResult.isRequiresMigration())__	};verifies,that,reconfiguring,with,a,config,snapshot,of,a,preceding,pojo,serializer,with,different,pojo,type,will,result,in,incompatible;test,public,void,test,reconfigure,with,different,pojo,type,throws,exception,pojo,serializer,sub,test,user,class,b,pojo,serializer1,pojo,serializer,sub,test,user,class,b,type,extractor,get,for,class,sub,test,user,class,b,class,create,serializer,new,execution,config,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer1,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,pojo,serializer,sub,test,user,class,a,pojo,serializer2,pojo,serializer,sub,test,user,class,a,type,extractor,get,for,class,sub,test,user,class,a,class,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,sub,test,user,class,a,compat,result,pojo,serializer2,ensure,compatibility,pojo,serializer,config,snapshot,assert,true,compat,result,is,requires,migration
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentPojoType() throws Exception;1497328697;Verifies that reconfiguring with a config snapshot of a preceding POJO serializer_with different POJO type will result in INCOMPATIBLE.;@Test_	public void testReconfigureWithDifferentPojoType() throws Exception {_		PojoSerializer<SubTestUserClassB> pojoSerializer1 = (PojoSerializer<SubTestUserClassB>)_			TypeExtractor.getForClass(SubTestUserClassB.class).createSerializer(new ExecutionConfig())___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer1.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		PojoSerializer<SubTestUserClassA> pojoSerializer2 = (PojoSerializer<SubTestUserClassA>)_			TypeExtractor.getForClass(SubTestUserClassA.class).createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		CompatibilityResult<SubTestUserClassA> compatResult = pojoSerializer2.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertTrue(compatResult.isRequiresMigration())__	};verifies,that,reconfiguring,with,a,config,snapshot,of,a,preceding,pojo,serializer,with,different,pojo,type,will,result,in,incompatible;test,public,void,test,reconfigure,with,different,pojo,type,throws,exception,pojo,serializer,sub,test,user,class,b,pojo,serializer1,pojo,serializer,sub,test,user,class,b,type,extractor,get,for,class,sub,test,user,class,b,class,create,serializer,new,execution,config,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer1,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,pojo,serializer,sub,test,user,class,a,pojo,serializer2,pojo,serializer,sub,test,user,class,a,type,extractor,get,for,class,sub,test,user,class,a,class,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,sub,test,user,class,a,compat,result,pojo,serializer2,ensure,compatibility,pojo,serializer,config,snapshot,assert,true,compat,result,is,requires,migration
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentPojoType() throws Exception;1525657109;Verifies that reconfiguring with a config snapshot of a preceding POJO serializer_with different POJO type will result in INCOMPATIBLE.;@Test_	public void testReconfigureWithDifferentPojoType() throws Exception {_		PojoSerializer<SubTestUserClassB> pojoSerializer1 = (PojoSerializer<SubTestUserClassB>)_			TypeExtractor.getForClass(SubTestUserClassB.class).createSerializer(new ExecutionConfig())___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer1.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		PojoSerializer<SubTestUserClassA> pojoSerializer2 = (PojoSerializer<SubTestUserClassA>)_			TypeExtractor.getForClass(SubTestUserClassA.class).createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		CompatibilityResult<SubTestUserClassA> compatResult = pojoSerializer2.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertTrue(compatResult.isRequiresMigration())__	};verifies,that,reconfiguring,with,a,config,snapshot,of,a,preceding,pojo,serializer,with,different,pojo,type,will,result,in,incompatible;test,public,void,test,reconfigure,with,different,pojo,type,throws,exception,pojo,serializer,sub,test,user,class,b,pojo,serializer1,pojo,serializer,sub,test,user,class,b,type,extractor,get,for,class,sub,test,user,class,b,class,create,serializer,new,execution,config,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer1,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,pojo,serializer,sub,test,user,class,a,pojo,serializer2,pojo,serializer,sub,test,user,class,a,type,extractor,get,for,class,sub,test,user,class,a,class,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,sub,test,user,class,a,compat,result,pojo,serializer2,ensure,compatibility,pojo,serializer,config,snapshot,assert,true,compat,result,is,requires,migration
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentPojoType() throws Exception;1539149027;Verifies that reconfiguring with a config snapshot of a preceding POJO serializer_with different POJO type will result in INCOMPATIBLE.;@Test_	public void testReconfigureWithDifferentPojoType() throws Exception {_		PojoSerializer<SubTestUserClassB> pojoSerializer1 = (PojoSerializer<SubTestUserClassB>)_			TypeExtractor.getForClass(SubTestUserClassB.class).createSerializer(new ExecutionConfig())___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer1.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer1)__			serializedConfig = out.toByteArray()__		}__		PojoSerializer<SubTestUserClassA> pojoSerializer2 = (PojoSerializer<SubTestUserClassA>)_			TypeExtractor.getForClass(SubTestUserClassA.class).createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		CompatibilityResult<SubTestUserClassA> compatResult = pojoSerializer2.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertTrue(compatResult.isRequiresMigration())__	};verifies,that,reconfiguring,with,a,config,snapshot,of,a,preceding,pojo,serializer,with,different,pojo,type,will,result,in,incompatible;test,public,void,test,reconfigure,with,different,pojo,type,throws,exception,pojo,serializer,sub,test,user,class,b,pojo,serializer1,pojo,serializer,sub,test,user,class,b,type,extractor,get,for,class,sub,test,user,class,b,class,create,serializer,new,execution,config,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer1,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer1,serialized,config,out,to,byte,array,pojo,serializer,sub,test,user,class,a,pojo,serializer2,pojo,serializer,sub,test,user,class,a,type,extractor,get,for,class,sub,test,user,class,a,class,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,sub,test,user,class,a,compat,result,pojo,serializer2,ensure,compatibility,pojo,serializer,config,snapshot,assert,true,compat,result,is,requires,migration
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentPojoType() throws Exception;1539149040;Verifies that reconfiguring with a config snapshot of a preceding POJO serializer_with different POJO type will result in INCOMPATIBLE.;@Test_	public void testReconfigureWithDifferentPojoType() throws Exception {_		PojoSerializer<SubTestUserClassB> pojoSerializer1 = (PojoSerializer<SubTestUserClassB>)_			TypeExtractor.getForClass(SubTestUserClassB.class).createSerializer(new ExecutionConfig())___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer1.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerConfigSnapshotSerializationUtil.writeSerializerConfigSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer1)__			serializedConfig = out.toByteArray()__		}__		PojoSerializer<SubTestUserClassA> pojoSerializer2 = (PojoSerializer<SubTestUserClassA>)_			TypeExtractor.getForClass(SubTestUserClassA.class).createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerConfigSnapshotSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		CompatibilityResult<SubTestUserClassA> compatResult = pojoSerializer2.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertTrue(compatResult.isRequiresMigration())__	};verifies,that,reconfiguring,with,a,config,snapshot,of,a,preceding,pojo,serializer,with,different,pojo,type,will,result,in,incompatible;test,public,void,test,reconfigure,with,different,pojo,type,throws,exception,pojo,serializer,sub,test,user,class,b,pojo,serializer1,pojo,serializer,sub,test,user,class,b,type,extractor,get,for,class,sub,test,user,class,b,class,create,serializer,new,execution,config,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer1,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,config,snapshot,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer1,serialized,config,out,to,byte,array,pojo,serializer,sub,test,user,class,a,pojo,serializer2,pojo,serializer,sub,test,user,class,a,type,extractor,get,for,class,sub,test,user,class,a,class,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,config,snapshot,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,sub,test,user,class,a,compat,result,pojo,serializer2,ensure,compatibility,pojo,serializer,config,snapshot,assert,true,compat,result,is,requires,migration
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentPojoType() throws Exception;1539149114;Verifies that reconfiguring with a config snapshot of a preceding POJO serializer_with different POJO type will result in INCOMPATIBLE.;@Test_	public void testReconfigureWithDifferentPojoType() throws Exception {_		PojoSerializer<SubTestUserClassB> pojoSerializer1 = (PojoSerializer<SubTestUserClassB>)_			TypeExtractor.getForClass(SubTestUserClassB.class).createSerializer(new ExecutionConfig())___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer1.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer1)__			serializedConfig = out.toByteArray()__		}__		PojoSerializer<SubTestUserClassA> pojoSerializer2 = (PojoSerializer<SubTestUserClassA>)_			TypeExtractor.getForClass(SubTestUserClassA.class).createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer2)__		}__		CompatibilityResult<SubTestUserClassA> compatResult = pojoSerializer2.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertTrue(compatResult.isRequiresMigration())__	};verifies,that,reconfiguring,with,a,config,snapshot,of,a,preceding,pojo,serializer,with,different,pojo,type,will,result,in,incompatible;test,public,void,test,reconfigure,with,different,pojo,type,throws,exception,pojo,serializer,sub,test,user,class,b,pojo,serializer1,pojo,serializer,sub,test,user,class,b,type,extractor,get,for,class,sub,test,user,class,b,class,create,serializer,new,execution,config,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer1,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer1,serialized,config,out,to,byte,array,pojo,serializer,sub,test,user,class,a,pojo,serializer2,pojo,serializer,sub,test,user,class,a,type,extractor,get,for,class,sub,test,user,class,a,class,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer2,compatibility,result,sub,test,user,class,a,compat,result,pojo,serializer2,ensure,compatibility,pojo,serializer,config,snapshot,assert,true,compat,result,is,requires,migration
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentPojoType() throws Exception;1540907751;Verifies that reconfiguring with a config snapshot of a preceding POJO serializer_with different POJO type will result in INCOMPATIBLE.;@Test_	public void testReconfigureWithDifferentPojoType() throws Exception {_		PojoSerializer<SubTestUserClassB> pojoSerializer1 = (PojoSerializer<SubTestUserClassB>)_			TypeExtractor.getForClass(SubTestUserClassB.class).createSerializer(new ExecutionConfig())___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer1.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer1)__			serializedConfig = out.toByteArray()__		}__		PojoSerializer<SubTestUserClassA> pojoSerializer2 = (PojoSerializer<SubTestUserClassA>)_			TypeExtractor.getForClass(SubTestUserClassA.class).createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer2)__		}__		@SuppressWarnings("unchecked")_		TypeSerializerSchemaCompatibility<SubTestUserClassA, ?> compatResult =_			pojoSerializerConfigSnapshot.resolveSchemaCompatibility(pojoSerializer2)__		assertTrue(compatResult.isIncompatible())__	};verifies,that,reconfiguring,with,a,config,snapshot,of,a,preceding,pojo,serializer,with,different,pojo,type,will,result,in,incompatible;test,public,void,test,reconfigure,with,different,pojo,type,throws,exception,pojo,serializer,sub,test,user,class,b,pojo,serializer1,pojo,serializer,sub,test,user,class,b,type,extractor,get,for,class,sub,test,user,class,b,class,create,serializer,new,execution,config,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer1,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer1,serialized,config,out,to,byte,array,pojo,serializer,sub,test,user,class,a,pojo,serializer2,pojo,serializer,sub,test,user,class,a,type,extractor,get,for,class,sub,test,user,class,a,class,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer2,suppress,warnings,unchecked,type,serializer,schema,compatibility,sub,test,user,class,a,compat,result,pojo,serializer,config,snapshot,resolve,schema,compatibility,pojo,serializer2,assert,true,compat,result,is,incompatible
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentPojoType() throws Exception;1540907751;Verifies that reconfiguring with a config snapshot of a preceding POJO serializer_with different POJO type will result in INCOMPATIBLE.;@Test_	public void testReconfigureWithDifferentPojoType() throws Exception {_		PojoSerializer<SubTestUserClassB> pojoSerializer1 = (PojoSerializer<SubTestUserClassB>)_			TypeExtractor.getForClass(SubTestUserClassB.class).createSerializer(new ExecutionConfig())___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer1.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer1)__			serializedConfig = out.toByteArray()__		}__		PojoSerializer<SubTestUserClassA> pojoSerializer2 = (PojoSerializer<SubTestUserClassA>)_			TypeExtractor.getForClass(SubTestUserClassA.class).createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer2)__		}__		@SuppressWarnings("unchecked")_		TypeSerializerSchemaCompatibility<SubTestUserClassA, ?> compatResult =_			pojoSerializerConfigSnapshot.resolveSchemaCompatibility(pojoSerializer2)__		assertTrue(compatResult.isIncompatible())__	};verifies,that,reconfiguring,with,a,config,snapshot,of,a,preceding,pojo,serializer,with,different,pojo,type,will,result,in,incompatible;test,public,void,test,reconfigure,with,different,pojo,type,throws,exception,pojo,serializer,sub,test,user,class,b,pojo,serializer1,pojo,serializer,sub,test,user,class,b,type,extractor,get,for,class,sub,test,user,class,b,class,create,serializer,new,execution,config,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer1,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer1,serialized,config,out,to,byte,array,pojo,serializer,sub,test,user,class,a,pojo,serializer2,pojo,serializer,sub,test,user,class,a,type,extractor,get,for,class,sub,test,user,class,a,class,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer2,suppress,warnings,unchecked,type,serializer,schema,compatibility,sub,test,user,class,a,compat,result,pojo,serializer,config,snapshot,resolve,schema,compatibility,pojo,serializer2,assert,true,compat,result,is,incompatible
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentPojoType() throws Exception;1540907751;Verifies that reconfiguring with a config snapshot of a preceding POJO serializer_with different POJO type will result in INCOMPATIBLE.;@Test_	public void testReconfigureWithDifferentPojoType() throws Exception {_		PojoSerializer<SubTestUserClassB> pojoSerializer1 = (PojoSerializer<SubTestUserClassB>)_			TypeExtractor.getForClass(SubTestUserClassB.class).createSerializer(new ExecutionConfig())___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer1.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer1)__			serializedConfig = out.toByteArray()__		}__		PojoSerializer<SubTestUserClassA> pojoSerializer2 = (PojoSerializer<SubTestUserClassA>)_			TypeExtractor.getForClass(SubTestUserClassA.class).createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer2)__		}__		@SuppressWarnings("unchecked")_		TypeSerializerSchemaCompatibility<SubTestUserClassA> compatResult =_			pojoSerializerConfigSnapshot.resolveSchemaCompatibility(pojoSerializer2)__		assertTrue(compatResult.isIncompatible())__	};verifies,that,reconfiguring,with,a,config,snapshot,of,a,preceding,pojo,serializer,with,different,pojo,type,will,result,in,incompatible;test,public,void,test,reconfigure,with,different,pojo,type,throws,exception,pojo,serializer,sub,test,user,class,b,pojo,serializer1,pojo,serializer,sub,test,user,class,b,type,extractor,get,for,class,sub,test,user,class,b,class,create,serializer,new,execution,config,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer1,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer1,serialized,config,out,to,byte,array,pojo,serializer,sub,test,user,class,a,pojo,serializer2,pojo,serializer,sub,test,user,class,a,type,extractor,get,for,class,sub,test,user,class,a,class,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer2,suppress,warnings,unchecked,type,serializer,schema,compatibility,sub,test,user,class,a,compat,result,pojo,serializer,config,snapshot,resolve,schema,compatibility,pojo,serializer2,assert,true,compat,result,is,incompatible
PojoSerializerTest -> @Test 	public void testReconfigureWithDifferentPojoType() throws Exception;1550821417;Verifies that reconfiguring with a config snapshot of a preceding POJO serializer_with different POJO type will result in INCOMPATIBLE.;@Test_	public void testReconfigureWithDifferentPojoType() throws Exception {_		PojoSerializer<SubTestUserClassB> pojoSerializer1 = (PojoSerializer<SubTestUserClassB>)_			TypeExtractor.getForClass(SubTestUserClassB.class).createSerializer(new ExecutionConfig())___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer1.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer1)__			serializedConfig = out.toByteArray()__		}__		PojoSerializer<SubTestUserClassA> pojoSerializer2 = (PojoSerializer<SubTestUserClassA>)_			TypeExtractor.getForClass(SubTestUserClassA.class).createSerializer(new ExecutionConfig())___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer2)__		}__		@SuppressWarnings("unchecked")_		TypeSerializerSchemaCompatibility<SubTestUserClassA> compatResult =_			pojoSerializerConfigSnapshot.resolveSchemaCompatibility(pojoSerializer2)__		assertTrue(compatResult.isIncompatible())__	};verifies,that,reconfiguring,with,a,config,snapshot,of,a,preceding,pojo,serializer,with,different,pojo,type,will,result,in,incompatible;test,public,void,test,reconfigure,with,different,pojo,type,throws,exception,pojo,serializer,sub,test,user,class,b,pojo,serializer1,pojo,serializer,sub,test,user,class,b,type,extractor,get,for,class,sub,test,user,class,b,class,create,serializer,new,execution,config,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer1,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer1,serialized,config,out,to,byte,array,pojo,serializer,sub,test,user,class,a,pojo,serializer2,pojo,serializer,sub,test,user,class,a,type,extractor,get,for,class,sub,test,user,class,a,class,create,serializer,new,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer2,suppress,warnings,unchecked,type,serializer,schema,compatibility,sub,test,user,class,a,compat,result,pojo,serializer,config,snapshot,resolve,schema,compatibility,pojo,serializer2,assert,true,compat,result,is,incompatible
PojoSerializerTest -> @Test 	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception;1494180263;Tests that reconfiguration correctly reorders subclass registrations to their previous order.;@Test_	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception {_		ExecutionConfig executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassA.class)__		executionConfig.registerPojoType(SubTestUserClassB.class)___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		int subClassATag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class)__		int subClassBTag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class)___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		_		executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassB.class)_ _		executionConfig.registerPojoType(SubTestUserClassA.class)___		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertTrue(!compatResult.requiresMigration())___		_		_		assertEquals(subClassATag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class).intValue())__		assertEquals(subClassBTag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class).intValue())__	};tests,that,reconfiguration,correctly,reorders,subclass,registrations,to,their,previous,order;test,public,void,test,reconfigure,different,subclass,registration,order,throws,exception,execution,config,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,a,class,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,int,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,b,class,execution,config,register,pojo,type,sub,test,user,class,a,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,true,compat,result,requires,migration,assert,equals,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,value,assert,equals,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,int,value
PojoSerializerTest -> @Test 	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception;1494658833;Tests that reconfiguration correctly reorders subclass registrations to their previous order.;@Test_	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception {_		ExecutionConfig executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassA.class)__		executionConfig.registerPojoType(SubTestUserClassB.class)___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		int subClassATag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class)__		int subClassBTag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class)___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		_		executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassB.class)_ _		executionConfig.registerPojoType(SubTestUserClassA.class)___		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertTrue(!compatResult.isRequiresMigration())___		_		_		assertEquals(subClassATag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class).intValue())__		assertEquals(subClassBTag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class).intValue())__	};tests,that,reconfiguration,correctly,reorders,subclass,registrations,to,their,previous,order;test,public,void,test,reconfigure,different,subclass,registration,order,throws,exception,execution,config,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,a,class,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,int,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,b,class,execution,config,register,pojo,type,sub,test,user,class,a,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,true,compat,result,is,requires,migration,assert,equals,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,value,assert,equals,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,int,value
PojoSerializerTest -> @Test 	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception;1495466666;Tests that reconfiguration correctly reorders subclass registrations to their previous order.;@Test_	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception {_		ExecutionConfig executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassA.class)__		executionConfig.registerPojoType(SubTestUserClassB.class)___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		int subClassATag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class)__		int subClassBTag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class)___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		_		executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassB.class)_ _		executionConfig.registerPojoType(SubTestUserClassA.class)___		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertTrue(!compatResult.isRequiresMigration())___		_		_		assertEquals(subClassATag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class).intValue())__		assertEquals(subClassBTag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class).intValue())__	};tests,that,reconfiguration,correctly,reorders,subclass,registrations,to,their,previous,order;test,public,void,test,reconfigure,different,subclass,registration,order,throws,exception,execution,config,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,a,class,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,int,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,b,class,execution,config,register,pojo,type,sub,test,user,class,a,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,true,compat,result,is,requires,migration,assert,equals,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,value,assert,equals,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,int,value
PojoSerializerTest -> @Test 	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception;1497328697;Tests that reconfiguration correctly reorders subclass registrations to their previous order.;@Test_	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception {_		ExecutionConfig executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassA.class)__		executionConfig.registerPojoType(SubTestUserClassB.class)___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		int subClassATag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class)__		int subClassBTag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class)___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		_		executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassB.class)_ _		executionConfig.registerPojoType(SubTestUserClassA.class)___		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertTrue(!compatResult.isRequiresMigration())___		_		_		assertEquals(subClassATag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class).intValue())__		assertEquals(subClassBTag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class).intValue())__	};tests,that,reconfiguration,correctly,reorders,subclass,registrations,to,their,previous,order;test,public,void,test,reconfigure,different,subclass,registration,order,throws,exception,execution,config,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,a,class,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,int,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,b,class,execution,config,register,pojo,type,sub,test,user,class,a,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,true,compat,result,is,requires,migration,assert,equals,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,value,assert,equals,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,int,value
PojoSerializerTest -> @Test 	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception;1525657109;Tests that reconfiguration correctly reorders subclass registrations to their previous order.;@Test_	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception {_		ExecutionConfig executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassA.class)__		executionConfig.registerPojoType(SubTestUserClassB.class)___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		int subClassATag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class)__		int subClassBTag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class)___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot)__			serializedConfig = out.toByteArray()__		}__		_		executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassB.class)_ _		executionConfig.registerPojoType(SubTestUserClassA.class)___		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertTrue(!compatResult.isRequiresMigration())___		_		_		assertEquals(subClassATag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class).intValue())__		assertEquals(subClassBTag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class).intValue())__	};tests,that,reconfiguration,correctly,reorders,subclass,registrations,to,their,previous,order;test,public,void,test,reconfigure,different,subclass,registration,order,throws,exception,execution,config,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,a,class,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,int,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,serialized,config,out,to,byte,array,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,b,class,execution,config,register,pojo,type,sub,test,user,class,a,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,true,compat,result,is,requires,migration,assert,equals,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,value,assert,equals,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,int,value
PojoSerializerTest -> @Test 	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception;1539149027;Tests that reconfiguration correctly reorders subclass registrations to their previous order.;@Test_	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception {_		ExecutionConfig executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassA.class)__		executionConfig.registerPojoType(SubTestUserClassB.class)___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		int subClassATag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class)__		int subClassBTag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class)___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSerializationUtil.writeSerializerConfigSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		_		executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassB.class)_ _		executionConfig.registerPojoType(SubTestUserClassA.class)___		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertTrue(!compatResult.isRequiresMigration())___		_		_		assertEquals(subClassATag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class).intValue())__		assertEquals(subClassBTag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class).intValue())__	};tests,that,reconfiguration,correctly,reorders,subclass,registrations,to,their,previous,order;test,public,void,test,reconfigure,different,subclass,registration,order,throws,exception,execution,config,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,a,class,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,int,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,b,class,execution,config,register,pojo,type,sub,test,user,class,a,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,true,compat,result,is,requires,migration,assert,equals,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,value,assert,equals,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,int,value
PojoSerializerTest -> @Test 	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception;1539149040;Tests that reconfiguration correctly reorders subclass registrations to their previous order.;@Test_	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception {_		ExecutionConfig executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassA.class)__		executionConfig.registerPojoType(SubTestUserClassB.class)___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		int subClassATag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class)__		int subClassBTag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class)___		_		TypeSerializerConfigSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerConfigSnapshotSerializationUtil.writeSerializerConfigSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		_		executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassB.class)_ _		executionConfig.registerPojoType(SubTestUserClassA.class)___		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerConfigSnapshotSerializationUtil.readSerializerConfigSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader())__		}__		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertTrue(!compatResult.isRequiresMigration())___		_		_		assertEquals(subClassATag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class).intValue())__		assertEquals(subClassBTag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class).intValue())__	};tests,that,reconfiguration,correctly,reorders,subclass,registrations,to,their,previous,order;test,public,void,test,reconfigure,different,subclass,registration,order,throws,exception,execution,config,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,a,class,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,int,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,type,serializer,config,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,config,snapshot,serialization,util,write,serializer,config,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,b,class,execution,config,register,pojo,type,sub,test,user,class,a,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,config,snapshot,serialization,util,read,serializer,config,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,true,compat,result,is,requires,migration,assert,equals,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,value,assert,equals,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,int,value
PojoSerializerTest -> @Test 	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception;1539149114;Tests that reconfiguration correctly reorders subclass registrations to their previous order.;@Test_	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception {_		ExecutionConfig executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassA.class)__		executionConfig.registerPojoType(SubTestUserClassB.class)___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		int subClassATag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class)__		int subClassBTag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class)___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		_		executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassB.class)_ _		executionConfig.registerPojoType(SubTestUserClassA.class)___		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer)__		}__		CompatibilityResult<TestUserClass> compatResult = pojoSerializer.ensureCompatibility(pojoSerializerConfigSnapshot)__		assertTrue(!compatResult.isRequiresMigration())___		_		_		assertEquals(subClassATag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class).intValue())__		assertEquals(subClassBTag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class).intValue())__	};tests,that,reconfiguration,correctly,reorders,subclass,registrations,to,their,previous,order;test,public,void,test,reconfigure,different,subclass,registration,order,throws,exception,execution,config,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,a,class,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,int,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,b,class,execution,config,register,pojo,type,sub,test,user,class,a,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer,compatibility,result,test,user,class,compat,result,pojo,serializer,ensure,compatibility,pojo,serializer,config,snapshot,assert,true,compat,result,is,requires,migration,assert,equals,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,value,assert,equals,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,int,value
PojoSerializerTest -> @Test 	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception;1540907751;Tests that reconfiguration correctly reorders subclass registrations to their previous order.;@Test_	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception {_		ExecutionConfig executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassA.class)__		executionConfig.registerPojoType(SubTestUserClassB.class)___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		int subClassATag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class)__		int subClassBTag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class)___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		_		executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassB.class)_ _		executionConfig.registerPojoType(SubTestUserClassA.class)___		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer)__		}__		@SuppressWarnings("unchecked")_		TypeSerializerSchemaCompatibility<TestUserClass, ?> compatResult =_			pojoSerializerConfigSnapshot.resolveSchemaCompatibility(pojoSerializer)__		assertTrue(compatResult.isCompatibleAsIs())___		_		_		assertEquals(subClassATag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class).intValue())__		assertEquals(subClassBTag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class).intValue())__	};tests,that,reconfiguration,correctly,reorders,subclass,registrations,to,their,previous,order;test,public,void,test,reconfigure,different,subclass,registration,order,throws,exception,execution,config,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,a,class,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,int,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,b,class,execution,config,register,pojo,type,sub,test,user,class,a,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer,suppress,warnings,unchecked,type,serializer,schema,compatibility,test,user,class,compat,result,pojo,serializer,config,snapshot,resolve,schema,compatibility,pojo,serializer,assert,true,compat,result,is,compatible,as,is,assert,equals,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,value,assert,equals,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,int,value
PojoSerializerTest -> @Test 	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception;1540907751;Tests that reconfiguration correctly reorders subclass registrations to their previous order.;@Test_	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception {_		ExecutionConfig executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassA.class)__		executionConfig.registerPojoType(SubTestUserClassB.class)___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		int subClassATag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class)__		int subClassBTag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class)___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		_		executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassB.class)_ _		executionConfig.registerPojoType(SubTestUserClassA.class)___		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer)__		}__		@SuppressWarnings("unchecked")_		TypeSerializerSchemaCompatibility<TestUserClass, ?> compatResult =_			pojoSerializerConfigSnapshot.resolveSchemaCompatibility(pojoSerializer)__		assertTrue(compatResult.isCompatibleAsIs())___		_		_		assertEquals(subClassATag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class).intValue())__		assertEquals(subClassBTag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class).intValue())__	};tests,that,reconfiguration,correctly,reorders,subclass,registrations,to,their,previous,order;test,public,void,test,reconfigure,different,subclass,registration,order,throws,exception,execution,config,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,a,class,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,int,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,b,class,execution,config,register,pojo,type,sub,test,user,class,a,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer,suppress,warnings,unchecked,type,serializer,schema,compatibility,test,user,class,compat,result,pojo,serializer,config,snapshot,resolve,schema,compatibility,pojo,serializer,assert,true,compat,result,is,compatible,as,is,assert,equals,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,value,assert,equals,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,int,value
PojoSerializerTest -> @Test 	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception;1540907751;Tests that reconfiguration correctly reorders subclass registrations to their previous order.;@Test_	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception {_		ExecutionConfig executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassA.class)__		executionConfig.registerPojoType(SubTestUserClassB.class)___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		int subClassATag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class)__		int subClassBTag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class)___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		_		executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassB.class)_ _		executionConfig.registerPojoType(SubTestUserClassA.class)___		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer)__		}__		@SuppressWarnings("unchecked")_		TypeSerializerSchemaCompatibility<TestUserClass> compatResult =_			pojoSerializerConfigSnapshot.resolveSchemaCompatibility(pojoSerializer)__		assertTrue(compatResult.isCompatibleAsIs())___		_		_		assertEquals(subClassATag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class).intValue())__		assertEquals(subClassBTag, pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class).intValue())__	};tests,that,reconfiguration,correctly,reorders,subclass,registrations,to,their,previous,order;test,public,void,test,reconfigure,different,subclass,registration,order,throws,exception,execution,config,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,a,class,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,int,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,b,class,execution,config,register,pojo,type,sub,test,user,class,a,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer,suppress,warnings,unchecked,type,serializer,schema,compatibility,test,user,class,compat,result,pojo,serializer,config,snapshot,resolve,schema,compatibility,pojo,serializer,assert,true,compat,result,is,compatible,as,is,assert,equals,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,value,assert,equals,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,int,value
PojoSerializerTest -> @Test 	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception;1550821417;Tests that reconfiguration correctly reorders subclass registrations to their previous order.;@Test_	public void testReconfigureDifferentSubclassRegistrationOrder() throws Exception {_		ExecutionConfig executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassA.class)__		executionConfig.registerPojoType(SubTestUserClassB.class)___		PojoSerializer<TestUserClass> pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		int subClassATag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class)__		int subClassBTag = pojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class)___		_		TypeSerializerSnapshot pojoSerializerConfigSnapshot = pojoSerializer.snapshotConfiguration()__		byte[] serializedConfig__		try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {_			TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(_				new DataOutputViewStreamWrapper(out), pojoSerializerConfigSnapshot, pojoSerializer)__			serializedConfig = out.toByteArray()__		}__		_		executionConfig = new ExecutionConfig()__		executionConfig.registerPojoType(SubTestUserClassB.class)_ _		executionConfig.registerPojoType(SubTestUserClassA.class)___		pojoSerializer = (PojoSerializer<TestUserClass>) type.createSerializer(executionConfig)___		_		try(ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {_			pojoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(_				new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), pojoSerializer)__		}__		@SuppressWarnings("unchecked")_		TypeSerializerSchemaCompatibility<TestUserClass> compatResult =_			pojoSerializerConfigSnapshot.resolveSchemaCompatibility(pojoSerializer)__		assertTrue(compatResult.isCompatibleWithReconfiguredSerializer())__		assertTrue(compatResult.getReconfiguredSerializer() instanceof PojoSerializer)___		_		_		PojoSerializer<TestUserClass> reconfiguredPojoSerializer = (PojoSerializer<TestUserClass>) compatResult.getReconfiguredSerializer()__		assertEquals(subClassATag, reconfiguredPojoSerializer.getRegisteredClasses().get(SubTestUserClassA.class).intValue())__		assertEquals(subClassBTag, reconfiguredPojoSerializer.getRegisteredClasses().get(SubTestUserClassB.class).intValue())__	};tests,that,reconfiguration,correctly,reorders,subclass,registrations,to,their,previous,order;test,public,void,test,reconfigure,different,subclass,registration,order,throws,exception,execution,config,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,a,class,execution,config,register,pojo,type,sub,test,user,class,b,class,pojo,serializer,test,user,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,int,sub,class,atag,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,sub,class,btag,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,type,serializer,snapshot,pojo,serializer,config,snapshot,pojo,serializer,snapshot,configuration,byte,serialized,config,try,byte,array,output,stream,out,new,byte,array,output,stream,type,serializer,snapshot,serialization,util,write,serializer,snapshot,new,data,output,view,stream,wrapper,out,pojo,serializer,config,snapshot,pojo,serializer,serialized,config,out,to,byte,array,execution,config,new,execution,config,execution,config,register,pojo,type,sub,test,user,class,b,class,execution,config,register,pojo,type,sub,test,user,class,a,class,pojo,serializer,pojo,serializer,test,user,class,type,create,serializer,execution,config,try,byte,array,input,stream,in,new,byte,array,input,stream,serialized,config,pojo,serializer,config,snapshot,type,serializer,snapshot,serialization,util,read,serializer,snapshot,new,data,input,view,stream,wrapper,in,thread,current,thread,get,context,class,loader,pojo,serializer,suppress,warnings,unchecked,type,serializer,schema,compatibility,test,user,class,compat,result,pojo,serializer,config,snapshot,resolve,schema,compatibility,pojo,serializer,assert,true,compat,result,is,compatible,with,reconfigured,serializer,assert,true,compat,result,get,reconfigured,serializer,instanceof,pojo,serializer,pojo,serializer,test,user,class,reconfigured,pojo,serializer,pojo,serializer,test,user,class,compat,result,get,reconfigured,serializer,assert,equals,sub,class,atag,reconfigured,pojo,serializer,get,registered,classes,get,sub,test,user,class,a,class,int,value,assert,equals,sub,class,btag,reconfigured,pojo,serializer,get,registered,classes,get,sub,test,user,class,b,class,int,value
