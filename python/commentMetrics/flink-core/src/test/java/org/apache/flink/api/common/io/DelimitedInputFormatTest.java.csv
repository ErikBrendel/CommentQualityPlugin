# id;timestamp;commentText;codeText;commentWords;codeWords
DelimitedInputFormatTest -> @Test 	public void testReadOverSplitBoundariesUnaligned() throws IOException;1487199189;Tests that the records are read correctly when the split boundary is in the middle of a record.;@Test_	public void testReadOverSplitBoundariesUnaligned() throws IOException {_		final String myString = "value1\nvalue2\nvalue3"__		final FileInputSplit split = createTempFile(myString)___		FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__		FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___		final Configuration parameters = new Configuration()___		format.configure(parameters)__		format.open(split1)___		assertEquals("value1", format.nextRecord(null))__		assertEquals("value2", format.nextRecord(null))__		assertNull(format.nextRecord(null))__		assertTrue(format.reachedEnd())___		format.close()__		format.open(split2)___		assertEquals("value3", format.nextRecord(null))__		assertNull(format.nextRecord(null))__		assertTrue(format.reachedEnd())___		format.close()__	};tests,that,the,records,are,read,correctly,when,the,split,boundary,is,in,the,middle,of,a,record;test,public,void,test,read,over,split,boundaries,unaligned,throws,ioexception,final,string,my,string,value1,nvalue2,nvalue3,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,configure,parameters,format,open,split1,assert,equals,value1,format,next,record,null,assert,equals,value2,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,format,open,split2,assert,equals,value3,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close
DelimitedInputFormatTest -> @Test 	public void testReadOverSplitBoundariesUnaligned() throws IOException;1489060855;Tests that the records are read correctly when the split boundary is in the middle of a record.;@Test_	public void testReadOverSplitBoundariesUnaligned() throws IOException {_		final String myString = "value1\nvalue2\nvalue3"__		final FileInputSplit split = createTempFile(myString)___		FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__		FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___		final Configuration parameters = new Configuration()___		format.configure(parameters)__		format.open(split1)___		assertEquals("value1", format.nextRecord(null))__		assertEquals("value2", format.nextRecord(null))__		assertNull(format.nextRecord(null))__		assertTrue(format.reachedEnd())___		format.close()__		format.open(split2)___		assertEquals("value3", format.nextRecord(null))__		assertNull(format.nextRecord(null))__		assertTrue(format.reachedEnd())___		format.close()__	};tests,that,the,records,are,read,correctly,when,the,split,boundary,is,in,the,middle,of,a,record;test,public,void,test,read,over,split,boundaries,unaligned,throws,ioexception,final,string,my,string,value1,nvalue2,nvalue3,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,configure,parameters,format,open,split1,assert,equals,value1,format,next,record,null,assert,equals,value2,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,format,open,split2,assert,equals,value3,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close
DelimitedInputFormatTest -> @Test 	public void testReadOverSplitBoundariesUnaligned() throws IOException;1497970731;Tests that the records are read correctly when the split boundary is in the middle of a record.;@Test_	public void testReadOverSplitBoundariesUnaligned() throws IOException {_		final String myString = "value1\nvalue2\nvalue3"__		final FileInputSplit split = createTempFile(myString)___		FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__		FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___		final Configuration parameters = new Configuration()___		format.configure(parameters)__		format.open(split1)___		assertEquals("value1", format.nextRecord(null))__		assertEquals("value2", format.nextRecord(null))__		assertNull(format.nextRecord(null))__		assertTrue(format.reachedEnd())___		format.close()__		format.open(split2)___		assertEquals("value3", format.nextRecord(null))__		assertNull(format.nextRecord(null))__		assertTrue(format.reachedEnd())___		format.close()__	};tests,that,the,records,are,read,correctly,when,the,split,boundary,is,in,the,middle,of,a,record;test,public,void,test,read,over,split,boundaries,unaligned,throws,ioexception,final,string,my,string,value1,nvalue2,nvalue3,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,configure,parameters,format,open,split1,assert,equals,value1,format,next,record,null,assert,equals,value2,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,format,open,split2,assert,equals,value3,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close
DelimitedInputFormatTest -> @Test 	public void testReadOverSplitBoundariesUnaligned() throws IOException;1518772855;Tests that the records are read correctly when the split boundary is in the middle of a record.;@Test_	public void testReadOverSplitBoundariesUnaligned() throws IOException {_		final String myString = "value1\nvalue2\nvalue3"__		final FileInputSplit split = createTempFile(myString)___		FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__		FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___		final Configuration parameters = new Configuration()___		format.configure(parameters)__		format.open(split1)___		assertEquals("value1", format.nextRecord(null))__		assertEquals("value2", format.nextRecord(null))__		assertNull(format.nextRecord(null))__		assertTrue(format.reachedEnd())___		format.close()__		format.open(split2)___		assertEquals("value3", format.nextRecord(null))__		assertNull(format.nextRecord(null))__		assertTrue(format.reachedEnd())___		format.close()__	};tests,that,the,records,are,read,correctly,when,the,split,boundary,is,in,the,middle,of,a,record;test,public,void,test,read,over,split,boundaries,unaligned,throws,ioexception,final,string,my,string,value1,nvalue2,nvalue3,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,configure,parameters,format,open,split1,assert,equals,value1,format,next,record,null,assert,equals,value2,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,format,open,split2,assert,equals,value3,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close
DelimitedInputFormatTest -> @Test 	public void testReadOverSplitBoundariesUnaligned() throws IOException;1518772855;Tests that the records are read correctly when the split boundary is in the middle of a record.;@Test_	public void testReadOverSplitBoundariesUnaligned() throws IOException {_		final String myString = "value1\nvalue2\nvalue3"__		final FileInputSplit split = createTempFile(myString)___		FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__		FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___		final Configuration parameters = new Configuration()___		format.configure(parameters)__		format.open(split1)___		assertEquals("value1", format.nextRecord(null))__		assertEquals("value2", format.nextRecord(null))__		assertNull(format.nextRecord(null))__		assertTrue(format.reachedEnd())___		format.close()__		format.open(split2)___		assertEquals("value3", format.nextRecord(null))__		assertNull(format.nextRecord(null))__		assertTrue(format.reachedEnd())___		format.close()__	};tests,that,the,records,are,read,correctly,when,the,split,boundary,is,in,the,middle,of,a,record;test,public,void,test,read,over,split,boundaries,unaligned,throws,ioexception,final,string,my,string,value1,nvalue2,nvalue3,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,configure,parameters,format,open,split1,assert,equals,value1,format,next,record,null,assert,equals,value2,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,format,open,split2,assert,equals,value3,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close
DelimitedInputFormatTest -> @Test 	public void testReadOverSplitBoundariesUnaligned();1436793281;Tests that the records are read correctly when the split boundary is in the middle of a record.;@Test_	public void testReadOverSplitBoundariesUnaligned() {_		try {_			final String myString = "value1\nvalue2\nvalue3"__			final FileInputSplit split = createTempFile(myString)__			_			FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__			FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___			final Configuration parameters = new Configuration()__			_			format.configure(parameters)__			format.open(split1)__			_			assertEquals("value1", format.nextRecord(null))__			assertEquals("value2", format.nextRecord(null))__			assertNull(format.nextRecord(null))__			assertTrue(format.reachedEnd())__			_			format.close()__			format.open(split2)___			assertEquals("value3", format.nextRecord(null))__			assertNull(format.nextRecord(null))__			assertTrue(format.reachedEnd())__			_			format.close()__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};tests,that,the,records,are,read,correctly,when,the,split,boundary,is,in,the,middle,of,a,record;test,public,void,test,read,over,split,boundaries,unaligned,try,final,string,my,string,value1,nvalue2,nvalue3,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,configure,parameters,format,open,split1,assert,equals,value1,format,next,record,null,assert,equals,value2,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,format,open,split2,assert,equals,value3,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,catch,exception,e,e,print,stack,trace,fail,e,get,message
DelimitedInputFormatTest -> @Test 	public void testReadOverSplitBoundariesUnaligned();1469630409;Tests that the records are read correctly when the split boundary is in the middle of a record.;@Test_	public void testReadOverSplitBoundariesUnaligned() {_		try {_			final String myString = "value1\nvalue2\nvalue3"__			final FileInputSplit split = createTempFile(myString)__			_			FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__			FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___			final Configuration parameters = new Configuration()__			_			format.configure(parameters)__			format.open(split1)__			_			assertEquals("value1", format.nextRecord(null))__			assertEquals("value2", format.nextRecord(null))__			assertNull(format.nextRecord(null))__			assertTrue(format.reachedEnd())__			_			format.close()__			format.open(split2)___			assertEquals("value3", format.nextRecord(null))__			assertNull(format.nextRecord(null))__			assertTrue(format.reachedEnd())__			_			format.close()__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};tests,that,the,records,are,read,correctly,when,the,split,boundary,is,in,the,middle,of,a,record;test,public,void,test,read,over,split,boundaries,unaligned,try,final,string,my,string,value1,nvalue2,nvalue3,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,configure,parameters,format,open,split1,assert,equals,value1,format,next,record,null,assert,equals,value2,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,format,open,split2,assert,equals,value3,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,catch,exception,e,e,print,stack,trace,fail,e,get,message
DelimitedInputFormatTest -> @Test 	public void testReadOverSplitBoundariesUnaligned();1475688973;Tests that the records are read correctly when the split boundary is in the middle of a record.;@Test_	public void testReadOverSplitBoundariesUnaligned() {_		try {_			final String myString = "value1\nvalue2\nvalue3"__			final FileInputSplit split = createTempFile(myString)__			_			FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__			FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___			final Configuration parameters = new Configuration()__			_			format.configure(parameters)__			format.open(split1)__			_			assertEquals("value1", format.nextRecord(null))__			assertEquals("value2", format.nextRecord(null))__			assertNull(format.nextRecord(null))__			assertTrue(format.reachedEnd())__			_			format.close()__			format.open(split2)___			assertEquals("value3", format.nextRecord(null))__			assertNull(format.nextRecord(null))__			assertTrue(format.reachedEnd())__			_			format.close()__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};tests,that,the,records,are,read,correctly,when,the,split,boundary,is,in,the,middle,of,a,record;test,public,void,test,read,over,split,boundaries,unaligned,try,final,string,my,string,value1,nvalue2,nvalue3,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,configure,parameters,format,open,split1,assert,equals,value1,format,next,record,null,assert,equals,value2,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,format,open,split2,assert,equals,value3,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,catch,exception,e,e,print,stack,trace,fail,e,get,message
DelimitedInputFormatTest -> @Test 	public void testReadOverSplitBoundariesUnaligned();1481228508;Tests that the records are read correctly when the split boundary is in the middle of a record.;@Test_	public void testReadOverSplitBoundariesUnaligned() {_		try {_			final String myString = "value1\nvalue2\nvalue3"__			final FileInputSplit split = createTempFile(myString)__			_			FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__			FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___			final Configuration parameters = new Configuration()__			_			format.configure(parameters)__			format.open(split1)__			_			assertEquals("value1", format.nextRecord(null))__			assertEquals("value2", format.nextRecord(null))__			assertNull(format.nextRecord(null))__			assertTrue(format.reachedEnd())__			_			format.close()__			format.open(split2)___			assertEquals("value3", format.nextRecord(null))__			assertNull(format.nextRecord(null))__			assertTrue(format.reachedEnd())__			_			format.close()__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};tests,that,the,records,are,read,correctly,when,the,split,boundary,is,in,the,middle,of,a,record;test,public,void,test,read,over,split,boundaries,unaligned,try,final,string,my,string,value1,nvalue2,nvalue3,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,configure,parameters,format,open,split1,assert,equals,value1,format,next,record,null,assert,equals,value2,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,format,open,split2,assert,equals,value3,format,next,record,null,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,catch,exception,e,e,print,stack,trace,fail,e,get,message
DelimitedInputFormatTest -> @Test 	public void testReadWithBufferSizeIsMultiple() throws IOException;1487199189;Tests that the correct number of records is read when the split boundary is exact at the record boundary.;@Test_	public void testReadWithBufferSizeIsMultiple() throws IOException {_		final String myString = "aaaaaaa\nbbbbbbb\nccccccc\nddddddd\n"__		final FileInputSplit split = createTempFile(myString)___		FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__		FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___		final Configuration parameters = new Configuration()___		format.setBufferSize(2 * ((int) split1.getLength()))__		format.configure(parameters)___		String next__		int count = 0___		_		format.open(split1)__		while ((next = format.nextRecord(null)) != null) {_			assertEquals(7, next.length())__			count++__		}_		assertNull(format.nextRecord(null))__		assertTrue(format.reachedEnd())__		format.close()___		_		_		assertEquals(3, count)___		_		format.open(split2)__		while ((next = format.nextRecord(null)) != null) {_			assertEquals(7, next.length())__			count++__		}_		format.close()___		assertEquals(4, count)__	};tests,that,the,correct,number,of,records,is,read,when,the,split,boundary,is,exact,at,the,record,boundary;test,public,void,test,read,with,buffer,size,is,multiple,throws,ioexception,final,string,my,string,aaaaaaa,nbbbbbbb,nccccccc,nddddddd,n,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,set,buffer,size,2,int,split1,get,length,format,configure,parameters,string,next,int,count,0,format,open,split1,while,next,format,next,record,null,null,assert,equals,7,next,length,count,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,assert,equals,3,count,format,open,split2,while,next,format,next,record,null,null,assert,equals,7,next,length,count,format,close,assert,equals,4,count
DelimitedInputFormatTest -> @Test 	public void testReadWithBufferSizeIsMultiple() throws IOException;1489060855;Tests that the correct number of records is read when the split boundary is exact at the record boundary.;@Test_	public void testReadWithBufferSizeIsMultiple() throws IOException {_		final String myString = "aaaaaaa\nbbbbbbb\nccccccc\nddddddd\n"__		final FileInputSplit split = createTempFile(myString)___		FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__		FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___		final Configuration parameters = new Configuration()___		format.setBufferSize(2 * ((int) split1.getLength()))__		format.configure(parameters)___		String next__		int count = 0___		_		format.open(split1)__		while ((next = format.nextRecord(null)) != null) {_			assertEquals(7, next.length())__			count++__		}_		assertNull(format.nextRecord(null))__		assertTrue(format.reachedEnd())__		format.close()___		_		_		assertEquals(3, count)___		_		format.open(split2)__		while ((next = format.nextRecord(null)) != null) {_			assertEquals(7, next.length())__			count++__		}_		format.close()___		assertEquals(4, count)__	};tests,that,the,correct,number,of,records,is,read,when,the,split,boundary,is,exact,at,the,record,boundary;test,public,void,test,read,with,buffer,size,is,multiple,throws,ioexception,final,string,my,string,aaaaaaa,nbbbbbbb,nccccccc,nddddddd,n,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,set,buffer,size,2,int,split1,get,length,format,configure,parameters,string,next,int,count,0,format,open,split1,while,next,format,next,record,null,null,assert,equals,7,next,length,count,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,assert,equals,3,count,format,open,split2,while,next,format,next,record,null,null,assert,equals,7,next,length,count,format,close,assert,equals,4,count
DelimitedInputFormatTest -> @Test 	public void testReadWithBufferSizeIsMultiple() throws IOException;1497970731;Tests that the correct number of records is read when the split boundary is exact at the record boundary.;@Test_	public void testReadWithBufferSizeIsMultiple() throws IOException {_		final String myString = "aaaaaaa\nbbbbbbb\nccccccc\nddddddd\n"__		final FileInputSplit split = createTempFile(myString)___		FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__		FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___		final Configuration parameters = new Configuration()___		format.setBufferSize(2 * ((int) split1.getLength()))__		format.configure(parameters)___		String next__		int count = 0___		_		format.open(split1)__		while ((next = format.nextRecord(null)) != null) {_			assertEquals(7, next.length())__			count++__		}_		assertNull(format.nextRecord(null))__		assertTrue(format.reachedEnd())__		format.close()___		_		_		assertEquals(3, count)___		_		format.open(split2)__		while ((next = format.nextRecord(null)) != null) {_			assertEquals(7, next.length())__			count++__		}_		format.close()___		assertEquals(4, count)__	};tests,that,the,correct,number,of,records,is,read,when,the,split,boundary,is,exact,at,the,record,boundary;test,public,void,test,read,with,buffer,size,is,multiple,throws,ioexception,final,string,my,string,aaaaaaa,nbbbbbbb,nccccccc,nddddddd,n,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,set,buffer,size,2,int,split1,get,length,format,configure,parameters,string,next,int,count,0,format,open,split1,while,next,format,next,record,null,null,assert,equals,7,next,length,count,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,assert,equals,3,count,format,open,split2,while,next,format,next,record,null,null,assert,equals,7,next,length,count,format,close,assert,equals,4,count
DelimitedInputFormatTest -> @Test 	public void testReadWithBufferSizeIsMultiple() throws IOException;1518772855;Tests that the correct number of records is read when the split boundary is exact at the record boundary.;@Test_	public void testReadWithBufferSizeIsMultiple() throws IOException {_		final String myString = "aaaaaaa\nbbbbbbb\nccccccc\nddddddd\n"__		final FileInputSplit split = createTempFile(myString)___		FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__		FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___		final Configuration parameters = new Configuration()___		format.setBufferSize(2 * ((int) split1.getLength()))__		format.configure(parameters)___		String next__		int count = 0___		_		format.open(split1)__		while ((next = format.nextRecord(null)) != null) {_			assertEquals(7, next.length())__			count++__		}_		assertNull(format.nextRecord(null))__		assertTrue(format.reachedEnd())__		format.close()___		_		_		assertEquals(3, count)___		_		format.open(split2)__		while ((next = format.nextRecord(null)) != null) {_			assertEquals(7, next.length())__			count++__		}_		format.close()___		assertEquals(4, count)__	};tests,that,the,correct,number,of,records,is,read,when,the,split,boundary,is,exact,at,the,record,boundary;test,public,void,test,read,with,buffer,size,is,multiple,throws,ioexception,final,string,my,string,aaaaaaa,nbbbbbbb,nccccccc,nddddddd,n,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,set,buffer,size,2,int,split1,get,length,format,configure,parameters,string,next,int,count,0,format,open,split1,while,next,format,next,record,null,null,assert,equals,7,next,length,count,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,assert,equals,3,count,format,open,split2,while,next,format,next,record,null,null,assert,equals,7,next,length,count,format,close,assert,equals,4,count
DelimitedInputFormatTest -> @Test 	public void testReadWithBufferSizeIsMultiple() throws IOException;1518772855;Tests that the correct number of records is read when the split boundary is exact at the record boundary.;@Test_	public void testReadWithBufferSizeIsMultiple() throws IOException {_		final String myString = "aaaaaaa\nbbbbbbb\nccccccc\nddddddd\n"__		final FileInputSplit split = createTempFile(myString)___		FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__		FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___		final Configuration parameters = new Configuration()___		format.setBufferSize(2 * ((int) split1.getLength()))__		format.configure(parameters)___		String next__		int count = 0___		_		format.open(split1)__		while ((next = format.nextRecord(null)) != null) {_			assertEquals(7, next.length())__			count++__		}_		assertNull(format.nextRecord(null))__		assertTrue(format.reachedEnd())__		format.close()___		_		_		assertEquals(3, count)___		_		format.open(split2)__		while ((next = format.nextRecord(null)) != null) {_			assertEquals(7, next.length())__			count++__		}_		format.close()___		assertEquals(4, count)__	};tests,that,the,correct,number,of,records,is,read,when,the,split,boundary,is,exact,at,the,record,boundary;test,public,void,test,read,with,buffer,size,is,multiple,throws,ioexception,final,string,my,string,aaaaaaa,nbbbbbbb,nccccccc,nddddddd,n,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,set,buffer,size,2,int,split1,get,length,format,configure,parameters,string,next,int,count,0,format,open,split1,while,next,format,next,record,null,null,assert,equals,7,next,length,count,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,assert,equals,3,count,format,open,split2,while,next,format,next,record,null,null,assert,equals,7,next,length,count,format,close,assert,equals,4,count
DelimitedInputFormatTest -> @Test 	public void testReadWithBufferSizeIsMultple();1436793281;Tests that the correct number of records is read when the split boundary is exact at the record boundary.;@Test_	public void testReadWithBufferSizeIsMultple() {_		try {_			final String myString = "aaaaaaa\nbbbbbbb\nccccccc\nddddddd\n"__			final FileInputSplit split = createTempFile(myString)___			FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__			FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___			final Configuration parameters = new Configuration()___			format.setBufferSize(2 * ((int) split1.getLength()))__			format.configure(parameters)___			String next__			int count = 0___			_			format.open(split1)__			while ((next = format.nextRecord(null)) != null) {_				assertEquals(7, next.length())__				count++__			}_			assertNull(format.nextRecord(null))__			assertTrue(format.reachedEnd())__			format.close()__			_			_			_			assertEquals(3, count)___			_			format.open(split2)__			while ((next = format.nextRecord(null)) != null) {_				assertEquals(7, next.length())__				count++__			}_			format.close()___			assertEquals(4, count)__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};tests,that,the,correct,number,of,records,is,read,when,the,split,boundary,is,exact,at,the,record,boundary;test,public,void,test,read,with,buffer,size,is,multple,try,final,string,my,string,aaaaaaa,nbbbbbbb,nccccccc,nddddddd,n,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,set,buffer,size,2,int,split1,get,length,format,configure,parameters,string,next,int,count,0,format,open,split1,while,next,format,next,record,null,null,assert,equals,7,next,length,count,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,assert,equals,3,count,format,open,split2,while,next,format,next,record,null,null,assert,equals,7,next,length,count,format,close,assert,equals,4,count,catch,exception,e,e,print,stack,trace,fail,e,get,message
DelimitedInputFormatTest -> @Test 	public void testReadWithBufferSizeIsMultple();1469630409;Tests that the correct number of records is read when the split boundary is exact at the record boundary.;@Test_	public void testReadWithBufferSizeIsMultple() {_		try {_			final String myString = "aaaaaaa\nbbbbbbb\nccccccc\nddddddd\n"__			final FileInputSplit split = createTempFile(myString)___			FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__			FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___			final Configuration parameters = new Configuration()___			format.setBufferSize(2 * ((int) split1.getLength()))__			format.configure(parameters)___			String next__			int count = 0___			_			format.open(split1)__			while ((next = format.nextRecord(null)) != null) {_				assertEquals(7, next.length())__				count++__			}_			assertNull(format.nextRecord(null))__			assertTrue(format.reachedEnd())__			format.close()__			_			_			_			assertEquals(3, count)___			_			format.open(split2)__			while ((next = format.nextRecord(null)) != null) {_				assertEquals(7, next.length())__				count++__			}_			format.close()___			assertEquals(4, count)__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};tests,that,the,correct,number,of,records,is,read,when,the,split,boundary,is,exact,at,the,record,boundary;test,public,void,test,read,with,buffer,size,is,multple,try,final,string,my,string,aaaaaaa,nbbbbbbb,nccccccc,nddddddd,n,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,set,buffer,size,2,int,split1,get,length,format,configure,parameters,string,next,int,count,0,format,open,split1,while,next,format,next,record,null,null,assert,equals,7,next,length,count,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,assert,equals,3,count,format,open,split2,while,next,format,next,record,null,null,assert,equals,7,next,length,count,format,close,assert,equals,4,count,catch,exception,e,e,print,stack,trace,fail,e,get,message
DelimitedInputFormatTest -> @Test 	public void testReadWithBufferSizeIsMultple();1475688973;Tests that the correct number of records is read when the split boundary is exact at the record boundary.;@Test_	public void testReadWithBufferSizeIsMultple() {_		try {_			final String myString = "aaaaaaa\nbbbbbbb\nccccccc\nddddddd\n"__			final FileInputSplit split = createTempFile(myString)___			FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__			FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___			final Configuration parameters = new Configuration()___			format.setBufferSize(2 * ((int) split1.getLength()))__			format.configure(parameters)___			String next__			int count = 0___			_			format.open(split1)__			while ((next = format.nextRecord(null)) != null) {_				assertEquals(7, next.length())__				count++__			}_			assertNull(format.nextRecord(null))__			assertTrue(format.reachedEnd())__			format.close()__			_			_			_			assertEquals(3, count)___			_			format.open(split2)__			while ((next = format.nextRecord(null)) != null) {_				assertEquals(7, next.length())__				count++__			}_			format.close()___			assertEquals(4, count)__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};tests,that,the,correct,number,of,records,is,read,when,the,split,boundary,is,exact,at,the,record,boundary;test,public,void,test,read,with,buffer,size,is,multple,try,final,string,my,string,aaaaaaa,nbbbbbbb,nccccccc,nddddddd,n,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,set,buffer,size,2,int,split1,get,length,format,configure,parameters,string,next,int,count,0,format,open,split1,while,next,format,next,record,null,null,assert,equals,7,next,length,count,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,assert,equals,3,count,format,open,split2,while,next,format,next,record,null,null,assert,equals,7,next,length,count,format,close,assert,equals,4,count,catch,exception,e,e,print,stack,trace,fail,e,get,message
DelimitedInputFormatTest -> @Test 	public void testReadWithBufferSizeIsMultple();1481228508;Tests that the correct number of records is read when the split boundary is exact at the record boundary.;@Test_	public void testReadWithBufferSizeIsMultple() {_		try {_			final String myString = "aaaaaaa\nbbbbbbb\nccccccc\nddddddd\n"__			final FileInputSplit split = createTempFile(myString)___			FileInputSplit split1 = new FileInputSplit(0, split.getPath(), 0, split.getLength() / 2, split.getHostnames())__			FileInputSplit split2 = new FileInputSplit(1, split.getPath(), split1.getLength(), split.getLength(), split.getHostnames())___			final Configuration parameters = new Configuration()___			format.setBufferSize(2 * ((int) split1.getLength()))__			format.configure(parameters)___			String next__			int count = 0___			_			format.open(split1)__			while ((next = format.nextRecord(null)) != null) {_				assertEquals(7, next.length())__				count++__			}_			assertNull(format.nextRecord(null))__			assertTrue(format.reachedEnd())__			format.close()__			_			_			_			assertEquals(3, count)___			_			format.open(split2)__			while ((next = format.nextRecord(null)) != null) {_				assertEquals(7, next.length())__				count++__			}_			format.close()___			assertEquals(4, count)__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};tests,that,the,correct,number,of,records,is,read,when,the,split,boundary,is,exact,at,the,record,boundary;test,public,void,test,read,with,buffer,size,is,multple,try,final,string,my,string,aaaaaaa,nbbbbbbb,nccccccc,nddddddd,n,final,file,input,split,split,create,temp,file,my,string,file,input,split,split1,new,file,input,split,0,split,get,path,0,split,get,length,2,split,get,hostnames,file,input,split,split2,new,file,input,split,1,split,get,path,split1,get,length,split,get,length,split,get,hostnames,final,configuration,parameters,new,configuration,format,set,buffer,size,2,int,split1,get,length,format,configure,parameters,string,next,int,count,0,format,open,split1,while,next,format,next,record,null,null,assert,equals,7,next,length,count,assert,null,format,next,record,null,assert,true,format,reached,end,format,close,assert,equals,3,count,format,open,split2,while,next,format,next,record,null,null,assert,equals,7,next,length,count,format,close,assert,equals,4,count,catch,exception,e,e,print,stack,trace,fail,e,get,message
