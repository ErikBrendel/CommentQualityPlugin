commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Class<ManagedSEContainerConfiguration> getConfigurationClass() {     return ManagedSEContainerConfiguration.class. }
false;public;1;12;;public void setup(ManagedSEContainerConfiguration configuration) {     debugModeEnabled = configuration.isDebug().     host = configuration.getHost().     port = configuration.getPort().     materializedFiles = new ArrayList<>().     classpathDependencies = new ArrayList<>().     librariesPath = configuration.getLibrariesPath().     keepDeploymentArchives = configuration.isKeepDeploymentArchives().     additionalJavaOpts = initAdditionalJavaOpts(configuration.getAdditionalJavaOpts()).     configureLogging(configuration).     waitTime = configuration.getWaitTime() > 0 ? configuration.getWaitTime() : 10. }
false;private;1;11;;private List<String> initAdditionalJavaOpts(String opts) {     if (opts == null || opts.isEmpty()) {         return Collections.emptyList().     }     List<String> additionalOpts = new ArrayList<>().     for (String option : opts.split("\\s+")) {         additionalOpts.add(option).     }     return additionalOpts. }
false;private;1;7;;private void configureLogging(ManagedSEContainerConfiguration configuration) {     ConsoleHandler consoleHandler = new ConsoleHandler().     consoleHandler.setLevel(configuration.getLogLevel()).     LOGGER.setUseParentHandlers(false).     LOGGER.addHandler(consoleHandler).     LOGGER.setLevel(configuration.getLogLevel()). }
false;public;0;3;;@Override public void start() throws LifecycleException { }
false;public;0;3;;@Override public void stop() throws LifecycleException { }
false;public;0;4;;@Override public ProtocolDescription getDefaultProtocol() {     return new ProtocolDescription(CustomJMXProtocol.NAME). }
false;public;1;4;;@Override public void deploy(Descriptor descriptor) throws DeploymentException {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public void undeploy(Descriptor descriptor) throws DeploymentException {     throw new UnsupportedOperationException(). }
false;public;1;27;;@Override public void undeploy(Archive<?> archive) throws DeploymentException {     LOGGER.info("Undeploying " + archive.getName()).     if (!keepDeploymentArchives) {         for (File materializedFile : materializedFiles) {             if (materializedFile.isDirectory()) {                 try {                     FileDeploymentUtils.deleteRecursively(materializedFile.toPath()).                 } catch (IOException e) {                     LOGGER.warning("Could not delete materialized directory: " + materializedFile).                 }             } else {                 materializedFile.delete().             }         }     }     // Kill the subprocess (test JVM)     if (process != null) {         process.destroy().         try {             process.waitFor().         } catch (final InterruptedException e) {             Thread.interrupted().             throw new RuntimeException("Interrupted while awaiting server daemon process termination", e).         }     } }
false;public;1;66;;@Override public ProtocolMetaData deploy(final Archive<?> archive) throws DeploymentException {     LOGGER.info("Deploying " + archive.getName()).     // First of all clear the list of previously materialized deployments - otherwise the class path would grow indefinitely     materializedFiles.clear().     // Create a new classpath     classpathDependencies.clear().     if (ClassPath.isRepresentedBy(archive)) {         for (Node child : archive.get(ClassPath.ROOT_ARCHIVE_PATH).getChildren()) {             Asset asset = child.getAsset().             if (asset instanceof ArchiveAsset) {                 Archive<?> assetArchive = ((ArchiveAsset) asset).getArchive().                 if (ClassPathDirectory.isRepresentedBy(assetArchive)) {                     materializeDirectory(assetArchive).                 } else {                     materializeArchive(assetArchive).                 }             }         }     } else {         materializeArchive(archive).     }     Properties systemProperties = getSystemProperties(archive).     readJarFilesFromDirectory().     addTestResourcesDirectory(systemProperties).     List<String> processCommand = buildProcessCommand(systemProperties).     logExecutedCommand(processCommand).     // Launch the process     final ProcessBuilder processBuilder = new ProcessBuilder(processCommand).     String path = systemProperties.getProperty("container.user.dir").     if (path != null) {         processBuilder.directory(new File(path)).     }     processBuilder.environment().put("JAVA_HOME", new File(System.getProperty(SYSPROP_KEY_JAVA_HOME)).getAbsolutePath()).     processBuilder.redirectErrorStream(true).     processBuilder.redirectError(ProcessBuilder.Redirect.INHERIT).     processBuilder.redirectOutput(ProcessBuilder.Redirect.INHERIT).     try {         process = processBuilder.start().     } catch (final IOException e) {         throw new DeploymentException("Could not start process", e).     }     int finalWaitTime = debugModeEnabled ? (3 * waitTime) : waitTime.     // Wait for socket connection     if (!isServerStarted(host, port, finalWaitTime)) {         throw new DeploymentException("Child JVM process failed to start within " + finalWaitTime + " seconds.").     }     if (!isJMXTestRunnerMBeanRegistered(host, port, finalWaitTime)) {         throw new DeploymentException("JMXTestRunnerMBean not registered within " + finalWaitTime + " seconds.").     }     ProtocolMetaData protocolMetaData = new ProtocolMetaData().     protocolMetaData.addContext(new JMXContext(host, port)).     return protocolMetaData. }
false;private;1;13;;private Properties getSystemProperties(final Archive<?> archive) throws DeploymentException {     Node systemPropertiesNode = archive.get(ClassPath.SYSTEM_PROPERTIES_ARCHIVE_PATH).     if (systemPropertiesNode != null) {         try (InputStream in = systemPropertiesNode.getAsset().openStream()) {             Properties systemProperties = new Properties().             systemProperties.load(in).             return systemProperties.         } catch (IOException e) {             throw new DeploymentException("Could not load system properties", e).         }     }     return null. }
false;public;0;6;;@Override public Boolean call() throws Exception {     try (Socket ignored = new Socket(host, port)) {         return true.     } }
false;private;3;10;;private boolean isServerStarted(final String host, final int port, int waitTime) {     return new Await(waitTime, new Callable<Boolean>() {          @Override         public Boolean call() throws Exception {             try (Socket ignored = new Socket(host, port)) {                 return true.             }         }     }).start(). }
false;public;0;6;;@Override public Boolean call() throws Exception {     mbsc.getObjectInstance(new ObjectName(JMXTestRunnerMBean.OBJECT_NAME)).     LOGGER.fine("JMXTestRunnerMBean registered with the remote MBean server at: " + jmxServiceUrl).     return true. }
false;private;3;17;;private boolean isJMXTestRunnerMBeanRegistered(final String host, final int port, int waitTime) throws DeploymentException {     // Taken from org.jboss.arquillian.container.spi.client.protocol.metadata.JMXContext     final String jmxServiceUrl = "service:jmx:rmi:///jndi/rmi://" + host + ":" + port + "/jmxrmi".     try (JMXConnector jmxc = JMXConnectorFactory.connect(new JMXServiceURL(jmxServiceUrl), null)) {         final MBeanServerConnection mbsc = jmxc.getMBeanServerConnection().         return new Await(waitTime, new Callable<Boolean>() {              @Override             public Boolean call() throws Exception {                 mbsc.getObjectInstance(new ObjectName(JMXTestRunnerMBean.OBJECT_NAME)).                 LOGGER.fine("JMXTestRunnerMBean registered with the remote MBean server at: " + jmxServiceUrl).                 return true.             }         }).start().     } catch (IOException e) {         throw new DeploymentException("Could not verify JMXTestRunnerMBean registration", e).     } }
false;private;1;5;;private void materializeArchive(Archive<?> archive) {     File deploymentFile = new File(TARGET.concat(File.separator).concat(archive.getName())).     archive.as(ZipExporter.class).exportTo(deploymentFile, true).     materializedFiles.add(deploymentFile). }
false;private;1;28;;private void materializeDirectory(Archive<?> archive) throws DeploymentException {     if (archive.getContent().isEmpty()) {         // Do not materialize an empty directory         return.     }     File entryDirectory = new File(TARGET.concat(File.separator).concat(archive.getName())).     try {         if (entryDirectory.exists()) {             // Always delete previous content             FileDeploymentUtils.deleteContent(entryDirectory.toPath()).         } else {             if (!entryDirectory.mkdirs()) {                 throw new DeploymentException("Could not create class path directory: " + entryDirectory).             }         }         for (Node child : archive.get(ClassPath.ROOT_ARCHIVE_PATH).getChildren()) {             Asset asset = child.getAsset().             if (asset instanceof ClassAsset) {                 FileDeploymentUtils.materializeClass(entryDirectory, (ClassAsset) asset).             } else if (asset == null) {                 FileDeploymentUtils.materializeSubdirectories(entryDirectory, child).             }         }     } catch (IOException e) {         throw new DeploymentException("Could not materialize class path directory: " + archive.getName(), e).     }     materializedFiles.add(entryDirectory). }
false;private;1;34;;private List<String> buildProcessCommand(Properties properties) {     final List<String> command = new ArrayList<>().     final File javaHome = new File(System.getProperty(SYSPROP_KEY_JAVA_HOME)).     command.add(javaHome.getAbsolutePath() + File.separator + "bin" + File.separator + "java").     command.add("-cp").     StringBuilder builder = new StringBuilder().     Set<File> classPathEntries = new HashSet<>(materializedFiles).     classPathEntries.addAll(classpathDependencies).     for (Iterator<File> iterator = classPathEntries.iterator(). iterator.hasNext(). ) {         builder.append(iterator.next().getPath()).         if (iterator.hasNext()) {             builder.append(File.pathSeparator).         }     }     command.add(builder.toString()).     command.add("-Dcom.sun.management.jmxremote").     command.add("-Dcom.sun.management.jmxremote.port=" + port).     command.add("-Dcom.sun.management.jmxremote.authenticate=false").     command.add("-Dcom.sun.management.jmxremote.ssl=false").     if (debugModeEnabled) {         command.add(DEBUG_AGENT_STRING).     }     for (String option : additionalJavaOpts) {         command.add(option).     }     if (properties != null) {         for (Map.Entry<Object, Object> entry : properties.entrySet()) {             addSystemProperty(command, entry.getKey().toString(), entry.getValue().toString()).         }     }     command.add(SERVER_MAIN_CLASS_FQN).     return command. }
false;private;3;3;;private void addSystemProperty(List<String> command, String key, String value) {     command.add(SYSTEM_PROPERTY_SWITCH + key + EQUALS + value). }
false;public;2;4;;@Override public boolean accept(File dir, String name) {     return name.endsWith(".jar"). }
false;private;0;18;;private void readJarFilesFromDirectory() throws DeploymentException {     if (librariesPath == null) {         return.     }     File lib = new File(librariesPath).     if (!lib.exists() || lib.isFile()) {         throw new DeploymentException("Cannot read files from " + librariesPath).     }     File[] dep = lib.listFiles(new FilenameFilter() {          @Override         public boolean accept(File dir, String name) {             return name.endsWith(".jar").         }     }).     classpathDependencies.addAll(Arrays.asList(dep)). }
false;private;1;9;;private void addTestResourcesDirectory(Properties properties) throws DeploymentException {     String testResources = properties.getProperty("container.test.resources.dir").     if (testResources != null) {         File testDir = new File(testResources).         if (testDir.exists() && testDir.isDirectory()) {             classpathDependencies.add(testDir).         }     } }
false;private;1;10;;private void logExecutedCommand(List<String> processCommand) {     if (LOGGER.isLoggable(Level.FINE)) {         StringBuilder builder = new StringBuilder().         for (String s : processCommand) {             builder.append(s).             builder.append(" ").         }         LOGGER.log(Level.FINE, "Executing command: " + builder).     } }
