commented;modifiers;parameterAmount;loc;comment;code
false;public;0;78;;@Override public int read() throws IOException {     if (outputStream == null && !outputStreamClosed) {         // first run         outputStream = createOutputStream(bufferedOutputStream).     }     int value = bufferInputStream != null ? bufferInputStream.read() : -1.     if (value == -1) {         if (currentNodeStream != null) {             // current node was not processed completely             try {                 doCopy().                 bufferInputStream = new ByteArrayInputStream(bufferedOutputStream.toByteArray()).                 bufferedOutputStream.reset().                 return this.read().             } catch (final Throwable t) {                 throw new ArchiveExportException("Failed to write asset to output: " + currentPath.get(), t).             }         } else if (nodesIterator.hasNext()) {             // current node was processed completely, process next one             final Node currentNode = nodesIterator.next().             currentPath = currentNode.getPath().             final String pathName = PathUtil.optionallyRemovePrecedingSlash(currentPath.get()).             final boolean isDirectory = currentNode.getAsset() == null.             String resolvedPath = pathName.             if (isDirectory) {                 resolvedPath = PathUtil.optionallyAppendSlash(resolvedPath).                 startAsset(resolvedPath, 0L, 0L).                 endAsset().             } else {                 try {                     byte[] content = IOUtil.asByteArray(currentNode.getAsset().openStream()).                     long size = content.length.                     CRC32 crc = new CRC32().                     crc.update(content).                     long crc32Value = crc.getValue().                     startAsset(resolvedPath, size, crc32Value).                     currentNodeStream = new ByteArrayInputStream(content).                     doCopy().                 } catch (final Throwable t) {                     throw new ArchiveExportException("Failed to write asset to output: " + currentPath.get(), t).                 }                 bufferInputStream = new ByteArrayInputStream(bufferedOutputStream.toByteArray()).                 bufferedOutputStream.reset().             }         } else {             // each node was processed             if (!outputStreamClosed) {                 outputStream.close().                 outputStreamClosed = true.                 // output closed, now process what was saved on close                 bufferInputStream = new ByteArrayInputStream(bufferedOutputStream.toByteArray()).                 bufferedOutputStream.close().                 currentNodeStream = null.                 outputStream = null.                 return this.read().             }             // everything was read, end             return -1.         }         // chosen new node or new data in buffer - read again         return this.read().     }     return value. }
true;private;0;6;/**  * Performs copy operation between currentNodeStream and outputStream using buffer length.  *  * @throws IOException  */ ;/**  * Performs copy operation between currentNodeStream and outputStream using buffer length.  *  * @throws IOException  */ private void doCopy() throws IOException {     IOUtil.copy(currentNodeStream, outputStream).     currentNodeStream.close().     currentNodeStream = null.     endAsset(). }
true;private;3;3;/**  * Start entry in stream.  *  * @param path  * @throws IOException  */ ;/**  * Start entry in stream.  *  * @param path  * @throws IOException  */ private void startAsset(final String path, long size, long crc32) throws IOException {     putNextEntry(outputStream, path, size, crc32). }
true;private;0;3;/**  * Close entry in stream.  *  * @throws IOException  */ ;/**  * Close entry in stream.  *  * @throws IOException  */ private void endAsset() throws IOException {     closeEntry(outputStream). }
false;protected;1;6;;protected ZipOutputStream createOutputStream(final OutputStream outputStream) {     ZipOutputStream stream = new ZipOutputStream(outputStream).     stream.setMethod(ZipEntry.STORED).     stream.setLevel(Deflater.NO_COMPRESSION).     return stream. }
false;protected;1;3;;protected void closeEntry(final ZipOutputStream outputStream) throws IOException {     outputStream.closeEntry(). }
false;protected;4;9;;protected void putNextEntry(final ZipOutputStream outputStream, final String context, long size, long crc32) throws IOException {     ZipEntry entry = new ZipEntry(context).     entry.setMethod(ZipEntry.STORED).     entry.setSize(size).     entry.setCrc(crc32).     outputStream.putNextEntry(entry). }
