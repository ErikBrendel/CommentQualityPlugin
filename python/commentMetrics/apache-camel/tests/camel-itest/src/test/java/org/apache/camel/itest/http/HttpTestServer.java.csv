commented;modifiers;parameterAmount;loc;comment;code
true;protected;0;6;/**  * Obtains an HTTP protocol processor with default interceptors.  *  * @return  a protocol processor for server-side use  */ ;/**  * Obtains an HTTP protocol processor with default interceptors.  *  * @return  a protocol processor for server-side use  */ protected HttpProcessor newProcessor() {     return new ImmutableHttpProcessor(new HttpResponseInterceptor[] { new ResponseDate(), new ResponseServer(), new ResponseContent(), new ResponseConnControl() }). }
true;protected;0;11;/**  * Obtains a set of reasonable default parameters for a server.  *  * @return  default parameters  */ ;/**  * Obtains a set of reasonable default parameters for a server.  *  * @return  default parameters  */ protected HttpParams newDefaultParams() {     HttpParams params = new SyncBasicHttpParams().     params.setIntParameter(CoreConnectionPNames.SO_TIMEOUT, 60000).setIntParameter(CoreConnectionPNames.SOCKET_BUFFER_SIZE, 8 * 1024).setBooleanParameter(CoreConnectionPNames.STALE_CONNECTION_CHECK, false).setBooleanParameter(CoreConnectionPNames.TCP_NODELAY, true).setParameter(CoreProtocolPNames.ORIGIN_SERVER, "LocalTestServer/1.1").     return params. }
false;protected;0;3;;protected ConnectionReuseStrategy newConnectionReuseStrategy() {     return new DefaultConnectionReuseStrategy(). }
false;protected;0;3;;protected HttpResponseFactory newHttpResponseFactory() {     return new DefaultHttpResponseFactory(). }
true;public;0;3;/**  * Returns the number of connections this test server has accepted.  */ ;/**  * Returns the number of connections this test server has accepted.  */ public int getAcceptedConnectionCount() {     return acceptedConnections.get(). }
true;public;0;4;/**  * {@link #register Registers} a set of default request handlers.  * <pre>  * URI pattern      Handler  * -----------      -------  * /echo/*          {@link EchoHandler EchoHandler}  * /random/*        {@link RandomHandler RandomHandler}  * </pre>  */ ;/**  * {@link #register Registers} a set of default request handlers.  * <pre>  * URI pattern      Handler  * -----------      -------  * /echo/*          {@link EchoHandler EchoHandler}  * /random/*        {@link RandomHandler RandomHandler}  * </pre>  */ public void registerDefaultHandlers() {     handlerRegistry.register("/echo/*", new EchoHandler()).     handlerRegistry.register("/random/*", new RandomHandler()). }
true;public;2;3;/**  * Registers a handler with the local registry.  *  * @param pattern   the URL pattern to match  * @param handler   the handler to apply  */ ;/**  * Registers a handler with the local registry.  *  * @param pattern   the URL pattern to match  * @param handler   the handler to apply  */ public void register(String pattern, HttpRequestHandler handler) {     handlerRegistry.register(pattern, handler). }
true;public;1;3;/**  * Unregisters a handler from the local registry.  *  * @param pattern   the URL pattern  */ ;/**  * Unregisters a handler from the local registry.  *  * @param pattern   the URL pattern  */ public void unregister(String pattern) {     handlerRegistry.unregister(pattern). }
true;public;0;20;/**  * Starts this test server.  */ ;/**  * Starts this test server.  */ public void start() throws Exception {     if (servicedSocket != null) {         throw new IllegalStateException(this.toString() + " already running").     }     ServerSocket ssock.     if (sslcontext != null) {         SSLServerSocketFactory sf = sslcontext.getServerSocketFactory().         ssock = sf.createServerSocket().     } else {         ssock = new ServerSocket().     }     // probably pointless for port '0'     ssock.setReuseAddress(true).     ssock.bind(TEST_SERVER_ADDR).     servicedSocket = ssock.     listenerThread = new ListenerThread().     listenerThread.setDaemon(false).     listenerThread.start(). }
true;public;0;14;/**  * Stops this test server.  */ ;/**  * Stops this test server.  */ public void stop() throws Exception {     if (servicedSocket == null) {         // not running         return.     }     ListenerThread t = listenerThread.     if (t != null) {         t.shutdown().     }     synchronized (workers) {         for (Worker worker : workers) {             worker.shutdown().         }     } }
false;public;1;5;;public void awaitTermination(long timeMs) throws InterruptedException {     if (listenerThread != null) {         listenerThread.join(timeMs).     } }
false;public;0;12;;@Override public String toString() {     // avoid synchronization     ServerSocket ssock = servicedSocket.     StringBuilder sb = new StringBuilder(80).     sb.append("LocalTestServer/").     if (ssock == null) {         sb.append("stopped").     } else {         sb.append(ssock.getLocalSocketAddress()).     }     return sb.toString(). }
true;public;0;7;/**  * Obtains the local address the server is listening on  *  * @return the service address  */ ;/**  * Obtains the local address the server is listening on  *  * @return the service address  */ public InetSocketAddress getServiceAddress() {     // avoid synchronization     ServerSocket ssock = servicedSocket.     if (ssock == null) {         throw new IllegalStateException("not running").     }     return (InetSocketAddress) ssock.getLocalSocketAddress(). }
false;public;0;23;;@Override public void run() {     try {         while (!interrupted()) {             Socket socket = servicedSocket.accept().             acceptedConnections.incrementAndGet().             DefaultHttpServerConnection conn = new DefaultHttpServerConnection().             conn.bind(socket, httpservice.getParams()).             // Start worker thread             Worker worker = new Worker(conn).             workers.add(worker).             worker.setDaemon(true).             worker.start().         }     } catch (Exception ex) {         this.exception = ex.     } finally {         try {             servicedSocket.close().         } catch (IOException ignore) {         }     } }
false;public;0;7;;public void shutdown() {     interrupt().     try {         servicedSocket.close().     } catch (IOException ignore) {     } }
false;public;0;3;;public Exception getException() {     return this.exception. }
false;public;0;17;;@Override public void run() {     HttpContext context = new BasicHttpContext().     try {         while (this.conn.isOpen() && !Thread.interrupted()) {             httpservice.handleRequest(this.conn, context).         }     } catch (Exception ex) {         this.exception = ex.     } finally {         workers.remove(this).         try {             this.conn.shutdown().         } catch (IOException ignore) {         }     } }
false;public;0;7;;public void shutdown() {     interrupt().     try {         this.conn.shutdown().     } catch (IOException ignore) {     } }
false;public;0;3;;public Exception getException() {     return this.exception. }
