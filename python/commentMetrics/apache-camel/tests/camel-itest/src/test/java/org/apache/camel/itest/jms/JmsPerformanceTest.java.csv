commented;modifiers;parameterAmount;loc;comment;code
false;public;0;14;;@Test public void testSendingAndReceivingMessages() throws Exception {     log.info("Sending {} messages", getMessageCount()).     sendLoop(getMessageCount()).     log.info("Sending {} messages completed, now will assert on their content as well as the order of their receipt", getMessageCount()).     // should wait a bit to make sure all messages have been received by the MyBean#onMessage() method     // as this happens asynchronously, that's not inside the 'main' thread     Thread.sleep(3000).     assertExpectedMessagesReceived(). }
false;protected;0;3;;protected int getMessageCount() {     return 100. }
false;protected;1;5;;protected void sendLoop(int messageCount) {     for (int i = 1. i <= messageCount. i++) {         sendMessage(i).     } }
false;protected;1;3;;protected void sendMessage(int messageCount) {     template.sendBodyAndHeader("activemq:" + getQueueName(), "Hello:" + messageCount, "counter", messageCount). }
false;protected;0;3;;protected String getQueueName() {     return "testSendingAndReceivingMessages". }
false;protected;0;18;;protected void assertExpectedMessagesReceived() throws InterruptedException {     // assert on the expected message count     assertEquals("The expected message count does not match!", getMessageCount(), receivedMessages.size()).     // assert on the expected message order     List<Integer> expectedHeaders = new ArrayList<>(getMessageCount()).     for (int i = 1. i <= getMessageCount(). i++) {         expectedHeaders.add(i).     }     List<Object> expectedMessages = new ArrayList<>(getMessageCount()).     for (int i = 1. i <= getMessageCount(). i++) {         expectedMessages.add("Hello:" + i).     }     assertEquals("The expected header order does not match!", expectedHeaders, receivedHeaders).     assertEquals("The expected message order does not match!", expectedMessages, receivedMessages). }
false;protected;1;12;;@Override protected void bindToRegistry(Registry registry) throws Exception {     // add AMQ client and make use of connection pooling we depend on because of the (large) number     // of the JMS messages we do produce     // add ActiveMQ with embedded broker     ConnectionFactory connectionFactory = CamelJmsTestHelper.createConnectionFactory().     JmsComponent amq = jmsComponentAutoAcknowledge(connectionFactory).     amq.setCamelContext(context).     registry.bind("myBean", new MyBean()).     registry.bind("activemq", amq). }
false;public;0;3;;public void configure() {     from("activemq:" + getQueueName()).to("bean:myBean"). }
false;protected;0;8;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          public void configure() {             from("activemq:" + getQueueName()).to("bean:myBean").         }     }. }
false;public;2;5;;public void onMessage(@Header("counter") int counter, Object body) {     // the invocation of this method happens inside the same thread so no need for a thread-safe list here     receivedHeaders.add(counter).     receivedMessages.add(body). }
