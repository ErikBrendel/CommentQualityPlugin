commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Test public void testNetty() throws Exception {     String out = template.requestBody("netty:tcp://localhost:" + port + "?textline=true&sync=true", "World", String.class).     assertEquals("Bye World", out).     String out2 = template.requestBody("netty:tcp://localhost:" + port + "?textline=true&sync=true", "Camel", String.class).     assertEquals("Bye Camel", out2). }
false;public;0;6;;public String call() throws Exception {     String reply = template.requestBody("netty:tcp://localhost:" + port + "?textline=true&sync=true", index, String.class).     log.info("Sent {} received {}", index, reply).     assertEquals("Bye " + index, reply).     return reply. }
false;public;0;34;;@Ignore("TODO: investigate for Camel 3.0") @Test public void testConcurrent() throws Exception {     int size = 1000.     ExecutorService executor = Executors.newFixedThreadPool(20).     // we access the responses Map below only inside the main thread,     // so no need for a thread-safe Map implementation     Map<Integer, Future<String>> responses = new HashMap<>().     for (int i = 0. i < size. i++) {         final int index = i.         Future<String> out = executor.submit(new Callable<String>() {              public String call() throws Exception {                 String reply = template.requestBody("netty:tcp://localhost:" + port + "?textline=true&sync=true", index, String.class).                 log.info("Sent {} received {}", index, reply).                 assertEquals("Bye " + index, reply).                 return reply.             }         }).         responses.put(index, out).     }     // get all responses     Set<String> unique = new HashSet<>().     for (Future<String> future : responses.values()) {         String reply = future.get(120, TimeUnit.SECONDS).         assertNotNull("Should get a reply", reply).         unique.add(reply).     }     // should be 1000 unique responses     assertEquals("Should be " + size + " unique responses", size, unique.size()).     executor.shutdownNow(). }
false;public;0;11;;@Override public void configure() throws Exception {     port = AvailablePortFinder.getNextAvailable(8000).     from("netty:tcp://localhost:" + port + "?textline=true&sync=true&reuseAddress=true&synchronous=false").to("activemq:queue:foo").log("Writing reply ${body}").     from("activemq:queue:foo").transform(simple("Bye ${body}")). }
false;protected;0;16;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             port = AvailablePortFinder.getNextAvailable(8000).             from("netty:tcp://localhost:" + port + "?textline=true&sync=true&reuseAddress=true&synchronous=false").to("activemq:queue:foo").log("Writing reply ${body}").             from("activemq:queue:foo").transform(simple("Bye ${body}")).         }     }. }
false;protected;1;9;;@Override protected void bindToRegistry(Registry registry) throws Exception {     // add ActiveMQ with embedded broker     ConnectionFactory connectionFactory = CamelJmsTestHelper.createConnectionFactory().     JmsComponent amq = jmsComponentAutoAcknowledge(connectionFactory).     amq.setCamelContext(context).     registry.bind("activemq", amq). }
