commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Override public int read() throws IOException {     if (timeout.get()) {         // emulate a timeout occurring in _getReply()         throw new SocketTimeoutException().     }     return stream.read(). }
false;public;1;17;;@Override public InputStream answer(InvocationOnMock invocation) throws Throwable {     final InputStream stream = (InputStream) invocation.callRealMethod().     InputStream inputStream = new InputStream() {          @Override         public int read() throws IOException {             if (timeout.get()) {                 // emulate a timeout occurring in _getReply()                 throw new SocketTimeoutException().             }             return stream.read().         }     }.     return inputStream. }
false;public;1;11;;@Override public Object answer(InvocationOnMock invocation) throws Throwable {     if ((Integer) invocation.getArguments()[0] == CONNECT_TIMEOUT) {         // setting of connect timeout         timeout.set(true).     } else {         // non-connect timeout         timeout.set(false).     }     return invocation.callRealMethod(). }
false;public;1;47;;@Override public Socket answer(InvocationOnMock invocation) throws Throwable {     final Socket socket = spy(new Socket()).     final AtomicBoolean timeout = new AtomicBoolean().     try {         doAnswer(new Answer<InputStream>() {              @Override             public InputStream answer(InvocationOnMock invocation) throws Throwable {                 final InputStream stream = (InputStream) invocation.callRealMethod().                 InputStream inputStream = new InputStream() {                      @Override                     public int read() throws IOException {                         if (timeout.get()) {                             // emulate a timeout occurring in _getReply()                             throw new SocketTimeoutException().                         }                         return stream.read().                     }                 }.                 return inputStream.             }         }).when(socket).getInputStream().     } catch (IOException ignored) {     }     try {         doAnswer(new Answer<Object>() {              @Override             public Object answer(InvocationOnMock invocation) throws Throwable {                 if ((Integer) invocation.getArguments()[0] == CONNECT_TIMEOUT) {                     // setting of connect timeout                     timeout.set(true).                 } else {                     // non-connect timeout                     timeout.set(false).                 }                 return invocation.callRealMethod().             }         }).when(socket).setSoTimeout(anyInt()).     } catch (SocketException e) {         throw new RuntimeException(e).     }     return socket. }
false;public;0;9;;@Override @Before public void setUp() throws Exception {     fakeFtpServer = new FakeFtpServer().     fakeFtpServer.setServerControlPort(0).     fakeFtpServer.start().     super.setUp(). }
false;public;0;8;;@Override @After public void tearDown() throws Exception {     super.tearDown().     if (fakeFtpServer != null) {         fakeFtpServer.stop().     } }
false;private;0;5;;private FTPClient mockedClient() throws IOException {     FTPClient client = new FTPClient().     client.setSocketFactory(createSocketFactory()).     return client. }
false;private;0;5;;private SocketFactory createSocketFactory() throws IOException {     SocketFactory socketFactory = mock(SocketFactory.class).     when(socketFactory.createSocket()).thenAnswer(new SocketAnswer()).     return socketFactory. }
false;protected;0;6;;@Override protected JndiRegistry createRegistry() throws Exception {     JndiRegistry registry = super.createRegistry().     registry.bind("mocked", mockedClient()).     return registry. }
false;public;0;10;;@Test public void testReConnect() throws Exception {     // we should fail, but we are testing that we are not in a deadlock which could potentially happen     getMockEndpoint("mock:done").expectedMessageCount(0).     getMockEndpoint("mock:dead").expectedMessageCount(1).     sendBody("direct:start", "test").     assertMockEndpointsSatisfied(). }
false;public;0;13;;@Override public void configure() throws Exception {     errorHandler(deadLetterChannel("mock:dead")).     // using soTimeout=0 could potentially cause the ftp producer to dead-lock doing endless reconnection attempts     // this is a test to ensure we have fixed that     from("direct:start").to("ftp://localhost:" + fakeFtpServer.getServerControlPort() + "?ftpClient=#mocked" + "&soTimeout=0&" + "connectTimeout=" + CONNECT_TIMEOUT).to("mock:done"). }
false;protected;0;18;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             errorHandler(deadLetterChannel("mock:dead")).             // using soTimeout=0 could potentially cause the ftp producer to dead-lock doing endless reconnection attempts             // this is a test to ensure we have fixed that             from("direct:start").to("ftp://localhost:" + fakeFtpServer.getServerControlPort() + "?ftpClient=#mocked" + "&soTimeout=0&" + "connectTimeout=" + CONNECT_TIMEOUT).to("mock:done").         }     }. }
