commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;33;/**  * Parses the dumped route coverage data and creates a line by line coverage data  *  * @param directory  the directory with the dumped route coverage data  * @param routeId    the route id to gather, must not be null.  * @return line by line coverage data  */ ;/**  * Parses the dumped route coverage data and creates a line by line coverage data  *  * @param directory  the directory with the dumped route coverage data  * @param routeId    the route id to gather, must not be null.  * @return line by line coverage data  */ public static List<CoverageData> parseDumpRouteCoverageByRouteId(String directory, String routeId) throws Exception {     List<CoverageData> answer = new ArrayList<>().     if (routeId == null) {         return answer.     }     File[] files = new File(directory).listFiles(f -> f.getName().endsWith(".xml")).     if (files == null) {         return answer.     }     CamelCatalog catalog = new DefaultCamelCatalog(true).     for (File file : files) {         try (FileInputStream fis = new FileInputStream(file)) {             Document dom = XmlLineNumberParser.parseXml(fis).             NodeList routes = dom.getElementsByTagName("route").             for (int i = 0. i < routes.getLength(). i++) {                 Node route = routes.item(i).                 String id = route.getAttributes().getNamedItem("id").getNodeValue().                 String customId = route.getAttributes().getNamedItem("customId") != null ? route.getAttributes().getNamedItem("customId").getNodeValue() : "false".                 // must be the target route and the route must be explicit assigned with that route id (not anonymous route)                 if ("true".equals(customId) && routeId.equals(id)) {                     // parse each route and build a List<CoverageData> for line by line coverage data                     AtomicInteger counter = new AtomicInteger().                     parseRouteData(catalog, route, answer, counter).                 }             }         }     }     return answer. }
false;public,static;1;37;;public static Map<String, List<CoverageData>> parseDumpRouteCoverageByClassAndTestMethod(String directory) throws Exception {     Map<String, List<CoverageData>> answer = new LinkedHashMap<>().     File[] files = new File(directory).listFiles(f -> f.getName().endsWith(".xml")).     if (files == null) {         return answer.     }     CamelCatalog catalog = new DefaultCamelCatalog(true).     for (File file : files) {         try (FileInputStream fis = new FileInputStream(file)) {             Document dom = XmlLineNumberParser.parseXml(fis).             NodeList routes = dom.getElementsByTagName("route").             for (int i = 0. i < routes.getLength(). i++) {                 Node route = routes.item(i).                 // parse each route and build a List<CoverageData> for line by line coverage data                 AtomicInteger counter = new AtomicInteger().                 List<CoverageData> data = new ArrayList<>().                 parseRouteData(catalog, route, data, counter).                 // create a key which is based on the file name without extension                 String key = file.getName().                 // strip .xml extension                 key = key.substring(0, key.length() - 4).                 // is there existing data                 List<CoverageData> existing = answer.get(key).                 if (existing != null) {                     existing.addAll(data).                 } else {                     answer.put(key, data).                 }             }         }     }     return answer. }
false;private,static;4;49;;private static void parseRouteData(CamelCatalog catalog, Node node, List<CoverageData> data, AtomicInteger counter) {     // must be a known EIP model     String key = node.getNodeName().     // skip route as we use from instead     boolean valid = catalog.findModelNames().contains(key).     if (!valid) {         return.     }     // inlined error handler, on completion etc should be skipped (and currently not supported in route coverage)     boolean skip = "onException".equals(key) || "onCompletion".equals(key) || "intercept".equals(key) || "interceptFrom".equals(key) || "interceptSendToEndpoint".equals(key).     if (skip) {         return.     }     // only calculate for elements within the route or children of policy/transaction     if (!"route".equals(key) && !"policy".equals(key) && !"transacted".equals(key)) {         int count = 0.         Node total = node.getAttributes().getNamedItem("exchangesTotal").         if (total != null) {             count = Integer.parseInt(total.getNodeValue()).         }         CoverageData holder = data.size() > counter.get() ? data.get(counter.get()) : null.         if (holder != null && holder.getNode().equals(key)) {             count += holder.getCount().         }         if (holder == null) {             // add new             data.add(counter.get(), new CoverageData(key, count)).         } else {             // replace existing             data.set(counter.get(), new CoverageData(key, count)).         }         // advance counter         counter.incrementAndGet().     }     // any children     NodeList children = node.getChildNodes().     if (children != null) {         for (int i = 0. i < children.getLength(). i++) {             Node child = children.item(i).             if (child instanceof Element) {                 parseRouteData(catalog, child, data, counter).             }         }     } }
