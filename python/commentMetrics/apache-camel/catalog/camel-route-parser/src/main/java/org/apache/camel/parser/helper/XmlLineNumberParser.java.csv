commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Parses the XML.  *  * @param is the XML content as an input stream  * @return the DOM model  * @throws Exception is thrown if error parsing  */ ;/**  * Parses the XML.  *  * @param is the XML content as an input stream  * @return the DOM model  * @throws Exception is thrown if error parsing  */ public static Document parseXml(final InputStream is) throws Exception {     return parseXml(is, null, null). }
false;public;1;5;;@Override public void setDocumentLocator(final Locator locator) {     // Save the locator, so that it can be used later for line tracking when traversing nodes.     this.locator = locator.     this.found = rootNames == null. }
false;private;1;8;;private boolean isRootName(String qName) {     for (String root : rootNames.split(",")) {         if (qName.equals(root)) {             return true.         }     }     return false. }
false;public;4;62;;@Override public void startElement(final String uri, final String localName, final String qName, final Attributes attributes) throws SAXException {     addTextIfNeeded().     if (rootNames != null && !found) {         if (isRootName(qName)) {             found = true.         }     }     if (found) {         Element el.         if (forceNamespace != null) {             el = doc.createElementNS(forceNamespace, qName).         } else {             String ns = null.             // are we using namespace prefixes             int pos = qName.indexOf(':').             if (pos > 0) {                 if (attributes != null) {                     String prefix = qName.substring(0, pos).                     ns = attributes.getValue("xmlns:" + prefix).                     if (ns != null) {                         localNs.put(prefix, ns).                     } else {                         ns = localNs.get(prefix).                     }                 }             } else {                 // maybe there is an anonymous namespace (xmlns)                 if (attributes != null) {                     ns = attributes.getValue("xmlns").                     if (ns != null) {                         anonymousNs.put(qName, ns).                     } else if (!anonymousNs.isEmpty()) {                         // grab latest anonymous namespace to use as the namespace as                         // this child tag should use the parents+ namespace                         List<String> values = new ArrayList<>(anonymousNs.values()).                         ns = values.get(values.size() - 1).                     }                 }             }             if (ns != null) {                 el = doc.createElementNS(ns, qName).             } else {                 el = doc.createElement(qName).             }         }         if (attributes != null) {             for (int i = 0. i < attributes.getLength(). i++) {                 el.setAttribute(attributes.getQName(i), attributes.getValue(i)).             }         }         String ln = String.valueOf(this.locator.getLineNumber()).         String cn = String.valueOf(this.locator.getColumnNumber()).         el.setUserData(LINE_NUMBER, ln, null).         el.setUserData(COLUMN_NUMBER, cn, null).         elementStack.push(el).     } }
false;public;3;26;;@Override public void endElement(final String uri, final String localName, final String qName) {     if (!found) {         return.     }     addTextIfNeeded().     final Element closedEl = elementStack.isEmpty() ? null : elementStack.pop().     if (closedEl != null) {         if (elementStack.isEmpty()) {             // Is this the root element?             doc.appendChild(closedEl).         } else {             final Element parentEl = elementStack.peek().             parentEl.appendChild(closedEl).         }         String ln = String.valueOf(this.locator.getLineNumber()).         String cn = String.valueOf(this.locator.getColumnNumber()).         closedEl.setUserData(LINE_NUMBER_END, ln, null).         closedEl.setUserData(COLUMN_NUMBER_END, cn, null).     }     anonymousNs.remove(qName). }
false;public;3;4;;@Override public void characters(final char[] ch, final int start, final int length) throws SAXException {     textBuffer.append(ch, start, length). }
false;public;2;5;;@Override public InputSource resolveEntity(String publicId, String systemId) throws IOException, SAXException {     // do not resolve external dtd     return new InputSource(new StringReader("")). }
true;private;0;10;// Outputs text accumulated under the current node ;// Outputs text accumulated under the current node private void addTextIfNeeded() {     if (textBuffer.length() > 0) {         final Element el = elementStack.isEmpty() ? null : elementStack.peek().         if (el != null) {             final Node textNode = doc.createTextNode(textBuffer.toString()).             el.appendChild(textNode).             textBuffer.delete(0, textBuffer.length()).         }     } }
true;public,static;3;160;/**  * Parses the XML.  *  * @param is the XML content as an input stream  * @param rootNames one or more root names that is used as baseline for beginning the parsing, for example camelContext to start parsing  *                  when Camel is discovered. Multiple names can be defined separated by comma  * @param forceNamespace an optional namespace to force assign to each node. This may be needed for JAXB unmarshalling from XML -> POJO.  * @return the DOM model  * @throws Exception is thrown if error parsing  */ ;/**  * Parses the XML.  *  * @param is the XML content as an input stream  * @param rootNames one or more root names that is used as baseline for beginning the parsing, for example camelContext to start parsing  *                  when Camel is discovered. Multiple names can be defined separated by comma  * @param forceNamespace an optional namespace to force assign to each node. This may be needed for JAXB unmarshalling from XML -> POJO.  * @return the DOM model  * @throws Exception is thrown if error parsing  */ public static Document parseXml(final InputStream is, final String rootNames, final String forceNamespace) throws Exception {     final Document doc.     SAXParser parser.     final SAXParserFactory factory = SAXParserFactory.newInstance().     factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE).     parser = factory.newSAXParser().     final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance().     // turn off validator and loading external dtd     dbf.setValidating(false).     dbf.setNamespaceAware(true).     dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE).     dbf.setFeature("http://xml.org/sax/features/namespaces", false).     dbf.setFeature("http://xml.org/sax/features/validation", false).     dbf.setFeature("http://apache.org/xml/features/nonvalidating/load-dtd-grammar", false).     dbf.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false).     dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false).     dbf.setFeature("http://xml.org/sax/features/external-general-entities", false).     final DocumentBuilder docBuilder = dbf.newDocumentBuilder().     doc = docBuilder.newDocument().     final Stack<Element> elementStack = new Stack<>().     final StringBuilder textBuffer = new StringBuilder().     final DefaultHandler handler = new DefaultHandler() {          private Locator locator.          private boolean found.          private final Map<String, String> localNs = new HashMap<>().          private final Map<String, String> anonymousNs = new LinkedHashMap<>().          @Override         public void setDocumentLocator(final Locator locator) {             // Save the locator, so that it can be used later for line tracking when traversing nodes.             this.locator = locator.             this.found = rootNames == null.         }          private boolean isRootName(String qName) {             for (String root : rootNames.split(",")) {                 if (qName.equals(root)) {                     return true.                 }             }             return false.         }          @Override         public void startElement(final String uri, final String localName, final String qName, final Attributes attributes) throws SAXException {             addTextIfNeeded().             if (rootNames != null && !found) {                 if (isRootName(qName)) {                     found = true.                 }             }             if (found) {                 Element el.                 if (forceNamespace != null) {                     el = doc.createElementNS(forceNamespace, qName).                 } else {                     String ns = null.                     // are we using namespace prefixes                     int pos = qName.indexOf(':').                     if (pos > 0) {                         if (attributes != null) {                             String prefix = qName.substring(0, pos).                             ns = attributes.getValue("xmlns:" + prefix).                             if (ns != null) {                                 localNs.put(prefix, ns).                             } else {                                 ns = localNs.get(prefix).                             }                         }                     } else {                         // maybe there is an anonymous namespace (xmlns)                         if (attributes != null) {                             ns = attributes.getValue("xmlns").                             if (ns != null) {                                 anonymousNs.put(qName, ns).                             } else if (!anonymousNs.isEmpty()) {                                 // grab latest anonymous namespace to use as the namespace as                                 // this child tag should use the parents+ namespace                                 List<String> values = new ArrayList<>(anonymousNs.values()).                                 ns = values.get(values.size() - 1).                             }                         }                     }                     if (ns != null) {                         el = doc.createElementNS(ns, qName).                     } else {                         el = doc.createElement(qName).                     }                 }                 if (attributes != null) {                     for (int i = 0. i < attributes.getLength(). i++) {                         el.setAttribute(attributes.getQName(i), attributes.getValue(i)).                     }                 }                 String ln = String.valueOf(this.locator.getLineNumber()).                 String cn = String.valueOf(this.locator.getColumnNumber()).                 el.setUserData(LINE_NUMBER, ln, null).                 el.setUserData(COLUMN_NUMBER, cn, null).                 elementStack.push(el).             }         }          @Override         public void endElement(final String uri, final String localName, final String qName) {             if (!found) {                 return.             }             addTextIfNeeded().             final Element closedEl = elementStack.isEmpty() ? null : elementStack.pop().             if (closedEl != null) {                 if (elementStack.isEmpty()) {                     // Is this the root element?                     doc.appendChild(closedEl).                 } else {                     final Element parentEl = elementStack.peek().                     parentEl.appendChild(closedEl).                 }                 String ln = String.valueOf(this.locator.getLineNumber()).                 String cn = String.valueOf(this.locator.getColumnNumber()).                 closedEl.setUserData(LINE_NUMBER_END, ln, null).                 closedEl.setUserData(COLUMN_NUMBER_END, cn, null).             }             anonymousNs.remove(qName).         }          @Override         public void characters(final char[] ch, final int start, final int length) throws SAXException {             textBuffer.append(ch, start, length).         }          @Override         public InputSource resolveEntity(String publicId, String systemId) throws IOException, SAXException {             // do not resolve external dtd             return new InputSource(new StringReader("")).         }          // Outputs text accumulated under the current node         private void addTextIfNeeded() {             if (textBuffer.length() > 0) {                 final Element el = elementStack.isEmpty() ? null : elementStack.peek().                 if (el != null) {                     final Node textNode = doc.createTextNode(textBuffer.toString()).                     el.appendChild(textNode).                     textBuffer.delete(0, textBuffer.length()).                 }             }         }     }.     parser.parse(is, handler).     return doc. }
