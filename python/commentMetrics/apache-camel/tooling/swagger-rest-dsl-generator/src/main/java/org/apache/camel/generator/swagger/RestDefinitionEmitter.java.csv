commented;modifiers;parameterAmount;loc;comment;code
false;public;2;20;;@Override public CodeEmitter<RestsDefinition> emit(final String method, final Object... args) {     try {         final Class<? extends Object> type = variable.getClass().         final Object[] arguments = argumentsFor(args).         final Method declaredMethod = type.getMethod(method, parameterTypesOf(arguments)).         variable = declaredMethod.invoke(variable, arguments).     } catch (final Throwable e) {         if (e instanceof RuntimeException) {             throw (RuntimeException) e.         } else {             throw new IllegalStateException(e).         }     }     return this. }
false;public;0;4;;@Override public RestsDefinition result() {     return definition. }
false;;1;13;;Object[] argumentsFor(final Object[] args) {     final List<Object> arguments = new ArrayList<>(args.length).     for (final Object arg : args) {         if (arg instanceof String[]) {             arguments.add(Arrays.stream((String[]) arg).collect(Collectors.joining(","))).         } else {             arguments.add(arg).         }     }     return arguments.toArray(new Object[arguments.size()]). }
false;;1;9;;Class<?>[] parameterTypesOf(final Object[] args) {     final Class<?>[] parameterTypes = new Class<?>[args.length].     for (int i = 0. i < args.length. i++) {         parameterTypes[i] = args[i].getClass().     }     return parameterTypes. }
false;;1;9;;Class<?>[] typesOf(final Object[] args) {     final Class<?>[] types = new Class<?>[args.length].     for (int i = 0. i < types.length. i++) {         types[i] = args[i].getClass().     }     return types. }
