commented;modifiers;parameterAmount;loc;comment;code
false;public;0;19;;public void run() {     try {         beforeBootstrapCamel().         getLog().info("Starting Camel ...").         Method main = Thread.currentThread().getContextClassLoader().loadClass(mainClass).getMethod("main", String[].class).         main.invoke(null, new Object[] { arguments }).         afterBootstrapCamel().     } catch (Exception e) {         // just pass it on         // let it be printed so end users can see the exception on the console         getLog().error("*************************************").         getLog().error("Error occurred while running main from: " + mainClass).         getLog().error(e).         getLog().error("*************************************").         Thread.currentThread().getThreadGroup().uncaughtException(Thread.currentThread(), e).     } }
true;public;0;181;/**  * Execute goal.  *  * @throws MojoExecutionException execution of the main class or one of the  *                 threads it generated failed.  * @throws MojoFailureException something bad happened...  */ ;/**  * Execute goal.  *  * @throws MojoExecutionException execution of the main class or one of the  *                 threads it generated failed.  * @throws MojoFailureException something bad happened...  */ public void execute() throws MojoExecutionException, MojoFailureException {     String skip = System.getProperties().getProperty("maven.test.skip").     if (skip == null || "false".equals(skip)) {         // lets log a INFO about how to skip tests if you want to so you can run faster         getLog().info("You can skip tests from the command line using: mvn camel:run -Dmaven.test.skip=true").     }     boolean usingSpringJavaConfigureMain = false.     boolean useCdiMain.     if (useCDI != null) {         // use configured value         useCdiMain = useCDI.     } else {         // auto detect if we have cdi         useCdiMain = detectCDIOnClassPath().     }     boolean usingBlueprintMain.     if (useBlueprint != null) {         // use configured value         usingBlueprintMain = useBlueprint.     } else {         // auto detect if we have blueprint         usingBlueprintMain = detectBlueprintOnClassPathOrBlueprintXMLFiles().     }     // lets create the command line arguments to pass in...     List<String> args = new ArrayList<>().     if (trace) {         args.add("-t").     }     if (fileWatcherDirectory != null) {         args.add("-watch").         args.add(fileWatcherDirectory).     }     if (applicationContextUri != null) {         args.add("-ac").         args.add(applicationContextUri).     } else if (fileApplicationContextUri != null) {         args.add("-fa").         args.add(fileApplicationContextUri).     }     if (configClasses != null) {         args.add("-cc").         args.add(configClasses).         usingSpringJavaConfigureMain = true.     }     if (basedPackages != null) {         args.add("-bp").         args.add(basedPackages).         usingSpringJavaConfigureMain = true.     }     if (!duration.equals("-1")) {         args.add("-d").         args.add(duration).     }     if (!durationIdle.equals("-1")) {         args.add("-di").         args.add(durationIdle).     }     if (!durationMaxMessages.equals("-1")) {         args.add("-dm").         args.add(durationMaxMessages).     }     if (arguments != null) {         args.addAll(Arrays.asList(arguments)).     }     if (usingSpringJavaConfigureMain) {         mainClass = "org.apache.camel.spring.javaconfig.Main".         getLog().info("Using org.apache.camel.spring.javaconfig.Main to initiate a CamelContext").     } else if (useCdiMain) {         mainClass = "org.apache.camel.cdi.Main".         // must include plugin dependencies for cdi         extraPluginDependencyArtifactId = "camel-cdi".         getLog().info("Using " + mainClass + " to initiate a CamelContext").     } else if (usingBlueprintMain) {         mainClass = "org.apache.camel.test.blueprint.Main".         // must include plugin dependencies for blueprint         extraPluginDependencyArtifactId = "camel-test-blueprint".         // set the configAdmin pid         if (configAdminPid != null) {             args.add("-pid").             args.add(configAdminPid).         }         // set the configAdmin pFile         if (configAdminFileName != null) {             args.add("-pf").             args.add(configAdminFileName).         }         getLog().info("Using org.apache.camel.test.blueprint.Main to initiate a CamelContext").     } else if (mainClass != null) {         getLog().info("Using custom " + mainClass + " to initiate a CamelContext").     } else {         // use spring by default         getLog().info("Using org.apache.camel.spring.Main to initiate a CamelContext").         mainClass = "org.apache.camel.spring.Main".     }     arguments = new String[args.size()].     args.toArray(arguments).     if (getLog().isDebugEnabled()) {         StringBuilder msg = new StringBuilder("Invoking: ").         msg.append(mainClass).         msg.append(".main(").         for (int i = 0. i < arguments.length. i++) {             if (i > 0) {                 msg.append(", ").             }             msg.append(arguments[i]).         }         msg.append(")").         getLog().debug(msg).     }     final ClassLoader loader = getClassLoader().     IsolatedThreadGroup threadGroup = new IsolatedThreadGroup(mainClass).     final Thread bootstrapThread = new Thread(threadGroup, new Runnable() {          public void run() {             try {                 beforeBootstrapCamel().                 getLog().info("Starting Camel ...").                 Method main = Thread.currentThread().getContextClassLoader().loadClass(mainClass).getMethod("main", String[].class).                 main.invoke(null, new Object[] { arguments }).                 afterBootstrapCamel().             } catch (Exception e) {                 // just pass it on                 // let it be printed so end users can see the exception on the console                 getLog().error("*************************************").                 getLog().error("Error occurred while running main from: " + mainClass).                 getLog().error(e).                 getLog().error("*************************************").                 Thread.currentThread().getThreadGroup().uncaughtException(Thread.currentThread(), e).             }         }     }, mainClass + ".main()").     bootstrapThread.setContextClassLoader(loader).     setSystemProperties().     bootstrapThread.start().     joinNonDaemonThreads(threadGroup).     // threads) has been triggered.     if (keepAlive) {         getLog().warn("Warning: keepAlive is now deprecated and obsolete. Do you need it? Please comment on MEXEC-6.").         waitFor(0).     }     if (cleanupDaemonThreads) {         terminateThreads(threadGroup).         try {             threadGroup.destroy().         } catch (IllegalThreadStateException e) {             getLog().warn("Couldn't destroy threadgroup " + threadGroup, e).         }     }     if (originalSystemProperties != null) {         System.setProperties(originalSystemProperties).     }     synchronized (threadGroup) {         if (threadGroup.uncaughtException != null) {             throw new MojoExecutionException(null, threadGroup.uncaughtException).         }     }     registerSourceRoots(). }
true;protected;0;3;/**  * Allows plugin extensions to do custom logic before bootstrapping Camel.  */ ;/**  * Allows plugin extensions to do custom logic before bootstrapping Camel.  */ protected void beforeBootstrapCamel() throws Exception { // noop }
true;protected;0;3;/**  * Allows plugin extensions to do custom logic after bootstrapping Camel.  */ ;/**  * Allows plugin extensions to do custom logic after bootstrapping Camel.  */ protected void afterBootstrapCamel() throws Exception { // noop }
false;public;2;18;;public void uncaughtException(Thread thread, Throwable throwable) {     if (throwable instanceof ThreadDeath) {         // harmless         return.     }     boolean doLog = false.     synchronized (this) {         // only remember the first one         if (uncaughtException == null) {             // will be reported             uncaughtException = throwable.         // eventually         } else {             doLog = true.         }     }     if (doLog) {         getLog().warn("an additional exception was thrown", throwable).     } }
false;private;1;15;;private void joinNonDaemonThreads(ThreadGroup threadGroup) {     boolean foundNonDaemon.     do {         foundNonDaemon = false.         Collection<Thread> threads = getActiveThreads(threadGroup).         for (Thread thread : threads) {             if (thread.isDaemon()) {                 continue.             }             // try again. maybe more threads were             foundNonDaemon = true.             // created while we were busy             joinThread(thread, 0).         }     } while (foundNonDaemon). }
false;private;2;15;;private void joinThread(Thread thread, long timeoutMsecs) {     try {         getLog().debug("joining on thread " + thread).         thread.join(timeoutMsecs).     } catch (InterruptedException e) {         // good practice if don't throw         Thread.currentThread().interrupt().         // not         getLog().warn("interrupted while joining against thread " + thread, e).     // expected!     }     // generally abnormal     if (thread.isAlive()) {         getLog().warn("thread " + thread + " was interrupted but is still alive after waiting at least " + timeoutMsecs + "msecs").     } }
false;private;1;62;;private void terminateThreads(ThreadGroup threadGroup) {     long startTime = System.currentTimeMillis().     // these were not responsive     Set<Thread> uncooperativeThreads = new HashSet<>().     // to interruption     for (Collection<Thread> threads = getActiveThreads(threadGroup). !threads.isEmpty(). threads = getActiveThreads(threadGroup), threads.removeAll(uncooperativeThreads)) {         // or if something else interrupted it ( isInterrupted() ).         for (Thread thread : threads) {             getLog().debug("interrupting thread " + thread).             thread.interrupt().         }         // right)         for (Thread thread : threads) {             if (!thread.isAlive()) {                 // and, presumably it won't show up in                 continue.             // getActiveThreads() next iteration             }             if (daemonThreadJoinTimeout <= 0) {                 // waits until not alive. no timeout                 joinThread(thread, 0).                 continue.             }             long timeout = daemonThreadJoinTimeout - (System.currentTimeMillis() - startTime).             if (timeout > 0) {                 joinThread(thread, timeout).             }             if (!thread.isAlive()) {                 continue.             }             // ensure we don't process             uncooperativeThreads.add(thread).             // again             if (stopUnresponsiveDaemonThreads) {                 getLog().warn("thread " + thread + " will be Thread.stop()'ed").                 thread.stop().             } else {                 getLog().warn("thread " + thread + " will linger despite being asked to die via interruption").             }         }     }     if (!uncooperativeThreads.isEmpty()) {         getLog().warn("NOTE: " + uncooperativeThreads.size() + " thread(s) did not finish despite being asked to " + " via interruption. This is not a problem with exec:java, it is a problem with the running code." + " Although not serious, it should be remedied.").     } else {         int activeCount = threadGroup.activeCount().         if (activeCount != 0) {             // TODO this may be nothing. continue on anyway. perhaps don't             // even log in future             Thread[] threadsArray = new Thread[1].             threadGroup.enumerate(threadsArray).             if (getLog().isDebugEnabled()) {                 getLog().debug("strange. " + activeCount + " thread(s) still active in the group " + threadGroup + " such as " + threadsArray[0]).             }         }     } }
false;private;1;10;;private Collection<Thread> getActiveThreads(ThreadGroup threadGroup) {     Thread[] threads = new Thread[threadGroup.activeCount()].     int numThreads = threadGroup.enumerate(threads).     Collection<Thread> result = new ArrayList<>(numThreads).     for (int i = 0. i < threads.length && threads[i] != null. i++) {         result.add(threads[i]).     }     // note: result should be modifiable     return result. }
true;private;0;9;/**  * Pass any given system properties to the java system properties.  */ ;/**  * Pass any given system properties to the java system properties.  */ private void setSystemProperties() {     if (systemProperties != null) {         originalSystemProperties = System.getProperties().         for (Property systemProperty : systemProperties) {             String value = systemProperty.getValue().             System.setProperty(systemProperty.getKey(), value == null ? "" : value).         }     } }
false;private;0;11;;@SuppressWarnings("unchecked") private boolean detectCDIOnClassPath() {     List<Dependency> deps = project.getCompileDependencies().     for (Dependency dep : deps) {         if ("org.apache.camel".equals(dep.getGroupId()) && "camel-cdi".equals(dep.getArtifactId())) {             getLog().info("camel-cdi detected on classpath").             return true.         }     }     return false. }
false;private;0;22;;@SuppressWarnings("unchecked") private boolean detectBlueprintOnClassPathOrBlueprintXMLFiles() {     List<Dependency> deps = project.getCompileDependencies().     for (Dependency dep : deps) {         if ("org.apache.camel".equals(dep.getGroupId()) && "camel-blueprint".equals(dep.getArtifactId())) {             getLog().info("camel-blueprint detected on classpath").         }     }     // maybe there is blueprint XML files     List<Resource> resources = project.getResources().     for (Resource res : resources) {         File dir = new File(res.getDirectory()).         File xml = new File(dir, "OSGI-INF/blueprint").         if (xml.exists() && xml.isDirectory()) {             getLog().info("OSGi Blueprint XML files detected in directory " + xml).             return true.         }     }     return false. }
true;private;0;17;/**  * Set up a classloader for the execution of the main class.  *  * @return the classloader  * @throws MojoExecutionException  */ ;/**  * Set up a classloader for the execution of the main class.  *  * @return the classloader  * @throws MojoExecutionException  */ private ClassLoader getClassLoader() throws MojoExecutionException {     Set<URL> classpathURLs = new LinkedHashSet<>().     // project classpath must be first     this.addRelevantProjectDependenciesToClasspath(classpathURLs).     // and extra plugin classpath     this.addExtraPluginDependenciesToClasspath(classpathURLs).     // and plugin classpath last     this.addRelevantPluginDependenciesToClasspath(classpathURLs).     if (logClasspath) {         getLog().info("Classpath:").         for (URL url : classpathURLs) {             getLog().info("  " + url.getFile().toString()).         }     }     return new URLClassLoader(classpathURLs.toArray(new URL[classpathURLs.size()])). }
true;private;1;28;/**  * Add any relevant project dependencies to the classpath. Indirectly takes  * includePluginDependencies and ExecutableDependency into consideration.  *  * @param path classpath of {@link java.net.URL} objects  * @throws MojoExecutionException  */ ;/**  * Add any relevant project dependencies to the classpath. Indirectly takes  * includePluginDependencies and ExecutableDependency into consideration.  *  * @param path classpath of {@link java.net.URL} objects  * @throws MojoExecutionException  */ private void addRelevantPluginDependenciesToClasspath(Set<URL> path) throws MojoExecutionException {     if (hasCommandlineArgs()) {         arguments = parseCommandlineArgs().     }     try {         Iterator<Artifact> iter = this.determineRelevantPluginDependencies().iterator().         while (iter.hasNext()) {             Artifact classPathElement = iter.next().             // java.lang.NoClassDefFoundError: org.osgi.vendor.framework property not set             if (classPathElement.getArtifactId().equals("org.osgi.core")) {                 if (getLog().isDebugEnabled()) {                     getLog().debug("Skipping org.osgi.core -> " + classPathElement.getGroupId() + "/" + classPathElement.getArtifactId() + "/" + classPathElement.getVersion()).                 }                 continue.             }             getLog().debug("Adding plugin dependency artifact: " + classPathElement.getArtifactId() + " to classpath").             path.add(classPathElement.getFile().toURI().toURL()).         }     } catch (MalformedURLException e) {         throw new MojoExecutionException("Error during setting up classpath", e).     } }
true;private;1;30;/**  * Add any relevant project dependencies to the classpath. Indirectly takes  * includePluginDependencies and ExecutableDependency into consideration.  *  * @param path classpath of {@link java.net.URL} objects  * @throws MojoExecutionException  */ ;/**  * Add any relevant project dependencies to the classpath. Indirectly takes  * includePluginDependencies and ExecutableDependency into consideration.  *  * @param path classpath of {@link java.net.URL} objects  * @throws MojoExecutionException  */ private void addExtraPluginDependenciesToClasspath(Set<URL> path) throws MojoExecutionException {     if (extraPluginDependencyArtifactId == null && extendedPluginDependencyArtifactId == null) {         return.     }     try {         Set<Artifact> artifacts = new HashSet<>(this.pluginDependencies).         for (Artifact artifact : artifacts) {             // must             if (artifact.getArtifactId().equals(extraPluginDependencyArtifactId) || artifact.getArtifactId().equals(extendedPluginDependencyArtifactId)) {                 getLog().debug("Adding extra plugin dependency artifact: " + artifact.getArtifactId() + " to classpath").                 path.add(artifact.getFile().toURI().toURL()).                 // add the transient dependencies of this artifact                 Set<Artifact> deps = resolveExecutableDependencies(artifact, true).                 if (deps != null) {                     for (Artifact dep : deps) {                         getLog().debug("Adding extra plugin dependency artifact: " + dep.getArtifactId() + " to classpath").                         path.add(dep.getFile().toURI().toURL()).                     }                 }             }         }     } catch (MalformedURLException e) {         throw new MojoExecutionException("Error during setting up classpath", e).     } }
true;private;1;34;/**  * Add any relevant project dependencies to the classpath. Takes  * includeProjectDependencies into consideration.  *  * @param path classpath of {@link java.net.URL} objects  * @throws MojoExecutionException  */ ;/**  * Add any relevant project dependencies to the classpath. Takes  * includeProjectDependencies into consideration.  *  * @param path classpath of {@link java.net.URL} objects  * @throws MojoExecutionException  */ private void addRelevantProjectDependenciesToClasspath(Set<URL> path) throws MojoExecutionException {     if (this.includeProjectDependencies) {         try {             getLog().debug("Project Dependencies will be included.").             URL mainClasses = new File(project.getBuild().getOutputDirectory()).toURI().toURL().             getLog().debug("Adding to classpath : " + mainClasses).             path.add(mainClasses).             Set<Artifact> dependencies = CastUtils.cast(project.getArtifacts()).             // system scope dependencies are not returned by maven 2.0. See             // MEXEC-17             dependencies.addAll(getAllNonTestScopedDependencies()).             Iterator<Artifact> iter = dependencies.iterator().             while (iter.hasNext()) {                 Artifact classPathElement = iter.next().                 getLog().debug("Adding project dependency artifact: " + classPathElement.getArtifactId() + " to classpath").                 File file = classPathElement.getFile().                 if (file != null) {                     path.add(file.toURI().toURL()).                 }             }         } catch (MalformedURLException e) {             throw new MojoExecutionException("Error during setting up classpath", e).         }     } else {         getLog().debug("Project Dependencies will be excluded.").     } }
false;private;0;12;;private Collection<Artifact> getAllNonTestScopedDependencies() throws MojoExecutionException {     List<Artifact> answer = new ArrayList<>().     for (Artifact artifact : getAllDependencies()) {         // do not add test artifacts         if (!artifact.getScope().equals(Artifact.SCOPE_TEST)) {             answer.add(artifact).         }     }     return answer. }
true;private;0;48;// generic method to retrieve all the transitive dependencies ;// generic method to retrieve all the transitive dependencies private Collection<Artifact> getAllDependencies() throws MojoExecutionException {     List<Artifact> artifacts = new ArrayList<>().     for (Iterator<?> dependencies = project.getDependencies().iterator(). dependencies.hasNext(). ) {         Dependency dependency = (Dependency) dependencies.next().         String groupId = dependency.getGroupId().         String artifactId = dependency.getArtifactId().         VersionRange versionRange.         try {             versionRange = VersionRange.createFromVersionSpec(dependency.getVersion()).         } catch (InvalidVersionSpecificationException e) {             throw new MojoExecutionException("unable to parse version", e).         }         String type = dependency.getType().         if (type == null) {             type = "jar".         }         String classifier = dependency.getClassifier().         boolean optional = dependency.isOptional().         String scope = dependency.getScope().         if (scope == null) {             scope = Artifact.SCOPE_COMPILE.         }         Artifact art = this.artifactFactory.createDependencyArtifact(groupId, artifactId, versionRange, type, classifier, scope, null, optional).         if (scope.equalsIgnoreCase(Artifact.SCOPE_SYSTEM)) {             art.setFile(new File(dependency.getSystemPath())).         }         List<String> exclusions = new ArrayList<>().         for (Exclusion exclusion : dependency.getExclusions()) {             exclusions.add(exclusion.getGroupId() + ":" + exclusion.getArtifactId()).         }         ArtifactFilter newFilter = new ExcludesArtifactFilter(exclusions).         art.setDependencyFilter(newFilter).         artifacts.add(art).     }     return artifacts. }
true;private;0;36;/**  * Determine all plugin dependencies relevant to the executable. Takes  * includePlugins, and the executableDependency into consideration.  *  * @return a set of Artifact objects. (Empty set is returned if there are no  *         relevant plugin dependencies.)  * @throws MojoExecutionException  */ ;/**  * Determine all plugin dependencies relevant to the executable. Takes  * includePlugins, and the executableDependency into consideration.  *  * @return a set of Artifact objects. (Empty set is returned if there are no  *         relevant plugin dependencies.)  * @throws MojoExecutionException  */ private Set<Artifact> determineRelevantPluginDependencies() throws MojoExecutionException {     Set<Artifact> relevantDependencies.     if (this.includePluginDependencies) {         if (this.executableDependency == null) {             getLog().debug("All Plugin Dependencies will be included.").             relevantDependencies = new HashSet<>(this.pluginDependencies).         } else {             getLog().debug("Selected plugin Dependencies will be included.").             Artifact executableArtifact = this.findExecutableArtifact().             Artifact executablePomArtifact = this.getExecutablePomArtifact(executableArtifact).             relevantDependencies = this.resolveExecutableDependencies(executablePomArtifact, false).         }     } else {         getLog().debug("Only Direct Plugin Dependencies will be included.").         PluginDescriptor descriptor = (PluginDescriptor) getPluginContext().get("pluginDescriptor").         try {             relevantDependencies = artifactResolver.resolveTransitively(MavenMetadataSource.createArtifacts(this.artifactFactory, descriptor.getPlugin().getDependencies(), null, null, null), this.project.getArtifact(), Collections.emptyMap(), this.localRepository, this.remoteRepositories, metadataSource, new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME), Collections.emptyList()).getArtifacts().         } catch (Exception ex) {             throw new MojoExecutionException("Encountered problems resolving dependencies of the plugin " + "in preparation for its execution.", ex).         }     }     return relevantDependencies. }
true;private;1;4;/**  * Get the artifact which refers to the POM of the executable artifact.  *  * @param executableArtifact this artifact refers to the actual assembly.  * @return an artifact which refers to the POM of the executable artifact.  */ ;/**  * Get the artifact which refers to the POM of the executable artifact.  *  * @param executableArtifact this artifact refers to the actual assembly.  * @return an artifact which refers to the POM of the executable artifact.  */ private Artifact getExecutablePomArtifact(Artifact executableArtifact) {     return this.artifactFactory.createBuildArtifact(executableArtifact.getGroupId(), executableArtifact.getArtifactId(), executableArtifact.getVersion(), "pom"). }
true;protected;0;20;/**  * Examine the plugin dependencies to find the executable artifact.  *  * @return an artifact which refers to the actual executable tool (not a POM)  * @throws MojoExecutionException  */ ;/**  * Examine the plugin dependencies to find the executable artifact.  *  * @return an artifact which refers to the actual executable tool (not a POM)  * @throws MojoExecutionException  */ protected Artifact findExecutableArtifact() throws MojoExecutionException {     // ILimitedArtifactIdentifier execToolAssembly =     // this.getExecutableToolAssembly().     Artifact executableTool = null.     for (Artifact pluginDep : this.pluginDependencies) {         if (this.executableDependency.matches(pluginDep)) {             executableTool = pluginDep.             break.         }     }     if (executableTool == null) {         throw new MojoExecutionException("No dependency of the plugin matches the specified executableDependency." + "  Specified executableToolAssembly is: " + executableDependency.toString()).     }     return executableTool. }
false;private;2;40;;private Set<Artifact> resolveExecutableDependencies(Artifact executablePomArtifact, boolean ignoreFailures) throws MojoExecutionException {     Set<Artifact> executableDependencies = null.     try {         MavenProject executableProject = this.projectBuilder.buildFromRepository(executablePomArtifact, this.remoteRepositories, this.localRepository).         // get all of the dependencies for the executable project         List<Dependency> dependencies = executableProject.getDependencies().         // make Artifacts of all the dependencies         Set<Artifact> dependencyArtifacts = MavenMetadataSource.createArtifacts(this.artifactFactory, dependencies, null, null, null).         // not forgetting the Artifact of the project itself         dependencyArtifacts.add(executableProject.getArtifact()).         // resolve runtime dependencies transitively to obtain a comprehensive list of assemblies         ArtifactResolutionResult result = artifactResolver.resolveTransitively(dependencyArtifacts, executablePomArtifact, Collections.emptyMap(), this.localRepository, this.remoteRepositories, metadataSource, new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME), Collections.emptyList()).         executableDependencies = CastUtils.cast(result.getArtifacts()).     } catch (Exception ex) {         if (ignoreFailures) {             getLog().debug("Ignoring maven resolving dependencies failure " + ex.getMessage()).         } else {             throw new MojoExecutionException("Encountered problems resolving dependencies of the executable " + "in preparation for its execution.", ex).         }     }     return executableDependencies. }
true;private;1;11;/**  * Stop program execution for nn millis.  *  * @param millis the number of millis-seconds to wait for, <code>0</code>  *                stops program forever.  */ ;/**  * Stop program execution for nn millis.  *  * @param millis the number of millis-seconds to wait for, <code>0</code>  *                stops program forever.  */ private void waitFor(long millis) {     Object lock = new Object().     synchronized (lock) {         try {             lock.wait(millis).         } catch (InterruptedException e) {             // good practice if don't throw             Thread.currentThread().interrupt().             getLog().warn("Spuriously interrupted while waiting for " + millis + "ms", e).         }     } }
