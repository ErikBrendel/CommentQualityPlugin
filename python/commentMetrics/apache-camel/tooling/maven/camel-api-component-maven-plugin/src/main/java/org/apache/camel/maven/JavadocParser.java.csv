commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;public void reset() {     parserState = ParserState.INIT.     methodWithTypes = null.     methodTextBuilder = new StringBuilder().     methods.clear().     methodText.clear().     errorMessage = null. }
false;protected;1;55;;@Override protected void startTag(TagElement tag) throws ChangedCharSetException {     super.startTag(tag).     final HTML.Tag htmlTag = tag.getHTMLTag().     if (htmlTag != null) {         if (HTML.Tag.A.equals(htmlTag)) {             final SimpleAttributeSet attributes = getAttributes().             final Object name = attributes.getAttribute(HTML.Attribute.NAME).             final Object id = attributes.getAttribute(HTML.Attribute.ID).             if (name != null || id != null) {                 final String nameAttr = (String) name.                 final String idAttr = (String) id.                 if (parserState == ParserState.INIT && ("method_summary".equals(nameAttr) || "method.summary".equals(nameAttr) || "method_summary".equals(idAttr) || "method.summary".equals(idAttr))) {                     parserState = ParserState.METHOD_SUMMARY.                 } else if (parserState == ParserState.METHOD) {                     if (methodWithTypes == null) {                         final String hrefAttr = (String) attributes.getAttribute(HTML.Attribute.HREF).                         if (hrefAttr != null && (hrefAttr.contains(hrefPattern) || hrefAttr.charAt(0) == '#')) {                             // unescape HTML                             String methodSignature = hrefAttr.substring(hrefAttr.indexOf('#') + 1).                             final int firstHyphen = methodSignature.indexOf('-').                             if (firstHyphen != -1) {                                 final int lastHyphen = methodSignature.lastIndexOf('-').                                 methodSignature = methodSignature.substring(0, firstHyphen) + "(" + methodSignature.substring(firstHyphen + 1, lastHyphen) + ")".                                 methodSignature = methodSignature.replaceAll("-", ",").                             }                             // support varargs                             if (methodSignature.contains("...)")) {                                 methodSignature = methodSignature.replaceAll("\\.\\.\\.\\)", "[])").                             }                             // map Java8 array types                             if (methodSignature.contains(":A")) {                                 methodSignature = methodSignature.replaceAll(":A", "[]").                             }                             methodWithTypes = unescapeHtml(methodSignature).                         }                     } else {                         final String title = (String) attributes.getAttribute(HTML.Attribute.TITLE).                         if (title != null) {                             // append package name to type name text                             methodTextBuilder.append(title.substring(title.lastIndexOf(' '))).append('.').                         }                     }                 }             }         } else if (parserState == ParserState.METHOD_SUMMARY && HTML.Tag.CODE.equals(htmlTag)) {             parserState = ParserState.METHOD.         }     } }
false;private,static;1;10;;private static String unescapeHtml(String htmlString) {     String result = StringEscapeUtils.unescapeHtml(htmlString).replaceAll(NON_BREAKING_SPACE, " ").replaceAll(JAVA6_NON_BREAKING_SPACE, " ").     try {         result = URLDecoder.decode(result, "UTF-8").     } catch (UnsupportedEncodingException ignored) {     }     return result. }
false;protected;1;21;;@Override protected void handleEmptyTag(TagElement tag) {     if (parserState == ParserState.METHOD && HTML.Tag.CODE.equals(tag.getHTMLTag())) {         if (methodWithTypes != null) {             // process collected method data             methods.add(methodWithTypes).             this.methodText.put(methodWithTypes, getArgSignature()).             // clear the text builder for next method             methodTextBuilder.delete(0, methodTextBuilder.length()).             methodWithTypes = null.         }         parserState = ParserState.METHOD_SUMMARY.     } else if (parserState == ParserState.METHOD_SUMMARY && !methods.isEmpty() && HTML.Tag.TABLE.equals(tag.getHTMLTag())) {         // end of method summary table         parserState = ParserState.INIT.     } }
false;private;0;14;;private String getArgSignature() {     final String typeString = methodWithTypes.substring(methodWithTypes.indexOf('(') + 1, methodWithTypes.indexOf(')')).     if (typeString.isEmpty()) {         return "()".     }     // unescape HTML method text     String plainText = unescapeHtml(methodTextBuilder.toString()).     // support varargs     if (plainText.contains("...")) {         plainText = plainText.replaceAll("\\.\\.\\.", "[]").     }     return plainText.substring(plainText.indexOf('('), plainText.indexOf(')') + 1). }
false;protected;1;6;;@Override protected void handleText(char[] text) {     if (parserState == ParserState.METHOD && methodWithTypes != null) {         methodTextBuilder.append(text).     } }
false;protected;2;6;;@Override protected void handleError(int ln, String msg) {     if (msg.startsWith("exception ")) {         this.errorMessage = "Exception parsing Javadoc line " + ln + ": " + msg.     } }
false;public;0;3;;public String getErrorMessage() {     return errorMessage. }
false;public;0;3;;public List<String> getMethods() {     return methods. }
false;public;0;3;;public Map<String, String> getMethodText() {     return methodText. }
