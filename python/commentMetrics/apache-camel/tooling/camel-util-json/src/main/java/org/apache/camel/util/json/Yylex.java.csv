commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;6;;private static int[] zzUnpackAction() {     int[] result = new int[45].     int offset = 0.     offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result).     return result. }
false;private,static;3;13;;private static int zzUnpackAction(String packed, int offset, int[] result) {     int i = 0.     /* index in packed string */     int j = offset.     /* index in unpacked array */     int l = packed.length().     while (i < l) {         int count = packed.charAt(i++).         int value = packed.charAt(i++).         do {             result[j++] = value.         } while (--count > 0).     }     return j. }
false;private,static;0;6;;private static int[] zzUnpackRowMap() {     int[] result = new int[45].     int offset = 0.     offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result).     return result. }
false;private,static;3;10;;private static int zzUnpackRowMap(String packed, int offset, int[] result) {     int i = 0.     /* index in packed string */     int j = offset.     /* index in unpacked array */     int l = packed.length().     while (i < l) {         int high = packed.charAt(i++) << 16.         result[j++] = high | packed.charAt(i++).     }     return j. }
false;private,static;0;6;;private static int[] zzUnpackAttribute() {     int[] result = new int[45].     int offset = 0.     offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result).     return result. }
false;private,static;3;13;;private static int zzUnpackAttribute(String packed, int offset, int[] result) {     int i = 0.     /* index in packed string */     int j = offset.     /* index in unpacked array */     int l = packed.length().     while (i < l) {         int count = packed.charAt(i++).         int value = packed.charAt(i++).         do {             result[j++] = value.         } while (--count > 0).     }     return j. }
false;;0;3;;int getPosition() {     return yychar. }
true;private,static;1;13;/**  * Unpacks the compressed character translation table.  *  * @param packed the packed character translation table  * @return the unpacked character translation table  */ ;/**  * Unpacks the compressed character translation table.  *  * @param packed the packed character translation table  * @return the unpacked character translation table  */ private static char[] zzUnpackCMap(String packed) {     char[] map = new char[0x10000].     int i = 0.     /* index in packed string */     int j = 0.     /* index in unpacked array */     while (i < 90) {         int count = packed.charAt(i++).         char value = packed.charAt(i++).         do {             map[j++] = value.         } while (--count > 0).     }     return map. }
true;private;0;43;/**  * Refills the input buffer.  *  * @return <code>false</code>, iff there was new input.  * @exception java.io.IOException if any I/O-Error occurs  */ ;/**  * Refills the input buffer.  *  * @return <code>false</code>, iff there was new input.  * @exception java.io.IOException if any I/O-Error occurs  */ private boolean zzRefill() throws java.io.IOException {     /* first: make room (if you can) */     if (zzStartRead > 0) {         System.arraycopy(zzBuffer, zzStartRead, zzBuffer, 0, zzEndRead - zzStartRead).         /* translate stored positions */         zzEndRead -= zzStartRead.         zzCurrentPos -= zzStartRead.         zzMarkedPos -= zzStartRead.         zzStartRead = 0.     }     /* is the buffer big enough? */     if (zzCurrentPos >= zzBuffer.length) {         /* if not: blow it up */         char[] newBuffer = new char[zzCurrentPos * 2].         System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length).         zzBuffer = newBuffer.     }     /* finally: fill the buffer with new input */     int numRead = zzReader.read(zzBuffer, zzEndRead, zzBuffer.length - zzEndRead).     if (numRead > 0) {         zzEndRead += numRead.         return false.     }     // stream     if (numRead == 0) {         int c = zzReader.read().         if (c == -1) {             return true.         } else {             zzBuffer[zzEndRead++] = (char) c.             return false.         }     }     // numRead < 0     return true. }
true;public,final;0;8;/**  * Closes the input stream.  */ ;/**  * Closes the input stream.  */ public final void yyclose() throws java.io.IOException {     zzAtEOF = true.     /* indicate end of file */     zzEndRead = zzStartRead.     if (zzReader != null) {         zzReader.close().     } }
true;public,final;1;10;/**  * Resets the scanner to read from a new input stream. Does not close the  * old reader. All internal variables are reset, the old input stream  * <b>cannot</b> be reused (internal buffer is discarded and lost). Lexical  * state is set to <tt>ZZ_INITIAL</tt>.  *  * @param reader the new input stream  */ ;/**  * Resets the scanner to read from a new input stream. Does not close the  * old reader. All internal variables are reset, the old input stream  * <b>cannot</b> be reused (internal buffer is discarded and lost). Lexical  * state is set to <tt>ZZ_INITIAL</tt>.  *  * @param reader the new input stream  */ public final void yyreset(java.io.Reader reader) {     zzReader = reader.     zzAtBOL = true.     zzAtEOF = false.     zzEOFDone = false.     zzEndRead = zzStartRead = 0.     zzCurrentPos = zzMarkedPos = 0.     yyline = yychar = yycolumn = 0.     zzLexicalState = YYINITIAL. }
true;public,final;0;3;/**  * Returns the current lexical state.  */ ;/**  * Returns the current lexical state.  */ public final int yystate() {     return zzLexicalState. }
true;public,final;1;3;/**  * Enters a new lexical state  *  * @param newState the new lexical state  */ ;/**  * Enters a new lexical state  *  * @param newState the new lexical state  */ public final void yybegin(int newState) {     zzLexicalState = newState. }
true;public,final;0;3;/**  * Returns the text matched by the current regular expression.  */ ;/**  * Returns the text matched by the current regular expression.  */ public final String yytext() {     return new String(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead). }
true;public,final;1;3;/**  * Returns the character at position <tt>pos</tt> from the matched text. It  * is equivalent to yytext().charAt(pos), but faster  *  * @param pos the position of the character to fetch. A value from 0 to  *            yylength()-1.  * @return the character at position pos  */ ;/**  * Returns the character at position <tt>pos</tt> from the matched text. It  * is equivalent to yytext().charAt(pos), but faster  *  * @param pos the position of the character to fetch. A value from 0 to  *            yylength()-1.  * @return the character at position pos  */ public final char yycharat(int pos) {     return zzBuffer[zzStartRead + pos]. }
true;public,final;0;3;/**  * Returns the length of the matched text region.  */ ;/**  * Returns the length of the matched text region.  */ public final int yylength() {     return zzMarkedPos - zzStartRead. }
true;private;1;10;/**  * Reports an error that occured while scanning. In a wellformed scanner (no  * or only correct usage of yypushback(int) and a match-all fallback rule)  * this method will only be called with things that "Can't Possibly Happen".  * If this method is called, something is seriously wrong (e.g. a JFlex bug  * producing a faulty scanner etc.). Usual syntax/scanner level error  * handling should be done in error fallback rules.  *  * @param errorCode the code of the errormessage to display  */ ;/**  * Reports an error that occured while scanning. In a wellformed scanner (no  * or only correct usage of yypushback(int) and a match-all fallback rule)  * this method will only be called with things that "Can't Possibly Happen".  * If this method is called, something is seriously wrong (e.g. a JFlex bug  * producing a faulty scanner etc.). Usual syntax/scanner level error  * handling should be done in error fallback rules.  *  * @param errorCode the code of the errormessage to display  */ private void zzScanError(int errorCode) {     String message.     try {         message = ZZ_ERROR_MSG[errorCode].     } catch (ArrayIndexOutOfBoundsException e) {         message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR].     }     throw new Error(message). }
true;public;1;7;/**  * Pushes the specified amount of characters back into the input stream.  * They will be read again by then next call of the scanning method  *  * @param number the number of characters to be read again. This number must  *            not be greater than yylength()!  */ ;/**  * Pushes the specified amount of characters back into the input stream.  * They will be read again by then next call of the scanning method  *  * @param number the number of characters to be read again. This number must  *            not be greater than yylength()!  */ public void yypushback(int number) {     if (number > yylength()) {         zzScanError(ZZ_PUSHBACK_2BIG).     }     zzMarkedPos -= number. }
true;public;0;210;// CHECKSTYLE:OFF ;/**  * Resumes scanning until the next regular expression is matched, the end of  * input is encountered or an I/O-Error occurs.  *  * @return the next token  * @exception java.io.IOException if any I/O-Error occurs  */ // CHECKSTYLE:OFF public Yytoken yylex() throws java.io.IOException, DeserializationException {     int zzInput.     int zzAction.     // cached fields:     int zzCurrentPosL.     int zzMarkedPosL.     int zzEndReadL = zzEndRead.     char[] zzBufferL = zzBuffer.     char[] zzCMapL = ZZ_CMAP.     int[] zzTransL = ZZ_TRANS.     int[] zzRowMapL = ZZ_ROWMAP.     int[] zzAttrL = ZZ_ATTRIBUTE.     while (true) {         zzMarkedPosL = zzMarkedPos.         yychar += zzMarkedPosL - zzStartRead.         zzAction = -1.         zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL.         zzState = ZZ_LEXSTATE[zzLexicalState].         zzForAction: {             while (true) {                 if (zzCurrentPosL < zzEndReadL) {                     zzInput = zzBufferL[zzCurrentPosL++].                 } else if (zzAtEOF) {                     zzInput = YYEOF.                     break zzForAction.                 } else {                     // store back cached positions                     zzCurrentPos = zzCurrentPosL.                     zzMarkedPos = zzMarkedPosL.                     boolean eof = zzRefill().                     // get translated positions and possibly new buffer                     zzCurrentPosL = zzCurrentPos.                     zzMarkedPosL = zzMarkedPos.                     zzBufferL = zzBuffer.                     zzEndReadL = zzEndRead.                     if (eof) {                         zzInput = YYEOF.                         break zzForAction.                     } else {                         zzInput = zzBufferL[zzCurrentPosL++].                     }                 }                 int zzNext = zzTransL[zzRowMapL[zzState] + zzCMapL[zzInput]].                 if (zzNext == -1) {                     break zzForAction.                 }                 zzState = zzNext.                 int zzAttributes = zzAttrL[zzState].                 if ((zzAttributes & 1) == 1) {                     zzAction = zzState.                     zzMarkedPosL = zzCurrentPosL.                     if ((zzAttributes & 8) == 8)                         break zzForAction.                 }             }         }         // store back cached position         zzMarkedPos = zzMarkedPosL.         switch(zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {             case 4:                 {                     sb = null.                     sb = new StringBuilder().                     yybegin(STRING_BEGIN).                 }             case 24:                 break.             case 11:                 {                     sb.append(yytext()).                 }             case 25:                 break.             case 5:                 {                     return new Yytoken(Yytoken.Types.LEFT_BRACE, null).                 }             case 26:                 break.             case 16:                 {                     sb.append('\b').                 }             case 27:                 break.             case 23:                 {                     try {                         int ch = Integer.parseInt(yytext().substring(2), 16).                         sb.append((char) ch).                     } catch (Exception e) {                         /*                      * The lexer is broken if it can build a 4 byte character                      * code and fail to append the character.                      */                         throw new DeserializationException(yychar, DeserializationException.Problems.UNEXPECTED_EXCEPTION, e).                     }                 }             case 28:                 break.             case 22:                 {                     Boolean val = Boolean.valueOf(yytext()).                     return new Yytoken(Yytoken.Types.DATUM, val).                 }             case 29:                 break.             case 12:                 {                     sb.append('\\').                 }             case 30:                 break.             case 10:                 {                     return new Yytoken(Yytoken.Types.COLON, null).                 }             case 31:                 break.             case 9:                 {                     return new Yytoken(Yytoken.Types.COMMA, null).                 }             case 32:                 break.             case 21:                 {                     return new Yytoken(Yytoken.Types.DATUM, null).                 }             case 33:                 break.             case 19:                 {                     sb.append('\r').                 }             case 34:                 break.             case 15:                 {                     sb.append('/').                 }             case 35:                 break.             case 2:                 {                     java.math.BigDecimal val = new java.math.BigDecimal(yytext()).                     return new Yytoken(Yytoken.Types.DATUM, val).                 }             case 36:                 break.             case 14:                 {                     sb.append('"').                 }             case 37:                 break.             case 8:                 {                     return new Yytoken(Yytoken.Types.RIGHT_SQUARE, null).                 }             case 38:                 break.             case 17:                 {                     sb.append('\f').                 }             case 39:                 break.             case 1:                 {                     throw new DeserializationException(yychar, DeserializationException.Problems.UNEXPECTED_CHARACTER, new Character(yycharat(0))).                 }             case 40:                 break.             case 6:                 {                     return new Yytoken(Yytoken.Types.RIGHT_BRACE, null).                 }             case 41:                 break.             case 20:                 {                     sb.append('\t').                 }             case 42:                 break.             case 7:                 {                     return new Yytoken(Yytoken.Types.LEFT_SQUARE, null).                 }             case 43:                 break.             case 18:                 {                     sb.append('\n').                 }             case 44:                 break.             case 13:                 {                     yybegin(YYINITIAL).                     return new Yytoken(Yytoken.Types.DATUM, sb.toString()).                 }             case 45:                 break.             case 3:                 {                 }             case 46:                 break.             default:                 if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {                     zzAtEOF = true.                     return null.                 } else {                     zzScanError(ZZ_NO_MATCH).                 }         }     } }
