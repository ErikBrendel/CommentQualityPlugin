commented;modifiers;parameterAmount;loc;comment;code
false;public,static;6;80;;public static String findJavaDoc(Elements elementUtils, Element element, String fieldName, String name, TypeElement classElement, boolean builderPattern) {     String answer = null.     if (element != null) {         answer = elementUtils.getDocComment(element).     }     if (isNullOrEmpty(answer)) {         ExecutableElement setter = findSetter(fieldName, classElement).         if (setter != null) {             String doc = elementUtils.getDocComment(setter).             if (!isNullOrEmpty(doc)) {                 answer = doc.             }         }         // lets find the getter         if (answer == null) {             ExecutableElement getter = findGetter(fieldName, classElement).             if (getter != null) {                 String doc = elementUtils.getDocComment(getter).                 if (!isNullOrEmpty(doc)) {                     answer = doc.                 }             }         }         // lets try builder pattern         if (answer == null && builderPattern) {             List<ExecutableElement> methods = ElementFilter.methodsIn(classElement.getEnclosedElements()).             // lets try the builder pattern using annotation name (optional) as the method name             if (name != null) {                 for (ExecutableElement method : methods) {                     String methodName = method.getSimpleName().toString().                     if (name.equals(methodName) && method.getParameters().size() == 1) {                         String doc = elementUtils.getDocComment(method).                         if (!isNullOrEmpty(doc)) {                             answer = doc.                             break.                         }                     }                 }                 // so lets try those as well                 for (ExecutableElement method : methods) {                     String methodName = method.getSimpleName().toString().                     if (name.equals(methodName) && method.getParameters().size() == 0) {                         String doc = elementUtils.getDocComment(method).                         if (!isNullOrEmpty(doc)) {                             answer = doc.                             break.                         }                     }                 }             }             // lets try builder pattern using fieldName as the method name             for (ExecutableElement method : methods) {                 String methodName = method.getSimpleName().toString().                 if (fieldName.equals(methodName) && method.getParameters().size() == 1) {                     String doc = elementUtils.getDocComment(method).                     if (!isNullOrEmpty(doc)) {                         answer = doc.                         break.                     }                 }             }             // so lets try those as well             for (ExecutableElement method : methods) {                 String methodName = method.getSimpleName().toString().                 if (fieldName.equals(methodName) && method.getParameters().size() == 0) {                     String doc = elementUtils.getDocComment(method).                     if (!isNullOrEmpty(doc)) {                         answer = doc.                         break.                     }                 }             }         }     }     return answer. }
false;public,static;2;16;;public static ExecutableElement findSetter(String fieldName, TypeElement classElement) {     String setter = "set" + fieldName.substring(0, 1).toUpperCase().     if (fieldName.length() > 1) {         setter += fieldName.substring(1).     }     // lets find the setter     List<ExecutableElement> methods = ElementFilter.methodsIn(classElement.getEnclosedElements()).     for (ExecutableElement method : methods) {         String methodName = method.getSimpleName().toString().         if (setter.equals(methodName) && method.getParameters().size() == 1 && method.getReturnType().getKind().equals(TypeKind.VOID)) {             return method.         }     }     return null. }
false;public,static;2;20;;public static ExecutableElement findGetter(String fieldName, TypeElement classElement) {     String getter1 = "get" + fieldName.substring(0, 1).toUpperCase().     if (fieldName.length() > 1) {         getter1 += fieldName.substring(1).     }     String getter2 = "is" + fieldName.substring(0, 1).toUpperCase().     if (fieldName.length() > 1) {         getter2 += fieldName.substring(1).     }     // lets find the getter     List<ExecutableElement> methods = ElementFilter.methodsIn(classElement.getEnclosedElements()).     for (ExecutableElement method : methods) {         String methodName = method.getSimpleName().toString().         if ((getter1.equals(methodName) || getter2.equals(methodName)) && method.getParameters().size() == 0) {             return method.         }     }     return null. }
false;public,static;2;14;;public static VariableElement findFieldElement(TypeElement classElement, String fieldName) {     if (isNullOrEmpty(fieldName)) {         return null.     }     List<VariableElement> fields = ElementFilter.fieldsIn(classElement.getEnclosedElements()).     for (VariableElement field : fields) {         if (fieldName.equals(field.getSimpleName().toString())) {             return field.         }     }     return null. }
false;public,static;3;39;;public static TypeElement findTypeElement(ProcessingEnvironment processingEnv, RoundEnvironment roundEnv, String className) {     if (isNullOrEmpty(className) || "java.lang.Object".equals(className)) {         return null.     }     Set<? extends Element> rootElements = roundEnv.getRootElements().     for (Element rootElement : rootElements) {         if (rootElement instanceof TypeElement) {             TypeElement typeElement = (TypeElement) rootElement.             String aRootName = canonicalClassName(typeElement.getQualifiedName().toString()).             if (className.equals(aRootName)) {                 return typeElement.             }         }     }     // fallback using package name     Elements elementUtils = processingEnv.getElementUtils().     int idx = className.lastIndexOf('.').     if (idx > 0) {         String packageName = className.substring(0, idx).         PackageElement pe = elementUtils.getPackageElement(packageName).         if (pe != null) {             List<? extends Element> enclosedElements = getEnclosedElements(pe).             for (Element rootElement : enclosedElements) {                 if (rootElement instanceof TypeElement) {                     TypeElement typeElement = (TypeElement) rootElement.                     String aRootName = canonicalClassName(typeElement.getQualifiedName().toString()).                     if (className.equals(aRootName)) {                         return typeElement.                     }                 }             }         }     }     return null. }
false;public,static;1;10;;@SuppressWarnings("unchecked") public static List<? extends Element> getEnclosedElements(PackageElement pe) {     // some components like hadoop/spark has bad classes that causes javac scanning issues     try {         return pe.getEnclosedElements().     } catch (Throwable e) {     // ignore     }     return Collections.EMPTY_LIST. }
false;public,static;4;21;;public static void findTypeElementChildren(ProcessingEnvironment processingEnv, RoundEnvironment roundEnv, Set<TypeElement> found, String superClassName) {     Elements elementUtils = processingEnv.getElementUtils().     int idx = superClassName.lastIndexOf('.').     if (idx > 0) {         String packageName = superClassName.substring(0, idx).         PackageElement pe = elementUtils.getPackageElement(packageName).         if (pe != null) {             List<? extends Element> enclosedElements = pe.getEnclosedElements().             for (Element rootElement : enclosedElements) {                 if (rootElement instanceof TypeElement) {                     TypeElement typeElement = (TypeElement) rootElement.                     String aSuperClassName = canonicalClassName(typeElement.getSuperclass().toString()).                     if (superClassName.equals(aSuperClassName)) {                         found.add(typeElement).                     }                 }             }         }     } }
false;public,static;4;20;;public static boolean hasSuperClass(ProcessingEnvironment processingEnv, RoundEnvironment roundEnv, TypeElement classElement, String superClassName) {     String aRootName = canonicalClassName(classElement.getQualifiedName().toString()).     // do not check the classes from JDK itself     if (isNullOrEmpty(aRootName) || aRootName.startsWith("java.") || aRootName.startsWith("javax.")) {         return false.     }     String aSuperClassName = canonicalClassName(classElement.getSuperclass().toString()).     if (superClassName.equals(aSuperClassName)) {         return true.     }     TypeElement aSuperClass = findTypeElement(processingEnv, roundEnv, aSuperClassName).     if (aSuperClass != null) {         return hasSuperClass(processingEnv, roundEnv, aSuperClass, superClassName).     } else {         return false.     } }
false;public,static;4;31;;public static boolean implementsInterface(ProcessingEnvironment processingEnv, RoundEnvironment roundEnv, TypeElement classElement, String interfaceClassName) {     while (true) {         // check if the class implements the interface         List<? extends TypeMirror> list = classElement.getInterfaces().         if (list != null) {             for (TypeMirror type : list) {                 if (type.getKind().compareTo(TypeKind.DECLARED) == 0) {                     String name = type.toString().                     if (interfaceClassName.equals(name)) {                         return true.                     }                 }             }         }         // check super classes which may implement the interface         TypeElement baseTypeElement = null.         TypeMirror superclass = classElement.getSuperclass().         if (superclass != null) {             String superClassName = canonicalClassName(superclass.toString()).             baseTypeElement = findTypeElement(processingEnv, roundEnv, superClassName).         }         if (baseTypeElement != null) {             classElement = baseTypeElement.         } else {             break.         }     }     return false. }
true;public,static;4;11;/**  * Helper method to produce class output text file using the given handler  */ ;/**  * Helper method to produce class output text file using the given handler  */ public static void processFile(ProcessingEnvironment processingEnv, String packageName, String fileName, Consumer<PrintWriter> handler) {     try {         Filer filer = processingEnv.getFiler().         FileObject resource = filer.createResource(StandardLocation.CLASS_OUTPUT, packageName, fileName).         try (Writer w = resource.openWriter().             PrintWriter writer = new PrintWriter(w)) {             handler.accept(writer).         }     } catch (IOException e) {         log(processingEnv, e).     } }
false;public,static;2;3;;public static void log(ProcessingEnvironment processingEnv, String message) {     processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message). }
false;public,static;2;3;;public static void warning(ProcessingEnvironment processingEnv, String message) {     processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, message). }
false;public,static;2;3;;public static void error(ProcessingEnvironment processingEnv, String message) {     processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message). }
false;public,static;2;8;;public static void log(ProcessingEnvironment processingEnv, Throwable e) {     processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage()).     StringWriter buffer = new StringWriter().     PrintWriter writer = new PrintWriter(buffer).     e.printStackTrace(writer).     writer.close().     processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, buffer.toString()). }
false;public,static;3;24;;public static String loadResource(ProcessingEnvironment processingEnv, String packageName, String fileName) {     Filer filer = processingEnv.getFiler().     FileObject resource.     String relativeName = packageName + "/" + fileName.     try {         resource = filer.getResource(StandardLocation.CLASS_OUTPUT, "", relativeName).     } catch (Throwable e) {         return "Cannot load classpath resource: " + relativeName + " due: " + e.getMessage().     }     if (resource == null) {         return null.     }     try {         InputStream is = resource.openInputStream().         return loadText(is, true).     } catch (Exception e) {         warning(processingEnv, "APT cannot load file: " + packageName + "/" + fileName).     }     return null. }
false;public,static;3;11;;public static void dumpExceptionToErrorFile(String fileName, String message, Throwable e) {     try (BufferedWriter w = Files.newBufferedWriter(Paths.get(fileName))) {         w.append(message).         w.append("\n\n").         PrintWriter pw = new PrintWriter(w).         e.printStackTrace(pw).         pw.flush().     } catch (Throwable t) {     // ignore     } }
