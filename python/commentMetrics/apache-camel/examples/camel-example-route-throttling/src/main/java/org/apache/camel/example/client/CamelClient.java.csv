commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;public void run() {     try {         for (int j = 0. j < SIZE / POOL. j++) {             producer.sendBody("jms:queue:inbox", "Message " + idx.intValue() * j + j).         }     } finally {         latch.countDown().     } }
false;public,static;1;36;;public static void main(final String[] args) throws Exception {     System.out.println("Notice this client requires that the CamelServer is already running!").     AbstractApplicationContext context = new ClassPathXmlApplicationContext("camel-client.xml").     // get the camel template for Spring template style sending of messages (= producer)     final ProducerTemplate producer = context.getBean("camelTemplate", ProducerTemplate.class).     // now send a lot of messages     System.out.println("Sending ...").     final CountDownLatch latch = new CountDownLatch(POOL).     ExecutorService executors = Executors.newFixedThreadPool(POOL).     for (int i = 0. i < POOL. i++) {         final Integer idx = i.         executors.execute(new Runnable() {              public void run() {                 try {                     for (int j = 0. j < SIZE / POOL. j++) {                         producer.sendBody("jms:queue:inbox", "Message " + idx.intValue() * j + j).                     }                 } finally {                     latch.countDown().                 }             }         }).     }     latch.await(300, TimeUnit.SECONDS).     System.out.println("... Send " + SIZE + " message to JMS broker").     executors.shutdownNow().     // we're done so let's properly close the application context     IOHelper.close(context). }
