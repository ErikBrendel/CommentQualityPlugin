commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getUri() {     return uri. }
false;public;0;3;;public boolean hasErrors() {     return errors > 0. }
false;public;0;3;;public int getNumberOfErrors() {     return errors. }
false;public;0;12;;public boolean isSuccess() {     boolean ok = syntaxError == null && unknownComponent == null && incapable == null && unknown == null && required == null.     if (ok) {         ok = notConsumerOnly == null && notProducerOnly == null.     }     if (ok) {         ok = invalidEnum == null && invalidEnumChoices == null && invalidReference == null && invalidBoolean == null && invalidInteger == null && invalidNumber == null.     }     return ok. }
false;public;1;4;;public void addSyntaxError(String syntaxError) {     this.syntaxError = syntaxError.     errors++. }
false;public;1;4;;public void addIncapable(String uri) {     this.incapable = uri.     errors++. }
false;public;1;4;;public void addUnknownComponent(String name) {     this.unknownComponent = name.     errors++. }
false;public;1;9;;public void addUnknown(String name) {     if (unknown == null) {         unknown = new LinkedHashSet<>().     }     if (!unknown.contains(name)) {         unknown.add(name).         errors++.     } }
false;public;2;6;;public void addUnknownSuggestions(String name, String[] suggestions) {     if (unknownSuggestions == null) {         unknownSuggestions = new LinkedHashMap<>().     }     unknownSuggestions.put(name, suggestions). }
false;public;1;8;;public void addLenient(String name) {     if (lenient == null) {         lenient = new LinkedHashSet<>().     }     if (!lenient.contains(name)) {         lenient.add(name).     } }
false;public;1;9;;public void addRequired(String name) {     if (required == null) {         required = new LinkedHashSet<>().     }     if (!required.contains(name)) {         required.add(name).         errors++.     } }
false;public;1;8;;public void addDeprecated(String name) {     if (deprecated == null) {         deprecated = new LinkedHashSet<>().     }     if (!deprecated.contains(name)) {         deprecated.add(name).     } }
false;public;2;9;;public void addInvalidEnum(String name, String value) {     if (invalidEnum == null) {         invalidEnum = new LinkedHashMap<>().     }     if (!invalidEnum.containsKey(name)) {         invalidEnum.put(name, value).         errors++.     } }
false;public;2;6;;public void addInvalidEnumChoices(String name, String[] choices) {     if (invalidEnumChoices == null) {         invalidEnumChoices = new LinkedHashMap<>().     }     invalidEnumChoices.put(name, choices). }
false;public;2;6;;public void addInvalidEnumSuggestions(String name, String[] suggestions) {     if (invalidEnumSuggestions == null) {         invalidEnumSuggestions = new LinkedHashMap<>().     }     invalidEnumSuggestions.put(name, suggestions). }
false;public;2;9;;public void addInvalidReference(String name, String value) {     if (invalidReference == null) {         invalidReference = new LinkedHashMap<>().     }     if (!invalidReference.containsKey(name)) {         invalidReference.put(name, value).         errors++.     } }
false;public;2;9;;public void addInvalidBoolean(String name, String value) {     if (invalidBoolean == null) {         invalidBoolean = new LinkedHashMap<>().     }     if (!invalidBoolean.containsKey(name)) {         invalidBoolean.put(name, value).         errors++.     } }
false;public;2;9;;public void addInvalidInteger(String name, String value) {     if (invalidInteger == null) {         invalidInteger = new LinkedHashMap<>().     }     if (!invalidInteger.containsKey(name)) {         invalidInteger.put(name, value).         errors++.     } }
false;public;2;9;;public void addInvalidNumber(String name, String value) {     if (invalidNumber == null) {         invalidNumber = new LinkedHashMap<>().     }     if (!invalidNumber.containsKey(name)) {         invalidNumber.put(name, value).         errors++.     } }
false;public;2;6;;public void addDefaultValue(String name, String value) {     if (defaultValues == null) {         defaultValues = new LinkedHashMap<>().     }     defaultValues.put(name, value). }
false;public;1;9;;public void addNotConsumerOnly(String name) {     if (notConsumerOnly == null) {         notConsumerOnly = new LinkedHashSet<>().     }     if (!notConsumerOnly.contains(name)) {         notConsumerOnly.add(name).         errors++.     } }
false;public;1;9;;public void addNotProducerOnly(String name) {     if (notProducerOnly == null) {         notProducerOnly = new LinkedHashSet<>().     }     if (!notProducerOnly.contains(name)) {         notProducerOnly.add(name).         errors++.     } }
false;public;0;3;;public String getSyntaxError() {     return syntaxError. }
false;public;0;3;;public String getIncapable() {     return incapable. }
false;public;0;3;;public Set<String> getUnknown() {     return unknown. }
false;public;0;3;;public Set<String> getLenient() {     return lenient. }
false;public;0;3;;public Map<String, String[]> getUnknownSuggestions() {     return unknownSuggestions. }
false;public;0;3;;public String getUnknownComponent() {     return unknownComponent. }
false;public;0;3;;public Set<String> getRequired() {     return required. }
false;public;0;3;;public Set<String> getDeprecated() {     return deprecated. }
false;public;0;3;;public Map<String, String> getInvalidEnum() {     return invalidEnum. }
false;public;0;3;;public Map<String, String[]> getInvalidEnumChoices() {     return invalidEnumChoices. }
false;public;1;10;;public List<String> getEnumChoices(String optionName) {     if (invalidEnumChoices != null) {         String[] enums = invalidEnumChoices.get(optionName).         if (enums != null) {             return Arrays.asList(enums).         }     }     return Collections.emptyList(). }
false;public;0;3;;public Map<String, String> getInvalidReference() {     return invalidReference. }
false;public;0;3;;public Map<String, String> getInvalidBoolean() {     return invalidBoolean. }
false;public;0;3;;public Map<String, String> getInvalidInteger() {     return invalidInteger. }
false;public;0;3;;public Map<String, String> getInvalidNumber() {     return invalidNumber. }
false;public;0;3;;public Map<String, String> getDefaultValues() {     return defaultValues. }
false;public;0;3;;public Set<String> getNotConsumerOnly() {     return notConsumerOnly. }
false;public;0;3;;public Set<String> getNotProducerOnly() {     return notProducerOnly. }
true;public;1;3;/**  * A human readable summary of the validation errors.  *  * @param includeHeader    whether to include a header  * @return the summary, or <tt>null</tt> if no validation errors  */ ;/**  * A human readable summary of the validation errors.  *  * @param includeHeader    whether to include a header  * @return the summary, or <tt>null</tt> if no validation errors  */ public String summaryErrorMessage(boolean includeHeader) {     return summaryErrorMessage(includeHeader, true). }
true;public;2;148;/**  * A human readable summary of the validation errors.  *  * @param includeHeader    whether to include a header  * @param ignoreDeprecated whether to ignore deprecated options in use as an error or not  * @return the summary, or <tt>null</tt> if no validation errors  */ ;/**  * A human readable summary of the validation errors.  *  * @param includeHeader    whether to include a header  * @param ignoreDeprecated whether to ignore deprecated options in use as an error or not  * @return the summary, or <tt>null</tt> if no validation errors  */ public String summaryErrorMessage(boolean includeHeader, boolean ignoreDeprecated) {     boolean ok = isSuccess().     // special check if we should ignore deprecated options being used     if (ok && !ignoreDeprecated) {         ok = deprecated == null.     }     if (ok) {         return null.     }     if (incapable != null) {         return "\tIncapable of parsing uri: " + incapable.     } else if (syntaxError != null) {         return "\tSyntax error: " + syntaxError.     } else if (unknownComponent != null) {         return "\tUnknown component: " + unknownComponent.     }     // for each invalid option build a reason message     Map<String, String> options = new LinkedHashMap<>().     if (unknown != null) {         for (String name : unknown) {             if (unknownSuggestions != null && unknownSuggestions.containsKey(name)) {                 String[] suggestions = unknownSuggestions.get(name).                 if (suggestions != null && suggestions.length > 0) {                     String str = Arrays.asList(suggestions).toString().                     options.put(name, "Unknown option. Did you mean: " + str).                 } else {                     options.put(name, "Unknown option").                 }             } else {                 options.put(name, "Unknown option").             }         }     }     if (notConsumerOnly != null) {         for (String name : notConsumerOnly) {             options.put(name, "Option not applicable in consumer only mode").         }     }     if (notProducerOnly != null) {         for (String name : notProducerOnly) {             options.put(name, "Option not applicable in producer only mode").         }     }     if (required != null) {         for (String name : required) {             options.put(name, "Missing required option").         }     }     if (deprecated != null) {         for (String name : deprecated) {             options.put(name, "Deprecated option").         }     }     if (invalidEnum != null) {         for (Map.Entry<String, String> entry : invalidEnum.entrySet()) {             String name = entry.getKey().             String[] choices = invalidEnumChoices.get(name).             String defaultValue = defaultValues != null ? defaultValues.get(entry.getKey()) : null.             String str = Arrays.asList(choices).toString().             String msg = "Invalid enum value: " + entry.getValue() + ". Possible values: " + str.             if (invalidEnumSuggestions != null) {                 String[] suggestions = invalidEnumSuggestions.get(name).                 if (suggestions != null && suggestions.length > 0) {                     str = Arrays.asList(suggestions).toString().                     msg += ". Did you mean: " + str.                 }             }             if (defaultValue != null) {                 msg += ". Default value: " + defaultValue.             }             options.put(entry.getKey(), msg).         }     }     if (invalidReference != null) {         for (Map.Entry<String, String> entry : invalidReference.entrySet()) {             boolean empty = isEmpty(entry.getValue()).             if (empty) {                 options.put(entry.getKey(), "Empty reference value").             } else if (!entry.getValue().startsWith("#")) {                 options.put(entry.getKey(), "Invalid reference value: " + entry.getValue() + " must start with #").             } else {                 options.put(entry.getKey(), "Invalid reference value: " + entry.getValue()).             }         }     }     if (invalidBoolean != null) {         for (Map.Entry<String, String> entry : invalidBoolean.entrySet()) {             boolean empty = isEmpty(entry.getValue()).             if (empty) {                 options.put(entry.getKey(), "Empty boolean value").             } else {                 options.put(entry.getKey(), "Invalid boolean value: " + entry.getValue()).             }         }     }     if (invalidInteger != null) {         for (Map.Entry<String, String> entry : invalidInteger.entrySet()) {             boolean empty = isEmpty(entry.getValue()).             if (empty) {                 options.put(entry.getKey(), "Empty integer value").             } else {                 options.put(entry.getKey(), "Invalid integer value: " + entry.getValue()).             }         }     }     if (invalidNumber != null) {         for (Map.Entry<String, String> entry : invalidNumber.entrySet()) {             boolean empty = isEmpty(entry.getValue()).             if (empty) {                 options.put(entry.getKey(), "Empty number value").             } else {                 options.put(entry.getKey(), "Invalid number value: " + entry.getValue()).             }         }     }     // build a table with the error summary nicely formatted     // lets use 24 as min length     int maxLen = 24.     for (String key : options.keySet()) {         maxLen = Math.max(maxLen, key.length()).     }     String format = "%" + maxLen + "s    %s".     // build the human error summary     StringBuilder sb = new StringBuilder().     if (includeHeader) {         sb.append("Endpoint validator error\n").         sb.append("---------------------------------------------------------------------------------------------------------------------------------------\n").         sb.append("\n").     }     if (uri != null) {         sb.append("\t").append(uri).append("\n").     } else {         sb.append("\n").     }     for (Map.Entry<String, String> option : options.entrySet()) {         String out = String.format(format, option.getKey(), option.getValue()).         sb.append("\n\t").append(out).     }     return sb.toString(). }
false;private,static;1;3;;private static boolean isEmpty(String value) {     return value == null || value.isEmpty() || value.trim().isEmpty(). }
