commented;modifiers;parameterAmount;loc;comment;code
true;public;0;6;/**  * Returns a live copy of the list of patterns to include.  * The list of excludes takes precedence over the include patterns.  *  * @return the list of patterns to include  */ ;/**  * Returns a live copy of the list of patterns to include.  * The list of excludes takes precedence over the include patterns.  *  * @return the list of patterns to include  */ public List<String> getInclude() {     if (this.include == null) {         this.include = new ArrayList<>().     }     return this.include. }
true;public;0;6;/**  * Returns a live copy of the list of patterns to exclude.  * This list takes precedence over the include patterns.  *  * @return the list of patterns to exclude  */ ;/**  * Returns a live copy of the list of patterns to exclude.  * This list takes precedence over the include patterns.  *  * @return the list of patterns to exclude  */ public List<String> getExclude() {     if (exclude == null) {         exclude = new ArrayList<>().     }     return this.exclude. }
true;public;0;3;/**  * Returns a list of compiled {@code Pattern}s based on the  * values of the include list.  *  * @return the list of compiled expressions, never {@code null}  *  * @throws PatternSyntaxException if any of the expressions are invalid  */ ;/**  * Returns a list of compiled {@code Pattern}s based on the  * values of the include list.  *  * @return the list of compiled expressions, never {@code null}  *  * @throws PatternSyntaxException if any of the expressions are invalid  */ public List<Pattern> getIncludePatterns() {     return this.getPattern(this.getInclude()). }
true;public;0;3;/**  * Returns a list of compiled {@code Pattern}s based on the  * values of the exclude list.  *  * @return the list of compiled expressions, never {@code null}  *  * @throws PatternSyntaxException if any of the expressions are invalid  */ ;/**  * Returns a list of compiled {@code Pattern}s based on the  * values of the exclude list.  *  * @return the list of compiled expressions, never {@code null}  *  * @throws PatternSyntaxException if any of the expressions are invalid  */ public List<Pattern> getExcludePatterns() {     return this.getPattern(this.getExclude()). }
true;public;0;3;/**  * Returns an immutable collection of compiled filter patterns based on  * the state of this instance at the time of invocation.  */ ;/**  * Returns an immutable collection of compiled filter patterns based on  * the state of this instance at the time of invocation.  */ public Patterns getPatterns() {     return new Patterns(this.getIncludePatterns(), this.getExcludePatterns()). }
true;protected;1;8;/**  * Compiles {@code Pattern}s for each expression in {@code patternStrings}.  *  * @param patternStrings the list of regular expressions to compile  *  * @return the list of compiled patterns  *  * @throws PatternSyntaxException if any of the expressions are invalid  */ ;/**  * Compiles {@code Pattern}s for each expression in {@code patternStrings}.  *  * @param patternStrings the list of regular expressions to compile  *  * @return the list of compiled patterns  *  * @throws PatternSyntaxException if any of the expressions are invalid  */ protected List<Pattern> getPattern(List<String> patternStrings) {     List<Pattern> patterns = new ArrayList<>(patternStrings.size()).     for (String expression : patternStrings) {         patterns.add(Pattern.compile(this.parsePropertyValue(expression))).     }     return patterns. }
false;public;0;3;;public List<Pattern> getIncludes() {     return includes. }
false;public;0;3;;public List<Pattern> getExcludes() {     return excludes. }
false;public;0;10;;@Override public String toString() {     StringBuilder builder = new StringBuilder().     builder.append("Patterns [includes=").     builder.append(includes).     builder.append(", excludes=").     builder.append(excludes).     builder.append("]").     return builder.toString(). }
false;public;0;10;;@Override public String toString() {     StringBuilder builder = new StringBuilder().     builder.append("FilterParameters[include=").     builder.append(Arrays.toString(getInclude().toArray(new String[getInclude().size()]))).     builder.append(", exclude=").     builder.append(Arrays.toString(getExclude().toArray(new String[getExclude().size()]))).     builder.append("]").     return builder.toString(). }
