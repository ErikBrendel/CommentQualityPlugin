# id;timestamp;commentText;codeText;commentWords;codeWords
AggregationStrategy -> default void onCompletion(Exchange exchange);1549264559;The aggregated {@link Exchange} has completed__<b>Important: </b> This method must <b>not</b> throw any exceptions.__@param exchange  the current aggregated exchange, or the original {@link org.apache.camel.Exchange} if no aggregation_has been done before the completion occurred;default void onCompletion(Exchange exchange) {_    };the,aggregated,link,exchange,has,completed,b,important,b,this,method,must,b,not,b,throw,any,exceptions,param,exchange,the,current,aggregated,exchange,or,the,original,link,org,apache,camel,exchange,if,no,aggregation,has,been,done,before,the,completion,occurred;default,void,on,completion,exchange,exchange
AggregationStrategy -> default void onCompletion(Exchange exchange);1550474172;The aggregated {@link Exchange} has completed__<b>Important: </b> This method must <b>not</b> throw any exceptions.__@param exchange  the current aggregated exchange, or the original {@link org.apache.camel.Exchange} if no aggregation_has been done before the completion occurred;default void onCompletion(Exchange exchange) {_    };the,aggregated,link,exchange,has,completed,b,important,b,this,method,must,b,not,b,throw,any,exceptions,param,exchange,the,current,aggregated,exchange,or,the,original,link,org,apache,camel,exchange,if,no,aggregation,has,been,done,before,the,completion,occurred;default,void,on,completion,exchange,exchange
AggregationStrategy -> default void onCompletion(Exchange exchange);1551167777;The aggregated {@link Exchange} has completed__<b>Important: </b> This method must <b>not</b> throw any exceptions.__@param exchange  the current aggregated exchange, or the original {@link org.apache.camel.Exchange} if no aggregation_has been done before the completion occurred;default void onCompletion(Exchange exchange) {_    };the,aggregated,link,exchange,has,completed,b,important,b,this,method,must,b,not,b,throw,any,exceptions,param,exchange,the,current,aggregated,exchange,or,the,original,link,org,apache,camel,exchange,if,no,aggregation,has,been,done,before,the,completion,occurred;default,void,on,completion,exchange,exchange
AggregationStrategy -> Exchange aggregate(Exchange oldExchange, Exchange newExchange)_;1549264559;Aggregates an old and new exchange together to create a single combined exchange__@param oldExchange the oldest exchange (is <tt>null</tt> on first aggregation as we only have the new exchange)_@param newExchange the newest exchange (can be <tt>null</tt> if there was no data possible to acquire)_@return a combined composite of the two exchanges, favor returning the <tt>oldExchange</tt> whenever possible;Exchange aggregate(Exchange oldExchange, Exchange newExchange)_;aggregates,an,old,and,new,exchange,together,to,create,a,single,combined,exchange,param,old,exchange,the,oldest,exchange,is,tt,null,tt,on,first,aggregation,as,we,only,have,the,new,exchange,param,new,exchange,the,newest,exchange,can,be,tt,null,tt,if,there,was,no,data,possible,to,acquire,return,a,combined,composite,of,the,two,exchanges,favor,returning,the,tt,old,exchange,tt,whenever,possible;exchange,aggregate,exchange,old,exchange,exchange,new,exchange
AggregationStrategy -> Exchange aggregate(Exchange oldExchange, Exchange newExchange)_;1550474172;Aggregates an old and new exchange together to create a single combined exchange__@param oldExchange the oldest exchange (is <tt>null</tt> on first aggregation as we only have the new exchange)_@param newExchange the newest exchange (can be <tt>null</tt> if there was no data possible to acquire)_@return a combined composite of the two exchanges, favor returning the <tt>oldExchange</tt> whenever possible;Exchange aggregate(Exchange oldExchange, Exchange newExchange)_;aggregates,an,old,and,new,exchange,together,to,create,a,single,combined,exchange,param,old,exchange,the,oldest,exchange,is,tt,null,tt,on,first,aggregation,as,we,only,have,the,new,exchange,param,new,exchange,the,newest,exchange,can,be,tt,null,tt,if,there,was,no,data,possible,to,acquire,return,a,combined,composite,of,the,two,exchanges,favor,returning,the,tt,old,exchange,tt,whenever,possible;exchange,aggregate,exchange,old,exchange,exchange,new,exchange
AggregationStrategy -> Exchange aggregate(Exchange oldExchange, Exchange newExchange)_;1551167777;Aggregates an old and new exchange together to create a single combined exchange__@param oldExchange the oldest exchange (is <tt>null</tt> on first aggregation as we only have the new exchange)_@param newExchange the newest exchange (can be <tt>null</tt> if there was no data possible to acquire)_@return a combined composite of the two exchanges, favor returning the <tt>oldExchange</tt> whenever possible;Exchange aggregate(Exchange oldExchange, Exchange newExchange)_;aggregates,an,old,and,new,exchange,together,to,create,a,single,combined,exchange,param,old,exchange,the,oldest,exchange,is,tt,null,tt,on,first,aggregation,as,we,only,have,the,new,exchange,param,new,exchange,the,newest,exchange,can,be,tt,null,tt,if,there,was,no,data,possible,to,acquire,return,a,combined,composite,of,the,two,exchanges,favor,returning,the,tt,old,exchange,tt,whenever,possible;exchange,aggregate,exchange,old,exchange,exchange,new,exchange
AggregationStrategy -> default boolean preComplete(Exchange oldExchange, Exchange newExchange);1549264559;Determines if the aggregation should complete the current group, and start a new group, or the aggregation_should continue using the current group. This callback will only be called if {@link #canPreComplete()}_returns <tt>true</tt>.__@param oldExchange the oldest exchange (is <tt>null</tt> on first aggregation as we only have the new exchange)_@param newExchange the newest exchange (can be <tt>null</tt> if there was no data possible to acquire)_@return <tt>true</tt> to complete current group and start a new group, or <tt>false</tt> to keep using current;default boolean preComplete(Exchange oldExchange, Exchange newExchange) {_        return false__    };determines,if,the,aggregation,should,complete,the,current,group,and,start,a,new,group,or,the,aggregation,should,continue,using,the,current,group,this,callback,will,only,be,called,if,link,can,pre,complete,returns,tt,true,tt,param,old,exchange,the,oldest,exchange,is,tt,null,tt,on,first,aggregation,as,we,only,have,the,new,exchange,param,new,exchange,the,newest,exchange,can,be,tt,null,tt,if,there,was,no,data,possible,to,acquire,return,tt,true,tt,to,complete,current,group,and,start,a,new,group,or,tt,false,tt,to,keep,using,current;default,boolean,pre,complete,exchange,old,exchange,exchange,new,exchange,return,false
AggregationStrategy -> default boolean preComplete(Exchange oldExchange, Exchange newExchange);1550474172;Determines if the aggregation should complete the current group, and start a new group, or the aggregation_should continue using the current group. This callback will only be called if {@link #canPreComplete()}_returns <tt>true</tt>.__@param oldExchange the oldest exchange (is <tt>null</tt> on first aggregation as we only have the new exchange)_@param newExchange the newest exchange (can be <tt>null</tt> if there was no data possible to acquire)_@return <tt>true</tt> to complete current group and start a new group, or <tt>false</tt> to keep using current;default boolean preComplete(Exchange oldExchange, Exchange newExchange) {_        return false__    };determines,if,the,aggregation,should,complete,the,current,group,and,start,a,new,group,or,the,aggregation,should,continue,using,the,current,group,this,callback,will,only,be,called,if,link,can,pre,complete,returns,tt,true,tt,param,old,exchange,the,oldest,exchange,is,tt,null,tt,on,first,aggregation,as,we,only,have,the,new,exchange,param,new,exchange,the,newest,exchange,can,be,tt,null,tt,if,there,was,no,data,possible,to,acquire,return,tt,true,tt,to,complete,current,group,and,start,a,new,group,or,tt,false,tt,to,keep,using,current;default,boolean,pre,complete,exchange,old,exchange,exchange,new,exchange,return,false
AggregationStrategy -> default boolean preComplete(Exchange oldExchange, Exchange newExchange);1551167777;Determines if the aggregation should complete the current group, and start a new group, or the aggregation_should continue using the current group. This callback will only be called if {@link #canPreComplete()}_returns <tt>true</tt>.__@param oldExchange the oldest exchange (is <tt>null</tt> on first aggregation as we only have the new exchange)_@param newExchange the newest exchange (can be <tt>null</tt> if there was no data possible to acquire)_@return <tt>true</tt> to complete current group and start a new group, or <tt>false</tt> to keep using current;default boolean preComplete(Exchange oldExchange, Exchange newExchange) {_        return false__    };determines,if,the,aggregation,should,complete,the,current,group,and,start,a,new,group,or,the,aggregation,should,continue,using,the,current,group,this,callback,will,only,be,called,if,link,can,pre,complete,returns,tt,true,tt,param,old,exchange,the,oldest,exchange,is,tt,null,tt,on,first,aggregation,as,we,only,have,the,new,exchange,param,new,exchange,the,newest,exchange,can,be,tt,null,tt,if,there,was,no,data,possible,to,acquire,return,tt,true,tt,to,complete,current,group,and,start,a,new,group,or,tt,false,tt,to,keep,using,current;default,boolean,pre,complete,exchange,old,exchange,exchange,new,exchange,return,false
AggregationStrategy -> default void timeout(Exchange exchange, int index, int total, long timeout);1549264559;A timeout occurred._<p/>_<b>Important: </b> This method must <b>not</b> throw any exceptions.__@param exchange  the current aggregated exchange, or the original {@link Exchange} if no aggregation_has been done before the timeout occurred_@param index     the index, may be <tt>-1</tt> if not possible to determine the index_@param total     the total, may be <tt>-1</tt> if not possible to determine the total_@param timeout   the timeout value in millis, may be <tt>-1</tt> if not possible to determine the timeout;default void timeout(Exchange exchange, int index, int total, long timeout) {_        _        LoggerFactory.getLogger(getClass()).warn("Parallel processing timed out after {} millis for number {}. This task will be cancelled and will not be aggregated.", timeout, index)__    };a,timeout,occurred,p,b,important,b,this,method,must,b,not,b,throw,any,exceptions,param,exchange,the,current,aggregated,exchange,or,the,original,link,exchange,if,no,aggregation,has,been,done,before,the,timeout,occurred,param,index,the,index,may,be,tt,1,tt,if,not,possible,to,determine,the,index,param,total,the,total,may,be,tt,1,tt,if,not,possible,to,determine,the,total,param,timeout,the,timeout,value,in,millis,may,be,tt,1,tt,if,not,possible,to,determine,the,timeout;default,void,timeout,exchange,exchange,int,index,int,total,long,timeout,logger,factory,get,logger,get,class,warn,parallel,processing,timed,out,after,millis,for,number,this,task,will,be,cancelled,and,will,not,be,aggregated,timeout,index
AggregationStrategy -> default void timeout(Exchange exchange, int index, int total, long timeout);1550474172;A timeout occurred._<p/>_<b>Important: </b> This method must <b>not</b> throw any exceptions.__@param exchange  the current aggregated exchange, or the original {@link Exchange} if no aggregation_has been done before the timeout occurred_@param index     the index, may be <tt>-1</tt> if not possible to determine the index_@param total     the total, may be <tt>-1</tt> if not possible to determine the total_@param timeout   the timeout value in millis, may be <tt>-1</tt> if not possible to determine the timeout;default void timeout(Exchange exchange, int index, int total, long timeout) {_        _        LoggerFactory.getLogger(getClass()).warn("Parallel processing timed out after {} millis for number {}. This task will be cancelled and will not be aggregated.", timeout, index)__    };a,timeout,occurred,p,b,important,b,this,method,must,b,not,b,throw,any,exceptions,param,exchange,the,current,aggregated,exchange,or,the,original,link,exchange,if,no,aggregation,has,been,done,before,the,timeout,occurred,param,index,the,index,may,be,tt,1,tt,if,not,possible,to,determine,the,index,param,total,the,total,may,be,tt,1,tt,if,not,possible,to,determine,the,total,param,timeout,the,timeout,value,in,millis,may,be,tt,1,tt,if,not,possible,to,determine,the,timeout;default,void,timeout,exchange,exchange,int,index,int,total,long,timeout,logger,factory,get,logger,get,class,warn,parallel,processing,timed,out,after,millis,for,number,this,task,will,be,cancelled,and,will,not,be,aggregated,timeout,index
AggregationStrategy -> default void timeout(Exchange exchange, int index, int total, long timeout);1551167777;A timeout occurred._<p/>_<b>Important: </b> This method must <b>not</b> throw any exceptions.__@param exchange  the current aggregated exchange, or the original {@link Exchange} if no aggregation_has been done before the timeout occurred_@param index     the index, may be <tt>-1</tt> if not possible to determine the index_@param total     the total, may be <tt>-1</tt> if not possible to determine the total_@param timeout   the timeout value in millis, may be <tt>-1</tt> if not possible to determine the timeout;default void timeout(Exchange exchange, int index, int total, long timeout) {_        _        LoggerFactory.getLogger(getClass()).warn("Parallel processing timed out after {} millis for number {}. This task will be cancelled and will not be aggregated.", timeout, index)__    };a,timeout,occurred,p,b,important,b,this,method,must,b,not,b,throw,any,exceptions,param,exchange,the,current,aggregated,exchange,or,the,original,link,exchange,if,no,aggregation,has,been,done,before,the,timeout,occurred,param,index,the,index,may,be,tt,1,tt,if,not,possible,to,determine,the,index,param,total,the,total,may,be,tt,1,tt,if,not,possible,to,determine,the,total,param,timeout,the,timeout,value,in,millis,may,be,tt,1,tt,if,not,possible,to,determine,the,timeout;default,void,timeout,exchange,exchange,int,index,int,total,long,timeout,logger,factory,get,logger,get,class,warn,parallel,processing,timed,out,after,millis,for,number,this,task,will,be,cancelled,and,will,not,be,aggregated,timeout,index
AggregationStrategy -> default void onOptimisticLockFailure(Exchange oldExchange, Exchange newExchange);1549264559;Callback when the aggregated {@link Exchange} fails to add_in the {@link org.apache.camel.spi.OptimisticLockingAggregationRepository} because of_an {@link org.apache.camel.spi.OptimisticLockingAggregationRepository.OptimisticLockingException}._<p/>_Please note that when aggregating {@link Exchange}'s to be careful not to modify and return the {@code oldExchange}_from the {@link AggregationStrategy#aggregate(org.apache.camel.Exchange, org.apache.camel.Exchange)} method._If you are using the default MemoryAggregationRepository this will mean you have modified the value of an object_already referenced/stored by the MemoryAggregationRepository. This makes it impossible for optimistic locking_to work correctly with the MemoryAggregationRepository._<p/>_You should instead return either the new {@code newExchange} or a completely new instance of {@link Exchange}. This_is due to the nature of how the underlying {@link java.util.concurrent.ConcurrentHashMap} performs CAS operations_on the value identity.__@see java.util.concurrent.ConcurrentHashMap;default void onOptimisticLockFailure(Exchange oldExchange, Exchange newExchange) {_        LoggerFactory.getLogger(getClass()).trace("onOptimisticLockFailure with AggregationStrategy: {}, oldExchange: {}, newExchange: {}", this, oldExchange, newExchange)___    };callback,when,the,aggregated,link,exchange,fails,to,add,in,the,link,org,apache,camel,spi,optimistic,locking,aggregation,repository,because,of,an,link,org,apache,camel,spi,optimistic,locking,aggregation,repository,optimistic,locking,exception,p,please,note,that,when,aggregating,link,exchange,s,to,be,careful,not,to,modify,and,return,the,code,old,exchange,from,the,link,aggregation,strategy,aggregate,org,apache,camel,exchange,org,apache,camel,exchange,method,if,you,are,using,the,default,memory,aggregation,repository,this,will,mean,you,have,modified,the,value,of,an,object,already,referenced,stored,by,the,memory,aggregation,repository,this,makes,it,impossible,for,optimistic,locking,to,work,correctly,with,the,memory,aggregation,repository,p,you,should,instead,return,either,the,new,code,new,exchange,or,a,completely,new,instance,of,link,exchange,this,is,due,to,the,nature,of,how,the,underlying,link,java,util,concurrent,concurrent,hash,map,performs,cas,operations,on,the,value,identity,see,java,util,concurrent,concurrent,hash,map;default,void,on,optimistic,lock,failure,exchange,old,exchange,exchange,new,exchange,logger,factory,get,logger,get,class,trace,on,optimistic,lock,failure,with,aggregation,strategy,old,exchange,new,exchange,this,old,exchange,new,exchange
AggregationStrategy -> default void onOptimisticLockFailure(Exchange oldExchange, Exchange newExchange);1550474172;Callback when the aggregated {@link Exchange} fails to add_in the {@link org.apache.camel.spi.OptimisticLockingAggregationRepository} because of_an {@link org.apache.camel.spi.OptimisticLockingAggregationRepository.OptimisticLockingException}._<p/>_Please note that when aggregating {@link Exchange}'s to be careful not to modify and return the {@code oldExchange}_from the {@link AggregationStrategy#aggregate(org.apache.camel.Exchange, org.apache.camel.Exchange)} method._If you are using the default MemoryAggregationRepository this will mean you have modified the value of an object_already referenced/stored by the MemoryAggregationRepository. This makes it impossible for optimistic locking_to work correctly with the MemoryAggregationRepository._<p/>_You should instead return either the new {@code newExchange} or a completely new instance of {@link Exchange}. This_is due to the nature of how the underlying {@link java.util.concurrent.ConcurrentHashMap} performs CAS operations_on the value identity.__@see java.util.concurrent.ConcurrentHashMap;default void onOptimisticLockFailure(Exchange oldExchange, Exchange newExchange) {_        LoggerFactory.getLogger(getClass()).trace("onOptimisticLockFailure with AggregationStrategy: {}, oldExchange: {}, newExchange: {}", this, oldExchange, newExchange)___    };callback,when,the,aggregated,link,exchange,fails,to,add,in,the,link,org,apache,camel,spi,optimistic,locking,aggregation,repository,because,of,an,link,org,apache,camel,spi,optimistic,locking,aggregation,repository,optimistic,locking,exception,p,please,note,that,when,aggregating,link,exchange,s,to,be,careful,not,to,modify,and,return,the,code,old,exchange,from,the,link,aggregation,strategy,aggregate,org,apache,camel,exchange,org,apache,camel,exchange,method,if,you,are,using,the,default,memory,aggregation,repository,this,will,mean,you,have,modified,the,value,of,an,object,already,referenced,stored,by,the,memory,aggregation,repository,this,makes,it,impossible,for,optimistic,locking,to,work,correctly,with,the,memory,aggregation,repository,p,you,should,instead,return,either,the,new,code,new,exchange,or,a,completely,new,instance,of,link,exchange,this,is,due,to,the,nature,of,how,the,underlying,link,java,util,concurrent,concurrent,hash,map,performs,cas,operations,on,the,value,identity,see,java,util,concurrent,concurrent,hash,map;default,void,on,optimistic,lock,failure,exchange,old,exchange,exchange,new,exchange,logger,factory,get,logger,get,class,trace,on,optimistic,lock,failure,with,aggregation,strategy,old,exchange,new,exchange,this,old,exchange,new,exchange
AggregationStrategy -> default void onOptimisticLockFailure(Exchange oldExchange, Exchange newExchange);1551167777;Callback when the aggregated {@link Exchange} fails to add_in the {@link org.apache.camel.spi.OptimisticLockingAggregationRepository} because of_an {@link org.apache.camel.spi.OptimisticLockingAggregationRepository.OptimisticLockingException}._<p/>_Please note that when aggregating {@link Exchange}'s to be careful not to modify and return the {@code oldExchange}_from the {@link AggregationStrategy#aggregate(org.apache.camel.Exchange, org.apache.camel.Exchange)} method._If you are using the default MemoryAggregationRepository this will mean you have modified the value of an object_already referenced/stored by the MemoryAggregationRepository. This makes it impossible for optimistic locking_to work correctly with the MemoryAggregationRepository._<p/>_You should instead return either the new {@code newExchange} or a completely new instance of {@link Exchange}. This_is due to the nature of how the underlying {@link java.util.concurrent.ConcurrentHashMap} performs CAS operations_on the value identity.__@see java.util.concurrent.ConcurrentHashMap;default void onOptimisticLockFailure(Exchange oldExchange, Exchange newExchange) {_        LoggerFactory.getLogger(getClass()).trace("onOptimisticLockFailure with AggregationStrategy: {}, oldExchange: {}, newExchange: {}", this, oldExchange, newExchange)__    };callback,when,the,aggregated,link,exchange,fails,to,add,in,the,link,org,apache,camel,spi,optimistic,locking,aggregation,repository,because,of,an,link,org,apache,camel,spi,optimistic,locking,aggregation,repository,optimistic,locking,exception,p,please,note,that,when,aggregating,link,exchange,s,to,be,careful,not,to,modify,and,return,the,code,old,exchange,from,the,link,aggregation,strategy,aggregate,org,apache,camel,exchange,org,apache,camel,exchange,method,if,you,are,using,the,default,memory,aggregation,repository,this,will,mean,you,have,modified,the,value,of,an,object,already,referenced,stored,by,the,memory,aggregation,repository,this,makes,it,impossible,for,optimistic,locking,to,work,correctly,with,the,memory,aggregation,repository,p,you,should,instead,return,either,the,new,code,new,exchange,or,a,completely,new,instance,of,link,exchange,this,is,due,to,the,nature,of,how,the,underlying,link,java,util,concurrent,concurrent,hash,map,performs,cas,operations,on,the,value,identity,see,java,util,concurrent,concurrent,hash,map;default,void,on,optimistic,lock,failure,exchange,old,exchange,exchange,new,exchange,logger,factory,get,logger,get,class,trace,on,optimistic,lock,failure,with,aggregation,strategy,old,exchange,new,exchange,this,old,exchange,new,exchange
AggregationStrategy -> default boolean canPreComplete();1549264559;Indicates if this aggregation strategy uses pre-completion mode._@return <tt>true</tt> if this strategy uses pre-completion mode, or <tt>false</tt> otherwise.;default boolean canPreComplete() {_        return false__    };indicates,if,this,aggregation,strategy,uses,pre,completion,mode,return,tt,true,tt,if,this,strategy,uses,pre,completion,mode,or,tt,false,tt,otherwise;default,boolean,can,pre,complete,return,false
AggregationStrategy -> default boolean canPreComplete();1550474172;Indicates if this aggregation strategy uses pre-completion mode._@return <tt>true</tt> if this strategy uses pre-completion mode, or <tt>false</tt> otherwise.;default boolean canPreComplete() {_        return false__    };indicates,if,this,aggregation,strategy,uses,pre,completion,mode,return,tt,true,tt,if,this,strategy,uses,pre,completion,mode,or,tt,false,tt,otherwise;default,boolean,can,pre,complete,return,false
AggregationStrategy -> default boolean canPreComplete();1551167777;Indicates if this aggregation strategy uses pre-completion mode._@return <tt>true</tt> if this strategy uses pre-completion mode, or <tt>false</tt> otherwise.;default boolean canPreComplete() {_        return false__    };indicates,if,this,aggregation,strategy,uses,pre,completion,mode,return,tt,true,tt,if,this,strategy,uses,pre,completion,mode,or,tt,false,tt,otherwise;default,boolean,can,pre,complete,return,false
