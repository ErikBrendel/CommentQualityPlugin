commented;modifiers;parameterAmount;loc;comment;code
true;;2;1;/**  * Aggregates an old and new exchange together to create a single combined exchange  *  * @param oldExchange the oldest exchange (is <tt>null</tt> on first aggregation as we only have the new exchange)  * @param newExchange the newest exchange (can be <tt>null</tt> if there was no data possible to acquire)  * @return a combined composite of the two exchanges, favor returning the <tt>oldExchange</tt> whenever possible  */ ;/**  * Aggregates an old and new exchange together to create a single combined exchange  *  * @param oldExchange the oldest exchange (is <tt>null</tt> on first aggregation as we only have the new exchange)  * @param newExchange the newest exchange (can be <tt>null</tt> if there was no data possible to acquire)  * @return a combined composite of the two exchanges, favor returning the <tt>oldExchange</tt> whenever possible  */ Exchange aggregate(Exchange oldExchange, Exchange newExchange).
true;default;0;3;/**  * Indicates if this aggregation strategy uses pre-completion mode.  * @return <tt>true</tt> if this strategy uses pre-completion mode, or <tt>false</tt> otherwise.  */ ;/**  * Indicates if this aggregation strategy uses pre-completion mode.  * @return <tt>true</tt> if this strategy uses pre-completion mode, or <tt>false</tt> otherwise.  */ default boolean canPreComplete() {     return false. }
true;default;2;3;/**  * Determines if the aggregation should complete the current group, and start a new group, or the aggregation  * should continue using the current group. This callback will only be called if {@link #canPreComplete()}  * returns <tt>true</tt>.  *  * @param oldExchange the oldest exchange (is <tt>null</tt> on first aggregation as we only have the new exchange)  * @param newExchange the newest exchange (can be <tt>null</tt> if there was no data possible to acquire)  * @return <tt>true</tt> to complete current group and start a new group, or <tt>false</tt> to keep using current  */ ;/**  * Determines if the aggregation should complete the current group, and start a new group, or the aggregation  * should continue using the current group. This callback will only be called if {@link #canPreComplete()}  * returns <tt>true</tt>.  *  * @param oldExchange the oldest exchange (is <tt>null</tt> on first aggregation as we only have the new exchange)  * @param newExchange the newest exchange (can be <tt>null</tt> if there was no data possible to acquire)  * @return <tt>true</tt> to complete current group and start a new group, or <tt>false</tt> to keep using current  */ default boolean preComplete(Exchange oldExchange, Exchange newExchange) {     return false. }
true;default;1;2;/**  * The aggregated {@link Exchange} has completed  *  * <b>Important: </b> This method must <b>not</b> throw any exceptions.  *  * @param exchange  the current aggregated exchange, or the original {@link org.apache.camel.Exchange} if no aggregation  *                  has been done before the completion occurred  */ ;/**  * The aggregated {@link Exchange} has completed  *  * <b>Important: </b> This method must <b>not</b> throw any exceptions.  *  * @param exchange  the current aggregated exchange, or the original {@link org.apache.camel.Exchange} if no aggregation  *                  has been done before the completion occurred  */ default void onCompletion(Exchange exchange) { }
true;default;4;4;/**  * A timeout occurred.  * <p/>  * <b>Important: </b> This method must <b>not</b> throw any exceptions.  *  * @param exchange  the current aggregated exchange, or the original {@link Exchange} if no aggregation  *                  has been done before the timeout occurred  * @param index     the index, may be <tt>-1</tt> if not possible to determine the index  * @param total     the total, may be <tt>-1</tt> if not possible to determine the total  * @param timeout   the timeout value in millis, may be <tt>-1</tt> if not possible to determine the timeout  */ ;/**  * A timeout occurred.  * <p/>  * <b>Important: </b> This method must <b>not</b> throw any exceptions.  *  * @param exchange  the current aggregated exchange, or the original {@link Exchange} if no aggregation  *                  has been done before the timeout occurred  * @param index     the index, may be <tt>-1</tt> if not possible to determine the index  * @param total     the total, may be <tt>-1</tt> if not possible to determine the total  * @param timeout   the timeout value in millis, may be <tt>-1</tt> if not possible to determine the timeout  */ default void timeout(Exchange exchange, int index, int total, long timeout) {     // log a WARN we timed out since it will not be aggregated and the Exchange will be lost     LoggerFactory.getLogger(getClass()).warn("Parallel processing timed out after {} millis for number {}. This task will be cancelled and will not be aggregated.", timeout, index). }
true;default;2;3;/**  * Callback when the aggregated {@link Exchange} fails to add  * in the {@link org.apache.camel.spi.OptimisticLockingAggregationRepository} because of  * an {@link org.apache.camel.spi.OptimisticLockingAggregationRepository.OptimisticLockingException}.  * <p/>  * Please note that when aggregating {@link Exchange}'s to be careful not to modify and return the {@code oldExchange}  * from the {@link AggregationStrategy#aggregate(org.apache.camel.Exchange, org.apache.camel.Exchange)} method.  * If you are using the default MemoryAggregationRepository this will mean you have modified the value of an object  * already referenced/stored by the MemoryAggregationRepository. This makes it impossible for optimistic locking  * to work correctly with the MemoryAggregationRepository.  * <p/>  * You should instead return either the new {@code newExchange} or a completely new instance of {@link Exchange}. This  * is due to the nature of how the underlying {@link java.util.concurrent.ConcurrentHashMap} performs CAS operations  * on the value identity.  *  * @see java.util.concurrent.ConcurrentHashMap  */ ;/**  * Callback when the aggregated {@link Exchange} fails to add  * in the {@link org.apache.camel.spi.OptimisticLockingAggregationRepository} because of  * an {@link org.apache.camel.spi.OptimisticLockingAggregationRepository.OptimisticLockingException}.  * <p/>  * Please note that when aggregating {@link Exchange}'s to be careful not to modify and return the {@code oldExchange}  * from the {@link AggregationStrategy#aggregate(org.apache.camel.Exchange, org.apache.camel.Exchange)} method.  * If you are using the default MemoryAggregationRepository this will mean you have modified the value of an object  * already referenced/stored by the MemoryAggregationRepository. This makes it impossible for optimistic locking  * to work correctly with the MemoryAggregationRepository.  * <p/>  * You should instead return either the new {@code newExchange} or a completely new instance of {@link Exchange}. This  * is due to the nature of how the underlying {@link java.util.concurrent.ConcurrentHashMap} performs CAS operations  * on the value identity.  *  * @see java.util.concurrent.ConcurrentHashMap  */ default void onOptimisticLockFailure(Exchange oldExchange, Exchange newExchange) {     LoggerFactory.getLogger(getClass()).trace("onOptimisticLockFailure with AggregationStrategy: {}, oldExchange: {}, newExchange: {}", this, oldExchange, newExchange). }
