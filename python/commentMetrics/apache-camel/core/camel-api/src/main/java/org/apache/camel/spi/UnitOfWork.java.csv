commented;modifiers;parameterAmount;loc;comment;code
true;;1;1;/**  * Adds a synchronization hook  *  * @param synchronization the hook  */ ;/**  * Adds a synchronization hook  *  * @param synchronization the hook  */ void addSynchronization(Synchronization synchronization).
true;;1;1;/**  * Removes a synchronization hook  *  * @param synchronization the hook  */ ;/**  * Removes a synchronization hook  *  * @param synchronization the hook  */ void removeSynchronization(Synchronization synchronization).
true;;1;1;/**  * Checks if the passed synchronization hook is already part of this unit of work.  *  * @param synchronization the hook  * @return <tt>true</tt>, if the passed synchronization is part of this unit of work, else <tt>false</tt>  */ ;/**  * Checks if the passed synchronization hook is already part of this unit of work.  *  * @param synchronization the hook  * @return <tt>true</tt>, if the passed synchronization is part of this unit of work, else <tt>false</tt>  */ boolean containsSynchronization(Synchronization synchronization).
true;;1;1;/**  * Handover all the registered synchronizations to the target {@link org.apache.camel.Exchange}.  * <p/>  * This is used when a route turns into asynchronous and the {@link org.apache.camel.Exchange} that  * is continued and routed in the async thread should do the on completion callbacks instead of the  * original synchronous thread.  *  * @param target the target exchange  */ ;/**  * Handover all the registered synchronizations to the target {@link org.apache.camel.Exchange}.  * <p/>  * This is used when a route turns into asynchronous and the {@link org.apache.camel.Exchange} that  * is continued and routed in the async thread should do the on completion callbacks instead of the  * original synchronous thread.  *  * @param target the target exchange  */ void handoverSynchronization(Exchange target).
true;;2;1;/**  * Handover all the registered synchronizations to the target {@link org.apache.camel.Exchange}.  * <p/>  * This is used when a route turns into asynchronous and the {@link org.apache.camel.Exchange} that  * is continued and routed in the async thread should do the on completion callbacks instead of the  * original synchronous thread.  *  * @param target the target exchange  * @param filter optional filter to only handover if filter returns <tt>true</tt>  */ ;/**  * Handover all the registered synchronizations to the target {@link org.apache.camel.Exchange}.  * <p/>  * This is used when a route turns into asynchronous and the {@link org.apache.camel.Exchange} that  * is continued and routed in the async thread should do the on completion callbacks instead of the  * original synchronous thread.  *  * @param target the target exchange  * @param filter optional filter to only handover if filter returns <tt>true</tt>  */ void handoverSynchronization(Exchange target, Predicate<Synchronization> filter).
true;;1;1;/**  * Invoked when this unit of work has been completed, whether it has failed or completed  *  * @param exchange the current exchange  */ ;/**  * Invoked when this unit of work has been completed, whether it has failed or completed  *  * @param exchange the current exchange  */ void done(Exchange exchange).
true;;2;1;/**  * Invoked when this unit of work is about to be routed by the given route.  *  * @param exchange the current exchange  * @param route    the route  */ ;/**  * Invoked when this unit of work is about to be routed by the given route.  *  * @param exchange the current exchange  * @param route    the route  */ void beforeRoute(Exchange exchange, Route route).
true;;2;1;/**  * Invoked when this unit of work is done being routed by the given route.  *  * @param exchange the current exchange  * @param route    the route  */ ;/**  * Invoked when this unit of work is done being routed by the given route.  *  * @param exchange the current exchange  * @param route    the route  */ void afterRoute(Exchange exchange, Route route).
true;;0;1;/**  * Returns the unique ID of this unit of work, lazily creating one if it does not yet have one  *  * @return the unique ID  */ ;/**  * Returns the unique ID of this unit of work, lazily creating one if it does not yet have one  *  * @return the unique ID  */ String getId().
true;;0;1;/**  * Gets the original IN {@link Message} this Unit of Work was started with.  * <p/>  * The original message is only returned if the option {@link org.apache.camel.RuntimeConfiguration#isAllowUseOriginalMessage()}  * is enabled. If its disabled an <tt>IllegalStateException</tt> is thrown.  *  * @return the original IN {@link Message}, or <tt>null</tt> if using original message is disabled.  */ ;/**  * Gets the original IN {@link Message} this Unit of Work was started with.  * <p/>  * The original message is only returned if the option {@link org.apache.camel.RuntimeConfiguration#isAllowUseOriginalMessage()}  * is enabled. If its disabled an <tt>IllegalStateException</tt> is thrown.  *  * @return the original IN {@link Message}, or <tt>null</tt> if using original message is disabled.  */ Message getOriginalInMessage().
true;;0;1;/**  * Are we transacted?  *  * @return <tt>true</tt> if transacted, <tt>false</tt> otherwise  */ ;/**  * Are we transacted?  *  * @return <tt>true</tt> if transacted, <tt>false</tt> otherwise  */ boolean isTransacted().
true;;1;1;/**  * Are we already transacted by the given transaction key?  *  * @param key the transaction key  * @return <tt>true</tt> if already, <tt>false</tt> otherwise  */ ;/**  * Are we already transacted by the given transaction key?  *  * @param key the transaction key  * @return <tt>true</tt> if already, <tt>false</tt> otherwise  */ boolean isTransactedBy(Object key).
true;;1;1;/**  * Mark this UnitOfWork as being transacted by the given transaction key.  * <p/>  * When the transaction is completed then invoke the {@link #endTransactedBy(Object)} method using the same key.  *  * @param key the transaction key  */ ;/**  * Mark this UnitOfWork as being transacted by the given transaction key.  * <p/>  * When the transaction is completed then invoke the {@link #endTransactedBy(Object)} method using the same key.  *  * @param key the transaction key  */ void beginTransactedBy(Object key).
true;;1;1;/**  * Mark this UnitOfWork as not transacted anymore by the given transaction definition.  *  * @param key the transaction key  */ ;/**  * Mark this UnitOfWork as not transacted anymore by the given transaction definition.  *  * @param key the transaction key  */ void endTransactedBy(Object key).
true;;0;1;/**  * Gets the {@link RouteContext} that this {@link UnitOfWork} currently is being routed through.  * <p/>  * Notice that an {@link Exchange} can be routed through multiple routes and thus the  * {@link org.apache.camel.spi.RouteContext} can change over time.  *  * @return the route context  * @see #pushRouteContext(RouteContext)  * @see #popRouteContext()  */ ;/**  * Gets the {@link RouteContext} that this {@link UnitOfWork} currently is being routed through.  * <p/>  * Notice that an {@link Exchange} can be routed through multiple routes and thus the  * {@link org.apache.camel.spi.RouteContext} can change over time.  *  * @return the route context  * @see #pushRouteContext(RouteContext)  * @see #popRouteContext()  */ RouteContext getRouteContext().
true;;1;1;/**  * Pushes the {@link RouteContext} that this {@link UnitOfWork} currently is being routed through.  * <p/>  * Notice that an {@link Exchange} can be routed through multiple routes and thus the  * {@link org.apache.camel.spi.RouteContext} can change over time.  *  * @param routeContext the route context  */ ;/**  * Pushes the {@link RouteContext} that this {@link UnitOfWork} currently is being routed through.  * <p/>  * Notice that an {@link Exchange} can be routed through multiple routes and thus the  * {@link org.apache.camel.spi.RouteContext} can change over time.  *  * @param routeContext the route context  */ void pushRouteContext(RouteContext routeContext).
true;;0;1;/**  * When finished being routed under the current {@link org.apache.camel.spi.RouteContext}  * it should be removed.  *  * @return the route context or <tt>null</tt> if none existed  */ ;/**  * When finished being routed under the current {@link org.apache.camel.spi.RouteContext}  * it should be removed.  *  * @return the route context or <tt>null</tt> if none existed  */ RouteContext popRouteContext().
true;;3;1;/**  * Strategy for optional work to be execute before processing  * <p/>  * For example the {@link org.apache.camel.impl.MDCUnitOfWork} leverages this  * to ensure MDC is handled correctly during routing exchanges using the  * asynchronous routing engine.  *  * @param processor the processor to be executed  * @param exchange  the current exchange  * @param callback  the callback  * @return the callback to be used (can return a wrapped callback)  */ ;/**  * Strategy for optional work to be execute before processing  * <p/>  * For example the {@link org.apache.camel.impl.MDCUnitOfWork} leverages this  * to ensure MDC is handled correctly during routing exchanges using the  * asynchronous routing engine.  *  * @param processor the processor to be executed  * @param exchange  the current exchange  * @param callback  the callback  * @return the callback to be used (can return a wrapped callback)  */ AsyncCallback beforeProcess(Processor processor, Exchange exchange, AsyncCallback callback).
true;;4;1;/**  * Strategy for optional work to be executed after the processing  *  * @param processor the processor executed  * @param exchange  the current exchange  * @param callback  the callback used  * @param doneSync  whether the process was done synchronously or asynchronously  */ ;/**  * Strategy for optional work to be executed after the processing  *  * @param processor the processor executed  * @param exchange  the current exchange  * @param callback  the callback used  * @param doneSync  whether the process was done synchronously or asynchronously  */ void afterProcess(Processor processor, Exchange exchange, AsyncCallback callback, boolean doneSync).
true;;1;1;/**  * Create a child unit of work, which is associated to this unit of work as its parent.  * <p/>  * This is often used when EIPs need to support {@link SubUnitOfWork}s. For example a splitter,  * where the sub messages of the splitter all participate in the same sub unit of work.  * That sub unit of work then decides whether the Splitter (in general) is failed or a  * processed successfully.  *  * @param childExchange the child exchange  * @return the created child unit of work  * @see SubUnitOfWork  * @see SubUnitOfWorkCallback  */ ;/**  * Create a child unit of work, which is associated to this unit of work as its parent.  * <p/>  * This is often used when EIPs need to support {@link SubUnitOfWork}s. For example a splitter,  * where the sub messages of the splitter all participate in the same sub unit of work.  * That sub unit of work then decides whether the Splitter (in general) is failed or a  * processed successfully.  *  * @param childExchange the child exchange  * @return the created child unit of work  * @see SubUnitOfWork  * @see SubUnitOfWorkCallback  */ UnitOfWork createChildUnitOfWork(Exchange childExchange).
true;;1;1;/**  * Sets the parent unit of work.  *  * @param parentUnitOfWork the parent  */ ;/**  * Sets the parent unit of work.  *  * @param parentUnitOfWork the parent  */ void setParentUnitOfWork(UnitOfWork parentUnitOfWork).
true;;0;1;/**  * Gets the {@link SubUnitOfWorkCallback} if this unit of work participates in a sub unit of work.  *  * @return the callback, or <tt>null</tt> if this unit of work is not part of a sub unit of work.  * @see #beginSubUnitOfWork(org.apache.camel.Exchange)  */ ;/**  * Gets the {@link SubUnitOfWorkCallback} if this unit of work participates in a sub unit of work.  *  * @return the callback, or <tt>null</tt> if this unit of work is not part of a sub unit of work.  * @see #beginSubUnitOfWork(org.apache.camel.Exchange)  */ SubUnitOfWorkCallback getSubUnitOfWorkCallback().
true;;1;1;/**  * Begins a {@link SubUnitOfWork}, where sub (child) unit of works participate in a parent unit of work.  * The {@link SubUnitOfWork} will callback to the parent unit of work using {@link SubUnitOfWorkCallback}s.  *  * @param exchange the exchange  */ ;/**  * Begins a {@link SubUnitOfWork}, where sub (child) unit of works participate in a parent unit of work.  * The {@link SubUnitOfWork} will callback to the parent unit of work using {@link SubUnitOfWorkCallback}s.  *  * @param exchange the exchange  */ void beginSubUnitOfWork(Exchange exchange).
true;;1;1;/**  * Ends a {@link SubUnitOfWork}.  * <p/>  * The {@link #beginSubUnitOfWork(org.apache.camel.Exchange)} must have been invoked  * prior to this operation.  *  * @param exchange the exchange  */ ;/**  * Ends a {@link SubUnitOfWork}.  * <p/>  * The {@link #beginSubUnitOfWork(org.apache.camel.Exchange)} must have been invoked  * prior to this operation.  *  * @param exchange the exchange  */ void endSubUnitOfWork(Exchange exchange).
