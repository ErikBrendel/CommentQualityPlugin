commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;public void init() {     if (status == NEW) {         synchronized (lock) {             if (status == NEW) {                 log.trace("Initializing service: {}", this).                 doInit().                 status = INITIALIZED.             }         }     } }
true;public;0;24;/**  * <b>Important: </b> You should override the lifecycle methods that start with <tt>do</tt>, eg {@link #doStart()},  * {@link #doStop()}, etc. where you implement your logic. The methods {@link #start()}, {@link #stop()} should  * <b>NOT</b> be overriden as they are used internally to keep track of the state of this service and properly  * invoke the operation in a safe manner.  */ ;/**  * <b>Important: </b> You should override the lifecycle methods that start with <tt>do</tt>, eg {@link #doStart()},  * {@link #doStop()}, etc. where you implement your logic. The methods {@link #start()}, {@link #stop()} should  * <b>NOT</b> be overriden as they are used internally to keep track of the state of this service and properly  * invoke the operation in a safe manner.  */ public void start() throws Exception {     synchronized (lock) {         if (status == STARTED) {             log.trace("Service: {} already started", this).             return.         }         if (status == STARTING) {             log.trace("Service: {} already starting", this).             return.         }         init().         try {             status = STARTING.             log.trace("Starting service: {}", this).             doStart().             status = STARTED.             log.trace("Service started: {}", this).         } catch (Exception e) {             status = FAILED.             log.trace("Error while starting service: " + this, e).             throw e.         }     } }
true;public;0;23;/**  * <b>Important: </b> You should override the lifecycle methods that start with <tt>do</tt>, eg {@link #doStart()},  * {@link #doStop()}, etc. where you implement your logic. The methods {@link #start()}, {@link #stop()} should  * <b>NOT</b> be overridden as they are used internally to keep track of the state of this service and properly  * invoke the operation in a safe manner.  */ ;/**  * <b>Important: </b> You should override the lifecycle methods that start with <tt>do</tt>, eg {@link #doStart()},  * {@link #doStop()}, etc. where you implement your logic. The methods {@link #start()}, {@link #stop()} should  * <b>NOT</b> be overridden as they are used internally to keep track of the state of this service and properly  * invoke the operation in a safe manner.  */ public void stop() throws Exception {     synchronized (lock) {         if (status == STOPPED || status == SHUTTINGDOWN || status == SHUTDOWN) {             log.trace("Service: {} already stopped", this).             return.         }         if (status == STOPPING) {             log.trace("Service: {} already stopping", this).             return.         }         status = STOPPING.         log.trace("Stopping service: {}", this).         try {             doStop().             status = STOPPED.             log.trace("Service: {} stopped service", this).         } catch (Exception e) {             status = FAILED.             log.trace("Error while stopping service: " + this, e).             throw e.         }     } }
true;public;0;24;/**  * <b>Important: </b> You should override the lifecycle methods that start with <tt>do</tt>, eg {@link #doStart()},  * {@link #doStop()}, etc. where you implement your logic. The methods {@link #start()}, {@link #stop()} should  * <b>NOT</b> be overridden as they are used internally to keep track of the state of this service and properly  * invoke the operation in a safe manner.  */ ;/**  * <b>Important: </b> You should override the lifecycle methods that start with <tt>do</tt>, eg {@link #doStart()},  * {@link #doStop()}, etc. where you implement your logic. The methods {@link #start()}, {@link #stop()} should  * <b>NOT</b> be overridden as they are used internally to keep track of the state of this service and properly  * invoke the operation in a safe manner.  */ @Override public void suspend() throws Exception {     synchronized (lock) {         if (status == SUSPENDED) {             log.trace("Service: {} already suspended", this).             return.         }         if (status == SUSPENDING) {             log.trace("Service: {} already suspending", this).             return.         }         status = SUSPENDING.         log.trace("Suspending service: {}", this).         try {             doSuspend().             status = SUSPENDED.             log.trace("Service suspended: {}", this).         } catch (Exception e) {             status = FAILED.             log.trace("Error while suspending service: " + this, e).             throw e.         }     } }
true;public;0;20;/**  * <b>Important: </b> You should override the lifecycle methods that start with <tt>do</tt>, eg {@link #doStart()},  * {@link #doStop()}, etc. where you implement your logic. The methods {@link #start()}, {@link #stop()} should  * <b>NOT</b> be overriden as they are used internally to keep track of the state of this service and properly  * invoke the operation in a safe manner.  */ ;/**  * <b>Important: </b> You should override the lifecycle methods that start with <tt>do</tt>, eg {@link #doStart()},  * {@link #doStop()}, etc. where you implement your logic. The methods {@link #start()}, {@link #stop()} should  * <b>NOT</b> be overriden as they are used internally to keep track of the state of this service and properly  * invoke the operation in a safe manner.  */ @Override public void resume() throws Exception {     synchronized (lock) {         if (status != SUSPENDED) {             log.trace("Service is not suspended: {}", this).             return.         }         status = STARTING.         log.trace("Resuming service: {}", this).         try {             doResume().             status = STARTED.             log.trace("Service resumed: {}", this).         } catch (Exception e) {             status = FAILED.             log.trace("Error while resuming service: " + this, e).             throw e.         }     } }
true;public;0;25;/**  * <b>Important: </b> You should override the lifecycle methods that start with <tt>do</tt>, eg {@link #doStart()},  * {@link #doStop()}, etc. where you implement your logic. The methods {@link #start()}, {@link #stop()} should  * <b>NOT</b> be overriden as they are used internally to keep track of the state of this service and properly  * invoke the operation in a safe manner.  */ ;/**  * <b>Important: </b> You should override the lifecycle methods that start with <tt>do</tt>, eg {@link #doStart()},  * {@link #doStop()}, etc. where you implement your logic. The methods {@link #start()}, {@link #stop()} should  * <b>NOT</b> be overriden as they are used internally to keep track of the state of this service and properly  * invoke the operation in a safe manner.  */ @Override public void shutdown() throws Exception {     synchronized (lock) {         if (status == SHUTDOWN) {             log.trace("Service: {} already shut down", this).             return.         }         if (status == SHUTTINGDOWN) {             log.trace("Service: {} already shutting down", this).             return.         }         stop().         status = SHUTDOWN.         log.trace("Shutting down service: {}", this).         try {             doShutdown().             log.trace("Service: {} shut down", this).             status = SHUTDOWN.         } catch (Exception e) {             status = FAILED.             log.trace("Error shutting down service: " + this, e).             throw e.         }     } }
false;public;0;17;;@Override public ServiceStatus getStatus() {     switch(status) {         case STARTING:             return ServiceStatus.Starting.         case STARTED:             return ServiceStatus.Started.         case SUSPENDING:             return ServiceStatus.Suspending.         case SUSPENDED:             return ServiceStatus.Suspended.         case STOPPING:             return ServiceStatus.Stopping.         default:             return ServiceStatus.Stopped.     } }
false;public;0;3;;public boolean isNew() {     return status == NEW. }
false;public;0;3;;public boolean isInit() {     return status == INITIALIZED. }
false;public;0;4;;@Override public boolean isStarted() {     return status == STARTED. }
false;public;0;4;;@Override public boolean isStarting() {     return status == STARTING. }
false;public;0;4;;@Override public boolean isStopping() {     return status == STOPPING. }
false;public;0;4;;@Override public boolean isStopped() {     return status == STOPPED || status == SHUTTINGDOWN || status == SHUTDOWN || status == FAILED. }
false;public;0;4;;@Override public boolean isSuspending() {     return status == SUSPENDING. }
false;public;0;4;;@Override public boolean isSuspended() {     return status == SUSPENDED. }
false;public;0;4;;@Override public boolean isRunAllowed() {     return isStartingOrStarted() || isSuspendingOrSuspended(). }
false;public;0;3;;public boolean isShutdown() {     return status == SHUTDOWN. }
true;public;0;3;/**  * Is the service in progress of being stopped or already stopped  */ ;/**  * Is the service in progress of being stopped or already stopped  */ public boolean isStoppingOrStopped() {     return isStopping() || isStopped(). }
true;public;0;3;/**  * Is the service in progress of being suspended or already suspended  */ ;/**  * Is the service in progress of being suspended or already suspended  */ public boolean isSuspendingOrSuspended() {     return isSuspending() || isSuspended(). }
true;public;0;3;/**  * Is the service in progress of being suspended or already suspended  */ ;/**  * Is the service in progress of being suspended or already suspended  */ public boolean isStartingOrStarted() {     return isStarting() || isStarted(). }
true;protected;0;2;/**  * Initialize the service.  * This method will only be called once before starting.  */ ;/**  * Initialize the service.  * This method will only be called once before starting.  */ protected void doInit() { }
true;protected,abstract;0;1;/**  * Implementations override this method to support customized start/stop.  * <p/>  * <b>Important: </b> See {@link #doStop()} for more details.  *  * @see #doStop()  */ ;/**  * Implementations override this method to support customized start/stop.  * <p/>  * <b>Important: </b> See {@link #doStop()} for more details.  *  * @see #doStop()  */ protected abstract void doStart() throws Exception.
true;protected,abstract;0;1;/**  * Implementations override this method to support customized start/stop.  * <p/>  * <b>Important:</b> Camel will invoke this {@link #doStop()} method when  * the service is being stopped. This method will <b>also</b> be invoked  * if the service is still in <i>uninitialized</i> state (eg has not  * been started). The method is <b>always</b> called to allow the service  * to do custom logic when the service is being stopped, such as when  * {@link org.apache.camel.CamelContext} is shutting down.  *  * @see #doStart()  */ ;/**  * Implementations override this method to support customized start/stop.  * <p/>  * <b>Important:</b> Camel will invoke this {@link #doStop()} method when  * the service is being stopped. This method will <b>also</b> be invoked  * if the service is still in <i>uninitialized</i> state (eg has not  * been started). The method is <b>always</b> called to allow the service  * to do custom logic when the service is being stopped, such as when  * {@link org.apache.camel.CamelContext} is shutting down.  *  * @see #doStart()  */ protected abstract void doStop() throws Exception.
true;protected;0;3;/**  * Implementations override this method to support customized suspend/resume.  */ ;/**  * Implementations override this method to support customized suspend/resume.  */ protected void doSuspend() throws Exception { // noop }
true;protected;0;3;/**  * Implementations override this method to support customized suspend/resume.  */ ;/**  * Implementations override this method to support customized suspend/resume.  */ protected void doResume() throws Exception { // noop }
true;protected;0;3;/**  * Implementations override this method to perform customized shutdown.  */ ;/**  * Implementations override this method to perform customized shutdown.  */ protected void doShutdown() throws Exception { // noop }
