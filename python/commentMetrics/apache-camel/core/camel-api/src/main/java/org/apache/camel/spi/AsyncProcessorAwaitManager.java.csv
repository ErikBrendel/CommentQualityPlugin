commented;modifiers;parameterAmount;loc;comment;code
true;;0;1;/**  * Total number of threads that has been blocked  */ ;/**  * Total number of threads that has been blocked  */ long getThreadsBlocked().
true;;0;1;/**  * Total number of threads that has been forced interrupted  */ ;/**  * Total number of threads that has been forced interrupted  */ long getThreadsInterrupted().
true;;0;1;/**  * The total duration time in millis.  */ ;/**  * The total duration time in millis.  */ long getTotalDuration().
true;;0;1;/**  * The lowest duration time in millis.  */ ;/**  * The lowest duration time in millis.  */ long getMinDuration().
true;;0;1;/**  * The highest duration time in millis.  */ ;/**  * The highest duration time in millis.  */ long getMaxDuration().
true;;0;1;/**  * The average duration time in millis.  */ ;/**  * The average duration time in millis.  */ long getMeanDuration().
true;;0;1;/**  * Reset the counters  */ ;/**  * Reset the counters  */ void reset().
true;;0;1;/**  * Whether statistics is enabled.  */ ;/**  * Whether statistics is enabled.  */ boolean isStatisticsEnabled().
true;;1;1;/**  * Sets whether statistics is enabled.  *  * @param statisticsEnabled <tt>true</tt> to enable  */ ;/**  * Sets whether statistics is enabled.  *  * @param statisticsEnabled <tt>true</tt> to enable  */ void setStatisticsEnabled(boolean statisticsEnabled).
true;;0;1;/**  * The thread which is blocked waiting for other threads to signal the callback.  */ ;/**  * The thread which is blocked waiting for other threads to signal the callback.  */ Thread getBlockedThread().
true;;0;1;/**  * The exchange being processed by the other thread.  */ ;/**  * The exchange being processed by the other thread.  */ Exchange getExchange().
true;;0;1;/**  * Time in millis the thread has been blocked waiting for the signal.  */ ;/**  * Time in millis the thread has been blocked waiting for the signal.  */ long getWaitDuration().
true;;0;1;/**  * The id of the route where the exchange was processed when the thread was set to block.  * <p/>  * Is <tt>null</tt> if message history is disabled.  */ ;/**  * The id of the route where the exchange was processed when the thread was set to block.  * <p/>  * Is <tt>null</tt> if message history is disabled.  */ String getRouteId().
true;;0;1;/**  * The id of the node from the route where the exchange was processed when the thread was set to block.  * <p/>  * Is <tt>null</tt> if message history is disabled.  */ ;/**  * The id of the node from the route where the exchange was processed when the thread was set to block.  * <p/>  * Is <tt>null</tt> if message history is disabled.  */ String getNodeId().
true;;2;1;/**  * Process the given exchange sychronously.  *  * @param processor the async processor to call  * @param exchange the exchange to process  */ ;/**  * Process the given exchange sychronously.  *  * @param processor the async processor to call  * @param exchange the exchange to process  */ void process(AsyncProcessor processor, Exchange exchange).
true;;0;1;/**  * Number of threads that are blocked waiting for other threads to trigger the callback when they are done processing  * the exchange.  */ ;/**  * Number of threads that are blocked waiting for other threads to trigger the callback when they are done processing  * the exchange.  */ int size().
true;;0;1;/**  * A <i>read-only</i> browser of the {@link AwaitThread}s that are currently inflight.  */ ;/**  * A <i>read-only</i> browser of the {@link AwaitThread}s that are currently inflight.  */ Collection<AwaitThread> browse().
true;;1;1;/**  * To interrupt an exchange which may seem as stuck, to force the exchange to continue,  * allowing any blocking thread to be released.  * <p/>  * <b>Important:</b> Use this with caution as the other thread is still assumed to be process the exchange. Though  * if it appears as the exchange is <i>stuck</i>, then this method can remedy this, by forcing the latch to count-down  * so the blocked thread can continue. An exception is set on the exchange which allows Camel's error handler to deal  * with this malfunctioned exchange.  *  * @param exchangeId    the exchange id to interrupt.  */ ;/**  * To interrupt an exchange which may seem as stuck, to force the exchange to continue,  * allowing any blocking thread to be released.  * <p/>  * <b>Important:</b> Use this with caution as the other thread is still assumed to be process the exchange. Though  * if it appears as the exchange is <i>stuck</i>, then this method can remedy this, by forcing the latch to count-down  * so the blocked thread can continue. An exception is set on the exchange which allows Camel's error handler to deal  * with this malfunctioned exchange.  *  * @param exchangeId    the exchange id to interrupt.  */ void interrupt(String exchangeId).
true;;1;1;/**  * To interrupt an exchange which may seem as stuck, to force the exchange to continue,  * allowing any blocking thread to be released.  * <p/>  * <b>Important:</b> Use this with caution as the other thread is still assumed to be process the exchange. Though  * if it appears as the exchange is <i>stuck</i>, then this method can remedy this, by forcing the latch to count-down  * so the blocked thread can continue. An exception is set on the exchange which allows Camel's error handler to deal  * with this malfunctioned exchange.  *  * @param exchange    the exchange to interrupt.  */ ;/**  * To interrupt an exchange which may seem as stuck, to force the exchange to continue,  * allowing any blocking thread to be released.  * <p/>  * <b>Important:</b> Use this with caution as the other thread is still assumed to be process the exchange. Though  * if it appears as the exchange is <i>stuck</i>, then this method can remedy this, by forcing the latch to count-down  * so the blocked thread can continue. An exception is set on the exchange which allows Camel's error handler to deal  * with this malfunctioned exchange.  *  * @param exchange    the exchange to interrupt.  */ void interrupt(Exchange exchange).
true;;0;1;/**  * Whether to interrupt any blocking threads during stopping.  * <p/>  * This is enabled by default which allows Camel to release any blocked thread during shutting down Camel itself.  */ ;/**  * Whether to interrupt any blocking threads during stopping.  * <p/>  * This is enabled by default which allows Camel to release any blocked thread during shutting down Camel itself.  */ boolean isInterruptThreadsWhileStopping().
true;;1;1;/**  * Sets whether to interrupt any blocking threads during stopping.  * <p/>  * This is enabled by default which allows Camel to release any blocked thread during shutting down Camel itself.  */ ;/**  * Sets whether to interrupt any blocking threads during stopping.  * <p/>  * This is enabled by default which allows Camel to release any blocked thread during shutting down Camel itself.  */ void setInterruptThreadsWhileStopping(boolean interruptThreadsWhileStopping).
true;;0;1;/**  * Gets the utilization statistics of this manager  *  * @return the utilization statistics  */ ;/**  * Gets the utilization statistics of this manager  *  * @return the utilization statistics  */ Statistics getStatistics().
