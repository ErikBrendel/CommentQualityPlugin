commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void init(ManagementStrategy strategy) { // do nothing }
false;public;0;3;;public CamelContext getContext() {     return camelContext. }
false;public;0;3;;public BacklogDebugger getBacklogDebugger() {     return backlogDebugger. }
false;public;0;3;;public String getCamelId() {     return camelContext.getName(). }
false;public;0;3;;public String getCamelManagementName() {     return camelContext.getManagementName(). }
false;public;0;3;;public String getLoggingLevel() {     return backlogDebugger.getLoggingLevel(). }
false;public;1;3;;public void setLoggingLevel(String level) {     backlogDebugger.setLoggingLevel(level). }
false;public;0;3;;public boolean isEnabled() {     return backlogDebugger.isEnabled(). }
false;public;0;3;;public void enableDebugger() {     backlogDebugger.enableDebugger(). }
false;public;0;3;;public void disableDebugger() {     backlogDebugger.disableDebugger(). }
false;public;1;3;;public void addBreakpoint(String nodeId) {     backlogDebugger.addBreakpoint(nodeId). }
false;public;3;3;;public void addConditionalBreakpoint(String nodeId, String language, String predicate) {     backlogDebugger.addConditionalBreakpoint(nodeId, language, predicate). }
false;public;1;3;;public void removeBreakpoint(String nodeId) {     backlogDebugger.removeBreakpoint(nodeId). }
false;public;0;3;;public void removeAllBreakpoints() {     backlogDebugger.removeAllBreakpoints(). }
false;public;0;3;;public Set<String> getBreakpoints() {     return backlogDebugger.getBreakpoints(). }
false;public;1;3;;public void resumeBreakpoint(String nodeId) {     backlogDebugger.resumeBreakpoint(nodeId). }
false;public;2;3;;public void setMessageBodyOnBreakpoint(String nodeId, Object body) {     backlogDebugger.setMessageBodyOnBreakpoint(nodeId, body). }
false;public;3;8;;public void setMessageBodyOnBreakpoint(String nodeId, Object body, String type) {     try {         Class<?> classType = camelContext.getClassResolver().resolveMandatoryClass(type).         backlogDebugger.setMessageBodyOnBreakpoint(nodeId, body, classType).     } catch (ClassNotFoundException e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;public;1;3;;public void removeMessageBodyOnBreakpoint(String nodeId) {     backlogDebugger.removeMessageBodyOnBreakpoint(nodeId). }
false;public;3;7;;public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, Object value) {     try {         backlogDebugger.setMessageHeaderOnBreakpoint(nodeId, headerName, value).     } catch (NoTypeConversionAvailableException e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;public;4;8;;public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, Object value, String type) {     try {         Class<?> classType = camelContext.getClassResolver().resolveMandatoryClass(type).         backlogDebugger.setMessageHeaderOnBreakpoint(nodeId, headerName, value, classType).     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;public;2;3;;public void removeMessageHeaderOnBreakpoint(String nodeId, String headerName) {     backlogDebugger.removeMessageHeaderOnBreakpoint(nodeId, headerName). }
false;public;0;3;;public void resumeAll() {     backlogDebugger.resumeAll(). }
false;public;1;3;;public void stepBreakpoint(String nodeId) {     backlogDebugger.stepBreakpoint(nodeId). }
false;public;0;3;;public boolean isSingleStepMode() {     return backlogDebugger.isSingleStepMode(). }
false;public;0;3;;public void step() {     backlogDebugger.step(). }
false;public;0;3;;public Set<String> getSuspendedBreakpointNodeIds() {     return backlogDebugger.getSuspendedBreakpointNodeIds(). }
false;public;1;3;;public void disableBreakpoint(String nodeId) {     backlogDebugger.disableBreakpoint(nodeId). }
false;public;1;3;;public void enableBreakpoint(String nodeId) {     backlogDebugger.enableBreakpoint(nodeId). }
false;public;0;3;;public int getBodyMaxChars() {     return backlogDebugger.getBodyMaxChars(). }
false;public;1;3;;public void setBodyMaxChars(int bodyMaxChars) {     backlogDebugger.setBodyMaxChars(bodyMaxChars). }
false;public;0;3;;public boolean isBodyIncludeStreams() {     return backlogDebugger.isBodyIncludeStreams(). }
false;public;1;3;;public void setBodyIncludeStreams(boolean bodyIncludeStreams) {     backlogDebugger.setBodyIncludeStreams(bodyIncludeStreams). }
false;public;0;3;;public boolean isBodyIncludeFiles() {     return backlogDebugger.isBodyIncludeFiles(). }
false;public;1;3;;public void setBodyIncludeFiles(boolean bodyIncludeFiles) {     backlogDebugger.setBodyIncludeFiles(bodyIncludeFiles). }
false;public;1;3;;public String dumpTracedMessagesAsXml(String nodeId) {     return backlogDebugger.dumpTracedMessagesAsXml(nodeId). }
false;public;0;3;;public long getDebugCounter() {     return backlogDebugger.getDebugCounter(). }
false;public;0;3;;public void resetDebugCounter() {     backlogDebugger.resetDebugCounter(). }
false;public;2;14;;public String validateConditionalBreakpoint(String language, String predicate) {     Language lan = null.     try {         lan = camelContext.resolveLanguage(language).         lan.createPredicate(predicate).         return null.     } catch (Exception e) {         if (lan == null) {             return e.getMessage().         } else {             return "Invalid syntax " + predicate + " due: " + e.getMessage().         }     } }
false;public;0;3;;public long getFallbackTimeout() {     return backlogDebugger.getFallbackTimeout(). }
false;public;1;3;;public void setFallbackTimeout(long fallbackTimeout) {     backlogDebugger.setFallbackTimeout(fallbackTimeout). }
