commented;modifiers;parameterAmount;loc;comment;code
false;public;1;14;;public void setCounter(Object counter) {     ManagedPerformanceCounter mpc = null.     if (counter instanceof ManagedPerformanceCounter) {         mpc = (ManagedPerformanceCounter) counter.     }     if (this.counter instanceof DelegatePerformanceCounter) {         ((DelegatePerformanceCounter) this.counter).setCounter(mpc).     } else if (mpc != null) {         this.counter = mpc.     } else if (counter instanceof PerformanceCounter) {         this.counter = (PerformanceCounter) counter.     } }
false;public;1;11;;public void done(boolean doneSync) {     try {         // record end time         if (watch != null) {             recordTime(exchange, watch.taken()).         }     } finally {         // and let the original callback know we are done as well         callback.done(doneSync).     } }
false;public;0;4;;@Override public String toString() {     return DefaultInstrumentationProcessor.this.toString(). }
false;public;2;29;;@Override public boolean process(final Exchange exchange, final AsyncCallback callback) {     // only record time if stats is enabled     final StopWatch watch = (counter != null && counter.isStatisticsEnabled()) ? new StopWatch() : null.     // mark beginning to process the exchange     if (watch != null) {         beginTime(exchange).     }     return processor.process(exchange, new AsyncCallback() {          public void done(boolean doneSync) {             try {                 // record end time                 if (watch != null) {                     recordTime(exchange, watch.taken()).                 }             } finally {                 // and let the original callback know we are done as well                 callback.done(doneSync).             }         }          @Override         public String toString() {             return DefaultInstrumentationProcessor.this.toString().         }     }). }
false;protected;1;3;;protected void beginTime(Exchange exchange) {     counter.processExchange(exchange). }
false;protected;2;11;;protected void recordTime(Exchange exchange, long duration) {     if (log.isTraceEnabled()) {         log.trace("{}Recording duration: {} millis for exchange: {}", type != null ? type + ": " : "", duration, exchange).     }     if (!exchange.isFailed() && exchange.getException() == null) {         counter.completedExchange(exchange, duration).     } else {         counter.failedExchange(exchange).     } }
false;public;0;3;;public String getType() {     return type. }
false;public;1;3;;public void setType(String type) {     this.type = type. }
false;public;1;9;;@Override public StopWatch before(Exchange exchange) throws Exception {     // only record time if stats is enabled     StopWatch answer = counter != null && counter.isStatisticsEnabled() ? new StopWatch() : null.     if (answer != null) {         beginTime(exchange).     }     return answer. }
false;public;2;7;;@Override public void after(Exchange exchange, StopWatch watch) throws Exception {     // record end time     if (watch != null) {         recordTime(exchange, watch.taken()).     } }
false;public;0;4;;@Override public String toString() {     return "InstrumentProcessorAdvice". }
false;public;0;5;;@Override public int getOrder() {     // we want instrumentation before calling the processor (but before tracer/debugger)     return Ordered.LOWEST - 2. }
