commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public void init(ManagementStrategy strategy) {     super.init(strategy).     boolean enabled = context.getManagementStrategy().getManagementAgent().getStatisticsLevel() != ManagementStatisticsLevel.Off.     setStatisticsEnabled(enabled). }
false;public;0;3;;public Route getRoute() {     return route. }
false;public;0;3;;public CamelContext getContext() {     return context. }
false;public;0;7;;public String getRouteId() {     String id = route.getId().     if (id == null) {         id = VALUE_UNKNOWN.     }     return id. }
false;public;0;3;;public String getRouteGroup() {     return route.getGroup(). }
false;public;0;25;;@Override public TabularData getRouteProperties() {     try {         final Map<String, Object> properties = route.getProperties().         final TabularData answer = new TabularDataSupport(CamelOpenMBeanTypes.camelRoutePropertiesTabularType()).         final CompositeType ct = CamelOpenMBeanTypes.camelRoutePropertiesCompositeType().         // gather route properties         for (Map.Entry<String, Object> entry : properties.entrySet()) {             final String key = entry.getKey().             final String val = context.getTypeConverter().convertTo(String.class, entry.getValue()).             CompositeData data = new CompositeDataSupport(ct, new String[] { "key", "value" }, new Object[] { key, val }).             answer.put(data).         }         return answer.     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;public;0;3;;public String getDescription() {     return description. }
false;public;0;7;;@Override public String getEndpointUri() {     if (route.getEndpoint() != null) {         return route.getEndpoint().getEndpointUri().     }     return VALUE_UNKNOWN. }
false;public;0;9;;public String getState() {     // must use String type to be sure remote JMX can read the attribute without requiring Camel classes.     ServiceStatus status = context.getRouteController().getRouteStatus(route.getId()).     // if no status exists then its stopped     if (status == null) {         status = ServiceStatus.Stopped.     }     return status.name(). }
false;public;0;3;;public String getUptime() {     return route.getUptime(). }
false;public;0;3;;public long getUptimeMillis() {     return route.getUptimeMillis(). }
false;public;0;3;;public Integer getInflightExchanges() {     return (int) super.getExchangesInflight(). }
false;public;0;3;;public String getCamelId() {     return context.getName(). }
false;public;0;3;;public String getCamelManagementName() {     return context.getManagementName(). }
false;public;0;3;;public Boolean getTracing() {     return route.getRouteContext().isTracing(). }
false;public;1;3;;public void setTracing(Boolean tracing) {     route.getRouteContext().setTracing(tracing). }
false;public;0;3;;public Boolean getMessageHistory() {     return route.getRouteContext().isMessageHistory(). }
false;public;0;3;;public Boolean getLogMask() {     return route.getRouteContext().isLogMask(). }
false;public;0;19;;public String getRoutePolicyList() {     List<RoutePolicy> policyList = route.getRouteContext().getRoutePolicyList().     if (policyList == null || policyList.isEmpty()) {         // return an empty string to have it displayed nicely in JMX consoles         return "".     }     StringBuilder sb = new StringBuilder().     for (int i = 0. i < policyList.size(). i++) {         RoutePolicy policy = policyList.get(i).         sb.append(policy.getClass().getSimpleName()).         sb.append("(").append(ObjectHelper.getIdentityHashCode(policy)).append(")").         if (i < policyList.size() - 1) {             sb.append(", ").         }     }     return sb.toString(). }
false;public;0;9;;public String getLoad01() {     double load1 = load.getLoad1().     if (Double.isNaN(load1)) {         // empty string if load statistics is disabled         return "".     } else {         return String.format("%.2f", load1).     } }
false;public;0;9;;public String getLoad05() {     double load5 = load.getLoad5().     if (Double.isNaN(load5)) {         // empty string if load statistics is disabled         return "".     } else {         return String.format("%.2f", load5).     } }
false;public;0;9;;public String getLoad15() {     double load15 = load.getLoad15().     if (Double.isNaN(load15)) {         // empty string if load statistics is disabled         return "".     } else {         return String.format("%.2f", load15).     } }
false;public;0;4;;@Override public void onTimer() {     load.update(getInflightExchanges()). }
false;public;0;6;;public void start() throws Exception {     if (!context.getStatus().isStarted()) {         throw new IllegalArgumentException("CamelContext is not started").     }     context.getRouteController().startRoute(getRouteId()). }
false;public;0;6;;public void stop() throws Exception {     if (!context.getStatus().isStarted()) {         throw new IllegalArgumentException("CamelContext is not started").     }     context.getRouteController().stopRoute(getRouteId()). }
false;public;1;6;;public void stop(long timeout) throws Exception {     if (!context.getStatus().isStarted()) {         throw new IllegalArgumentException("CamelContext is not started").     }     context.getRouteController().stopRoute(getRouteId(), timeout, TimeUnit.SECONDS). }
false;public;2;6;;public boolean stop(Long timeout, Boolean abortAfterTimeout) throws Exception {     if (!context.getStatus().isStarted()) {         throw new IllegalArgumentException("CamelContext is not started").     }     return context.getRouteController().stopRoute(getRouteId(), timeout, TimeUnit.SECONDS, abortAfterTimeout). }
false;public;0;8;;public void shutdown() throws Exception {     if (!context.getStatus().isStarted()) {         throw new IllegalArgumentException("CamelContext is not started").     }     String routeId = getRouteId().     context.getRouteController().stopRoute(routeId).     context.removeRoute(routeId). }
false;public;1;8;;public void shutdown(long timeout) throws Exception {     if (!context.getStatus().isStarted()) {         throw new IllegalArgumentException("CamelContext is not started").     }     String routeId = getRouteId().     context.getRouteController().stopRoute(routeId, timeout, TimeUnit.SECONDS).     context.removeRoute(routeId). }
false;public;0;6;;public boolean remove() throws Exception {     if (!context.getStatus().isStarted()) {         throw new IllegalArgumentException("CamelContext is not started").     }     return context.removeRoute(getRouteId()). }
false;public;0;4;;@Override public void restart() throws Exception {     restart(1). }
false;public;1;13;;@Override public void restart(long delay) throws Exception {     stop().     if (delay > 0) {         try {             LOG.debug("Sleeping {} seconds before starting route: {}", delay, getRouteId()).             Thread.sleep(delay * 1000).         } catch (InterruptedException e) {         // ignore         }     }     start(). }
false;public;0;3;;public String dumpRouteAsXml() throws Exception {     return dumpRouteAsXml(false). }
false;public;1;13;;@Override public String transform(String text) {     try {         String after = getContext().resolvePropertyPlaceholders(text).         if (!changed.get()) {             changed.set(!text.equals(after)).         }         return after.     } catch (Exception e) {         // ignore         return text.     } }
false;public;1;37;;@Override public String dumpRouteAsXml(boolean resolvePlaceholders) throws Exception {     String id = route.getId().     RouteDefinition def = context.getRouteDefinition(id).     if (def != null) {         String xml = ModelHelper.dumpModelAsXml(context, def).         // if resolving placeholders we parse the xml, and resolve the property placeholders during parsing         if (resolvePlaceholders) {             final AtomicBoolean changed = new AtomicBoolean().             InputStream is = new ByteArrayInputStream(xml.getBytes("UTF-8")).             Document dom = XmlLineNumberParser.parseXml(is, new XmlLineNumberParser.XmlTextTransformer() {                  @Override                 public String transform(String text) {                     try {                         String after = getContext().resolvePropertyPlaceholders(text).                         if (!changed.get()) {                             changed.set(!text.equals(after)).                         }                         return after.                     } catch (Exception e) {                         // ignore                         return text.                     }                 }             }).             // okay there were some property placeholder replaced so re-create the model             if (changed.get()) {                 xml = context.getTypeConverter().mandatoryConvertTo(String.class, dom).                 RouteDefinition copy = ModelHelper.createModelFromXml(context, xml, RouteDefinition.class).                 xml = ModelHelper.dumpModelAsXml(context, copy).             }         }         return xml.     }     return null. }
false;public;1;29;;public void updateRouteFromXml(String xml) throws Exception {     // convert to model from xml     RouteDefinition def = ModelHelper.createModelFromXml(context, xml, RouteDefinition.class).     if (def == null) {         return.     }     // and not add a new route, adding a new route, use the MBean operation on ManagedCamelContext instead.     if (ObjectHelper.isEmpty(def.getId())) {         def.setId(getRouteId()).     } else if (!def.getId().equals(getRouteId())) {         throw new IllegalArgumentException("Cannot update route from XML as routeIds does not match. routeId: " + getRouteId() + ", routeId from XML: " + def.getId()).     }     LOG.debug("Updating route: {} from xml: {}", def.getId(), xml).     try {         // add will remove existing route first         context.addRouteDefinition(def).     } catch (Exception e) {         // log the error as warn as the management api may be invoked remotely over JMX which does not propagate such exception         String msg = "Error updating route: " + def.getId() + " from xml: " + xml + " due: " + e.getMessage().         LOG.warn(msg, e).         throw e.     } }
false;public;2;84;;public String dumpRouteStatsAsXml(boolean fullStats, boolean includeProcessors) throws Exception {     // in this logic we need to calculate the accumulated processing time for the processor in the route     // and hence why the logic is a bit more complicated to do this, as we need to calculate that from     // the bottom -> top of the route but this information is valuable for profiling routes     StringBuilder sb = new StringBuilder().     // need to calculate this value first, as we need that value for the route stat     Long processorAccumulatedTime = 0L.     // gather all the processors for this route, which requires JMX     if (includeProcessors) {         sb.append("  <processorStats>\n").         MBeanServer server = getContext().getManagementStrategy().getManagementAgent().getMBeanServer().         if (server != null) {             // get all the processor mbeans and sort them accordingly to their index             String prefix = getContext().getManagementStrategy().getManagementAgent().getIncludeHostName() ? "*/" : "".             ObjectName query = ObjectName.getInstance(jmxDomain + ":context=" + prefix + getContext().getManagementName() + ",type=processors,*").             Set<ObjectName> names = server.queryNames(query, null).             List<ManagedProcessorMBean> mps = new ArrayList<>().             for (ObjectName on : names) {                 ManagedProcessorMBean processor = context.getManagementStrategy().getManagementAgent().newProxyClient(on, ManagedProcessorMBean.class).                 // the processor must belong to this route                 if (getRouteId().equals(processor.getRouteId())) {                     mps.add(processor).                 }             }             mps.sort(new OrderProcessorMBeans()).             // walk the processors in reverse order, and calculate the accumulated total time             Map<String, Long> accumulatedTimes = new HashMap<>().             Collections.reverse(mps).             for (ManagedProcessorMBean processor : mps) {                 processorAccumulatedTime += processor.getTotalProcessingTime().                 accumulatedTimes.put(processor.getProcessorId(), processorAccumulatedTime).             }             // and reverse back again             Collections.reverse(mps).             // and now add the sorted list of processors to the xml output             for (ManagedProcessorMBean processor : mps) {                 sb.append("    <processorStat").append(String.format(" id=\"%s\" index=\"%s\" state=\"%s\"", processor.getProcessorId(), processor.getIndex(), processor.getState())).                 // do we have an accumulated time then append that                 Long accTime = accumulatedTimes.get(processor.getProcessorId()).                 if (accTime != null) {                     sb.append(" accumulatedProcessingTime=\"").append(accTime).append("\"").                 }                 // use substring as we only want the attributes                 sb.append(" ").append(processor.dumpStatsAsXml(fullStats).substring(7)).append("\n").             }         }         sb.append("  </processorStats>\n").     }     // route self time is route total - processor accumulated total)     long routeSelfTime = getTotalProcessingTime() - processorAccumulatedTime.     if (routeSelfTime < 0) {         // ensure we don't calculate that as negative         routeSelfTime = 0.     }     StringBuilder answer = new StringBuilder().     answer.append("<routeStat").append(String.format(" id=\"%s\"", route.getId())).append(String.format(" state=\"%s\"", getState())).     // use substring as we only want the attributes     String stat = dumpStatsAsXml(fullStats).     answer.append(" exchangesInflight=\"").append(getInflightExchanges()).append("\"").     answer.append(" selfProcessingTime=\"").append(routeSelfTime).append("\"").     InflightRepository.InflightExchange oldest = getOldestInflightEntry().     if (oldest == null) {         answer.append(" oldestInflightExchangeId=\"\"").         answer.append(" oldestInflightDuration=\"\"").     } else {         answer.append(" oldestInflightExchangeId=\"").append(oldest.getExchange().getExchangeId()).append("\"").         answer.append(" oldestInflightDuration=\"").append(oldest.getDuration()).append("\"").     }     answer.append(" ").append(stat.substring(7, stat.length() - 2)).append(">\n").     if (includeProcessors) {         answer.append(sb).     }     answer.append("</routeStat>").     return answer.toString(). }
false;public;1;18;;public void reset(boolean includeProcessors) throws Exception {     reset().     // and now reset all processors for this route     if (includeProcessors) {         MBeanServer server = getContext().getManagementStrategy().getManagementAgent().getMBeanServer().         if (server != null) {             // get all the processor mbeans and sort them accordingly to their index             String prefix = getContext().getManagementStrategy().getManagementAgent().getIncludeHostName() ? "*/" : "".             ObjectName query = ObjectName.getInstance(jmxDomain + ":context=" + prefix + getContext().getManagementName() + ",type=processors,*").             QueryExp queryExp = Query.match(new AttributeValueExp("RouteId"), new StringValueExp(getRouteId())).             Set<ObjectName> names = server.queryNames(query, queryExp).             for (ObjectName name : names) {                 server.invoke(name, "reset", null, null).             }         }     } }
false;public;0;3;;public String createRouteStaticEndpointJson() {     return getContext().createRouteStaticEndpointJson(getRouteId()). }
false;public;1;4;;@Override public String createRouteStaticEndpointJson(boolean includeDynamic) {     return getContext().createRouteStaticEndpointJson(getRouteId(), includeDynamic). }
false;public;1;4;;@Override public boolean equals(Object o) {     return this == o || (o != null && getClass() == o.getClass() && route.equals(((ManagedRoute) o).route)). }
false;public;0;4;;@Override public int hashCode() {     return route.hashCode(). }
false;private;0;3;;private InflightRepository.InflightExchange getOldestInflightEntry() {     return getContext().getInflightRepository().oldest(getRouteId()). }
false;public;0;8;;public Long getOldestInflightDuration() {     InflightRepository.InflightExchange oldest = getOldestInflightEntry().     if (oldest == null) {         return null.     } else {         return oldest.getDuration().     } }
false;public;0;8;;public String getOldestInflightExchangeId() {     InflightRepository.InflightExchange oldest = getOldestInflightEntry().     if (oldest == null) {         return null.     } else {         return oldest.getExchange().getExchangeId().     } }
false;public;0;4;;@Override public Boolean getHasRouteController() {     return route.getRouteContext().getRouteController() != null. }
false;public;0;15;;@Override public Phase getPhase() {     if (error.getPhase() != null) {         switch(error.getPhase()) {             case START:                 return Phase.START.             case STOP:                 return Phase.STOP.             case SUSPEND:                 return Phase.SUSPEND.             case RESUME:                 return Phase.RESUME.             case SHUTDOWN:                 return Phase.SHUTDOWN.             case REMOVE:                 return Phase.REMOVE.             default:                 throw new IllegalStateException().         }     }     return null. }
false;public;0;4;;@Override public Throwable getException() {     return error.getException(). }
false;public;0;30;;@Override public RouteError getLastError() {     org.apache.camel.spi.RouteError error = route.getRouteContext().getLastError().     if (error == null) {         return null.     } else {         return new RouteError() {              @Override             public Phase getPhase() {                 if (error.getPhase() != null) {                     switch(error.getPhase()) {                         case START:                             return Phase.START.                         case STOP:                             return Phase.STOP.                         case SUSPEND:                             return Phase.SUSPEND.                         case RESUME:                             return Phase.RESUME.                         case SHUTDOWN:                             return Phase.SHUTDOWN.                         case REMOVE:                             return Phase.REMOVE.                         default:                             throw new IllegalStateException().                     }                 }                 return null.             }              @Override             public Throwable getException() {                 return error.getException().             }         }.     } }
false;public;2;4;;@Override public int compare(ManagedProcessorMBean o1, ManagedProcessorMBean o2) {     return o1.getIndex().compareTo(o2.getIndex()). }
