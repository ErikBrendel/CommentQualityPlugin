commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Override @Before public void setUp() throws Exception {     deleteDirectory("target/data/output").     super.setUp(). }
true;public;0;9;/**  * Reproducer for the memory leak: CAMEL-10048  */ ;/**  * Reproducer for the memory leak: CAMEL-10048  */ @Test public void testMemoryLeakInExceptionHandlerCaching() throws Exception {     int messageCount = 100.     for (int i = 0. i < messageCount. i++) {         template.sendBody("direct:start", "message " + i).     }     RoutingSlip routingSlip = context.getProcessor("memory-leak", RoutingSlip.class).     assertNotNull(routingSlip). }
false;public;0;7;;@Override public void configure() throws Exception {     errorHandler(deadLetterChannel("mock:dead")).     from("direct:start").routingSlip(method(SlipProvider.class)).id("memory-leak"). }
false;protected;0;12;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             errorHandler(deadLetterChannel("mock:dead")).             from("direct:start").routingSlip(method(SlipProvider.class)).id("memory-leak").         }     }. }
false;public;1;12;;public String computeSlip(String body) {     /*              * It is important to have a processor here, that does not extend              * AsyncProcessor. Only in this case              * AsyncProcessorConverterHelper.convert() creates a new object,              * thus leading to a memory leak. For example, if you replace file              * endpoint with mock endpoint, then everything goes fine, because              * MockEndpoint.createProducer() creates an implementation of              * AsyncProcessor.              */     return "file:target/data/output". }
