commented;modifiers;parameterAmount;loc;comment;code
false;public;0;39;;@SuppressWarnings("unchecked") @Test public void testGrouped() throws Exception {     MockEndpoint result = getMockEndpoint("mock:result").     // we expect 1 or 2 messages since we group all we get in using the same correlation key     result.expectedMinimumMessageCount(1).     // then we sent all the message at once     template.sendBody("direct:start", "100").     template.sendBody("direct:start", "150").     template.sendBody("direct:start", "130").     template.sendBody("direct:start", "200").     assertMockEndpointsSatisfied().     Exchange out = result.getExchanges().get(0).     List<Exchange> grouped = out.getIn().getBody(List.class).     assertTrue("Should be either 2 or 4, was " + grouped.size(), grouped.size() == 2 || grouped.size() == 4).     assertEquals("100", grouped.get(0).getIn().getBody(String.class)).     assertEquals("150", grouped.get(1).getIn().getBody(String.class)).     // wait a bit for the remainder to come in     Thread.sleep(1000).     if (result.getReceivedCounter() == 2) {         out = result.getExchanges().get(1).         grouped = out.getIn().getBody(List.class).         assertEquals(2, grouped.size()).         assertEquals("130", grouped.get(0).getIn().getBody(String.class)).         assertEquals("200", grouped.get(1).getIn().getBody(String.class)).     } // END SNIPPET: e2 }
false;public;0;12;;public void configure() throws Exception {     // START SNIPPET: e1     // our route is aggregating from the direct queue and sending the response to the mock     from("direct:start").log("Aggregator received ${body}").aggregate(new GroupedExchangeAggregationStrategy()).constant(true).completionSize(2).completionTimeout(500L).to("mock:result"). // END SNIPPET: e1 }
false;protected;0;17;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          public void configure() throws Exception {             // START SNIPPET: e1             // our route is aggregating from the direct queue and sending the response to the mock             from("direct:start").log("Aggregator received ${body}").aggregate(new GroupedExchangeAggregationStrategy()).constant(true).completionSize(2).completionTimeout(500L).to("mock:result").         // END SNIPPET: e1         }     }. }
