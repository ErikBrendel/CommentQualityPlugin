commented;modifiers;parameterAmount;loc;comment;code
false;private,static;2;8;;private static byte[] getBytes(String template, String charset) {     try {         return MessageFormat.format(template, charset).getBytes(charset).     } catch (UnsupportedEncodingException e) {     // ignore     }     return null. }
false;public;0;7;;@Test public void testTokenzeWithUTF8() throws Exception {     XMLTokenExpressionIterator xtei = new XMLTokenExpressionIterator("//statement", 'i').     xtei.setNamespaces(NSMAP).     invokeAndVerify(xtei.createIterator(new ByteArrayInputStream(DATA_UTF8), "utf-8")). }
false;public;0;7;;@Test public void testTokenizeWithISOLatin() throws Exception {     XMLTokenExpressionIterator xtei = new XMLTokenExpressionIterator("//statement", 'i').     xtei.setNamespaces(NSMAP).     invokeAndVerify(xtei.createIterator(new ByteArrayInputStream(DATA_ISOLATIN), "iso-8859-1")). }
false;public;0;7;;@Test public void testTokenizeWithReader() throws Exception {     XMLTokenExpressionIterator xtei = new XMLTokenExpressionIterator("//statement", 'i').     xtei.setNamespaces(NSMAP).     invokeAndVerify(xtei.createIterator(new StringReader(DATA_STRING))). }
false;private;1;14;;private void invokeAndVerify(Iterator<?> tokenizer) throws IOException, XMLStreamException {     List<String> results = new ArrayList<>().     while (tokenizer.hasNext()) {         String token = (String) tokenizer.next().         results.add(token).     }     ((Closeable) tokenizer).close().     assertEquals("token count", RESULTS.length, results.size()).     for (int i = 0. i < RESULTS.length. i++) {         assertEquals("mismatch [" + i + "]", RESULTS[i], results.get(i)).     } }
