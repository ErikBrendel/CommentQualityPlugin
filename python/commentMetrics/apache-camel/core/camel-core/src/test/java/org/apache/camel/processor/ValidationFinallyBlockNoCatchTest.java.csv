commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;@Test public void testValidMessage() throws Exception {     validEndpoint.expectedMessageCount(1).     allEndpoint.expectedMessageCount(1).     template.sendBodyAndHeader("direct:start", "<valid/>", "foo", "bar").     assertMockEndpointsSatisfied(). }
false;public;0;19;;@Test public void testInvalidMessage() throws Exception {     validEndpoint.expectedMessageCount(0).     // allEndpoint should only receive 1 when the message is being moved to the dead letter queue     allEndpoint.expectedMessageCount(1).     // regular error handler is disbled for try .. catch .. finally     deadEndpoint.expectedMessageCount(0).     try {         template.sendBodyAndHeader("direct:start", "<invalid/>", "foo", "notMatchedHeaderValue").         fail("Should have thrown an exception").     } catch (Exception e) {     // expected     }     assertMockEndpointsSatisfied(). }
false;public;0;9;;@Override @Before public void setUp() throws Exception {     super.setUp().     validEndpoint = resolveMandatoryEndpoint("mock:valid", MockEndpoint.class).     allEndpoint = resolveMandatoryEndpoint("mock:all", MockEndpoint.class).     deadEndpoint = resolveMandatoryEndpoint("mock:dead", MockEndpoint.class). }
false;public;0;11;;public void configure() {     // use dead letter channel that supports redeliveries     errorHandler(deadLetterChannel("mock:dead").redeliveryDelay(0).maximumRedeliveries(3).logStackTrace(false)).     from("direct:start").doTry().process(validator).to("mock:valid").doFinally().to("mock:all"). }
false;protected;0;15;;protected RouteBuilder createRouteBuilder() {     return new RouteBuilder() {          public void configure() {             // use dead letter channel that supports redeliveries             errorHandler(deadLetterChannel("mock:dead").redeliveryDelay(0).maximumRedeliveries(3).logStackTrace(false)).             from("direct:start").doTry().process(validator).to("mock:valid").doFinally().to("mock:all").         }     }. }
