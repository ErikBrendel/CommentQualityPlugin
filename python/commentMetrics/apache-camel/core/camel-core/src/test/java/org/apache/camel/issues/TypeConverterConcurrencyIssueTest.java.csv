commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Override public void run() {     try {         context.getTypeConverter().mandatoryConvertTo(MyCamelBean.class, "1.MyCamel").         latch.countDown().     } catch (NoTypeConversionAvailableException e) {     // ignore, as the latch will not be decremented anymore so that the assert below     // will fail after the one minute timeout anyway     } }
false;public;0;29;;@Test public void testTypeConverter() throws Exception {     // add as type converter     Method method = TypeConverterConcurrencyIssueTest.class.getMethod("toMyCamelBean", String.class).     assertNotNull(method).     context.getTypeConverterRegistry().addTypeConverter(MyCamelBean.class, String.class, new StaticMethodTypeConverter(method, false)).     ExecutorService pool = context.getExecutorServiceManager().newThreadPool(this, "test", 50, 50).     final CountDownLatch latch = new CountDownLatch(size).     StopWatch watch = new StopWatch().     for (int i = 0. i < size. i++) {         pool.submit(new Runnable() {              @Override             public void run() {                 try {                     context.getTypeConverter().mandatoryConvertTo(MyCamelBean.class, "1.MyCamel").                     latch.countDown().                 } catch (NoTypeConversionAvailableException e) {                 // ignore, as the latch will not be decremented anymore so that the assert below                 // will fail after the one minute timeout anyway                 }             }         }).     }     assertTrue("The expected mandatory conversions failed!", latch.await(1, TimeUnit.MINUTES)).     log.info("Took {} millis to convert {} objects", watch.taken(), size). }
false;public,static;1;7;;public static MyCamelBean toMyCamelBean(String body) {     MyCamelBean bean = new MyCamelBean().     String[] data = body.split(".").     bean.setId(Integer.parseInt(data[0])).     bean.setName(data[1]).     return bean. }
