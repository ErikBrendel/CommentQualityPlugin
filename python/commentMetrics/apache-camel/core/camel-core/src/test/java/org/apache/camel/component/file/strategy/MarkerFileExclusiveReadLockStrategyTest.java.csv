commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override @Before public void setUp() throws Exception {     deleteDirectory("target/data/marker/").     createDirectory("target/data/marker/in").     super.setUp(). }
false;public;0;33;;@Test public void testMultithreadedLocking() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMessageCount(2).     mock.expectedFileExists("target/data/marker/out/file1.dat").     mock.expectedFileExists("target/data/marker/out/file2.dat").     writeFiles().     assertMockEndpointsSatisfied().     String content = context.getTypeConverter().convertTo(String.class, new File("target/data/marker/out/file1.dat")).     String[] lines = content.split(LS).     for (int i = 0. i < 20. i++) {         assertEquals("Line " + i, lines[i]).     }     content = context.getTypeConverter().convertTo(String.class, new File("target/data/marker/out/file2.dat")).     lines = content.split(LS).     for (int i = 0. i < 20. i++) {         assertEquals("Line " + i, lines[i]).     }     waitUntilCompleted().     assertFileDoesNotExists("target/data/marker/in/file1.dat.camelLock").     assertFileDoesNotExists("target/data/marker/in/file2.dat.camelLock").     assertFileDoesNotExists("target/data/marker/in/file1.dat").     assertFileDoesNotExists("target/data/marker/in/file2.dat").     assertEquals(2, this.numberOfFilesProcessed.get()). }
false;private;0;16;;private void writeFiles() throws Exception {     LOG.debug("Writing files...").     FileOutputStream fos = new FileOutputStream("target/data/marker/in/file1.dat").     FileOutputStream fos2 = new FileOutputStream("target/data/marker/in/file2.dat").     for (int i = 0. i < 20. i++) {         fos.write(("Line " + i + LS).getBytes()).         fos2.write(("Line " + i + LS).getBytes()).         LOG.debug("Writing line " + i).     }     fos.flush().     fos.close().     fos2.flush().     fos2.close(). }
false;public;1;3;;public void process(Exchange exchange) throws Exception {     numberOfFilesProcessed.addAndGet(1). }
false;public;0;13;;@Override public void configure() throws Exception {     from("file:target/data/marker/in?readLock=markerFile&initialDelay=0&delay=10").onCompletion().process(new Processor() {          public void process(Exchange exchange) throws Exception {             numberOfFilesProcessed.addAndGet(1).         }     }).end().threads(NUMBER_OF_THREADS).to("file:target/data/marker/out", "mock:result"). }
false;protected;0;18;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             from("file:target/data/marker/in?readLock=markerFile&initialDelay=0&delay=10").onCompletion().process(new Processor() {                  public void process(Exchange exchange) throws Exception {                     numberOfFilesProcessed.addAndGet(1).                 }             }).end().threads(NUMBER_OF_THREADS).to("file:target/data/marker/out", "mock:result").         }     }. }
false;private;0;9;;private void waitUntilCompleted() {     while (this.numberOfFilesProcessed.get() < 2) {         try {             Thread.sleep(10).         } catch (InterruptedException e) {         // ignore         }     } }
false;private,static;1;4;;private static void assertFileDoesNotExists(String filename) {     File file = new File(filename).     assertFalse("File " + filename + " should not exist, it should have been deleted after being processed", file.exists()). }
