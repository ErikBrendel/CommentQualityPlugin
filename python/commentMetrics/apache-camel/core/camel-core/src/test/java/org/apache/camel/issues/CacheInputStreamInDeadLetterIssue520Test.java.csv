commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Test public void testSendingInputStream() throws Exception {     InputStream message = new ByteArrayInputStream("<hello>Willem</hello>".getBytes()).     sendingMessage(message). }
false;public;0;5;;@Test public void testSendingReader() throws Exception {     StringReader message = new StringReader("<hello>Willem</hello>").     sendingMessage(message). }
false;public;0;5;;@Test public void testSendingSource() throws Exception {     StreamSource message = new StreamSource(new StringReader("<hello>Willem</hello>")).     sendingMessage(message). }
false;private;1;12;;private void sendingMessage(Object message) throws InterruptedException {     count = 0.     MockEndpoint mock = getMockEndpoint("mock:error").     mock.expectedMessageCount(1).     // having dead letter channel as the errorHandler in place makes exchanges to appear as completed from     // the client point of view so that we don't count with any thrown exception here (the client side)     template.sendBody("direct:start", message).     assertEquals("The message should be delivered 4 times", count, 4).     mock.assertIsSatisfied(). }
false;public;1;7;;public void process(Exchange exchange) throws Exception {     count++.     // Read the in stream from cache     String result = exchange.getIn().getBody(String.class).     assertEquals("Should read the inputstream out again", "<hello>Willem</hello>", result).     throw new Exception("Forced exception by unit test"). }
false;public;1;4;;public void process(Exchange exchange) throws Exception {     String result = exchange.getIn().getBody(String.class).     assertEquals("Should read the inputstream out again", "<hello>Willem</hello>", result). }
false;public;0;26;;public void configure() throws Exception {     // enable stream caching     context.setStreamCaching(true).     // 0 delay for faster unit test     errorHandler(deadLetterChannel("direct:errorHandler").maximumRedeliveries(3).redeliveryDelay(0)).     from("direct:start").process(new Processor() {          public void process(Exchange exchange) throws Exception {             count++.             // Read the in stream from cache             String result = exchange.getIn().getBody(String.class).             assertEquals("Should read the inputstream out again", "<hello>Willem</hello>", result).             throw new Exception("Forced exception by unit test").         }     }).     // Need to set the streamCaching for the deadLetterChannel     from("direct:errorHandler").process(new Processor() {          public void process(Exchange exchange) throws Exception {             String result = exchange.getIn().getBody(String.class).             assertEquals("Should read the inputstream out again", "<hello>Willem</hello>", result).         }     }).to("mock:error"). }
false;protected;0;31;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          public void configure() throws Exception {             // enable stream caching             context.setStreamCaching(true).             // 0 delay for faster unit test             errorHandler(deadLetterChannel("direct:errorHandler").maximumRedeliveries(3).redeliveryDelay(0)).             from("direct:start").process(new Processor() {                  public void process(Exchange exchange) throws Exception {                     count++.                     // Read the in stream from cache                     String result = exchange.getIn().getBody(String.class).                     assertEquals("Should read the inputstream out again", "<hello>Willem</hello>", result).                     throw new Exception("Forced exception by unit test").                 }             }).             // Need to set the streamCaching for the deadLetterChannel             from("direct:errorHandler").process(new Processor() {                  public void process(Exchange exchange) throws Exception {                     String result = exchange.getIn().getBody(String.class).                     assertEquals("Should read the inputstream out again", "<hello>Willem</hello>", result).                 }             }).to("mock:error").         }     }. }
