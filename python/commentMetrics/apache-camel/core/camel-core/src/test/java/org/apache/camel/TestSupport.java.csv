commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return getName() + "(" + getClass().getName() + ")". }
false;public;0;3;;public String getName() {     return name.getMethodName(). }
false;public;0;7;;@Before public void setUp() throws Exception {     // start with a clean slate     DefaultCamelContext.setContextCounter(0).     TestSupportNodeIdFactory.resetCounters().     Assume.assumeTrue(canRunOnThisPlatform()). }
false;public;0;5;;@After public void tearDown() throws Exception {     // make sure we cleanup the platform mbean server     TestSupportJmxCleanup.removeMBeans(null). }
false;protected;0;3;;protected boolean canRunOnThisPlatform() {     return true. }
true;public,static;1;3;/**  * Returns a value builder for the given header  */ ;// Builder methods for expressions used when testing // ------------------------------------------------------------------------- /**  * Returns a value builder for the given header  */ public static ValueBuilder header(String name) {     return Builder.header(name). }
true;public,static;1;3;/**  * Returns a value builder for the given exchange property  */ ;/**  * Returns a value builder for the given exchange property  */ public static ValueBuilder exchangeProperty(String name) {     return Builder.exchangeProperty(name). }
true;public,static;0;3;/**  * Returns a predicate and value builder for the inbound body on an exchange  */ ;/**  * Returns a predicate and value builder for the inbound body on an exchange  */ public static ValueBuilder body() {     return Builder.body(). }
true;public,static;1;3;/**  * Returns a predicate and value builder for the inbound message body as a  * specific type  */ ;/**  * Returns a predicate and value builder for the inbound message body as a  * specific type  */ public static <T> ValueBuilder bodyAs(Class<T> type) {     return Builder.bodyAs(type). }
true;public,static;1;3;/**  * Returns a value builder for the given system property  */ ;/**  * Returns a value builder for the given system property  */ public static ValueBuilder systemProperty(String name) {     return Builder.systemProperty(name). }
true;public,static;2;3;/**  * Returns a value builder for the given system property  */ ;/**  * Returns a value builder for the given system property  */ public static ValueBuilder systemProperty(String name, String defaultValue) {     return Builder.systemProperty(name, defaultValue). }
false;public,static;2;6;;// Assertions // ----------------------------------------------------------------------- public static <T> T assertIsInstanceOf(Class<T> expectedType, Object value) {     assertNotNull("Expected an instance of type: " + expectedType.getName() + " but was null", value).     assertTrue("object should be a " + expectedType.getName() + " but was: " + value + " with type: " + value.getClass().getName(), expectedType.isInstance(value)).     return expectedType.cast(value). }
false;public,static;2;4;;public static void assertEndpointUri(Endpoint endpoint, String uri) {     assertNotNull("Endpoint is null when expecting endpoint for: " + uri, endpoint).     assertEquals("Endoint uri for: " + endpoint, uri, endpoint.getEndpointUri()). }
true;public,static;3;3;/**  * Asserts the In message on the exchange contains the expected value  */ ;/**  * Asserts the In message on the exchange contains the expected value  */ public static Object assertInMessageHeader(Exchange exchange, String name, Object expected) {     return assertMessageHeader(exchange.getIn(), name, expected). }
true;public,static;3;3;/**  * Asserts the Out message on the exchange contains the expected value  */ ;/**  * Asserts the Out message on the exchange contains the expected value  */ public static Object assertOutMessageHeader(Exchange exchange, String name, Object expected) {     return assertMessageHeader(exchange.getOut(), name, expected). }
true;public,static;2;14;/**  * Asserts that the given exchange has an OUT message of the given body value  *  * @param exchange the exchange which should have an OUT message  * @param expected the expected value of the OUT message  * @throws InvalidPayloadException is thrown if the payload is not the expected class type  */ ;/**  * Asserts that the given exchange has an OUT message of the given body value  *  * @param exchange the exchange which should have an OUT message  * @param expected the expected value of the OUT message  * @throws InvalidPayloadException is thrown if the payload is not the expected class type  */ public static void assertInMessageBodyEquals(Exchange exchange, Object expected) throws InvalidPayloadException {     assertNotNull("Should have a response exchange!", exchange).     Object actual.     if (expected == null) {         actual = exchange.getIn().getMandatoryBody().         assertEquals("in body of: " + exchange, expected, actual).     } else {         actual = exchange.getIn().getMandatoryBody(expected.getClass()).     }     assertEquals("in body of: " + exchange, expected, actual).     LOG.debug("Received response: {} with in: {}", exchange, exchange.getIn()). }
true;public,static;2;14;/**  * Asserts that the given exchange has an OUT message of the given body value  *  * @param exchange the exchange which should have an OUT message  * @param expected the expected value of the OUT message  * @throws InvalidPayloadException is thrown if the payload is not the expected class type  */ ;/**  * Asserts that the given exchange has an OUT message of the given body value  *  * @param exchange the exchange which should have an OUT message  * @param expected the expected value of the OUT message  * @throws InvalidPayloadException is thrown if the payload is not the expected class type  */ public static void assertOutMessageBodyEquals(Exchange exchange, Object expected) throws InvalidPayloadException {     assertNotNull("Should have a response exchange!", exchange).     Object actual.     if (expected == null) {         actual = exchange.getOut().getMandatoryBody().         assertEquals("output body of: " + exchange, expected, actual).     } else {         actual = exchange.getOut().getMandatoryBody(expected.getClass()).     }     assertEquals("output body of: " + exchange, expected, actual).     LOG.debug("Received response: {} with out: {}", exchange, exchange.getOut()). }
false;public,static;3;5;;public static Object assertMessageHeader(Message message, String name, Object expected) {     Object value = message.getHeader(name).     assertEquals("Header: " + name + " on Message: " + message, expected, value).     return value. }
false;public,static;3;5;;public static Object assertProperty(Exchange exchange, String name, Object expected) {     Object value = exchange.getProperty(name).     assertEquals("Property: " + name + " on Exchange: " + exchange, expected, value).     return value. }
true;public,static;3;13;/**  * Asserts that the given expression when evaluated returns the given answer  */ ;/**  * Asserts that the given expression when evaluated returns the given answer  */ public static Object assertExpression(Expression expression, Exchange exchange, Object expected) {     Object value.     if (expected != null) {         value = expression.evaluate(exchange, expected.getClass()).     } else {         value = expression.evaluate(exchange, Object.class).     }     LOG.debug("Evaluated expression: {} on exchange: {} result: {}", expression, exchange, value).     assertEquals("Expression: " + expression + " on Exchange: " + exchange, expected, value).     return value. }
true;public,static;2;3;/**  * Asserts that the predicate returns the expected value on the exchange  */ ;/**  * Asserts that the predicate returns the expected value on the exchange  */ public static void assertPredicateMatches(Predicate predicate, Exchange exchange) {     assertPredicate(predicate, exchange, true). }
true;public,static;2;8;/**  * Asserts that the predicate returns the expected value on the exchange  */ ;/**  * Asserts that the predicate returns the expected value on the exchange  */ public static void assertPredicateDoesNotMatch(Predicate predicate, Exchange exchange) {     try {         PredicateAssertHelper.assertMatches(predicate, "Predicate should match: ", exchange).     } catch (AssertionError e) {         LOG.debug("Caught expected assertion error: " + e).     }     assertPredicate(predicate, exchange, false). }
true;public,static;3;11;/**  * Asserts that the predicate returns the expected value on the exchange  */ ;/**  * Asserts that the predicate returns the expected value on the exchange  */ public static boolean assertPredicate(final Predicate predicate, Exchange exchange, boolean expected) {     if (expected) {         PredicateAssertHelper.assertMatches(predicate, "Predicate failed: ", exchange).     }     boolean value = predicate.matches(exchange).     LOG.debug("Evaluated predicate: {} on exchange: {} result: {}", predicate, exchange, value).     assertEquals("Predicate: " + predicate + " on Exchange: " + exchange, expected, value).     return value. }
true;public,static;2;7;/**  * Resolves an endpoint and asserts that it is found  */ ;/**  * Resolves an endpoint and asserts that it is found  */ public static Endpoint resolveMandatoryEndpoint(CamelContext context, String uri) {     Endpoint endpoint = context.getEndpoint(uri).     assertNotNull("No endpoint found for URI: " + uri, endpoint).     return endpoint. }
true;public,static;3;8;/**  * Resolves an endpoint and asserts that it is found  */ ;/**  * Resolves an endpoint and asserts that it is found  */ public static <T extends Endpoint> T resolveMandatoryEndpoint(CamelContext context, String uri, Class<T> endpointType) {     T endpoint = context.getEndpoint(uri, endpointType).     assertNotNull("No endpoint found for URI: " + uri, endpoint).     return endpoint. }
true;protected;2;8;/**  * Creates an exchange with the given body  */ ;/**  * Creates an exchange with the given body  */ protected Exchange createExchangeWithBody(CamelContext camelContext, Object body) {     Exchange exchange = new DefaultExchange(camelContext).     Message message = exchange.getIn().     message.setHeader("testName", getName()).     message.setHeader("testClass", getClass().getName()).     message.setBody(body).     return exchange. }
false;public,static;1;4;;public static <T> T assertOneElement(List<T> list) {     assertEquals("Size of list should be 1: " + list, 1, list.size()).     return list.get(0). }
true;public,static;2;3;/**  * Asserts that a list is of the given size  */ ;/**  * Asserts that a list is of the given size  */ public static <T> List<T> assertListSize(List<T> list, int size) {     return assertListSize("List", list, size). }
true;public,static;3;5;/**  * Asserts that a list is of the given size  */ ;/**  * Asserts that a list is of the given size  */ public static <T> List<T> assertListSize(String message, List<T> list, int size) {     assertEquals(message + " should be of size: " + size + " but is: " + list, size, list.size()).     return list. }
true;public,static;2;3;/**  * Asserts that a list is of the given size  */ ;/**  * Asserts that a list is of the given size  */ public static <T> Collection<T> assertCollectionSize(Collection<T> list, int size) {     return assertCollectionSize("List", list, size). }
true;public,static;3;5;/**  * Asserts that a list is of the given size  */ ;/**  * Asserts that a list is of the given size  */ public static <T> Collection<T> assertCollectionSize(String message, Collection<T> list, int size) {     assertEquals(message + " should be of size: " + size + " but is: " + list, size, list.size()).     return list. }
true;public,static;1;8;/**  * A helper method to create a list of Route objects for a given route builder  */ ;/**  * A helper method to create a list of Route objects for a given route builder  */ public static List<Route> getRouteList(RouteBuilder builder) throws Exception {     CamelContext context = new DefaultCamelContext().     context.addRoutes(builder).     context.start().     List<Route> answer = context.getRoutes().     context.stop().     return answer. }
true;public,static;2;4;/**  * Asserts that the text contains the given string  *  * @param text          the text to compare  * @param containedText the text which must be contained inside the other text parameter  */ ;/**  * Asserts that the text contains the given string  *  * @param text          the text to compare  * @param containedText the text which must be contained inside the other text parameter  */ public static void assertStringContains(String text, String containedText) {     assertNotNull("Text should not be null!", text).     assertTrue("Text: " + text + " does not contain: " + containedText, text.contains(containedText)). }
true;public,static;1;9;/**  * If a processor is wrapped with a bunch of DelegateProcessor or DelegateAsyncProcessor objects  * this call will drill through them and return the wrapped Processor.  */ ;/**  * If a processor is wrapped with a bunch of DelegateProcessor or DelegateAsyncProcessor objects  * this call will drill through them and return the wrapped Processor.  */ public static Processor unwrap(Processor processor) {     while (true) {         if (processor instanceof DelegateProcessor) {             processor = ((DelegateProcessor) processor).getProcessor().         } else {             return processor.         }     } }
true;public,static;1;13;/**  * If a processor is wrapped with a bunch of DelegateProcessor or DelegateAsyncProcessor objects  * this call will drill through them and return the Channel.  * <p/>  * Returns null if no channel is found.  */ ;/**  * If a processor is wrapped with a bunch of DelegateProcessor or DelegateAsyncProcessor objects  * this call will drill through them and return the Channel.  * <p/>  * Returns null if no channel is found.  */ public static Channel unwrapChannel(Processor processor) {     while (true) {         if (processor instanceof Channel) {             return (Channel) processor.         } else if (processor instanceof DelegateProcessor) {             processor = ((DelegateProcessor) processor).getProcessor().         } else if (processor instanceof ErrorHandlerSupport) {             processor = ((ErrorHandlerSupport) processor).getOutput().         } else {             return null.         }     } }
true;public,static;1;3;/**  * Recursively delete a directory, useful to zapping test data  *  * @param file the directory to be deleted  */ ;/**  * Recursively delete a directory, useful to zapping test data  *  * @param file the directory to be deleted  */ public static void deleteDirectory(String file) {     deleteDirectory(new File(file)). }
true;public,static;1;10;/**  * Recursively delete a directory, useful to zapping test data  *  * @param file the directory to be deleted  */ ;/**  * Recursively delete a directory, useful to zapping test data  *  * @param file the directory to be deleted  */ public static void deleteDirectory(File file) {     if (file.isDirectory()) {         File[] files = file.listFiles().         for (File child : files) {             deleteDirectory(child).         }     }     file.delete(). }
true;public,static;1;4;/**  * create the directory  *  * @param file the directory to be created  */ ;/**  * create the directory  *  * @param file the directory to be created  */ public static void createDirectory(String file) {     File dir = new File(file).     dir.mkdirs(). }
true;public,static;2;3;/**  * To be used for folder/directory comparison that works across different platforms such  * as Window, Mac and Linux.  */ ;/**  * To be used for folder/directory comparison that works across different platforms such  * as Window, Mac and Linux.  */ public static void assertDirectoryEquals(String expected, String actual) {     assertDirectoryEquals(null, expected, actual). }
true;public,static;3;11;/**  * To be used for folder/directory comparison that works across different platforms such  * as Window, Mac and Linux.  */ ;/**  * To be used for folder/directory comparison that works across different platforms such  * as Window, Mac and Linux.  */ public static void assertDirectoryEquals(String message, String expected, String actual) {     // must use single / as path separators     String expectedPath = expected.replace('\\', '/').     String actualPath = actual.replace('\\', '/').     if (message != null) {         assertEquals(message, expectedPath, actualPath).     } else {         assertEquals(expectedPath, actualPath).     } }
true;public,static;1;5;/**  * To be used to check is a directory is found in the file system  */ ;/**  * To be used to check is a directory is found in the file system  */ public static void assertDirectoryExists(String filename) {     File file = new File(filename).     assertTrue("Directory " + filename + " should exist", file.exists()).     assertTrue("Directory " + filename + " should be a directory", file.isDirectory()). }
true;public,static;1;5;/**  * To be used to check is a file is found in the file system  */ ;/**  * To be used to check is a file is found in the file system  */ public static void assertFileExists(String filename) {     File file = new File(filename).     assertTrue("File " + filename + " should exist", file.exists()).     assertTrue("File " + filename + " should be a file", file.isFile()). }
true;public,static;1;4;/**  * To be used to check is a file is <b>not</b> found in the file system  */ ;/**  * To be used to check is a file is <b>not</b> found in the file system  */ public static void assertFileNotExists(String filename) {     File file = new File(filename).     assertFalse("File " + filename + " should not exist", file.exists()). }
true;public,static;1;4;/**  * Is this OS the given platform.  * <p/>  * Uses <tt>os.name</tt> from the system properties to determine the OS.  *  * @param platform such as Windows  * @return <tt>true</tt> if its that platform.  */ ;/**  * Is this OS the given platform.  * <p/>  * Uses <tt>os.name</tt> from the system properties to determine the OS.  *  * @param platform such as Windows  * @return <tt>true</tt> if its that platform.  */ public static boolean isPlatform(String platform) {     String osName = System.getProperty("os.name").toLowerCase(Locale.ENGLISH).     return osName.contains(platform.toLowerCase(Locale.ENGLISH)). }
true;public,static;1;4;/**  * Is this Java by the given vendor.  * <p/>  * Uses <tt>java.vendor</tt> from the system properties to determine the vendor.  *  * @param vendor such as IBM  * @return <tt>true</tt> if its that vendor.  */ ;/**  * Is this Java by the given vendor.  * <p/>  * Uses <tt>java.vendor</tt> from the system properties to determine the vendor.  *  * @param vendor such as IBM  * @return <tt>true</tt> if its that vendor.  */ public static boolean isJavaVendor(String vendor) {     String javaVendor = System.getProperty("java.vendor").toLowerCase(Locale.ENGLISH).     return javaVendor.contains(vendor.toLowerCase(Locale.ENGLISH)). }
true;public,static;1;7;/**  * Is this version the given Java version.  * <p/>  * Uses <tt>java.version</tt> from the system properties to determine the version.  *  * @param version such as 1.6 or 6  * @return <tt>true</tt> if its that vendor.  */ ;/**  * Is this version the given Java version.  * <p/>  * Uses <tt>java.version</tt> from the system properties to determine the version.  *  * @param version such as 1.6 or 6  * @return <tt>true</tt> if its that vendor.  */ public static boolean isJavaVersion(String version) {     if (version.contains(".")) {         // before jdk 9         return Integer.parseInt(version.split("\\.")[1]) == getJavaMajorVersion().     } else {         return Integer.parseInt(version) == getJavaMajorVersion().     } }
true;public,static;0;8;/**  * Returns the current major Java version e.g 8.  * <p/>  * Uses <tt>java.specification.version</tt> from the system properties to determine the major version.  *  * @return the current major Java version.  */ ;/**  * Returns the current major Java version e.g 8.  * <p/>  * Uses <tt>java.specification.version</tt> from the system properties to determine the major version.  *  * @return the current major Java version.  */ public static int getJavaMajorVersion() {     String javaSpecVersion = System.getProperty("java.specification.version").     if (javaSpecVersion.contains(".")) {         // before jdk 9         return Integer.parseInt(javaSpecVersion.split("\\.")[1]).     } else {         return Integer.parseInt(javaSpecVersion).     } }
true;public,static;3;12;/**  * Used for registering a sysetem property.  * <p/>  * if the property already contains the passed value nothing will happen.  * If the system property has already a value, the passed value will be appended separated by <tt>separator</tt>  *  * @param sysPropertyName   the name of the system property to be set  * @param sysPropertyValue  the value to be set for the system property passed as sysPropertyName  * @param separator         the property separator to be used to append sysPropertyValue  */ ;/**  * Used for registering a sysetem property.  * <p/>  * if the property already contains the passed value nothing will happen.  * If the system property has already a value, the passed value will be appended separated by <tt>separator</tt>  *  * @param sysPropertyName   the name of the system property to be set  * @param sysPropertyValue  the value to be set for the system property passed as sysPropertyName  * @param separator         the property separator to be used to append sysPropertyValue  */ public static void registerSystemProperty(String sysPropertyName, String sysPropertyValue, String separator) {     synchronized (System.getProperties()) {         if (System.getProperties().contains(sysPropertyName)) {             String current = System.getProperty(sysPropertyName).             if (!current.contains(sysPropertyValue)) {                 System.setProperty(sysPropertyName, current + separator + sysPropertyValue).             }         } else {             System.setProperty(sysPropertyName, sysPropertyValue).         }     } }
