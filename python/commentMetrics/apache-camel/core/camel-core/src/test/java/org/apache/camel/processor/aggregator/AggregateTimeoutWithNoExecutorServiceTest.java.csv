commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;@Test public void testThreadUsedForEveryAggregatorWhenDefaultExecutorServiceUsed() throws Exception {     assertTrue("There should be a thread for every aggregator when using defaults", AggregateTimeoutWithExecutorServiceTest.aggregateThreadsCount() >= AggregateTimeoutWithExecutorServiceTest.NUM_AGGREGATORS).     // sanity check to make sure were testing routes that work     for (int i = 0. i < AggregateTimeoutWithExecutorServiceTest.NUM_AGGREGATORS. ++i) {         MockEndpoint result = getMockEndpoint("mock:result" + i).         // by default the use latest aggregation strategy is used so we get message 4         result.expectedBodiesReceived("Message 4").     }     for (int i = 0. i < AggregateTimeoutWithExecutorServiceTest.NUM_AGGREGATORS. ++i) {         for (int j = 0. j < 5. j++) {             template.sendBodyAndHeader("direct:start" + i, "Message " + j, "id", "1").         }     }     assertMockEndpointsSatisfied(). }
false;public;0;9;;@Override public void configure() throws Exception {     for (int i = 0. i < AggregateTimeoutWithExecutorServiceTest.NUM_AGGREGATORS. ++i) {         from("direct:start" + i).aggregate(header("id"), new UseLatestAggregationStrategy()).completionTimeout(100).completionTimeoutCheckerInterval(10).to("mock:result" + i).     } }
false;protected;0;14;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             for (int i = 0. i < AggregateTimeoutWithExecutorServiceTest.NUM_AGGREGATORS. ++i) {                 from("direct:start" + i).aggregate(header("id"), new UseLatestAggregationStrategy()).completionTimeout(100).completionTimeoutCheckerInterval(10).to("mock:result" + i).             }         }     }. }
