commented;modifiers;parameterAmount;loc;comment;code
false;public;0;12;;@Test public void testSplitAndAggregateInOut() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedBodiesReceived(expectedBody).     // use requestBody as its InOut     Object out = template.requestBody("direct:start", "A@B@C").     assertEquals(expectedBody, out).     LOG.debug("Response to caller: " + out).     assertMockEndpointsSatisfied(). }
false;protected;0;6;;@Override protected JndiRegistry createRegistry() throws Exception {     JndiRegistry jndi = super.createRegistry().     jndi.bind("MyOrderService", new MyOrderService()).     return jndi. }
false;public;0;22;;@Override public void configure() throws Exception {     // START SNIPPET: e1     // this routes starts from the direct:start endpoint     // the body is then splitted based on @ separator     // the splitter in Camel supports InOut as well and for that we need     // to be able to aggregate what response we need to send back, so we provide our     // own strategy with the class MyOrderStrategy.     from("direct:start").split(body().tokenize("@"), new MyOrderStrategy()).to("bean:MyOrderService?method=handleOrder").end().to("bean:MyOrderService?method=buildCombinedResponse").to("mock:result"). }
false;protected;0;27;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             // START SNIPPET: e1             // this routes starts from the direct:start endpoint             // the body is then splitted based on @ separator             // the splitter in Camel supports InOut as well and for that we need             // to be able to aggregate what response we need to send back, so we provide our             // own strategy with the class MyOrderStrategy.             from("direct:start").split(body().tokenize("@"), new MyOrderStrategy()).to("bean:MyOrderService?method=handleOrder").end().to("bean:MyOrderService?method=buildCombinedResponse").to("mock:result").         }     }. }
true;public;1;4;/**  * We just handle the order by returning a id line for the order  */ ;/**  * We just handle the order by returning a id line for the order  */ public String handleOrder(String line) {     LOG.debug("HandleOrder: " + line).     return "(id=" + ++counter + ",item=" + line + ")". }
true;public;1;4;/**  * We use the same bean for building the combined response to send  * back to the original caller  */ ;/**  * We use the same bean for building the combined response to send  * back to the original caller  */ public String buildCombinedResponse(String line) {     LOG.debug("BuildCombinedResponse: " + line).     return "Response[" + line + "]". }
false;public;2;23;;public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {     if (oldExchange == null) {         // so we just return it         return newExchange.     }     String orders = oldExchange.getIn().getBody(String.class).     String newLine = newExchange.getIn().getBody(String.class).     LOG.debug("Aggregate old orders: " + orders).     LOG.debug("Aggregate new order: " + newLine).     // put orders together separating by semi colon     orders = orders + "." + newLine.     // put combined order back on old to preserve it     oldExchange.getIn().setBody(orders).     // return old as this is the one that has all the orders gathered until now     return oldExchange. }
