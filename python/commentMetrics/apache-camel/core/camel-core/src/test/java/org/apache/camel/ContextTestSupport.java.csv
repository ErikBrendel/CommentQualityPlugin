commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Use the RouteBuilder or not  * @return  *  If the return value is true, the camel context will be started in the setup method.  *  If the return value is false, the camel context will not be started in the setup method.  */ ;/**  * Use the RouteBuilder or not  * @return  *  If the return value is true, the camel context will be started in the setup method.  *  If the return value is false, the camel context will not be started in the setup method.  */ public boolean isUseRouteBuilder() {     return useRouteBuilder. }
false;public;1;3;;public void setUseRouteBuilder(boolean useRouteBuilder) {     this.useRouteBuilder = useRouteBuilder. }
false;public;0;3;;public Service getCamelContextService() {     return camelContextService. }
true;public;1;3;/**  * Allows a service to be registered a separate lifecycle service to start  * and stop the context. such as for Spring when the ApplicationContext is  * started and stopped, rather than directly stopping the CamelContext  */ ;/**  * Allows a service to be registered a separate lifecycle service to start  * and stop the context. such as for Spring when the ApplicationContext is  * started and stopped, rather than directly stopping the CamelContext  */ public void setCamelContextService(Service camelContextService) {     this.camelContextService = camelContextService. }
true;protected;0;3;/**  * Convenient api to create a NotifyBuilder to be notified of a specific event  */ ;/**  * Convenient api to create a NotifyBuilder to be notified of a specific event  */ protected NotifyBuilder event() {     return new NotifyBuilder(context). }
false;public;0;39;;@Before public void setUp() throws Exception {     super.setUp().     // make SEDA testing faster     System.setProperty("CamelSedaPollTimeout", "10").     CamelContext c2 = createCamelContext().     if (c2 instanceof ModelCamelContext) {         context = (ModelCamelContext) c2.     } else {         throw new Exception("Context must be a ModelCamelContext").     }     assertValidContext(context).     context.init().     // reduce default shutdown timeout to avoid waiting for 300 seconds     context.getShutdownStrategy().setTimeout(10).     template = context.createProducerTemplate().     template.start().     consumer = context.createConsumerTemplate().     consumer.start().     // create a default notifier when 1 exchange is done which is the most common case     oneExchangeDone = event().whenDone(1).create().     if (isUseRouteBuilder()) {         RouteBuilder[] builders = createRouteBuilders().         for (RouteBuilder builder : builders) {             log.debug("Using created route builder: {}", builder).             context.addRoutes(builder).         }         startCamelContext().     } else {         log.debug("isUseRouteBuilder() is false").     } }
false;public;0;14;;@After public void tearDown() throws Exception {     log.debug("tearDown test: {}", getName()).     if (consumer != null) {         consumer.stop().     }     if (template != null) {         template.stop().     }     stopCamelContext().     System.clearProperty("CamelSedaPollTimeout").     super.tearDown(). }
true;protected;0;3;/**  * Whether or not JMX should be used during testing.  *  * @return <tt>false</tt> by default.  */ ;/**  * Whether or not JMX should be used during testing.  *  * @return <tt>false</tt> by default.  */ protected boolean useJmx() {     return false. }
true;protected;0;3;/**  * Whether to load additional type converters by scanning the classpath.  * This should only be enabled for tests that uses custom type converters.  */ ;/**  * Whether to load additional type converters by scanning the classpath.  * This should only be enabled for tests that uses custom type converters.  */ protected boolean isLoadTypeConverters() {     return true. }
false;protected;0;9;;protected void stopCamelContext() throws Exception {     if (camelContextService != null) {         camelContextService.stop().     } else {         if (context != null) {             context.stop().         }     } }
false;protected;0;14;;protected void startCamelContext() throws Exception {     if (camelContextService != null) {         camelContextService.start().     } else {         if (context instanceof DefaultCamelContext) {             DefaultCamelContext defaultCamelContext = (DefaultCamelContext) context.             if (!defaultCamelContext.isStarted()) {                 defaultCamelContext.start().             }         } else {             context.start().         }     } }
false;protected;0;9;;protected CamelContext createCamelContext() throws Exception {     DefaultCamelContext context = new DefaultCamelContext(false).     if (!useJmx()) {         context.disableJMX().     }     context.setRegistry(createRegistry()).     context.setLoadTypeConverters(isLoadTypeConverters()).     return context. }
false;protected;0;3;;protected JndiRegistry createRegistry() throws Exception {     return new JndiRegistry(createJndiContext()). }
false;protected;0;3;;protected Context createJndiContext() throws Exception {     return JndiTest.createInitialContext(). }
false;public;0;3;;public void configure() { // no routes added by default }
true;protected;0;7;/**  * Factory method which derived classes can use to create a {@link RouteBuilder}  * to define the routes for testing  */ ;/**  * Factory method which derived classes can use to create a {@link RouteBuilder}  * to define the routes for testing  */ protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          public void configure() {         // no routes added by default         }     }. }
true;protected;0;3;/**  * Factory method which derived classes can use to create an array of  * {@link RouteBuilder}s to define the routes for testing  *  * @see #createRouteBuilder()  */ ;/**  * Factory method which derived classes can use to create an array of  * {@link RouteBuilder}s to define the routes for testing  *  * @see #createRouteBuilder()  */ protected RouteBuilder[] createRouteBuilders() throws Exception {     return new RouteBuilder[] { createRouteBuilder() }. }
true;protected;1;3;/**  * Resolves a mandatory endpoint for the given URI or an exception is thrown  *  * @param uri the Camel <a href="">URI</a> to use to create or resolve an endpoint  * @return the endpoint  */ ;/**  * Resolves a mandatory endpoint for the given URI or an exception is thrown  *  * @param uri the Camel <a href="">URI</a> to use to create or resolve an endpoint  * @return the endpoint  */ protected Endpoint resolveMandatoryEndpoint(String uri) {     return resolveMandatoryEndpoint(context, uri). }
true;protected;2;3;/**  * Resolves a mandatory endpoint for the given URI and expected type or an exception is thrown  *  * @param uri the Camel <a href="">URI</a> to use to create or resolve an endpoint  * @return the endpoint  */ ;/**  * Resolves a mandatory endpoint for the given URI and expected type or an exception is thrown  *  * @param uri the Camel <a href="">URI</a> to use to create or resolve an endpoint  * @return the endpoint  */ protected <T extends Endpoint> T resolveMandatoryEndpoint(String uri, Class<T> endpointType) {     return resolveMandatoryEndpoint(context, uri, endpointType). }
true;protected;1;3;/**  * Resolves the mandatory Mock endpoint using a URI of the form <code>mock:someName</code>  *  * @param uri the URI which typically starts with "mock:" and has some name  * @return the mandatory mock endpoint or an exception is thrown if it could not be resolved  */ ;/**  * Resolves the mandatory Mock endpoint using a URI of the form <code>mock:someName</code>  *  * @param uri the URI which typically starts with "mock:" and has some name  * @return the mandatory mock endpoint or an exception is thrown if it could not be resolved  */ protected MockEndpoint getMockEndpoint(String uri) {     return resolveMandatoryEndpoint(uri, MockEndpoint.class). }
false;public;1;5;;public void process(Exchange exchange) {     Message in = exchange.getIn().     in.setBody(body).     in.setHeader("testCase", getName()). }
true;protected;2;9;/**  * Sends a message to the given endpoint URI with the body value  *  * @param endpointUri the URI of the endpoint to send to  * @param body        the body for the message  */ ;/**  * Sends a message to the given endpoint URI with the body value  *  * @param endpointUri the URI of the endpoint to send to  * @param body        the body for the message  */ protected void sendBody(String endpointUri, final Object body) {     template.send(endpointUri, new Processor() {          public void process(Exchange exchange) {             Message in = exchange.getIn().             in.setBody(body).             in.setHeader("testCase", getName()).         }     }). }
false;public;1;8;;public void process(Exchange exchange) {     Message in = exchange.getIn().     in.setBody(body).     in.setHeader("testCase", getName()).     for (Map.Entry<String, Object> entry : headers.entrySet()) {         in.setHeader(entry.getKey(), entry.getValue()).     } }
true;protected;3;12;/**  * Sends a message to the given endpoint URI with the body value and specified headers  *  * @param endpointUri the URI of the endpoint to send to  * @param body        the body for the message  * @param headers     any headers to set on the message  */ ;/**  * Sends a message to the given endpoint URI with the body value and specified headers  *  * @param endpointUri the URI of the endpoint to send to  * @param body        the body for the message  * @param headers     any headers to set on the message  */ protected void sendBody(String endpointUri, final Object body, final Map<String, Object> headers) {     template.send(endpointUri, new Processor() {          public void process(Exchange exchange) {             Message in = exchange.getIn().             in.setBody(body).             in.setHeader("testCase", getName()).             for (Map.Entry<String, Object> entry : headers.entrySet()) {                 in.setHeader(entry.getKey(), entry.getValue()).             }         }     }). }
true;protected;2;5;/**  * Sends messages to the given endpoint for each of the specified bodies  *  * @param endpointUri the endpoint URI to send to  * @param bodies      the bodies to send, one per message  */ ;/**  * Sends messages to the given endpoint for each of the specified bodies  *  * @param endpointUri the endpoint URI to send to  * @param bodies      the bodies to send, one per message  */ protected void sendBodies(String endpointUri, Object... bodies) {     for (Object body : bodies) {         sendBody(endpointUri, body).     } }
true;protected;1;3;/**  * Creates an exchange with the given body  */ ;/**  * Creates an exchange with the given body  */ protected Exchange createExchangeWithBody(Object body) {     return createExchangeWithBody(context, body). }
true;protected;4;8;/**  * Asserts that the given language name and expression evaluates to the  * given value on a specific exchange  */ ;/**  * Asserts that the given language name and expression evaluates to the  * given value on a specific exchange  */ protected void assertExpression(Exchange exchange, String languageName, String expressionText, Object expectedValue) {     Language language = assertResolveLanguage(languageName).     Expression expression = language.createExpression(expressionText).     assertNotNull("No Expression could be created for text: " + expressionText + " language: " + language, expression).     assertExpression(expression, exchange, expectedValue). }
true;protected;4;8;/**  * Asserts that the given language name and predicate expression evaluates  * to the expected value on the message exchange  */ ;/**  * Asserts that the given language name and predicate expression evaluates  * to the expected value on the message exchange  */ protected void assertPredicate(String languageName, String expressionText, Exchange exchange, boolean expected) {     Language language = assertResolveLanguage(languageName).     Predicate predicate = language.createPredicate(expressionText).     assertNotNull("No Predicate could be created for text: " + expressionText + " language: " + language, predicate).     assertPredicate(predicate, exchange, expected). }
true;protected;1;5;/**  * Asserts that the language name can be resolved  */ ;/**  * Asserts that the language name can be resolved  */ protected Language assertResolveLanguage(String languageName) {     Language language = context.resolveLanguage(languageName).     assertNotNull("No language found for name: " + languageName, language).     return language. }
true;protected;0;3;/**  * Asserts that all the expectations of the Mock endpoints are valid  */ ;/**  * Asserts that all the expectations of the Mock endpoints are valid  */ protected void assertMockEndpointsSatisfied() throws InterruptedException {     MockEndpoint.assertIsSatisfied(context). }
true;protected;1;3;/**  * Sets the assert period on all the Mock endpoints  */ ;/**  * Sets the assert period on all the Mock endpoints  */ protected void setAssertPeriod(long period) {     MockEndpoint.setAssertPeriod(context, period). }
true;protected;0;3;/**  * Reset all Mock endpoints.  */ ;/**  * Reset all Mock endpoints.  */ protected void resetMocks() {     MockEndpoint.resetMocks(context). }
false;protected;1;3;;protected void assertValidContext(CamelContext context) {     assertNotNull("No context found!", context). }
false;protected;2;5;;protected <T extends Endpoint> T getMandatoryEndpoint(String uri, Class<T> type) {     T endpoint = context.getEndpoint(uri, type).     assertNotNull("No endpoint found for uri: " + uri, endpoint).     return endpoint. }
false;protected;1;5;;protected Endpoint getMandatoryEndpoint(String uri) {     Endpoint endpoint = context.getEndpoint(uri).     assertNotNull("No endpoint found for uri: " + uri, endpoint).     return endpoint. }
