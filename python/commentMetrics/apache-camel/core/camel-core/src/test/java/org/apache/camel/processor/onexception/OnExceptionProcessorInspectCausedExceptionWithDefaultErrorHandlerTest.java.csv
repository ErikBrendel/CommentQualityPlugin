commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;@Test public void testInspectExceptionByProcessor() throws Exception {     getMockEndpoint("mock:myerror").expectedMessageCount(1).     try {         template.sendBody("direct:start", "Hello World").         fail("Should throw exception").     } catch (Exception e) {     // ok     }     assertMockEndpointsSatisfied(). }
false;public;1;3;;public void process(Exchange exchange) throws Exception {     throw new MyFunctionalException("Sorry you cannot do this"). }
false;public;0;16;;@Override public void configure() throws Exception {     errorHandler(defaultErrorHandler().maximumRedeliveries(3)).     // START SNIPPET: e1     // here we register exception cause for MyFunctionException     // when this exception occur we want it to be processed by our processor     onException(MyFunctionalException.class).process(new MyFunctionFailureHandler()).     // END SNIPPET: e1     from("direct:start").process(new Processor() {          public void process(Exchange exchange) throws Exception {             throw new MyFunctionalException("Sorry you cannot do this").         }     }). }
false;protected;0;21;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             errorHandler(defaultErrorHandler().maximumRedeliveries(3)).             // START SNIPPET: e1             // here we register exception cause for MyFunctionException             // when this exception occur we want it to be processed by our processor             onException(MyFunctionalException.class).process(new MyFunctionFailureHandler()).             // END SNIPPET: e1             from("direct:start").process(new Processor() {                  public void process(Exchange exchange) throws Exception {                     throw new MyFunctionalException("Sorry you cannot do this").                 }             }).         }     }. }
false;public;1;12;;public void process(Exchange exchange) throws Exception {     // the caused by exception is stored in a property on the exchange     Throwable caused = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Throwable.class).     assertNotNull(caused).     // here you can do what you want, but Camel regard this exception as handled, and     // this processor as a failurehandler, so it wont do redeliveries. So this is the     // end of this route. But if we want to route it somewhere we can just get a     // producer template and send it.     // send it to our mock endpoint     exchange.getContext().createProducerTemplate().send("mock:myerror", exchange). }
