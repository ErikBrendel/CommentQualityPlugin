commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Test public void testValidMessage() throws Exception {     validEndpoint.expectedMessageCount(1).     invalidEndpoint.expectedMessageCount(0).     Object result = template.requestBodyAndHeader("direct:start", "<valid/>", "foo", "bar").     assertEquals("validResult", result).     assertMockEndpointsSatisfied(). }
false;public;0;17;;@Test public void testInvalidMessage() throws Exception {     validEndpoint.expectedMessageCount(0).     invalidEndpoint.expectedMessageCount(1).     try {         template.sendBodyAndHeader("direct:start", "<invalid/>", "foo", "notMatchedHeaderValue").     } catch (RuntimeCamelException e) {     // the expected empty catch block here is not intended for this class itself but the subclasses     // e.g. ValidationWithErrorInHandleAndFinallyBlockTest where noErrorHandler() is being installed.     // this's also why there's no fail("Should have thrown an exception") call here right after     // template.sendBodyAndHeader() call as RuntimeCamelException will be not thrown by *all* subclasses     // but only by some of them.     }     assertMockEndpointsSatisfied(). }
false;public;0;19;;@Test public void testinvalidThenValidMessage() throws Exception {     validEndpoint.expectedMessageCount(2).     invalidEndpoint.expectedMessageCount(1).     try {         template.sendBodyAndHeader("direct:start", "<invalid/>", "foo", "notMatchedHeaderValue").     } catch (RuntimeCamelException e) {     // the same as above     }     Object result = template.requestBodyAndHeader("direct:start", "<valid/>", "foo", "bar").     assertEquals("validResult", result).     result = template.requestBodyAndHeader("direct:start", "<valid/>", "foo", "bar").     assertEquals("validResult", result).     assertMockEndpointsSatisfied(). }
false;public;0;11;;@Override @Before public void setUp() throws Exception {     super.setUp().     validEndpoint = resolveMandatoryEndpoint("mock:valid", MockEndpoint.class).     invalidEndpoint = resolveMandatoryEndpoint("mock:invalid", MockEndpoint.class).     validEndpoint.whenAnyExchangeReceived(e -> e.getMessage().setBody("validResult")).     invalidEndpoint.whenAnyExchangeReceived(e -> e.getMessage().setBody("invalidResult")). }
false;public;0;7;;public void configure() {     from("direct:start").doTry().process(validator).to("mock:valid").doCatch(ValidationException.class).to("mock:invalid"). }
false;protected;0;11;;protected RouteBuilder createRouteBuilder() {     return new RouteBuilder() {          public void configure() {             from("direct:start").doTry().process(validator).to("mock:valid").doCatch(ValidationException.class).to("mock:invalid").         }     }. }
