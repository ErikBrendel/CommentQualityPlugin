commented;modifiers;parameterAmount;loc;comment;code
false;public;0;17;;@Test public void testInOnly() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedBodiesReceived(3).     Exchange exchange = context.getEndpoint("direct:a").createExchange(ExchangePattern.InOnly).     exchange.getIn().setBody(1).     Exchange out = template.send("direct:a", exchange).     assertNotNull(out).     assertEquals(ExchangePattern.InOnly, out.getPattern()).     assertMockEndpointsSatisfied().     // should keep MEP as InOnly     assertEquals(ExchangePattern.InOnly, mock.getExchanges().get(0).getPattern()). }
false;public;0;17;;@Test public void testInOut() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedBodiesReceived(3).     Exchange exchange = context.getEndpoint("direct:a").createExchange(ExchangePattern.InOut).     exchange.getIn().setBody(1).     Exchange out = template.send("direct:a", exchange).     assertNotNull(out).     assertEquals(ExchangePattern.InOut, out.getPattern()).     assertMockEndpointsSatisfied().     // should keep MEP as InOut     assertEquals(ExchangePattern.InOut, mock.getExchanges().get(0).getPattern()). }
false;public;1;8;;public void process(Exchange exchange) {     Integer number = exchange.getIn().getBody(Integer.class).     if (number == null) {         number = 0.     }     number = number + 1.     exchange.getIn().setBody(number). }
false;public;1;13;;public void process(Exchange exchange) {     Integer number = exchange.getIn().getBody(Integer.class).     if (number == null) {         number = 0.     }     number = number + 1.     // this is a bit evil we let you set on OUT body even if the MEP is InOnly     // however the result after the routing is correct using APIs to get the result     // however the exchange will carry body IN and OUT when the route completes, as     // we operate on the original exchange in this processor     // (= we are the first node in the route after the from consumer)     exchange.getOut().setBody(number). }
false;public;0;8;;public void configure() {     from("direct:a").process(outProcessor).pipeline("log:x", "log:y").process(inProcessor).to("mock:result"). }
false;protected;0;39;;protected RouteBuilder createRouteBuilder() {     final Processor inProcessor = new Processor() {          public void process(Exchange exchange) {             Integer number = exchange.getIn().getBody(Integer.class).             if (number == null) {                 number = 0.             }             number = number + 1.             exchange.getIn().setBody(number).         }     }.     final Processor outProcessor = new Processor() {          public void process(Exchange exchange) {             Integer number = exchange.getIn().getBody(Integer.class).             if (number == null) {                 number = 0.             }             number = number + 1.             // this is a bit evil we let you set on OUT body even if the MEP is InOnly             // however the result after the routing is correct using APIs to get the result             // however the exchange will carry body IN and OUT when the route completes, as             // we operate on the original exchange in this processor             // (= we are the first node in the route after the from consumer)             exchange.getOut().setBody(number).         }     }.     return new RouteBuilder() {          public void configure() {             from("direct:a").process(outProcessor).pipeline("log:x", "log:y").process(inProcessor).to("mock:result").         }     }. }
