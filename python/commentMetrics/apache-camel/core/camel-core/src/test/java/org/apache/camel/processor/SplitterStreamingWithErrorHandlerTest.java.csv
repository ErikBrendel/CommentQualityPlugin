commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;@Override public void remove() { }
false;public;0;4;;@Override public boolean hasNext() {     return true. }
false;public;0;4;;@Override public String next() {     throw new RuntimeException("Uhoh."). }
false;public;0;30;;@Test public void testSplitterStreamingWithError() throws Exception {     getMockEndpoint("mock:b").expectedMessageCount(0).     getMockEndpoint("mock:error").expectedMessageCount(1).     // we do not stop on exception and thus the splitted message which     // failed     // would be silently ignored so we can continue routing     // you can always use a custom aggregation strategy to deal with errors     // your-self     template.sendBody("direct:start", new Iterator<String>() {          @Override         public void remove() {         }          @Override         public boolean hasNext() {             return true.         }          @Override         public String next() {             throw new RuntimeException("Uhoh.").         }     }).     assertMockEndpointsSatisfied(). }
false;public;0;5;;@Override public void configure() throws Exception {     errorHandler(deadLetterChannel("mock:error")).     from("direct:start").split(body()).streaming().to("mock:b").end(). }
false;protected;0;10;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             errorHandler(deadLetterChannel("mock:error")).             from("direct:start").split(body()).streaming().to("mock:b").end().         }     }. }
