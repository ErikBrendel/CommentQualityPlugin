commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;protected boolean canTest() {     // skip test on windows as it does not run well there     return !isPlatform("windows"). }
false;protected;0;6;;@Override protected JndiRegistry createRegistry() throws Exception {     JndiRegistry jndi = super.createRegistry().     jndi.bind("myBean", this).     return jndi. }
false;public;0;3;;public long getMessagesPerInterval() {     return 3. }
false;public;0;3;;public void run() {     template.sendBody("direct:expressionMethod", "<message>payload</message>"). }
false;public;0;28;;@Test public void testConfigurationWithMethodCallExpression() throws Exception {     if (!canTest()) {         return.     }     MockEndpoint resultEndpoint = resolveMandatoryEndpoint("mock:result", MockEndpoint.class).     resultEndpoint.expectedMessageCount(messageCount).     ExecutorService executor = Executors.newFixedThreadPool(messageCount).     StopWatch watch = new StopWatch().     for (int i = 0. i < messageCount. i++) {         executor.execute(new Runnable() {              public void run() {                 template.sendBody("direct:expressionMethod", "<message>payload</message>").             }         }).     }     // let's wait for the exchanges to arrive     resultEndpoint.assertIsSatisfied().     // should take a little time     assertTrue(watch.taken() > 100).     executor.shutdownNow(). }
false;public;0;5;;public void configure() {     from("direct:expressionMethod").throttle(method("myBean", "getMessagesPerInterval")).timePeriodMillis(INTERVAL).to("log:result", "mock:result"). }
false;protected;0;9;;protected RouteBuilder createRouteBuilder() {     return new RouteBuilder() {          public void configure() {             from("direct:expressionMethod").throttle(method("myBean", "getMessagesPerInterval")).timePeriodMillis(INTERVAL).to("log:result", "mock:result").         }     }. }
