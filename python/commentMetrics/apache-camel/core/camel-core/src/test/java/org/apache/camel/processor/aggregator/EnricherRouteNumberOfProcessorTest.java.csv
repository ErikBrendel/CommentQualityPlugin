commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isUseRouteBuilder() {     return false. }
false;public;2;9;;public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {     if (oldExchange == null) {         return newExchange.     }     // should always be in     String body = newExchange.getIn().getBody(String.class).     assertNotNull(body).     return newExchange. }
false;public;1;5;;public void process(Exchange exchange) throws Exception {     assertFalse("Should not have out", failed).     String s = exchange.getIn().getBody(String.class).     exchange.getIn().setBody("Hi " + s). }
false;public;0;27;;@Override public void configure() throws Exception {     from("direct:start").enrich("direct:enrich", new AggregationStrategy() {          public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {             if (oldExchange == null) {                 return newExchange.             }             // should always be in             String body = newExchange.getIn().getBody(String.class).             assertNotNull(body).             return newExchange.         }     }).to("mock:foo").end().to("mock:result").     from("direct:enrich").process(new Processor() {          public void process(Exchange exchange) throws Exception {             assertFalse("Should not have out", failed).             String s = exchange.getIn().getBody(String.class).             exchange.getIn().setBody("Hi " + s).         }     }). }
false;public;0;45;;@Test public void testOneProcesssor() throws Exception {     failed = false.     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             from("direct:start").enrich("direct:enrich", new AggregationStrategy() {                  public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {                     if (oldExchange == null) {                         return newExchange.                     }                     // should always be in                     String body = newExchange.getIn().getBody(String.class).                     assertNotNull(body).                     return newExchange.                 }             }).to("mock:foo").end().to("mock:result").             from("direct:enrich").process(new Processor() {                  public void process(Exchange exchange) throws Exception {                     assertFalse("Should not have out", failed).                     String s = exchange.getIn().getBody(String.class).                     exchange.getIn().setBody("Hi " + s).                 }             }).         }     }).     context.start().     MockEndpoint result = getMockEndpoint("mock:result").     result.expectedMessageCount(1).     getMockEndpoint("mock:foo").expectedBodiesReceived("Hi Claus").     getMockEndpoint("mock:foo").expectedHeaderReceived("id", 1).     template.requestBodyAndHeader("direct:start", "Claus", "id", 1).     assertMockEndpointsSatisfied(). }
false;public;2;9;;public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {     if (oldExchange == null) {         return newExchange.     }     // should always be in     String body = newExchange.getIn().getBody(String.class).     assertNotNull(body).     return newExchange. }
false;public;1;5;;public void process(Exchange exchange) throws Exception {     assertFalse("Should not have out", failed).     String s = exchange.getIn().getBody(String.class).     exchange.getIn().setBody("Hi " + s). }
false;public;0;29;;@Override public void configure() throws Exception {     from("direct:start").enrich("direct:enrich", new AggregationStrategy() {          public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {             if (oldExchange == null) {                 return newExchange.             }             // should always be in             String body = newExchange.getIn().getBody(String.class).             assertNotNull(body).             return newExchange.         }     }).to("mock:foo").end().to("mock:result").     from("direct:enrich").pipeline("log:a", "log:b").to("log:foo").process(new Processor() {          public void process(Exchange exchange) throws Exception {             assertFalse("Should not have out", failed).             String s = exchange.getIn().getBody(String.class).             exchange.getIn().setBody("Hi " + s).         }     }). }
false;public;0;47;;@Test public void testThreeProcesssors() throws Exception {     failed = false.     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             from("direct:start").enrich("direct:enrich", new AggregationStrategy() {                  public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {                     if (oldExchange == null) {                         return newExchange.                     }                     // should always be in                     String body = newExchange.getIn().getBody(String.class).                     assertNotNull(body).                     return newExchange.                 }             }).to("mock:foo").end().to("mock:result").             from("direct:enrich").pipeline("log:a", "log:b").to("log:foo").process(new Processor() {                  public void process(Exchange exchange) throws Exception {                     assertFalse("Should not have out", failed).                     String s = exchange.getIn().getBody(String.class).                     exchange.getIn().setBody("Hi " + s).                 }             }).         }     }).     context.start().     MockEndpoint result = getMockEndpoint("mock:result").     result.expectedMessageCount(1).     getMockEndpoint("mock:foo").expectedBodiesReceived("Hi Claus").     getMockEndpoint("mock:foo").expectedHeaderReceived("id", 1).     template.requestBodyAndHeader("direct:start", "Claus", "id", 1).     assertMockEndpointsSatisfied(). }
