commented;modifiers;parameterAmount;loc;comment;code
false;public;0;14;;@Before public void setup() {     files = Arrays.asList("file1.txt.20171123", "file2.txt.20171123", "file1.txt.20171124", "file3.txt.20171125", "file2.txt.20171126", "fixed.income.lamr.out.20171126", "pricing.px.20171126", "test.out.20171126", "processing.source.lamr.out.20171126").     this.fileIdempotentRepository = new FileIdempotentRepository(). }
false;public;0;32;;@Test public void testTrunkStoreNotMaxHit() throws Exception {     // ensure empty folder     deleteDirectory("target/data/mystore").     createDirectory("target/data/mystore").     // given     File fileStore = new File("target/data/mystore/data.dat").     fileIdempotentRepository.setFileStore(fileStore).     fileIdempotentRepository.setCacheSize(10).     fileIdempotentRepository.start().     files.forEach(e -> fileIdempotentRepository.add(e)).     // when (will rebalance)     fileIdempotentRepository.stop().     // then     Stream<String> fileContent = Files.lines(fileStore.toPath()).     List<String> fileEntries = fileContent.collect(Collectors.toList()).     fileContent.close().     // expected order     Assert.assertThat(fileEntries, IsIterableContainingInOrder.contains("file1.txt.20171123", "file2.txt.20171123", "file1.txt.20171124", "file3.txt.20171125", "file2.txt.20171126", "fixed.income.lamr.out.20171126", "pricing.px.20171126", "test.out.20171126", "processing.source.lamr.out.20171126")). }
false;public;0;32;;@Test public void testTrunkStoreFirstLevelMaxHit() throws Exception {     // ensure empty folder     deleteDirectory("target/data/mystore").     createDirectory("target/data/mystore").     // given     File fileStore = new File("target/data/mystore/data.dat").     fileIdempotentRepository.setFileStore(fileStore).     fileIdempotentRepository.setCacheSize(5).     fileIdempotentRepository.start().     files.forEach(e -> fileIdempotentRepository.add(e)).     // when (will rebalance)     fileIdempotentRepository.stop().     // then     Stream<String> fileContent = Files.lines(fileStore.toPath()).     List<String> fileEntries = fileContent.collect(Collectors.toList()).     fileContent.close().     // expected order     Assert.assertThat(fileEntries, IsIterableContainingInOrder.contains("file1.txt.20171123", "file2.txt.20171123", "file1.txt.20171124", "file3.txt.20171125", "file2.txt.20171126", "fixed.income.lamr.out.20171126", "pricing.px.20171126", "test.out.20171126", "processing.source.lamr.out.20171126")). }
false;public;0;30;;@Test public void testTrunkStoreFileMaxHit() throws Exception {     // ensure empty folder     deleteDirectory("target/data/mystore").     createDirectory("target/data/mystore").     // given     File fileStore = new File("target/data/mystore/data.dat").     fileIdempotentRepository.setFileStore(fileStore).     fileIdempotentRepository.setCacheSize(5).     fileIdempotentRepository.setMaxFileStoreSize(128).     fileIdempotentRepository.setDropOldestFileStore(1000).     fileIdempotentRepository.start().     files.forEach(e -> fileIdempotentRepository.add(e)).     // force cleanup and trunk     fileIdempotentRepository.cleanup().     fileIdempotentRepository.trunkStore().     fileIdempotentRepository.stop().     // then     Stream<String> fileContent = Files.lines(fileStore.toPath()).     List<String> fileEntries = fileContent.collect(Collectors.toList()).     fileContent.close().     // all old entries is removed     Assert.assertEquals(0, fileEntries.size()). }
