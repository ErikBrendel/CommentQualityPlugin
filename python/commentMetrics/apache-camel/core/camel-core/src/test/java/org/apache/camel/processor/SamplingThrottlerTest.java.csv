commented;modifiers;parameterAmount;loc;comment;code
false;public;0;16;;@Test public void testSamplingFromExchangeStream() throws Exception {     NotifyBuilder notify = new NotifyBuilder(context).whenDone(15).create().     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMinimumMessageCount(2).     mock.setResultWaitTime(3000).     List<Exchange> sentExchanges = new ArrayList<>().     sendExchangesThroughDroppingThrottler(sentExchanges, 15).     notify.matchesMockWaitTime().     mock.assertIsSatisfied().     validateDroppedExchanges(sentExchanges, mock.getReceivedCounter()). }
false;public;0;22;;@Test public void testBurstySampling() throws Exception {     NotifyBuilder notify = new NotifyBuilder(context).whenDone(5).create().     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMinimumMessageCount(2).     mock.setResultWaitTime(3000).     List<Exchange> sentExchanges = new ArrayList<>().     // send a burst of 5 exchanges, expecting only one to get through     sendExchangesThroughDroppingThrottler(sentExchanges, 5).     // sleep through a complete period     Thread.sleep(1100).     // send another 5 now     sendExchangesThroughDroppingThrottler(sentExchanges, 5).     notify.matchesMockWaitTime().     mock.assertIsSatisfied().     validateDroppedExchanges(sentExchanges, mock.getReceivedCounter()). }
false;public;0;7;;public void run() {     try {         sendExchangesThroughDroppingThrottler(sentExchanges, 35).     } catch (Exception e) {     // ignore     } }
false;public;0;23;;@Test public void testSendLotsOfMessagesSimultaneouslyButOnly3GetThrough() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMinimumMessageCount(3).     mock.setResultWaitTime(4000).     final List<Exchange> sentExchanges = Collections.synchronizedList(new ArrayList<Exchange>()).     ExecutorService executor = Executors.newFixedThreadPool(5).     for (int i = 0. i < 5. i++) {         executor.execute(new Runnable() {              public void run() {                 try {                     sendExchangesThroughDroppingThrottler(sentExchanges, 35).                 } catch (Exception e) {                 // ignore                 }             }         }).     }     mock.assertIsSatisfied().     executor.shutdownNow(). }
false;public;0;13;;@Test public void testSamplingUsingMessageFrequency() throws Exception {     long totalMessages = 100.     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMinimumMessageCount(10).     mock.setResultWaitTime(100).     for (int i = 0. i < totalMessages. i++) {         template.sendBody("direct:sample-messageFrequency", "<message>" + i + "</message>").     }     mock.assertIsSatisfied(). }
false;public;0;13;;@Test public void testSamplingUsingMessageFrequencyViaDSL() throws Exception {     long totalMessages = 50.     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMinimumMessageCount(10).     mock.setResultWaitTime(100).     for (int i = 0. i < totalMessages. i++) {         template.sendBody("direct:sample-messageFrequency-via-dsl", "<message>" + i + "</message>").     }     mock.assertIsSatisfied(). }
false;private;2;16;;private void sendExchangesThroughDroppingThrottler(List<Exchange> sentExchanges, int messages) throws Exception {     ProducerTemplate myTemplate = context.createProducerTemplate().     DirectEndpoint targetEndpoint = resolveMandatoryEndpoint("direct:sample", DirectEndpoint.class).     for (int i = 0. i < messages. i++) {         Exchange e = targetEndpoint.createExchange().         e.getIn().setBody("<message>" + i + "</message>").         // only send if we are still started         if (context.getStatus().isStarted()) {             myTemplate.send(targetEndpoint, e).             sentExchanges.add(e).             Thread.sleep(100).         }     }     myTemplate.stop(). }
false;private;2;10;;private void validateDroppedExchanges(List<Exchange> sentExchanges, int expectedNotDroppedCount) {     int notDropped = 0.     for (Exchange e : sentExchanges) {         Boolean stopped = e.getProperty(Exchange.ROUTE_STOP, Boolean.class).         if (stopped == null) {             notDropped++.         }     }     assertEquals(expectedNotDroppedCount, notDropped). }
false;public;0;24;;public void configure() {     // START SNIPPET: e1     from("direct:sample").sample().to("mock:result").     from("direct:sample-configured").sample(1, TimeUnit.SECONDS).to("mock:result").     from("direct:sample-configured-via-dsl").sample().samplePeriod(1).timeUnits(TimeUnit.SECONDS).to("mock:result").     from("direct:sample-messageFrequency").sample(10).to("mock:result").     from("direct:sample-messageFrequency-via-dsl").sample().sampleMessageFrequency(5).to("mock:result"). // END SNIPPET: e1 }
false;protected;0;28;;protected RouteBuilder createRouteBuilder() {     return new RouteBuilder() {          public void configure() {             // START SNIPPET: e1             from("direct:sample").sample().to("mock:result").             from("direct:sample-configured").sample(1, TimeUnit.SECONDS).to("mock:result").             from("direct:sample-configured-via-dsl").sample().samplePeriod(1).timeUnits(TimeUnit.SECONDS).to("mock:result").             from("direct:sample-messageFrequency").sample(10).to("mock:result").             from("direct:sample-messageFrequency-via-dsl").sample().sampleMessageFrequency(5).to("mock:result").         // END SNIPPET: e1         }     }. }
