commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;6;;@Override protected JndiRegistry createRegistry() throws Exception {     JndiRegistry jndi = super.createRegistry().     jndi.bind("foo", new MyPolicy("foo")).     return jndi. }
false;public;0;21;;@Test public void testAsyncEndpoint() throws Exception {     getMockEndpoint("mock:foo").expectedMessageCount(1).     getMockEndpoint("mock:foo").expectedHeaderReceived("foo", "was wrapped").     getMockEndpoint("mock:bar").expectedMessageCount(1).     getMockEndpoint("mock:bar").expectedHeaderReceived("foo", "was wrapped").     getMockEndpoint("mock:result").expectedMessageCount(1).     getMockEndpoint("mock:result").expectedHeaderReceived("foo", "was wrapped").     getMockEndpoint("mock:response").expectedMessageCount(1).     getMockEndpoint("mock:response").expectedHeaderReceived("foo", "policy finished execution").     template.sendBody("direct:send", "Hello World").     assertMockEndpointsSatisfied().     MyPolicy foo = context.getRegistry().lookupByNameAndType("foo", MyPolicy.class).     assertEquals("Should only be invoked 1 time", 1, foo.getInvoked()).     assertFalse("Should use different threads", beforeThreadName.equalsIgnoreCase(afterThreadName)). }
false;public;1;3;;public void process(Exchange exchange) throws Exception {     afterThreadName = Thread.currentThread().getName(). }
false;public;1;3;;public void process(Exchange exchange) throws Exception {     beforeThreadName = Thread.currentThread().getName(). }
false;public;0;30;;@Override public void configure() throws Exception {     context.addComponent("async", new MyAsyncComponent()).     from("direct:start").policy("foo").to("mock:foo").to("async:bye:camel").to("mock:bar").to("mock:result").     from("direct:send").to("mock:before").to("log:before").process(new Processor() {          public void process(Exchange exchange) throws Exception {             beforeThreadName = Thread.currentThread().getName().         }     }).to("direct:start").process(new Processor() {          public void process(Exchange exchange) throws Exception {             afterThreadName = Thread.currentThread().getName().         }     }).to("log:after").to("mock:after").to("mock:response"). }
false;protected;0;35;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             context.addComponent("async", new MyAsyncComponent()).             from("direct:start").policy("foo").to("mock:foo").to("async:bye:camel").to("mock:bar").to("mock:result").             from("direct:send").to("mock:before").to("log:before").process(new Processor() {                  public void process(Exchange exchange) throws Exception {                     beforeThreadName = Thread.currentThread().getName().                 }             }).to("direct:start").process(new Processor() {                  public void process(Exchange exchange) throws Exception {                     afterThreadName = Thread.currentThread().getName().                 }             }).to("log:after").to("mock:after").to("mock:response").         }     }. }
false;public;2;4;;public void beforeWrap(RouteContext routeContext, NamedNode definition) { // no need to modify the route }
false;public;2;11;;public boolean process(final Exchange exchange, final AsyncCallback callback) {     invoked++.     // let the original processor continue routing     exchange.getIn().setHeader(name, "was wrapped").     AsyncProcessor ap = AsyncProcessorConverterHelper.convert(processor).     ap.process(exchange, doneSync -> {         exchange.getIn().setHeader(name, "policy finished execution").         callback.done(false).     }).     return false. }
false;public;1;4;;public void process(Exchange exchange) throws Exception {     final AsyncProcessorAwaitManager awaitManager = exchange.getContext().getAsyncProcessorAwaitManager().     awaitManager.process(this, exchange). }
false;public;1;5;;public CompletableFuture<Exchange> processAsync(Exchange exchange) {     AsyncCallbackToCompletableFutureAdapter<Exchange> callback = new AsyncCallbackToCompletableFutureAdapter<>(exchange).     process(exchange, callback).     return callback.getFuture(). }
false;public;2;26;;public Processor wrap(RouteContext routeContext, final Processor processor) {     return new AsyncProcessor() {          public boolean process(final Exchange exchange, final AsyncCallback callback) {             invoked++.             // let the original processor continue routing             exchange.getIn().setHeader(name, "was wrapped").             AsyncProcessor ap = AsyncProcessorConverterHelper.convert(processor).             ap.process(exchange, doneSync -> {                 exchange.getIn().setHeader(name, "policy finished execution").                 callback.done(false).             }).             return false.         }          public void process(Exchange exchange) throws Exception {             final AsyncProcessorAwaitManager awaitManager = exchange.getContext().getAsyncProcessorAwaitManager().             awaitManager.process(this, exchange).         }          public CompletableFuture<Exchange> processAsync(Exchange exchange) {             AsyncCallbackToCompletableFutureAdapter<Exchange> callback = new AsyncCallbackToCompletableFutureAdapter<>(exchange).             process(exchange, callback).             return callback.getFuture().         }     }. }
false;public;0;3;;public int getInvoked() {     return invoked. }
