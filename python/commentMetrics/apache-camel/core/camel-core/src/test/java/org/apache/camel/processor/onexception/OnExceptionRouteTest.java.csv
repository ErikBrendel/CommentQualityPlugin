commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@Test public void testNoError() throws Exception {     getMockEndpoint("mock:error").expectedMessageCount(0).     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMessageCount(1).     template.sendBody("direct:start", "<order><type>myType</type><user>James</user></order>").     assertMockEndpointsSatisfied(). }
false;public;0;12;;@Test public void testFunctionalError() throws Exception {     getMockEndpoint("mock:error").expectedMessageCount(0).     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMessageCount(0).     template.sendBody("direct:start", "<order><type>myType</type><user>Func</user></order>").     assertMockEndpointsSatisfied().     assertEquals("<order><type>myType</type><user>Func</user></order>", myOwnHandlerBean.getPayload()). }
false;public;0;13;;@Test public void testTechnicalError() throws Exception {     getMockEndpoint("mock:error").expectedMessageCount(1).     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMessageCount(0).     template.sendBody("direct:start", "<order><type>myType</type><user>Tech</user></order>").     assertMockEndpointsSatisfied().     // should not handle it     assertNull(myOwnHandlerBean.getPayload()). }
false;public;0;23;;@Test public void testErrorWhileHandlingException() throws Exception {     // DLC does not handle the exception as we failed during processing in onException     MockEndpoint error = getMockEndpoint("mock:error").     error.expectedMessageCount(0).     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMessageCount(0).     try {         template.sendBody("direct:start", "<order><type>myType</type><user>FuncError</user></order>").         fail("Should have thrown an exception").     } catch (CamelExecutionException e) {         // the myOwnHandlerBean throw exception while handling an exception         IOException cause = assertIsInstanceOf(IOException.class, e.getCause()).         assertEquals("Damn something did not work", cause.getMessage()).     }     assertMockEndpointsSatisfied().     // should not handle it     assertNull(myOwnHandlerBean.getPayload()). }
false;public;0;7;;@Override @Before public void setUp() throws Exception {     myOwnHandlerBean = new MyOwnHandlerBean().     myServiceBean = new MyServiceBean().     super.setUp(). }
false;protected;0;7;;@Override protected JndiRegistry createRegistry() throws Exception {     JndiRegistry jndi = super.createRegistry().     jndi.bind("myOwnHandler", myOwnHandlerBean).     jndi.bind("myServiceBean", myServiceBean).     return jndi. }
false;public;0;25;;@Override public void configure() throws Exception {     // START SNIPPET: e1     // default should errors go to mock:error     errorHandler(deadLetterChannel("mock:error").redeliveryDelay(0)).     // if a MyTechnicalException is thrown we will not try to redeliver and we mark it as handled     // so the caller does not get a failure     // since we have no to then the exchange will continue to be routed to the normal error handler     // destination that is mock:error as defined above     onException(MyTechnicalException.class).maximumRedeliveries(0).handled(true).     // if a MyFunctionalException is thrown we do not want Camel to redelivery but handle it our self using     // our bean myOwnHandler, then the exchange is not routed to the default error (mock:error)     onException(MyFunctionalException.class).maximumRedeliveries(0).handled(true).to("bean:myOwnHandler").     // here we route message to our service bean     from("direct:start").choice().when().xpath("//type = 'myType'").to("bean:myServiceBean").end().to("mock:result"). // END SNIPPET: e1 }
false;protected;0;30;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             // START SNIPPET: e1             // default should errors go to mock:error             errorHandler(deadLetterChannel("mock:error").redeliveryDelay(0)).             // if a MyTechnicalException is thrown we will not try to redeliver and we mark it as handled             // so the caller does not get a failure             // since we have no to then the exchange will continue to be routed to the normal error handler             // destination that is mock:error as defined above             onException(MyTechnicalException.class).maximumRedeliveries(0).handled(true).             // if a MyFunctionalException is thrown we do not want Camel to redelivery but handle it our self using             // our bean myOwnHandler, then the exchange is not routed to the default error (mock:error)             onException(MyFunctionalException.class).maximumRedeliveries(0).handled(true).to("bean:myOwnHandler").             // here we route message to our service bean             from("direct:start").choice().when().xpath("//type = 'myType'").to("bean:myServiceBean").end().to("mock:result").         // END SNIPPET: e1         }     }. }
