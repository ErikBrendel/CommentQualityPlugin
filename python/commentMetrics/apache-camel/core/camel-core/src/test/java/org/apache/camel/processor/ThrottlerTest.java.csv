commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;protected boolean canTest() {     // skip test on windows as it does not run well there     return !isPlatform("windows"). }
false;public;0;18;;@Test public void testSendLotsOfMessagesButOnly3GetThroughWithin2Seconds() throws Exception {     if (!canTest()) {         return.     }     MockEndpoint resultEndpoint = resolveMandatoryEndpoint("mock:result", MockEndpoint.class).     resultEndpoint.expectedMessageCount(3).     resultEndpoint.setResultWaitTime(2000).     for (int i = 0. i < MESSAGE_COUNT. i++) {         template.sendBody("seda:a", "<message>" + i + "</message>").     }     // lets pause to give the requests time to be processed     // to check that the throttle really does kick in     resultEndpoint.assertIsSatisfied(). }
false;public;0;20;;@Test public void testSendLotsOfMessagesWithRejectExecution() throws Exception {     if (!canTest()) {         return.     }     MockEndpoint resultEndpoint = resolveMandatoryEndpoint("mock:result", MockEndpoint.class).     resultEndpoint.expectedMessageCount(2).     MockEndpoint errorEndpoint = resolveMandatoryEndpoint("mock:error", MockEndpoint.class).     errorEndpoint.expectedMessageCount(4).     for (int i = 0. i < 6. i++) {         template.sendBody("direct:start", "<message>" + i + "</message>").     }     // lets pause to give the requests time to be processed     // to check that the throttle really does kick in     assertMockEndpointsSatisfied(). }
false;public;0;10;;@Test public void testSendLotsOfMessagesSimultaneouslyButOnly3GetThrough() throws Exception {     if (!canTest()) {         return.     }     MockEndpoint resultEndpoint = resolveMandatoryEndpoint("mock:result", MockEndpoint.class).     long elapsed = sendMessagesAndAwaitDelivery(MESSAGE_COUNT, "direct:a", MESSAGE_COUNT, resultEndpoint).     assertThrottlerTiming(elapsed, 5, INTERVAL, MESSAGE_COUNT). }
false;public;0;10;;@Test public void testConfigurationWithConstantExpression() throws Exception {     if (!canTest()) {         return.     }     MockEndpoint resultEndpoint = resolveMandatoryEndpoint("mock:result", MockEndpoint.class).     long elapsed = sendMessagesAndAwaitDelivery(MESSAGE_COUNT, "direct:expressionConstant", MESSAGE_COUNT, resultEndpoint).     assertThrottlerTiming(elapsed, 5, INTERVAL, MESSAGE_COUNT). }
false;public;0;16;;@Test public void testConfigurationWithHeaderExpression() throws Exception {     if (!canTest()) {         return.     }     MockEndpoint resultEndpoint = resolveMandatoryEndpoint("mock:result", MockEndpoint.class).     resultEndpoint.expectedMessageCount(MESSAGE_COUNT).     ExecutorService executor = Executors.newFixedThreadPool(MESSAGE_COUNT).     try {         sendMessagesWithHeaderExpression(executor, resultEndpoint, 5, INTERVAL, MESSAGE_COUNT).     } finally {         executor.shutdownNow().     } }
false;public;0;26;;@Test public void testConfigurationWithChangingHeaderExpression() throws Exception {     if (!canTest()) {         return.     }     ExecutorService executor = Executors.newFixedThreadPool(5).     try {         MockEndpoint resultEndpoint = resolveMandatoryEndpoint("mock:result", MockEndpoint.class).         sendMessagesWithHeaderExpression(executor, resultEndpoint, 5, INTERVAL, MESSAGE_COUNT).         // sleep here to ensure the first throttle rate does not influence the next one.         Thread.sleep(INTERVAL + TOLERANCE).         resultEndpoint.reset().         sendMessagesWithHeaderExpression(executor, resultEndpoint, 10, INTERVAL, MESSAGE_COUNT).         // sleep here to ensure the first throttle rate does not influence the next one.         Thread.sleep(INTERVAL + TOLERANCE).         resultEndpoint.reset().         sendMessagesWithHeaderExpression(executor, resultEndpoint, 5, INTERVAL, MESSAGE_COUNT).         // sleep here to ensure the first throttle rate does not influence the next one.         Thread.sleep(INTERVAL + TOLERANCE).         resultEndpoint.reset().         sendMessagesWithHeaderExpression(executor, resultEndpoint, 10, INTERVAL, MESSAGE_COUNT).     } finally {         executor.shutdownNow().     } }
false;private;4;11;;private void assertThrottlerTiming(final long elapsedTimeMs, final int throttle, final int intervalMs, final int messageCount) {     // now assert that they have actually been throttled (use +/- 50 as slack)     long minimum = calculateMinimum(intervalMs, throttle, messageCount) - 50.     long maximum = calculateMaximum(intervalMs, throttle, messageCount) + 50.     // add 500 in case running on slow CI boxes     maximum += 500.     log.info("Sent {} exchanges in {}ms, with throttle rate of {} per {}ms. Calculated min {}ms and max {}ms", messageCount, elapsedTimeMs, throttle, intervalMs, minimum, maximum).     assertTrue("Should take at least " + minimum + "ms, was: " + elapsedTimeMs, elapsedTimeMs >= minimum).     assertTrue("Should take at most " + maximum + "ms, was: " + elapsedTimeMs, elapsedTimeMs <= maximum + TOLERANCE). }
false;public;0;3;;public void run() {     template.sendBody(endpointUri, "<message>payload</message>"). }
false;private;4;25;;private long sendMessagesAndAwaitDelivery(final int messageCount, final String endpointUri, final int threadPoolSize, final MockEndpoint receivingEndpoint) throws InterruptedException {     ExecutorService executor = Executors.newFixedThreadPool(threadPoolSize).     try {         if (receivingEndpoint != null) {             receivingEndpoint.expectedMessageCount(messageCount).         }         long start = System.nanoTime().         for (int i = 0. i < messageCount. i++) {             executor.execute(new Runnable() {                  public void run() {                     template.sendBody(endpointUri, "<message>payload</message>").                 }             }).         }         // let's wait for the exchanges to arrive         if (receivingEndpoint != null) {             receivingEndpoint.assertIsSatisfied().         }         return TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start).     } finally {         executor.shutdownNow().     } }
false;public;0;3;;public void run() {     template.sendBodyAndHeader("direct:expressionHeader", "<message>payload</message>", "throttleValue", throttle). }
false;private;5;18;;private void sendMessagesWithHeaderExpression(final ExecutorService executor, final MockEndpoint resultEndpoint, final int throttle, final int intervalMs, final int messageCount) throws InterruptedException {     resultEndpoint.expectedMessageCount(messageCount).     long start = System.nanoTime().     for (int i = 0. i < messageCount. i++) {         executor.execute(new Runnable() {              public void run() {                 template.sendBodyAndHeader("direct:expressionHeader", "<message>payload</message>", "throttleValue", throttle).             }         }).     }     // let's wait for the exchanges to arrive     resultEndpoint.assertIsSatisfied().     long elapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start).     assertThrottlerTiming(elapsed, throttle, intervalMs, messageCount). }
false;private;3;7;;private long calculateMinimum(final long periodMs, final long throttleRate, final long messageCount) {     if (messageCount % throttleRate > 0) {         return (long) Math.floor((double) messageCount / (double) throttleRate) * periodMs.     } else {         return (long) (Math.floor((double) messageCount / (double) throttleRate) * periodMs) - periodMs.     } }
false;private;3;3;;private long calculateMaximum(final long periodMs, final long throttleRate, final long messageCount) {     return ((long) Math.ceil((double) messageCount / (double) throttleRate)) * periodMs. }
false;public;0;20;;public void configure() {     onException(ThrottlerRejectedExecutionException.class).handled(true).to("mock:error").     // START SNIPPET: ex     from("seda:a").throttle(3).timePeriodMillis(1000).to("log:result", "mock:result").     // END SNIPPET: ex     from("direct:a").throttle(5).timePeriodMillis(INTERVAL).to("log:result", "mock:result").     from("direct:expressionConstant").throttle(constant(5)).timePeriodMillis(INTERVAL).to("log:result", "mock:result").     from("direct:expressionHeader").throttle(header("throttleValue")).timePeriodMillis(INTERVAL).to("log:result", "mock:result").     from("direct:start").throttle(2).timePeriodMillis(1000).rejectExecution(true).to("log:result", "mock:result").     from("direct:highThrottleRate").throttle(10000).timePeriodMillis(INTERVAL).to("mock:result"). }
false;protected;0;24;;protected RouteBuilder createRouteBuilder() {     return new RouteBuilder() {          public void configure() {             onException(ThrottlerRejectedExecutionException.class).handled(true).to("mock:error").             // START SNIPPET: ex             from("seda:a").throttle(3).timePeriodMillis(1000).to("log:result", "mock:result").             // END SNIPPET: ex             from("direct:a").throttle(5).timePeriodMillis(INTERVAL).to("log:result", "mock:result").             from("direct:expressionConstant").throttle(constant(5)).timePeriodMillis(INTERVAL).to("log:result", "mock:result").             from("direct:expressionHeader").throttle(header("throttleValue")).timePeriodMillis(INTERVAL).to("log:result", "mock:result").             from("direct:start").throttle(2).timePeriodMillis(1000).rejectExecution(true).to("log:result", "mock:result").             from("direct:highThrottleRate").throttle(10000).timePeriodMillis(INTERVAL).to("mock:result").         }     }. }
