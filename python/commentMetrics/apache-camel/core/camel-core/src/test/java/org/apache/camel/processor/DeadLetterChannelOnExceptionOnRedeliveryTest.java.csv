commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;@Test public void testGlobalOnRedelivery() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedBodiesReceived("Hello World3").     template.sendBody("direct:start", "Hello World").     assertMockEndpointsSatisfied(). }
false;public;0;10;;@Test public void testRouteSpecificOnRedelivery() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedBodiesReceived("Hello World").     mock.message(0).header("Timeout").isEqualTo(5000).     template.sendBody("direct:io", "Hello World").     assertMockEndpointsSatisfied(). }
false;public;0;6;;@Override @Before public void setUp() throws Exception {     super.setUp().     counter = 0. }
false;public;0;28;;@Override public void configure() throws Exception {     // START SNIPPET: e1     // when we redeliver caused by an IOException we want to do some special     // code before the redeliver attempt     onException(IOException.class).maximumRedeliveries(3).redeliveryDelay(0).onRedelivery(new MyIORedeliverProcessor()).     // END SNIPPET: e1     // START SNIPPET: e2     // we configure our Dead Letter Channel to invoke     // MyRedeliveryProcessor before a redelivery is     // attempted. This allows us to alter the message before     errorHandler(deadLetterChannel("mock:error").maximumRedeliveries(5).onRedelivery(new MyRedeliverProcessor()).redeliveryDelay(0L)).     // END SNIPPET: e2     from("direct:start").process(new ThrowExceptionProcessor()).to("mock:result").     from("direct:io").process(new ThrowIOExceptionProcessor()).to("mock:result"). }
false;protected;0;33;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             // START SNIPPET: e1             // when we redeliver caused by an IOException we want to do some special             // code before the redeliver attempt             onException(IOException.class).maximumRedeliveries(3).redeliveryDelay(0).onRedelivery(new MyIORedeliverProcessor()).             // END SNIPPET: e1             // START SNIPPET: e2             // we configure our Dead Letter Channel to invoke             // MyRedeliveryProcessor before a redelivery is             // attempted. This allows us to alter the message before             errorHandler(deadLetterChannel("mock:error").maximumRedeliveries(5).onRedelivery(new MyRedeliverProcessor()).redeliveryDelay(0L)).             // END SNIPPET: e2             from("direct:start").process(new ThrowExceptionProcessor()).to("mock:result").             from("direct:io").process(new ThrowIOExceptionProcessor()).to("mock:result").         }     }. }
false;public;1;10;;public void process(Exchange exchange) throws Exception {     // the message is being redelivered so we can alter it     // we just append the redelivery counter to the body     // you can of course do all kind of stuff instead     String body = exchange.getIn().getBody(String.class).     int count = exchange.getIn().getHeader("CamelRedeliveryCounter", Integer.class).     exchange.getIn().setBody(body + count). }
false;public;1;5;;public void process(Exchange exchange) throws Exception {     // just for show and tell, here we set a special header to instruct     // the receive a given timeout value     exchange.getIn().setHeader("Timeout", 5000). }
false;public;1;7;;public void process(Exchange exchange) throws Exception {     // force some error so Camel will do redelivery     if (++counter <= 3) {         throw new IllegalArgumentException("Forced by unit test").     } }
false;public;1;7;;public void process(Exchange exchange) throws Exception {     // force some error so Camel will do redelivery     if (++counter <= 3) {         throw new IOException("Cannot connect").     } }
