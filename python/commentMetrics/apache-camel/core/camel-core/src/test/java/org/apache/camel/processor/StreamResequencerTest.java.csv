commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;public void process(Exchange exchange) {     Message in = exchange.getIn().     in.setBody(body).     in.setHeader(headerName, headerValue).     in.setHeader("testCase", getName()). }
false;protected;4;10;;protected void sendBodyAndHeader(String endpointUri, final Object body, final String headerName, final Object headerValue) {     template.send(endpointUri, new Processor() {          public void process(Exchange exchange) {             Message in = exchange.getIn().             in.setBody(body).             in.setHeader(headerName, headerValue).             in.setHeader("testCase", getName()).         }     }). }
false;public;0;11;;@Test public void testSendMessagesInWrongOrderButReceiveThemInCorrectOrder() throws Exception {     getMockEndpoint("mock:result").expectedBodiesReceived("msg1", "msg2", "msg3", "msg4").     sendBodyAndHeader("direct:start", "msg4", "seqnum", 4L).     sendBodyAndHeader("direct:start", "msg1", "seqnum", 1L).     sendBodyAndHeader("direct:start", "msg3", "seqnum", 3L).     sendBodyAndHeader("direct:start", "msg2", "seqnum", 2L).     assertMockEndpointsSatisfied(). }
false;public;0;24;;@Test public void testMultithreaded() throws Exception {     int numMessages = 100.     Object[] bodies = new Object[numMessages].     for (int i = 0. i < numMessages. i++) {         bodies[i] = "msg" + i.     }     getMockEndpoint("mock:result").expectedBodiesReceived(bodies).     getMockEndpoint("mock:result").setResultWaitTime(20000).     ProducerTemplate producerTemplate = context.createProducerTemplate().     ProducerTemplate producerTemplate2 = context.createProducerTemplate().     ExecutorService service = context.getExecutorServiceManager().newFixedThreadPool(this, getName(), 2).     service.execute(new Sender(producerTemplate, 0, numMessages, 2)).     service.execute(new Sender(producerTemplate2, 1, numMessages, 2)).     assertMockEndpointsSatisfied().     ServiceHelper.stopService(producerTemplate, producerTemplate2). }
false;protected;0;7;;@Override protected boolean useJmx() {     boolean enable = "testStreamResequencerTypeWithJmx".equals(getName()).     log.info("Going to {} JMX for the test {}", enable ? "enable" : "disable", getName()).     return enable. }
false;public;0;5;;public void configure() {     // START SNIPPET: example     from("direct:start").resequence(header("seqnum")).stream().timeout(100).deliveryAttemptInterval(10).to("mock:result"). // END SNIPPET: example }
false;protected;0;9;;protected RouteBuilder createRouteBuilder() {     return new RouteBuilder() {          public void configure() {             // START SNIPPET: example             from("direct:start").resequence(header("seqnum")).stream().timeout(100).deliveryAttemptInterval(10).to("mock:result").         // END SNIPPET: example         }     }. }
false;public;0;4;;@Test public void testStreamResequencerTypeWithJmx() throws Exception {     doTestStreamResequencerType(). }
false;public;0;4;;@Test public void testStreamResequencerTypeWithoutJmx() throws Exception {     doTestStreamResequencerType(). }
false;protected;0;12;;protected void doTestStreamResequencerType() throws Exception {     List<Route> list = getRouteList(createRouteBuilder()).     assertEquals("Number of routes created: " + list, 1, list.size()).     Route route = list.get(0).     EventDrivenConsumerRoute consumerRoute = assertIsInstanceOf(EventDrivenConsumerRoute.class, route).     Channel channel = unwrapChannel(consumerRoute.getProcessor()).     assertIsInstanceOf(DefaultErrorHandler.class, channel.getErrorHandler()).     assertIsInstanceOf(StreamResequencer.class, channel.getNextProcessor()). }
false;public;0;13;;@Override public void run() {     for (long i = start. i < end. i += increment) {         try {             // let's sleep randomly             Thread.sleep(random.nextInt(20)).         } catch (InterruptedException e) {             Thread.currentThread().interrupt().         }         template.sendBodyAndHeader("direct:start", "msg" + i, "seqnum", i).     } }
