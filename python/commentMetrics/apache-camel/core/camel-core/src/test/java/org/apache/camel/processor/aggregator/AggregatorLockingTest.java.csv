commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Test public void testAggregationWithoutParallelNorOptimisticShouldNotLockDownstreamProcessors() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedBodiesReceivedInAnyOrder("a", "b").     template.sendBodyAndHeader("seda:a", "a", "myId", 1).     template.sendBodyAndHeader("seda:a", "b", "myId", 2).     assertMockEndpointsSatisfied(). }
false;public;1;8;;@Override public void process(Exchange exchange) throws Exception {     latch.countDown().     // block until the other thread counts down as well     if (!latch.await(5, TimeUnit.SECONDS)) {         throw new RuntimeException("Took too long. assume threads are blocked and fail test").     } }
false;public;0;25;;@Override public void configure() throws Exception {     from("seda:a?concurrentConsumers=2").aggregate(header("myId"), new UseLatestAggregationStrategy()).completionSize(1).log("Before await with thread: ${threadName} and body: ${body}").process(new Processor() {          @Override         public void process(Exchange exchange) throws Exception {             latch.countDown().             // block until the other thread counts down as well             if (!latch.await(5, TimeUnit.SECONDS)) {                 throw new RuntimeException("Took too long. assume threads are blocked and fail test").             }         }     }).log("After await with thread: ${threadName} and body: ${body}").to("mock:result"). }
false;protected;0;30;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             from("seda:a?concurrentConsumers=2").aggregate(header("myId"), new UseLatestAggregationStrategy()).completionSize(1).log("Before await with thread: ${threadName} and body: ${body}").process(new Processor() {                  @Override                 public void process(Exchange exchange) throws Exception {                     latch.countDown().                     // block until the other thread counts down as well                     if (!latch.await(5, TimeUnit.SECONDS)) {                         throw new RuntimeException("Took too long. assume threads are blocked and fail test").                     }                 }             }).log("After await with thread: ${threadName} and body: ${body}").to("mock:result").         }     }. }
