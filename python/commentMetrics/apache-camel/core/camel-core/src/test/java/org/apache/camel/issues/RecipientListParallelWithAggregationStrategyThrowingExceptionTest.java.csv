commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@Test public void testAggregationTimeExceptionWithParallelProcessing() throws Exception {     getMockEndpoint("mock:a").expectedMessageCount(1).     getMockEndpoint("mock:b").expectedMessageCount(1).     getMockEndpoint("mock:end").expectedMessageCount(0).     getMockEndpoint("mock:dead").expectedMessageCount(1).     template.sendBodyAndHeader("direct:start", "Hello World", "recipients", "mock:a,mock:b").     assertMockEndpointsSatisfied(). }
false;public;0;16;;@Override public void configure() throws Exception {     errorHandler(deadLetterChannel("mock:dead")).     // must use share UoW if we want the error handler to react on     // exceptions     // from the aggregation strategy also.     from("direct:start").recipientList(header("recipients")).aggregationStrategy(new MyAggregateBean()).parallelProcessing().stopOnAggregateException().shareUnitOfWork().end().to("mock:end"). }
false;protected;0;21;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             errorHandler(deadLetterChannel("mock:dead")).             // must use share UoW if we want the error handler to react on             // exceptions             // from the aggregation strategy also.             from("direct:start").recipientList(header("recipients")).aggregationStrategy(new MyAggregateBean()).parallelProcessing().stopOnAggregateException().shareUnitOfWork().end().to("mock:end").         }     }. }
false;public;2;3;;public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {     throw new RuntimeException("Simulating a runtime exception thrown from the aggregation strategy"). }
