commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Override @Before public void setUp() throws Exception {     deleteDirectory("target/data/messages/input").     super.setUp(). }
false;public;0;12;;@Test public void testParis() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:valid").     mock.expectedBodiesReceived("Hello Paris").     template.sendBodyAndHeader("file:target/data/messages/input/", "Paris", Exchange.FILE_NAME, "paris.txt").     mock.assertIsSatisfied().     oneExchangeDone.matchesMockWaitTime().     assertFiles("paris.txt", true). }
false;public;0;14;;@Test public void testLondon() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:invalid").     // we get the original input so its not Hello London but only London     mock.expectedBodiesReceived("London").     template.sendBodyAndHeader("file:target/data/messages/input/", "London", Exchange.FILE_NAME, "london.txt").     mock.assertIsSatisfied().     oneExchangeDone.matchesMockWaitTime().     // london should be deleted as we have failure handled it     assertFiles("london.txt", true). }
false;public;0;14;;@Test public void testDublin() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:beer").     // we get the original input so its not Hello London but only London     mock.expectedBodiesReceived("Dublin").     template.sendBodyAndHeader("file:target/data/messages/input/", "Dublin", Exchange.FILE_NAME, "dublin.txt").     mock.assertIsSatisfied().     oneExchangeDone.matchesMockWaitTime().     // dublin should NOT be deleted, but should be retired on next consumer     assertFiles("dublin.txt", false). }
false;public;0;14;;@Test public void testMadrid() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:error").     // we get the original input so its not Hello London but only London     mock.expectedBodiesReceived("Madrid").     template.sendBodyAndHeader("file:target/data/messages/input/", "Madrid", Exchange.FILE_NAME, "madrid.txt").     mock.assertIsSatisfied().     oneExchangeDone.matchesMockWaitTime().     // madrid should be deleted as the DLC handles it     assertFiles("madrid.txt", true). }
false;private,static;2;10;;private static void assertFiles(String filename, boolean deleted) throws InterruptedException {     // file should be deleted as delete=true in parameter in the route below     File file = new File("target/data/messages/input/" + filename).     assertEquals("File " + filename + " should be deleted: " + deleted, deleted, !file.exists()).     // and no lock files     String lock = filename + FileComponent.DEFAULT_LOCK_FILE_POSTFIX.     file = new File("target/data/messages/input/" + lock).     assertFalse("File " + lock + " should be deleted", file.exists()). }
false;public;0;17;;public void configure() throws Exception {     // make sure mock:error is the dead letter channel     // use no delay for fast unit testing     errorHandler(deadLetterChannel("mock:error").maximumRedeliveries(2).redeliveryDelay(0).logStackTrace(false)).     // special for not handled when we got beer     onException(ValidationException.class).onWhen(exceptionMessage().contains("beer")).handled(false).to("mock:beer").     // special failure handler for ValidationException     onException(ValidationException.class).handled(true).to("mock:invalid").     // our route logic to process files from the input folder     from("file:target/data/messages/input/?initialDelay=0&delay=10&delete=true").process(new MyValidatorProcessor()).to("mock:valid"). }
false;protected;0;21;;protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          public void configure() throws Exception {             // make sure mock:error is the dead letter channel             // use no delay for fast unit testing             errorHandler(deadLetterChannel("mock:error").maximumRedeliveries(2).redeliveryDelay(0).logStackTrace(false)).             // special for not handled when we got beer             onException(ValidationException.class).onWhen(exceptionMessage().contains("beer")).handled(false).to("mock:beer").             // special failure handler for ValidationException             onException(ValidationException.class).handled(true).to("mock:invalid").             // our route logic to process files from the input folder             from("file:target/data/messages/input/?initialDelay=0&delay=10&delete=true").process(new MyValidatorProcessor()).to("mock:valid").         }     }. }
false;public;1;11;;public void process(Exchange exchange) throws Exception {     String body = exchange.getIn().getBody(String.class).     if ("London".equals(body)) {         throw new ValidationException(exchange, "Forced exception by unit test").     } else if ("Madrid".equals(body)) {         throw new RuntimeCamelException("Madrid is not a supported city").     } else if ("Dublin".equals(body)) {         throw new ValidationException(exchange, "Dublin have good beer").     }     exchange.getOut().setBody("Hello " + body). }
