commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;public void process(Exchange exchange) {     Message in = exchange.getIn().     in.setBody(new StreamSource(new StringReader("<input/>"))).     in.setHeader("foo", "bar"). }
false;public;0;15;;public void testSendingAMessageUsingWiretapConvertsToReReadable() throws Exception {     x.expectedBodiesReceived("<input/>+output").     y.expectedBodiesReceived("<input/>+output").     z.expectedBodiesReceived("<input/>+output").     template.send("direct:a", new Processor() {          public void process(Exchange exchange) {             Message in = exchange.getIn().             in.setBody(new StreamSource(new StringReader("<input/>"))).             in.setHeader("foo", "bar").         }     }).     assertMockEndpointsSatisfied(). }
false;public;0;12;;@Test public void testSendingAMessageUsingWiretapShouldNotDeleteStreamFileBeforeAllExcangesAreComplete() throws InterruptedException {     x.expectedMessageCount(1).     y.expectedMessageCount(1).     z.expectedMessageCount(1).     // the used file should contain more than one character in order to be streamed into the file system     template.sendBody("direct:a", this.getClass().getClassLoader().getResourceAsStream("org/apache/camel/processor/twoCharacters.txt")).     assertMockEndpointsSatisfied(). }
false;public;0;9;;@Override @Before public void setUp() throws Exception {     super.setUp().     x = getMockEndpoint("mock:x").     y = getMockEndpoint("mock:y").     z = getMockEndpoint("mock:z"). }
false;public;1;6;;public void process(Exchange exchange) {     // lets transform the IN message     Message in = exchange.getIn().     String body = in.getBody(String.class).     in.setBody(body + "+output"). }
false;public;0;16;;public void configure() {     // enable stream caching     context.setStreamCaching(true).     // set stream threshold to 1, in order to stream into the file system     context.getStreamCachingStrategy().setSpoolThreshold(1).     errorHandler(deadLetterChannel("mock:error").redeliveryDelay(0).maximumRedeliveries(3)).     // stream caching should fix re-readability issues when wire tapping messages     from("direct:a").wireTap("direct:x").wireTap("direct:y").wireTap("direct:z").     from("direct:x").process(processor).to("mock:x").     // even if a process takes more time then the others the wire tap shall work     from("direct:y").delay(500).process(processor).to("mock:y").     from("direct:z").process(processor).to("mock:z"). }
false;protected;0;29;;protected RouteBuilder createRouteBuilder() {     final Processor processor = new Processor() {          public void process(Exchange exchange) {             // lets transform the IN message             Message in = exchange.getIn().             String body = in.getBody(String.class).             in.setBody(body + "+output").         }     }.     return new RouteBuilder() {          public void configure() {             // enable stream caching             context.setStreamCaching(true).             // set stream threshold to 1, in order to stream into the file system             context.getStreamCachingStrategy().setSpoolThreshold(1).             errorHandler(deadLetterChannel("mock:error").redeliveryDelay(0).maximumRedeliveries(3)).             // stream caching should fix re-readability issues when wire tapping messages             from("direct:a").wireTap("direct:x").wireTap("direct:y").wireTap("direct:z").             from("direct:x").process(processor).to("mock:x").             // even if a process takes more time then the others the wire tap shall work             from("direct:y").delay(500).process(processor).to("mock:y").             from("direct:z").process(processor).to("mock:z").         }     }. }
