commented;modifiers;parameterAmount;loc;comment;code
false;public;0;16;;@Test public void testRouteIsCorrectAtRuntime() throws Exception {     // use navigate to find that the end works as expected     Navigate<Processor> nav = context.getRoutes().get(0).navigate().     List<Processor> node = nav.next().     // there should be 4 outputs as the end in the otherwise should     // ensure that the transform and last send is not within the choice     assertEquals(4, node.size()).     // the navigate API is a bit simple at this time of writing so it does take a little     // bit of ugly code to find the correct processor in the runtime route     assertIsInstanceOf(SendProcessor.class, unwrapChannel(node.get(0)).getNextProcessor()).     assertIsInstanceOf(Splitter.class, unwrapChannel(node.get(1)).getNextProcessor()).     assertIsInstanceOf(TransformProcessor.class, unwrapChannel(node.get(2)).getNextProcessor()).     assertIsInstanceOf(SendProcessor.class, unwrapChannel(node.get(3)).getNextProcessor()). }
false;public;0;9;;@Test public void testSplit() throws Exception {     getMockEndpoint("mock:start").expectedBodiesReceived("Hello,World,Moon").     getMockEndpoint("mock:last").expectedBodiesReceived("last hi Hello@hi World@hi Moon").     template.sendBody("direct:start", "Hello,World,Moon").     assertMockEndpointsSatisfied(). }
false;public;2;9;;public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {     if (oldExchange == null) {         return newExchange.     }     String body = oldExchange.getIn().getBody(String.class).     String newBody = newExchange.getIn().getBody(String.class).     newExchange.getIn().setBody(body + "@" + newBody).     return newExchange. }
false;public;0;25;;@Override public void configure() throws Exception {     context.setTracing(true).     MySplitBean bean = new MySplitBean().     from("direct:start").to("mock:start").split(body().tokenize(","), new AggregationStrategy() {          public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {             if (oldExchange == null) {                 return newExchange.             }             String body = oldExchange.getIn().getBody(String.class).             String newBody = newExchange.getIn().getBody(String.class).             newExchange.getIn().setBody(body + "@" + newBody).             return newExchange.         }     }).bean(bean, "hi").to("mock:split").to("log:foo").end().transform(body().prepend("last ")).to("mock:last"). }
false;protected;0;30;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             context.setTracing(true).             MySplitBean bean = new MySplitBean().             from("direct:start").to("mock:start").split(body().tokenize(","), new AggregationStrategy() {                  public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {                     if (oldExchange == null) {                         return newExchange.                     }                     String body = oldExchange.getIn().getBody(String.class).                     String newBody = newExchange.getIn().getBody(String.class).                     newExchange.getIn().setBody(body + "@" + newBody).                     return newExchange.                 }             }).bean(bean, "hi").to("mock:split").to("log:foo").end().transform(body().prepend("last ")).to("mock:last").         }     }. }
false;public;1;3;;public String hi(String s) {     return "hi " + s. }
