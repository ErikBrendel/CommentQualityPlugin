commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;protected boolean canTest() {     // skip test on windows as it does not run well there     return !isPlatform("windows"). }
false;public;0;26;;@Test public void testDsl() throws Exception {     if (!canTest()) {         return.     }     MockEndpoint resultEndpoint = resolveMandatoryEndpoint("mock:result", MockEndpoint.class).     resultEndpoint.expectedMessageCount(messageCount).     ExecutorService executor = Executors.newFixedThreadPool(messageCount).     long start = System.currentTimeMillis().     for (int i = 0. i < messageCount. i++) {         executor.execute(() -> template.sendBodyAndHeader("direct:start", "payload", "ThrottleCount", 1)).     }     // let's wait for the exchanges to arrive     resultEndpoint.assertIsSatisfied().     // now assert that they have actually been throttled     long minimumTime = (messageCount - 1) * INTERVAL.     // add a little slack     long delta = System.currentTimeMillis() - start + 200.     assertTrue("Should take at least " + minimumTime + "ms, was: " + delta, delta >= minimumTime).     executor.shutdownNow(). }
false;public;0;7;;public void configure() {     from("direct:start").throttle().message(m -> m.getHeader("ThrottleCount", Integer.class)).timePeriodMillis(INTERVAL).to("log:result", "mock:result"). }
false;protected;0;11;;protected RouteBuilder createRouteBuilder() {     return new RouteBuilder() {          public void configure() {             from("direct:start").throttle().message(m -> m.getHeader("ThrottleCount", Integer.class)).timePeriodMillis(INTERVAL).to("log:result", "mock:result").         }     }. }
