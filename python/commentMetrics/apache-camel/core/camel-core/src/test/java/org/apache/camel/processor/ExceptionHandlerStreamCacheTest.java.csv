commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Test public void testSendFault() throws Exception {     doTestInputStreamPayload("fault"). }
false;public;0;4;;@Test public void testSendError() throws Exception {     doTestInputStreamPayload("error"). }
false;private;1;12;;private void doTestInputStreamPayload(String message) throws InterruptedException, IOException {     successEndpoint.expectedMessageCount(0).     exceptionEndpoint.expectedMessageCount(1).     template.sendBody("direct:start", new ByteArrayInputStream(message.getBytes())).     successEndpoint.assertIsSatisfied().     exceptionEndpoint.assertIsSatisfied().     InputStream body = (InputStream) exceptionEndpoint.getExchanges().get(0).getIn().getBody().     assertEquals("Ensure message re-readability in the exception handler", message, new String(IOConverter.toBytes(body))). }
false;public;0;4;;@Test public void testSendFaultXml() throws Exception {     doTestXmlPayload("<fault/>"). }
false;public;0;4;;@Test public void testSendErrorXml() throws Exception {     doTestXmlPayload("<error/>"). }
false;private;1;12;;private void doTestXmlPayload(String xml) throws InterruptedException, TransformerException {     successEndpoint.expectedMessageCount(0).     exceptionEndpoint.expectedMessageCount(1).     template.sendBody("direct:start", new StreamSource(new ByteArrayInputStream(xml.getBytes()))).     successEndpoint.assertIsSatisfied().     exceptionEndpoint.assertIsSatisfied().     StreamSource body = (StreamSource) exceptionEndpoint.getExchanges().get(0).getIn().getBody().     assertEquals("Ensure message re-readability in the exception handler", xml, new XmlConverter().toString(body, null)). }
false;public;0;8;;@Override @Before public void setUp() throws Exception {     super.setUp().     exceptionEndpoint = getMockEndpoint("mock:exception").     successEndpoint = getMockEndpoint("mock:success"). }
false;public;1;13;;public void process(Exchange exchange) throws Exception {     String message = exchange.getIn().getBody(String.class).     if (message.contains("fault")) {         exchange.getOut().copyFrom(exchange.getIn()).         exchange.getOut().setBody(new ByteArrayInputStream(message.getBytes())).         exchange.getOut().setFault(true).     }     if (message.contains("error")) {         throw new RuntimeException(message).     } }
false;public;0;23;;public void configure() {     // enable support for handling faults and stream caching     context.setHandleFault(true).     context.setStreamCaching(true).     onException(Exception.class).handled(true).to("mock:exception").     from("direct:start").process(new Processor() {          public void process(Exchange exchange) throws Exception {             String message = exchange.getIn().getBody(String.class).             if (message.contains("fault")) {                 exchange.getOut().copyFrom(exchange.getIn()).                 exchange.getOut().setBody(new ByteArrayInputStream(message.getBytes())).                 exchange.getOut().setFault(true).             }             if (message.contains("error")) {                 throw new RuntimeException(message).             }         }     }).to("mock:success"). }
false;protected;0;28;;protected RouteBuilder createRouteBuilder() {     return new RouteBuilder() {          public void configure() {             // enable support for handling faults and stream caching             context.setHandleFault(true).             context.setStreamCaching(true).             onException(Exception.class).handled(true).to("mock:exception").             from("direct:start").process(new Processor() {                  public void process(Exchange exchange) throws Exception {                     String message = exchange.getIn().getBody(String.class).                     if (message.contains("fault")) {                         exchange.getOut().copyFrom(exchange.getIn()).                         exchange.getOut().setBody(new ByteArrayInputStream(message.getBytes())).                         exchange.getOut().setFault(true).                     }                     if (message.contains("error")) {                         throw new RuntimeException(message).                     }                 }             }).to("mock:success").         }     }. }
