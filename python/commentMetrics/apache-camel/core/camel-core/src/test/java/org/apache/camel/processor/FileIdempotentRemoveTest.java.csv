commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@Override @Before public void setUp() throws Exception {     // delete file store before testing     if (store.exists()) {         store.delete().     }     repo = FileIdempotentRepository.fileIdempotentRepository(store).     super.setUp(). }
false;public;0;27;;@Test public void testRemove() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedBodiesReceived("Foo", "Bar").     template.sendBodyAndHeader("direct:start", "Foo", "messageId", "A").     template.sendBodyAndHeader("direct:start", "Camel rocks", "messageId", "A").     template.sendBodyAndHeader("direct:start", "Bar", "messageId", "B").     assertMockEndpointsSatisfied().     mock.reset().     mock.expectedBodiesReceived("Camel rocks").     repo.remove("A").     template.sendBodyAndHeader("direct:start", "Camel rocks", "messageId", "A").     template.sendBodyAndHeader("direct:start", "Bar again", "messageId", "B").     assertMockEndpointsSatisfied().     // remove should flush file so we will only see B in the file     repo.remove("A").     String data = context.getTypeConverter().convertTo(String.class, store).     assertEquals("B\n", data). }
false;public;0;5;;public void configure() {     from("direct:start").idempotentConsumer(header("messageId"), repo).to("mock:result"). }
false;protected;0;9;;protected RouteBuilder createRouteBuilder() {     return new RouteBuilder() {          public void configure() {             from("direct:start").idempotentConsumer(header("messageId"), repo).to("mock:result").         }     }. }
