commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isUseRouteBuilder() {     return false. }
false;public;0;14;;@Override public void configure() throws Exception {     errorHandler(deadLetterChannel("mock:dead")).     from("direct:start").idempotentConsumer(header("messageId"), repo).completionEager(true).to("log:a", "mock:a").to("log:b", "mock:b").end().filter(simple("${header.messageId} == '2'")).throwException(new IllegalArgumentException("Forced")).end().to("log:result", "mock:result"). }
false;public;0;37;;@Test public void testCompletionEager() throws Exception {     repo = MemoryIdempotentRepository.memoryIdempotentRepository(200).     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             errorHandler(deadLetterChannel("mock:dead")).             from("direct:start").idempotentConsumer(header("messageId"), repo).completionEager(true).to("log:a", "mock:a").to("log:b", "mock:b").end().filter(simple("${header.messageId} == '2'")).throwException(new IllegalArgumentException("Forced")).end().to("log:result", "mock:result").         }     }).     context.start().     // we are on block only scope as "two" was success in the block, and then "two" failed afterwards does not matter     // the idempotent consumer will not receive "two" again     a.expectedBodiesReceived("one", "two", "three").     b.expectedBodiesReceived("one", "two", "three").     dead.expectedBodiesReceived("two", "two").     resultEndpoint.expectedBodiesReceived("one", "one", "one", "three").     sendMessage("1", "one").     sendMessage("2", "two").     sendMessage("1", "one").     sendMessage("2", "two").     sendMessage("1", "one").     sendMessage("3", "three").     assertMockEndpointsSatisfied(). }
false;public;0;14;;@Override public void configure() throws Exception {     errorHandler(deadLetterChannel("mock:dead")).     from("direct:start").idempotentConsumer(header("messageId"), repo).completionEager(false).to("log:a", "mock:a").to("log:b", "mock:b").end().filter(simple("${header.messageId} == '2'")).throwException(new IllegalArgumentException("Forced")).end().to("log:result", "mock:result"). }
false;public;0;36;;@Test public void testNotCompletionEager() throws Exception {     repo = MemoryIdempotentRepository.memoryIdempotentRepository(200).     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             errorHandler(deadLetterChannel("mock:dead")).             from("direct:start").idempotentConsumer(header("messageId"), repo).completionEager(false).to("log:a", "mock:a").to("log:b", "mock:b").end().filter(simple("${header.messageId} == '2'")).throwException(new IllegalArgumentException("Forced")).end().to("log:result", "mock:result").         }     }).     context.start().     // we are on completion scope so the "two" will rollback and therefore the idempotent consumer receives those again     a.expectedBodiesReceived("one", "two", "two", "three").     b.expectedBodiesReceived("one", "two", "two", "three").     dead.expectedBodiesReceived("two", "two").     resultEndpoint.expectedBodiesReceived("one", "one", "one", "three").     sendMessage("1", "one").     sendMessage("2", "two").     sendMessage("1", "one").     sendMessage("2", "two").     sendMessage("1", "one").     sendMessage("3", "three").     assertMockEndpointsSatisfied(). }
false;public;1;6;;public void process(Exchange exchange) {     // now lets fire in a message     Message in = exchange.getIn().     in.setBody(body).     in.setHeader("messageId", messageId). }
false;protected;2;10;;protected void sendMessage(final Object messageId, final Object body) {     template.send(startEndpoint, new Processor() {          public void process(Exchange exchange) {             // now lets fire in a message             Message in = exchange.getIn().             in.setBody(body).             in.setHeader("messageId", messageId).         }     }). }
false;public;0;11;;@Override @Before public void setUp() throws Exception {     super.setUp().     startEndpoint = resolveMandatoryEndpoint("direct:start").     resultEndpoint = getMockEndpoint("mock:result").     a = getMockEndpoint("mock:a").     b = getMockEndpoint("mock:b").     dead = getMockEndpoint("mock:dead"). }
