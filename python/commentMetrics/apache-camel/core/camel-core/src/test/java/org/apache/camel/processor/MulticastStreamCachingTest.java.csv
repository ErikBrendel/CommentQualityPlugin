commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;public void process(Exchange exchange) {     Message in = exchange.getIn().     in.setBody(new StreamSource(new StringReader("<input/>"))).     in.setHeader("foo", "bar"). }
false;public;0;16;;@Test public void testSendingAMessageUsingMulticastConvertsToReReadable() throws Exception {     x.expectedBodiesReceived("<input/>+output").     y.expectedBodiesReceived("<input/>+output").     z.expectedBodiesReceived("<input/>+output").     template.send("direct:a", new Processor() {          public void process(Exchange exchange) {             Message in = exchange.getIn().             in.setBody(new StreamSource(new StringReader("<input/>"))).             in.setHeader("foo", "bar").         }     }).     assertMockEndpointsSatisfied(). }
false;public;0;9;;@Override @Before public void setUp() throws Exception {     super.setUp().     x = getMockEndpoint("mock:x").     y = getMockEndpoint("mock:y").     z = getMockEndpoint("mock:z"). }
false;public;1;6;;public void process(Exchange exchange) {     // lets transform the IN message     Message in = exchange.getIn().     String body = in.getBody(String.class).     in.setBody(body + "+output"). }
false;public;0;13;;public void configure() {     // enable stream caching     context.setStreamCaching(true).     errorHandler(deadLetterChannel("mock:error").redeliveryDelay(0).maximumRedeliveries(3)).     // stream caching should fix re-readability issues when multicasting messages     from("direct:a").multicast().to("direct:x", "direct:y", "direct:z").     from("direct:x").process(processor).to("mock:x").     from("direct:y").process(processor).to("mock:y").     from("direct:z").process(processor).to("mock:z"). }
false;protected;0;26;;protected RouteBuilder createRouteBuilder() {     final Processor processor = new Processor() {          public void process(Exchange exchange) {             // lets transform the IN message             Message in = exchange.getIn().             String body = in.getBody(String.class).             in.setBody(body + "+output").         }     }.     return new RouteBuilder() {          public void configure() {             // enable stream caching             context.setStreamCaching(true).             errorHandler(deadLetterChannel("mock:error").redeliveryDelay(0).maximumRedeliveries(3)).             // stream caching should fix re-readability issues when multicasting messages             from("direct:a").multicast().to("direct:x", "direct:y", "direct:z").             from("direct:x").process(processor).to("mock:x").             from("direct:y").process(processor).to("mock:y").             from("direct:z").process(processor).to("mock:z").         }     }. }
