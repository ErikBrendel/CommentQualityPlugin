commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override @Before public void setUp() throws Exception {     latch = new CountDownLatch(2).     bean = spy(new MyBean(latch)).     super.setUp(). }
false;public;0;28;;@Test public void testAsyncAwaitInterrupt() throws Exception {     context.getAsyncProcessorAwaitManager().getStatistics().setStatisticsEnabled(true).     assertEquals(0, context.getAsyncProcessorAwaitManager().size()).     getMockEndpoint("mock:before").expectedBodiesReceived("Hello Camel").     getMockEndpoint("mock:result").expectedMessageCount(0).     getMockEndpoint("mock:error").expectedMessageCount(0).     createThreadToInterrupt().     try {         template.sendBody("direct:start", "Hello Camel").         fail("Should throw exception").     } catch (CamelExecutionException e) {         RejectedExecutionException cause = assertIsInstanceOf(RejectedExecutionException.class, e.getCause()).         assertTrue(cause.getMessage().startsWith("Interrupted while waiting for asynchronous callback")).     }     assertMockEndpointsSatisfied().     // Check we have not reached the full 5 re-deliveries     verify(bean, atMost(4)).callMe().     assertEquals(0, context.getAsyncProcessorAwaitManager().size()).     assertEquals(1, context.getAsyncProcessorAwaitManager().getStatistics().getThreadsBlocked()).     assertEquals(1, context.getAsyncProcessorAwaitManager().getStatistics().getThreadsInterrupted()). }
false;private;0;21;;private void createThreadToInterrupt() {     new Thread(() -> {         // Allow some time for camel exchange to enter the re-deliveries         try {             latch.await(1, TimeUnit.SECONDS).         } catch (InterruptedException e) {             e.printStackTrace().         }         // Get our blocked thread         int size = context.getAsyncProcessorAwaitManager().size().         assertEquals(1, size).         Collection<AsyncProcessorAwaitManager.AwaitThread> threads = context.getAsyncProcessorAwaitManager().browse().         AsyncProcessorAwaitManager.AwaitThread thread = threads.iterator().next().         // Interrupt it         String id = thread.getExchange().getExchangeId().         context.getAsyncProcessorAwaitManager().interrupt(id).     }).start(). }
false;protected;0;7;;@Override protected Context createJndiContext() throws Exception {     JndiContext jndiContext = new JndiContext().     jndiContext.bind("myBean", bean).     return jndiContext. }
false;public;0;12;;@Override public void configure() {     errorHandler(deadLetterChannel("mock:error").maximumRedeliveries(5).redeliveryDelay(100).asyncDelayedRedelivery()).     from("direct:start").routeId("myRoute").to("mock:before").bean("myBean", "callMe").to("mock:result"). }
false;protected;0;17;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() {             errorHandler(deadLetterChannel("mock:error").maximumRedeliveries(5).redeliveryDelay(100).asyncDelayedRedelivery()).             from("direct:start").routeId("myRoute").to("mock:before").bean("myBean", "callMe").to("mock:result").         }     }. }
false;public;0;4;;public void callMe() throws Exception {     latch.countDown().     throw new Exception(). }
