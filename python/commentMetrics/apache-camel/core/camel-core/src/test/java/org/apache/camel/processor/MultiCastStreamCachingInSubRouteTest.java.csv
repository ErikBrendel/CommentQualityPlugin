commented;modifiers;parameterAmount;loc;comment;code
false;public;0;20;;@Override public void configure() throws Exception {     context.setStreamCaching(true).     context.getStreamCachingStrategy().setEnabled(true).     context.getStreamCachingStrategy().setSpoolDirectory("target/camel/cache").     context.getStreamCachingStrategy().setSpoolThreshold(1L).     from("direct:start").multicast(new InternalAggregationStrategy()).to("direct:a", "direct:b").end().to("mock:result").     from("direct:startNestedMultiCast").multicast(new InternalAggregationStrategy()).to("direct:start").end().to("mock:resultNested").     //      from("direct:a").process(//      new InputProcessorWithStreamCache(1)).to("mock:resulta").     //      from("direct:b").process(//      new InputProcessorWithStreamCache(2)).to("mock:resultb"). }
false;protected;0;25;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             context.setStreamCaching(true).             context.getStreamCachingStrategy().setEnabled(true).             context.getStreamCachingStrategy().setSpoolDirectory("target/camel/cache").             context.getStreamCachingStrategy().setSpoolThreshold(1L).             from("direct:start").multicast(new InternalAggregationStrategy()).to("direct:a", "direct:b").end().to("mock:result").             from("direct:startNestedMultiCast").multicast(new InternalAggregationStrategy()).to("direct:start").end().to("mock:resultNested").             //              from("direct:a").process(//              new InputProcessorWithStreamCache(1)).to("mock:resulta").             //              from("direct:b").process(//              new InputProcessorWithStreamCache(2)).to("mock:resultb").         }     }. }
false;public;0;8;;@Test public void testWithAggregationStrategyAndStreamCacheInSubRoute() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedBodiesReceived("Test Message 1Test Message 2").     template.sendBody("direct:start", "<start></start>").     assertMockEndpointsSatisfied(). }
false;public;0;8;;@Test public void testNestedMultiCastWithCachedStreamInAggregationStrategy() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:resultNested").     mock.expectedBodiesReceived("Test Message 1Test Message 2").     template.sendBody("direct:startNestedMultiCast", "<start></start>").     assertMockEndpointsSatisfied(). }
false;public;1;11;;@Override public void process(Exchange exchange) throws Exception {     CachedOutputStream cos = new CachedOutputStream(exchange).     String s = "Test Message " + number.     cos.write(s.getBytes(Charset.forName("UTF-8"))).     cos.close().     InputStream is = (InputStream) cos.newStreamCache().     exchange.getOut().setBody(is). }
false;public;2;20;;@Override public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {     if (oldExchange == null) {         return newExchange.     }     try {         String oldBody = oldExchange.getIn().getBody(String.class).         String newBody = newExchange.getIn().getBody(String.class).         String merged = oldBody + newBody.         // also do stream caching in the aggregation strategy         CachedOutputStream cos = new CachedOutputStream(newExchange).         cos.write(merged.getBytes("UTF-8")).         cos.close().         oldExchange.getIn().setBody(cos.newStreamCache()).         return oldExchange.     } catch (IOException e) {         throw new IllegalStateException(e).     } }
