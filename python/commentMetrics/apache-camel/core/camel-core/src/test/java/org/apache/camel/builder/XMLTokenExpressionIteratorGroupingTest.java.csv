commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before public void setUp() {     nsmap = new HashMap<>().     nsmap.put("g", "urn:g").     nsmap.put("c", "urn:c"). }
true;public;0;5;// wrapped mode ;// wrapped mode @Test public void testExtractWrappedSize1() throws Exception {     invokeAndVerify("//c:C", 'w', 1, new ByteArrayInputStream(TEST_BODY), "utf-8", RESULTS_WRAPPED_SIZE1). }
false;public;0;5;;@Test public void testExtractWrappedSize2() throws Exception {     invokeAndVerify("//c:C", 'w', 2, new ByteArrayInputStream(TEST_BODY), "utf-8", RESULTS_WRAPPED_SIZE2). }
false;public;0;5;;@Test public void testExtractWrappedSize3L() throws Exception {     invokeAndVerify("//c:C", 'w', 3, new ByteArrayInputStream(TEST_BODY), "utf-8", RESULTS_WRAPPED_SIZE3L). }
true;public;0;4;// disabled: not working for now as the context extraction across two ancestor paths is not working ;// disabled: not working for now as the context extraction across two ancestor paths is not working public void disabledtestExtractWrappedSize3U() throws Exception {     invokeAndVerify("//c:C", 'W', 3, new ByteArrayInputStream(TEST_BODY), "utf-8", RESULTS_WRAPPED_SIZE3U). }
false;public;0;5;;@Test public void testExtractWrappedSize4() throws Exception {     invokeAndVerify("//c:C", 'w', 4, new ByteArrayInputStream(TEST_BODY), "utf-8", RESULTS_WRAPPED_SIZE4). }
false;public;0;5;;@Test public void testExtractWrappedSize5L() throws Exception {     invokeAndVerify("//c:C", 'w', 5, new ByteArrayInputStream(TEST_BODY), "utf-8", RESULTS_WRAPPED_SIZE5L). }
true;public;0;4;// disabled: not working for now as the context extraction across two ancestor paths is not working ;// disabled: not working for now as the context extraction across two ancestor paths is not working public void disabledtestExtractWrappedSize5U() throws Exception {     invokeAndVerify("//c:C", 'W', 5, new ByteArrayInputStream(TEST_BODY), "utf-8", RESULTS_WRAPPED_SIZE5U). }
true;public;0;5;// injected mode ;// injected mode @Test public void testExtractInjectedSize1() throws Exception {     invokeAndVerify("//c:C", 'i', 1, new ByteArrayInputStream(TEST_BODY), "utf-8", RESULTS_INJECTED_SIZE1). }
false;public;0;5;;@Test public void testExtractInjectedSize2() throws Exception {     invokeAndVerify("//c:C", 'i', 2, new ByteArrayInputStream(TEST_BODY), "utf-8", RESULTS_INJECTED_SIZE2). }
false;public;0;5;;@Test public void testExtractInjectedSize3() throws Exception {     invokeAndVerify("//c:C", 'i', 3, new ByteArrayInputStream(TEST_BODY), "utf-8", RESULTS_INJECTED_SIZE3). }
false;public;0;5;;@Test public void testExtractInjectedSize4() throws Exception {     invokeAndVerify("//c:C", 'i', 4, new ByteArrayInputStream(TEST_BODY), "utf-8", RESULTS_INJECTED_SIZE4). }
false;public;0;5;;@Test public void testExtractInjectedSize5() throws Exception {     invokeAndVerify("//c:C", 'i', 5, new ByteArrayInputStream(TEST_BODY), "utf-8", RESULTS_INJECTED_SIZE5). }
false;public;0;16;;@Test public void testExtractWrappedLeftOver() throws Exception {     final byte[] data = ("<?xml version='1.0' encoding='UTF-8'?><g:A xmlns:g='urn:g'><c:B attr='1' xmlns:c='urn:c'>" + "<c:C attr='1'>peach</c:C>" + "<c:C attr='2'/>" + "<c:C attr='3'>orange</c:C>" + "</c:B></g:A>").getBytes().     final String[] results = { "<?xml version='1.0' encoding='UTF-8'?><g:A xmlns:g='urn:g'><c:B attr='1' xmlns:c='urn:c'>" + "<c:C attr='1'>peach</c:C><c:C attr='2'/>" + "</c:B></g:A>", "<?xml version='1.0' encoding='UTF-8'?><g:A xmlns:g='urn:g'><c:B attr='1' xmlns:c='urn:c'>" + "<c:C attr='3'>orange</c:C>" + "</c:B></g:A>" }.     invokeAndVerify("//c:C", 'w', 2, new ByteArrayInputStream(data), "utf-8", results). }
false;private;6;19;;private void invokeAndVerify(String path, char mode, int group, InputStream in, String charset, String[] expected) throws Exception {     XMLTokenExpressionIterator xtei = new XMLTokenExpressionIterator(path, mode).     xtei.setNamespaces(nsmap).     xtei.setGroup(group).     Iterator<?> it = xtei.createIterator(in, "utf-8").     List<String> results = new ArrayList<>().     while (it.hasNext()) {         results.add((String) it.next()).     }     ((Closeable) it).close().     assertEquals("token count", expected.length, results.size()).     for (int i = 0. i < expected.length. i++) {         assertEquals("mismatch [" + i + "]", expected[i], results.get(i)).     } }
