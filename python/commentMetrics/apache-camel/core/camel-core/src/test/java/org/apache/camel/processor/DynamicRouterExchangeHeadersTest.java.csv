commented;modifiers;parameterAmount;loc;comment;code
false;public;0;24;;@Test public void testDynamicRouter() throws Exception {     getMockEndpoint("mock:a").expectedBodiesReceived("Hello World").     getMockEndpoint("mock:a").expectedHeaderReceived("invoked", 1).     getMockEndpoint("mock:b").expectedBodiesReceived("Hello World").     getMockEndpoint("mock:b").expectedHeaderReceived("invoked", 2).     getMockEndpoint("mock:c").expectedBodiesReceived("Hello World").     getMockEndpoint("mock:c").expectedHeaderReceived("invoked", 2).     getMockEndpoint("mock:foo").expectedBodiesReceived("Bye World").     getMockEndpoint("mock:foo").expectedHeaderReceived("invoked", 3).     getMockEndpoint("mock:result").expectedBodiesReceived("Bye World").     getMockEndpoint("mock:result").expectedHeaderReceived("invoked", 4).     template.sendBody("direct:start", "Hello World").     assertMockEndpointsSatisfied().     assertEquals(5, bodies.size()).     assertEquals("Hello World", bodies.get(0)).     assertEquals("Hello World", bodies.get(1)).     assertEquals("Hello World", bodies.get(2)).     assertEquals("Bye World", bodies.get(3)).     assertEquals("Bye World", bodies.get(4)). }
false;public;0;8;;@Override public void configure() throws Exception {     from("direct:start").dynamicRouter(method(DynamicRouterExchangeHeadersTest.class, "slip")).     from("direct:foo").transform(constant("Bye World")).to("mock:foo"). }
false;protected;0;13;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             from("direct:start").dynamicRouter(method(DynamicRouterExchangeHeadersTest.class, "slip")).             from("direct:foo").transform(constant("Bye World")).to("mock:foo").         }     }. }
true;public;2;27;/**  * Use this method to compute dynamic where we should route next.  *  * @param body the message body  * @param headers the message headers where we can store state between invocations  * @return endpoints to go, or <tt>null</tt> to indicate the end  */ ;// START SNIPPET: e2 /**  * Use this method to compute dynamic where we should route next.  *  * @param body the message body  * @param headers the message headers where we can store state between invocations  * @return endpoints to go, or <tt>null</tt> to indicate the end  */ public String slip(String body, @Headers Map<String, Object> headers) {     bodies.add(body).     // get the state from the message headers and keep track how many times     // we have been invoked     int invoked = 0.     Object current = headers.get("invoked").     if (current != null) {         invoked = Integer.valueOf(current.toString()).     }     invoked++.     // and store the state back on the headers     headers.put("invoked", invoked).     if (invoked == 1) {         return "mock:a".     } else if (invoked == 2) {         return "mock:b,mock:c".     } else if (invoked == 3) {         return "direct:foo".     } else if (invoked == 4) {         return "mock:result".     }     // no more so return null     return null. }
