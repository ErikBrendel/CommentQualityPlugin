commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isUseRouteBuilder() {     return false. }
false;public;0;6;;@Override @Before public void setUp() throws Exception {     super.setUp().     executorService = Executors.newSingleThreadExecutor(). }
false;public;0;43;;@Test public void testAggregateProcessorTimeoutRestart() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedBodiesReceived("A+B").     mock.expectedPropertyReceived(Exchange.AGGREGATED_COMPLETED_BY, "timeout").     AsyncProcessor done = new SendProcessor(context.getEndpoint("mock:result")).     Expression corr = header("id").     AggregationStrategy as = new BodyInAggregatingStrategy().     AggregateProcessor ap = new AggregateProcessor(context, done, corr, as, executorService, true).     // start with a high timeout so no completes before we stop     ap.setCompletionTimeout(250).     ap.setCompletionTimeoutCheckerInterval(10).     ap.start().     Exchange e1 = new DefaultExchange(context).     e1.getIn().setBody("A").     e1.getIn().setHeader("id", 123).     Exchange e2 = new DefaultExchange(context).     e2.getIn().setBody("B").     e2.getIn().setHeader("id", 123).     ap.process(e1).     ap.process(e2).     // shutdown before the 1/4 sec timeout occurs     // however we use stop instead of shutdown as shutdown will clear the in memory aggregation repository,     ap.stop().     // should be no completed     assertEquals(0, mock.getReceivedCounter()).     // start aggregator again     ap.start().     // the aggregator should restore the timeout condition and trigger timeout     assertMockEndpointsSatisfied().     assertEquals(1, mock.getReceivedCounter()).     ap.shutdown(). }
false;public;0;45;;@Test public void testAggregateProcessorTimeoutExpressionRestart() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedBodiesReceived("A+B").     mock.expectedPropertyReceived(Exchange.AGGREGATED_COMPLETED_BY, "timeout").     AsyncProcessor done = new SendProcessor(context.getEndpoint("mock:result")).     Expression corr = header("id").     AggregationStrategy as = new BodyInAggregatingStrategy().     AggregateProcessor ap = new AggregateProcessor(context, done, corr, as, executorService, true).     // start with a high timeout so no completes before we stop     ap.setCompletionTimeoutExpression(header("myTimeout")).     ap.setCompletionTimeoutCheckerInterval(10).     ap.start().     Exchange e1 = new DefaultExchange(context).     e1.getIn().setBody("A").     e1.getIn().setHeader("id", 123).     e1.getIn().setHeader("myTimeout", 250).     Exchange e2 = new DefaultExchange(context).     e2.getIn().setBody("B").     e2.getIn().setHeader("id", 123).     e2.getIn().setHeader("myTimeout", 250).     ap.process(e1).     ap.process(e2).     // shutdown before the 1/4 sec timeout occurs     // however we use stop instead of shutdown as shutdown will clear the in memory aggregation repository,     ap.stop().     // should be no completed     assertEquals(0, mock.getReceivedCounter()).     // start aggregator again     ap.start().     // the aggregator should restore the timeout condition and trigger timeout     assertMockEndpointsSatisfied().     assertEquals(1, mock.getReceivedCounter()).     ap.shutdown(). }
false;public;0;57;;@Test public void testAggregateProcessorTwoTimeoutExpressionRestart() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedBodiesReceived("C+D", "A+B").     mock.expectedPropertyReceived(Exchange.AGGREGATED_COMPLETED_BY, "timeout").     AsyncProcessor done = new SendProcessor(context.getEndpoint("mock:result")).     Expression corr = header("id").     AggregationStrategy as = new BodyInAggregatingStrategy().     AggregateProcessor ap = new AggregateProcessor(context, done, corr, as, executorService, true).     // start with a high timeout so no completes before we stop     ap.setCompletionTimeoutExpression(header("myTimeout")).     ap.setCompletionTimeoutCheckerInterval(10).     ap.start().     Exchange e1 = new DefaultExchange(context).     e1.getIn().setBody("A").     e1.getIn().setHeader("id", 123).     e1.getIn().setHeader("myTimeout", 300).     Exchange e2 = new DefaultExchange(context).     e2.getIn().setBody("B").     e2.getIn().setHeader("id", 123).     e2.getIn().setHeader("myTimeout", 300).     Exchange e3 = new DefaultExchange(context).     e3.getIn().setBody("C").     e3.getIn().setHeader("id", 456).     e3.getIn().setHeader("myTimeout", 250).     Exchange e4 = new DefaultExchange(context).     e4.getIn().setBody("D").     e4.getIn().setHeader("id", 456).     e4.getIn().setHeader("myTimeout", 250).     ap.process(e1).     ap.process(e2).     ap.process(e3).     ap.process(e4).     // shutdown before the 1/4 sec timeout occurs     // however we use stop instead of shutdown as shutdown will clear the in memory aggregation repository,     ap.stop().     // should be no completed     assertEquals(0, mock.getReceivedCounter()).     // start aggregator again     ap.start().     // the aggregator should restore the timeout condition and trigger timeout     assertMockEndpointsSatisfied().     assertEquals(2, mock.getReceivedCounter()).     ap.shutdown(). }
