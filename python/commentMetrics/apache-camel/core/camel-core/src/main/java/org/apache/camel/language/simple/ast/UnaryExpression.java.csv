commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Override public String toString() {     if (left != null) {         return left + token.getText().     } else {         return token.getText().     } }
true;public;1;3;/**  * Accepts the left node to this operator  *  * @param left  the left node to accept  */ ;/**  * Accepts the left node to this operator  *  * @param left  the left node to accept  */ public void acceptLeft(SimpleNode left) {     this.left = left. }
false;public;0;3;;public UnaryOperatorType getOperator() {     return operator. }
false;public;1;14;;@Override public Expression createExpression(String expression) {     ObjectHelper.notNull(left, "left node", this).     final Expression leftExp = left.createExpression(expression).     if (operator == UnaryOperatorType.INC) {         return createIncExpression(leftExp).     } else if (operator == UnaryOperatorType.DEC) {         return createDecExpression(leftExp).     }     throw new SimpleParserException("Unknown unary operator " + operator, token.getIndex()). }
false;public;2;22;;@Override public <T> T evaluate(Exchange exchange, Class<T> type) {     Number num = leftExp.evaluate(exchange, Number.class).     if (num != null) {         long val = num.longValue().         val++.         // convert value back to same type as input as we want to preserve type         Object left = leftExp.evaluate(exchange, Object.class).         try {             left = exchange.getContext().getTypeConverter().mandatoryConvertTo(left.getClass(), exchange, val).         } catch (NoTypeConversionAvailableException e) {             throw RuntimeCamelException.wrapRuntimeCamelException(e).         }         // and return the result         return exchange.getContext().getTypeConverter().convertTo(type, left).     }     // cannot convert the expression as a number     Exception cause = new CamelExchangeException("Cannot evaluate " + leftExp + " as a number", exchange).     throw RuntimeCamelException.wrapRuntimeCamelException(cause). }
false;public;0;4;;@Override public String toString() {     return left + operator.toString(). }
false;private;1;31;;private Expression createIncExpression(final Expression leftExp) {     return new Expression() {          @Override         public <T> T evaluate(Exchange exchange, Class<T> type) {             Number num = leftExp.evaluate(exchange, Number.class).             if (num != null) {                 long val = num.longValue().                 val++.                 // convert value back to same type as input as we want to preserve type                 Object left = leftExp.evaluate(exchange, Object.class).                 try {                     left = exchange.getContext().getTypeConverter().mandatoryConvertTo(left.getClass(), exchange, val).                 } catch (NoTypeConversionAvailableException e) {                     throw RuntimeCamelException.wrapRuntimeCamelException(e).                 }                 // and return the result                 return exchange.getContext().getTypeConverter().convertTo(type, left).             }             // cannot convert the expression as a number             Exception cause = new CamelExchangeException("Cannot evaluate " + leftExp + " as a number", exchange).             throw RuntimeCamelException.wrapRuntimeCamelException(cause).         }          @Override         public String toString() {             return left + operator.toString().         }     }. }
false;public;2;22;;@Override public <T> T evaluate(Exchange exchange, Class<T> type) {     Number num = leftExp.evaluate(exchange, Number.class).     if (num != null) {         long val = num.longValue().         val--.         // convert value back to same type as input as we want to preserve type         Object left = leftExp.evaluate(exchange, Object.class).         try {             left = exchange.getContext().getTypeConverter().mandatoryConvertTo(left.getClass(), exchange, val).         } catch (NoTypeConversionAvailableException e) {             throw RuntimeCamelException.wrapRuntimeCamelException(e).         }         // and return the result         return exchange.getContext().getTypeConverter().convertTo(type, left).     }     // cannot convert the expression as a number     Exception cause = new CamelExchangeException("Cannot evaluate " + leftExp + " as a number", exchange).     throw RuntimeCamelException.wrapRuntimeCamelException(cause). }
false;public;0;4;;@Override public String toString() {     return left + operator.toString(). }
false;private;1;31;;private Expression createDecExpression(final Expression leftExp) {     return new Expression() {          @Override         public <T> T evaluate(Exchange exchange, Class<T> type) {             Number num = leftExp.evaluate(exchange, Number.class).             if (num != null) {                 long val = num.longValue().                 val--.                 // convert value back to same type as input as we want to preserve type                 Object left = leftExp.evaluate(exchange, Object.class).                 try {                     left = exchange.getContext().getTypeConverter().mandatoryConvertTo(left.getClass(), exchange, val).                 } catch (NoTypeConversionAvailableException e) {                     throw RuntimeCamelException.wrapRuntimeCamelException(e).                 }                 // and return the result                 return exchange.getContext().getTypeConverter().convertTo(type, left).             }             // cannot convert the expression as a number             Exception cause = new CamelExchangeException("Cannot evaluate " + leftExp + " as a number", exchange).             throw RuntimeCamelException.wrapRuntimeCamelException(cause).         }          @Override         public String toString() {             return left + operator.toString().         }     }. }
