commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public void done(boolean doneSync) {     log.trace("Delayed task done for exchangeId: {}", exchange.getExchangeId()).     // we must done the callback from this async callback as well, to ensure callback is done correctly     // must invoke done on callback with false, as that is what the original caller would     // expect as we returned false in the process method     callback.done(false). }
false;public;0;21;;public void run() {     // we are running now so decrement the counter     delayedCount.decrementAndGet().     log.trace("Delayed task woke up and continues routing for exchangeId: {}", exchange.getExchangeId()).     if (!isRunAllowed()) {         exchange.setException(new RejectedExecutionException("Run is not allowed")).     }     // process the exchange now that we woke up     DelayProcessorSupport.this.processor.process(exchange, new AsyncCallback() {          @Override         public void done(boolean doneSync) {             log.trace("Delayed task done for exchangeId: {}", exchange.getExchangeId()).             // we must done the callback from this async callback as well, to ensure callback is done correctly             // must invoke done on callback with false, as that is what the original caller would             // expect as we returned false in the process method             callback.done(false).         }     }). }
false;protected;3;50;;protected boolean processDelay(Exchange exchange, AsyncCallback callback, long delay) {     if (!isAsyncDelayed() || exchange.isTransacted()) {         // use synchronous delay (also required if using transactions)         try {             delay(delay, exchange).             // then continue routing             return processor.process(exchange, callback).         } catch (Exception e) {             // exception occurred so we are done             exchange.setException(e).             callback.done(true).             return true.         }     } else {         // asynchronous delay so schedule a process call task         // and increment the counter (we decrement the counter when we run the ProcessCall)         delayedCount.incrementAndGet().         ProcessCall call = new ProcessCall(exchange, callback).         try {             log.trace("Scheduling delayed task to run in {} millis for exchangeId: {}", delay, exchange.getExchangeId()).             executorService.schedule(call, delay, TimeUnit.MILLISECONDS).             // tell Camel routing engine we continue routing asynchronous             return false.         } catch (RejectedExecutionException e) {             // we were not allowed to run the ProcessCall, so need to decrement the counter here             delayedCount.decrementAndGet().             if (isCallerRunsWhenRejected()) {                 if (!isRunAllowed()) {                     exchange.setException(new RejectedExecutionException()).                 } else {                     log.debug("Scheduling rejected task, so letting caller run, delaying at first for {} millis for exchangeId: {}", delay, exchange.getExchangeId()).                     // let caller run by processing                     try {                         delay(delay, exchange).                     } catch (InterruptedException ie) {                         exchange.setException(ie).                     }                     // then continue routing                     return processor.process(exchange, callback).                 }             } else {                 exchange.setException(e).             }             // caller don't run the task so we are done             callback.done(true).             return true.         }     } }
false;public;2;25;;@Override public boolean process(Exchange exchange, AsyncCallback callback) {     if (!isRunAllowed()) {         exchange.setException(new RejectedExecutionException("Run is not allowed")).         callback.done(true).         return true.     }     // calculate delay and wait     long delay.     try {         delay = calculateDelay(exchange).         if (delay <= 0) {             // no delay then continue routing             log.trace("No delay for exchangeId: {}", exchange.getExchangeId()).             return processor.process(exchange, callback).         }     } catch (Throwable e) {         exchange.setException(e).         callback.done(true).         return true.     }     return processDelay(exchange, callback, delay). }
false;public;0;3;;public boolean isAsyncDelayed() {     return asyncDelayed. }
false;public;1;3;;public void setAsyncDelayed(boolean asyncDelayed) {     this.asyncDelayed = asyncDelayed. }
false;public;0;3;;public boolean isCallerRunsWhenRejected() {     return callerRunsWhenRejected. }
false;public;1;3;;public void setCallerRunsWhenRejected(boolean callerRunsWhenRejected) {     this.callerRunsWhenRejected = callerRunsWhenRejected. }
false;protected,abstract;1;1;;protected abstract long calculateDelay(Exchange exchange).
true;public;0;3;/**  * Gets the current number of {@link Exchange}s being delayed (hold back due throttle limit hit)  */ ;/**  * Gets the current number of {@link Exchange}s being delayed (hold back due throttle limit hit)  */ public int getDelayedCount() {     return delayedCount.get(). }
true;protected;2;20;/**  * Delays the given time before continuing.  * <p/>  * This implementation will block while waiting  *  * @param delay the delay time in millis  * @param exchange the exchange being processed  */ ;/**  * Delays the given time before continuing.  * <p/>  * This implementation will block while waiting  *  * @param delay the delay time in millis  * @param exchange the exchange being processed  */ protected void delay(long delay, Exchange exchange) throws InterruptedException {     // only run is we are started     if (!isRunAllowed()) {         return.     }     if (delay < 0) {         return.     } else {         try {             // keep track on delayer counter while we sleep             delayedCount.incrementAndGet().             sleep(delay).         } catch (InterruptedException e) {             handleSleepInterruptedException(e, exchange).         } finally {             delayedCount.decrementAndGet().         }     } }
true;protected;2;7;/**  * Called when a sleep is interrupted. allows derived classes to handle this case differently  */ ;/**  * Called when a sleep is interrupted. allows derived classes to handle this case differently  */ protected void handleSleepInterruptedException(InterruptedException e, Exchange exchange) throws InterruptedException {     if (log.isDebugEnabled()) {         log.debug("Sleep interrupted, are we stopping? {}", isStopping() || isStopped()).     }     Thread.currentThread().interrupt().     throw e. }
false;protected;0;3;;protected long currentSystemTime() {     return System.currentTimeMillis(). }
false;private;1;7;;private void sleep(long delay) throws InterruptedException {     if (delay <= 0) {         return.     }     log.trace("Sleeping for: {} millis", delay).     Thread.sleep(delay). }
false;protected;0;9;;@Override protected void doStart() throws Exception {     if (isAsyncDelayed()) {         ObjectHelper.notNull(executorService, "executorService", this).     } else if (executorService != null) {         asyncDelayed = true.     }     super.doStart(). }
false;protected;0;7;;@Override protected void doShutdown() throws Exception {     if (shutdownExecutorService && executorService != null) {         camelContext.getExecutorServiceManager().shutdownNow(executorService).     }     super.doShutdown(). }
false;public;1;4;;@Override public boolean deferShutdown(ShutdownRunningTask shutdownRunningTask) {     return true. }
false;public;0;4;;@Override public int getPendingExchangesSize() {     return getDelayedCount(). }
false;public;2;4;;@Override public void prepareShutdown(boolean suspendOnly, boolean forced) { }
