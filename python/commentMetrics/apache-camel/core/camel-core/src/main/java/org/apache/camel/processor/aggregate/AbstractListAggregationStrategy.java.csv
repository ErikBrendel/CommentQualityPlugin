commented;modifiers;parameterAmount;loc;comment;code
true;public,abstract;1;1;/**  * This method is implemented by the sub-class and is called to retrieve  * an instance of the value that will be aggregated and forwarded to the  * receiving end point.  * <p/>  * If <tt>null</tt> is returned, then the value is <b>not</b> added to the {@link List}.  *  * @param exchange  The exchange that is used to retrieve the value from  * @return An instance of V that is the associated value of the passed exchange  */ ;/**  * This method is implemented by the sub-class and is called to retrieve  * an instance of the value that will be aggregated and forwarded to the  * receiving end point.  * <p/>  * If <tt>null</tt> is returned, then the value is <b>not</b> added to the {@link List}.  *  * @param exchange  The exchange that is used to retrieve the value from  * @return An instance of V that is the associated value of the passed exchange  */ public abstract V getValue(Exchange exchange).
true;public;0;3;/**  * Whether to store the completed aggregated {@link List} as message body, or to keep as property on the exchange.  * <p/>  * The default behavior is <tt>true</tt> to store as message body.  *  * @return <tt>true</tt> to store as message body, <tt>false</tt> to keep as property on the exchange.  */ ;/**  * Whether to store the completed aggregated {@link List} as message body, or to keep as property on the exchange.  * <p/>  * The default behavior is <tt>true</tt> to store as message body.  *  * @return <tt>true</tt> to store as message body, <tt>false</tt> to keep as property on the exchange.  */ public boolean isStoreAsBodyOnCompletion() {     return true. }
false;public;1;9;;@SuppressWarnings("unchecked") public void onCompletion(Exchange exchange) {     if (exchange != null && isStoreAsBodyOnCompletion()) {         List<V> list = (List<V>) exchange.removeProperty(Exchange.GROUPED_EXCHANGE).         if (list != null) {             exchange.getIn().setBody(list).         }     } }
true;public;2;18;/**  * This method will aggregate the old and new exchange and return the result.  *  * @param oldExchange The oldest exchange, can be null  * @param newExchange The newest exchange, can be null  * @return a composite exchange of the old and/or new exchanges  */ ;/**  * This method will aggregate the old and new exchange and return the result.  *  * @param oldExchange The oldest exchange, can be null  * @param newExchange The newest exchange, can be null  * @return a composite exchange of the old and/or new exchanges  */ public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {     List<V> list.     if (oldExchange == null) {         list = getList(newExchange).     } else {         list = getList(oldExchange).     }     if (newExchange != null) {         V value = getValue(newExchange).         if (value != null) {             list.add(value).         }     }     return oldExchange != null ? oldExchange : newExchange. }
false;private;1;9;;@SuppressWarnings("unchecked") private List<V> getList(Exchange exchange) {     List<V> list = exchange.getProperty(Exchange.GROUPED_EXCHANGE, List.class).     if (list == null) {         list = new GroupedExchangeList<>().         exchange.setProperty(Exchange.GROUPED_EXCHANGE, list).     }     return list. }
false;public;0;5;;@Override public String toString() {     // lets override toString so we don't write data for all the Exchanges by default     return "List<Exchange>(" + size() + " elements)". }
