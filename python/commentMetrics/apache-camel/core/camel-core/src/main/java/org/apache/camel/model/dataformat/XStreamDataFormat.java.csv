commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getEncoding() {     return encoding. }
true;public;1;3;/**  * Sets the encoding to use  */ ;/**  * Sets the encoding to use  */ public void setEncoding(String encoding) {     this.encoding = encoding. }
false;public;0;3;;public String getDriver() {     return driver. }
true;public;1;3;/**  * To use a custom XStream driver.  * The instance must be of type com.thoughtworks.xstream.io.HierarchicalStreamDriver  */ ;/**  * To use a custom XStream driver.  * The instance must be of type com.thoughtworks.xstream.io.HierarchicalStreamDriver  */ public void setDriver(String driver) {     this.driver = driver. }
false;public;0;3;;public String getDriverRef() {     return driverRef. }
true;public;1;3;/**  * To refer to a custom XStream driver to lookup in the registry.  * The instance must be of type com.thoughtworks.xstream.io.HierarchicalStreamDriver  */ ;/**  * To refer to a custom XStream driver to lookup in the registry.  * The instance must be of type com.thoughtworks.xstream.io.HierarchicalStreamDriver  */ public void setDriverRef(String driverRef) {     this.driverRef = driverRef. }
false;public;0;3;;public String getMode() {     return mode. }
true;public;1;3;/**  * Mode for dealing with duplicate references The possible values are:  * <ul>  *     <li>NO_REFERENCES</li>  *     <li>ID_REFERENCES</li>  *     <li>XPATH_RELATIVE_REFERENCES</li>  *     <li>XPATH_ABSOLUTE_REFERENCES</li>  *     <li>SINGLE_NODE_XPATH_RELATIVE_REFERENCES</li>  *     <li>SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES</li>  * </ul>  */ ;/**  * Mode for dealing with duplicate references The possible values are:  * <ul>  *     <li>NO_REFERENCES</li>  *     <li>ID_REFERENCES</li>  *     <li>XPATH_RELATIVE_REFERENCES</li>  *     <li>XPATH_ABSOLUTE_REFERENCES</li>  *     <li>SINGLE_NODE_XPATH_RELATIVE_REFERENCES</li>  *     <li>SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES</li>  * </ul>  */ public void setMode(String mode) {     this.mode = mode. }
false;public;0;3;;public List<String> getConverters() {     return converters. }
true;public;1;3;/**  * List of class names for using custom XStream converters.  * The classes must be of type com.thoughtworks.xstream.converters.Converter  */ ;/**  * List of class names for using custom XStream converters.  * The classes must be of type com.thoughtworks.xstream.converters.Converter  */ public void setConverters(List<String> converters) {     this.converters = converters. }
false;public;0;3;;public Map<String, String> getAliases() {     return aliases. }
true;public;1;3;/**  * Alias a Class to a shorter name to be used in XML elements.  */ ;/**  * Alias a Class to a shorter name to be used in XML elements.  */ public void setAliases(Map<String, String> aliases) {     this.aliases = aliases. }
false;public;0;3;;public Map<String, String[]> getOmitFields() {     return omitFields. }
true;public;1;3;/**  * Prevents a field from being serialized. To omit a field you must always provide the  * declaring type and not necessarily the type that is converted.  */ ;/**  * Prevents a field from being serialized. To omit a field you must always provide the  * declaring type and not necessarily the type that is converted.  */ public void setOmitFields(Map<String, String[]> omitFields) {     this.omitFields = omitFields. }
false;public;0;3;;public Map<String, String[]> getImplicitCollections() {     return implicitCollections. }
true;public;1;3;/**  * Adds a default implicit collection which is used for any unmapped XML tag.  */ ;/**  * Adds a default implicit collection which is used for any unmapped XML tag.  */ public void setImplicitCollections(Map<String, String[]> implicitCollections) {     this.implicitCollections = implicitCollections. }
false;public;0;3;;public String getPermissions() {     return permissions. }
true;public;1;3;/**  * Adds permissions that controls which Java packages and classes XStream is allowed to use during  * unmarshal from xml/json to Java beans.  * <p/>  * A permission must be configured either here or globally using a JVM system property. The permission  * can be specified in a syntax where a plus sign is allow, and minus sign is deny.  * <br/>  * Wildcards is supported by using <tt>.*</tt> as prefix. For example to allow <tt>com.foo</tt> and all subpackages  * then specfy <tt>+com.foo.*</tt>. Multiple permissions can be configured separated by comma, such as  * <tt>+com.foo.*,-com.foo.bar.MySecretBean</tt>.  * <br/>  * The following default permission is always included: <tt>"-*,java.lang.*,java.util.*"</tt> unless  * its overridden by specifying a JVM system property with they key <tt>org.apache.camel.xstream.permissions</tt>.  */ ;/**  * Adds permissions that controls which Java packages and classes XStream is allowed to use during  * unmarshal from xml/json to Java beans.  * <p/>  * A permission must be configured either here or globally using a JVM system property. The permission  * can be specified in a syntax where a plus sign is allow, and minus sign is deny.  * <br/>  * Wildcards is supported by using <tt>.*</tt> as prefix. For example to allow <tt>com.foo</tt> and all subpackages  * then specfy <tt>+com.foo.*</tt>. Multiple permissions can be configured separated by comma, such as  * <tt>+com.foo.*,-com.foo.bar.MySecretBean</tt>.  * <br/>  * The following default permission is always included: <tt>"-*,java.lang.*,java.util.*"</tt> unless  * its overridden by specifying a JVM system property with they key <tt>org.apache.camel.xstream.permissions</tt>.  */ public void setPermissions(String permissions) {     this.permissions = permissions. }
true;public;1;8;/**  * To add permission for the given pojo classes.  * @param type the pojo class(es) xstream should use as allowed permission  * @see #setPermissions(String)  */ ;/**  * To add permission for the given pojo classes.  * @param type the pojo class(es) xstream should use as allowed permission  * @see #setPermissions(String)  */ public void setPermissions(Class<?>... type) {     CollectionStringBuffer csb = new CollectionStringBuffer(",").     for (Class<?> clazz : type) {         csb.append("+").         csb.append(clazz.getName()).     }     setPermissions(csb.toString()). }
false;protected;1;12;;@Override protected DataFormat createDataFormat(RouteContext routeContext) {     if ("json".equals(this.driver)) {         setProperty(routeContext.getCamelContext(), this, "dataFormatName", "json-xstream").     }     DataFormat answer = super.createDataFormat(routeContext).     // need to lookup the reference for the xstreamDriver     if (ObjectHelper.isNotEmpty(driverRef)) {         setProperty(routeContext.getCamelContext(), answer, "xstreamDriver", CamelContextHelper.mandatoryLookup(routeContext.getCamelContext(), driverRef)).     }     return answer. }
false;protected;2;24;;@Override protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {     if (this.permissions != null) {         setProperty(camelContext, dataFormat, "permissions", this.permissions).     }     if (encoding != null) {         setProperty(camelContext, dataFormat, "encoding", encoding).     }     if (this.converters != null) {         setProperty(camelContext, dataFormat, "converters", this.converters).     }     if (this.aliases != null) {         setProperty(camelContext, dataFormat, "aliases", this.aliases).     }     if (this.omitFields != null) {         setProperty(camelContext, dataFormat, "omitFields", this.omitFields).     }     if (this.implicitCollections != null) {         setProperty(camelContext, dataFormat, "implicitCollections", this.implicitCollections).     }     if (this.mode != null) {         setProperty(camelContext, dataFormat, "mode", mode).     } }
false;public;1;16;;@Override public ConverterList marshal(List<String> v) throws Exception {     if (v == null) {         return null.     }     List<ConverterEntry> list = new ArrayList<>().     for (String str : v) {         ConverterEntry entry = new ConverterEntry().         entry.setClsName(str).         list.add(entry).     }     ConverterList converterList = new ConverterList().     converterList.setList(list).     return converterList. }
false;public;1;12;;@Override public List<String> unmarshal(ConverterList v) throws Exception {     if (v == null) {         return null.     }     List<String> list = new ArrayList<>().     for (ConverterEntry entry : v.getList()) {         list.add(entry.getClsName()).     }     return list. }
false;public;0;3;;public List<ConverterEntry> getList() {     return list. }
false;public;1;3;;public void setList(List<ConverterEntry> list) {     this.list = list. }
false;public;0;3;;public String getClsName() {     return clsName. }
false;public;1;3;;public void setClsName(String clsName) {     this.clsName = clsName. }
false;public;1;17;;@Override public ImplicitCollectionList marshal(Map<String, String[]> v) throws Exception {     if (v == null || v.isEmpty()) {         return null.     }     List<ImplicitCollectionEntry> list = new ArrayList<>().     for (Entry<String, String[]> e : v.entrySet()) {         ImplicitCollectionEntry entry = new ImplicitCollectionEntry(e.getKey(), e.getValue()).         list.add(entry).     }     ImplicitCollectionList collectionList = new ImplicitCollectionList().     collectionList.setList(list).     return collectionList. }
false;public;1;12;;@Override public Map<String, String[]> unmarshal(ImplicitCollectionList v) throws Exception {     if (v == null) {         return null.     }     Map<String, String[]> map = new HashMap<>().     for (ImplicitCollectionEntry entry : v.getList()) {         map.put(entry.getClsName(), entry.getFields()).     }     return map. }
false;public;0;3;;public List<ImplicitCollectionEntry> getList() {     return list. }
false;public;1;3;;public void setList(List<ImplicitCollectionEntry> list) {     this.list = list. }
false;public;0;3;;public String getClsName() {     return clsName. }
false;public;1;3;;public void setClsName(String clsName) {     this.clsName = clsName. }
false;public;0;3;;public String[] getFields() {     return fields. }
false;public;1;3;;public void setFields(String[] fields) {     this.fields = fields. }
false;public;0;4;;@Override public String toString() {     return "Alias[ImplicitCollection=" + clsName + ", fields=" + Arrays.asList(this.fields) + "]". }
false;public;1;14;;@Override public AliasList marshal(Map<String, String> value) throws Exception {     if (value == null || value.isEmpty()) {         return null.     }     List<AliasEntry> ret = new ArrayList<>(value.size()).     for (Map.Entry<String, String> entry : value.entrySet()) {         ret.add(new AliasEntry(entry.getKey(), entry.getValue())).     }     AliasList jaxbMap = new AliasList().     jaxbMap.setList(ret).     return jaxbMap. }
false;public;1;12;;@Override public Map<String, String> unmarshal(AliasList value) throws Exception {     if (value == null || value.getList() == null || value.getList().isEmpty()) {         return null.     }     Map<String, String> answer = new HashMap<>().     for (AliasEntry alias : value.getList()) {         answer.put(alias.getName(), alias.getClsName()).     }     return answer. }
false;public;0;3;;public List<AliasEntry> getList() {     return list. }
false;public;1;3;;public void setList(List<AliasEntry> list) {     this.list = list. }
false;public;0;3;;public String getName() {     return name. }
false;public;1;3;;public void setName(String name) {     this.name = name. }
false;public;0;3;;public String getClsName() {     return clsName. }
false;public;1;3;;public void setClsName(String clsName) {     this.clsName = clsName. }
false;public;0;4;;@Override public String toString() {     return "Alias[name=" + name + ", class=" + clsName + "]". }
false;public;1;17;;@Override public OmitFieldList marshal(Map<String, String[]> v) throws Exception {     if (v == null || v.isEmpty()) {         return null.     }     List<OmitFieldEntry> list = new ArrayList<>().     for (Entry<String, String[]> e : v.entrySet()) {         OmitFieldEntry entry = new OmitFieldEntry(e.getKey(), e.getValue()).         list.add(entry).     }     OmitFieldList collectionList = new OmitFieldList().     collectionList.setList(list).     return collectionList. }
false;public;1;12;;@Override public Map<String, String[]> unmarshal(OmitFieldList v) throws Exception {     if (v == null || v.getList() == null || v.getList().isEmpty()) {         return null.     }     Map<String, String[]> map = new HashMap<>().     for (OmitFieldEntry entry : v.getList()) {         map.put(entry.getClsName(), entry.getFields()).     }     return map. }
false;public;0;3;;public List<OmitFieldEntry> getList() {     return list. }
false;public;1;3;;public void setList(List<OmitFieldEntry> list) {     this.list = list. }
false;public;0;3;;public String getClsName() {     return clsName. }
false;public;1;3;;public void setClsName(String clsName) {     this.clsName = clsName. }
false;public;0;3;;public String[] getFields() {     return fields. }
false;public;1;3;;public void setFields(String[] fields) {     this.fields = fields. }
false;public;0;4;;@Override public String toString() {     return "OmitField[" + clsName + ", fields=" + Arrays.asList(this.fields) + "]". }
