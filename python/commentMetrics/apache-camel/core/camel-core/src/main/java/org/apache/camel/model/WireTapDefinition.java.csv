commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;public boolean isDynamic() {     // its dynamic by default     return dynamicUri == null || dynamicUri. }
false;public;0;3;;public ExchangePattern getPattern() {     return ExchangePattern.InOnly. }
false;public;0;4;;@Override public String toString() {     return "WireTap[" + getUri() + "]". }
false;public;0;4;;@Override public String getShortName() {     return "wireTap". }
false;public;0;4;;@Override public String getLabel() {     return "wireTap[" + getUri() + "]". }
false;public;0;6;;@Override @SuppressWarnings("unchecked") public Type end() {     // allow end() to return to previous type so you can continue in the DSL     return (Type) super.end(). }
false;public;1;5;;@Override public void addOutput(ProcessorDefinition<?> output) {     // add outputs on parent as this wiretap does not support outputs     getParent().addOutput(output). }
true;public;1;4;/**  * Uses a custom thread pool  *  * @param executorService a custom {@link ExecutorService} to use as thread pool  *                        for sending tapped exchanges  * @return the builder  */ ;// Fluent API // ------------------------------------------------------------------------- /**  * Uses a custom thread pool  *  * @param executorService a custom {@link ExecutorService} to use as thread pool  *                        for sending tapped exchanges  * @return the builder  */ public WireTapDefinition<Type> executorService(ExecutorService executorService) {     setExecutorService(executorService).     return this. }
true;public;1;4;/**  * Uses a custom thread pool  *  * @param executorServiceRef reference to lookup a custom {@link ExecutorService}  *                           to use as thread pool for sending tapped exchanges  * @return the builder  */ ;/**  * Uses a custom thread pool  *  * @param executorServiceRef reference to lookup a custom {@link ExecutorService}  *                           to use as thread pool for sending tapped exchanges  * @return the builder  */ public WireTapDefinition<Type> executorServiceRef(String executorServiceRef) {     setExecutorServiceRef(executorServiceRef).     return this. }
true;public;0;4;/**  * Uses a copy of the original exchange  *  * @return the builder  */ ;/**  * Uses a copy of the original exchange  *  * @return the builder  */ public WireTapDefinition<Type> copy() {     setCopy(true).     return this. }
true;public;1;4;/**  * Uses a copy of the original exchange  *  * @param copy if it is true camel will copy the original exchange,  *             if it is false camel will not copy the original exchange  * @return the builder  */ ;/**  * Uses a copy of the original exchange  *  * @param copy if it is true camel will copy the original exchange,  *             if it is false camel will not copy the original exchange  * @return the builder  */ public WireTapDefinition<Type> copy(boolean copy) {     setCopy(copy).     return this. }
true;public;1;4;/**  * Whether the uri is dynamic or static.  * If the uri is dynamic then the simple language is used to evaluate a dynamic uri to use as the wire-tap destination,  * for each incoming message. This works similar to how the <tt>toD</tt> EIP pattern works.  * If static then the uri is used as-is as the wire-tap destination.  *  * @param dynamicUri  whether to use dynamic or static uris  * @return the builder  */ ;/**  * Whether the uri is dynamic or static.  * If the uri is dynamic then the simple language is used to evaluate a dynamic uri to use as the wire-tap destination,  * for each incoming message. This works similar to how the <tt>toD</tt> EIP pattern works.  * If static then the uri is used as-is as the wire-tap destination.  *  * @param dynamicUri  whether to use dynamic or static uris  * @return the builder  */ public WireTapDefinition<Type> dynamicUri(boolean dynamicUri) {     setDynamicUri(dynamicUri).     return this. }
true;public;1;4;/**  * Sends a <i>new</i> Exchange, instead of tapping an existing, using {@link ExchangePattern#InOnly}  *  * @param expression expression that creates the new body to send  * @return the builder  * @see #newExchangeHeader(String, org.apache.camel.Expression)  */ ;/**  * Sends a <i>new</i> Exchange, instead of tapping an existing, using {@link ExchangePattern#InOnly}  *  * @param expression expression that creates the new body to send  * @return the builder  * @see #newExchangeHeader(String, org.apache.camel.Expression)  */ public WireTapDefinition<Type> newExchangeBody(Expression expression) {     setNewExchangeExpression(new ExpressionSubElementDefinition(expression)).     return this. }
true;public;1;4;/**  * Sends a <i>new</i> Exchange, instead of tapping an existing, using {@link ExchangePattern#InOnly}  *  * @param ref reference to the {@link Processor} to lookup in the {@link org.apache.camel.spi.Registry} to  *            be used for preparing the new exchange to send  * @return the builder  */ ;/**  * Sends a <i>new</i> Exchange, instead of tapping an existing, using {@link ExchangePattern#InOnly}  *  * @param ref reference to the {@link Processor} to lookup in the {@link org.apache.camel.spi.Registry} to  *            be used for preparing the new exchange to send  * @return the builder  */ public WireTapDefinition<Type> newExchangeRef(String ref) {     setNewExchangeProcessorRef(ref).     return this. }
true;public;1;4;/**  * Sends a <i>new</i> Exchange, instead of tapping an existing, using {@link ExchangePattern#InOnly}  *  * @param processor  processor preparing the new exchange to send  * @return the builder  * @see #newExchangeHeader(String, org.apache.camel.Expression)  */ ;/**  * Sends a <i>new</i> Exchange, instead of tapping an existing, using {@link ExchangePattern#InOnly}  *  * @param processor  processor preparing the new exchange to send  * @return the builder  * @see #newExchangeHeader(String, org.apache.camel.Expression)  */ public WireTapDefinition<Type> newExchange(Processor processor) {     setNewExchangeProcessor(processor).     return this. }
true;public;2;4;/**  * Sets a header on the <i>new</i> Exchange, instead of tapping an existing, using {@link ExchangePattern#InOnly}.  * <p/>  * Use this together with the {@link #newExchangeBody(org.apache.camel.Expression)} or {@link #newExchange(org.apache.camel.Processor)}  * methods.  *  * @param headerName  the header name  * @param expression  the expression setting the header value  * @return the builder  */ ;/**  * Sets a header on the <i>new</i> Exchange, instead of tapping an existing, using {@link ExchangePattern#InOnly}.  * <p/>  * Use this together with the {@link #newExchangeBody(org.apache.camel.Expression)} or {@link #newExchange(org.apache.camel.Processor)}  * methods.  *  * @param headerName  the header name  * @param expression  the expression setting the header value  * @return the builder  */ public WireTapDefinition<Type> newExchangeHeader(String headerName, Expression expression) {     headers.add(new SetHeaderDefinition(headerName, expression)).     return this. }
true;public;1;4;/**  * Uses the {@link Processor} when preparing the {@link org.apache.camel.Exchange} to be send.  * This can be used to deep-clone messages that should be send, or any custom logic needed before  * the exchange is send.  *  * @param onPrepare the processor  * @return the builder  */ ;/**  * Uses the {@link Processor} when preparing the {@link org.apache.camel.Exchange} to be send.  * This can be used to deep-clone messages that should be send, or any custom logic needed before  * the exchange is send.  *  * @param onPrepare the processor  * @return the builder  */ public WireTapDefinition<Type> onPrepare(Processor onPrepare) {     setOnPrepare(onPrepare).     return this. }
true;public;1;4;/**  * Uses the {@link Processor} when preparing the {@link org.apache.camel.Exchange} to be send.  * This can be used to deep-clone messages that should be send, or any custom logic needed before  * the exchange is send.  *  * @param onPrepareRef reference to the processor to lookup in the {@link org.apache.camel.spi.Registry}  * @return the builder  */ ;/**  * Uses the {@link Processor} when preparing the {@link org.apache.camel.Exchange} to be send.  * This can be used to deep-clone messages that should be send, or any custom logic needed before  * the exchange is send.  *  * @param onPrepareRef reference to the processor to lookup in the {@link org.apache.camel.spi.Registry}  * @return the builder  */ public WireTapDefinition<Type> onPrepareRef(String onPrepareRef) {     setOnPrepareRef(onPrepareRef).     return this. }
true;public;1;5;/**  * Sets the maximum size used by the {@link org.apache.camel.spi.ProducerCache} which is used  * to cache and reuse producers, when uris are reused.  *  * @param cacheSize  the cache size, use <tt>0</tt> for default cache size, or <tt>-1</tt> to turn cache off.  * @return the builder  */ ;/**  * Sets the maximum size used by the {@link org.apache.camel.spi.ProducerCache} which is used  * to cache and reuse producers, when uris are reused.  *  * @param cacheSize  the cache size, use <tt>0</tt> for default cache size, or <tt>-1</tt> to turn cache off.  * @return the builder  */ @Override public WireTapDefinition<Type> cacheSize(int cacheSize) {     setCacheSize(cacheSize).     return this. }
true;public;0;5;/**  * Ignore the invalidate endpoint exception when try to create a producer with that endpoint  *  * @return the builder  */ ;/**  * Ignore the invalidate endpoint exception when try to create a producer with that endpoint  *  * @return the builder  */ @Override public WireTapDefinition<Type> ignoreInvalidEndpoint() {     setIgnoreInvalidEndpoint(true).     return this. }
false;public;0;4;;// Properties // ------------------------------------------------------------------------- @Override public String getUri() {     return super.getUri(). }
true;public;1;4;/**  * The uri of the endpoint to wiretap to. The uri can be dynamic computed using the {@link org.apache.camel.language.simple.SimpleLanguage} expression.  */ ;/**  * The uri of the endpoint to wiretap to. The uri can be dynamic computed using the {@link org.apache.camel.language.simple.SimpleLanguage} expression.  */ @Override public void setUri(String uri) {     super.setUri(uri). }
false;public;0;3;;public Processor getNewExchangeProcessor() {     return newExchangeProcessor. }
true;public;1;3;/**  * To use a Processor for creating a new body as the message to use for wire tapping  */ ;/**  * To use a Processor for creating a new body as the message to use for wire tapping  */ public void setNewExchangeProcessor(Processor processor) {     this.newExchangeProcessor = processor. }
false;public;0;3;;public String getNewExchangeProcessorRef() {     return newExchangeProcessorRef. }
true;public;1;3;/**  * Reference to a Processor to use for creating a new body as the message to use for wire tapping  */ ;/**  * Reference to a Processor to use for creating a new body as the message to use for wire tapping  */ public void setNewExchangeProcessorRef(String ref) {     this.newExchangeProcessorRef = ref. }
false;public;0;3;;public ExpressionSubElementDefinition getNewExchangeExpression() {     return newExchangeExpression. }
true;public;1;3;/**  * Uses the expression for creating a new body as the message to use for wire tapping  */ ;/**  * Uses the expression for creating a new body as the message to use for wire tapping  */ public void setNewExchangeExpression(ExpressionSubElementDefinition newExchangeExpression) {     this.newExchangeExpression = newExchangeExpression. }
false;public;0;3;;public ExecutorService getExecutorService() {     return executorService. }
false;public;1;3;;public void setExecutorService(ExecutorService executorService) {     this.executorService = executorService. }
false;public;0;3;;public String getExecutorServiceRef() {     return executorServiceRef. }
false;public;1;3;;public void setExecutorServiceRef(String executorServiceRef) {     this.executorServiceRef = executorServiceRef. }
false;public;0;3;;public Boolean getCopy() {     return copy. }
false;public;1;3;;public void setCopy(Boolean copy) {     this.copy = copy. }
false;public;0;3;;public Boolean getDynamicUri() {     return dynamicUri. }
false;public;1;3;;public void setDynamicUri(Boolean dynamicUri) {     this.dynamicUri = dynamicUri. }
false;public;0;3;;public String getOnPrepareRef() {     return onPrepareRef. }
false;public;1;3;;public void setOnPrepareRef(String onPrepareRef) {     this.onPrepareRef = onPrepareRef. }
false;public;0;3;;public Processor getOnPrepare() {     return onPrepare. }
false;public;1;3;;public void setOnPrepare(Processor onPrepare) {     this.onPrepare = onPrepare. }
false;public;0;3;;public List<SetHeaderDefinition> getHeaders() {     return headers. }
false;public;1;3;;public void setHeaders(List<SetHeaderDefinition> headers) {     this.headers = headers. }
