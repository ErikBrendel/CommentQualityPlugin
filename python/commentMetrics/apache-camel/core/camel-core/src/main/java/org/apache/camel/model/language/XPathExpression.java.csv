commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getLanguage() {     return "xpath". }
false;public;0;3;;public Class<?> getDocumentType() {     return documentType. }
true;public;1;3;/**  * Class for document type to use  * <p/>  * The default value is org.w3c.dom.Document  */ ;/**  * Class for document type to use  * <p/>  * The default value is org.w3c.dom.Document  */ public void setDocumentType(Class<?> documentType) {     this.documentType = documentType. }
false;public;0;3;;public String getDocumentTypeName() {     return documentTypeName. }
true;public;1;3;/**  * Name of class for document type  * <p/>  * The default value is org.w3c.dom.Document  */ ;/**  * Name of class for document type  * <p/>  * The default value is org.w3c.dom.Document  */ public void setDocumentTypeName(String documentTypeName) {     this.documentTypeName = documentTypeName. }
false;public;0;3;;public Class<?> getResultType() {     return resultType. }
true;public;1;3;/**  * Sets the class of the result type (type from output).  * <p/>  * The default result type is NodeSet  */ ;/**  * Sets the class of the result type (type from output).  * <p/>  * The default result type is NodeSet  */ public void setResultType(Class<?> resultType) {     this.resultType = resultType. }
false;public;0;3;;public String getResultTypeName() {     return resultTypeName. }
true;public;1;3;/**  * Sets the class name of the result type (type from output)  * <p/>  * The default result type is NodeSet  */ ;/**  * Sets the class name of the result type (type from output)  * <p/>  * The default result type is NodeSet  */ public void setResultTypeName(String resultTypeName) {     this.resultTypeName = resultTypeName. }
true;public;1;3;/**  * Whether to use Saxon.  */ ;/**  * Whether to use Saxon.  */ public void setSaxon(Boolean saxon) {     this.saxon = saxon. }
false;public;0;3;;public Boolean getSaxon() {     return saxon. }
true;public;1;3;/**  * References to a custom XPathFactory to lookup in the registry  */ ;/**  * References to a custom XPathFactory to lookup in the registry  */ public void setFactoryRef(String factoryRef) {     this.factoryRef = factoryRef. }
false;public;0;3;;public String getFactoryRef() {     return factoryRef. }
true;public;1;3;/**  * The XPath object model to use  */ ;/**  * The XPath object model to use  */ public void setObjectModel(String objectModel) {     this.objectModel = objectModel. }
false;public;0;3;;public String getObjectModel() {     return objectModel. }
true;public;1;3;/**  * Whether to log namespaces which can assist during trouble shooting  */ ;/**  * Whether to log namespaces which can assist during trouble shooting  */ public void setLogNamespaces(Boolean logNamespaces) {     this.logNamespaces = logNamespaces. }
false;public;0;3;;public Boolean getLogNamespaces() {     return logNamespaces. }
false;public;0;3;;public String getHeaderName() {     return headerName. }
true;public;1;3;/**  * Name of header to use as input, instead of the message body  */ ;/**  * Name of header to use as input, instead of the message body  */ public void setHeaderName(String headerName) {     this.headerName = headerName. }
false;public;0;3;;public Boolean getThreadSafety() {     return threadSafety. }
true;public;1;3;/**  * Whether to enable thread-safety for the returned result of the xpath expression.  * This applies to when using NODESET as the result type, and the returned set has  * multiple elements. In this situation there can be thread-safety issues if you  * process the NODESET concurrently such as from a Camel Splitter EIP in parallel processing mode.  * This option prevents concurrency issues by doing defensive copies of the nodes.  * <p/>  * It is recommended to turn this option on if you are using camel-saxon or Saxon in your application.  * Saxon has thread-safety issues which can be prevented by turning this option on.  */ ;/**  * Whether to enable thread-safety for the returned result of the xpath expression.  * This applies to when using NODESET as the result type, and the returned set has  * multiple elements. In this situation there can be thread-safety issues if you  * process the NODESET concurrently such as from a Camel Splitter EIP in parallel processing mode.  * This option prevents concurrency issues by doing defensive copies of the nodes.  * <p/>  * It is recommended to turn this option on if you are using camel-saxon or Saxon in your application.  * Saxon has thread-safety issues which can be prevented by turning this option on.  */ public void setThreadSafety(Boolean threadSafety) {     this.threadSafety = threadSafety. }
false;public;1;19;;@Override public Expression createExpression(CamelContext camelContext) {     if (documentType == null && documentTypeName != null) {         try {             documentType = camelContext.getClassResolver().resolveMandatoryClass(documentTypeName).         } catch (ClassNotFoundException e) {             throw RuntimeCamelException.wrapRuntimeCamelException(e).         }     }     if (resultType == null && resultTypeName != null) {         try {             resultType = camelContext.getClassResolver().resolveMandatoryClass(resultTypeName).         } catch (ClassNotFoundException e) {             throw RuntimeCamelException.wrapRuntimeCamelException(e).         }     }     resolveXPathFactory(camelContext).     return super.createExpression(camelContext). }
false;public;1;12;;@Override public Predicate createPredicate(CamelContext camelContext) {     if (documentType == null && documentTypeName != null) {         try {             documentType = camelContext.getClassResolver().resolveMandatoryClass(documentTypeName).         } catch (ClassNotFoundException e) {             throw RuntimeCamelException.wrapRuntimeCamelException(e).         }     }     resolveXPathFactory(camelContext).     return super.createPredicate(camelContext). }
false;protected;2;32;;@Override protected void configureExpression(CamelContext camelContext, Expression expression) {     boolean isSaxon = getSaxon() != null && getSaxon().     boolean isLogNamespaces = getLogNamespaces() != null && getLogNamespaces().     if (documentType != null) {         setProperty(expression, "documentType", documentType).     }     if (resultType != null) {         setProperty(expression, "resultType", resultType).     }     if (isSaxon) {         ObjectHelper.cast(XPathBuilder.class, expression).enableSaxon().     }     if (xpathFactory != null) {         setProperty(expression, "xPathFactory", xpathFactory).     }     if (objectModel != null) {         setProperty(expression, "objectModelUri", objectModel).     }     if (threadSafety != null) {         setProperty(expression, "threadSafety", threadSafety).     }     if (isLogNamespaces) {         ObjectHelper.cast(XPathBuilder.class, expression).setLogNamespaces(true).     }     if (ObjectHelper.isNotEmpty(getHeaderName())) {         ObjectHelper.cast(XPathBuilder.class, expression).setHeaderName(getHeaderName()).     }     // moved the super configuration to the bottom so that the namespace init picks up the newly set XPath Factory     super.configureExpression(camelContext, expression). }
false;protected;2;32;;@Override protected void configurePredicate(CamelContext camelContext, Predicate predicate) {     boolean isSaxon = getSaxon() != null && getSaxon().     boolean isLogNamespaces = getLogNamespaces() != null && getLogNamespaces().     if (documentType != null) {         setProperty(predicate, "documentType", documentType).     }     if (resultType != null) {         setProperty(predicate, "resultType", resultType).     }     if (isSaxon) {         ObjectHelper.cast(XPathBuilder.class, predicate).enableSaxon().     }     if (xpathFactory != null) {         setProperty(predicate, "xPathFactory", xpathFactory).     }     if (objectModel != null) {         setProperty(predicate, "objectModelUri", objectModel).     }     if (threadSafety != null) {         setProperty(predicate, "threadSafety", threadSafety).     }     if (isLogNamespaces) {         ObjectHelper.cast(XPathBuilder.class, predicate).setLogNamespaces(true).     }     if (ObjectHelper.isNotEmpty(getHeaderName())) {         ObjectHelper.cast(XPathBuilder.class, predicate).setHeaderName(getHeaderName()).     }     // moved the super configuration to the bottom so that the namespace init picks up the newly set XPath Factory     super.configurePredicate(camelContext, predicate). }
false;private;1;15;;private void resolveXPathFactory(CamelContext camelContext) {     // setting the appropriate Object Model, it is not wise to allow this in XML because the order of invocation of the setters by JAXB may cause undeterministic behaviour     if ((ObjectHelper.isNotEmpty(factoryRef) || ObjectHelper.isNotEmpty(objectModel)) && (saxon != null)) {         throw new IllegalArgumentException("The saxon attribute cannot be set on the xpath element if any of the following is also set: factory, objectModel" + this).     }     // Validate the factory class     if (ObjectHelper.isNotEmpty(factoryRef)) {         xpathFactory = camelContext.getRegistry().lookupByNameAndType(factoryRef, XPathFactory.class).         if (xpathFactory == null) {             throw new IllegalArgumentException("The provided XPath Factory is invalid. either it cannot be resolved or it is not an XPathFactory instance").         }     } }
