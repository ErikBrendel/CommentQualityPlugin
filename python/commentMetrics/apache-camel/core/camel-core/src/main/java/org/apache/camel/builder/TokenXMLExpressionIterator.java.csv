commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;39;;protected Iterator<?> createIterator(Exchange exchange, InputStream in, String charset) {     String tag = tagToken.     if (SimpleLanguage.hasSimpleFunction(tag)) {         tag = SimpleLanguage.expression(tag).evaluate(exchange, String.class).     }     String inherit = inheritNamespaceToken.     if (inherit != null && SimpleLanguage.hasSimpleFunction(inherit)) {         inherit = SimpleLanguage.expression(inherit).evaluate(exchange, String.class).     }     // must be XML tokens     if (!tag.startsWith("<")) {         tag = "<" + tag.     }     if (!tag.endsWith(">")) {         tag = tag + ">".     }     if (inherit != null) {         if (!inherit.startsWith("<")) {             inherit = "<" + inherit.         }         if (!inherit.endsWith(">")) {             inherit = inherit + ">".         }     }     // must be XML tokens     if (!tag.startsWith("<") || !tag.endsWith(">")) {         throw new IllegalArgumentException("XML Tag token must be a valid XML tag, was: " + tag).     }     if (inherit != null && (!inherit.startsWith("<") || !inherit.endsWith(">"))) {         throw new IllegalArgumentException("Namespace token must be a valid XML token, was: " + inherit).     }     XMLTokenIterator iterator = new XMLTokenIterator(tag, inherit, in, charset).     iterator.init().     return iterator. }
false;public;1;7;;@Override public boolean matches(Exchange exchange) {     // as a predicate we must close the stream, as we do not return an iterator that can be used     // afterwards to iterate the input stream     Object value = doEvaluate(exchange, true).     return ObjectHelper.evaluateValuePredicate(value). }
false;public;1;5;;@Override public Object evaluate(Exchange exchange) {     // as we return an iterator to access the input stream, we should not close it     return doEvaluate(exchange, false). }
true;protected;2;18;/**  * Strategy to evaluate the exchange  *  * @param exchange   the exchange  * @param closeStream whether to close the stream before returning from this method.  * @return the evaluated value  */ ;/**  * Strategy to evaluate the exchange  *  * @param exchange   the exchange  * @param closeStream whether to close the stream before returning from this method.  * @return the evaluated value  */ protected Object doEvaluate(Exchange exchange, boolean closeStream) {     InputStream in = null.     try {         in = exchange.getIn().getMandatoryBody(InputStream.class).         // we may read from a file, and want to support custom charset defined on the exchange         String charset = ExchangeHelper.getCharsetName(exchange).         return createIterator(exchange, in, charset).     } catch (InvalidPayloadException e) {         exchange.setException(e).         // must close input stream         IOHelper.close(in).         return null.     } finally {         if (closeStream) {             IOHelper.close(in).         }     } }
false;;0;5;;void init() {     // use a scanner with the default delimiter     this.scanner = new Scanner(in, charset).     this.image = scanner.hasNext() ? (String) next(true) : null. }
false;;1;39;;String getNext(boolean first) {     // initialize inherited namespaces on first     if (first && inheritNamespaceToken != null && !wrapToken) {         rootTokenNamespaces = getNamespacesFromNamespaceToken(scanner.findWithinHorizon(inheritNamespaceTokenPattern, 0)).     }     String next = scanner.findWithinHorizon(tagTokenPattern, 0).     if (next == null) {         return null.     }     if (first && wrapToken) {         MatchResult mres = scanner.match().         wrapHead = ((RecordableInputStream) in).getText(mres.start()).         wrapTail = buildXMLTail(wrapHead).     }     // build answer accordingly to whether namespaces should be inherited or not     if (inheritNamespaceToken != null && rootTokenNamespaces != null) {         // REVISIT should skip the prefixes that are declared within the child itself.         String head = StringHelper.before(next, ">").         boolean empty = false.         if (head.endsWith("/")) {             head = head.substring(0, head.length() - 1).             empty = true.         }         StringBuilder sb = new StringBuilder().         // append root namespaces to local start token         // grab the text         String tail = StringHelper.after(next, ">").         // build result with inherited namespaces         next = sb.append(head).append(rootTokenNamespaces).append(empty ? "/>" : ">").append(tail).toString().     } else if (wrapToken) {         // wrap the token         StringBuilder sb = new StringBuilder().         next = sb.append(wrapHead).append(next).append(wrapTail).toString().     }     return next. }
false;private;1;40;;private String getNamespacesFromNamespaceToken(String text) {     if (text == null) {         return null.     }     // find namespaces (there can be attributes mixed, so we should only grab the namespaces)     Map<String, String> namespaces = new LinkedHashMap<>().     Matcher matcher = NAMESPACE_PATTERN.matcher(text).     while (matcher.find()) {         String prefix = matcher.group(1).         String url = matcher.group(2).         if (ObjectHelper.isEmpty(prefix)) {             prefix = "_DEFAULT_".         } else {             // skip leading :             prefix = prefix.substring(1).         }         namespaces.put(prefix, url).     }     // did we find any namespaces     if (namespaces.isEmpty()) {         return null.     }     // build namespace String     StringBuilder sb = new StringBuilder().     for (Map.Entry<String, String> entry : namespaces.entrySet()) {         String key = entry.getKey().         // note the value is already quoted         String value = entry.getValue().         if ("_DEFAULT_".equals(key)) {             sb.append(" xmlns=").append(value).         } else {             sb.append(" xmlns:").append(key).append("=").append(value).         }     }     return sb.toString(). }
false;public;0;4;;@Override public boolean hasNext() {     return image != null. }
false;public;0;4;;@Override public Object next() {     return next(false). }
false;;1;15;;Object next(boolean first) {     Object answer = image.     // calculate next     if (scanner.hasNext()) {         image = getNext(first).     } else {         image = null.     }     if (answer == null) {         // first time the image may be null         answer = image.     }     return answer. }
false;public;0;4;;@Override public void remove() { // noop }
false;public;0;4;;@Override public void close() throws IOException {     scanner.close(). }
false;private,static;1;33;;private static String buildXMLTail(String xmlhead) {     // assume the input text is a portion of a well-formed xml     List<String> tags = new ArrayList<>().     int p = 0.     while (p < xmlhead.length()) {         p = xmlhead.indexOf('<', p).         if (p < 0) {             break.         }         int nc = xmlhead.charAt(p + 1).         if (nc == '?') {             p++.             continue.         } else if (nc == '/') {             p++.             tags.remove(tags.size() - 1).         } else {             final int ep = xmlhead.indexOf('>', p).             if (xmlhead.charAt(ep - 1) == '/') {                 p++.                 continue.             }             final int sp = xmlhead.substring(p, ep).indexOf(' ').             tags.add(xmlhead.substring(p + 1, sp > 0 ? p + sp : ep)).             p = ep.         }     }     StringBuilder sb = new StringBuilder().     for (int i = tags.size() - 1. i >= 0. i--) {         sb.append("</").append(tags.get(i)).append(">").     }     return sb.toString(). }
