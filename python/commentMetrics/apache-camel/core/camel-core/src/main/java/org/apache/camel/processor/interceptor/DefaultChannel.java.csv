commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setNextProcessor(Processor next) {     this.nextProcessor = next. }
false;public;0;8;;public Processor getOutput() {     // the error handlers, interceptors, etc. woven in at design time     return errorHandler != null ? errorHandler : output. }
false;public;0;4;;@Override public boolean hasNext() {     return nextProcessor != null. }
false;public;0;9;;@Override public List<Processor> next() {     if (!hasNext()) {         return null.     }     List<Processor> answer = new ArrayList<>(1).     answer.add(nextProcessor).     return answer. }
false;public;1;3;;public void setOutput(Processor output) {     this.output = output. }
false;public;0;3;;public Processor getNextProcessor() {     return nextProcessor. }
false;public;1;8;;public boolean hasInterceptorStrategy(Class<?> type) {     for (InterceptStrategy strategy : interceptors) {         if (type.isInstance(strategy)) {             return true.         }     }     return false. }
false;public;1;3;;public void setErrorHandler(Processor errorHandler) {     this.errorHandler = errorHandler. }
false;public;0;3;;public Processor getErrorHandler() {     return errorHandler. }
false;public;1;3;;public void addInterceptStrategy(InterceptStrategy strategy) {     interceptors.add(strategy). }
false;public;1;3;;public void addInterceptStrategies(List<InterceptStrategy> strategies) {     interceptors.addAll(strategies). }
false;public;0;3;;public List<InterceptStrategy> getInterceptStrategies() {     return interceptors. }
false;public;0;3;;public ProcessorDefinition<?> getProcessorDefinition() {     return definition. }
false;public;1;3;;public void setChildDefinition(ProcessorDefinition<?> childDefinition) {     this.childDefinition = childDefinition. }
false;public;0;3;;public RouteContext getRouteContext() {     return routeContext. }
false;protected;0;6;;@Override protected void doStart() throws Exception {     // the output has now been created, so assign the output as the processor     setProcessor(getOutput()).     ServiceHelper.startService(errorHandler, output). }
false;protected;0;7;;@Override protected void doStop() throws Exception {     if (!isContextScoped()) {         // only stop services if not context scoped (as context scoped is reused by others)         ServiceHelper.stopService(output, errorHandler).     } }
false;protected;0;4;;@Override protected void doShutdown() throws Exception {     ServiceHelper.stopAndShutdownServices(output, errorHandler). }
false;private;0;9;;private boolean isContextScoped() {     if (definition instanceof OnExceptionDefinition) {         return !((OnExceptionDefinition) definition).isRouteScoped().     } else if (definition instanceof OnCompletionDefinition) {         return !((OnCompletionDefinition) definition).isRouteScoped().     }     return false. }
false;public;2;93;;public void initChannel(ProcessorDefinition<?> outputDefinition, RouteContext routeContext) throws Exception {     this.routeContext = routeContext.     this.definition = outputDefinition.     this.camelContext = routeContext.getCamelContext().     Processor target = nextProcessor.     Processor next.     // init CamelContextAware as early as possible on target     if (target instanceof CamelContextAware) {         ((CamelContextAware) target).setCamelContext(camelContext).     }     // the definition to wrap should be the fine grained,     // so if a child is set then use it, if not then its the original output used     ProcessorDefinition<?> targetOutputDef = childDefinition != null ? childDefinition : outputDefinition.     log.debug("Initialize channel for target: '{}'", targetOutputDef).     // ideally we need the design time route -> runtime route to be a 2-phase pass (scheduled work for Camel 3.0)     if (childDefinition != null && outputDefinition != childDefinition) {         childDefinition.setParent(outputDefinition).     }     // force the creation of an id     RouteDefinitionHelper.forceAssignIds(routeContext.getCamelContext(), definition).     // setup instrumentation processor for management (jmx)     // this is later used in postInitChannel as we need to setup the error handler later as well     ManagementInterceptStrategy managed = routeContext.getManagementInterceptStrategy().     if (managed != null) {         instrumentationProcessor = managed.createProcessor(targetOutputDef, target).     }     // then wrap the output with the backlog and tracer (backlog first, as we do not want regular tracer to trace the backlog)     BacklogTracer tracer = getOrCreateBacklogTracer().     camelContext.setExtension(BacklogTracer.class, tracer).     RouteDefinition route = ProcessorDefinitionHelper.getRoute(definition).     boolean first = false.     if (route != null && !route.getOutputs().isEmpty()) {         first = route.getOutputs().get(0) == definition.     }     addAdvice(new BacklogTracerAdvice(tracer, targetOutputDef, route, first)).     // add debugger as well so we have both tracing and debugging out of the box     BacklogDebugger debugger = getOrCreateBacklogDebugger().     camelContext.addService(debugger).     addAdvice(new BacklogDebuggerAdvice(debugger, target, targetOutputDef)).     if (routeContext.isMessageHistory()) {         // add message history advice         MessageHistoryFactory factory = camelContext.getMessageHistoryFactory().         addAdvice(new MessageHistoryAdvice(factory, targetOutputDef)).     }     // sort interceptors according to ordered     interceptors.sort(OrderedComparator.get()).     // reverse list so the first will be wrapped last, as it would then be first being invoked     Collections.reverse(interceptors).     // wrap the output with the configured interceptors     for (InterceptStrategy strategy : interceptors) {         next = target == nextProcessor ? null : nextProcessor.         // use the fine grained definition (eg the child if available). Its always possible to get back to the parent         Processor wrapped = strategy.wrapProcessorInInterceptors(routeContext.getCamelContext(), targetOutputDef, target, next).         if (!(wrapped instanceof AsyncProcessor)) {             log.warn("Interceptor: " + strategy + " at: " + outputDefinition + " does not return an AsyncProcessor instance." + " This causes the asynchronous routing engine to not work as optimal as possible." + " See more details at the InterceptStrategy javadoc." + " Camel will use a bridge to adapt the interceptor to the asynchronous routing engine," + " but its not the most optimal solution. Please consider changing your interceptor to comply.").         }         if (!(wrapped instanceof WrapProcessor)) {             // wrap the target so it becomes a service and we can manage its lifecycle             wrapped = new WrapProcessor(wrapped, target).         }         target = wrapped.     }     if (routeContext.isStreamCaching()) {         addAdvice(new StreamCachingAdvice(camelContext.getStreamCachingStrategy())).     }     if (routeContext.getDelayer() != null && routeContext.getDelayer() > 0) {         addAdvice(new DelayerAdvice(routeContext.getDelayer())).     }     // sets the delegate to our wrapped output     output = target. }
false;public;2;22;;@Override public void postInitChannel(ProcessorDefinition<?> outputDefinition, RouteContext routeContext) throws Exception {     // on the error handler. See more details in the class javadoc of InstrumentationProcessor     if (instrumentationProcessor != null) {         boolean redeliveryPossible = false.         if (errorHandler instanceof RedeliveryErrorHandler) {             redeliveryPossible = ((RedeliveryErrorHandler) errorHandler).determineIfRedeliveryIsEnabled().             if (redeliveryPossible) {                 // okay we can redeliver then we need to change the output in the error handler                 // to use us which we then wrap the call so we can capture before/after for redeliveries as well                 Processor currentOutput = ((RedeliveryErrorHandler) errorHandler).getOutput().                 instrumentationProcessor.setProcessor(currentOutput).                 ((RedeliveryErrorHandler) errorHandler).changeOutput(instrumentationProcessor).             }         }         if (!redeliveryPossible) {             // optimise to use advice as we cannot redeliver             addAdvice(CamelInternalProcessorAdvice.wrap(instrumentationProcessor)).         }     } }
false;private;0;17;;private BacklogTracer getOrCreateBacklogTracer() {     BacklogTracer tracer = null.     if (camelContext.getRegistry() != null) {         // lookup in registry         Map<String, BacklogTracer> map = camelContext.getRegistry().findByTypeWithName(BacklogTracer.class).         if (map.size() == 1) {             tracer = map.values().iterator().next().         }     }     if (tracer == null) {         tracer = camelContext.getExtension(BacklogTracer.class).     }     if (tracer == null) {         tracer = BacklogTracer.createTracer(camelContext).     }     return tracer. }
false;private;0;18;;private BacklogDebugger getOrCreateBacklogDebugger() {     BacklogDebugger debugger = null.     if (camelContext.getRegistry() != null) {         // lookup in registry         Map<String, BacklogDebugger> map = camelContext.getRegistry().findByTypeWithName(BacklogDebugger.class).         if (map.size() == 1) {             debugger = map.values().iterator().next().         }     }     if (debugger == null) {         debugger = camelContext.hasService(BacklogDebugger.class).     }     if (debugger == null) {         // fallback to use the default debugger         debugger = BacklogDebugger.createDebugger(camelContext).     }     return debugger. }
false;public;0;5;;@Override public String toString() {     // just output the next processor as all the interceptors and error handler is just too verbose     return "Channel[" + nextProcessor + "]". }
