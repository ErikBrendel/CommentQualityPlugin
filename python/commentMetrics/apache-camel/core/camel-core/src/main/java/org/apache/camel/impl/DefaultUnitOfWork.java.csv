commented;modifiers;parameterAmount;loc;comment;code
false;;1;3;;UnitOfWork newInstance(Exchange exchange) {     return new DefaultUnitOfWork(exchange). }
false;public;1;4;;@Override public void setParentUnitOfWork(UnitOfWork parentUnitOfWork) {     this.parent = parentUnitOfWork. }
false;public;1;6;;public UnitOfWork createChildUnitOfWork(Exchange childExchange) {     // create a new child unit of work, and mark me as its parent     UnitOfWork answer = newInstance(childExchange).     answer.setParentUnitOfWork(this).     return answer. }
false;public;0;3;;public void start() throws Exception {     id = null. }
false;public;0;16;;public void stop() throws Exception {     // need to clean up when we are stopping to not leak memory     if (synchronizations != null) {         synchronizations.clear().     }     if (transactedBy != null) {         transactedBy.clear().     }     routeContextStack.clear().     if (subUnitOfWorks != null) {         subUnitOfWorks.clear().     }     originalInMessage = null.     parent = null.     id = null. }
false;public,synchronized;1;7;;public synchronized void addSynchronization(Synchronization synchronization) {     if (synchronizations == null) {         synchronizations = new ArrayList<>().     }     log.trace("Adding synchronization {}", synchronization).     synchronizations.add(synchronization). }
false;public,synchronized;1;5;;public synchronized void removeSynchronization(Synchronization synchronization) {     if (synchronizations != null) {         synchronizations.remove(synchronization).     } }
false;public,synchronized;1;3;;public synchronized boolean containsSynchronization(Synchronization synchronization) {     return synchronizations != null && synchronizations.contains(synchronization). }
false;public;1;3;;public void handoverSynchronization(Exchange target) {     handoverSynchronization(target, null). }
false;public;2;26;;@Override public void handoverSynchronization(Exchange target, Predicate<Synchronization> filter) {     if (synchronizations == null || synchronizations.isEmpty()) {         return.     }     Iterator<Synchronization> it = synchronizations.iterator().     while (it.hasNext()) {         Synchronization synchronization = it.next().         boolean handover = true.         if (synchronization instanceof SynchronizationVetoable) {             SynchronizationVetoable veto = (SynchronizationVetoable) synchronization.             handover = veto.allowHandover().         }         if (handover && (filter == null || filter.test(synchronization))) {             log.trace("Handover synchronization {} to: {}", synchronization, target).             target.addOnCompletion(synchronization).             // remove it if its handed over             it.remove().         } else {             log.trace("Handover not allow for synchronization {}", synchronization).         }     } }
false;public;1;36;;public void done(Exchange exchange) {     log.trace("UnitOfWork done for ExchangeId: {} with {}", exchange.getExchangeId(), exchange).     boolean failed = exchange.isFailed().     // at first done the synchronizations     UnitOfWorkHelper.doneSynchronizations(exchange, synchronizations, log).     // notify uow callback if in use     try {         SubUnitOfWorkCallback uowCallback = getSubUnitOfWorkCallback().         if (uowCallback != null) {             uowCallback.onDone(exchange).         }     } catch (Throwable e) {         // must catch exceptions to ensure synchronizations is also invoked         log.warn("Exception occurred during savepoint onDone. This exception will be ignored.", e).     }     // unregister from inflight registry, before signalling we are done     if (exchange.getContext() != null) {         exchange.getContext().getInflightRepository().remove(exchange).     }     // then fire event to signal the exchange is done     try {         if (failed) {             EventHelper.notifyExchangeFailed(exchange.getContext(), exchange).         } else {             EventHelper.notifyExchangeDone(exchange.getContext(), exchange).         }     } catch (Throwable e) {         // must catch exceptions to ensure synchronizations is also invoked         log.warn("Exception occurred during event notification. This exception will be ignored.", e).     } }
false;public;2;7;;@Override public void beforeRoute(Exchange exchange, Route route) {     if (log.isTraceEnabled()) {         log.trace("UnitOfWork beforeRoute: {} for ExchangeId: {} with {}", route.getId(), exchange.getExchangeId(), exchange).     }     UnitOfWorkHelper.beforeRouteSynchronizations(route, exchange, synchronizations, log). }
false;public;2;7;;@Override public void afterRoute(Exchange exchange, Route route) {     if (log.isTraceEnabled()) {         log.trace("UnitOfWork afterRoute: {} for ExchangeId: {} with {}", route.getId(), exchange.getExchangeId(), exchange).     }     UnitOfWorkHelper.afterRouteSynchronizations(route, exchange, synchronizations, log). }
false;public;0;6;;public String getId() {     if (id == null) {         id = context.getUuidGenerator().generateUuid().     }     return id. }
false;public;0;6;;public Message getOriginalInMessage() {     if (originalInMessage == null && !context.isAllowUseOriginalMessage()) {         throw new IllegalStateException("AllowUseOriginalMessage is disabled. Cannot access the original message.").     }     return originalInMessage. }
false;public;0;3;;public boolean isTransacted() {     return transactedBy != null && !transactedBy.isEmpty(). }
false;public;1;3;;public boolean isTransactedBy(Object key) {     return getTransactedBy().contains(key). }
false;public;1;3;;public void beginTransactedBy(Object key) {     getTransactedBy().add(key). }
false;public;1;3;;public void endTransactedBy(Object key) {     getTransactedBy().remove(key). }
false;public;0;3;;public RouteContext getRouteContext() {     return routeContextStack.peek(). }
false;public;1;3;;public void pushRouteContext(RouteContext routeContext) {     routeContextStack.push(routeContext). }
false;public;0;3;;public RouteContext popRouteContext() {     return routeContextStack.pollFirst(). }
false;public;3;4;;public AsyncCallback beforeProcess(Processor processor, Exchange exchange, AsyncCallback callback) {     // no wrapping needed     return callback. }
false;public;4;2;;public void afterProcess(Processor processor, Exchange exchange, AsyncCallback callback, boolean doneSync) { }
false;public;1;11;;@Override public void beginSubUnitOfWork(Exchange exchange) {     if (log.isTraceEnabled()) {         log.trace("beginSubUnitOfWork exchangeId: {}", exchange.getExchangeId()).     }     if (subUnitOfWorks == null) {         subUnitOfWorks = new ArrayDeque<>().     }     subUnitOfWorks.push(new DefaultSubUnitOfWork()). }
false;public;1;45;;@Override public void endSubUnitOfWork(Exchange exchange) {     if (log.isTraceEnabled()) {         log.trace("endSubUnitOfWork exchangeId: {}", exchange.getExchangeId()).     }     if (subUnitOfWorks == null || subUnitOfWorks.isEmpty()) {         return.     }     // pop last sub unit of work as its now ended     SubUnitOfWork subUoW = null.     try {         subUoW = subUnitOfWorks.pop().     } catch (NoSuchElementException e) {     // ignore     }     if (subUoW != null && subUoW.isFailed()) {         // the sub unit of work failed so set an exception containing all the caused exceptions         // and mark the exchange for rollback only         // if there are multiple exceptions then wrap those into another exception with them all         Exception cause.         List<Exception> list = subUoW.getExceptions().         if (list != null) {             if (list.size() == 1) {                 cause = list.get(0).             } else {                 cause = new CamelUnitOfWorkException(exchange, list).             }             exchange.setException(cause).         }         // mark it as rollback and that the unit of work is exhausted. This ensures that we do not try         // to redeliver this exception (again)         exchange.setProperty(Exchange.ROLLBACK_ONLY, true).         exchange.setProperty(Exchange.UNIT_OF_WORK_EXHAUSTED, true).         // and remove any indications of error handled which will prevent this exception to be noticed         // by the error handler which we want to react with the result of the sub unit of work         exchange.setProperty(Exchange.ERRORHANDLER_HANDLED, null).         exchange.setProperty(Exchange.FAILURE_HANDLED, null).         if (log.isTraceEnabled()) {             log.trace("endSubUnitOfWork exchangeId: {} with {} caused exceptions.", exchange.getExchangeId(), list != null ? list.size() : 0).         }     } }
false;public;0;10;;@Override public SubUnitOfWorkCallback getSubUnitOfWorkCallback() {     // then we should use the callback strategies from the parent     if (parent != null) {         return parent.getSubUnitOfWorkCallback().     }     return subUnitOfWorks != null ? subUnitOfWorks.peek() : null. }
false;private;0;6;;private Set<Object> getTransactedBy() {     if (transactedBy == null) {         transactedBy = new LinkedHashSet<>().     }     return transactedBy. }
false;public;0;4;;@Override public String toString() {     return "DefaultUnitOfWork". }
