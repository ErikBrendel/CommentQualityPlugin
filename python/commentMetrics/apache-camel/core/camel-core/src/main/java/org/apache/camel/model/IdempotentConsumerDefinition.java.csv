commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "IdempotentConsumer[" + getExpression() + " -> " + getOutputs() + "]". }
false;public;0;4;;@Override public String getShortName() {     return "idempotentConsumer". }
false;public;0;4;;@Override public String getLabel() {     return "idempotentConsumer[" + getExpression() + "]". }
true;public;1;4;/**  * Sets the reference name of the message id repository  *  * @param messageIdRepositoryRef the reference name of message id repository  * @return builder  */ ;// Fluent API // ------------------------------------------------------------------------- /**  * Sets the reference name of the message id repository  *  * @param messageIdRepositoryRef the reference name of message id repository  * @return builder  */ public IdempotentConsumerDefinition messageIdRepositoryRef(String messageIdRepositoryRef) {     setMessageIdRepositoryRef(messageIdRepositoryRef).     return this. }
true;public;1;4;/**  * Sets the message id repository for the idempotent consumer  *  * @param idempotentRepository the repository instance of idempotent  * @return builder  */ ;/**  * Sets the message id repository for the idempotent consumer  *  * @param idempotentRepository the repository instance of idempotent  * @return builder  */ public IdempotentConsumerDefinition messageIdRepository(IdempotentRepository idempotentRepository) {     setMessageIdRepository(idempotentRepository).     return this. }
true;public;1;4;/**  * Sets whether to eagerly add the key to the idempotent repository or wait until the exchange  * is complete. Eager is default enabled.  *  * @param eager <tt>true</tt> to add the key before processing, <tt>false</tt> to wait until  *              the exchange is complete.  * @return builder  */ ;/**  * Sets whether to eagerly add the key to the idempotent repository or wait until the exchange  * is complete. Eager is default enabled.  *  * @param eager <tt>true</tt> to add the key before processing, <tt>false</tt> to wait until  *              the exchange is complete.  * @return builder  */ public IdempotentConsumerDefinition eager(boolean eager) {     setEager(eager).     return this. }
true;public;1;4;/**  * Sets whether to complete the idempotent consumer eager or when the exchange is done.  * <p/>  * If this option is <tt>true</tt> to complete eager, then the idempotent consumer will trigger its completion  * when the exchange reached the end of the block of the idempotent consumer pattern. So if the exchange  * is continued routed after the block ends, then whatever happens there does not affect the state.  * <p/>  * If this option is <tt>false</tt> (default) to <b>not</b> complete eager, then the idempotent consumer  * will complete when the exchange is done being routed. So if the exchange is continued routed after the block ends,  * then whatever happens there <b>also</b> affect the state.  * For example if the exchange failed due to an exception, then the state of the idempotent consumer will be a rollback.  *  * @param completionEager   whether to complete eager or complete when the exchange is done  * @return builder  */ ;/**  * Sets whether to complete the idempotent consumer eager or when the exchange is done.  * <p/>  * If this option is <tt>true</tt> to complete eager, then the idempotent consumer will trigger its completion  * when the exchange reached the end of the block of the idempotent consumer pattern. So if the exchange  * is continued routed after the block ends, then whatever happens there does not affect the state.  * <p/>  * If this option is <tt>false</tt> (default) to <b>not</b> complete eager, then the idempotent consumer  * will complete when the exchange is done being routed. So if the exchange is continued routed after the block ends,  * then whatever happens there <b>also</b> affect the state.  * For example if the exchange failed due to an exception, then the state of the idempotent consumer will be a rollback.  *  * @param completionEager   whether to complete eager or complete when the exchange is done  * @return builder  */ public IdempotentConsumerDefinition completionEager(boolean completionEager) {     setCompletionEager(completionEager).     return this. }
true;public;1;4;/**  * Sets whether to remove or keep the key on failure.  * <p/>  * The default behavior is to remove the key on failure.  *  * @param removeOnFailure <tt>true</tt> to remove the key, <tt>false</tt> to keep the key  *                        if the exchange fails.  * @return builder  */ ;/**  * Sets whether to remove or keep the key on failure.  * <p/>  * The default behavior is to remove the key on failure.  *  * @param removeOnFailure <tt>true</tt> to remove the key, <tt>false</tt> to keep the key  *                        if the exchange fails.  * @return builder  */ public IdempotentConsumerDefinition removeOnFailure(boolean removeOnFailure) {     setRemoveOnFailure(removeOnFailure).     return this. }
true;public;1;4;/**  * Sets whether to skip duplicates or not.  * <p/>  * The default behavior is to skip duplicates.  * <p/>  * A duplicate message would have the Exchange property {@link org.apache.camel.Exchange#DUPLICATE_MESSAGE} set  * to a {@link Boolean#TRUE} value. A none duplicate message will not have this property set.  *  * @param skipDuplicate <tt>true</tt> to skip duplicates, <tt>false</tt> to allow duplicates.  * @return builder  */ ;/**  * Sets whether to skip duplicates or not.  * <p/>  * The default behavior is to skip duplicates.  * <p/>  * A duplicate message would have the Exchange property {@link org.apache.camel.Exchange#DUPLICATE_MESSAGE} set  * to a {@link Boolean#TRUE} value. A none duplicate message will not have this property set.  *  * @param skipDuplicate <tt>true</tt> to skip duplicates, <tt>false</tt> to allow duplicates.  * @return builder  */ public IdempotentConsumerDefinition skipDuplicate(boolean skipDuplicate) {     setSkipDuplicate(skipDuplicate).     return this. }
true;public;1;5;/**  * Expression used to calculate the correlation key to use for duplicate check.  * The Exchange which has the same correlation key is regarded as a duplicate and will be rejected.  */ ;/**  * Expression used to calculate the correlation key to use for duplicate check.  * The Exchange which has the same correlation key is regarded as a duplicate and will be rejected.  */ @Override public void setExpression(ExpressionDefinition expression) {     // override to include javadoc what the expression is used for     super.setExpression(expression). }
false;public;0;3;;public String getMessageIdRepositoryRef() {     return messageIdRepositoryRef. }
false;public;1;3;;public void setMessageIdRepositoryRef(String messageIdRepositoryRef) {     this.messageIdRepositoryRef = messageIdRepositoryRef. }
false;public;0;3;;public IdempotentRepository getMessageIdRepository() {     return idempotentRepository. }
false;public;1;3;;public void setMessageIdRepository(IdempotentRepository idempotentRepository) {     this.idempotentRepository = idempotentRepository. }
false;public;0;3;;public Boolean getEager() {     return eager. }
false;public;1;3;;public void setEager(Boolean eager) {     this.eager = eager. }
false;public;0;3;;public Boolean getSkipDuplicate() {     return skipDuplicate. }
false;public;1;3;;public void setSkipDuplicate(Boolean skipDuplicate) {     this.skipDuplicate = skipDuplicate. }
false;public;0;3;;public Boolean getRemoveOnFailure() {     return removeOnFailure. }
false;public;1;3;;public void setRemoveOnFailure(Boolean removeOnFailure) {     this.removeOnFailure = removeOnFailure. }
false;public;0;3;;public Boolean getCompletionEager() {     return completionEager. }
false;public;1;3;;public void setCompletionEager(Boolean completionEager) {     this.completionEager = completionEager. }
