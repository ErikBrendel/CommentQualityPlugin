commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setExpectedMessageEndpoint(Endpoint expectedMessageEndpoint) {     this.expectedMessageEndpoint = expectedMessageEndpoint. }
false;public;1;18;;public void process(Exchange exchange) throws Exception {     // if file based we need to load the file into memory as the file may be deleted/moved afterwards     Object body = getInBody(exchange).     if (body instanceof WrappedFile) {         body = exchange.getIn().getBody(String.class).     }     if (split) {         // use new lines in both styles         Iterator<?> it = ObjectHelper.createIterator(body, delimiter, false, true).         while (it.hasNext()) {             Object line = it.next().             log.trace("Received message body {}", line).             expectedBodies.add(line).         }     } else {         expectedBodies.add(body).     } }
false;protected;0;33;;@Override protected void doStart() throws Exception {     log.debug("Consuming expected messages from: {}", expectedMessageEndpoint).     final List<Object> expectedBodies = new ArrayList<>().     EndpointHelper.pollEndpoint(expectedMessageEndpoint, new Processor() {          public void process(Exchange exchange) throws Exception {             // if file based we need to load the file into memory as the file may be deleted/moved afterwards             Object body = getInBody(exchange).             if (body instanceof WrappedFile) {                 body = exchange.getIn().getBody(String.class).             }             if (split) {                 // use new lines in both styles                 Iterator<?> it = ObjectHelper.createIterator(body, delimiter, false, true).                 while (it.hasNext()) {                     Object line = it.next().                     log.trace("Received message body {}", line).                     expectedBodies.add(line).                 }             } else {                 expectedBodies.add(body).             }         }     }, timeout).     log.info("Received: {} expected message(s) from: {}", expectedBodies.size(), expectedMessageEndpoint).     if (anyOrder) {         expectedBodiesReceivedInAnyOrder(expectedBodies).     } else {         expectedBodiesReceived(expectedBodies).     } }
true;protected;1;3;/**  * This method allows us to convert or coerce the expected message body into some other type  */ ;/**  * This method allows us to convert or coerce the expected message body into some other type  */ protected Object getInBody(Exchange exchange) {     return exchange.getIn().getBody(). }
false;public;0;3;;public long getTimeout() {     return timeout. }
true;public;1;3;/**  * The timeout to use when polling for message bodies from the URI  */ ;/**  * The timeout to use when polling for message bodies from the URI  */ public void setTimeout(long timeout) {     this.timeout = timeout. }
false;public;0;3;;public boolean isAnyOrder() {     return anyOrder. }
true;public;1;3;/**  * Whether the expected messages should arrive in the same order or can be in any order.  */ ;/**  * Whether the expected messages should arrive in the same order or can be in any order.  */ public void setAnyOrder(boolean anyOrder) {     this.anyOrder = anyOrder. }
false;public;0;3;;public boolean isSplit() {     return split. }
true;public;1;3;/**  * If enabled the messages loaded from the test endpoint will be split using new line delimiters  * so each line is an expected message.  * <br/>  * For example to use a file endpoint to load a file where each line is an expected message.  */ ;/**  * If enabled the messages loaded from the test endpoint will be split using new line delimiters  * so each line is an expected message.  * <br/>  * For example to use a file endpoint to load a file where each line is an expected message.  */ public void setSplit(boolean split) {     this.split = split. }
false;public;0;3;;public String getDelimiter() {     return delimiter. }
true;public;1;3;/**  * The split delimiter to use when split is enabled.  * By default the delimiter is new line based.  * The delimiter can be a regular expression.  */ ;/**  * The split delimiter to use when split is enabled.  * By default the delimiter is new line based.  * The delimiter can be a regular expression.  */ public void setDelimiter(String delimiter) {     this.delimiter = delimiter. }
