commented;modifiers;parameterAmount;loc;comment;code
false;public,static;4;5;;public static void assertEquals(String description, Object expected, Object actual, Exchange exchange) {     if (!ObjectHelper.equal(expected, actual)) {         throw new AssertionError(description + " does not match. Expected: " + expected + " but was: " + actual + " on " + exchange + " with headers: " + exchange.getIn().getHeaders()).     } }
false;public;1;6;;@Override public Consumer createConsumer(Processor processor) throws Exception {     Consumer answer = new DataSetConsumer(this, processor).     configureConsumer(answer).     return answer. }
false;public;0;9;;@Override public Producer createProducer() throws Exception {     Producer answer = super.createProducer().     long size = getDataSet().getSize().     expectedMessageCount((int) size).     return answer. }
false;public;0;5;;@Override public void reset() {     super.reset().     receivedCounter.set(0). }
false;public;0;4;;@Override public int getReceivedCounter() {     return receivedCounter.get(). }
true;public;1;12;/**  * Creates a message exchange for the given index in the {@link DataSet}  */ ;/**  * Creates a message exchange for the given index in the {@link DataSet}  */ public Exchange createExchange(long messageIndex) throws Exception {     Exchange exchange = createExchange().     getDataSet().populateMessage(exchange, messageIndex).     if (!getDataSetIndex().equals("off")) {         Message in = exchange.getIn().         in.setHeader(Exchange.DATASET_INDEX, messageIndex).     }     return exchange. }
false;protected;1;13;;@Override protected void waitForCompleteLatch(long timeout) throws InterruptedException {     super.waitForCompleteLatch(timeout).     if (minRate > 0) {         int count = getReceivedCounter().         do {             // wait as long as we get a decent message rate             super.waitForCompleteLatch(1000L).             count = getReceivedCounter() - count.         } while (count >= minRate).     } }
false;public;0;3;;// Properties // ------------------------------------------------------------------------- public DataSet getDataSet() {     return dataSet. }
false;public;1;3;;public void setDataSet(DataSet dataSet) {     this.dataSet = dataSet. }
false;public;0;3;;public int getMinRate() {     return minRate. }
true;public;1;3;/**  * Wait until the DataSet contains at least this number of messages  */ ;/**  * Wait until the DataSet contains at least this number of messages  */ public void setMinRate(int minRate) {     this.minRate = minRate. }
false;public;0;3;;public long getPreloadSize() {     return preloadSize. }
true;public;1;3;/**  * Sets how many messages should be preloaded (sent) before the route completes its initialization  */ ;/**  * Sets how many messages should be preloaded (sent) before the route completes its initialization  */ public void setPreloadSize(long preloadSize) {     this.preloadSize = preloadSize. }
false;public;0;3;;public long getConsumeDelay() {     return consumeDelay. }
true;public;1;3;/**  * Allows a delay to be specified which causes a delay when a message is consumed by the producer (to simulate slow processing)  */ ;/**  * Allows a delay to be specified which causes a delay when a message is consumed by the producer (to simulate slow processing)  */ public void setConsumeDelay(long consumeDelay) {     this.consumeDelay = consumeDelay. }
false;public;0;3;;public long getProduceDelay() {     return produceDelay. }
true;public;1;3;/**  * Allows a delay to be specified which causes a delay when a message is sent by the consumer (to simulate slow processing)  */ ;/**  * Allows a delay to be specified which causes a delay when a message is sent by the consumer (to simulate slow processing)  */ public void setProduceDelay(long produceDelay) {     this.produceDelay = produceDelay. }
false;public;0;3;;public long getInitialDelay() {     return initialDelay. }
true;public;1;3;/**  * Time period in millis to wait before starting sending messages.  */ ;/**  * Time period in millis to wait before starting sending messages.  */ public void setInitialDelay(long initialDelay) {     this.initialDelay = initialDelay. }
true;public;1;12;/**  * Controls the behaviour of the CamelDataSetIndex header.  * For Consumers:  * - off => the header will not be set  * - strict/lenient => the header will be set  * For Producers:  * - off => the header value will not be verified, and will not be set if it is not present  * = strict => the header value must be present and will be verified  * = lenient => the header value will be verified if it is present, and will be set if it is not present  */ ;/**  * Controls the behaviour of the CamelDataSetIndex header.  * For Consumers:  * - off => the header will not be set  * - strict/lenient => the header will be set  * For Producers:  * - off => the header value will not be verified, and will not be set if it is not present  * = strict => the header value must be present and will be verified  * = lenient => the header value will be verified if it is present, and will be set if it is not present  */ public void setDataSetIndex(String dataSetIndex) {     switch(dataSetIndex) {         case "off":         case "lenient":         case "strict":             this.dataSetIndex = dataSetIndex.             break.         default:             throw new IllegalArgumentException("Invalid value specified for the dataSetIndex URI parameter:" + dataSetIndex + "Supported values are strict, lenient and off ").     } }
false;public;0;3;;public String getDataSetIndex() {     return dataSetIndex. }
false;protected;2;23;;// Implementation methods // ------------------------------------------------------------------------- @Override protected void performAssertions(Exchange actual, Exchange copy) throws Exception {     int receivedCount = receivedCounter.incrementAndGet().     long index = receivedCount - 1.     Exchange expected = createExchange(index).     // now let's assert that they are the same     if (log.isDebugEnabled()) {         if (copy.getIn().getHeader(Exchange.DATASET_INDEX) != null) {             log.debug("Received message: {} (DataSet index={}) = {}", new Object[] { index, copy.getIn().getHeader(Exchange.DATASET_INDEX, Integer.class), copy }).         } else {             log.debug("Received message: {} = {}", new Object[] { index, copy }).         }     }     assertMessageExpected(index, expected, copy).     if (consumeDelay > 0) {         Thread.sleep(consumeDelay).     } }
false;protected;3;23;;protected void assertMessageExpected(long index, Exchange expected, Exchange actual) throws Exception {     switch(getDataSetIndex()) {         case "off":             break.         case "strict":             long actualCounter = ExchangeHelper.getMandatoryHeader(actual, Exchange.DATASET_INDEX, Long.class).             assertEquals("Header: " + Exchange.DATASET_INDEX, index, actualCounter, actual).             break.         case "lenient":         default:             // Validate the header value if it is present             Long dataSetIndexHeaderValue = actual.getIn().getHeader(Exchange.DATASET_INDEX, Long.class).             if (dataSetIndexHeaderValue != null) {                 assertEquals("Header: " + Exchange.DATASET_INDEX, index, dataSetIndexHeaderValue, actual).             } else {                 // set the header if it isn't there                 actual.getIn().setHeader(Exchange.DATASET_INDEX, index).             }             break.     }     getDataSet().assertMessageExpected(this, expected, actual, index). }
false;protected;0;8;;protected ThroughputLogger createReporter() {     // must sanitize uri to avoid logging sensitive information     String uri = URISupport.sanitizeUri(getEndpointUri()).     CamelLogger logger = new CamelLogger(uri).     ThroughputLogger answer = new ThroughputLogger(logger, (int) this.getDataSet().getReportCount()).     answer.setAction("Received").     return answer. }
false;protected;0;10;;@Override protected void doStart() throws Exception {     super.doStart().     if (reporter == null) {         reporter = createReporter().     }     log.info(this + " expecting " + getExpectedCount() + " messages"). }
