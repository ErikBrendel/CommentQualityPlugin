commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Set an expression to extract the element to be aggregated from the incoming {@link Exchange}.  * All results are cast to the {@link FlexibleAggregationStrategy#castAs} type (or the type specified in the constructor).  * <p/>  * By default, it picks the full IN message body of the incoming exchange.  * @param expression The picking expression.  * @return This instance.  */ ;/**  * Set an expression to extract the element to be aggregated from the incoming {@link Exchange}.  * All results are cast to the {@link FlexibleAggregationStrategy#castAs} type (or the type specified in the constructor).  * <p/>  * By default, it picks the full IN message body of the incoming exchange.  * @param expression The picking expression.  * @return This instance.  */ public FlexibleAggregationStrategy<E> pick(Expression expression) {     this.pickExpression = expression.     return this. }
true;public;1;4;/**  * Set a filter condition such as only results satisfying it will be aggregated.  * By default, all picked values will be processed.  * @param predicate The condition.  * @return This instance.  */ ;/**  * Set a filter condition such as only results satisfying it will be aggregated.  * By default, all picked values will be processed.  * @param predicate The condition.  * @return This instance.  */ public FlexibleAggregationStrategy<E> condition(Predicate predicate) {     this.conditionPredicate = predicate.     return this. }
true;public;1;5;/**  * Accumulate the result of the <i>pick expression</i> in a collection of the designated type.  * No <tt>null</tt>s will stored unless the {@link FlexibleAggregationStrategy#storeNulls()} option is enabled.  * @param collectionType The type of the Collection to aggregate into.  * @return This instance.  */ ;/**  * Accumulate the result of the <i>pick expression</i> in a collection of the designated type.  * No <tt>null</tt>s will stored unless the {@link FlexibleAggregationStrategy#storeNulls()} option is enabled.  * @param collectionType The type of the Collection to aggregate into.  * @return This instance.  */ @SuppressWarnings("rawtypes") public FlexibleAggregationStrategy<E> accumulateInCollection(Class<? extends Collection> collectionType) {     this.collectionType = collectionType.     return this. }
true;public;1;4;/**  * Store the result of this Aggregation Strategy (whether an atomic element or a Collection) in a property with  * the designated name.  * @param propertyName The property name.  * @return This instance.  */ ;/**  * Store the result of this Aggregation Strategy (whether an atomic element or a Collection) in a property with  * the designated name.  * @param propertyName The property name.  * @return This instance.  */ public FlexibleAggregationStrategy<E> storeInProperty(String propertyName) {     this.injector = new PropertyInjector(castAs, propertyName).     return this. }
true;public;1;4;/**  * Store the result of this Aggregation Strategy (whether an atomic element or a Collection) in an IN message header with  * the designated name.  * @param headerName The header name.  * @return This instance.  */ ;/**  * Store the result of this Aggregation Strategy (whether an atomic element or a Collection) in an IN message header with  * the designated name.  * @param headerName The header name.  * @return This instance.  */ public FlexibleAggregationStrategy<E> storeInHeader(String headerName) {     this.injector = new HeaderInjector(castAs, headerName).     return this. }
true;public;0;4;/**  * Store the result of this Aggregation Strategy (whether an atomic element or a Collection) in the body of the IN message.  * @return This instance.  */ ;/**  * Store the result of this Aggregation Strategy (whether an atomic element or a Collection) in the body of the IN message.  * @return This instance.  */ public FlexibleAggregationStrategy<E> storeInBody() {     this.injector = new BodyInjector(castAs).     return this. }
true;public;1;5;/**  * Cast the result of the <i>pick expression</i> to this type.  * @param castAs Type for the cast.  * @return This instance.  */ ;/**  * Cast the result of the <i>pick expression</i> to this type.  * @param castAs Type for the cast.  * @return This instance.  */ public FlexibleAggregationStrategy<E> castAs(Class<E> castAs) {     this.castAs = castAs.     injector.setType(castAs).     return this. }
true;public;0;4;/**  * Enables storing null values in the resulting collection.  * By default, this aggregation strategy will drop null values.  * @return This instance.  */ ;/**  * Enables storing null values in the resulting collection.  * By default, this aggregation strategy will drop null values.  * @return This instance.  */ public FlexibleAggregationStrategy<E> storeNulls() {     this.storeNulls = true.     return this. }
true;public;0;4;/**  * Ignores invalid casts instead of throwing an exception if the <i>pick expression</i> result cannot be casted to the  * specified type.  * By default, this aggregation strategy will throw an exception if an invalid cast occurs.  * @return This instance.  */ ;/**  * Ignores invalid casts instead of throwing an exception if the <i>pick expression</i> result cannot be casted to the  * specified type.  * By default, this aggregation strategy will throw an exception if an invalid cast occurs.  * @return This instance.  */ public FlexibleAggregationStrategy<E> ignoreInvalidCasts() {     this.ignoreInvalidCasts = true.     return this. }
true;public;1;4;/**  * Plugs in logic to execute when a timeout occurs.  * @param timeoutMixin  * @return This instance.  */ ;/**  * Plugs in logic to execute when a timeout occurs.  * @param timeoutMixin  * @return This instance.  */ public FlexibleAggregationStrategy<E> timeoutAware(TimeoutAwareMixin timeoutMixin) {     this.timeoutMixin = timeoutMixin.     return this. }
true;public;1;4;/**  * Plugs in logic to execute when an aggregation batch completes.  * @param completionMixin  * @return This instance.  */ ;/**  * Plugs in logic to execute when an aggregation batch completes.  * @param completionMixin  * @return This instance.  */ public FlexibleAggregationStrategy<E> completionAware(CompletionAwareMixin completionMixin) {     this.completionMixin = completionMixin.     return this. }
false;public;2;38;;@Override public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {     Exchange exchange = oldExchange.     if (exchange == null) {         exchange = ExchangeHelper.createCorrelatedCopy(newExchange, true).         injector.prepareAggregationExchange(exchange).     }     // 1. Apply the condition and reject the aggregation if unmatched     if (conditionPredicate != null && !conditionPredicate.matches(newExchange)) {         LOG.trace("Dropped exchange {} from aggregation as predicate {} was not matched", newExchange, conditionPredicate).         return exchange.     }     // 2. Pick the appropriate element of the incoming message, casting it to the specified class     // If null, act accordingly based on storeNulls     E picked = null.     try {         picked = pickExpression.evaluate(newExchange, castAs).     } catch (TypeConversionException exception) {         if (!ignoreInvalidCasts) {             throw exception.         }     }     if (picked == null && !storeNulls) {         LOG.trace("Dropped exchange {} from aggregation as pick expression returned null and storing nulls is not enabled", newExchange).         return exchange.     }     if (collectionType == null) {         injectAsRawValue(exchange, picked).     } else {         injectAsCollection(exchange, picked, collectionType).     }     return exchange. }
false;public;4;7;;@Override public void timeout(Exchange oldExchange, int index, int total, long timeout) {     if (timeoutMixin == null) {         return.     }     timeoutMixin.timeout(oldExchange, index, total, timeout). }
false;public;1;7;;@Override public void onCompletion(Exchange exchange) {     if (completionMixin == null) {         return.     }     completionMixin.onCompletion(exchange). }
false;private;2;3;;private void injectAsRawValue(Exchange oldExchange, E picked) {     injector.setValue(oldExchange, picked). }
false;private;3;5;;private void injectAsCollection(Exchange oldExchange, E picked, Class<? extends Collection> collectionType) {     Collection<E> col = injector.getValueAsCollection(oldExchange, collectionType).     col = safeInsertIntoCollection(oldExchange, col, picked).     injector.setValueAsCollection(oldExchange, col). }
false;private;3;27;;@SuppressWarnings("unchecked") private Collection<E> safeInsertIntoCollection(Exchange oldExchange, Collection<E> oldValue, E toInsert) {     Collection<E> collection = null.     try {         if (oldValue == null || oldExchange.getProperty(Exchange.AGGREGATED_COLLECTION_GUARD, Boolean.class) == null) {             try {                 collection = collectionType.newInstance().             } catch (Exception e) {                 LOG.warn("Could not instantiate collection of type {}. Aborting aggregation.", collectionType).                 throw CamelExecutionException.wrapCamelExecutionException(oldExchange, e).             }             oldExchange.setProperty(Exchange.AGGREGATED_COLLECTION_GUARD, Boolean.FALSE).         } else {             collection = collectionType.cast(oldValue).         }         if (collection != null) {             collection.add(toInsert).         }     } catch (ClassCastException exception) {         if (!ignoreInvalidCasts) {             throw exception.         }     }     return collection. }
false;;4;1;;void timeout(Exchange exchange, int index, int total, long timeout).
false;;1;1;;void onCompletion(Exchange exchange).
false;public;1;3;;public void setType(Class<E> type) {     this.type = type. }
false;public,abstract;1;1;;public abstract void prepareAggregationExchange(Exchange exchange).
false;public,abstract;1;1;;public abstract E getValue(Exchange exchange).
false;public,abstract;2;1;;public abstract void setValue(Exchange exchange, E obj).
false;public,abstract;2;1;;public abstract Collection<E> getValueAsCollection(Exchange exchange, Class<? extends Collection> type).
false;public,abstract;2;1;;public abstract void setValueAsCollection(Exchange exchange, Collection<E> obj).
false;public;1;4;;@Override public void prepareAggregationExchange(Exchange exchange) {     exchange.removeProperty(propertyName). }
false;public;1;4;;@Override public E getValue(Exchange exchange) {     return exchange.getProperty(propertyName, type). }
false;public;2;4;;@Override public void setValue(Exchange exchange, E obj) {     exchange.setProperty(propertyName, obj). }
false;public;2;10;;@Override @SuppressWarnings("unchecked") public Collection<E> getValueAsCollection(Exchange exchange, Class<? extends Collection> type) {     Object value = exchange.getProperty(propertyName).     if (value == null) {         // empty so create a new collection to host this         return exchange.getContext().getInjector().newInstance(type).     } else {         return exchange.getProperty(propertyName, type).     } }
false;public;2;4;;@Override public void setValueAsCollection(Exchange exchange, Collection<E> obj) {     exchange.setProperty(propertyName, obj). }
false;public;1;4;;@Override public void prepareAggregationExchange(Exchange exchange) {     exchange.getIn().removeHeader(headerName). }
false;public;1;4;;@Override public E getValue(Exchange exchange) {     return exchange.getIn().getHeader(headerName, type). }
false;public;2;4;;@Override public void setValue(Exchange exchange, E obj) {     exchange.getIn().setHeader(headerName, obj). }
false;public;2;10;;@Override @SuppressWarnings("unchecked") public Collection<E> getValueAsCollection(Exchange exchange, Class<? extends Collection> type) {     Object value = exchange.getIn().getHeader(headerName).     if (value == null) {         // empty so create a new collection to host this         return exchange.getContext().getInjector().newInstance(type).     } else {         return exchange.getIn().getHeader(headerName, type).     } }
false;public;2;4;;@Override public void setValueAsCollection(Exchange exchange, Collection<E> obj) {     exchange.getIn().setHeader(headerName, obj). }
false;public;1;4;;@Override public void prepareAggregationExchange(Exchange exchange) {     exchange.getIn().setBody(null). }
false;public;1;4;;@Override public E getValue(Exchange exchange) {     return exchange.getIn().getBody(type). }
false;public;2;4;;@Override public void setValue(Exchange exchange, E obj) {     exchange.getIn().setBody(obj). }
false;public;2;10;;@Override @SuppressWarnings("unchecked") public Collection<E> getValueAsCollection(Exchange exchange, Class<? extends Collection> type) {     Object value = exchange.getIn().getBody().     if (value == null) {         // empty so create a new collection to host this         return exchange.getContext().getInjector().newInstance(type).     } else {         return exchange.getIn().getBody(type).     } }
false;public;2;4;;@Override public void setValueAsCollection(Exchange exchange, Collection<E> obj) {     exchange.getIn().setBody(obj). }
