commented;modifiers;parameterAmount;loc;comment;code
true;public;2;25;/**  * Apply this post processor to the given new bean instance <i>before</i> any bean  * initialization callbacks (like <code>afterPropertiesSet</code>  * or a custom init-method). The bean will already be populated with property values.  * The returned bean instance may be a wrapper around the original.  *  * @param bean the new bean instance  * @param beanName the name of the bean  * @return the bean instance to use, either the original or a wrapped one. if  * <code>null</code>, no subsequent BeanPostProcessors will be invoked  * @throws Exception is thrown if error post processing bean  */ ;/**  * Apply this post processor to the given new bean instance <i>before</i> any bean  * initialization callbacks (like <code>afterPropertiesSet</code>  * or a custom init-method). The bean will already be populated with property values.  * The returned bean instance may be a wrapper around the original.  *  * @param bean the new bean instance  * @param beanName the name of the bean  * @return the bean instance to use, either the original or a wrapped one. if  * <code>null</code>, no subsequent BeanPostProcessors will be invoked  * @throws Exception is thrown if error post processing bean  */ public Object postProcessBeforeInitialization(Object bean, String beanName) throws Exception {     LOG.trace("Camel bean processing before initialization for bean: {}", beanName).     // some beans cannot be post processed at this given time, so we gotta check beforehand     if (!canPostProcessBean(bean, beanName)) {         return bean.     }     injectFields(bean, beanName).     injectMethods(bean, beanName).     if (bean instanceof CamelContextAware && canSetCamelContext(bean, beanName)) {         CamelContextAware contextAware = (CamelContextAware) bean.         DeferredContextBinding deferredBinding = bean.getClass().getAnnotation(DeferredContextBinding.class).         CamelContext context = getOrLookupCamelContext().         if (context == null && deferredBinding == null) {             LOG.warn("No CamelContext defined yet so cannot inject into bean: {}", beanName).         } else if (context != null) {             contextAware.setCamelContext(context).         }     }     return bean. }
true;public;2;15;/**  * Apply this post processor to the given new bean instance <i>after</i> any bean  * initialization callbacks (like <code>afterPropertiesSet</code>  * or a custom init-method). The bean will already be populated with property values.  * The returned bean instance may be a wrapper around the original.  *  * @param bean the new bean instance  * @param beanName the name of the bean  * @return the bean instance to use, either the original or a wrapped one. if  * <code>null</code>, no subsequent BeanPostProcessors will be invoked  * @throws Exception is thrown if error post processing bean  */ ;/**  * Apply this post processor to the given new bean instance <i>after</i> any bean  * initialization callbacks (like <code>afterPropertiesSet</code>  * or a custom init-method). The bean will already be populated with property values.  * The returned bean instance may be a wrapper around the original.  *  * @param bean the new bean instance  * @param beanName the name of the bean  * @return the bean instance to use, either the original or a wrapped one. if  * <code>null</code>, no subsequent BeanPostProcessors will be invoked  * @throws Exception is thrown if error post processing bean  */ public Object postProcessAfterInitialization(Object bean, String beanName) throws Exception {     LOG.trace("Camel bean processing after initialization for bean: {}", beanName).     // some beans cannot be post processed at this given time, so we gotta check beforehand     if (!canPostProcessBean(bean, beanName)) {         return bean.     }     if (bean instanceof DefaultEndpoint) {         DefaultEndpoint defaultEndpoint = (DefaultEndpoint) bean.         defaultEndpoint.setEndpointUriIfNotSpecified(beanName).     }     return bean. }
true;public;0;3;/**  * Strategy to get the {@link CamelContext} to use.  */ ;/**  * Strategy to get the {@link CamelContext} to use.  */ public CamelContext getOrLookupCamelContext() {     return camelContext. }
true;public;0;6;/**  * Strategy to get the {@link CamelPostProcessorHelper}  */ ;/**  * Strategy to get the {@link CamelPostProcessorHelper}  */ public CamelPostProcessorHelper getPostProcessorHelper() {     if (camelPostProcessorHelper == null) {         camelPostProcessorHelper = new CamelPostProcessorHelper(getOrLookupCamelContext()).     }     return camelPostProcessorHelper. }
false;protected;2;3;;protected boolean canPostProcessBean(Object bean, String beanName) {     return bean != null. }
false;protected;2;12;;protected boolean canSetCamelContext(Object bean, String beanName) {     if (bean instanceof CamelContextAware) {         CamelContextAware camelContextAware = (CamelContextAware) bean.         CamelContext context = camelContextAware.getCamelContext().         if (context != null) {             LOG.trace("CamelContext already set on bean with id [{}]. Will keep existing CamelContext on bean.", beanName).             return false.         }     }     return true. }
false;public;1;21;;public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {     PropertyInject propertyInject = field.getAnnotation(PropertyInject.class).     if (propertyInject != null && getPostProcessorHelper().matchContext(propertyInject.context())) {         injectFieldProperty(field, propertyInject.value(), propertyInject.defaultValue(), bean, beanName).     }     BeanInject beanInject = field.getAnnotation(BeanInject.class).     if (beanInject != null && getPostProcessorHelper().matchContext(beanInject.context())) {         injectFieldBean(field, beanInject.value(), bean, beanName).     }     EndpointInject endpointInject = field.getAnnotation(EndpointInject.class).     if (endpointInject != null && getPostProcessorHelper().matchContext(endpointInject.context())) {         injectField(field, endpointInject.uri(), endpointInject.ref(), endpointInject.property(), bean, beanName).     }     Produce produce = field.getAnnotation(Produce.class).     if (produce != null && getPostProcessorHelper().matchContext(produce.context())) {         injectField(field, produce.uri(), produce.ref(), produce.property(), bean, beanName, produce.binding()).     } }
true;protected;2;25;/**  * A strategy method to allow implementations to perform some custom JBI  * based injection of the POJO  *  * @param bean the bean to be injected  */ ;/**  * A strategy method to allow implementations to perform some custom JBI  * based injection of the POJO  *  * @param bean the bean to be injected  */ protected void injectFields(final Object bean, final String beanName) {     ReflectionHelper.doWithFields(bean.getClass(), new ReflectionHelper.FieldCallback() {          public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {             PropertyInject propertyInject = field.getAnnotation(PropertyInject.class).             if (propertyInject != null && getPostProcessorHelper().matchContext(propertyInject.context())) {                 injectFieldProperty(field, propertyInject.value(), propertyInject.defaultValue(), bean, beanName).             }             BeanInject beanInject = field.getAnnotation(BeanInject.class).             if (beanInject != null && getPostProcessorHelper().matchContext(beanInject.context())) {                 injectFieldBean(field, beanInject.value(), bean, beanName).             }             EndpointInject endpointInject = field.getAnnotation(EndpointInject.class).             if (endpointInject != null && getPostProcessorHelper().matchContext(endpointInject.context())) {                 injectField(field, endpointInject.uri(), endpointInject.ref(), endpointInject.property(), bean, beanName).             }             Produce produce = field.getAnnotation(Produce.class).             if (produce != null && getPostProcessorHelper().matchContext(produce.context())) {                 injectField(field, produce.uri(), produce.ref(), produce.property(), bean, beanName, produce.binding()).             }         }     }). }
false;public;6;4;;public void injectField(Field field, String endpointUri, String endpointRef, String endpointProperty, Object bean, String beanName) {     injectField(field, endpointUri, endpointRef, endpointProperty, bean, beanName, true). }
false;public;7;6;;public void injectField(Field field, String endpointUri, String endpointRef, String endpointProperty, Object bean, String beanName, boolean binding) {     ReflectionHelper.setField(field, bean, getPostProcessorHelper().getInjectionValue(field.getType(), endpointUri, endpointRef, endpointProperty, field.getName(), bean, beanName, binding)). }
false;public;4;4;;public void injectFieldBean(Field field, String name, Object bean, String beanName) {     ReflectionHelper.setField(field, bean, getPostProcessorHelper().getInjectionBeanValue(field.getType(), name)). }
false;public;5;5;;public void injectFieldProperty(Field field, String propertyName, String propertyDefaultValue, Object bean, String beanName) {     ReflectionHelper.setField(field, bean, getPostProcessorHelper().getInjectionPropertyValue(field.getType(), propertyName, propertyDefaultValue, field.getName(), bean, beanName)). }
false;public;1;4;;public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {     setterInjection(method, bean, beanName).     getPostProcessorHelper().consumerInjection(method, bean, beanName). }
false;protected;2;8;;protected void injectMethods(final Object bean, final String beanName) {     ReflectionHelper.doWithMethods(bean.getClass(), new ReflectionHelper.MethodCallback() {          public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {             setterInjection(method, bean, beanName).             getPostProcessorHelper().consumerInjection(method, bean, beanName).         }     }). }
false;protected;3;21;;protected void setterInjection(Method method, Object bean, String beanName) {     PropertyInject propertyInject = method.getAnnotation(PropertyInject.class).     if (propertyInject != null && getPostProcessorHelper().matchContext(propertyInject.context())) {         setterPropertyInjection(method, propertyInject.value(), propertyInject.defaultValue(), bean, beanName).     }     BeanInject beanInject = method.getAnnotation(BeanInject.class).     if (beanInject != null && getPostProcessorHelper().matchContext(beanInject.context())) {         setterBeanInjection(method, beanInject.value(), bean, beanName).     }     EndpointInject endpointInject = method.getAnnotation(EndpointInject.class).     if (endpointInject != null && getPostProcessorHelper().matchContext(endpointInject.context())) {         setterInjection(method, bean, beanName, endpointInject.uri(), endpointInject.ref(), endpointInject.property()).     }     Produce produce = method.getAnnotation(Produce.class).     if (produce != null && getPostProcessorHelper().matchContext(produce.context())) {         setterInjection(method, bean, beanName, produce.uri(), produce.ref(), produce.property()).     } }
false;public;6;13;;public void setterInjection(Method method, Object bean, String beanName, String endpointUri, String endpointRef, String endpointProperty) {     Class<?>[] parameterTypes = method.getParameterTypes().     if (parameterTypes != null) {         if (parameterTypes.length != 1) {             LOG.warn("Ignoring badly annotated method for injection due to incorrect number of parameters: {}", method).         } else {             String propertyName = org.apache.camel.util.ObjectHelper.getPropertyName(method).             Object value = getPostProcessorHelper().getInjectionValue(parameterTypes[0], endpointUri, endpointRef, endpointProperty, propertyName, bean, beanName).             ObjectHelper.invokeMethod(method, bean, value).         }     } }
false;public;5;13;;public void setterPropertyInjection(Method method, String propertyValue, String propertyDefaultValue, Object bean, String beanName) {     Class<?>[] parameterTypes = method.getParameterTypes().     if (parameterTypes != null) {         if (parameterTypes.length != 1) {             LOG.warn("Ignoring badly annotated method for injection due to incorrect number of parameters: {}", method).         } else {             String propertyName = org.apache.camel.util.ObjectHelper.getPropertyName(method).             Object value = getPostProcessorHelper().getInjectionPropertyValue(parameterTypes[0], propertyValue, propertyDefaultValue, propertyName, bean, beanName).             ObjectHelper.invokeMethod(method, bean, value).         }     } }
false;public;4;11;;public void setterBeanInjection(Method method, String name, Object bean, String beanName) {     Class<?>[] parameterTypes = method.getParameterTypes().     if (parameterTypes != null) {         if (parameterTypes.length != 1) {             LOG.warn("Ignoring badly annotated method for injection due to incorrect number of parameters: {}", method).         } else {             Object value = getPostProcessorHelper().getInjectionBeanValue(parameterTypes[0], name).             ObjectHelper.invokeMethod(method, bean, value).         }     } }
