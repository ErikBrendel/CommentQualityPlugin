commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Exchange getExchange() {     return exchange. }
false;public;0;3;;public CountDownLatch getLatch() {     return latch. }
true;public,static;1;3;/**  * Creates a new backlog debugger.  *  * @param context Camel context  * @return a new backlog debugger  */ ;/**  * Creates a new backlog debugger.  *  * @param context Camel context  * @return a new backlog debugger  */ public static BacklogDebugger createDebugger(CamelContext context) {     return new BacklogDebugger(context). }
true;public,static;1;3;/**  * A helper method to return the BacklogDebugger instance if one is enabled  *  * @return the backlog debugger or null if none can be found  */ ;/**  * A helper method to return the BacklogDebugger instance if one is enabled  *  * @return the backlog debugger or null if none can be found  */ public static BacklogDebugger getBacklogDebugger(CamelContext context) {     return context.hasService(BacklogDebugger.class). }
false;public;0;3;;public Debugger getDebugger() {     return debugger. }
false;public;0;3;;public String getLoggingLevel() {     return loggingLevel.name(). }
false;public;1;4;;public void setLoggingLevel(String level) {     loggingLevel = LoggingLevel.valueOf(level).     logger.setLevel(loggingLevel). }
false;public;0;9;;public void enableDebugger() {     logger.log("Enabling debugger").     try {         ServiceHelper.startService(debugger).         enabled.set(true).     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;public;0;10;;public void disableDebugger() {     logger.log("Disabling debugger").     try {         enabled.set(false).         ServiceHelper.stopService(debugger).     } catch (Exception e) {     // ignore     }     clearBreakpoints(). }
false;public;0;3;;public boolean isEnabled() {     return enabled.get(). }
false;public;1;3;;public boolean hasBreakpoint(String nodeId) {     return breakpoints.containsKey(nodeId). }
false;public;0;3;;public boolean isSingleStepMode() {     return singleStepExchangeId != null. }
false;public;1;11;;public void addBreakpoint(String nodeId) {     NodeBreakpoint breakpoint = breakpoints.get(nodeId).     if (breakpoint == null) {         logger.log("Adding breakpoint " + nodeId).         breakpoint = new NodeBreakpoint(nodeId, null).         breakpoints.put(nodeId, breakpoint).         debugger.addBreakpoint(breakpoint, breakpoint).     } else {         breakpoint.setCondition(null).     } }
false;public;3;18;;public void addConditionalBreakpoint(String nodeId, String language, String predicate) {     Predicate condition = camelContext.resolveLanguage(language).createPredicate(predicate).     NodeBreakpoint breakpoint = breakpoints.get(nodeId).     if (breakpoint == null) {         logger.log("Adding conditional breakpoint " + nodeId + " [" + predicate + "]").         breakpoint = new NodeBreakpoint(nodeId, condition).         breakpoints.put(nodeId, breakpoint).         debugger.addBreakpoint(breakpoint, breakpoint).     } else if (breakpoint.getCondition() == null) {         logger.log("Updating to conditional breakpoint " + nodeId + " [" + predicate + "]").         debugger.removeBreakpoint(breakpoint).         breakpoints.put(nodeId, breakpoint).         debugger.addBreakpoint(breakpoint, breakpoint).     } else if (breakpoint.getCondition() != null) {         logger.log("Updating conditional breakpoint " + nodeId + " [" + predicate + "]").         breakpoint.setCondition(condition).     } }
false;public;1;13;;public void removeBreakpoint(String nodeId) {     logger.log("Removing breakpoint " + nodeId).     // when removing a break point then ensure latches is cleared and counted down so we wont have hanging threads     suspendedBreakpointMessages.remove(nodeId).     SuspendedExchange se = suspendedBreakpoints.remove(nodeId).     NodeBreakpoint breakpoint = breakpoints.remove(nodeId).     if (breakpoint != null) {         debugger.removeBreakpoint(breakpoint).     }     if (se != null) {         se.getLatch().countDown().     } }
false;public;0;8;;public void removeAllBreakpoints() {     // stop single stepping     singleStepExchangeId = null.     for (String nodeId : getSuspendedBreakpointNodeIds()) {         removeBreakpoint(nodeId).     } }
false;public;0;3;;public Set<String> getBreakpoints() {     return new LinkedHashSet<>(breakpoints.keySet()). }
false;public;1;3;;public void resumeBreakpoint(String nodeId) {     resumeBreakpoint(nodeId, false). }
false;private;2;17;;private void resumeBreakpoint(String nodeId, boolean stepMode) {     logger.log("Resume breakpoint " + nodeId).     if (!stepMode) {         if (singleStepExchangeId != null) {             debugger.stopSingleStepExchange(singleStepExchangeId).             singleStepExchangeId = null.         }     }     // remember to remove the dumped message as its no longer in need     suspendedBreakpointMessages.remove(nodeId).     SuspendedExchange se = suspendedBreakpoints.remove(nodeId).     if (se != null) {         se.getLatch().countDown().     } }
false;public;2;17;;public void setMessageBodyOnBreakpoint(String nodeId, Object body) {     SuspendedExchange se = suspendedBreakpoints.get(nodeId).     if (se != null) {         boolean remove = body == null.         if (remove) {             removeMessageBodyOnBreakpoint(nodeId).         } else {             Class<?> oldType.             if (se.getExchange().hasOut()) {                 oldType = se.getExchange().getOut().getBody() != null ? se.getExchange().getOut().getBody().getClass() : null.             } else {                 oldType = se.getExchange().getIn().getBody() != null ? se.getExchange().getIn().getBody().getClass() : null.             }             setMessageBodyOnBreakpoint(nodeId, body, oldType).         }     } }
false;public;3;25;;public void setMessageBodyOnBreakpoint(String nodeId, Object body, Class<?> type) {     SuspendedExchange se = suspendedBreakpoints.get(nodeId).     if (se != null) {         boolean remove = body == null.         if (remove) {             removeMessageBodyOnBreakpoint(nodeId).         } else {             logger.log("Breakpoint at node " + nodeId + " is updating message body on exchangeId: " + se.getExchange().getExchangeId() + " with new body: " + body).             if (se.getExchange().hasOut()) {                 // preserve type                 if (type != null) {                     se.getExchange().getOut().setBody(body, type).                 } else {                     se.getExchange().getOut().setBody(body).                 }             } else {                 if (type != null) {                     se.getExchange().getIn().setBody(body, type).                 } else {                     se.getExchange().getIn().setBody(body).                 }             }         }     } }
false;public;1;11;;public void removeMessageBodyOnBreakpoint(String nodeId) {     SuspendedExchange se = suspendedBreakpoints.get(nodeId).     if (se != null) {         logger.log("Breakpoint at node " + nodeId + " is removing message body on exchangeId: " + se.getExchange().getExchangeId()).         if (se.getExchange().hasOut()) {             se.getExchange().getOut().setBody(null).         } else {             se.getExchange().getIn().setBody(null).         }     } }
false;public;3;12;;public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, Object value) throws NoTypeConversionAvailableException {     SuspendedExchange se = suspendedBreakpoints.get(nodeId).     if (se != null) {         Class<?> oldType.         if (se.getExchange().hasOut()) {             oldType = se.getExchange().getOut().getHeader(headerName) != null ? se.getExchange().getOut().getHeader(headerName).getClass() : null.         } else {             oldType = se.getExchange().getIn().getHeader(headerName) != null ? se.getExchange().getIn().getHeader(headerName).getClass() : null.         }         setMessageHeaderOnBreakpoint(nodeId, headerName, value, oldType).     } }
false;public;4;21;;public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, Object value, Class<?> type) throws NoTypeConversionAvailableException {     SuspendedExchange se = suspendedBreakpoints.get(nodeId).     if (se != null) {         logger.log("Breakpoint at node " + nodeId + " is updating message header on exchangeId: " + se.getExchange().getExchangeId() + " with header: " + headerName + " and value: " + value).         if (se.getExchange().hasOut()) {             if (type != null) {                 Object convertedValue = se.getExchange().getContext().getTypeConverter().mandatoryConvertTo(type, se.getExchange(), value).                 se.getExchange().getOut().setHeader(headerName, convertedValue).             } else {                 se.getExchange().getOut().setHeader(headerName, value).             }         } else {             if (type != null) {                 Object convertedValue = se.getExchange().getContext().getTypeConverter().mandatoryConvertTo(type, se.getExchange(), value).                 se.getExchange().getIn().setHeader(headerName, convertedValue).             } else {                 se.getExchange().getIn().setHeader(headerName, value).             }         }     } }
false;public;0;3;;public long getFallbackTimeout() {     return fallbackTimeout. }
false;public;1;3;;public void setFallbackTimeout(long fallbackTimeout) {     this.fallbackTimeout = fallbackTimeout. }
false;public;2;11;;public void removeMessageHeaderOnBreakpoint(String nodeId, String headerName) {     SuspendedExchange se = suspendedBreakpoints.get(nodeId).     if (se != null) {         logger.log("Breakpoint at node " + nodeId + " is removing message header on exchangeId: " + se.getExchange().getExchangeId() + " with header: " + headerName).         if (se.getExchange().hasOut()) {             se.getExchange().getOut().removeHeader(headerName).         } else {             se.getExchange().getIn().removeHeader(headerName).         }     } }
false;public;0;14;;public void resumeAll() {     logger.log("Resume all").     // stop single stepping     singleStepExchangeId = null.     for (String node : getSuspendedBreakpointNodeIds()) {         // remember to remove the dumped message as its no longer in need         suspendedBreakpointMessages.remove(node).         SuspendedExchange se = suspendedBreakpoints.remove(node).         if (se != null) {             se.getLatch().countDown().         }     } }
false;public;1;19;;public void stepBreakpoint(String nodeId) {     // if we are already in single step mode, then infer stepping     if (isSingleStepMode()) {         logger.log("stepBreakpoint " + nodeId + " is already in single step mode, so stepping instead.").         step().     }     logger.log("Step breakpoint " + nodeId).     // we want to step current exchange to next     BacklogTracerEventMessage msg = suspendedBreakpointMessages.get(nodeId).     NodeBreakpoint breakpoint = breakpoints.get(nodeId).     if (msg != null && breakpoint != null) {         singleStepExchangeId = msg.getExchangeId().         if (debugger.startSingleStepExchange(singleStepExchangeId, new StepBreakpoint())) {             // now resume             resumeBreakpoint(nodeId, true).         }     } }
false;public;0;10;;public void step() {     for (String node : getSuspendedBreakpointNodeIds()) {         // remember to remove the dumped message as its no longer in need         suspendedBreakpointMessages.remove(node).         SuspendedExchange se = suspendedBreakpoints.remove(node).         if (se != null) {             se.getLatch().countDown().         }     } }
false;public;0;3;;public Set<String> getSuspendedBreakpointNodeIds() {     return new LinkedHashSet<>(suspendedBreakpoints.keySet()). }
true;public;1;4;/**  * Gets the exchanged suspended at the given breakpoint id or null if there is none at that id.  *  * @param id - node id for the breakpoint  * @return The suspended exchange or null if there isn't one suspended at the given breakpoint.  */ ;/**  * Gets the exchanged suspended at the given breakpoint id or null if there is none at that id.  *  * @param id - node id for the breakpoint  * @return The suspended exchange or null if there isn't one suspended at the given breakpoint.  */ public Exchange getSuspendedExchange(String id) {     SuspendedExchange suspendedExchange = suspendedBreakpoints.get(id).     return suspendedExchange != null ? suspendedExchange.getExchange() : null. }
false;public;1;7;;public void disableBreakpoint(String nodeId) {     logger.log("Disable breakpoint " + nodeId).     NodeBreakpoint breakpoint = breakpoints.get(nodeId).     if (breakpoint != null) {         breakpoint.suspend().     } }
false;public;1;7;;public void enableBreakpoint(String nodeId) {     logger.log("Enable breakpoint " + nodeId).     NodeBreakpoint breakpoint = breakpoints.get(nodeId).     if (breakpoint != null) {         breakpoint.activate().     } }
false;public;0;3;;public int getBodyMaxChars() {     return bodyMaxChars. }
false;public;1;3;;public void setBodyMaxChars(int bodyMaxChars) {     this.bodyMaxChars = bodyMaxChars. }
false;public;0;3;;public boolean isBodyIncludeStreams() {     return bodyIncludeStreams. }
false;public;1;3;;public void setBodyIncludeStreams(boolean bodyIncludeStreams) {     this.bodyIncludeStreams = bodyIncludeStreams. }
false;public;0;3;;public boolean isBodyIncludeFiles() {     return bodyIncludeFiles. }
false;public;1;3;;public void setBodyIncludeFiles(boolean bodyIncludeFiles) {     this.bodyIncludeFiles = bodyIncludeFiles. }
false;public;1;9;;public String dumpTracedMessagesAsXml(String nodeId) {     logger.log("Dump trace message from breakpoint " + nodeId).     BacklogTracerEventMessage msg = suspendedBreakpointMessages.get(nodeId).     if (msg != null) {         return msg.toXml(0).     } else {         return null.     } }
false;public;0;3;;public long getDebugCounter() {     return debugCounter.get(). }
false;public;0;4;;public void resetDebugCounter() {     logger.log("Reset debug counter").     debugCounter.set(0). }
false;public;3;3;;public boolean beforeProcess(Exchange exchange, Processor processor, ProcessorDefinition<?> definition) {     return debugger.beforeProcess(exchange, processor, definition). }
false;public;4;4;;public boolean afterProcess(Exchange exchange, Processor processor, ProcessorDefinition<?> definition, long timeTaken) {     // noop     return false. }
false;protected;0;3;;protected void doStart() throws Exception { // noop }
false;protected;0;6;;protected void doStop() throws Exception {     if (enabled.get()) {         disableDebugger().     }     clearBreakpoints(). }
false;private;0;9;;private void clearBreakpoints() {     // make sure to clear state and latches is counted down so we wont have hanging threads     breakpoints.clear().     for (SuspendedExchange se : suspendedBreakpoints.values()) {         se.getLatch().countDown().     }     suspendedBreakpoints.clear().     suspendedBreakpointMessages.clear(). }
false;public;0;3;;public Predicate getCondition() {     return condition. }
false;public;1;3;;public void setCondition(Predicate predicate) {     this.condition = predicate. }
false;public;3;30;;@Override public void beforeProcess(Exchange exchange, Processor processor, NamedNode definition) {     // store a copy of the message so we can see that from the debugger     Date timestamp = new Date().     String toNode = definition.getId().     String routeId = ProcessorDefinitionHelper.getRouteId(definition).     String exchangeId = exchange.getExchangeId().     String messageAsXml = MessageHelper.dumpAsXml(exchange.getIn(), true, 2, isBodyIncludeStreams(), isBodyIncludeFiles(), getBodyMaxChars()).     long uid = debugCounter.incrementAndGet().     BacklogTracerEventMessage msg = new DefaultBacklogTracerEventMessage(uid, timestamp, routeId, toNode, exchangeId, messageAsXml).     suspendedBreakpointMessages.put(nodeId, msg).     // suspend at this breakpoint     final SuspendedExchange se = suspendedBreakpoints.get(nodeId).     if (se != null) {         // now wait until we should continue         logger.log("NodeBreakpoint at node " + toNode + " is waiting to continue for exchangeId: " + exchangeId).         try {             boolean hit = se.getLatch().await(fallbackTimeout, TimeUnit.SECONDS).             if (!hit) {                 logger.log("NodeBreakpoint at node " + toNode + " timed out and is continued exchangeId: " + exchangeId, LoggingLevel.WARN).             } else {                 logger.log("NodeBreakpoint at node " + toNode + " is continued exchangeId: " + exchangeId).             }         } catch (InterruptedException e) {         // ignore         }     } }
false;public;3;17;;@Override public boolean matchProcess(Exchange exchange, Processor processor, NamedNode definition) {     // must match node     if (!nodeId.equals(definition.getId())) {         return false.     }     // if condition then must match     if (condition != null && !condition.matches(exchange)) {         return false.     }     // we only want to break one exchange at a time, so if there is already a suspended breakpoint then do not match     SuspendedExchange se = new SuspendedExchange(exchange, new CountDownLatch(1)).     boolean existing = suspendedBreakpoints.putIfAbsent(nodeId, se) != null.     return !existing. }
false;public;2;4;;@Override public boolean matchEvent(Exchange exchange, ExchangeEvent event) {     return false. }
false;public;3;30;;@Override public void beforeProcess(Exchange exchange, Processor processor, NamedNode definition) {     // store a copy of the message so we can see that from the debugger     Date timestamp = new Date().     String toNode = definition.getId().     String routeId = ProcessorDefinitionHelper.getRouteId(definition).     String exchangeId = exchange.getExchangeId().     String messageAsXml = MessageHelper.dumpAsXml(exchange.getIn(), true, 2, isBodyIncludeStreams(), isBodyIncludeFiles(), getBodyMaxChars()).     long uid = debugCounter.incrementAndGet().     BacklogTracerEventMessage msg = new DefaultBacklogTracerEventMessage(uid, timestamp, routeId, toNode, exchangeId, messageAsXml).     suspendedBreakpointMessages.put(toNode, msg).     // suspend at this breakpoint     SuspendedExchange se = new SuspendedExchange(exchange, new CountDownLatch(1)).     suspendedBreakpoints.put(toNode, se).     // now wait until we should continue     logger.log("StepBreakpoint at node " + toNode + " is waiting to continue for exchangeId: " + exchange.getExchangeId()).     try {         boolean hit = se.getLatch().await(fallbackTimeout, TimeUnit.SECONDS).         if (!hit) {             logger.log("StepBreakpoint at node " + toNode + " timed out and is continued exchangeId: " + exchange.getExchangeId(), LoggingLevel.WARN).         } else {             logger.log("StepBreakpoint at node " + toNode + " is continued exchangeId: " + exchange.getExchangeId()).         }     } catch (InterruptedException e) {     // ignore     } }
false;public;3;4;;@Override public boolean matchProcess(Exchange exchange, Processor processor, NamedNode definition) {     return true. }
false;public;2;4;;@Override public boolean matchEvent(Exchange exchange, ExchangeEvent event) {     return event instanceof ExchangeCompletedEvent. }
false;public;3;12;;@Override public void onEvent(Exchange exchange, ExchangeEvent event, NamedNode definition) {     // when the exchange is complete, we need to turn off single step mode if we were debug stepping the exchange     if (event instanceof ExchangeCompletedEvent) {         String completedId = event.getExchange().getExchangeId().         if (singleStepExchangeId != null && singleStepExchangeId.equals(completedId)) {             logger.log("ExchangeId: " + completedId + " is completed, so exiting single step mode.").             singleStepExchangeId = null.         }     } }
