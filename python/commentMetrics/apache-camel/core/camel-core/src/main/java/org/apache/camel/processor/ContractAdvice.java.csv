commented;modifiers;parameterAmount;loc;comment;code
false;public;1;25;;@Override public Object before(Exchange exchange) throws Exception {     if (!(exchange.getIn() instanceof DataTypeAware)) {         return null.     }     try {         DataType to = contract.getInputType().         if (to != null) {             DataTypeAware target = (DataTypeAware) exchange.getIn().             DataType from = target.getDataType().             if (!to.equals(from)) {                 LOG.debug("Looking for transformer for INPUT: from='{}', to='{}'", from, to).                 doTransform(exchange.getIn(), from, to).                 target.setDataType(to).             }             if (contract.isValidateInput()) {                 doValidate(exchange.getIn(), to).             }         }     } catch (Exception e) {         exchange.setException(e).     }     return null. }
false;public;2;29;;@Override public void after(Exchange exchange, Object data) throws Exception {     if (exchange.isFailed()) {         // TODO can we add FAULT_TYPE processing?         return.     }     Message target = exchange.hasOut() ? exchange.getOut() : exchange.getIn().     if (!(target instanceof DataTypeAware)) {         return.     }     try {         DataType to = contract.getOutputType().         if (to != null) {             DataTypeAware typeAwareTarget = (DataTypeAware) target.             DataType from = typeAwareTarget.getDataType().             if (!to.equals(from)) {                 LOG.debug("Looking for transformer for OUTPUT: from='{}', to='{}'", from, to).                 doTransform(target, from, to).                 typeAwareTarget.setDataType(to).             }             if (contract.isValidateOutput()) {                 doValidate(target, to).             }         }     } catch (Exception e) {         exchange.setException(e).     } }
false;private;3;27;;private void doTransform(Message message, DataType from, DataType to) throws Exception {     if (from == null) {         // If 'from' is null, only Java-Java convertion is performed.         // It means if 'to' is other than Java, it's assumed to be already in expected type.         convertIfRequired(message, to).         return.     }     // transform into 'from' type before performing declared transformation     convertIfRequired(message, from).     if (applyMatchedTransformer(message, from, to)) {         // Found matched transformer. Java-Java transformer is also allowed.         return.     } else if (from.isJavaType()) {         // Try TypeConverter as a fallback for Java->Java transformation         convertIfRequired(message, to).         // then assume it's already in expected type, i.e. do nothing.         return.     } else if (applyTransformerChain(message, from, to)) {         // Other->Other transformation - found a transformer chain         return.     }     throw new IllegalArgumentException("No Transformer found for [from='" + from + "', to='" + to + "']"). }
false;private;2;14;;private boolean convertIfRequired(Message message, DataType type) throws Exception {     // into transformer registry automatically to avoid unnecessary scan in transformer registry     if (type != null && type.isJavaType() && type.getName() != null) {         CamelContext context = message.getExchange().getContext().         Class<?> typeJava = getClazz(type.getName(), context).         if (!typeJava.isAssignableFrom(message.getBody().getClass())) {             LOG.debug("Converting to '{}'", typeJava.getName()).             message.setBody(message.getMandatoryBody(typeJava)).             return true.         }     }     return false. }
false;private;4;8;;private boolean applyTransformer(Transformer transformer, Message message, DataType from, DataType to) throws Exception {     if (transformer != null) {         LOG.debug("Applying transformer: from='{}', to='{}', transformer='{}'", from, to, transformer).         transformer.transform(message, from, to).         return true.     }     return false. }
false;private;3;4;;private boolean applyMatchedTransformer(Message message, DataType from, DataType to) throws Exception {     Transformer transformer = message.getExchange().getContext().resolveTransformer(from, to).     return applyTransformer(transformer, message, from, to). }
false;private;3;13;;private boolean applyTransformerChain(Message message, DataType from, DataType to) throws Exception {     CamelContext context = message.getExchange().getContext().     Transformer fromTransformer = context.resolveTransformer(from.getModel()).     Transformer toTransformer = context.resolveTransformer(to.getModel()).     if (fromTransformer != null && toTransformer != null) {         LOG.debug("Applying transformer 1/2: from='{}', to='{}', transformer='{}'", from, to, fromTransformer).         fromTransformer.transform(message, from, new DataType(Object.class)).         LOG.debug("Applying transformer 2/2: from='{}', to='{}', transformer='{}'", from, to, toTransformer).         toTransformer.transform(message, new DataType(Object.class), to).         return true.     }     return false. }
false;private;2;3;;private Class<?> getClazz(String type, CamelContext context) throws Exception {     return context.getClassResolver().resolveMandatoryClass(type). }
false;private;2;9;;private void doValidate(Message message, DataType type) throws ValidationException {     Validator validator = message.getExchange().getContext().resolveValidator(type).     if (validator != null) {         LOG.debug("Applying validator: type='{}', validator='{}'", type, validator).         validator.validate(message, type).     } else {         throw new ValidationException(message.getExchange(), String.format("No Validator found for '%s'", type)).     } }
