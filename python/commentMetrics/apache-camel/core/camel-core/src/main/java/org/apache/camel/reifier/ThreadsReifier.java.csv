commented;modifiers;parameterAmount;loc;comment;code
false;public;1;63;;@Override public Processor createProcessor(RouteContext routeContext) throws Exception {     // the threads name     String name = definition.getThreadName() != null ? definition.getThreadName() : "Threads".     // prefer any explicit configured executor service     boolean shutdownThreadPool = ProcessorDefinitionHelper.willCreateNewThreadPool(routeContext, definition, true).     ExecutorService threadPool = ProcessorDefinitionHelper.getConfiguredExecutorService(routeContext, name, definition, false).     // resolve what rejected policy to use     ThreadPoolRejectedPolicy policy = resolveRejectedPolicy(routeContext).     if (policy == null) {         if (definition.getCallerRunsWhenRejected() == null || definition.getCallerRunsWhenRejected()) {             // should use caller runs by default if not configured             policy = ThreadPoolRejectedPolicy.CallerRuns.         } else {             policy = ThreadPoolRejectedPolicy.Abort.         }     }     log.debug("Using ThreadPoolRejectedPolicy: {}", policy).     // if no explicit then create from the options     if (threadPool == null) {         ExecutorServiceManager manager = routeContext.getCamelContext().getExecutorServiceManager().         // create the thread pool using a builder         ThreadPoolProfile profile = new ThreadPoolProfileBuilder(name).poolSize(definition.getPoolSize()).maxPoolSize(definition.getMaxPoolSize()).keepAliveTime(definition.getKeepAliveTime(), definition.getTimeUnit()).maxQueueSize(definition.getMaxQueueSize()).rejectedPolicy(policy).allowCoreThreadTimeOut(definition.getAllowCoreThreadTimeOut()).build().         threadPool = manager.newThreadPool(definition, name, profile).         shutdownThreadPool = true.     } else {         if (definition.getThreadName() != null && !definition.getThreadName().equals("Threads")) {             throw new IllegalArgumentException("ThreadName and executorServiceRef options cannot be used together.").         }         if (definition.getPoolSize() != null) {             throw new IllegalArgumentException("PoolSize and executorServiceRef options cannot be used together.").         }         if (definition.getMaxPoolSize() != null) {             throw new IllegalArgumentException("MaxPoolSize and executorServiceRef options cannot be used together.").         }         if (definition.getKeepAliveTime() != null) {             throw new IllegalArgumentException("KeepAliveTime and executorServiceRef options cannot be used together.").         }         if (definition.getTimeUnit() != null) {             throw new IllegalArgumentException("TimeUnit and executorServiceRef options cannot be used together.").         }         if (definition.getMaxQueueSize() != null) {             throw new IllegalArgumentException("MaxQueueSize and executorServiceRef options cannot be used together.").         }         if (definition.getRejectedPolicy() != null) {             throw new IllegalArgumentException("RejectedPolicy and executorServiceRef options cannot be used together.").         }         if (definition.getAllowCoreThreadTimeOut() != null) {             throw new IllegalArgumentException("AllowCoreThreadTimeOut and executorServiceRef options cannot be used together.").         }     }     return new ThreadsProcessor(routeContext.getCamelContext(), threadPool, shutdownThreadPool, policy). }
false;protected;1;9;;protected ThreadPoolRejectedPolicy resolveRejectedPolicy(RouteContext routeContext) {     if (definition.getExecutorServiceRef() != null && definition.getRejectedPolicy() == null) {         ThreadPoolProfile threadPoolProfile = routeContext.getCamelContext().getExecutorServiceManager().getThreadPoolProfile(definition.getExecutorServiceRef()).         if (threadPoolProfile != null) {             return threadPoolProfile.getRejectedPolicy().         }     }     return definition.getRejectedPolicy(). }
