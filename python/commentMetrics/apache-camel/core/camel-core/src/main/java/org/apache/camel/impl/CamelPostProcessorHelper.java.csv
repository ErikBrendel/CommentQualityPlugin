commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;1;3;;public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
true;public;1;8;/**  * Does the given context match this camel context  */ ;/**  * Does the given context match this camel context  */ public boolean matchContext(String context) {     if (ObjectHelper.isNotEmpty(context)) {         if (!getCamelContext().getName().equals(context)) {             return false.         }     }     return true. }
false;public;3;7;;public void consumerInjection(Method method, Object bean, String beanName) {     Consume consume = method.getAnnotation(Consume.class).     if (consume != null && matchContext(consume.context())) {         LOG.debug("Creating a consumer for: {}", consume).         subscribeMethod(method, bean, beanName, consume.uri(), consume.ref(), consume.property(), consume.predicate()).     } }
false;public;7;34;;public void subscribeMethod(Method method, Object bean, String beanName, String endpointUri, String endpointName, String endpointProperty, String predicate) {     // lets bind this method to a listener     String injectionPointName = method.getName().     Endpoint endpoint = getEndpointInjection(bean, endpointUri, endpointName, endpointProperty, injectionPointName, true).     if (endpoint != null) {         boolean multipleConsumer = false.         if (endpoint instanceof MultipleConsumersSupport) {             multipleConsumer = ((MultipleConsumersSupport) endpoint).isMultipleConsumersSupported().         }         try {             SubscribeMethodProcessor processor = getConsumerProcessor(endpoint).             // if multiple consumer then create a new consumer per subscribed method             if (multipleConsumer || processor == null) {                 // create new processor and new consumer which happens the first time                 processor = new SubscribeMethodProcessor(endpoint).                 // make sure processor is registered in registry so we can reuse it (eg we can look it up)                 endpoint.getCamelContext().addService(processor, true).                 processor.addMethod(bean, method, endpoint, predicate).                 Consumer consumer = endpoint.createConsumer(processor).                 startService(consumer, endpoint.getCamelContext(), bean, beanName).             } else {                 // add method to existing processor                 processor.addMethod(bean, method, endpoint, predicate).             }             if (predicate != null) {                 LOG.debug("Subscribed method: {} to consume from endpoint: {} with predicate: {}", method, endpoint, predicate).             } else {                 LOG.debug("Subscribed method: {} to consume from endpoint: {}", method, endpoint).             }         } catch (Exception e) {             throw RuntimeCamelException.wrapRuntimeCamelException(e).         }     } }
true;protected;4;14;/**  * Stats the given service  */ ;/**  * Stats the given service  */ protected void startService(Service service, CamelContext camelContext, Object bean, String beanName) throws Exception {     // defer starting the service until CamelContext has started all its initial services     if (camelContext != null) {         camelContext.deferStartService(service, true).     } else {         // mo CamelContext then start service manually         ServiceHelper.startService(service).     }     boolean singleton = isSingleton(bean, beanName).     if (!singleton) {         LOG.debug("Service is not singleton so you must remember to stop it manually {}", service).     } }
false;protected;1;4;;protected SubscribeMethodProcessor getConsumerProcessor(Endpoint endpoint) {     Set<SubscribeMethodProcessor> processors = endpoint.getCamelContext().hasServices(SubscribeMethodProcessor.class).     return processors.stream().filter(s -> s.getEndpoint() == endpoint).findFirst().orElse(null). }
false;public;6;9;;public Endpoint getEndpointInjection(Object bean, String uri, String name, String propertyName, String injectionPointName, boolean mandatory) {     if (ObjectHelper.isEmpty(uri) && ObjectHelper.isEmpty(name)) {         // if no uri or ref, then fallback and try the endpoint property         return doGetEndpointInjection(bean, propertyName, injectionPointName).     } else {         return doGetEndpointInjection(uri, name, injectionPointName, mandatory).     } }
false;private;4;3;;private Endpoint doGetEndpointInjection(String uri, String name, String injectionPointName, boolean mandatory) {     return CamelContextHelper.getEndpointInjection(getCamelContext(), uri, name, injectionPointName, mandatory). }
true;private;3;33;/**  * Gets the injection endpoint from a bean property.  *  * @param bean the bean  * @param propertyName the property name on the bean  */ ;/**  * Gets the injection endpoint from a bean property.  *  * @param bean the bean  * @param propertyName the property name on the bean  */ private Endpoint doGetEndpointInjection(Object bean, String propertyName, String injectionPointName) {     // fall back and use the method name if no explicit property name was given     if (ObjectHelper.isEmpty(propertyName)) {         propertyName = injectionPointName.     }     // 3. then if start with on then try step 1 and 2 again, but omit the on prefix     try {         Object value = IntrospectionSupport.getOrElseProperty(bean, propertyName, null).         if (value == null) {             // try endpoint as postfix             value = IntrospectionSupport.getOrElseProperty(bean, propertyName + "Endpoint", null).         }         if (value == null && propertyName.startsWith("on")) {             // retry but without the on as prefix             propertyName = propertyName.substring(2).             return doGetEndpointInjection(bean, propertyName, injectionPointName).         }         if (value == null) {             return null.         } else if (value instanceof Endpoint) {             return (Endpoint) value.         } else {             String uriOrRef = getCamelContext().getTypeConverter().mandatoryConvertTo(String.class, value).             return getCamelContext().getEndpoint(uriOrRef).         }     } catch (Exception e) {         throw new IllegalArgumentException("Error getting property " + propertyName + " from bean " + bean + " due " + e.getMessage(), e).     } }
true;public;7;4;/**  * Creates the object to be injected for an  * {@link org.apache.camel.EndpointInject} or  * {@link org.apache.camel.Produce} injection point  */ ;/**  * Creates the object to be injected for an  * {@link org.apache.camel.EndpointInject} or  * {@link org.apache.camel.Produce} injection point  */ public Object getInjectionValue(Class<?> type, String endpointUri, String endpointRef, String endpointProperty, String injectionPointName, Object bean, String beanName) {     return getInjectionValue(type, endpointUri, endpointRef, endpointProperty, injectionPointName, bean, beanName, true). }
true;public;8;32;/**  * Creates the object to be injected for an  * {@link org.apache.camel.EndpointInject} or  * {@link org.apache.camel.Produce} injection point  */ ;/**  * Creates the object to be injected for an  * {@link org.apache.camel.EndpointInject} or  * {@link org.apache.camel.Produce} injection point  */ public Object getInjectionValue(Class<?> type, String endpointUri, String endpointRef, String endpointProperty, String injectionPointName, Object bean, String beanName, boolean binding) {     if (type.isAssignableFrom(ProducerTemplate.class)) {         return createInjectionProducerTemplate(endpointUri, endpointRef, endpointProperty, injectionPointName, bean).     } else if (type.isAssignableFrom(FluentProducerTemplate.class)) {         return createInjectionFluentProducerTemplate(endpointUri, endpointRef, endpointProperty, injectionPointName, bean).     } else if (type.isAssignableFrom(ConsumerTemplate.class)) {         return createInjectionConsumerTemplate(endpointUri, endpointRef, endpointProperty, injectionPointName).     } else {         Endpoint endpoint = getEndpointInjection(bean, endpointUri, endpointRef, endpointProperty, injectionPointName, true).         if (endpoint != null) {             if (type.isInstance(endpoint)) {                 return endpoint.             } else if (type.isAssignableFrom(Producer.class)) {                 return createInjectionProducer(endpoint, bean, beanName).             } else if (type.isAssignableFrom(PollingConsumer.class)) {                 return createInjectionPollingConsumer(endpoint, bean, beanName).             } else if (type.isInterface()) {                 // lets create a proxy                 try {                     return ProxyHelper.createProxy(endpoint, binding, type).                 } catch (Exception e) {                     throw createProxyInstantiationRuntimeException(type, endpoint, e).                 }             } else {                 throw new IllegalArgumentException("Invalid type: " + type.getName() + " which cannot be injected via @EndpointInject/@Produce for: " + endpoint).             }         }         return null.     } }
false;public;6;33;;public Object getInjectionPropertyValue(Class<?> type, String propertyName, String propertyDefaultValue, String injectionPointName, Object bean, String beanName) {     try {         // enforce a properties component to be created if none existed         getCamelContext().getPropertiesComponent(true).         String key.         String prefix = getCamelContext().getPropertyPrefixToken().         String suffix = getCamelContext().getPropertySuffixToken().         if (!propertyName.contains(prefix)) {             // must enclose the property name with prefix/suffix to have it resolved             key = prefix + propertyName + suffix.         } else {             // key has already prefix/suffix so use it as-is as it may be a compound key             key = propertyName.         }         String value = getCamelContext().resolvePropertyPlaceholders(key).         if (value != null) {             return getCamelContext().getTypeConverter().mandatoryConvertTo(type, value).         } else {             return null.         }     } catch (Exception e) {         if (ObjectHelper.isNotEmpty(propertyDefaultValue)) {             try {                 return getCamelContext().getTypeConverter().mandatoryConvertTo(type, propertyDefaultValue).             } catch (Exception e2) {                 throw RuntimeCamelException.wrapRuntimeCamelException(e2).             }         }         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;public;2;15;;public Object getInjectionBeanValue(Class<?> type, String name) {     if (ObjectHelper.isEmpty(name)) {         Set<?> found = getCamelContext().getRegistry().findByType(type).         if (found == null || found.isEmpty()) {             throw new NoSuchBeanException(name, type.getName()).         } else if (found.size() > 1) {             throw new NoSuchBeanException("Found " + found.size() + " beans of type: " + type + ". Only one bean expected.").         } else {             // we found only one             return found.iterator().next().         }     } else {         return CamelContextHelper.mandatoryLookup(getCamelContext(), name, type).     } }
true;protected;5;15;/**  * Factory method to create a {@link org.apache.camel.ProducerTemplate} to  * be injected into a POJO  */ ;/**  * Factory method to create a {@link org.apache.camel.ProducerTemplate} to  * be injected into a POJO  */ protected ProducerTemplate createInjectionProducerTemplate(String endpointUri, String endpointRef, String endpointProperty, String injectionPointName, Object bean) {     // endpoint is optional for this injection point     Endpoint endpoint = getEndpointInjection(bean, endpointUri, endpointRef, endpointProperty, injectionPointName, false).     CamelContext context = endpoint != null ? endpoint.getCamelContext() : getCamelContext().     ProducerTemplate answer = new DefaultProducerTemplate(context, endpoint).     // start the template so its ready to use     try {         // no need to defer the template as it can adjust to the endpoint at runtime         startService(answer, context, bean, null).     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     }     return answer. }
true;protected;5;16;/**  * Factory method to create a  * {@link org.apache.camel.FluentProducerTemplate} to be injected into a  * POJO  */ ;/**  * Factory method to create a  * {@link org.apache.camel.FluentProducerTemplate} to be injected into a  * POJO  */ protected FluentProducerTemplate createInjectionFluentProducerTemplate(String endpointUri, String endpointRef, String endpointProperty, String injectionPointName, Object bean) {     // endpoint is optional for this injection point     Endpoint endpoint = getEndpointInjection(bean, endpointUri, endpointRef, endpointProperty, injectionPointName, false).     CamelContext context = endpoint != null ? endpoint.getCamelContext() : getCamelContext().     FluentProducerTemplate answer = new DefaultFluentProducerTemplate(context).     answer.setDefaultEndpoint(endpoint).     // start the template so its ready to use     try {         // no need to defer the template as it can adjust to the endpoint at runtime         startService(answer, context, bean, null).     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     }     return answer. }
true;protected;4;11;/**  * Factory method to create a {@link org.apache.camel.ConsumerTemplate} to  * be injected into a POJO  */ ;/**  * Factory method to create a {@link org.apache.camel.ConsumerTemplate} to  * be injected into a POJO  */ protected ConsumerTemplate createInjectionConsumerTemplate(String endpointUri, String endpointRef, String endpointProperty, String injectionPointName) {     ConsumerTemplate answer = new DefaultConsumerTemplate(getCamelContext()).     // start the template so its ready to use     try {         startService(answer, null, null, null).     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     }     return answer. }
true;protected;3;9;/**  * Factory method to create a started  * {@link org.apache.camel.PollingConsumer} to be injected into a POJO  */ ;/**  * Factory method to create a started  * {@link org.apache.camel.PollingConsumer} to be injected into a POJO  */ protected PollingConsumer createInjectionPollingConsumer(Endpoint endpoint, Object bean, String beanName) {     try {         PollingConsumer consumer = endpoint.createPollingConsumer().         startService(consumer, endpoint.getCamelContext(), bean, beanName).         return consumer.     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
true;protected;3;7;/**  * A Factory method to create a started {@link org.apache.camel.Producer} to  * be injected into a POJO  */ ;/**  * A Factory method to create a started {@link org.apache.camel.Producer} to  * be injected into a POJO  */ protected Producer createInjectionProducer(Endpoint endpoint, Object bean, String beanName) {     try {         return DeferServiceFactory.createProducer(endpoint).     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;protected;3;3;;protected RuntimeException createProxyInstantiationRuntimeException(Class<?> type, Endpoint endpoint, Exception e) {     return new ProxyInstantiationException(type, endpoint, e). }
true;protected;2;7;/**  * Implementations can override this method to determine if the bean is  * singleton.  *  * @param bean the bean  * @return <tt>true</tt> if its singleton scoped, for prototype scoped  * <tt>false</tt> is returned.  */ ;/**  * Implementations can override this method to determine if the bean is  * singleton.  *  * @param bean the bean  * @return <tt>true</tt> if its singleton scoped, for prototype scoped  * <tt>false</tt> is returned.  */ protected boolean isSingleton(Object bean, String beanName) {     if (bean instanceof IsSingleton) {         IsSingleton singleton = (IsSingleton) bean.         return singleton.isSingleton().     }     return true. }
