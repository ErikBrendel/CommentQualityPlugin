commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "Catch[" + exceptions + " -> " + getProcessor() + "]". }
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setId(String id) {     this.id = id. }
false;public;0;3;;public String getTraceLabel() {     return "catch". }
false;public;1;14;;public void done(boolean doneSync) {     // emit event that the failure was handled     EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, false, null).     // always clear redelivery exhausted in a catch clause     exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED).     if (!doneSync) {         // signal callback to continue routing async         ExchangeHelper.prepareOutToIn(exchange).     }     callback.done(doneSync). }
false;public;2;51;;@Override public boolean process(final Exchange exchange, final AsyncCallback callback) {     Exception e = exchange.getException().     Throwable caught = catches(exchange, e).     // If a previous catch clause handled the exception or if this clause does not match, exit     if (exchange.getProperty(Exchange.EXCEPTION_HANDLED) != null || caught == null) {         callback.done(true).         return true.     }     if (log.isTraceEnabled()) {         log.trace("This CatchProcessor catches the exception: {} caused by: {}", caught.getClass().getName(), e.getMessage()).     }     // store the last to endpoint as the failure endpoint     if (exchange.getProperty(Exchange.FAILURE_ENDPOINT) == null) {         exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT)).     }     // give the rest of the pipeline another chance     exchange.setProperty(Exchange.EXCEPTION_HANDLED, true).     exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e).     exchange.setException(null).     // and we should not be regarded as exhausted as we are in a try .. catch block     exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED).     if (log.isDebugEnabled()) {         log.debug("The exception is handled for the exception: {} caused by: {}", new Object[] { e.getClass().getName(), e.getMessage() }).     }     // emit event that the failure is being handled     EventHelper.notifyExchangeFailureHandling(exchange.getContext(), exchange, processor, false, null).     boolean sync = processor.process(exchange, new AsyncCallback() {          public void done(boolean doneSync) {             // emit event that the failure was handled             EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, false, null).             // always clear redelivery exhausted in a catch clause             exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED).             if (!doneSync) {                 // signal callback to continue routing async                 ExchangeHelper.prepareOutToIn(exchange).             }             callback.done(doneSync).         }     }).     return sync. }
true;protected;2;14;/**  * Returns with the exception that is caught by this processor.  *  * This method traverses exception causes, so sometimes the exception  * returned from this method might be one of causes of the parameter  * passed.  *  * @param exchange  the current exchange  * @param exception the thrown exception  * @return Throwable that this processor catches. <tt>null</tt> if nothing matches.  */ ;/**  * Returns with the exception that is caught by this processor.  *  * This method traverses exception causes, so sometimes the exception  * returned from this method might be one of causes of the parameter  * passed.  *  * @param exchange  the current exchange  * @param exception the thrown exception  * @return Throwable that this processor catches. <tt>null</tt> if nothing matches.  */ protected Throwable catches(Exchange exchange, Throwable exception) {     // use the exception iterator to walk the caused by hierarchy     for (final Throwable e : ObjectHelper.createExceptionIterable(exception)) {         // see if we catch this type         for (final Class<?> type : exceptions) {             if (type.isInstance(e) && matchesWhen(exchange)) {                 return e.             }         }     }     // not found     return null. }
false;public;0;3;;public List<Class<? extends Throwable>> getExceptions() {     return exceptions. }
true;protected;1;7;/**  * Strategy method for matching the exception type with the current exchange.  * <p/>  * This default implementation will match as:  * <ul>  *   <li>Always true if no when predicate on the exception type  *   <li>Otherwise the when predicate is matches against the current exchange  * </ul>  *  * @param exchange the current {@link org.apache.camel.Exchange}  * @return <tt>true</tt> if matched, <tt>false</tt> otherwise.  */ ;/**  * Strategy method for matching the exception type with the current exchange.  * <p/>  * This default implementation will match as:  * <ul>  *   <li>Always true if no when predicate on the exception type  *   <li>Otherwise the when predicate is matches against the current exchange  * </ul>  *  * @param exchange the current {@link org.apache.camel.Exchange}  * @return <tt>true</tt> if matched, <tt>false</tt> otherwise.  */ protected boolean matchesWhen(Exchange exchange) {     if (onWhen == null) {         // if no predicate then it's always a match         return true.     }     return onWhen.matches(exchange). }
