commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "Aggregate[" + description() + " -> " + getOutputs() + "]". }
false;protected;0;3;;protected String description() {     return getExpression() != null ? getExpression().getLabel() : "". }
false;public;0;4;;@Override public String getShortName() {     return "aggregate". }
false;public;0;4;;@Override public String getLabel() {     return "aggregate[" + description() + "]". }
false;public;1;17;;@Override public void configureChild(ProcessorDefinition<?> output) {     if (expression instanceof ExpressionClause) {         ExpressionClause<?> clause = (ExpressionClause<?>) expression.         if (clause.getExpressionType() != null) {             // if using the Java DSL then the expression may have been set using the             // ExpressionClause which is a fancy builder to define expressions and predicates             // using fluent builders in the DSL. However we need afterwards a callback to             // reset the expression to the expression type the ExpressionClause did build for us             expression = clause.getExpressionType().             // set the correlation expression from the expression type, as the model definition             // would then be accurate             correlationExpression = new ExpressionSubElementDefinition().             correlationExpression.setExpressionType(clause.getExpressionType()).         }     } }
false;public;0;3;;public AggregationStrategy getAggregationStrategy() {     return aggregationStrategy. }
true;public;1;3;/**  * The AggregationStrategy to use.  * <p/>  * Configuring an AggregationStrategy is required, and is used to merge the incoming Exchange with the existing already merged exchanges.  * At first call the oldExchange parameter is null.  * On subsequent invocations the oldExchange contains the merged exchanges and newExchange is of course the new incoming Exchange.  */ ;/**  * The AggregationStrategy to use.  * <p/>  * Configuring an AggregationStrategy is required, and is used to merge the incoming Exchange with the existing already merged exchanges.  * At first call the oldExchange parameter is null.  * On subsequent invocations the oldExchange contains the merged exchanges and newExchange is of course the new incoming Exchange.  */ public void setAggregationStrategy(AggregationStrategy aggregationStrategy) {     this.aggregationStrategy = aggregationStrategy. }
false;public;0;3;;public String getAggregationStrategyRef() {     return strategyRef. }
true;public;1;3;/**  * A reference to lookup the AggregationStrategy in the Registry.  * <p/>  * Configuring an AggregationStrategy is required, and is used to merge the incoming Exchange with the existing already merged exchanges.  * At first call the oldExchange parameter is null.  * On subsequent invocations the oldExchange contains the merged exchanges and newExchange is of course the new incoming Exchange.  */ ;/**  * A reference to lookup the AggregationStrategy in the Registry.  * <p/>  * Configuring an AggregationStrategy is required, and is used to merge the incoming Exchange with the existing already merged exchanges.  * At first call the oldExchange parameter is null.  * On subsequent invocations the oldExchange contains the merged exchanges and newExchange is of course the new incoming Exchange.  */ public void setAggregationStrategyRef(String aggregationStrategyRef) {     this.strategyRef = aggregationStrategyRef. }
false;public;0;3;;public String getStrategyRef() {     return strategyRef. }
true;public;1;3;/**  * A reference to lookup the AggregationStrategy in the Registry.  * <p/>  * Configuring an AggregationStrategy is required, and is used to merge the incoming Exchange with the existing already merged exchanges.  * At first call the oldExchange parameter is null.  * On subsequent invocations the oldExchange contains the merged exchanges and newExchange is of course the new incoming Exchange.  */ ;/**  * A reference to lookup the AggregationStrategy in the Registry.  * <p/>  * Configuring an AggregationStrategy is required, and is used to merge the incoming Exchange with the existing already merged exchanges.  * At first call the oldExchange parameter is null.  * On subsequent invocations the oldExchange contains the merged exchanges and newExchange is of course the new incoming Exchange.  */ public void setStrategyRef(String strategyRef) {     this.strategyRef = strategyRef. }
false;public;0;3;;public String getAggregationStrategyMethodName() {     return strategyMethodName. }
true;public;1;3;/**  * This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.  */ ;/**  * This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.  */ public void setAggregationStrategyMethodName(String strategyMethodName) {     this.strategyMethodName = strategyMethodName. }
false;public;0;3;;public Boolean getStrategyMethodAllowNull() {     return strategyMethodAllowNull. }
false;public;0;3;;public String getStrategyMethodName() {     return strategyMethodName. }
true;public;1;3;/**  * This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.  */ ;/**  * This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.  */ public void setStrategyMethodName(String strategyMethodName) {     this.strategyMethodName = strategyMethodName. }
true;public;1;3;/**  * If this option is false then the aggregate method is not used for the very first aggregation.  * If this option is true then null values is used as the oldExchange (at the very first aggregation),  * when using POJOs as the AggregationStrategy.  */ ;/**  * If this option is false then the aggregate method is not used for the very first aggregation.  * If this option is true then null values is used as the oldExchange (at the very first aggregation),  * when using POJOs as the AggregationStrategy.  */ public void setStrategyMethodAllowNull(Boolean strategyMethodAllowNull) {     this.strategyMethodAllowNull = strategyMethodAllowNull. }
true;public;1;3;/**  * The expression used to calculate the correlation key to use for aggregation.  * The Exchange which has the same correlation key is aggregated together.  * If the correlation key could not be evaluated an Exception is thrown.  * You can disable this by using the ignoreBadCorrelationKeys option.  */ ;/**  * The expression used to calculate the correlation key to use for aggregation.  * The Exchange which has the same correlation key is aggregated together.  * If the correlation key could not be evaluated an Exception is thrown.  * You can disable this by using the ignoreBadCorrelationKeys option.  */ public void setCorrelationExpression(ExpressionSubElementDefinition correlationExpression) {     this.correlationExpression = correlationExpression. }
false;public;0;3;;public ExpressionSubElementDefinition getCorrelationExpression() {     return correlationExpression. }
false;public;0;3;;public Integer getCompletionSize() {     return completionSize. }
false;public;1;3;;public void setCompletionSize(Integer completionSize) {     this.completionSize = completionSize. }
false;public;0;3;;public OptimisticLockRetryPolicyDefinition getOptimisticLockRetryPolicyDefinition() {     return optimisticLockRetryPolicyDefinition. }
false;public;1;3;;public void setOptimisticLockRetryPolicyDefinition(OptimisticLockRetryPolicyDefinition optimisticLockRetryPolicyDefinition) {     this.optimisticLockRetryPolicyDefinition = optimisticLockRetryPolicyDefinition. }
false;public;0;3;;public OptimisticLockRetryPolicy getOptimisticLockRetryPolicy() {     return optimisticLockRetryPolicy. }
false;public;1;3;;public void setOptimisticLockRetryPolicy(OptimisticLockRetryPolicy optimisticLockRetryPolicy) {     this.optimisticLockRetryPolicy = optimisticLockRetryPolicy. }
false;public;0;3;;public Long getCompletionInterval() {     return completionInterval. }
false;public;1;3;;public void setCompletionInterval(Long completionInterval) {     this.completionInterval = completionInterval. }
false;public;0;3;;public Long getCompletionTimeout() {     return completionTimeout. }
false;public;1;3;;public void setCompletionTimeout(Long completionTimeout) {     this.completionTimeout = completionTimeout. }
false;public;0;3;;public Long getCompletionTimeoutCheckerInterval() {     return completionTimeoutCheckerInterval. }
false;public;1;3;;public void setCompletionTimeoutCheckerInterval(Long completionTimeoutCheckerInterval) {     this.completionTimeoutCheckerInterval = completionTimeoutCheckerInterval. }
false;public;0;3;;public ExpressionSubElementDefinition getCompletionPredicate() {     return completionPredicate. }
false;public;1;3;;public void setCompletionPredicate(ExpressionSubElementDefinition completionPredicate) {     this.completionPredicate = completionPredicate. }
false;public;0;3;;public ExpressionSubElementDefinition getCompletionTimeoutExpression() {     return completionTimeoutExpression. }
false;public;1;3;;public void setCompletionTimeoutExpression(ExpressionSubElementDefinition completionTimeoutExpression) {     this.completionTimeoutExpression = completionTimeoutExpression. }
false;public;0;3;;public ExpressionSubElementDefinition getCompletionSizeExpression() {     return completionSizeExpression. }
false;public;1;3;;public void setCompletionSizeExpression(ExpressionSubElementDefinition completionSizeExpression) {     this.completionSizeExpression = completionSizeExpression. }
false;public;0;3;;public Boolean getCompletionFromBatchConsumer() {     return completionFromBatchConsumer. }
false;public;1;3;;public void setCompletionFromBatchConsumer(Boolean completionFromBatchConsumer) {     this.completionFromBatchConsumer = completionFromBatchConsumer. }
false;public;0;3;;public Boolean getCompletionOnNewCorrelationGroup() {     return completionOnNewCorrelationGroup. }
false;public;1;3;;public void setCompletionOnNewCorrelationGroup(Boolean completionOnNewCorrelationGroup) {     this.completionOnNewCorrelationGroup = completionOnNewCorrelationGroup. }
false;public;0;3;;public ExecutorService getExecutorService() {     return executorService. }
false;public;1;3;;public void setExecutorService(ExecutorService executorService) {     this.executorService = executorService. }
false;public;0;3;;public Boolean getOptimisticLocking() {     return optimisticLocking. }
false;public;1;3;;public void setOptimisticLocking(boolean optimisticLocking) {     this.optimisticLocking = optimisticLocking. }
false;public;0;3;;public Boolean getParallelProcessing() {     return parallelProcessing. }
false;public;1;3;;public void setParallelProcessing(boolean parallelProcessing) {     this.parallelProcessing = parallelProcessing. }
false;public;0;3;;public String getExecutorServiceRef() {     return executorServiceRef. }
false;public;1;3;;public void setExecutorServiceRef(String executorServiceRef) {     this.executorServiceRef = executorServiceRef. }
false;public;0;3;;public Boolean getEagerCheckCompletion() {     return eagerCheckCompletion. }
false;public;1;3;;public void setEagerCheckCompletion(Boolean eagerCheckCompletion) {     this.eagerCheckCompletion = eagerCheckCompletion. }
false;public;0;3;;public Boolean getIgnoreInvalidCorrelationKeys() {     return ignoreInvalidCorrelationKeys. }
false;public;1;3;;public void setIgnoreInvalidCorrelationKeys(Boolean ignoreInvalidCorrelationKeys) {     this.ignoreInvalidCorrelationKeys = ignoreInvalidCorrelationKeys. }
false;public;0;3;;public Integer getCloseCorrelationKeyOnCompletion() {     return closeCorrelationKeyOnCompletion. }
false;public;1;3;;public void setCloseCorrelationKeyOnCompletion(Integer closeCorrelationKeyOnCompletion) {     this.closeCorrelationKeyOnCompletion = closeCorrelationKeyOnCompletion. }
false;public;0;3;;public AggregationRepository getAggregationRepository() {     return aggregationRepository. }
false;public;1;3;;public void setAggregationRepository(AggregationRepository aggregationRepository) {     this.aggregationRepository = aggregationRepository. }
false;public;0;3;;public String getAggregationRepositoryRef() {     return aggregationRepositoryRef. }
false;public;1;3;;public void setAggregationRepositoryRef(String aggregationRepositoryRef) {     this.aggregationRepositoryRef = aggregationRepositoryRef. }
false;public;0;3;;public Boolean getDiscardOnCompletionTimeout() {     return discardOnCompletionTimeout. }
false;public;1;3;;public void setDiscardOnCompletionTimeout(Boolean discardOnCompletionTimeout) {     this.discardOnCompletionTimeout = discardOnCompletionTimeout. }
false;public;1;3;;public void setTimeoutCheckerExecutorService(ScheduledExecutorService timeoutCheckerExecutorService) {     this.timeoutCheckerExecutorService = timeoutCheckerExecutorService. }
false;public;0;3;;public ScheduledExecutorService getTimeoutCheckerExecutorService() {     return timeoutCheckerExecutorService. }
false;public;1;3;;public void setTimeoutCheckerExecutorServiceRef(String timeoutCheckerExecutorServiceRef) {     this.timeoutCheckerExecutorServiceRef = timeoutCheckerExecutorServiceRef. }
false;public;0;3;;public String getTimeoutCheckerExecutorServiceRef() {     return timeoutCheckerExecutorServiceRef. }
false;public;0;3;;public Boolean getForceCompletionOnStop() {     return forceCompletionOnStop. }
false;public;1;3;;public void setForceCompletionOnStop(Boolean forceCompletionOnStop) {     this.forceCompletionOnStop = forceCompletionOnStop. }
false;public;0;3;;public Boolean getCompleteAllOnStop() {     return completeAllOnStop. }
false;public;1;3;;public void setCompleteAllOnStop(Boolean completeAllOnStop) {     this.completeAllOnStop = completeAllOnStop. }
false;public;0;3;;public AggregateController getAggregateController() {     return aggregateController. }
false;public;1;3;;public void setAggregateController(AggregateController aggregateController) {     this.aggregateController = aggregateController. }
false;public;0;3;;public String getAggregateControllerRef() {     return aggregateControllerRef. }
true;public;1;3;/**  * To use a {@link org.apache.camel.processor.aggregate.AggregateController} to allow external sources to control  * this aggregator.  */ ;/**  * To use a {@link org.apache.camel.processor.aggregate.AggregateController} to allow external sources to control  * this aggregator.  */ public void setAggregateControllerRef(String aggregateControllerRef) {     this.aggregateControllerRef = aggregateControllerRef. }
true;public;0;4;/**  * Use eager completion checking which means that the completionPredicate will use the incoming Exchange.  * As opposed to without eager completion checking the completionPredicate will use the aggregated Exchange.  *  * @return builder  */ ;// Fluent API // ------------------------------------------------------------------------- /**  * Use eager completion checking which means that the completionPredicate will use the incoming Exchange.  * As opposed to without eager completion checking the completionPredicate will use the aggregated Exchange.  *  * @return builder  */ public AggregateDefinition eagerCheckCompletion() {     setEagerCheckCompletion(true).     return this. }
true;public;0;4;/**  * If a correlation key cannot be successfully evaluated it will be ignored by logging a DEBUG and then just  * ignore the incoming Exchange.  *  * @return builder  */ ;/**  * If a correlation key cannot be successfully evaluated it will be ignored by logging a DEBUG and then just  * ignore the incoming Exchange.  *  * @return builder  */ public AggregateDefinition ignoreInvalidCorrelationKeys() {     setIgnoreInvalidCorrelationKeys(true).     return this. }
true;public;1;4;/**  * Closes a correlation key when its complete. Any <i>late</i> received exchanges which has a correlation key  * that has been closed, it will be defined and a ClosedCorrelationKeyException  * is thrown.  *  * @param capacity the maximum capacity of the closed correlation key cache.  *                 Use <tt>0</tt> or negative value for unbounded capacity.  * @return builder  */ ;/**  * Closes a correlation key when its complete. Any <i>late</i> received exchanges which has a correlation key  * that has been closed, it will be defined and a ClosedCorrelationKeyException  * is thrown.  *  * @param capacity the maximum capacity of the closed correlation key cache.  *                 Use <tt>0</tt> or negative value for unbounded capacity.  * @return builder  */ public AggregateDefinition closeCorrelationKeyOnCompletion(int capacity) {     setCloseCorrelationKeyOnCompletion(capacity).     return this. }
true;public;0;4;/**  * Discards the aggregated message on completion timeout.  * <p/>  * This means on timeout the aggregated message is dropped and not sent out of the aggregator.  *  * @return builder  */ ;/**  * Discards the aggregated message on completion timeout.  * <p/>  * This means on timeout the aggregated message is dropped and not sent out of the aggregator.  *  * @return builder  */ public AggregateDefinition discardOnCompletionTimeout() {     setDiscardOnCompletionTimeout(true).     return this. }
true;public;0;4;/**  * Enables the batch completion mode where we aggregate from a {@link org.apache.camel.BatchConsumer}  * and aggregate the total number of exchanges the {@link org.apache.camel.BatchConsumer} has reported  * as total by checking the exchange property {@link org.apache.camel.Exchange#BATCH_COMPLETE} when its complete.  *  * @return builder  */ ;/**  * Enables the batch completion mode where we aggregate from a {@link org.apache.camel.BatchConsumer}  * and aggregate the total number of exchanges the {@link org.apache.camel.BatchConsumer} has reported  * as total by checking the exchange property {@link org.apache.camel.Exchange#BATCH_COMPLETE} when its complete.  *  * @return builder  */ public AggregateDefinition completionFromBatchConsumer() {     setCompletionFromBatchConsumer(true).     return this. }
true;public;0;4;/**  * Enables completion on all previous groups when a new incoming correlation group. This can for example be used  * to complete groups with same correlation keys when they are in consecutive order.  * Notice when this is enabled then only 1 correlation group can be in progress as when a new correlation group  * starts, then the previous groups is forced completed.  *  * @return builder  */ ;/**  * Enables completion on all previous groups when a new incoming correlation group. This can for example be used  * to complete groups with same correlation keys when they are in consecutive order.  * Notice when this is enabled then only 1 correlation group can be in progress as when a new correlation group  * starts, then the previous groups is forced completed.  *  * @return builder  */ public AggregateDefinition completionOnNewCorrelationGroup() {     setCompletionOnNewCorrelationGroup(true).     return this. }
true;public;1;4;/**  * Number of messages aggregated before the aggregation is complete. This option can be set as either  * a fixed value or using an Expression which allows you to evaluate a size dynamically - will use Integer as result.  * If both are set Camel will fallback to use the fixed value if the Expression result was null or 0.  *  * @param completionSize  the completion size, must be a positive number  * @return builder  */ ;/**  * Number of messages aggregated before the aggregation is complete. This option can be set as either  * a fixed value or using an Expression which allows you to evaluate a size dynamically - will use Integer as result.  * If both are set Camel will fallback to use the fixed value if the Expression result was null or 0.  *  * @param completionSize  the completion size, must be a positive number  * @return builder  */ public AggregateDefinition completionSize(int completionSize) {     setCompletionSize(completionSize).     return this. }
true;public;1;4;/**  * Number of messages aggregated before the aggregation is complete. This option can be set as either  * a fixed value or using an Expression which allows you to evaluate a size dynamically - will use Integer as result.  * If both are set Camel will fallback to use the fixed value if the Expression result was null or 0.  *  * @param completionSize  the completion size as an {@link org.apache.camel.Expression} which is evaluated as a {@link Integer} type  * @return builder  */ ;/**  * Number of messages aggregated before the aggregation is complete. This option can be set as either  * a fixed value or using an Expression which allows you to evaluate a size dynamically - will use Integer as result.  * If both are set Camel will fallback to use the fixed value if the Expression result was null or 0.  *  * @param completionSize  the completion size as an {@link org.apache.camel.Expression} which is evaluated as a {@link Integer} type  * @return builder  */ public AggregateDefinition completionSize(Expression completionSize) {     setCompletionSizeExpression(new ExpressionSubElementDefinition(completionSize)).     return this. }
true;public;1;4;/**  * A repeating period in millis by which the aggregator will complete all current aggregated exchanges.  * Camel has a background task which is triggered every period. You cannot use this option together  * with completionTimeout, only one of them can be used.  *  * @param completionInterval  the interval in millis, must be a positive value  * @return the builder  */ ;/**  * A repeating period in millis by which the aggregator will complete all current aggregated exchanges.  * Camel has a background task which is triggered every period. You cannot use this option together  * with completionTimeout, only one of them can be used.  *  * @param completionInterval  the interval in millis, must be a positive value  * @return the builder  */ public AggregateDefinition completionInterval(long completionInterval) {     setCompletionInterval(completionInterval).     return this. }
true;public;1;4;/**  * Time in millis that an aggregated exchange should be inactive before its complete (timeout).  * This option can be set as either a fixed value or using an Expression which allows you to evaluate  * a timeout dynamically - will use Long as result.  * If both are set Camel will fallback to use the fixed value if the Expression result was null or 0.  * You cannot use this option together with completionInterval, only one of the two can be used.  * <p/>  * By default the timeout checker runs every second, you can use the completionTimeoutCheckerInterval option  * to configure how frequently to run the checker.  * The timeout is an approximation and there is no guarantee that the a timeout is triggered exactly after the timeout value.  * It is not recommended to use very low timeout values or checker intervals.  *  * @param completionTimeout  the timeout in millis, must be a positive value  * @return the builder  */ ;/**  * Time in millis that an aggregated exchange should be inactive before its complete (timeout).  * This option can be set as either a fixed value or using an Expression which allows you to evaluate  * a timeout dynamically - will use Long as result.  * If both are set Camel will fallback to use the fixed value if the Expression result was null or 0.  * You cannot use this option together with completionInterval, only one of the two can be used.  * <p/>  * By default the timeout checker runs every second, you can use the completionTimeoutCheckerInterval option  * to configure how frequently to run the checker.  * The timeout is an approximation and there is no guarantee that the a timeout is triggered exactly after the timeout value.  * It is not recommended to use very low timeout values or checker intervals.  *  * @param completionTimeout  the timeout in millis, must be a positive value  * @return the builder  */ public AggregateDefinition completionTimeout(long completionTimeout) {     setCompletionTimeout(completionTimeout).     return this. }
true;public;1;4;/**  * Time in millis that an aggregated exchange should be inactive before its complete (timeout).  * This option can be set as either a fixed value or using an Expression which allows you to evaluate  * a timeout dynamically - will use Long as result.  * If both are set Camel will fallback to use the fixed value if the Expression result was null or 0.  * You cannot use this option together with completionInterval, only one of the two can be used.  * <p/>  * By default the timeout checker runs every second, you can use the completionTimeoutCheckerInterval option  * to configure how frequently to run the checker.  * The timeout is an approximation and there is no guarantee that the a timeout is triggered exactly after the timeout value.  * It is not recommended to use very low timeout values or checker intervals.  *  * @param completionTimeout  the timeout as an {@link Expression} which is evaluated as a {@link Long} type  * @return the builder  */ ;/**  * Time in millis that an aggregated exchange should be inactive before its complete (timeout).  * This option can be set as either a fixed value or using an Expression which allows you to evaluate  * a timeout dynamically - will use Long as result.  * If both are set Camel will fallback to use the fixed value if the Expression result was null or 0.  * You cannot use this option together with completionInterval, only one of the two can be used.  * <p/>  * By default the timeout checker runs every second, you can use the completionTimeoutCheckerInterval option  * to configure how frequently to run the checker.  * The timeout is an approximation and there is no guarantee that the a timeout is triggered exactly after the timeout value.  * It is not recommended to use very low timeout values or checker intervals.  *  * @param completionTimeout  the timeout as an {@link Expression} which is evaluated as a {@link Long} type  * @return the builder  */ public AggregateDefinition completionTimeout(Expression completionTimeout) {     setCompletionTimeoutExpression(new ExpressionSubElementDefinition(completionTimeout)).     return this. }
true;public;1;4;/**  * Interval in millis that is used by the background task that checks for timeouts ({@link org.apache.camel.TimeoutMap}).  * <p/>  * By default the timeout checker runs every second.  * The timeout is an approximation and there is no guarantee that the a timeout is triggered exactly after the timeout value.  * It is not recommended to use very low timeout values or checker intervals.  *  * @param completionTimeoutCheckerInterval  the interval in millis, must be a positive value  * @return the builder  */ ;/**  * Interval in millis that is used by the background task that checks for timeouts ({@link org.apache.camel.TimeoutMap}).  * <p/>  * By default the timeout checker runs every second.  * The timeout is an approximation and there is no guarantee that the a timeout is triggered exactly after the timeout value.  * It is not recommended to use very low timeout values or checker intervals.  *  * @param completionTimeoutCheckerInterval  the interval in millis, must be a positive value  * @return the builder  */ public AggregateDefinition completionTimeoutCheckerInterval(long completionTimeoutCheckerInterval) {     setCompletionTimeoutCheckerInterval(completionTimeoutCheckerInterval).     return this. }
true;public;0;5;/**  * Sets the AggregationStrategy to use with a fluent builder.  */ ;/**  * Sets the AggregationStrategy to use with a fluent builder.  */ public AggregationStrategyClause<AggregateDefinition> aggregationStrategy() {     AggregationStrategyClause<AggregateDefinition> clause = new AggregationStrategyClause<>(this).     setAggregationStrategy(clause).     return clause. }
true;public;0;3;/**  * Sets the AggregationStrategy to use with a fluent builder.  */ ;/**  * Sets the AggregationStrategy to use with a fluent builder.  */ public AggregationStrategyClause<AggregateDefinition> strategy() {     return aggregationStrategy(). }
true;public;1;3;/**  * Sets the aggregate strategy to use  *  * @param aggregationStrategy  the aggregate strategy to use  * @return the builder  */ ;/**  * Sets the aggregate strategy to use  *  * @param aggregationStrategy  the aggregate strategy to use  * @return the builder  */ public AggregateDefinition strategy(AggregationStrategy aggregationStrategy) {     return aggregationStrategy(aggregationStrategy). }
true;public;1;4;/**  * Sets the aggregate strategy to use  *  * @param aggregationStrategy  the aggregate strategy to use  * @return the builder  */ ;/**  * Sets the aggregate strategy to use  *  * @param aggregationStrategy  the aggregate strategy to use  * @return the builder  */ public AggregateDefinition aggregationStrategy(AggregationStrategy aggregationStrategy) {     setAggregationStrategy(aggregationStrategy).     return this. }
true;public;1;4;/**  * Sets the aggregate strategy to use  *  * @param aggregationStrategyRef  reference to the strategy to lookup in the registry  * @return the builder  */ ;/**  * Sets the aggregate strategy to use  *  * @param aggregationStrategyRef  reference to the strategy to lookup in the registry  * @return the builder  */ public AggregateDefinition aggregationStrategyRef(String aggregationStrategyRef) {     setAggregationStrategyRef(aggregationStrategyRef).     return this. }
true;public;1;4;/**  * Sets the method name to use when using a POJO as {@link AggregationStrategy}.  *  * @param  methodName the method name to call  * @return the builder  */ ;/**  * Sets the method name to use when using a POJO as {@link AggregationStrategy}.  *  * @param  methodName the method name to call  * @return the builder  */ public AggregateDefinition aggregationStrategyMethodName(String methodName) {     setAggregationStrategyMethodName(methodName).     return this. }
true;public;0;4;/**  * Sets allowing null when using a POJO as {@link AggregationStrategy}.  *  * @return the builder  */ ;/**  * Sets allowing null when using a POJO as {@link AggregationStrategy}.  *  * @return the builder  */ public AggregateDefinition aggregationStrategyMethodAllowNull() {     setStrategyMethodAllowNull(true).     return this. }
true;public;1;4;/**  * Sets the custom aggregate repository to use.  * <p/>  * Will by default use {@link org.apache.camel.processor.aggregate.MemoryAggregationRepository}  *  * @param aggregationRepository  the aggregate repository to use  * @return the builder  */ ;/**  * Sets the custom aggregate repository to use.  * <p/>  * Will by default use {@link org.apache.camel.processor.aggregate.MemoryAggregationRepository}  *  * @param aggregationRepository  the aggregate repository to use  * @return the builder  */ public AggregateDefinition aggregationRepository(AggregationRepository aggregationRepository) {     setAggregationRepository(aggregationRepository).     return this. }
true;public;1;4;/**  * Sets the custom aggregate repository to use  * <p/>  * Will by default use {@link org.apache.camel.processor.aggregate.MemoryAggregationRepository}  *  * @param aggregationRepositoryRef  reference to the repository to lookup in the registry  * @return the builder  */ ;/**  * Sets the custom aggregate repository to use  * <p/>  * Will by default use {@link org.apache.camel.processor.aggregate.MemoryAggregationRepository}  *  * @param aggregationRepositoryRef  reference to the repository to lookup in the registry  * @return the builder  */ public AggregateDefinition aggregationRepositoryRef(String aggregationRepositoryRef) {     setAggregationRepositoryRef(aggregationRepositoryRef).     return this. }
true;public;1;5;/**  * A Predicate to indicate when an aggregated exchange is complete.  * If this is not specified and the AggregationStrategy object implements Predicate,  * the aggregationStrategy object will be used as the completionPredicate.  */ ;/**  * A Predicate to indicate when an aggregated exchange is complete.  * If this is not specified and the AggregationStrategy object implements Predicate,  * the aggregationStrategy object will be used as the completionPredicate.  */ public AggregateDefinition completionPredicate(@AsPredicate Predicate predicate) {     checkNoCompletedPredicate().     setCompletionPredicate(new ExpressionSubElementDefinition(predicate)).     return this. }
true;public;0;6;/**  * A Predicate to indicate when an aggregated exchange is complete.  * If this is not specified and the AggregationStrategy object implements Predicate,  * the aggregationStrategy object will be used as the completionPredicate.  */ ;/**  * A Predicate to indicate when an aggregated exchange is complete.  * If this is not specified and the AggregationStrategy object implements Predicate,  * the aggregationStrategy object will be used as the completionPredicate.  */ @AsPredicate public PredicateClause<AggregateDefinition> completionPredicate() {     PredicateClause<AggregateDefinition> clause = new PredicateClause<>(this).     completionPredicate(clause).     return clause. }
true;public;0;4;/**  * A Predicate to indicate when an aggregated exchange is complete.  * If this is not specified and the AggregationStrategy object implements Predicate,  * the aggregationStrategy object will be used as the completionPredicate.  */ ;/**  * A Predicate to indicate when an aggregated exchange is complete.  * If this is not specified and the AggregationStrategy object implements Predicate,  * the aggregationStrategy object will be used as the completionPredicate.  */ @AsPredicate public PredicateClause<AggregateDefinition> completion() {     return completionPredicate(). }
true;public;1;3;/**  * A Predicate to indicate when an aggregated exchange is complete.  * If this is not specified and the AggregationStrategy object implements Predicate,  * the aggregationStrategy object will be used as the completionPredicate.  */ ;/**  * A Predicate to indicate when an aggregated exchange is complete.  * If this is not specified and the AggregationStrategy object implements Predicate,  * the aggregationStrategy object will be used as the completionPredicate.  */ public AggregateDefinition completion(@AsPredicate Predicate predicate) {     return completionPredicate(predicate). }
true;public;0;4;/**  * Indicates to complete all current aggregated exchanges when the context is stopped  */ ;/**  * Indicates to complete all current aggregated exchanges when the context is stopped  */ public AggregateDefinition forceCompletionOnStop() {     setForceCompletionOnStop(true).     return this. }
true;public;0;4;/**  * Indicates to wait to complete all current and partial (pending) aggregated exchanges when the context is stopped.  * <p/>  * This also means that we will wait for all pending exchanges which are stored in the aggregation repository  * to complete so the repository is empty before we can stop.  * <p/>  * You may want to enable this when using the memory based aggregation repository that is memory based only,  * and do not store data on disk. When this option is enabled, then the aggregator is waiting to complete  * all those exchanges before its stopped, when stopping CamelContext or the route using it.  */ ;/**  * Indicates to wait to complete all current and partial (pending) aggregated exchanges when the context is stopped.  * <p/>  * This also means that we will wait for all pending exchanges which are stored in the aggregation repository  * to complete so the repository is empty before we can stop.  * <p/>  * You may want to enable this when using the memory based aggregation repository that is memory based only,  * and do not store data on disk. When this option is enabled, then the aggregator is waiting to complete  * all those exchanges before its stopped, when stopping CamelContext or the route using it.  */ public AggregateDefinition completeAllOnStop() {     setCompleteAllOnStop(true).     return this. }
true;public;0;4;/**  * When aggregated are completed they are being send out of the aggregator.  * This option indicates whether or not Camel should use a thread pool with multiple threads for concurrency.  * If no custom thread pool has been specified then Camel creates a default pool with 10 concurrent threads.  */ ;/**  * When aggregated are completed they are being send out of the aggregator.  * This option indicates whether or not Camel should use a thread pool with multiple threads for concurrency.  * If no custom thread pool has been specified then Camel creates a default pool with 10 concurrent threads.  */ public AggregateDefinition parallelProcessing() {     setParallelProcessing(true).     return this. }
true;public;1;4;/**  * When aggregated are completed they are being send out of the aggregator.  * This option indicates whether or not Camel should use a thread pool with multiple threads for concurrency.  * If no custom thread pool has been specified then Camel creates a default pool with 10 concurrent threads.  */ ;/**  * When aggregated are completed they are being send out of the aggregator.  * This option indicates whether or not Camel should use a thread pool with multiple threads for concurrency.  * If no custom thread pool has been specified then Camel creates a default pool with 10 concurrent threads.  */ public AggregateDefinition parallelProcessing(boolean parallelProcessing) {     setParallelProcessing(parallelProcessing).     return this. }
true;public;0;4;/**  * Turns on using optimistic locking, which requires the aggregationRepository being used,  * is supporting this by implementing {@link org.apache.camel.spi.OptimisticLockingAggregationRepository}.  */ ;/**  * Turns on using optimistic locking, which requires the aggregationRepository being used,  * is supporting this by implementing {@link org.apache.camel.spi.OptimisticLockingAggregationRepository}.  */ public AggregateDefinition optimisticLocking() {     setOptimisticLocking(true).     return this. }
true;public;1;4;/**  * Allows to configure retry settings when using optimistic locking.  */ ;/**  * Allows to configure retry settings when using optimistic locking.  */ public AggregateDefinition optimisticLockRetryPolicy(OptimisticLockRetryPolicy policy) {     setOptimisticLockRetryPolicy(policy).     return this. }
true;public;1;4;/**  * If using parallelProcessing you can specify a custom thread pool to be used.  * In fact also if you are not using parallelProcessing this custom thread pool is used to send out aggregated exchanges as well.  */ ;/**  * If using parallelProcessing you can specify a custom thread pool to be used.  * In fact also if you are not using parallelProcessing this custom thread pool is used to send out aggregated exchanges as well.  */ public AggregateDefinition executorService(ExecutorService executorService) {     setExecutorService(executorService).     return this. }
true;public;1;4;/**  * If using parallelProcessing you can specify a custom thread pool to be used.  * In fact also if you are not using parallelProcessing this custom thread pool is used to send out aggregated exchanges as well.  */ ;/**  * If using parallelProcessing you can specify a custom thread pool to be used.  * In fact also if you are not using parallelProcessing this custom thread pool is used to send out aggregated exchanges as well.  */ public AggregateDefinition executorServiceRef(String executorServiceRef) {     setExecutorServiceRef(executorServiceRef).     return this. }
true;public;1;4;/**  * If using either of the completionTimeout, completionTimeoutExpression, or completionInterval options a  * background thread is created to check for the completion for every aggregator.  * Set this option to provide a custom thread pool to be used rather than creating a new thread for every aggregator.  */ ;/**  * If using either of the completionTimeout, completionTimeoutExpression, or completionInterval options a  * background thread is created to check for the completion for every aggregator.  * Set this option to provide a custom thread pool to be used rather than creating a new thread for every aggregator.  */ public AggregateDefinition timeoutCheckerExecutorService(ScheduledExecutorService executorService) {     setTimeoutCheckerExecutorService(executorService).     return this. }
true;public;1;4;/**  * If using either of the completionTimeout, completionTimeoutExpression, or completionInterval options a  * background thread is created to check for the completion for every aggregator.  * Set this option to provide a custom thread pool to be used rather than creating a new thread for every aggregator.  */ ;/**  * If using either of the completionTimeout, completionTimeoutExpression, or completionInterval options a  * background thread is created to check for the completion for every aggregator.  * Set this option to provide a custom thread pool to be used rather than creating a new thread for every aggregator.  */ public AggregateDefinition timeoutCheckerExecutorServiceRef(String executorServiceRef) {     setTimeoutCheckerExecutorServiceRef(executorServiceRef).     return this. }
true;public;1;4;/**  * To use a {@link org.apache.camel.processor.aggregate.AggregateController} to allow external sources to control  * this aggregator.  */ ;/**  * To use a {@link org.apache.camel.processor.aggregate.AggregateController} to allow external sources to control  * this aggregator.  */ public AggregateDefinition aggregateController(AggregateController aggregateController) {     setAggregateController(aggregateController).     return this. }
false;public;0;6;;// Section - Methods from ExpressionNode // Needed to copy methods from ExpressionNode here so that I could specify the // correlation expression as optional in JAXB public ExpressionDefinition getExpression() {     if (expression == null && correlationExpression != null) {         expression = correlationExpression.getExpressionType().     }     return expression. }
false;public;1;3;;public void setExpression(ExpressionDefinition expression) {     this.expression = expression. }
false;protected;0;5;;protected void checkNoCompletedPredicate() {     if (getCompletionPredicate() != null) {         throw new IllegalArgumentException("There is already a completionPredicate defined for this aggregator: " + this).     } }
false;public;0;4;;@Override public List<ProcessorDefinition<?>> getOutputs() {     return outputs. }
false;public;0;3;;public boolean isOutputSupported() {     return true. }
false;public;1;3;;public void setOutputs(List<ProcessorDefinition<?>> outputs) {     this.outputs = outputs. }
