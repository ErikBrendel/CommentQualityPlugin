commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;45;;@Override protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {     if (keyUserid != null) {         setProperty(camelContext, dataFormat, "keyUserid", keyUserid).     }     if (signatureKeyUserid != null) {         setProperty(camelContext, dataFormat, "signatureKeyUserid", signatureKeyUserid).     }     if (password != null) {         setProperty(camelContext, dataFormat, "password", password).     }     if (signaturePassword != null) {         setProperty(camelContext, dataFormat, "signaturePassword", signaturePassword).     }     if (keyFileName != null) {         setProperty(camelContext, dataFormat, "keyFileName", keyFileName).     }     if (signatureKeyFileName != null) {         setProperty(camelContext, dataFormat, "signatureKeyFileName", signatureKeyFileName).     }     if (signatureKeyRing != null) {         setProperty(camelContext, dataFormat, "signatureKeyRing", signatureKeyRing).     }     if (armored != null) {         setProperty(camelContext, dataFormat, "armored", armored).     }     if (integrity != null) {         setProperty(camelContext, dataFormat, "integrity", integrity).     }     if (provider != null) {         setProperty(camelContext, dataFormat, "provider", provider).     }     if (algorithm != null) {         setProperty(camelContext, dataFormat, "algorithm", algorithm).     }     if (compressionAlgorithm != null) {         setProperty(camelContext, dataFormat, "compressionAlgorithm", compressionAlgorithm).     }     if (hashAlgorithm != null) {         setProperty(camelContext, dataFormat, "hashAlgorithm", hashAlgorithm).     }     if (signatureVerificationOption != null) {         setProperty(camelContext, dataFormat, "signatureVerificationOption", signatureVerificationOption).     } }
false;public;0;3;;public String getSignatureKeyUserid() {     return signatureKeyUserid. }
true;public;1;3;/**  * User ID of the key in the PGP keyring used for signing (during encryption) or signature verification (during decryption).  * During the signature verification process the specified User ID restricts the public keys from the public  * keyring which can be used for the verification. If no User ID is specified for the signature verficiation  * then any public key in the public keyring can be used for the verification. Can also be only a part of a user ID.  * For example, if the user ID is "Test User <test@camel.com>" then you can use the  * part "Test User" or "<test@camel.com>" to address the User ID.  */ ;/**  * User ID of the key in the PGP keyring used for signing (during encryption) or signature verification (during decryption).  * During the signature verification process the specified User ID restricts the public keys from the public  * keyring which can be used for the verification. If no User ID is specified for the signature verficiation  * then any public key in the public keyring can be used for the verification. Can also be only a part of a user ID.  * For example, if the user ID is "Test User <test@camel.com>" then you can use the  * part "Test User" or "<test@camel.com>" to address the User ID.  */ public void setSignatureKeyUserid(String signatureKeyUserid) {     this.signatureKeyUserid = signatureKeyUserid. }
false;public;0;3;;public String getSignaturePassword() {     return signaturePassword. }
true;public;1;3;/**  * Password used when opening the private key used for signing (during encryption).  */ ;/**  * Password used when opening the private key used for signing (during encryption).  */ public void setSignaturePassword(String signaturePassword) {     this.signaturePassword = signaturePassword. }
false;public;0;3;;public String getSignatureKeyFileName() {     return signatureKeyFileName. }
true;public;1;3;/**  * Filename of the keyring to use for signing (during encryption) or for signature verification (during decryption).  * must be accessible as a classpath resource (but you can specify a location in the file system by using the "file:" prefix).  */ ;/**  * Filename of the keyring to use for signing (during encryption) or for signature verification (during decryption).  * must be accessible as a classpath resource (but you can specify a location in the file system by using the "file:" prefix).  */ public void setSignatureKeyFileName(String signatureKeyFileName) {     this.signatureKeyFileName = signatureKeyFileName. }
false;public;0;3;;public String getSignatureKeyRing() {     return signatureKeyRing. }
true;public;1;3;/**  * Keyring used for signing/verifying as byte array.  * You can not set the signatureKeyFileName and signatureKeyRing at the same time.  */ ;/**  * Keyring used for signing/verifying as byte array.  * You can not set the signatureKeyFileName and signatureKeyRing at the same time.  */ public void setSignatureKeyRing(String signatureKeyRing) {     this.signatureKeyRing = signatureKeyRing. }
false;public;0;3;;public Integer getHashAlgorithm() {     return hashAlgorithm. }
true;public;1;3;/**  * Signature hash algorithm. possible values are defined in org.bouncycastle.bcpg.HashAlgorithmTags.  * for example 2 (= SHA1), 8 (= SHA256), 9 (= SHA384), 10 (= SHA512), 11 (=SHA224). Only relevant for signing.  */ ;/**  * Signature hash algorithm. possible values are defined in org.bouncycastle.bcpg.HashAlgorithmTags.  * for example 2 (= SHA1), 8 (= SHA256), 9 (= SHA384), 10 (= SHA512), 11 (=SHA224). Only relevant for signing.  */ public void setHashAlgorithm(Integer hashAlgorithm) {     this.hashAlgorithm = hashAlgorithm. }
false;public;0;3;;public Boolean getArmored() {     return armored. }
true;public;1;3;/**  * This option will cause PGP to base64 encode the encrypted text, making it available for copy/paste, etc.  */ ;/**  * This option will cause PGP to base64 encode the encrypted text, making it available for copy/paste, etc.  */ public void setArmored(Boolean armored) {     this.armored = armored. }
false;public;0;3;;public Boolean getIntegrity() {     return integrity. }
true;public;1;3;/**  * Adds an integrity check/sign into the encryption file.  * <p/>  * The default value is true.  */ ;/**  * Adds an integrity check/sign into the encryption file.  * <p/>  * The default value is true.  */ public void setIntegrity(Boolean integrity) {     this.integrity = integrity. }
false;public;0;3;;public String getKeyFileName() {     return keyFileName. }
true;public;1;3;/**  * Filename of the keyring. must be accessible as a classpath resource (but you can specify a location in the file system by using the "file:" prefix).  */ ;/**  * Filename of the keyring. must be accessible as a classpath resource (but you can specify a location in the file system by using the "file:" prefix).  */ public void setKeyFileName(String keyFileName) {     this.keyFileName = keyFileName. }
false;public;0;3;;public String getKeyUserid() {     return keyUserid. }
true;public;1;3;/**  * The user ID of the key in the PGP keyring used during encryption.  * Can also be only a part of a user ID.  * For example, if the user ID is "Test User <test@camel.com>"  * then you can use the part "Test User" or "<test@camel.com>" to address the user ID.  */ ;/**  * The user ID of the key in the PGP keyring used during encryption.  * Can also be only a part of a user ID.  * For example, if the user ID is "Test User <test@camel.com>"  * then you can use the part "Test User" or "<test@camel.com>" to address the user ID.  */ public void setKeyUserid(String keyUserid) {     this.keyUserid = keyUserid. }
false;public;0;3;;public String getPassword() {     return password. }
false;public;0;3;;public Integer getAlgorithm() {     return algorithm. }
true;public;1;3;/**  * Symmetric key encryption algorithm. possible values are defined in org.bouncycastle.bcpg.SymmetricKeyAlgorithmTags.  * for example 2 (= TRIPLE DES), 3 (= CAST5), 4 (= BLOWFISH), 6 (= DES), 7 (= AES_128). Only relevant for encrypting.  */ ;/**  * Symmetric key encryption algorithm. possible values are defined in org.bouncycastle.bcpg.SymmetricKeyAlgorithmTags.  * for example 2 (= TRIPLE DES), 3 (= CAST5), 4 (= BLOWFISH), 6 (= DES), 7 (= AES_128). Only relevant for encrypting.  */ public void setAlgorithm(Integer algorithm) {     this.algorithm = algorithm. }
false;public;0;3;;public Integer getCompressionAlgorithm() {     return compressionAlgorithm. }
true;public;1;3;/**  * Compression algorithm. possible values are defined in org.bouncycastle.bcpg.CompressionAlgorithmTags.  * for example 0 (= UNCOMPRESSED), 1 (= ZIP), 2 (= ZLIB), 3 (= BZIP2). Only relevant for encrypting.  */ ;/**  * Compression algorithm. possible values are defined in org.bouncycastle.bcpg.CompressionAlgorithmTags.  * for example 0 (= UNCOMPRESSED), 1 (= ZIP), 2 (= ZLIB), 3 (= BZIP2). Only relevant for encrypting.  */ public void setCompressionAlgorithm(Integer compressionAlgorithm) {     this.compressionAlgorithm = compressionAlgorithm. }
true;public;1;3;/**  * Password used when opening the private key (not used for encryption).  */ ;/**  * Password used when opening the private key (not used for encryption).  */ public void setPassword(String password) {     this.password = password. }
false;public;0;3;;public String getProvider() {     return provider. }
true;public;1;3;/**  * Java Cryptography Extension (JCE) provider, default is Bouncy Castle  * ("BC"). Alternatively you can use, for example, the IAIK JCE provider. in  * this case the provider must be registered beforehand and the Bouncy  * Castle provider must not be registered beforehand. The Sun JCE provider  * does not work.  */ ;/**  * Java Cryptography Extension (JCE) provider, default is Bouncy Castle  * ("BC"). Alternatively you can use, for example, the IAIK JCE provider. in  * this case the provider must be registered beforehand and the Bouncy  * Castle provider must not be registered beforehand. The Sun JCE provider  * does not work.  */ public void setProvider(String provider) {     this.provider = provider. }
false;public;0;3;;public String getSignatureVerificationOption() {     return signatureVerificationOption. }
true;public;1;3;/**  * Controls the behavior for verifying the signature during unmarshaling. There are 4 values possible:  * "optional": The PGP message may or may not contain signatures. if it does contain signatures, then a signature verification is executed.  * "required": The PGP message must contain at least one signature. if this is not the case an exception (PGPException) is thrown. A signature verification is executed.  * "ignore": Contained signatures in the PGP message are ignored. no signature verification is executed.  * "no_signature_allowed": The PGP message must not contain a signature. otherwise an exception (PGPException) is thrown.  */ ;/**  * Controls the behavior for verifying the signature during unmarshaling. There are 4 values possible:  * "optional": The PGP message may or may not contain signatures. if it does contain signatures, then a signature verification is executed.  * "required": The PGP message must contain at least one signature. if this is not the case an exception (PGPException) is thrown. A signature verification is executed.  * "ignore": Contained signatures in the PGP message are ignored. no signature verification is executed.  * "no_signature_allowed": The PGP message must not contain a signature. otherwise an exception (PGPException) is thrown.  */ public void setSignatureVerificationOption(String signatureVerificationOption) {     this.signatureVerificationOption = signatureVerificationOption. }
