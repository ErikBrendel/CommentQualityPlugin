commented;modifiers;parameterAmount;loc;comment;code
false;public;2;23;;public void addExceptionPolicy(RouteContext routeContext, OnExceptionDefinition exceptionType) {     if (routeContext != null) {         // add error handler as child service so they get lifecycle handled         Processor errorHandler = exceptionType.getErrorHandler(routeContext.getRoute().getId()).         if (errorHandler != null) {             addChildService(errorHandler).         }     }     List<Class<? extends Throwable>> list = exceptionType.getExceptionClasses().     for (Class<? extends Throwable> clazz : list) {         String routeId = null.         // only get the route id, if the exception type is route scoped         if (exceptionType.isRouteScoped()) {             RouteDefinition route = ProcessorDefinitionHelper.getRoute(exceptionType).             if (route != null) {                 routeId = route.getId().             }         }         ExceptionPolicyKey key = new ExceptionPolicyKey(routeId, clazz, exceptionType.getOnWhen()).         exceptionPolicies.put(key, exceptionType).     } }
true;protected;2;7;/**  * Attempts to find the best suited {@link OnExceptionDefinition} to be used for handling the given thrown exception.  *  * @param exchange  the exchange  * @param exception the exception that was thrown  * @return the best exception type to handle this exception, <tt>null</tt> if none found.  */ ;/**  * Attempts to find the best suited {@link OnExceptionDefinition} to be used for handling the given thrown exception.  *  * @param exchange  the exchange  * @param exception the exception that was thrown  * @return the best exception type to handle this exception, <tt>null</tt> if none found.  */ protected OnExceptionDefinition getExceptionPolicy(Exchange exchange, Throwable exception) {     if (exceptionPolicy == null) {         throw new IllegalStateException("The exception policy has not been set").     }     return exceptionPolicy.getExceptionPolicy(exceptionPolicies, exchange, exception). }
true;public;1;5;/**  * Sets the strategy to use for resolving the {@link OnExceptionDefinition} to use  * for handling thrown exceptions.  */ ;/**  * Sets the strategy to use for resolving the {@link OnExceptionDefinition} to use  * for handling thrown exceptions.  */ public void setExceptionPolicy(ExceptionPolicyStrategy exceptionPolicy) {     if (exceptionPolicy != null) {         this.exceptionPolicy = exceptionPolicy.     } }
true;public,static;0;3;/**  * Creates the default exception policy strategy to use.  */ ;/**  * Creates the default exception policy strategy to use.  */ public static ExceptionPolicyStrategy createDefaultExceptionPolicyStrategy() {     return new DefaultExceptionPolicyStrategy(). }
true;public,abstract;0;1;/**  * Whether this error handler supports transacted exchanges or not.  */ ;/**  * Whether this error handler supports transacted exchanges or not.  */ public abstract boolean supportTransacted().
true;public;0;3;/**  * Whether this error handler handles exhausted errors by moving the exchange to a dead letter channel.  */ ;/**  * Whether this error handler handles exhausted errors by moving the exchange to a dead letter channel.  */ public boolean isDeadLetterChannel() {     return false. }
true;public,abstract;0;1;/**  * Gets the output  */ ;/**  * Gets the output  */ public abstract Processor getOutput().
