commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "BeanProcessor[" + beanHolder + "]". }
false;public;2;123;;public boolean process(Exchange exchange, AsyncCallback callback) {     // do we have an explicit method name we always should invoke (either configured on endpoint or as a header)     String explicitMethodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, method, String.class).     Object bean.     BeanInfo beanInfo.     try {         bean = beanHolder.getBean().         // get bean info for this bean instance (to avoid thread issue)         beanInfo = beanHolder.getBeanInfo(bean).         if (beanInfo == null) {             // fallback and use old way             beanInfo = beanHolder.getBeanInfo().         }     } catch (Throwable e) {         exchange.setException(e).         callback.done(true).         return true.     }     // we need to check beanHolder is Processor is support, to avoid the bean cached issue     if (allowProcessor(explicitMethodName, beanInfo)) {         Processor target = getProcessor().         if (target == null) {             // only attempt to lookup the processor once or nearly once             // allow cache by default             boolean allowCache = cache == null || cache.             if (allowCache) {                 if (!lookupProcessorDone) {                     synchronized (lock) {                         lookupProcessorDone = true.                         // so if there is a custom type converter for the bean to processor                         target = exchange.getContext().getTypeConverter().tryConvertTo(Processor.class, exchange, bean).                         processor = target.                     }                 }             } else {                 // so if there is a custom type converter for the bean to processor                 target = exchange.getContext().getTypeConverter().tryConvertTo(Processor.class, exchange, bean).             }         }         if (target != null) {             if (log.isTraceEnabled()) {                 log.trace("Using a custom adapter as bean invocation: {}", target).             }             try {                 target.process(exchange).             } catch (Throwable e) {                 exchange.setException(e).             }             callback.done(true).             return true.         }     }     Message in = exchange.getIn().     // is the message proxied using a BeanInvocation?     BeanInvocation beanInvoke = null.     if (in.getBody() instanceof BeanInvocation) {         // BeanInvocation would be stored directly as the message body         // do not force any type conversion attempts as it would just be unnecessary and cost a bit performance         // so a regular instanceof check is sufficient         beanInvoke = (BeanInvocation) in.getBody().     }     if (beanInvoke != null) {         // so we must test whether BeanHolder and BeanInvocation is the same bean or not         if (log.isTraceEnabled()) {             log.trace("Exchange IN body is a BeanInvocation instance: {}", beanInvoke).         }         Class<?> clazz = beanInvoke.getMethod().getDeclaringClass().         boolean sameBean = clazz.isInstance(bean).         if (log.isDebugEnabled()) {             log.debug("BeanHolder bean: {} and beanInvocation bean: {} is same instance: {}", bean.getClass(), clazz, sameBean).         }         if (sameBean) {             try {                 beanInvoke.invoke(bean, exchange).                 if (exchange.hasOut()) {                     // propagate headers                     exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders()).                 }             } catch (Throwable e) {                 exchange.setException(e).             }             callback.done(true).             return true.         }     }     // set explicit method name to invoke as a header, which is how BeanInfo can detect it     if (explicitMethodName != null) {         in.setHeader(Exchange.BEAN_METHOD_NAME, explicitMethodName).     }     MethodInvocation invocation.     try {         invocation = beanInfo.createInvocation(bean, exchange).     } catch (Throwable e) {         exchange.setException(e).         callback.done(true).         return true.     } finally {         // must remove headers as they were provisional         if (explicitMethodName != null) {             in.removeHeader(Exchange.BEAN_METHOD_NAME).         }     }     if (invocation == null) {         exchange.setException(new IllegalStateException("No method invocation could be created, no matching method could be found on: " + bean)).         callback.done(true).         return true.     }     // invoke invocation     return invocation.proceed(callback). }
false;protected;0;3;;protected Processor getProcessor() {     return processor. }
false;protected;0;3;;protected BeanHolder getBeanHolder() {     return this.beanHolder. }
false;public;0;3;;public Object getBean() {     return beanHolder.getBean(). }
false;public;0;3;;// Properties // ----------------------------------------------------------------------- public String getMethod() {     return method. }
false;public;0;3;;public Boolean getCache() {     return cache. }
false;public;1;3;;public void setCache(Boolean cache) {     this.cache = cache. }
true;public;1;3;/**  * Sets the method name to use  */ ;/**  * Sets the method name to use  */ public void setMethod(String method) {     this.method = method. }
false;public;0;3;;public boolean isShorthandMethod() {     return shorthandMethod. }
true;public;1;3;/**  * Sets whether to support getter style method name, so you can  * say the method is called 'name' but it will invoke the 'getName' method.  * <p/>  * Is by default turned off.  */ ;/**  * Sets whether to support getter style method name, so you can  * say the method is called 'name' but it will invoke the 'getName' method.  * <p/>  * Is by default turned off.  */ public void setShorthandMethod(boolean shorthandMethod) {     this.shorthandMethod = shorthandMethod. }
true;protected;0;15;// ------------------------------------------------------------------------- ;// Implementation methods // ------------------------------------------------------------------------- protected void doStart() throws Exception {     // optimize to only get (create) a processor if really needed     if (beanHolder.supportProcessor() && allowProcessor(method, beanHolder.getBeanInfo())) {         processor = beanHolder.getProcessor().         ServiceHelper.startService(processor).     } else if (beanHolder instanceof ConstantBeanHolder) {         try {             // Start the bean if it implements Service interface and if cached             // so meant to be reused             ServiceHelper.startService(beanHolder.getBean()).         } catch (NoSuchBeanException e) {         // ignore         }     } }
false;protected;0;13;;protected void doStop() throws Exception {     if (processor != null) {         ServiceHelper.stopService(processor).     } else if (beanHolder instanceof ConstantBeanHolder) {         try {             // Stop the bean if it implements Service interface and if cached             // so meant to be reused             ServiceHelper.stopService(beanHolder.getBean()).         } catch (NoSuchBeanException e) {         // ignore         }     } }
false;private;2;16;;private boolean allowProcessor(String explicitMethodName, BeanInfo info) {     if (explicitMethodName != null) {         // don't allow if explicit method name is given, as we then must invoke this method         return false.     }     // of the given method     if (info.hasAnyMethodHandlerAnnotation()) {         return false.     }     // fallback and allow using the processor     return true. }
