commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;1;3;;public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setId(String id) {     this.id = id. }
false;public;0;3;;public Expression getExpression() {     return expression. }
false;public;0;3;;public EndpointUtilizationStatistics getEndpointUtilizationStatistics() {     return producerCache.getEndpointUtilizationStatistics(). }
false;public;1;3;;public void setAggregationStrategy(AggregationStrategy aggregationStrategy) {     this.aggregationStrategy = aggregationStrategy. }
false;public;0;3;;public AggregationStrategy getAggregationStrategy() {     return aggregationStrategy. }
false;public;0;3;;public boolean isAggregateOnException() {     return aggregateOnException. }
false;public;1;3;;public void setAggregateOnException(boolean aggregateOnException) {     this.aggregateOnException = aggregateOnException. }
false;public;0;3;;public boolean isShareUnitOfWork() {     return shareUnitOfWork. }
false;public;1;3;;public void setShareUnitOfWork(boolean shareUnitOfWork) {     this.shareUnitOfWork = shareUnitOfWork. }
false;public;0;3;;public int getCacheSize() {     return cacheSize. }
false;public;1;3;;public void setCacheSize(int cacheSize) {     this.cacheSize = cacheSize. }
false;public;0;3;;public boolean isIgnoreInvalidEndpoint() {     return ignoreInvalidEndpoint. }
false;public;1;3;;public void setIgnoreInvalidEndpoint(boolean ignoreInvalidEndpoint) {     this.ignoreInvalidEndpoint = ignoreInvalidEndpoint. }
false;public;1;47;;public void done(boolean doneSync) {     // we only have to handle async completion of the routing slip     if (doneSync) {         return.     }     // emit event that the exchange was sent to the endpoint     if (watch != null) {         long timeTaken = watch.taken().         EventHelper.notifyExchangeSent(resourceExchange.getContext(), resourceExchange, destination, timeTaken).     }     if (!isAggregateOnException() && resourceExchange.isFailed()) {         // copy resource exchange onto original exchange (preserving pattern)         copyResultsPreservePattern(exchange, resourceExchange).     } else {         prepareResult(exchange).         try {             // prepare the exchanges for aggregation             ExchangeHelper.prepareAggregation(exchange, resourceExchange).             Exchange aggregatedExchange = aggregationStrategy.aggregate(exchange, resourceExchange).             if (aggregatedExchange != null) {                 // copy aggregation result onto original exchange (preserving pattern)                 copyResultsPreservePattern(exchange, aggregatedExchange).             }         } catch (Throwable e) {             // if the aggregationStrategy threw an exception, set it on the original exchange             exchange.setException(new CamelExchangeException("Error occurred during aggregation", exchange, e)).             callback.done(false).             // we failed so break out now             return.         }     }     // set property with the uri of the endpoint enriched so we can use that for tracing etc     exchange.setProperty(Exchange.TO_ENDPOINT, producer.getEndpoint().getEndpointUri()).     // return the producer back to the cache     try {         producerCache.releaseProducer(endpoint, producer).     } catch (Exception e) {     // ignore     }     callback.done(false). }
true;public;2;137;/**  * Enriches the input data (<code>exchange</code>) by first obtaining  * additional data from an endpoint represented by an endpoint  * <code>producer</code> and second by aggregating input data and additional  * data. Aggregation of input data and additional data is delegated to an  * {@link AggregationStrategy} object set at construction time. If the  * message exchange with the resource endpoint fails then no aggregation  * will be done and the failed exchange content is copied over to the  * original message exchange.  *  * @param exchange input data.  */ ;/**  * Enriches the input data (<code>exchange</code>) by first obtaining  * additional data from an endpoint represented by an endpoint  * <code>producer</code> and second by aggregating input data and additional  * data. Aggregation of input data and additional data is delegated to an  * {@link AggregationStrategy} object set at construction time. If the  * message exchange with the resource endpoint fails then no aggregation  * will be done and the failed exchange content is copied over to the  * original message exchange.  *  * @param exchange input data.  */ public boolean process(final Exchange exchange, final AsyncCallback callback) {     // which producer to use     final AsyncProducer producer.     final Endpoint endpoint.     // use dynamic endpoint so calculate the endpoint to use     Object recipient = null.     try {         recipient = expression.evaluate(exchange, Object.class).         endpoint = resolveEndpoint(exchange, recipient).         // acquire the consumer from the cache         producer = producerCache.acquireProducer(endpoint).     } catch (Throwable e) {         if (isIgnoreInvalidEndpoint()) {             if (log.isDebugEnabled()) {                 log.debug("Endpoint uri is invalid: " + recipient + ". This exception will be ignored.", e).             }         } else {             exchange.setException(e).         }         callback.done(true).         return true.     }     final Exchange resourceExchange = createResourceExchange(exchange, ExchangePattern.InOut).     final Endpoint destination = producer.getEndpoint().     StopWatch sw = null.     boolean sending = EventHelper.notifyExchangeSending(exchange.getContext(), resourceExchange, destination).     if (sending) {         sw = new StopWatch().     }     // record timing for sending the exchange using the producer     final StopWatch watch = sw.     AsyncProcessor ap = AsyncProcessorConverterHelper.convert(producer).     boolean sync = ap.process(resourceExchange, new AsyncCallback() {          public void done(boolean doneSync) {             // we only have to handle async completion of the routing slip             if (doneSync) {                 return.             }             // emit event that the exchange was sent to the endpoint             if (watch != null) {                 long timeTaken = watch.taken().                 EventHelper.notifyExchangeSent(resourceExchange.getContext(), resourceExchange, destination, timeTaken).             }             if (!isAggregateOnException() && resourceExchange.isFailed()) {                 // copy resource exchange onto original exchange (preserving pattern)                 copyResultsPreservePattern(exchange, resourceExchange).             } else {                 prepareResult(exchange).                 try {                     // prepare the exchanges for aggregation                     ExchangeHelper.prepareAggregation(exchange, resourceExchange).                     Exchange aggregatedExchange = aggregationStrategy.aggregate(exchange, resourceExchange).                     if (aggregatedExchange != null) {                         // copy aggregation result onto original exchange (preserving pattern)                         copyResultsPreservePattern(exchange, aggregatedExchange).                     }                 } catch (Throwable e) {                     // if the aggregationStrategy threw an exception, set it on the original exchange                     exchange.setException(new CamelExchangeException("Error occurred during aggregation", exchange, e)).                     callback.done(false).                     // we failed so break out now                     return.                 }             }             // set property with the uri of the endpoint enriched so we can use that for tracing etc             exchange.setProperty(Exchange.TO_ENDPOINT, producer.getEndpoint().getEndpointUri()).             // return the producer back to the cache             try {                 producerCache.releaseProducer(endpoint, producer).             } catch (Exception e) {             // ignore             }             callback.done(false).         }     }).     if (!sync) {         log.trace("Processing exchangeId: {} is continued being processed asynchronously", exchange.getExchangeId()).         // so we break out now, then the callback will be invoked which then continue routing from where we left here         return false.     }     log.trace("Processing exchangeId: {} is continued being processed synchronously", exchange.getExchangeId()).     if (watch != null) {         // emit event that the exchange was sent to the endpoint         long timeTaken = watch.taken().         EventHelper.notifyExchangeSent(resourceExchange.getContext(), resourceExchange, destination, timeTaken).     }     if (!isAggregateOnException() && resourceExchange.isFailed()) {         // copy resource exchange onto original exchange (preserving pattern)         copyResultsPreservePattern(exchange, resourceExchange).     } else {         prepareResult(exchange).         try {             // prepare the exchanges for aggregation             ExchangeHelper.prepareAggregation(exchange, resourceExchange).             Exchange aggregatedExchange = aggregationStrategy.aggregate(exchange, resourceExchange).             if (aggregatedExchange != null) {                 // copy aggregation result onto original exchange (preserving pattern)                 copyResultsPreservePattern(exchange, aggregatedExchange).             }         } catch (Throwable e) {             // if the aggregationStrategy threw an exception, set it on the original exchange             exchange.setException(new CamelExchangeException("Error occurred during aggregation", exchange, e)).             callback.done(true).             // we failed so break out now             return true.         }     }     // set property with the uri of the endpoint enriched so we can use that for tracing etc     exchange.setProperty(Exchange.TO_ENDPOINT, producer.getEndpoint().getEndpointUri()).     // return the producer back to the cache     try {         producerCache.releaseProducer(endpoint, producer).     } catch (Exception e) {     // ignore     }     callback.done(true).     return true. }
false;protected;2;7;;protected Endpoint resolveEndpoint(Exchange exchange, Object recipient) {     // trim strings as end users might have added spaces between separators     if (recipient instanceof String) {         recipient = ((String) recipient).trim().     }     return ExchangeHelper.resolveEndpoint(exchange, recipient). }
true;protected;2;13;/**  * Creates a new {@link DefaultExchange} instance from the given  * <code>exchange</code>. The resulting exchange's pattern is defined by  * <code>pattern</code>.  *  * @param source  exchange to copy from.  * @param pattern exchange pattern to set.  * @return created exchange.  */ ;/**  * Creates a new {@link DefaultExchange} instance from the given  * <code>exchange</code>. The resulting exchange's pattern is defined by  * <code>pattern</code>.  *  * @param source  exchange to copy from.  * @param pattern exchange pattern to set.  * @return created exchange.  */ protected Exchange createResourceExchange(Exchange source, ExchangePattern pattern) {     // copy exchange, and do not share the unit of work     Exchange target = ExchangeHelper.createCorrelatedCopy(source, false).     target.setPattern(pattern).     // if we share unit of work, we need to prepare the resource exchange     if (isShareUnitOfWork()) {         target.setProperty(Exchange.PARENT_UNIT_OF_WORK, source.getUnitOfWork()).         // and then share the unit of work         target.setUnitOfWork(source.getUnitOfWork()).     }     return target. }
false;private,static;1;5;;private static void prepareResult(Exchange exchange) {     if (exchange.getPattern().isOutCapable()) {         exchange.getOut().copyFrom(exchange.getIn()).     } }
false;private,static;0;3;;private static AggregationStrategy defaultAggregationStrategy() {     return new CopyAggregationStrategy(). }
false;public;0;4;;@Override public String toString() {     return "Enrich[" + expression + "]". }
false;protected;0;15;;protected void doStart() throws Exception {     if (aggregationStrategy == null) {         aggregationStrategy = defaultAggregationStrategy().     }     if (aggregationStrategy instanceof CamelContextAware) {         ((CamelContextAware) aggregationStrategy).setCamelContext(camelContext).     }     if (producerCache == null) {         producerCache = new DefaultProducerCache(this, camelContext, cacheSize).         log.debug("Enricher {} using ProducerCache with cacheSize={}", this, producerCache.getCapacity()).     }     ServiceHelper.startService(producerCache, aggregationStrategy). }
false;protected;0;3;;protected void doStop() throws Exception {     ServiceHelper.stopService(aggregationStrategy, producerCache). }
false;public;2;6;;public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {     if (newExchange != null) {         copyResultsPreservePattern(oldExchange, newExchange).     }     return oldExchange. }
