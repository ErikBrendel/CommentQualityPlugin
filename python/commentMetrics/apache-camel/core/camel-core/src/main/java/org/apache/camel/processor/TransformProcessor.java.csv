commented;modifiers;parameterAmount;loc;comment;code
false;public;2;40;;public boolean process(Exchange exchange, AsyncCallback callback) {     try {         Object newBody = expression.evaluate(exchange, Object.class).         if (exchange.getException() != null) {             // the expression threw an exception so we should break-out             callback.done(true).             return true.         }         boolean out = exchange.hasOut().         Message old = out ? exchange.getOut() : exchange.getIn().         // create a new message container so we do not drag specialized message objects along         // but that is only needed if the old message is a specialized message         boolean copyNeeded = !(old.getClass().equals(DefaultMessage.class)).         if (copyNeeded) {             Message msg = new DefaultMessage(exchange.getContext()).             msg.copyFromWithNewBody(old, newBody).             // replace message on exchange (must set as OUT)             ExchangeHelper.replaceMessage(exchange, msg, true).         } else {             // no copy needed so set replace value directly             old.setBody(newBody).             // but the message must be on OUT             if (!exchange.hasOut()) {                 exchange.setOut(exchange.getIn()).             }         }     } catch (Throwable e) {         exchange.setException(e).     }     callback.done(true).     return true. }
false;public;0;4;;@Override public String toString() {     return "Transform(" + expression + ")". }
false;public;0;3;;public String getTraceLabel() {     return "transform[" + expression + "]". }
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setId(String id) {     this.id = id. }
false;public;0;3;;public Expression getExpression() {     return expression. }
false;protected;0;4;;@Override protected void doStart() throws Exception { // noop }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
