commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return left + " " + token.getText() + " " + right. }
false;public;1;4;;public boolean acceptLeftNode(SimpleNode lef) {     this.left = lef.     return true. }
false;public;1;4;;public boolean acceptRightNode(SimpleNode right) {     this.right = right.     return true. }
false;public;0;3;;public BinaryOperatorType getOperator() {     return operator. }
false;public;1;44;;@Override public Expression createExpression(String expression) {     org.apache.camel.util.ObjectHelper.notNull(left, "left node", this).     org.apache.camel.util.ObjectHelper.notNull(right, "right node", this).     final Expression leftExp = left.createExpression(expression).     final Expression rightExp = right.createExpression(expression).     if (operator == BinaryOperatorType.EQ) {         return createExpression(leftExp, rightExp, PredicateBuilder.isEqualTo(leftExp, rightExp)).     } else if (operator == BinaryOperatorType.EQ_IGNORE) {         return createExpression(leftExp, rightExp, PredicateBuilder.isEqualToIgnoreCase(leftExp, rightExp)).     } else if (operator == BinaryOperatorType.GT) {         return createExpression(leftExp, rightExp, PredicateBuilder.isGreaterThan(leftExp, rightExp)).     } else if (operator == BinaryOperatorType.GTE) {         return createExpression(leftExp, rightExp, PredicateBuilder.isGreaterThanOrEqualTo(leftExp, rightExp)).     } else if (operator == BinaryOperatorType.LT) {         return createExpression(leftExp, rightExp, PredicateBuilder.isLessThan(leftExp, rightExp)).     } else if (operator == BinaryOperatorType.LTE) {         return createExpression(leftExp, rightExp, PredicateBuilder.isLessThanOrEqualTo(leftExp, rightExp)).     } else if (operator == BinaryOperatorType.NOT_EQ) {         return createExpression(leftExp, rightExp, PredicateBuilder.isNotEqualTo(leftExp, rightExp)).     } else if (operator == BinaryOperatorType.CONTAINS) {         return createExpression(leftExp, rightExp, PredicateBuilder.contains(leftExp, rightExp)).     } else if (operator == BinaryOperatorType.NOT_CONTAINS) {         return createExpression(leftExp, rightExp, PredicateBuilder.not(PredicateBuilder.contains(leftExp, rightExp))).     } else if (operator == BinaryOperatorType.CONTAINS_IGNORECASE) {         return createExpression(leftExp, rightExp, PredicateBuilder.containsIgnoreCase(leftExp, rightExp)).     } else if (operator == BinaryOperatorType.IS || operator == BinaryOperatorType.NOT_IS) {         return createIsExpression(expression, leftExp, rightExp).     } else if (operator == BinaryOperatorType.REGEX || operator == BinaryOperatorType.NOT_REGEX) {         return createRegexExpression(leftExp, rightExp).     } else if (operator == BinaryOperatorType.IN || operator == BinaryOperatorType.NOT_IN) {         return createInExpression(leftExp, rightExp).     } else if (operator == BinaryOperatorType.RANGE || operator == BinaryOperatorType.NOT_RANGE) {         return createRangeExpression(expression, leftExp, rightExp).     } else if (operator == BinaryOperatorType.STARTS_WITH) {         return createExpression(leftExp, rightExp, PredicateBuilder.startsWith(leftExp, rightExp)).     } else if (operator == BinaryOperatorType.ENDS_WITH) {         return createExpression(leftExp, rightExp, PredicateBuilder.endsWith(leftExp, rightExp)).     }     throw new SimpleParserException("Unknown binary operator " + operator, token.getIndex()). }
false;public;2;20;;@Override public <T> T evaluate(Exchange exchange, Class<T> type) {     Predicate predicate.     String name = rightExp.evaluate(exchange, String.class).     if (name == null || "null".equals(name)) {         throw new SimpleIllegalSyntaxException(expression, right.getToken().getIndex(), operator + " operator cannot accept null. A class type must be provided.").     }     Class<?> rightType = exchange.getContext().getClassResolver().resolveClass(name).     if (rightType == null) {         throw new SimpleIllegalSyntaxException(expression, right.getToken().getIndex(), operator + " operator cannot find class with name: " + name).     }     predicate = PredicateBuilder.isInstanceOf(leftExp, rightType).     if (operator == BinaryOperatorType.NOT_IS) {         predicate = PredicateBuilder.not(predicate).     }     boolean answer = predicate.matches(exchange).     return exchange.getContext().getTypeConverter().convertTo(type, answer). }
false;public;0;4;;@Override public String toString() {     return left + " " + token.getText() + " " + right. }
false;private;3;29;;private Expression createIsExpression(final String expression, final Expression leftExp, final Expression rightExp) {     return new Expression() {          @Override         public <T> T evaluate(Exchange exchange, Class<T> type) {             Predicate predicate.             String name = rightExp.evaluate(exchange, String.class).             if (name == null || "null".equals(name)) {                 throw new SimpleIllegalSyntaxException(expression, right.getToken().getIndex(), operator + " operator cannot accept null. A class type must be provided.").             }             Class<?> rightType = exchange.getContext().getClassResolver().resolveClass(name).             if (rightType == null) {                 throw new SimpleIllegalSyntaxException(expression, right.getToken().getIndex(), operator + " operator cannot find class with name: " + name).             }             predicate = PredicateBuilder.isInstanceOf(leftExp, rightType).             if (operator == BinaryOperatorType.NOT_IS) {                 predicate = PredicateBuilder.not(predicate).             }             boolean answer = predicate.matches(exchange).             return exchange.getContext().getTypeConverter().convertTo(type, answer).         }          @Override         public String toString() {             return left + " " + token.getText() + " " + right.         }     }. }
false;public;2;10;;@Override public <T> T evaluate(Exchange exchange, Class<T> type) {     // reg ex should use String pattern, so we evaluate the right hand side as a String     Predicate predicate = PredicateBuilder.regex(leftExp, rightExp.evaluate(exchange, String.class)).     if (operator == BinaryOperatorType.NOT_REGEX) {         predicate = PredicateBuilder.not(predicate).     }     boolean answer = predicate.matches(exchange).     return exchange.getContext().getTypeConverter().convertTo(type, answer). }
false;public;0;4;;@Override public String toString() {     return left + " " + token.getText() + " " + right. }
false;private;2;19;;private Expression createRegexExpression(final Expression leftExp, final Expression rightExp) {     return new Expression() {          @Override         public <T> T evaluate(Exchange exchange, Class<T> type) {             // reg ex should use String pattern, so we evaluate the right hand side as a String             Predicate predicate = PredicateBuilder.regex(leftExp, rightExp.evaluate(exchange, String.class)).             if (operator == BinaryOperatorType.NOT_REGEX) {                 predicate = PredicateBuilder.not(predicate).             }             boolean answer = predicate.matches(exchange).             return exchange.getContext().getTypeConverter().convertTo(type, answer).         }          @Override         public String toString() {             return left + " " + token.getText() + " " + right.         }     }. }
false;public;2;19;;@Override public <T> T evaluate(Exchange exchange, Class<T> type) {     // okay the in operator is a bit more complex as we need to build a list of values     // from the right hand side expression.     // each element on the right hand side must be separated by comma (default for create iterator)     Iterator<?> it = ObjectHelper.createIterator(rightExp.evaluate(exchange, Object.class)).     List<Object> values = new ArrayList<>().     while (it.hasNext()) {         values.add(it.next()).     }     // then reuse value builder to create the in predicate with the list of values     ValueBuilder vb = new ValueBuilder(leftExp).     Predicate predicate = vb.in(values.toArray()).     if (operator == BinaryOperatorType.NOT_IN) {         predicate = PredicateBuilder.not(predicate).     }     boolean answer = predicate.matches(exchange).     return exchange.getContext().getTypeConverter().convertTo(type, answer). }
false;public;0;4;;@Override public String toString() {     return left + " " + token.getText() + " " + right. }
false;private;2;28;;private Expression createInExpression(final Expression leftExp, final Expression rightExp) {     return new Expression() {          @Override         public <T> T evaluate(Exchange exchange, Class<T> type) {             // okay the in operator is a bit more complex as we need to build a list of values             // from the right hand side expression.             // each element on the right hand side must be separated by comma (default for create iterator)             Iterator<?> it = ObjectHelper.createIterator(rightExp.evaluate(exchange, Object.class)).             List<Object> values = new ArrayList<>().             while (it.hasNext()) {                 values.add(it.next()).             }             // then reuse value builder to create the in predicate with the list of values             ValueBuilder vb = new ValueBuilder(leftExp).             Predicate predicate = vb.in(values.toArray()).             if (operator == BinaryOperatorType.NOT_IN) {                 predicate = PredicateBuilder.not(predicate).             }             boolean answer = predicate.matches(exchange).             return exchange.getContext().getTypeConverter().convertTo(type, answer).         }          @Override         public String toString() {             return left + " " + token.getText() + " " + right.         }     }. }
false;public;2;24;;@Override public <T> T evaluate(Exchange exchange, Class<T> type) {     Predicate predicate.     String range = rightExp.evaluate(exchange, String.class).     Matcher matcher = RANGE_PATTERN.matcher(range).     if (matcher.matches()) {         // wrap as constant expression for the from and to values         Expression from = ExpressionBuilder.constantExpression(matcher.group(1)).         Expression to = ExpressionBuilder.constantExpression(matcher.group(3)).         // build a compound predicate for the range         predicate = PredicateBuilder.isGreaterThanOrEqualTo(leftExp, from).         predicate = PredicateBuilder.and(predicate, PredicateBuilder.isLessThanOrEqualTo(leftExp, to)).     } else {         throw new SimpleIllegalSyntaxException(expression, right.getToken().getIndex(), operator + " operator is not valid. Valid syntax:'from..to' (where from and to are numbers).").     }     if (operator == BinaryOperatorType.NOT_RANGE) {         predicate = PredicateBuilder.not(predicate).     }     boolean answer = predicate.matches(exchange).     return exchange.getContext().getTypeConverter().convertTo(type, answer). }
false;public;0;4;;@Override public String toString() {     return left + " " + token.getText() + " " + right. }
false;private;3;33;;private Expression createRangeExpression(final String expression, final Expression leftExp, final Expression rightExp) {     return new Expression() {          @Override         public <T> T evaluate(Exchange exchange, Class<T> type) {             Predicate predicate.             String range = rightExp.evaluate(exchange, String.class).             Matcher matcher = RANGE_PATTERN.matcher(range).             if (matcher.matches()) {                 // wrap as constant expression for the from and to values                 Expression from = ExpressionBuilder.constantExpression(matcher.group(1)).                 Expression to = ExpressionBuilder.constantExpression(matcher.group(3)).                 // build a compound predicate for the range                 predicate = PredicateBuilder.isGreaterThanOrEqualTo(leftExp, from).                 predicate = PredicateBuilder.and(predicate, PredicateBuilder.isLessThanOrEqualTo(leftExp, to)).             } else {                 throw new SimpleIllegalSyntaxException(expression, right.getToken().getIndex(), operator + " operator is not valid. Valid syntax:'from..to' (where from and to are numbers).").             }             if (operator == BinaryOperatorType.NOT_RANGE) {                 predicate = PredicateBuilder.not(predicate).             }             boolean answer = predicate.matches(exchange).             return exchange.getContext().getTypeConverter().convertTo(type, answer).         }          @Override         public String toString() {             return left + " " + token.getText() + " " + right.         }     }. }
false;public;2;5;;@Override public <T> T evaluate(Exchange exchange, Class<T> type) {     boolean answer = predicate.matches(exchange).     return exchange.getContext().getTypeConverter().convertTo(type, answer). }
false;public;0;4;;@Override public String toString() {     return left + " " + token.getText() + " " + right. }
false;private;3;14;;private Expression createExpression(final Expression left, final Expression right, final Predicate predicate) {     return new Expression() {          @Override         public <T> T evaluate(Exchange exchange, Class<T> type) {             boolean answer = predicate.matches(exchange).             return exchange.getContext().getTypeConverter().convertTo(type, answer).         }          @Override         public String toString() {             return left + " " + token.getText() + " " + right.         }     }. }
