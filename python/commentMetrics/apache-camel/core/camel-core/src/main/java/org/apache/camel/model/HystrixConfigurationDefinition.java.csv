commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Sets the group key to use. The default value is CamelHystrix.  */ ;// Fluent API // ------------------------------------------------------------------------- /**  * Sets the group key to use. The default value is CamelHystrix.  */ public HystrixConfigurationDefinition groupKey(String groupKey) {     setGroupKey(groupKey).     return this. }
true;public;1;4;/**  * Sets the thread pool key to use. Will by default use the same value as groupKey has been configured to use.  */ ;/**  * Sets the thread pool key to use. Will by default use the same value as groupKey has been configured to use.  */ public HystrixConfigurationDefinition threadPoolKey(String threadPoolKey) {     setThreadPoolKey(threadPoolKey).     return this. }
true;public;1;4;/**  * Whether to use a HystrixCircuitBreaker or not. If false no circuit-breaker logic will be used and all requests permitted.  * <p>  * This is similar in effect to circuitBreakerForceClosed() except that continues tracking metrics and knowing whether it  * should be open/closed, this property results in not even instantiating a circuit-breaker.  */ ;/**  * Whether to use a HystrixCircuitBreaker or not. If false no circuit-breaker logic will be used and all requests permitted.  * <p>  * This is similar in effect to circuitBreakerForceClosed() except that continues tracking metrics and knowing whether it  * should be open/closed, this property results in not even instantiating a circuit-breaker.  */ public HystrixConfigurationDefinition circuitBreakerEnabled(Boolean circuitBreakerEnabled) {     setCircuitBreakerEnabled(circuitBreakerEnabled).     return this. }
true;public;1;4;/**  * Error percentage threshold (as whole number such as 50) at which point the circuit breaker will trip open and reject requests.  * <p>  * It will stay tripped for the duration defined in circuitBreakerSleepWindowInMilliseconds.  * <p>  * The error percentage this is compared against comes from HystrixCommandMetrics.getHealthCounts().  */ ;/**  * Error percentage threshold (as whole number such as 50) at which point the circuit breaker will trip open and reject requests.  * <p>  * It will stay tripped for the duration defined in circuitBreakerSleepWindowInMilliseconds.  * <p>  * The error percentage this is compared against comes from HystrixCommandMetrics.getHealthCounts().  */ public HystrixConfigurationDefinition circuitBreakerErrorThresholdPercentage(Integer circuitBreakerErrorThresholdPercentage) {     setCircuitBreakerErrorThresholdPercentage(circuitBreakerErrorThresholdPercentage).     return this. }
true;public;1;4;/**  * If true the HystrixCircuitBreaker.allowRequest() will always return true to allow requests regardless of  * the error percentage from HystrixCommandMetrics.getHealthCounts().  * <p>  * The circuitBreakerForceOpen() property takes precedence so if it set to true this property does nothing.  */ ;/**  * If true the HystrixCircuitBreaker.allowRequest() will always return true to allow requests regardless of  * the error percentage from HystrixCommandMetrics.getHealthCounts().  * <p>  * The circuitBreakerForceOpen() property takes precedence so if it set to true this property does nothing.  */ public HystrixConfigurationDefinition circuitBreakerForceClosed(Boolean circuitBreakerForceClosed) {     setCircuitBreakerForceClosed(circuitBreakerForceClosed).     return this. }
true;public;1;4;/**  * If true the HystrixCircuitBreaker.allowRequest() will always return false, causing the circuit to be open (tripped) and reject all requests.  * <p>  * This property takes precedence over circuitBreakerForceClosed().  */ ;/**  * If true the HystrixCircuitBreaker.allowRequest() will always return false, causing the circuit to be open (tripped) and reject all requests.  * <p>  * This property takes precedence over circuitBreakerForceClosed().  */ public HystrixConfigurationDefinition circuitBreakerForceOpen(Boolean circuitBreakerForceOpen) {     setCircuitBreakerForceOpen(circuitBreakerForceOpen).     return this. }
true;public;1;4;/**  * Minimum number of requests in the metricsRollingStatisticalWindowInMilliseconds() that must exist before the HystrixCircuitBreaker will trip.  * <p>  * If below this number the circuit will not trip regardless of error percentage.  */ ;/**  * Minimum number of requests in the metricsRollingStatisticalWindowInMilliseconds() that must exist before the HystrixCircuitBreaker will trip.  * <p>  * If below this number the circuit will not trip regardless of error percentage.  */ public HystrixConfigurationDefinition circuitBreakerRequestVolumeThreshold(Integer circuitBreakerRequestVolumeThreshold) {     setCircuitBreakerRequestVolumeThreshold(circuitBreakerRequestVolumeThreshold).     return this. }
true;public;1;4;/**  * The time in milliseconds after a HystrixCircuitBreaker trips open that it should wait before trying requests again.  */ ;/**  * The time in milliseconds after a HystrixCircuitBreaker trips open that it should wait before trying requests again.  */ public HystrixConfigurationDefinition circuitBreakerSleepWindowInMilliseconds(Integer circuitBreakerSleepWindowInMilliseconds) {     setCircuitBreakerSleepWindowInMilliseconds(circuitBreakerSleepWindowInMilliseconds).     return this. }
true;public;1;4;/**  * Number of concurrent requests permitted to HystrixCommand.run(). Requests beyond the concurrent limit will be rejected.  * <p>  * Applicable only when executionIsolationStrategy is SEMAPHORE.  */ ;/**  * Number of concurrent requests permitted to HystrixCommand.run(). Requests beyond the concurrent limit will be rejected.  * <p>  * Applicable only when executionIsolationStrategy is SEMAPHORE.  */ public HystrixConfigurationDefinition executionIsolationSemaphoreMaxConcurrentRequests(Integer executionIsolationSemaphoreMaxConcurrentRequests) {     setExecutionIsolationSemaphoreMaxConcurrentRequests(executionIsolationSemaphoreMaxConcurrentRequests).     return this. }
true;public;1;4;/**  * What isolation strategy HystrixCommand.run() will be executed with.  * <p>  * If THREAD then it will be executed on a separate thread and concurrent requests limited by the number of threads in the thread-pool.  * <p>  * If SEMAPHORE then it will be executed on the calling thread and concurrent requests limited by the semaphore count.  */ ;/**  * What isolation strategy HystrixCommand.run() will be executed with.  * <p>  * If THREAD then it will be executed on a separate thread and concurrent requests limited by the number of threads in the thread-pool.  * <p>  * If SEMAPHORE then it will be executed on the calling thread and concurrent requests limited by the semaphore count.  */ public HystrixConfigurationDefinition executionIsolationStrategy(String executionIsolationStrategy) {     setExecutionIsolationStrategy(executionIsolationStrategy).     return this. }
true;public;1;4;/**  * Whether the execution thread should attempt an interrupt (using Future cancel) when a thread times out.  * <p>  * Applicable only when executionIsolationStrategy() is set to THREAD.  */ ;/**  * Whether the execution thread should attempt an interrupt (using Future cancel) when a thread times out.  * <p>  * Applicable only when executionIsolationStrategy() is set to THREAD.  */ public HystrixConfigurationDefinition executionIsolationThreadInterruptOnTimeout(Boolean executionIsolationThreadInterruptOnTimeout) {     setExecutionIsolationThreadInterruptOnTimeout(executionIsolationThreadInterruptOnTimeout).     return this. }
true;public;1;4;/**  * Time in milliseconds at which point the command will timeout and halt execution.  * <p>  * If executionIsolationThreadInterruptOnTimeout is true and the command is thread-isolated, the executing thread will be interrupted.  * If the command is semaphore-isolated and a HystrixObservableCommand, that command will get unsubscribed.  */ ;/**  * Time in milliseconds at which point the command will timeout and halt execution.  * <p>  * If executionIsolationThreadInterruptOnTimeout is true and the command is thread-isolated, the executing thread will be interrupted.  * If the command is semaphore-isolated and a HystrixObservableCommand, that command will get unsubscribed.  */ public HystrixConfigurationDefinition executionTimeoutInMilliseconds(Integer executionTimeoutInMilliseconds) {     setExecutionTimeoutInMilliseconds(executionTimeoutInMilliseconds).     return this. }
true;public;1;4;/**  * Whether the timeout mechanism is enabled for this command  */ ;/**  * Whether the timeout mechanism is enabled for this command  */ public HystrixConfigurationDefinition executionTimeoutEnabled(Boolean executionTimeoutEnabled) {     setExecutionTimeoutEnabled(executionTimeoutEnabled).     return this. }
true;public;1;4;/**  * Number of concurrent requests permitted to HystrixCommand.getFallback().  * Requests beyond the concurrent limit will fail-fast and not attempt retrieving a fallback.  */ ;/**  * Number of concurrent requests permitted to HystrixCommand.getFallback().  * Requests beyond the concurrent limit will fail-fast and not attempt retrieving a fallback.  */ public HystrixConfigurationDefinition fallbackIsolationSemaphoreMaxConcurrentRequests(Integer fallbackIsolationSemaphoreMaxConcurrentRequests) {     setFallbackIsolationSemaphoreMaxConcurrentRequests(fallbackIsolationSemaphoreMaxConcurrentRequests).     return this. }
true;public;1;4;/**  * Whether HystrixCommand.getFallback() should be attempted when failure occurs.  */ ;/**  * Whether HystrixCommand.getFallback() should be attempted when failure occurs.  */ public HystrixConfigurationDefinition fallbackEnabled(Boolean fallbackEnabled) {     setFallbackEnabled(fallbackEnabled).     return this. }
true;public;1;4;/**  * Time in milliseconds to wait between allowing health snapshots to be taken that calculate success and error  * percentages and affect HystrixCircuitBreaker.isOpen() status.  * <p>  * On high-volume circuits the continual calculation of error percentage can become CPU intensive thus this controls how often it is calculated.  */ ;/**  * Time in milliseconds to wait between allowing health snapshots to be taken that calculate success and error  * percentages and affect HystrixCircuitBreaker.isOpen() status.  * <p>  * On high-volume circuits the continual calculation of error percentage can become CPU intensive thus this controls how often it is calculated.  */ public HystrixConfigurationDefinition metricsHealthSnapshotIntervalInMilliseconds(Integer metricsHealthSnapshotIntervalInMilliseconds) {     setMetricsHealthSnapshotIntervalInMilliseconds(metricsHealthSnapshotIntervalInMilliseconds).     return this. }
true;public;1;4;/**  * Maximum number of values stored in each bucket of the rolling percentile.  * This is passed into HystrixRollingPercentile inside HystrixCommandMetrics.  */ ;/**  * Maximum number of values stored in each bucket of the rolling percentile.  * This is passed into HystrixRollingPercentile inside HystrixCommandMetrics.  */ public HystrixConfigurationDefinition metricsRollingPercentileBucketSize(Integer metricsRollingPercentileBucketSize) {     setMetricsRollingPercentileBucketSize(metricsRollingPercentileBucketSize).     return this. }
true;public;1;4;/**  * Whether percentile metrics should be captured using HystrixRollingPercentile inside HystrixCommandMetrics.  */ ;/**  * Whether percentile metrics should be captured using HystrixRollingPercentile inside HystrixCommandMetrics.  */ public HystrixConfigurationDefinition metricsRollingPercentileEnabled(Boolean metricsRollingPercentileEnabled) {     setMetricsRollingPercentileEnabled(metricsRollingPercentileEnabled).     return this. }
true;public;1;4;/**  * Duration of percentile rolling window in milliseconds.  * This is passed into HystrixRollingPercentile inside HystrixCommandMetrics.  */ ;/**  * Duration of percentile rolling window in milliseconds.  * This is passed into HystrixRollingPercentile inside HystrixCommandMetrics.  */ public HystrixConfigurationDefinition metricsRollingPercentileWindowInMilliseconds(Integer metricsRollingPercentileWindowInMilliseconds) {     setMetricsRollingPercentileWindowInMilliseconds(metricsRollingPercentileWindowInMilliseconds).     return this. }
true;public;1;4;/**  * Number of buckets the rolling percentile window is broken into.  * This is passed into HystrixRollingPercentile inside HystrixCommandMetrics.  */ ;/**  * Number of buckets the rolling percentile window is broken into.  * This is passed into HystrixRollingPercentile inside HystrixCommandMetrics.  */ public HystrixConfigurationDefinition metricsRollingPercentileWindowBuckets(Integer metricsRollingPercentileWindowBuckets) {     setMetricsRollingPercentileWindowBuckets(metricsRollingPercentileWindowBuckets).     return this. }
true;public;1;4;/**  * This property sets the duration of the statistical rolling window, in milliseconds. This is how long metrics are kept for the thread pool.  *  * The window is divided into buckets and “rolls” by those increments.  */ ;/**  * This property sets the duration of the statistical rolling window, in milliseconds. This is how long metrics are kept for the thread pool.  *  * The window is divided into buckets and “rolls” by those increments.  */ public HystrixConfigurationDefinition metricsRollingStatisticalWindowInMilliseconds(Integer metricsRollingStatisticalWindowInMilliseconds) {     setMetricsRollingStatisticalWindowInMilliseconds(metricsRollingStatisticalWindowInMilliseconds).     return this. }
true;public;1;4;/**  * Number of buckets the rolling statistical window is broken into.  * This is passed into HystrixRollingNumber inside HystrixCommandMetrics.  */ ;/**  * Number of buckets the rolling statistical window is broken into.  * This is passed into HystrixRollingNumber inside HystrixCommandMetrics.  */ public HystrixConfigurationDefinition metricsRollingStatisticalWindowBuckets(Integer metricsRollingStatisticalWindowBuckets) {     setMetricsRollingStatisticalWindowBuckets(metricsRollingStatisticalWindowBuckets).     return this. }
true;public;1;4;/**  * Whether HystrixCommand execution and events should be logged to HystrixRequestLog.  */ ;/**  * Whether HystrixCommand execution and events should be logged to HystrixRequestLog.  */ public HystrixConfigurationDefinition requestLogEnabled(Boolean requestLogEnabled) {     setRequestLogEnabled(requestLogEnabled).     return this. }
true;public;1;4;/**  * Core thread-pool size.  */ ;/**  * Core thread-pool size.  */ public HystrixConfigurationDefinition corePoolSize(Integer corePoolSize) {     setCorePoolSize(corePoolSize).     return this. }
true;public;1;4;/**  * Keep-alive time in minutes.  */ ;/**  * Keep-alive time in minutes.  */ public HystrixConfigurationDefinition keepAliveTime(Integer keepAliveTime) {     setKeepAliveTime(keepAliveTime).     return this. }
true;public;1;4;/**  * Max queue size.  *  * This should only affect the instantiation of the thread-pool - it is not eligible to change a queue size on the fly.  */ ;/**  * Max queue size.  *  * This should only affect the instantiation of the thread-pool - it is not eligible to change a queue size on the fly.  */ public HystrixConfigurationDefinition maxQueueSize(Integer maxQueueSize) {     setMaxQueueSize(maxQueueSize).     return this. }
true;public;1;4;/**  * Maximum thread-pool size that gets passed to {@link ThreadPoolExecutor#setMaximumPoolSize(int)}.  * This is the maximum amount of concurrency that can be supported without starting to reject HystrixCommands.  * Please note that this setting only takes effect if you also set allowMaximumSizeToDivergeFromCoreSize  */ ;/**  * Maximum thread-pool size that gets passed to {@link ThreadPoolExecutor#setMaximumPoolSize(int)}.  * This is the maximum amount of concurrency that can be supported without starting to reject HystrixCommands.  * Please note that this setting only takes effect if you also set allowMaximumSizeToDivergeFromCoreSize  */ public HystrixConfigurationDefinition maximumSize(Integer maximumSize) {     setMaximumSize(maximumSize).     return this. }
true;public;1;4;/**  * Queue size rejection threshold is an artificial max size at which rejections will occur even  * if maxQueueSize has not been reached. This is done because the maxQueueSize  * of a blocking queue can not be dynamically changed and we want to support dynamically  * changing the queue size that affects rejections.  * <p>  * This is used by HystrixCommand when queuing a thread for execution.  */ ;/**  * Queue size rejection threshold is an artificial max size at which rejections will occur even  * if maxQueueSize has not been reached. This is done because the maxQueueSize  * of a blocking queue can not be dynamically changed and we want to support dynamically  * changing the queue size that affects rejections.  * <p>  * This is used by HystrixCommand when queuing a thread for execution.  */ public HystrixConfigurationDefinition queueSizeRejectionThreshold(Integer queueSizeRejectionThreshold) {     setQueueSizeRejectionThreshold(queueSizeRejectionThreshold).     return this. }
true;public;1;4;/**  * Duration of statistical rolling window in milliseconds.  * This is passed into HystrixRollingNumber inside each HystrixThreadPoolMetrics instance.  */ ;/**  * Duration of statistical rolling window in milliseconds.  * This is passed into HystrixRollingNumber inside each HystrixThreadPoolMetrics instance.  */ public HystrixConfigurationDefinition threadPoolRollingNumberStatisticalWindowInMilliseconds(Integer threadPoolRollingNumberStatisticalWindowInMilliseconds) {     setThreadPoolRollingNumberStatisticalWindowInMilliseconds(threadPoolRollingNumberStatisticalWindowInMilliseconds).     return this. }
true;public;1;4;/**  * Number of buckets the rolling statistical window is broken into.  * This is passed into HystrixRollingNumber inside each HystrixThreadPoolMetrics instance.  */ ;/**  * Number of buckets the rolling statistical window is broken into.  * This is passed into HystrixRollingNumber inside each HystrixThreadPoolMetrics instance.  */ public HystrixConfigurationDefinition threadPoolRollingNumberStatisticalWindowBuckets(Integer threadPoolRollingNumberStatisticalWindowBuckets) {     setThreadPoolRollingNumberStatisticalWindowBuckets(threadPoolRollingNumberStatisticalWindowBuckets).     return this. }
true;public;1;4;/**  * Allows the configuration for maximumSize to take effect. That value can then be equal to, or higher, than coreSize  */ ;/**  * Allows the configuration for maximumSize to take effect. That value can then be equal to, or higher, than coreSize  */ public HystrixConfigurationDefinition allowMaximumSizeToDivergeFromCoreSize(Boolean allowMaximumSizeToDivergeFromCoreSize) {     setAllowMaximumSizeToDivergeFromCoreSize(allowMaximumSizeToDivergeFromCoreSize).     return this. }
true;public;0;3;/**  * End of configuration.  */ ;/**  * End of configuration.  */ public HystrixDefinition end() {     return parent. }
