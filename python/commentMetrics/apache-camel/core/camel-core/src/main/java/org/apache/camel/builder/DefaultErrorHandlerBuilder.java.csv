commented;modifiers;parameterAmount;loc;comment;code
false;public;2;8;;public Processor createErrorHandler(RouteContext routeContext, Processor processor) throws Exception {     DefaultErrorHandler answer = new DefaultErrorHandler(routeContext.getCamelContext(), processor, getLogger(), getOnRedelivery(), getRedeliveryPolicy(), getExceptionPolicyStrategy(), getRetryWhilePolicy(routeContext.getCamelContext()), getExecutorService(routeContext.getCamelContext()), getOnPrepareFailure(), getOnExceptionOccurred()).     // configure error handler before we can use it     configure(routeContext, answer).     return answer. }
false;public;0;3;;public boolean supportTransacted() {     return false. }
false;public;0;6;;@Override public ErrorHandlerBuilder cloneBuilder() {     DefaultErrorHandlerBuilder answer = new DefaultErrorHandlerBuilder().     cloneBuilder(answer).     return answer. }
false;protected;1;38;;protected void cloneBuilder(DefaultErrorHandlerBuilder other) {     super.cloneBuilder(other).     if (logger != null) {         other.setLogger(logger).     }     if (redeliveryPolicy != null) {         other.setRedeliveryPolicy(redeliveryPolicy.copy()).     }     if (onRedelivery != null) {         other.setOnRedelivery(onRedelivery).     }     if (retryWhile != null) {         other.setRetryWhile(retryWhile).     }     if (retryWhileRef != null) {         other.setRetryWhileRef(retryWhileRef).     }     if (failureProcessor != null) {         other.setFailureProcessor(failureProcessor).     }     if (deadLetter != null) {         other.setDeadLetter(deadLetter).     }     if (deadLetterUri != null) {         other.setDeadLetterUri(deadLetterUri).     }     if (onPrepareFailure != null) {         other.setOnPrepareFailure(onPrepareFailure).     }     if (onExceptionOccurred != null) {         other.setOnExceptionOccurred(onExceptionOccurred).     }     other.setDeadLetterHandleNewException(deadLetterHandleNewException).     other.setUseOriginalMessage(useOriginalMessage).     other.setAsyncDelayedRedelivery(asyncDelayedRedelivery).     other.setExecutorServiceRef(executorServiceRef). }
true;public;1;4;// ------------------------------------------------------------------------- ;// Builder methods // ------------------------------------------------------------------------- public DefaultErrorHandlerBuilder backOffMultiplier(double backOffMultiplier) {     getRedeliveryPolicy().backOffMultiplier(backOffMultiplier).     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder collisionAvoidancePercent(double collisionAvoidancePercent) {     getRedeliveryPolicy().collisionAvoidancePercent(collisionAvoidancePercent).     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder redeliveryDelay(long delay) {     getRedeliveryPolicy().redeliveryDelay(delay).     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder delayPattern(String delayPattern) {     getRedeliveryPolicy().delayPattern(delayPattern).     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder maximumRedeliveries(int maximumRedeliveries) {     getRedeliveryPolicy().maximumRedeliveries(maximumRedeliveries).     return this. }
false;public;0;4;;public DefaultErrorHandlerBuilder disableRedelivery() {     getRedeliveryPolicy().maximumRedeliveries(0).     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder maximumRedeliveryDelay(long maximumRedeliveryDelay) {     getRedeliveryPolicy().maximumRedeliveryDelay(maximumRedeliveryDelay).     return this. }
false;public;0;4;;public DefaultErrorHandlerBuilder useCollisionAvoidance() {     getRedeliveryPolicy().useCollisionAvoidance().     return this. }
false;public;0;4;;public DefaultErrorHandlerBuilder useExponentialBackOff() {     getRedeliveryPolicy().useExponentialBackOff().     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder retriesExhaustedLogLevel(LoggingLevel retriesExhaustedLogLevel) {     getRedeliveryPolicy().setRetriesExhaustedLogLevel(retriesExhaustedLogLevel).     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder retryAttemptedLogLevel(LoggingLevel retryAttemptedLogLevel) {     getRedeliveryPolicy().setRetryAttemptedLogLevel(retryAttemptedLogLevel).     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder retryAttemptedLogInterval(int retryAttemptedLogInterval) {     getRedeliveryPolicy().setRetryAttemptedLogInterval(retryAttemptedLogInterval).     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder logStackTrace(boolean logStackTrace) {     getRedeliveryPolicy().setLogStackTrace(logStackTrace).     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder logRetryStackTrace(boolean logRetryStackTrace) {     getRedeliveryPolicy().setLogRetryStackTrace(logRetryStackTrace).     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder logHandled(boolean logHandled) {     getRedeliveryPolicy().setLogHandled(logHandled).     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder logNewException(boolean logNewException) {     getRedeliveryPolicy().setLogNewException(logNewException).     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder logExhausted(boolean logExhausted) {     getRedeliveryPolicy().setLogExhausted(logExhausted).     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder logRetryAttempted(boolean logRetryAttempted) {     getRedeliveryPolicy().setLogRetryAttempted(logRetryAttempted).     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder logExhaustedMessageHistory(boolean logExhaustedMessageHistory) {     getRedeliveryPolicy().setLogExhaustedMessageHistory(logExhaustedMessageHistory).     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder logExhaustedMessageBody(boolean logExhaustedMessageBody) {     getRedeliveryPolicy().setLogExhaustedMessageBody(logExhaustedMessageBody).     return this. }
false;public;1;4;;public DefaultErrorHandlerBuilder exchangeFormatterRef(String exchangeFormatterRef) {     getRedeliveryPolicy().setExchangeFormatterRef(exchangeFormatterRef).     return this. }
true;public;0;4;/**  * Will allow asynchronous delayed redeliveries. The route, in particular the consumer's component,  * must support the Asynchronous Routing Engine (e.g. seda)  *  * @see org.apache.camel.processor.RedeliveryPolicy#setAsyncDelayedRedelivery(boolean)  * @return the builder  */ ;/**  * Will allow asynchronous delayed redeliveries. The route, in particular the consumer's component,  * must support the Asynchronous Routing Engine (e.g. seda)  *  * @see org.apache.camel.processor.RedeliveryPolicy#setAsyncDelayedRedelivery(boolean)  * @return the builder  */ public DefaultErrorHandlerBuilder asyncDelayedRedelivery() {     getRedeliveryPolicy().setAsyncDelayedRedelivery(true).     return this. }
true;public;1;4;/**  * Controls whether to allow redelivery while stopping/shutting down a route that uses error handling.  *  * @param allowRedeliveryWhileStopping <tt>true</tt> to allow redelivery, <tt>false</tt> to reject redeliveries  * @return the builder  */ ;/**  * Controls whether to allow redelivery while stopping/shutting down a route that uses error handling.  *  * @param allowRedeliveryWhileStopping <tt>true</tt> to allow redelivery, <tt>false</tt> to reject redeliveries  * @return the builder  */ public DefaultErrorHandlerBuilder allowRedeliveryWhileStopping(boolean allowRedeliveryWhileStopping) {     getRedeliveryPolicy().setAllowRedeliveryWhileStopping(allowRedeliveryWhileStopping).     return this. }
true;public;1;4;/**  * Sets a reference to a thread pool to be used for redelivery.  *  * @param ref reference to a scheduled thread pool  * @return the builder.  */ ;/**  * Sets a reference to a thread pool to be used for redelivery.  *  * @param ref reference to a scheduled thread pool  * @return the builder.  */ public DefaultErrorHandlerBuilder executorServiceRef(String ref) {     setExecutorServiceRef(ref).     return this. }
true;public;1;4;/**  * Sets the logger used for caught exceptions  *  * @param logger the logger  * @return the builder  */ ;/**  * Sets the logger used for caught exceptions  *  * @param logger the logger  * @return the builder  */ public DefaultErrorHandlerBuilder logger(CamelLogger logger) {     setLogger(logger).     return this. }
true;public;1;4;/**  * Sets the logging level of exceptions caught  *  * @param level the logging level  * @return the builder  */ ;/**  * Sets the logging level of exceptions caught  *  * @param level the logging level  * @return the builder  */ public DefaultErrorHandlerBuilder loggingLevel(LoggingLevel level) {     getLogger().setLevel(level).     return this. }
true;public;1;4;/**  * Sets the log used for caught exceptions  *  * @param log the logger  * @return the builder  */ ;/**  * Sets the log used for caught exceptions  *  * @param log the logger  * @return the builder  */ public DefaultErrorHandlerBuilder log(org.slf4j.Logger log) {     getLogger().setLog(log).     return this. }
true;public;1;3;/**  * Sets the log used for caught exceptions  *  * @param log the log name  * @return the builder  */ ;/**  * Sets the log used for caught exceptions  *  * @param log the log name  * @return the builder  */ public DefaultErrorHandlerBuilder log(String log) {     return log(LoggerFactory.getLogger(log)). }
true;public;1;3;/**  * Sets the log used for caught exceptions  *  * @param log the log class  * @return the builder  */ ;/**  * Sets the log used for caught exceptions  *  * @param log the log class  * @return the builder  */ public DefaultErrorHandlerBuilder log(Class<?> log) {     return log(LoggerFactory.getLogger(log)). }
true;public;1;4;/**  * Sets a processor that should be processed <b>before</b> a redelivery attempt.  * <p/>  * Can be used to change the {@link org.apache.camel.Exchange} <b>before</b> its being redelivered.  *  * @param processor the processor  * @return the builder  */ ;/**  * Sets a processor that should be processed <b>before</b> a redelivery attempt.  * <p/>  * Can be used to change the {@link org.apache.camel.Exchange} <b>before</b> its being redelivered.  *  * @param processor the processor  * @return the builder  */ public DefaultErrorHandlerBuilder onRedelivery(Processor processor) {     setOnRedelivery(processor).     return this. }
true;public;1;4;/**  * Sets the retry while expression.  * <p/>  * Will continue retrying until expression evaluates to <tt>false</tt>.  *  * @param retryWhile expression that determines when to stop retrying  * @return the builder  */ ;/**  * Sets the retry while expression.  * <p/>  * Will continue retrying until expression evaluates to <tt>false</tt>.  *  * @param retryWhile expression that determines when to stop retrying  * @return the builder  */ public DefaultErrorHandlerBuilder retryWhile(Expression retryWhile) {     setRetryWhile(ExpressionToPredicateAdapter.toPredicate(retryWhile)).     return this. }
true;public;0;4;/**  * Will use the original input {@link org.apache.camel.Message} when an {@link org.apache.camel.Exchange}  * is moved to the dead letter queue.  * <p/>  * <b>Notice:</b> this only applies when all redeliveries attempt have failed and the {@link org.apache.camel.Exchange}  * is doomed for failure.  * <br/>  * Instead of using the current inprogress {@link org.apache.camel.Exchange} IN message we use the original  * IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress  * snapshot of the IN message.  * For instance if you route transform the IN body during routing and then failed. With the original exchange  * store in the dead letter queue it might be easier to manually re submit the {@link org.apache.camel.Exchange}  * again as the IN message is the same as when Camel received it.  * So you should be able to send the {@link org.apache.camel.Exchange} to the same input.  * <p/>  * By default this feature is off.  *  * @return the builder  */ ;/**  * Will use the original input {@link org.apache.camel.Message} when an {@link org.apache.camel.Exchange}  * is moved to the dead letter queue.  * <p/>  * <b>Notice:</b> this only applies when all redeliveries attempt have failed and the {@link org.apache.camel.Exchange}  * is doomed for failure.  * <br/>  * Instead of using the current inprogress {@link org.apache.camel.Exchange} IN message we use the original  * IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress  * snapshot of the IN message.  * For instance if you route transform the IN body during routing and then failed. With the original exchange  * store in the dead letter queue it might be easier to manually re submit the {@link org.apache.camel.Exchange}  * again as the IN message is the same as when Camel received it.  * So you should be able to send the {@link org.apache.camel.Exchange} to the same input.  * <p/>  * By default this feature is off.  *  * @return the builder  */ public DefaultErrorHandlerBuilder useOriginalMessage() {     setUseOriginalMessage(true).     return this. }
true;public;1;4;/**  * Whether the dead letter channel should handle (and ignore) any new exception that may been thrown during sending the  * message to the dead letter endpoint.  * <p/>  * The default value is <tt>true</tt> which means any such kind of exception is handled and ignored. Set this to <tt>false</tt>  * to let the exception be propagated back on the {@link org.apache.camel.Exchange}. This can be used in situations  * where you use transactions, and want to use Camel's dead letter channel to deal with exceptions during routing,  * but if the dead letter channel itself fails because of a new exception being thrown, then by setting this to <tt>false</tt>  * the new exceptions is propagated back and set on the {@link org.apache.camel.Exchange}, which allows the transaction  * to detect the exception, and rollback.  *  * @param handleNewException <tt>true</tt> to handle (and ignore), <tt>false</tt> to catch and propagated the exception on the {@link org.apache.camel.Exchange}  * @return the builder  */ ;/**  * Whether the dead letter channel should handle (and ignore) any new exception that may been thrown during sending the  * message to the dead letter endpoint.  * <p/>  * The default value is <tt>true</tt> which means any such kind of exception is handled and ignored. Set this to <tt>false</tt>  * to let the exception be propagated back on the {@link org.apache.camel.Exchange}. This can be used in situations  * where you use transactions, and want to use Camel's dead letter channel to deal with exceptions during routing,  * but if the dead letter channel itself fails because of a new exception being thrown, then by setting this to <tt>false</tt>  * the new exceptions is propagated back and set on the {@link org.apache.camel.Exchange}, which allows the transaction  * to detect the exception, and rollback.  *  * @param handleNewException <tt>true</tt> to handle (and ignore), <tt>false</tt> to catch and propagated the exception on the {@link org.apache.camel.Exchange}  * @return the builder  */ public DefaultErrorHandlerBuilder deadLetterHandleNewException(boolean handleNewException) {     setDeadLetterHandleNewException(handleNewException).     return this. }
true;public;1;4;/**  * Sets a custom {@link org.apache.camel.Processor} to prepare the {@link org.apache.camel.Exchange} before  * handled by the failure processor / dead letter channel. This allows for example to enrich the message  * before sending to a dead letter queue.  *  * @param processor the processor  * @return the builder  */ ;/**  * Sets a custom {@link org.apache.camel.Processor} to prepare the {@link org.apache.camel.Exchange} before  * handled by the failure processor / dead letter channel. This allows for example to enrich the message  * before sending to a dead letter queue.  *  * @param processor the processor  * @return the builder  */ public DefaultErrorHandlerBuilder onPrepareFailure(Processor processor) {     setOnPrepareFailure(processor).     return this. }
true;public;1;4;/**  * Sets a custom {@link org.apache.camel.Processor} to process the {@link org.apache.camel.Exchange} just after an exception was thrown.  * This allows to execute the processor at the same time the exception was thrown.  * <p/>  * Important: Any exception thrown from this processor will be ignored.  *  * @param processor the processor  * @return the builder  */ ;/**  * Sets a custom {@link org.apache.camel.Processor} to process the {@link org.apache.camel.Exchange} just after an exception was thrown.  * This allows to execute the processor at the same time the exception was thrown.  * <p/>  * Important: Any exception thrown from this processor will be ignored.  *  * @param processor the processor  * @return the builder  */ public DefaultErrorHandlerBuilder onExceptionOccurred(Processor processor) {     setOnExceptionOccurred(processor).     return this. }
false;public;0;3;;// Properties // ------------------------------------------------------------------------- public Processor getFailureProcessor() {     return failureProcessor. }
false;public;1;3;;public void setFailureProcessor(Processor failureProcessor) {     this.failureProcessor = failureProcessor. }
false;public;0;6;;public RedeliveryPolicy getRedeliveryPolicy() {     if (redeliveryPolicy == null) {         redeliveryPolicy = createRedeliveryPolicy().     }     return redeliveryPolicy. }
true;public;1;3;/**  * Sets the redelivery policy  */ ;/**  * Sets the redelivery policy  */ public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {     this.redeliveryPolicy = redeliveryPolicy. }
false;public;0;6;;public CamelLogger getLogger() {     if (logger == null) {         logger = createLogger().     }     return logger. }
false;public;1;3;;public void setLogger(CamelLogger logger) {     this.logger = logger. }
false;public;0;3;;public Processor getOnRedelivery() {     return onRedelivery. }
false;public;1;3;;public void setOnRedelivery(Processor onRedelivery) {     this.onRedelivery = onRedelivery. }
false;public;1;11;;public Predicate getRetryWhilePolicy(CamelContext context) {     Predicate answer = getRetryWhile().     if (getRetryWhileRef() != null) {         // its a bean expression         Language bean = context.resolveLanguage("bean").         answer = bean.createPredicate(getRetryWhileRef()).     }     return answer. }
false;public;0;3;;public Predicate getRetryWhile() {     return retryWhile. }
false;public;1;3;;public void setRetryWhile(Predicate retryWhile) {     this.retryWhile = retryWhile. }
false;public;0;3;;public String getRetryWhileRef() {     return retryWhileRef. }
false;public;1;3;;public void setRetryWhileRef(String retryWhileRef) {     this.retryWhileRef = retryWhileRef. }
false;public;0;3;;public String getDeadLetterUri() {     return deadLetterUri. }
false;public;1;4;;public void setDeadLetterUri(String deadLetterUri) {     this.deadLetter = null.     this.deadLetterUri = deadLetterUri. }
false;public;0;3;;public Endpoint getDeadLetter() {     return deadLetter. }
false;public;1;4;;public void setDeadLetter(Endpoint deadLetter) {     this.deadLetter = deadLetter.     this.deadLetterUri = deadLetter.getEndpointUri(). }
false;public;0;3;;public boolean isDeadLetterHandleNewException() {     return deadLetterHandleNewException. }
false;public;1;3;;public void setDeadLetterHandleNewException(boolean deadLetterHandleNewException) {     this.deadLetterHandleNewException = deadLetterHandleNewException. }
false;public;0;3;;public boolean isUseOriginalMessage() {     return useOriginalMessage. }
false;public;1;3;;public void setUseOriginalMessage(boolean useOriginalMessage) {     this.useOriginalMessage = useOriginalMessage. }
false;public;0;3;;public boolean isAsyncDelayedRedelivery() {     return asyncDelayedRedelivery. }
false;public;1;3;;public void setAsyncDelayedRedelivery(boolean asyncDelayedRedelivery) {     this.asyncDelayedRedelivery = asyncDelayedRedelivery. }
false;public;0;3;;public String getExecutorServiceRef() {     return executorServiceRef. }
false;public;1;3;;public void setExecutorServiceRef(String executorServiceRef) {     this.executorServiceRef = executorServiceRef. }
false;public;0;3;;public Processor getOnPrepareFailure() {     return onPrepareFailure. }
false;public;1;3;;public void setOnPrepareFailure(Processor onPrepareFailure) {     this.onPrepareFailure = onPrepareFailure. }
false;public;0;3;;public Processor getOnExceptionOccurred() {     return onExceptionOccurred. }
false;public;1;3;;public void setOnExceptionOccurred(Processor onExceptionOccurred) {     this.onExceptionOccurred = onExceptionOccurred. }
false;protected;0;5;;protected RedeliveryPolicy createRedeliveryPolicy() {     RedeliveryPolicy policy = new RedeliveryPolicy().     policy.disableRedelivery().     return policy. }
false;protected;0;3;;protected CamelLogger createLogger() {     return new CamelLogger(LoggerFactory.getLogger(DefaultErrorHandler.class), LoggingLevel.ERROR). }
false;protected,synchronized;1;21;;protected synchronized ScheduledExecutorService getExecutorService(CamelContext camelContext) {     if (executorService == null || executorService.isShutdown()) {         // camel context will shutdown the executor when it shutdown so no need to shut it down when stopping         if (executorServiceRef != null) {             executorService = camelContext.getRegistry().lookupByNameAndType(executorServiceRef, ScheduledExecutorService.class).             if (executorService == null) {                 ExecutorServiceManager manager = camelContext.getExecutorServiceManager().                 ThreadPoolProfile profile = manager.getThreadPoolProfile(executorServiceRef).                 executorService = manager.newScheduledThreadPool(this, executorServiceRef, profile).             }             if (executorService == null) {                 throw new IllegalArgumentException("ExecutorServiceRef " + executorServiceRef + " not found in registry.").             }         } else {             // no explicit configured thread pool, so leave it up to the error handler to decide if it need             // a default thread pool from CamelContext#getErrorHandlerExecutorService             executorService = null.         }     }     return executorService. }
false;public;0;4;;@Override public String toString() {     return "DefaultErrorHandlerBuilder". }
