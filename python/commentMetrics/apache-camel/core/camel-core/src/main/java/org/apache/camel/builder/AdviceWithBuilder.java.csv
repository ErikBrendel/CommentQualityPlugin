commented;modifiers;parameterAmount;loc;comment;code
true;public;0;5;/**  * Will only apply the first node matched.  *  * @return the builder to build the nodes.  */ ;/**  * Will only apply the first node matched.  *  * @return the builder to build the nodes.  */ public AdviceWithBuilder<T> selectFirst() {     selectFirst = true.     selectLast = false.     return this. }
true;public;0;5;/**  * Will only apply the last node matched.  *  * @return the builder to build the nodes.  */ ;/**  * Will only apply the last node matched.  *  * @return the builder to build the nodes.  */ public AdviceWithBuilder<T> selectLast() {     selectLast = true.     selectFirst = false.     return this. }
true;public;1;8;/**  * Will only apply the n'th node matched.  *  * @param index index of node to match (is 0-based)  * @return the builder to build the nodes.  */ ;/**  * Will only apply the n'th node matched.  *  * @param index index of node to match (is 0-based)  * @return the builder to build the nodes.  */ public AdviceWithBuilder<T> selectIndex(int index) {     if (index < 0) {         throw new IllegalArgumentException("Index must be a non negative number, was: " + index).     }     selectFrom = index.     selectTo = index.     return this. }
true;public;2;11;/**  * Will only apply the node in the index range matched.  *  * @param from from index of node to start matching (inclusive)  * @param to to index of node to stop matching (inclusive)  * @return the builder to build the nodes.  */ ;/**  * Will only apply the node in the index range matched.  *  * @param from from index of node to start matching (inclusive)  * @param to to index of node to stop matching (inclusive)  * @return the builder to build the nodes.  */ public AdviceWithBuilder<T> selectRange(int from, int to) {     if (from < 0) {         throw new IllegalArgumentException("From must be a non negative number, was: " + from).     }     if (from > to) {         throw new IllegalArgumentException("From must be equal or lower than to. from: " + from + ", to: " + to).     }     selectFrom = from.     selectTo = to.     return this. }
true;public;1;8;/**  * Will only apply for nodes maximum levels deep.  * <p/>  * The first level is <tt>1</tt>, and level <tt>2</tt> is the children of the first level nodes, and so on.  * <p/>  * Use zero or negative value for unbounded level.  *  * @param maxDeep the maximum levels to traverse deep in the Camel route tree.  * @return the builder to build the nodes.  */ ;/**  * Will only apply for nodes maximum levels deep.  * <p/>  * The first level is <tt>1</tt>, and level <tt>2</tt> is the children of the first level nodes, and so on.  * <p/>  * Use zero or negative value for unbounded level.  *  * @param maxDeep the maximum levels to traverse deep in the Camel route tree.  * @return the builder to build the nodes.  */ public AdviceWithBuilder<T> maxDeep(int maxDeep) {     if (maxDeep == 0) {         // disable it         this.maxDeep = -1.     }     this.maxDeep = maxDeep.     return this. }
true;public;0;14;/**  * Replaces the matched node(s) with the following nodes.  *  * @return the builder to build the nodes.  */ ;/**  * Replaces the matched node(s) with the following nodes.  *  * @return the builder to build the nodes.  */ public ProcessorDefinition<?> replace() {     RouteDefinition route = builder.getOriginalRoute().     PipelineDefinition answer = new PipelineDefinition().     if (id != null) {         builder.getAdviceWithTasks().add(AdviceWithTasks.replaceById(route, id, answer, selectFirst, selectLast, selectFrom, selectTo, maxDeep)).     } else if (toString != null) {         builder.getAdviceWithTasks().add(AdviceWithTasks.replaceByToString(route, toString, answer, selectFirst, selectLast, selectFrom, selectTo, maxDeep)).     } else if (toUri != null) {         builder.getAdviceWithTasks().add(AdviceWithTasks.replaceByToUri(route, toUri, answer, selectFirst, selectLast, selectFrom, selectTo, maxDeep)).     } else if (type != null) {         builder.getAdviceWithTasks().add(AdviceWithTasks.replaceByType(route, type, answer, selectFirst, selectLast, selectFrom, selectTo, maxDeep)).     }     return answer. }
true;public;0;12;/**  * Removes the matched node(s)  */ ;/**  * Removes the matched node(s)  */ public void remove() {     RouteDefinition route = builder.getOriginalRoute().     if (id != null) {         builder.getAdviceWithTasks().add(AdviceWithTasks.removeById(route, id, selectFirst, selectLast, selectFrom, selectTo, maxDeep)).     } else if (toString != null) {         builder.getAdviceWithTasks().add(AdviceWithTasks.removeByToString(route, toString, selectFirst, selectLast, selectFrom, selectTo, maxDeep)).     } else if (toUri != null) {         builder.getAdviceWithTasks().add(AdviceWithTasks.removeByToUri(route, toUri, selectFirst, selectLast, selectFrom, selectTo, maxDeep)).     } else if (type != null) {         builder.getAdviceWithTasks().add(AdviceWithTasks.removeByType(route, type, selectFirst, selectLast, selectFrom, selectTo, maxDeep)).     } }
true;public;0;14;/**  * Insert the following node(s) <b>before</b> the matched node(s)  *  * @return the builder to build the nodes.  */ ;/**  * Insert the following node(s) <b>before</b> the matched node(s)  *  * @return the builder to build the nodes.  */ public ProcessorDefinition<?> before() {     RouteDefinition route = builder.getOriginalRoute().     PipelineDefinition answer = new PipelineDefinition().     if (id != null) {         builder.getAdviceWithTasks().add(AdviceWithTasks.beforeById(route, id, answer, selectFirst, selectLast, selectFrom, selectTo, maxDeep)).     } else if (toString != null) {         builder.getAdviceWithTasks().add(AdviceWithTasks.beforeByToString(route, toString, answer, selectFirst, selectLast, selectFrom, selectTo, maxDeep)).     } else if (toUri != null) {         builder.getAdviceWithTasks().add(AdviceWithTasks.beforeByToUri(route, toUri, answer, selectFirst, selectLast, selectFrom, selectTo, maxDeep)).     } else if (type != null) {         builder.getAdviceWithTasks().add(AdviceWithTasks.beforeByType(route, type, answer, selectFirst, selectLast, selectFrom, selectTo, maxDeep)).     }     return answer. }
true;public;0;14;/**  * Insert the following node(s) <b>after</b> the matched node(s)  *  * @return the builder to build the nodes.  */ ;/**  * Insert the following node(s) <b>after</b> the matched node(s)  *  * @return the builder to build the nodes.  */ public ProcessorDefinition<?> after() {     RouteDefinition route = builder.getOriginalRoute().     PipelineDefinition answer = new PipelineDefinition().     if (id != null) {         builder.getAdviceWithTasks().add(AdviceWithTasks.afterById(route, id, answer, selectFirst, selectLast, selectFrom, selectTo, maxDeep)).     } else if (toString != null) {         builder.getAdviceWithTasks().add(AdviceWithTasks.afterByToString(route, toString, answer, selectFirst, selectLast, selectFrom, selectTo, maxDeep)).     } else if (toUri != null) {         builder.getAdviceWithTasks().add(AdviceWithTasks.afterByToUri(route, toUri, answer, selectFirst, selectLast, selectFrom, selectTo, maxDeep)).     } else if (type != null) {         builder.getAdviceWithTasks().add(AdviceWithTasks.afterByType(route, type, answer, selectFirst, selectLast, selectFrom, selectTo, maxDeep)).     }     return answer. }
