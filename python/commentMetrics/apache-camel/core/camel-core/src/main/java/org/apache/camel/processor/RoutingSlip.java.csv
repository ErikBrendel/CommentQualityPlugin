commented;modifiers;parameterAmount;loc;comment;code
true;;1;1;/**  * Are the more routing slip(s)?  *  * @param exchange the current exchange  * @return <tt>true</tt> if more slips, <tt>false</tt> otherwise.  */ ;/**  * Are the more routing slip(s)?  *  * @param exchange the current exchange  * @return <tt>true</tt> if more slips, <tt>false</tt> otherwise.  */ boolean hasNext(Exchange exchange).
true;;1;1;/**  * Returns the next routing slip(s).  *  * @param exchange the current exchange  * @return the slip(s).  */ ;/**  * Returns the next routing slip(s).  *  * @param exchange the current exchange  * @return the slip(s).  */ Object next(Exchange exchange).
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setId(String id) {     this.id = id. }
false;public;0;3;;public Expression getExpression() {     return expression. }
false;public;0;3;;public String getUriDelimiter() {     return uriDelimiter. }
false;public;1;3;;public void setDelimiter(String delimiter) {     this.uriDelimiter = delimiter. }
false;public;0;3;;public boolean isIgnoreInvalidEndpoints() {     return ignoreInvalidEndpoints. }
false;public;1;3;;public void setIgnoreInvalidEndpoints(boolean ignoreInvalidEndpoints) {     this.ignoreInvalidEndpoints = ignoreInvalidEndpoints. }
false;public;0;3;;public int getCacheSize() {     return cacheSize. }
false;public;1;3;;public void setCacheSize(int cacheSize) {     this.cacheSize = cacheSize. }
false;public;0;3;;public AsyncProcessor getErrorHandler() {     return errorHandler. }
false;public;1;3;;public void setErrorHandler(AsyncProcessor errorHandler) {     this.errorHandler = errorHandler. }
false;public;0;4;;@Override public String toString() {     return "RoutingSlip[expression=" + expression + " uriDelimiter=" + uriDelimiter + "]". }
false;public;0;3;;public String getTraceLabel() {     return "routingSlip[" + expression + "]". }
false;public;2;9;;public boolean process(Exchange exchange, AsyncCallback callback) {     if (!isStarted()) {         exchange.setException(new IllegalStateException("RoutingSlip has not been started: " + this)).         callback.done(true).         return true.     }     return doRoutingSlipWithExpression(exchange, this.expression, callback). }
false;public;3;7;;public boolean doRoutingSlip(Exchange exchange, Object routingSlip, AsyncCallback callback) {     if (routingSlip instanceof Expression) {         return doRoutingSlipWithExpression(exchange, (Expression) routingSlip, callback).     } else {         return doRoutingSlipWithExpression(exchange, ExpressionBuilder.constantExpression(routingSlip), callback).     } }
false;public;1;3;;public boolean hasNext(Exchange exchange) {     return delegate.hasNext(). }
false;public;1;3;;public Object next(Exchange exchange) {     return delegate.next(). }
true;protected;2;19;/**  * Creates the route slip iterator to be used.  *  * @param exchange the exchange  * @param expression the expression  * @return the iterator, should never be <tt>null</tt>  */ ;/**  * Creates the route slip iterator to be used.  *  * @param exchange the exchange  * @param expression the expression  * @return the iterator, should never be <tt>null</tt>  */ protected RoutingSlipIterator createRoutingSlipIterator(final Exchange exchange, final Expression expression) throws Exception {     Object slip = expression.evaluate(exchange, Object.class).     if (exchange.getException() != null) {         // force any exceptions occurred during evaluation to be thrown         throw exchange.getException().     }     final Iterator<?> delegate = ObjectHelper.createIterator(slip, uriDelimiter).     return new RoutingSlipIterator() {          public boolean hasNext(Exchange exchange) {             return delegate.hasNext().         }          public Object next(Exchange exchange) {             return delegate.next().         }     }. }
false;private;3;74;;private boolean doRoutingSlipWithExpression(final Exchange exchange, final Expression expression, final AsyncCallback originalCallback) {     Exchange current = exchange.     RoutingSlipIterator iter.     try {         iter = createRoutingSlipIterator(exchange, expression).     } catch (Exception e) {         exchange.setException(e).         originalCallback.done(true).         return true.     }     // ensure the slip is empty when we start     if (current.hasProperties()) {         current.setProperty(Exchange.SLIP_ENDPOINT, null).     }     while (iter.hasNext(current)) {         Endpoint endpoint.         try {             endpoint = resolveEndpoint(iter, exchange).             // if no endpoint was resolved then try the next             if (endpoint == null) {                 continue.             }         } catch (Exception e) {             // error resolving endpoint so we should break out             current.setException(e).             break.         }         // process and prepare the routing slip         boolean sync = processExchange(endpoint, current, exchange, originalCallback, iter).         current = prepareExchangeForRoutingSlip(current, endpoint).         if (!sync) {             log.trace("Processing exchangeId: {} is continued being processed asynchronously", exchange.getExchangeId()).             // so we break out now, then the callback will be invoked which then continue routing from where we left here             return false.         }         log.trace("Processing exchangeId: {} is continued being processed synchronously", exchange.getExchangeId()).         // we ignore some kind of exceptions and allow us to continue         if (isIgnoreInvalidEndpoints()) {             FailedToCreateProducerException e = current.getException(FailedToCreateProducerException.class).             if (e != null) {                 if (log.isDebugEnabled()) {                     log.debug("Endpoint uri is invalid: " + endpoint + ". This exception will be ignored.", e).                 }                 current.setException(null).             }         }         // check for error if so we should break out         if (!continueProcessing(current, "so breaking out of the routing slip", log)) {             break.         }     }     // logging nextExchange as it contains the exchange that might have altered the payload and since     // we are logging the completion if will be confusing if we log the original instead     // we could also consider logging the original and the nextExchange then we have *before* and *after* snapshots     log.trace("Processing complete for exchangeId: {} >>> {}", exchange.getExchangeId(), current).     // copy results back to the original exchange     ExchangeHelper.copyResults(exchange, current).     // okay we are completely done with the routing slip     // so we need to signal done on the original callback so it can continue     originalCallback.done(true).     return true. }
false;protected;2;14;;protected Endpoint resolveEndpoint(RoutingSlipIterator iter, Exchange exchange) throws Exception {     Object nextRecipient = iter.next(exchange).     Endpoint endpoint = null.     try {         endpoint = ExchangeHelper.resolveEndpoint(exchange, nextRecipient).     } catch (Exception e) {         if (isIgnoreInvalidEndpoints()) {             log.info("Endpoint uri is invalid: " + nextRecipient + ". This exception will be ignored.", e).         } else {             throw e.         }     }     return endpoint. }
false;protected;2;15;;protected Exchange prepareExchangeForRoutingSlip(Exchange current, Endpoint endpoint) {     Exchange copy = new DefaultExchange(current).     // we must use the same id as this is a snapshot strategy where Camel copies a snapshot     // before processing the next step in the pipeline, so we have a snapshot of the exchange     // just before. This snapshot is used if Camel should do redeliveries (re try) using     // DeadLetterChannel. That is why it's important the id is the same, as it is the *same*     // exchange being routed.     copy.setExchangeId(current.getExchangeId()).     copyOutToIn(copy, current).     // ensure stream caching is reset     MessageHelper.resetStreamCache(copy.getIn()).     return copy. }
false;protected;4;16;;protected AsyncProcessor createErrorHandler(RouteContext routeContext, Exchange exchange, AsyncProcessor processor, Endpoint endpoint) {     AsyncProcessor answer = processor.     boolean tryBlock = exchange.getProperty(Exchange.TRY_ROUTE_BLOCK, false, boolean.class).     // do not wrap in error handler if we are inside a try block     if (!tryBlock && routeContext != null && errorHandler != null) {         // wrap the producer in error handler so we have fine grained error handling on         // the output side instead of the input side         // this is needed to support redelivery on that output alone and not doing redelivery         // for the entire routingslip/dynamic-router block again which will start from scratch again         answer = errorHandler.     }     return answer. }
false;public;1;71;;public void done(boolean doneSync) {     // cleanup producer after usage     ex.removeProperty(Exchange.SLIP_PRODUCER).     // we only have to handle async completion of the routing slip     if (doneSync) {         cb.done(true).         return.     }     try {         // continue processing the routing slip asynchronously         Exchange current = prepareExchangeForRoutingSlip(ex, endpoint).         while (iter.hasNext(current)) {             // we ignore some kind of exceptions and allow us to continue             if (isIgnoreInvalidEndpoints()) {                 FailedToCreateProducerException e = current.getException(FailedToCreateProducerException.class).                 if (e != null) {                     if (log.isDebugEnabled()) {                         log.debug("Endpoint uri is invalid: " + endpoint + ". This exception will be ignored.", e).                     }                     current.setException(null).                 }             }             // check for error if so we should break out             if (!continueProcessing(current, "so breaking out of the routing slip", log)) {                 break.             }             Endpoint endpoint1.             try {                 endpoint1 = resolveEndpoint(iter, ex).                 // if no endpoint was resolved then try the next                 if (endpoint1 == null) {                     continue.                 }             } catch (Exception e) {                 // error resolving endpoint so we should break out                 current.setException(e).                 break.             }             // prepare and process the routing slip             boolean sync = processExchange(endpoint1, current, original, cb, iter).             current = prepareExchangeForRoutingSlip(current, endpoint1).             if (!sync) {                 log.trace("Processing exchangeId: {} is continued being processed asynchronously", original.getExchangeId()).                 return.             }         }         // logging nextExchange as it contains the exchange that might have altered the payload and since         // we are logging the completion if will be confusing if we log the original instead         // we could also consider logging the original and the nextExchange then we have *before* and *after* snapshots         log.trace("Processing complete for exchangeId: {} >>> {}", original.getExchangeId(), current).         // copy results back to the original exchange         ExchangeHelper.copyResults(original, current).     } catch (Throwable e) {         ex.setException(e).     }     // okay we are completely done with the routing slip     // so we need to signal done on the original callback so it can continue     cb.done(false). }
false;protected;5;101;;protected boolean processExchange(final Endpoint endpoint, final Exchange exchange, final Exchange original, final AsyncCallback originalCallback, final RoutingSlipIterator iter) {     // this does the actual processing so log at trace level     log.trace("Processing exchangeId: {} >>> {}", exchange.getExchangeId(), exchange).     // routing slip callback which are used when     // - routing slip was routed asynchronously     // - and we are completely done with the routing slip     // so we need to signal done on the original callback so it can continue     AsyncCallback callback = doneSync -> {         if (!doneSync) {             originalCallback.done(false).         }     }.     return producerCache.doInAsyncProducer(endpoint, exchange, callback, (p, ex, cb) -> {         // rework error handling to support fine grained error handling         RouteContext routeContext = ex.getUnitOfWork() != null ? ex.getUnitOfWork().getRouteContext() : null.         AsyncProcessor target = createErrorHandler(routeContext, ex, p, endpoint).         // set property which endpoint we send to and the producer that can do it         ex.setProperty(Exchange.TO_ENDPOINT, endpoint.getEndpointUri()).         ex.setProperty(Exchange.SLIP_ENDPOINT, endpoint.getEndpointUri()).         ex.setProperty(Exchange.SLIP_PRODUCER, p).         return target.process(ex, new AsyncCallback() {              public void done(boolean doneSync) {                 // cleanup producer after usage                 ex.removeProperty(Exchange.SLIP_PRODUCER).                 // we only have to handle async completion of the routing slip                 if (doneSync) {                     cb.done(true).                     return.                 }                 try {                     // continue processing the routing slip asynchronously                     Exchange current = prepareExchangeForRoutingSlip(ex, endpoint).                     while (iter.hasNext(current)) {                         // we ignore some kind of exceptions and allow us to continue                         if (isIgnoreInvalidEndpoints()) {                             FailedToCreateProducerException e = current.getException(FailedToCreateProducerException.class).                             if (e != null) {                                 if (log.isDebugEnabled()) {                                     log.debug("Endpoint uri is invalid: " + endpoint + ". This exception will be ignored.", e).                                 }                                 current.setException(null).                             }                         }                         // check for error if so we should break out                         if (!continueProcessing(current, "so breaking out of the routing slip", log)) {                             break.                         }                         Endpoint endpoint1.                         try {                             endpoint1 = resolveEndpoint(iter, ex).                             // if no endpoint was resolved then try the next                             if (endpoint1 == null) {                                 continue.                             }                         } catch (Exception e) {                             // error resolving endpoint so we should break out                             current.setException(e).                             break.                         }                         // prepare and process the routing slip                         boolean sync = processExchange(endpoint1, current, original, cb, iter).                         current = prepareExchangeForRoutingSlip(current, endpoint1).                         if (!sync) {                             log.trace("Processing exchangeId: {} is continued being processed asynchronously", original.getExchangeId()).                             return.                         }                     }                     // logging nextExchange as it contains the exchange that might have altered the payload and since                     // we are logging the completion if will be confusing if we log the original instead                     // we could also consider logging the original and the nextExchange then we have *before* and *after* snapshots                     log.trace("Processing complete for exchangeId: {} >>> {}", original.getExchangeId(), current).                     // copy results back to the original exchange                     ExchangeHelper.copyResults(original, current).                 } catch (Throwable e) {                     ex.setException(e).                 }                 // okay we are completely done with the routing slip                 // so we need to signal done on the original callback so it can continue                 cb.done(false).             }         }).     }). }
false;protected;0;8;;protected void doStart() throws Exception {     if (producerCache == null) {         producerCache = new DefaultProducerCache(this, camelContext, cacheSize).         log.debug("RoutingSlip {} using ProducerCache with cacheSize={}", this, producerCache.getCapacity()).     }     ServiceHelper.startService(producerCache, errorHandler). }
false;protected;0;3;;protected void doStop() throws Exception {     ServiceHelper.stopService(producerCache, errorHandler). }
false;protected;0;3;;protected void doShutdown() throws Exception {     ServiceHelper.stopAndShutdownServices(producerCache, errorHandler). }
false;public;0;3;;public EndpointUtilizationStatistics getEndpointUtilizationStatistics() {     return producerCache.getEndpointUtilizationStatistics(). }
true;private;1;8;/**  * Returns the outbound message if available. Otherwise return the inbound message.  */ ;/**  * Returns the outbound message if available. Otherwise return the inbound message.  */ private Message getResultMessage(Exchange exchange) {     if (exchange.hasOut()) {         return exchange.getOut().     } else {         // if this endpoint had no out (like a mock endpoint) just take the in         return exchange.getIn().     } }
true;private;2;7;/**  * Copy the outbound data in 'source' to the inbound data in 'result'.  */ ;/**  * Copy the outbound data in 'source' to the inbound data in 'result'.  */ private void copyOutToIn(Exchange result, Exchange source) {     result.setException(source.getException()).     result.setIn(getResultMessage(source)).     result.getProperties().clear().     result.getProperties().putAll(source.getProperties()). }
true;public;0;3;/**  * Creates the embedded processor to use when wrapping this routing slip in an error handler.  */ ;/**  * Creates the embedded processor to use when wrapping this routing slip in an error handler.  */ public AsyncProcessor newRoutingSlipProcessorForErrorHandler() {     return new RoutingSlipProcessor(). }
false;public;2;5;;@Override public boolean process(Exchange exchange, AsyncCallback callback) {     AsyncProcessor producer = exchange.getProperty(Exchange.SLIP_PRODUCER, AsyncProcessor.class).     return producer.process(exchange, callback). }
false;public;0;4;;@Override public String toString() {     return "RoutingSlipProcessor". }
