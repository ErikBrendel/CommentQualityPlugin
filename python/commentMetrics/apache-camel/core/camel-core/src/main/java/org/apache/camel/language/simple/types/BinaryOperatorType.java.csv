commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;44;;public static BinaryOperatorType asOperator(String text) {     if ("==".equals(text)) {         return EQ.     } else if ("=~".equals(text)) {         return EQ_IGNORE.     } else if (">".equals(text)) {         return GT.     } else if (">=".equals(text)) {         return GTE.     } else if ("<".equals(text)) {         return LT.     } else if ("<=".equals(text)) {         return LTE.     } else if ("!=".equals(text)) {         return NOT_EQ.     } else if ("contains".equals(text)) {         return CONTAINS.     } else if ("not contains".equals(text)) {         return NOT_CONTAINS.     } else if ("~~".equals(text)) {         return CONTAINS_IGNORECASE.     } else if ("regex".equals(text)) {         return REGEX.     } else if ("not regex".equals(text)) {         return NOT_REGEX.     } else if ("in".equals(text)) {         return IN.     } else if ("not in".equals(text)) {         return NOT_IN.     } else if ("is".equals(text)) {         return IS.     } else if ("not is".equals(text)) {         return NOT_IS.     } else if ("range".equals(text)) {         return RANGE.     } else if ("not range".equals(text)) {         return NOT_RANGE.     } else if ("starts with".equals(text)) {         return STARTS_WITH.     } else if ("ends with".equals(text)) {         return ENDS_WITH.     }     throw new IllegalArgumentException("Operator not supported: " + text). }
false;public,static;1;44;;public static String getOperatorText(BinaryOperatorType operator) {     if (operator == EQ) {         return "==".     } else if (operator == EQ_IGNORE) {         return "=~".     } else if (operator == GT) {         return ">".     } else if (operator == GTE) {         return ">=".     } else if (operator == LT) {         return "<".     } else if (operator == LTE) {         return "<=".     } else if (operator == NOT_EQ) {         return "!=".     } else if (operator == CONTAINS) {         return "contains".     } else if (operator == NOT_CONTAINS) {         return "not contains".     } else if (operator == CONTAINS_IGNORECASE) {         return "~~".     } else if (operator == REGEX) {         return "regex".     } else if (operator == NOT_REGEX) {         return "not regex".     } else if (operator == IN) {         return "in".     } else if (operator == NOT_IN) {         return "not in".     } else if (operator == IS) {         return "is".     } else if (operator == NOT_IS) {         return "not is".     } else if (operator == RANGE) {         return "range".     } else if (operator == NOT_RANGE) {         return "not range".     } else if (operator == STARTS_WITH) {         return "starts with".     } else if (operator == ENDS_WITH) {         return "ends with".     }     return "". }
false;public;0;3;;public boolean isLiteralSupported() {     return this == Literal. }
false;public;0;3;;public boolean isLiteralWithFunctionSupport() {     return this == LiteralWithFunction. }
false;public;0;3;;public boolean isFunctionSupport() {     return this == Function. }
false;public;0;3;;public boolean isNumericValueSupported() {     return this == NumericValue. }
false;public;0;3;;public boolean isBooleanValueSupported() {     return this == BooleanValue. }
false;public;0;3;;public boolean isNullValueSupported() {     return this == NullValue. }
false;public;0;3;;public boolean isMinusValueSupported() {     return this == MinusValue. }
true;public,static;1;44;/**  * Returns the types of right hand side parameters this operator supports.  *  * @param operator the operator  * @return <tt>null</tt> if accepting all types, otherwise the array of accepted types  */ ;/**  * Returns the types of right hand side parameters this operator supports.  *  * @param operator the operator  * @return <tt>null</tt> if accepting all types, otherwise the array of accepted types  */ public static ParameterType[] supportedParameterTypes(BinaryOperatorType operator) {     if (operator == EQ) {         return null.     } else if (operator == EQ_IGNORE) {         return null.     } else if (operator == GT) {         return null.     } else if (operator == GTE) {         return null.     } else if (operator == LT) {         return null.     } else if (operator == LTE) {         return null.     } else if (operator == NOT_EQ) {         return null.     } else if (operator == CONTAINS) {         return null.     } else if (operator == NOT_CONTAINS) {         return null.     } else if (operator == CONTAINS_IGNORECASE) {         return null.     } else if (operator == REGEX) {         return new ParameterType[] { ParameterType.Literal, ParameterType.Function }.     } else if (operator == NOT_REGEX) {         return new ParameterType[] { ParameterType.Literal, ParameterType.Function }.     } else if (operator == IN) {         return null.     } else if (operator == NOT_IN) {         return null.     } else if (operator == IS) {         return new ParameterType[] { ParameterType.LiteralWithFunction, ParameterType.Function }.     } else if (operator == NOT_IS) {         return new ParameterType[] { ParameterType.LiteralWithFunction, ParameterType.Function }.     } else if (operator == RANGE) {         return new ParameterType[] { ParameterType.LiteralWithFunction, ParameterType.Function }.     } else if (operator == NOT_RANGE) {         return new ParameterType[] { ParameterType.LiteralWithFunction, ParameterType.Function }.     } else if (operator == STARTS_WITH) {         return null.     } else if (operator == ENDS_WITH) {         return null.     }     return null. }
false;public;0;4;;@Override public String toString() {     return getOperatorText(this). }
