commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;public Endpoint getEndpoint() {     if (endpoint == null) {         endpoint = from.resolveEndpoint(this).     }     return endpoint. }
false;public;0;3;;public FromDefinition getFrom() {     return from. }
false;public;0;3;;public RouteDefinition getRoute() {     return route. }
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;1;3;;public Endpoint resolveEndpoint(String uri) {     return new RouteReifier(route).resolveEndpoint(getCamelContext(), uri). }
false;public;2;30;;public Endpoint resolveEndpoint(String uri, String ref) {     Endpoint endpoint = null.     if (uri != null) {         endpoint = resolveEndpoint(uri).         if (endpoint == null) {             throw new NoSuchEndpointException(uri).         }     }     if (ref != null) {         endpoint = lookup(ref, Endpoint.class).         if (endpoint == null) {             throw new NoSuchEndpointException("ref:" + ref, "check your camel registry with id " + ref).         }         // Check the endpoint has the right CamelContext         if (!this.getCamelContext().equals(endpoint.getCamelContext())) {             throw new NoSuchEndpointException("ref:" + ref, "make sure the endpoint has the same camel context as the route does.").         }         try {             // need add the endpoint into service             getCamelContext().addService(endpoint).         } catch (Exception ex) {             throw new RuntimeCamelException(ex).         }     }     if (endpoint == null) {         throw new IllegalArgumentException("Either 'uri' or 'ref' must be specified on: " + this).     } else {         return endpoint.     } }
false;public;2;3;;public <T> T lookup(String name, Class<T> type) {     return getCamelContext().getRegistry().lookupByNameAndType(name, type). }
false;public;1;3;;public <T> Map<String, T> lookupByType(Class<T> type) {     return getCamelContext().getRegistry().findByTypeWithName(type). }
false;public;2;4;;@Override public <T> T mandatoryLookup(String name, Class<T> type) {     return CamelContextHelper.mandatoryLookup(getCamelContext(), name, type). }
false;public;0;128;;public void commit() {     // now lets turn all of the event driven consumer processors into a single route     if (!eventDrivenProcessors.isEmpty()) {         Processor target = Pipeline.newInstance(getCamelContext(), eventDrivenProcessors).         // force creating the route id so its known ahead of the route is started         String routeId = route.idOrCreate(getCamelContext().getNodeIdFactory()).         // and wrap it in a unit of work so the UoW is on the top, so the entire route will be in the same UoW         CamelInternalProcessor internal = new CamelInternalProcessor(target).         internal.addAdvice(new CamelInternalProcessor.UnitOfWorkProcessorAdvice(this)).         // and then optionally add route policy processor if a custom policy is set         List<RoutePolicy> routePolicyList = getRoutePolicyList().         if (routePolicyList != null && !routePolicyList.isEmpty()) {             for (RoutePolicy policy : routePolicyList) {                 // this ensures Camel can control the lifecycle of the policy                 if (!camelContext.hasService(policy)) {                     try {                         camelContext.addService(policy).                     } catch (Exception e) {                         throw RuntimeCamelException.wrapRuntimeCamelException(e).                     }                 }             }             internal.addAdvice(new CamelInternalProcessor.RoutePolicyAdvice(routePolicyList)).         }         // wrap in route inflight processor to track number of inflight exchanges for the route         internal.addAdvice(new CamelInternalProcessor.RouteInflightRepositoryAdvice(camelContext.getInflightRepository(), routeId)).         // wrap in JMX instrumentation processor that is used for performance stats         if (managementInterceptStrategy != null) {             internal.addAdvice(CamelInternalProcessorAdvice.wrap(managementInterceptStrategy.createProcessor("route"))).         }         // wrap in route lifecycle         internal.addAdvice(new CamelInternalProcessor.RouteLifecycleAdvice()).         // wrap in REST binding         if (route.getRestBindingDefinition() != null) {             try {                 internal.addAdvice(new RestBindingReifier(route.getRestBindingDefinition()).createRestBindingAdvice(this)).             } catch (Exception e) {                 throw RuntimeCamelException.wrapRuntimeCamelException(e).             }         }         // wrap in contract         if (route.getInputType() != null || route.getOutputType() != null) {             Contract contract = new Contract().             if (route.getInputType() != null) {                 contract.setInputType(route.getInputType().getUrn()).                 contract.setValidateInput(route.getInputType().isValidate()).             }             if (route.getOutputType() != null) {                 contract.setOutputType(route.getOutputType().getUrn()).                 contract.setValidateOutput(route.getOutputType().isValidate()).             }             internal.addAdvice(new ContractAdvice(contract)).             // make sure to enable data type as its in use when using input/output types on routes             camelContext.setUseDataType(true).         }         // and create the route that wraps the UoW         Route edcr = new EventDrivenConsumerRoute(this, getEndpoint(), internal).         edcr.getProperties().put(Route.ID_PROPERTY, routeId).         edcr.getProperties().put(Route.PARENT_PROPERTY, Integer.toHexString(route.hashCode())).         edcr.getProperties().put(Route.DESCRIPTION_PROPERTY, route.getDescriptionText()).         if (route.getGroup() != null) {             edcr.getProperties().put(Route.GROUP_PROPERTY, route.getGroup()).         }         String rest = "false".         if (route.isRest() != null && route.isRest()) {             rest = "true".         }         edcr.getProperties().put(Route.REST_PROPERTY, rest).         List<PropertyDefinition> properties = route.getRouteProperties().         if (properties != null) {             final String[] reservedProperties = new String[] { Route.ID_PROPERTY, Route.PARENT_PROPERTY, Route.GROUP_PROPERTY, Route.REST_PROPERTY, Route.DESCRIPTION_PROPERTY }.             for (PropertyDefinition prop : properties) {                 try {                     final String key = CamelContextHelper.parseText(camelContext, prop.getKey()).                     final String val = CamelContextHelper.parseText(camelContext, prop.getValue()).                     for (String property : reservedProperties) {                         if (property.equalsIgnoreCase(key)) {                             throw new IllegalArgumentException("Cannot set route property " + property + " as it is a reserved property").                         }                     }                     edcr.getProperties().put(key, val).                 } catch (Exception e) {                     throw RuntimeCamelException.wrapRuntimeCamelException(e).                 }             }         }         // after the route is created then set the route on the policy processor so we get hold of it         CamelInternalProcessor.RoutePolicyAdvice task = internal.getAdvice(CamelInternalProcessor.RoutePolicyAdvice.class).         if (task != null) {             task.setRoute(edcr).         }         CamelInternalProcessor.RouteLifecycleAdvice task2 = internal.getAdvice(CamelInternalProcessor.RouteLifecycleAdvice.class).         if (task2 != null) {             task2.setRoute(edcr).         }         // invoke init on route policy         if (routePolicyList != null && !routePolicyList.isEmpty()) {             for (RoutePolicy policy : routePolicyList) {                 policy.onInit(edcr).             }         }         routes.add(edcr).     } }
false;public;1;3;;public void addEventDrivenProcessor(Processor processor) {     eventDrivenProcessors.add(processor). }
false;public;0;3;;public List<InterceptStrategy> getInterceptStrategies() {     return interceptStrategies. }
false;public;1;3;;public void setInterceptStrategies(List<InterceptStrategy> interceptStrategies) {     this.interceptStrategies = interceptStrategies. }
false;public;1;3;;public void addInterceptStrategy(InterceptStrategy interceptStrategy) {     getInterceptStrategies().add(interceptStrategy). }
false;public;1;3;;public void setManagementInterceptStrategy(ManagementInterceptStrategy interceptStrategy) {     this.managementInterceptStrategy = interceptStrategy. }
false;public;0;3;;public ManagementInterceptStrategy getManagementInterceptStrategy() {     return managementInterceptStrategy. }
false;public;0;3;;public boolean isRouteAdded() {     return routeAdded. }
false;public;1;3;;public void setIsRouteAdded(boolean routeAdded) {     this.routeAdded = routeAdded. }
false;public;1;3;;public void setTracing(Boolean tracing) {     this.trace = tracing. }
false;public;0;8;;public Boolean isTracing() {     if (trace != null) {         return trace.     } else {         // fallback to the option from camel context         return getCamelContext().isTracing().     } }
false;public;1;3;;public void setMessageHistory(Boolean messageHistory) {     this.messageHistory = messageHistory. }
false;public;0;8;;public Boolean isMessageHistory() {     if (messageHistory != null) {         return messageHistory.     } else {         // fallback to the option from camel context         return getCamelContext().isMessageHistory().     } }
false;public;1;3;;public void setLogMask(Boolean logMask) {     this.logMask = logMask. }
false;public;0;8;;public Boolean isLogMask() {     if (logMask != null) {         return logMask.     } else {         // fallback to the option from camel context         return getCamelContext().isLogMask().     } }
false;public;1;3;;public void setLogExhaustedMessageBody(Boolean logExhaustedMessageBody) {     this.logExhaustedMessageBody = logExhaustedMessageBody. }
false;public;0;8;;public Boolean isLogExhaustedMessageBody() {     if (logExhaustedMessageBody != null) {         return logExhaustedMessageBody.     } else {         // fallback to the option from camel context         return getCamelContext().isLogExhaustedMessageBody().     } }
false;public;1;3;;public void setStreamCaching(Boolean cache) {     this.streamCache = cache. }
false;public;0;8;;public Boolean isStreamCaching() {     if (streamCache != null) {         return streamCache.     } else {         // fallback to the option from camel context         return getCamelContext().isStreamCaching().     } }
false;public;1;3;;public void setHandleFault(Boolean handleFault) {     this.handleFault = handleFault. }
false;public;0;8;;public Boolean isHandleFault() {     if (handleFault != null) {         return handleFault.     } else {         // fallback to the option from camel context         return getCamelContext().isHandleFault().     } }
false;public;1;3;;public void setDelayer(Long delay) {     this.delay = delay. }
false;public;0;8;;public Long getDelayer() {     if (delay != null) {         return delay.     } else {         // fallback to the option from camel context         return getCamelContext().getDelayer().     } }
false;public;1;3;;public void setAutoStartup(Boolean autoStartup) {     this.autoStartup = autoStartup. }
false;public;0;7;;public Boolean isAutoStartup() {     if (autoStartup != null) {         return autoStartup.     }     // default to true     return true. }
false;public;1;3;;public void setShutdownRoute(ShutdownRoute shutdownRoute) {     this.shutdownRoute = shutdownRoute. }
false;public;1;4;;public void setAllowUseOriginalMessage(Boolean allowUseOriginalMessage) {     // can only be configured on CamelContext     getCamelContext().setAllowUseOriginalMessage(allowUseOriginalMessage). }
false;public;0;4;;public Boolean isAllowUseOriginalMessage() {     // can only be configured on CamelContext     return getCamelContext().isAllowUseOriginalMessage(). }
false;public;0;8;;public ShutdownRoute getShutdownRoute() {     if (shutdownRoute != null) {         return shutdownRoute.     } else {         // fallback to the option from camel context         return getCamelContext().getShutdownRoute().     } }
false;public;1;3;;public void setShutdownRunningTask(ShutdownRunningTask shutdownRunningTask) {     this.shutdownRunningTask = shutdownRunningTask. }
false;public;0;8;;public ShutdownRunningTask getShutdownRunningTask() {     if (shutdownRunningTask != null) {         return shutdownRunningTask.     } else {         // fallback to the option from camel context         return getCamelContext().getShutdownRunningTask().     } }
false;public;1;8;;public int getAndIncrement(NamedNode node) {     AtomicInteger count = nodeIndex.get(node).     if (count == null) {         count = new AtomicInteger().         nodeIndex.put(node, count).     }     return count.getAndIncrement(). }
false;public;1;3;;public void setRoutePolicyList(List<RoutePolicy> routePolicyList) {     this.routePolicyList = routePolicyList. }
false;public;0;3;;public List<RoutePolicy> getRoutePolicyList() {     return routePolicyList. }
false;public;0;4;;@Override public RouteError getLastError() {     return routeError. }
false;public;1;4;;@Override public void setLastError(RouteError routeError) {     this.routeError = routeError. }
false;public;0;4;;@Override public RouteController getRouteController() {     return routeController. }
false;public;1;4;;@Override public void setRouteController(RouteController routeController) {     this.routeController = routeController. }
