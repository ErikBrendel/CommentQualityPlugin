commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "Resequencer[to: " + getProcessor() + "]". }
false;public;0;3;;public String getTraceLabel() {     return "resequencer". }
false;public;0;3;;// Properties // ------------------------------------------------------------------------- public Expression getExpression() {     return expression. }
false;public;0;3;;public ExceptionHandler getExceptionHandler() {     return exceptionHandler. }
false;public;1;3;;public void setExceptionHandler(ExceptionHandler exceptionHandler) {     this.exceptionHandler = exceptionHandler. }
false;public;0;3;;public int getBatchSize() {     return batchSize. }
true;public;1;10;/**  * Sets the <b>in</b> batch size. This is the number of incoming exchanges that this batch processor will  * process before its completed. The default value is {@link #DEFAULT_BATCH_SIZE}.  *  * @param batchSize the size  */ ;/**  * Sets the <b>in</b> batch size. This is the number of incoming exchanges that this batch processor will  * process before its completed. The default value is {@link #DEFAULT_BATCH_SIZE}.  *  * @param batchSize the size  */ public void setBatchSize(int batchSize) {     // as the code logic is dependent on a batch size having 1..n value     if (batchSize <= 0) {         log.debug("Disabling batch size, will only be triggered by timeout").         this.batchSize = Integer.MAX_VALUE.     } else {         this.batchSize = batchSize.     } }
false;public;0;3;;public int getOutBatchSize() {     return outBatchSize. }
true;public;1;3;/**  * Sets the <b>out</b> batch size. If the batch processor holds more exchanges than this out size then the  * completion is triggered. Can for instance be used to ensure that this batch is completed when a certain  * number of exchanges has been collected. By default this feature is <b>not</b> enabled.  *  * @param outBatchSize the size  */ ;/**  * Sets the <b>out</b> batch size. If the batch processor holds more exchanges than this out size then the  * completion is triggered. Can for instance be used to ensure that this batch is completed when a certain  * number of exchanges has been collected. By default this feature is <b>not</b> enabled.  *  * @param outBatchSize the size  */ public void setOutBatchSize(int outBatchSize) {     this.outBatchSize = outBatchSize. }
false;public;0;3;;public long getBatchTimeout() {     return batchTimeout. }
false;public;1;3;;public void setBatchTimeout(long batchTimeout) {     this.batchTimeout = batchTimeout. }
false;public;0;3;;public boolean isGroupExchanges() {     return groupExchanges. }
false;public;1;3;;public void setGroupExchanges(boolean groupExchanges) {     this.groupExchanges = groupExchanges. }
false;public;0;3;;public boolean isBatchConsumer() {     return batchConsumer. }
false;public;1;3;;public void setBatchConsumer(boolean batchConsumer) {     this.batchConsumer = batchConsumer. }
false;public;0;3;;public boolean isIgnoreInvalidExchanges() {     return ignoreInvalidExchanges. }
false;public;1;3;;public void setIgnoreInvalidExchanges(boolean ignoreInvalidExchanges) {     this.ignoreInvalidExchanges = ignoreInvalidExchanges. }
false;public;0;3;;public boolean isReverse() {     return reverse. }
false;public;1;3;;public void setReverse(boolean reverse) {     this.reverse = reverse. }
false;public;0;3;;public boolean isAllowDuplicates() {     return allowDuplicates. }
false;public;1;3;;public void setAllowDuplicates(boolean allowDuplicates) {     this.allowDuplicates = allowDuplicates. }
false;public;0;3;;public Predicate getCompletionPredicate() {     return completionPredicate. }
false;public;1;3;;public void setCompletionPredicate(Predicate completionPredicate) {     this.completionPredicate = completionPredicate. }
false;public;0;3;;public Processor getProcessor() {     return processor. }
false;public;0;8;;public List<Processor> next() {     if (!hasNext()) {         return null.     }     List<Processor> answer = new ArrayList<>(1).     answer.add(processor).     return answer. }
false;public;0;3;;public boolean hasNext() {     return processor != null. }
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setId(String id) {     this.id = id. }
false;protected,static;3;3;;// Implementation methods // ------------------------------------------------------------------------- protected static Set<Exchange> createSet(Expression expression, boolean allowDuplicates, boolean reverse) {     return createSet(new ExpressionComparator(expression), allowDuplicates, reverse). }
false;protected,static;3;16;;protected static Set<Exchange> createSet(final Comparator<? super Exchange> comparator, boolean allowDuplicates, boolean reverse) {     Comparator<? super Exchange> answer = comparator.     if (reverse) {         answer = comparator.reversed().     }     // if we allow duplicates then we need to cater for that in the comparator     if (allowDuplicates) {         // they are equal but we should allow duplicates so say that o2 is higher         // so it will come next         answer = answer.thenComparing((o1, o2) -> 1).     }     return new TreeSet<>(answer). }
true;private;1;3;/**  * A strategy method to decide if the "in" batch is completed. That is, whether the resulting exchanges in  * the in queue should be drained to the "out" collection.  */ ;/**  * A strategy method to decide if the "in" batch is completed. That is, whether the resulting exchanges in  * the in queue should be drained to the "out" collection.  */ private boolean isInBatchCompleted(int num) {     return num >= batchSize. }
true;private;0;7;/**  * A strategy method to decide if the "out" batch is completed. That is, whether the resulting exchange in  * the out collection should be sent.  */ ;/**  * A strategy method to decide if the "out" batch is completed. That is, whether the resulting exchange in  * the out collection should be sent.  */ private boolean isOutBatchCompleted() {     if (outBatchSize == 0) {         // out batch is disabled, so go ahead and send.         return true.     }     return collection.size() > 0 && collection.size() >= outBatchSize. }
true;protected;1;3;/**  * Strategy Method to process an exchange in the batch. This method allows derived classes to perform  * custom processing before or after an individual exchange is processed  */ ;/**  * Strategy Method to process an exchange in the batch. This method allows derived classes to perform  * custom processing before or after an individual exchange is processed  */ protected void processExchange(Exchange exchange) {     processor.process(exchange, sync -> postProcess(exchange)). }
false;protected;1;5;;protected void postProcess(Exchange exchange) {     if (exchange.getException() != null) {         getExceptionHandler().handleException("Error processing aggregated exchange: " + exchange, exchange.getException()).     } }
false;protected;0;4;;protected void doStart() throws Exception {     ServiceHelper.startService(processor).     sender.start(). }
false;protected;0;5;;protected void doStop() throws Exception {     sender.cancel().     ServiceHelper.stopService(processor).     collection.clear(). }
true;public;2;29;/**  * Enqueues an exchange for later batch processing.  */ ;/**  * Enqueues an exchange for later batch processing.  */ public boolean process(Exchange exchange, AsyncCallback callback) {     try {         // with the size from the batch consumer         if (isBatchConsumer()) {             int size = exchange.getProperty(Exchange.BATCH_SIZE, Integer.class).             if (batchSize != size) {                 batchSize = size.                 log.trace("Using batch consumer completion, so setting batch size to: {}", batchSize).             }         }         // validate that the exchange can be used         if (!isValid(exchange)) {             if (isIgnoreInvalidExchanges()) {                 log.debug("Invalid Exchange. This Exchange will be ignored: {}", exchange).             } else {                 throw new CamelExchangeException("Exchange is not valid to be used by the BatchProcessor", exchange).             }         } else {             // exchange is valid so enqueue the exchange             sender.enqueueExchange(exchange).         }     } catch (Throwable e) {         exchange.setException(e).     }     callback.done(true).     return true. }
true;private;1;9;/**  * Is the given exchange valid to be used.  *  * @param exchange the given exchange  * @return <tt>true</tt> if valid, <tt>false</tt> otherwise  */ ;/**  * Is the given exchange valid to be used.  *  * @param exchange the given exchange  * @return <tt>true</tt> if valid, <tt>false</tt> otherwise  */ private boolean isValid(Exchange exchange) {     Object result = null.     try {         result = expression.evaluate(exchange, Object.class).     } catch (Exception e) {     // ignore     }     return result != null. }
false;public;0;84;;@Override public void run() {     // Wait until one of either:     // * an exchange being queued.     // * the batch timeout expiring. or     // * the thread being cancelled.     //      // If an exchange is queued then we need to determine whether the     // batch is complete. If it is complete then we send out the batched     // exchanges. Otherwise we move back into our wait state.     //      // If the batch times out then we send out the batched exchanges     // collected so far.     //      // If we receive an interrupt then all blocking operations are     // interrupted and our thread terminates.     //      // The goal of the following algorithm in terms of synchronisation     // is to provide fine grained locking i.e. retaining the lock only     // when required. Special consideration is given to releasing the     // lock when calling an overloaded method i.e. sendExchanges.     // Unlocking is important as the process of sending out the exchanges     // would otherwise block new exchanges from being queued.     queueLock.lock().     try {         do {             try {                 if (!exchangeEnqueued.get()) {                     log.trace("Waiting for new exchange to arrive or batchTimeout to occur after {} ms.", batchTimeout).                     exchangeEnqueuedCondition.await(batchTimeout, TimeUnit.MILLISECONDS).                 }                 // if the completion predicate was triggered then there is an exchange id which denotes when to complete                 String id = null.                 if (!completionPredicateMatched.isEmpty()) {                     id = completionPredicateMatched.poll().                 }                 if (id != null || !exchangeEnqueued.get()) {                     if (id != null) {                         log.trace("Collecting exchanges to be aggregated triggered by completion predicate").                     } else {                         log.trace("Collecting exchanges to be aggregated triggered by batch timeout").                     }                     drainQueueTo(collection, batchSize, id).                 } else {                     exchangeEnqueued.set(false).                     boolean drained = false.                     while (isInBatchCompleted(queue.size())) {                         drained = true.                         drainQueueTo(collection, batchSize, id).                     }                     if (drained) {                         log.trace("Collecting exchanges to be aggregated triggered by new exchanges received").                     }                     if (!isOutBatchCompleted()) {                         continue.                     }                 }                 queueLock.unlock().                 try {                     try {                         sendExchanges().                     } catch (Throwable t) {                         // a fail safe to handle all exceptions being thrown                         getExceptionHandler().handleException(t).                     }                 } finally {                     queueLock.lock().                 }             } catch (InterruptedException e) {                 break.             }         } while (isRunAllowed()).     } finally {         queueLock.unlock().     } }
true;private;3;20;/**  * This method should be called with queueLock held  */ ;/**  * This method should be called with queueLock held  */ private void drainQueueTo(Collection<Exchange> collection, int batchSize, String exchangeId) {     for (int i = 0. i < batchSize. ++i) {         Exchange e = queue.poll().         if (e != null) {             try {                 collection.add(e).             } catch (Exception t) {                 e.setException(t).             } catch (Throwable t) {                 getExceptionHandler().handleException(t).             }             if (exchangeId != null && exchangeId.equals(e.getExchangeId())) {                 // this batch is complete so stop draining                 break.             }         } else {             break.         }     } }
false;public;0;3;;public void cancel() {     interrupt(). }
false;public;1;20;;public void enqueueExchange(Exchange exchange) {     log.debug("Received exchange to be batched: {}", exchange).     queueLock.lock().     try {         // pre test whether the completion predicate matched         if (completionPredicate != null) {             boolean matches = completionPredicate.matches(exchange).             if (matches) {                 log.trace("Exchange matched completion predicate: {}", exchange).                 // add this exchange to the list of exchanges which marks the batch as complete                 completionPredicateMatched.add(exchange.getExchangeId()).             }         }         queue.add(exchange).         exchangeEnqueued.set(true).         exchangeEnqueuedCondition.signal().     } finally {         queueLock.unlock().     } }
false;private;0;9;;private void sendExchanges() throws Exception {     Iterator<Exchange> iter = collection.iterator().     while (iter.hasNext()) {         Exchange exchange = iter.next().         iter.remove().         log.debug("Sending aggregated exchange: {}", exchange).         processExchange(exchange).     } }
