commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getDataFormatName() {     return "zip". }
false;public;0;3;;public int getCompressionLevel() {     return compressionLevel. }
false;public;1;3;;public void setCompressionLevel(int compressionLevel) {     this.compressionLevel = compressionLevel. }
false;public;3;20;;public void marshal(final Exchange exchange, final Object graph, final OutputStream stream) throws Exception {     // ask for a mandatory type conversion to avoid a possible NPE beforehand as we do copy from the InputStream     final InputStream is = exchange.getContext().getTypeConverter().mandatoryConvertTo(InputStream.class, exchange, graph).     final Deflater deflater = new Deflater(compressionLevel).     final DeflaterOutputStream zipOutput = new DeflaterOutputStream(stream, deflater).     try {         IOHelper.copy(is, zipOutput).     } finally {         IOHelper.close(is, zipOutput).         /*             * As we create the Deflater our self and do not use the stream default             * (see {@link java.util.zip.DeflaterOutputStream#usesDefaultDeflater})             * we need to close the Deflater to not risk a OutOfMemoryException             * in native code parts (see {@link java.util.zip.Deflater#end})             */         deflater.end().     } }
false;public;2;12;;public Object unmarshal(final Exchange exchange, final InputStream inputStream) throws Exception {     InflaterInputStream inflaterInputStream = new InflaterInputStream(inputStream).     OutputStreamBuilder osb = OutputStreamBuilder.withExchange(exchange).     try {         IOHelper.copy(inflaterInputStream, osb).         return osb.build().     } finally {         // must close input streams         IOHelper.close(osb, inflaterInputStream, inputStream).     } }
false;protected;0;4;;@Override protected void doStart() throws Exception { // noop }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
