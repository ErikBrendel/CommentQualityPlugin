commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "InterceptSendToEndpoint[" + uri + " -> " + getOutputs() + "]". }
false;public;0;4;;@Override public String getShortName() {     return "interceptSendToEndpoint". }
false;public;0;4;;@Override public String getLabel() {     return "interceptSendToEndpoint[" + uri + "]". }
false;public;0;4;;@Override public boolean isAbstract() {     return true. }
false;public;0;4;;@Override public boolean isTopLevelOnly() {     return true. }
true;public;1;5;/**  * Applies this interceptor only if the given predicate is true  *  * @param predicate  the predicate  * @return the builder  */ ;/**  * Applies this interceptor only if the given predicate is true  *  * @param predicate  the predicate  * @return the builder  */ public InterceptSendToEndpointDefinition when(@AsPredicate Predicate predicate) {     WhenDefinition when = new WhenDefinition(predicate).     addOutput(when).     return this. }
true;public;0;4;/**  * Skip sending the {@link org.apache.camel.Exchange} to the original intended endpoint  *  * @return the builder  */ ;/**  * Skip sending the {@link org.apache.camel.Exchange} to the original intended endpoint  *  * @return the builder  */ public InterceptSendToEndpointDefinition skipSendToOriginalEndpoint() {     setSkipSendToOriginalEndpoint(Boolean.TRUE).     return this. }
true;public;0;34;/**  * This method is <b>only</b> for handling some post configuration  * that is needed since this is an interceptor, and we have to do  * a bit of magic logic to fixup to handle predicates  * with or without proceed/stop set as well.  */ ;/**  * This method is <b>only</b> for handling some post configuration  * that is needed since this is an interceptor, and we have to do  * a bit of magic logic to fixup to handle predicates  * with or without proceed/stop set as well.  */ public void afterPropertiesSet() {     if (getOutputs().size() == 0) {         // no outputs         return.     }     // if there is a when definition at first, then its a predicate for this interceptor     ProcessorDefinition<?> first = getOutputs().get(0).     if (first instanceof WhenDefinition && !(first instanceof WhenSkipSendToEndpointDefinition)) {         WhenDefinition when = (WhenDefinition) first.         // create a copy of when to use as replacement         WhenSkipSendToEndpointDefinition newWhen = new WhenSkipSendToEndpointDefinition().         newWhen.setExpression(when.getExpression()).         newWhen.setId(when.getId()).         newWhen.setInheritErrorHandler(when.isInheritErrorHandler()).         newWhen.setParent(when.getParent()).         newWhen.setOtherAttributes(when.getOtherAttributes()).         newWhen.setDescription(when.getDescription()).         // as the first one is the interceptor itself         for (int i = 1. i < outputs.size(). i++) {             ProcessorDefinition<?> out = outputs.get(i).             newWhen.addOutput(out).         }         // remove the moved from the original output, by just keeping the first one         clearOutput().         outputs.add(newWhen).     } }
false;public;0;3;;public Boolean getSkipSendToOriginalEndpoint() {     return skipSendToOriginalEndpoint. }
true;public;1;3;/**  * If set to true then the message is not sent to the original endpoint.  * By default (false) the message is both intercepted and then sent to the original endpoint.  */ ;/**  * If set to true then the message is not sent to the original endpoint.  * By default (false) the message is both intercepted and then sent to the original endpoint.  */ public void setSkipSendToOriginalEndpoint(Boolean skipSendToOriginalEndpoint) {     this.skipSendToOriginalEndpoint = skipSendToOriginalEndpoint. }
false;public;0;3;;public String getUri() {     return uri. }
true;public;1;3;/**  * Intercept sending to the uri or uri pattern.  */ ;/**  * Intercept sending to the uri or uri pattern.  */ public void setUri(String uri) {     this.uri = uri. }
