commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isEventNotifierEnabled() {     return eventNotifierEnabled. }
true;public;1;3;/**  * Whether {@link org.apache.camel.spi.EventNotifier} is enabled  */ ;/**  * Whether {@link org.apache.camel.spi.EventNotifier} is enabled  */ public void setEventNotifierEnabled(boolean eventNotifierEnabled) {     this.eventNotifierEnabled = eventNotifierEnabled. }
false;public;0;3;;public boolean isExtendedStatistics() {     return extendedStatistics. }
true;public;1;3;/**  * Whether extended JMX statistics is enabled for {@link org.apache.camel.spi.EndpointUtilizationStatistics}  */ ;/**  * Whether extended JMX statistics is enabled for {@link org.apache.camel.spi.EndpointUtilizationStatistics}  */ public void setExtendedStatistics(boolean extendedStatistics) {     this.extendedStatistics = extendedStatistics. }
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
true;public;0;3;/**  * Gets the source which uses this cache  *  * @return the source  */ ;/**  * Gets the source which uses this cache  *  * @return the source  */ public Object getSource() {     return source. }
true;public;1;11;/**  * Acquires a pooled producer which you <b>must</b> release back again after usage using the  * {@link #releaseProducer(org.apache.camel.Endpoint, org.apache.camel.AsyncProducer)} method.  *  * @param endpoint the endpoint  * @return the producer  */ ;/**  * Acquires a pooled producer which you <b>must</b> release back again after usage using the  * {@link #releaseProducer(org.apache.camel.Endpoint, org.apache.camel.AsyncProducer)} method.  *  * @param endpoint the endpoint  * @return the producer  */ public AsyncProducer acquireProducer(Endpoint endpoint) {     try {         AsyncProducer producer = producers.acquire(endpoint).         if (statistics != null) {             statistics.onHit(endpoint.getEndpointUri()).         }         return producer.     } catch (Throwable e) {         throw new FailedToCreateProducerException(endpoint, e).     } }
true;public;2;3;/**  * Releases an acquired producer back after usage.  *  * @param endpoint the endpoint  * @param producer the producer to release  */ ;/**  * Releases an acquired producer back after usage.  *  * @param endpoint the endpoint  * @param producer the producer to release  */ public void releaseProducer(Endpoint endpoint, AsyncProducer producer) {     producers.release(endpoint, producer). }
true;public;3;37;/**  * Sends the exchange to the given endpoint.  * <p>  * This method will <b>not</b> throw an exception. If processing of the given  * Exchange failed then the exception is stored on the provided Exchange  *  * @param endpoint the endpoint to send the exchange to  * @param exchange the exchange to send  */ ;/**  * Sends the exchange to the given endpoint.  * <p>  * This method will <b>not</b> throw an exception. If processing of the given  * Exchange failed then the exception is stored on the provided Exchange  *  * @param endpoint the endpoint to send the exchange to  * @param exchange the exchange to send  */ public Exchange send(Endpoint endpoint, Exchange exchange, Processor resultProcessor) {     AsyncProducer producer = acquireProducer(endpoint).     try {         // now lets dispatch         log.debug(">>>> {} {}", endpoint, exchange).         // set property which endpoint we send to         exchange.setProperty(Exchange.TO_ENDPOINT, endpoint.getEndpointUri()).         // send the exchange using the processor         StopWatch watch = null.         try {             if (eventNotifierEnabled) {                 boolean sending = EventHelper.notifyExchangeSending(exchange.getContext(), exchange, endpoint).                 if (sending) {                     watch = new StopWatch().                 }             }             // invoke the synchronous method             internalProcessor.process(exchange, producer, resultProcessor).         } catch (Throwable e) {             // ensure exceptions is caught and set on the exchange             exchange.setException(e).         } finally {             // emit event that the exchange was sent to the endpoint             if (eventNotifierEnabled && watch != null) {                 long timeTaken = watch.taken().                 EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken).             }         }         return exchange.     } finally {         releaseProducer(endpoint, producer).     } }
true;public;5;7;/**  * Asynchronously sends an exchange to an endpoint using a supplied  * {@link Processor} to populate the exchange  * <p>  * This method will <b>neither</b> throw an exception <b>nor</b> complete future exceptionally.  * If processing of the given Exchange failed then the exception is stored on the return Exchange  *  * @param endpoint        the endpoint to send the exchange to  * @param pattern         the message {@link ExchangePattern} such as  *                        {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}  * @param processor       the transformer used to populate the new exchange  * @param resultProcessor a processor to process the exchange when the send is complete.  * @param future          the preexisting future to complete when processing is done or null if to create new one  * @return future that completes with exchange when processing is done. Either passed into future parameter  *              or new one if parameter was null  */ ;/**  * Asynchronously sends an exchange to an endpoint using a supplied  * {@link Processor} to populate the exchange  * <p>  * This method will <b>neither</b> throw an exception <b>nor</b> complete future exceptionally.  * If processing of the given Exchange failed then the exception is stored on the return Exchange  *  * @param endpoint        the endpoint to send the exchange to  * @param pattern         the message {@link ExchangePattern} such as  *                        {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}  * @param processor       the transformer used to populate the new exchange  * @param resultProcessor a processor to process the exchange when the send is complete.  * @param future          the preexisting future to complete when processing is done or null if to create new one  * @return future that completes with exchange when processing is done. Either passed into future parameter  *              or new one if parameter was null  */ public CompletableFuture<Exchange> asyncSend(Endpoint endpoint, ExchangePattern pattern, Processor processor, Processor resultProcessor, CompletableFuture<Exchange> future) {     return asyncSendExchange(endpoint, pattern, processor, resultProcessor, null, future). }
true;public;6;11;/**  * Asynchronously sends an exchange to an endpoint using a supplied  * {@link Processor} to populate the exchange  * <p>  * This method will <b>neither</b> throw an exception <b>nor</b> complete future exceptionally.  * If processing of the given Exchange failed then the exception is stored on the return Exchange  *  * @param endpoint        the endpoint to send the exchange to  * @param pattern         the message {@link ExchangePattern} such as  *                        {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}  * @param processor       the transformer used to populate the new exchange  * @param resultProcessor a processor to process the exchange when the send is complete.  * @param exchange        an exchange to use in processing. Exchange will be created if parameter is null.  * @param future          the preexisting future to complete when processing is done or null if to create new one  * @return future that completes with exchange when processing is done. Either passed into future parameter  *              or new one if parameter was null  */ ;/**  * Asynchronously sends an exchange to an endpoint using a supplied  * {@link Processor} to populate the exchange  * <p>  * This method will <b>neither</b> throw an exception <b>nor</b> complete future exceptionally.  * If processing of the given Exchange failed then the exception is stored on the return Exchange  *  * @param endpoint        the endpoint to send the exchange to  * @param pattern         the message {@link ExchangePattern} such as  *                        {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}  * @param processor       the transformer used to populate the new exchange  * @param resultProcessor a processor to process the exchange when the send is complete.  * @param exchange        an exchange to use in processing. Exchange will be created if parameter is null.  * @param future          the preexisting future to complete when processing is done or null if to create new one  * @return future that completes with exchange when processing is done. Either passed into future parameter  *              or new one if parameter was null  */ public CompletableFuture<Exchange> asyncSendExchange(Endpoint endpoint, ExchangePattern pattern, Processor processor, Processor resultProcessor, Exchange exchange, CompletableFuture<Exchange> future) {     if (exchange == null) {         exchange = pattern != null ? endpoint.createExchange(pattern) : endpoint.createExchange().     }     return doAsyncSendExchange(endpoint, processor, resultProcessor, exchange, future). }
false;protected;5;24;;protected CompletableFuture<Exchange> doAsyncSendExchange(Endpoint endpoint, Processor processor, Processor resultProcessor, Exchange exchange, CompletableFuture<Exchange> f) {     CompletableFuture<Exchange> future = f != null ? f : new CompletableFuture<>().     AsyncProducerCallback cb = (p, e, c) -> asyncDispatchExchange(endpoint, p, resultProcessor, e, c).     try {         if (processor instanceof AsyncProcessor) {             ((AsyncProcessor) processor).process(exchange, doneSync -> doInAsyncProducer(endpoint, exchange, ds -> future.complete(exchange), cb)).         } else {             if (processor != null) {                 processor.process(exchange).             }             doInAsyncProducer(endpoint, exchange, ds -> future.complete(exchange), cb).         }     } catch (Throwable e) {         // populate failed so return         exchange.setException(e).         future.complete(exchange).     }     return future. }
true;public;4;65;/**  * Sends an exchange to an endpoint using a supplied callback supporting the asynchronous routing engine.  * <p/>  * If an exception was thrown during processing, it would be set on the given Exchange  *  * @param endpoint         the endpoint to send the exchange to  * @param exchange         the exchange, can be <tt>null</tt> if so then create a new exchange from the producer  * @param callback         the asynchronous callback  * @param producerCallback the producer template callback to be executed  * @return (doneSync) <tt>true</tt> to continue execute synchronously, <tt>false</tt> to continue being executed asynchronously  */ ;/**  * Sends an exchange to an endpoint using a supplied callback supporting the asynchronous routing engine.  * <p/>  * If an exception was thrown during processing, it would be set on the given Exchange  *  * @param endpoint         the endpoint to send the exchange to  * @param exchange         the exchange, can be <tt>null</tt> if so then create a new exchange from the producer  * @param callback         the asynchronous callback  * @param producerCallback the producer template callback to be executed  * @return (doneSync) <tt>true</tt> to continue execute synchronously, <tt>false</tt> to continue being executed asynchronously  */ public boolean doInAsyncProducer(Endpoint endpoint, Exchange exchange, AsyncCallback callback, AsyncProducerCallback producerCallback) {     AsyncProducer producer.     try {         // get the producer and we do not mind if its pooled as we can handle returning it back to the pool         producer = acquireProducer(endpoint).         if (producer == null) {             if (isStopped()) {                 log.warn("Ignoring exchange sent after processor is stopped: {}", exchange).                 callback.done(true).                 return true.             } else {                 exchange.setException(new IllegalStateException("No producer, this processor has not been started: " + this)).                 callback.done(true).                 return true.             }         }     } catch (Throwable e) {         exchange.setException(e).         callback.done(true).         return true.     }     try {         // record timing for sending the exchange using the producer         StopWatch watch.         if (eventNotifierEnabled && exchange != null) {             boolean sending = EventHelper.notifyExchangeSending(exchange.getContext(), exchange, endpoint).             if (sending) {                 watch = new StopWatch().             } else {                 watch = null.             }         } else {             watch = null.         }         // invoke the callback         return producerCallback.doInAsyncProducer(producer, exchange, doneSync -> {             try {                 if (eventNotifierEnabled && watch != null) {                     long timeTaken = watch.taken().                     // emit event that the exchange was sent to the endpoint                     EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken).                 }                 // release back to the pool                 producers.release(endpoint, producer).             } finally {                 callback.done(doneSync).             }         }).     } catch (Throwable e) {         // ensure exceptions is caught and set on the exchange         if (exchange != null) {             exchange.setException(e).         }         callback.done(true).         return true.     } }
false;protected;5;23;;protected boolean asyncDispatchExchange(Endpoint endpoint, AsyncProducer producer, Processor resultProcessor, Exchange exchange, AsyncCallback callback) {     // now lets dispatch     log.debug(">>>> {} {}", endpoint, exchange).     // set property which endpoint we send to     exchange.setProperty(Exchange.TO_ENDPOINT, endpoint.getEndpointUri()).     // send the exchange using the processor     try {         if (eventNotifierEnabled) {             callback = new EventNotifierCallback(callback, exchange, endpoint).         }         // invoke the asynchronous method         return internalProcessor.process(exchange, callback, producer, resultProcessor).     } catch (Throwable e) {         // ensure exceptions is caught and set on the exchange         exchange.setException(e).         callback.done(true).         return true.     } }
false;protected;1;3;;protected AsyncProducer doGetProducer(Endpoint endpoint) throws Exception {     return producers.acquire(endpoint). }
false;protected;0;8;;protected void doStart() throws Exception {     if (extendedStatistics) {         int max = maxCacheSize == 0 ? CamelContextHelper.getMaximumCachePoolSize(camelContext) : maxCacheSize.         statistics = new DefaultEndpointUtilizationStatistics(max).     }     ServiceHelper.startService(producers, statistics). }
false;protected;0;7;;protected void doStop() throws Exception {     // when stopping we intend to shutdown     ServiceHelper.stopAndShutdownServices(statistics, producers).     if (statistics != null) {         statistics.clear().     } }
true;public;0;6;/**  * Returns the current size of the cache  *  * @return the current size  */ ;/**  * Returns the current size of the cache  *  * @return the current size  */ public int size() {     int size = producers.size().     log.trace("size = {}", size).     return size. }
true;public;0;3;/**  * Gets the maximum cache size (capacity).  *  * @return the capacity  */ ;/**  * Gets the maximum cache size (capacity).  *  * @return the capacity  */ public int getCapacity() {     return maxCacheSize. }
true;public;0;3;/**  * Gets the cache hits statistic  * <p/>  * Will return <tt>-1</tt> if it cannot determine this if a custom cache was used.  *  * @return the hits  */ ;/**  * Gets the cache hits statistic  * <p/>  * Will return <tt>-1</tt> if it cannot determine this if a custom cache was used.  *  * @return the hits  */ public long getHits() {     return producers.getHits(). }
true;public;0;3;/**  * Gets the cache misses statistic  * <p/>  * Will return <tt>-1</tt> if it cannot determine this if a custom cache was used.  *  * @return the misses  */ ;/**  * Gets the cache misses statistic  * <p/>  * Will return <tt>-1</tt> if it cannot determine this if a custom cache was used.  *  * @return the misses  */ public long getMisses() {     return producers.getMisses(). }
true;public;0;3;/**  * Gets the cache evicted statistic  * <p/>  * Will return <tt>-1</tt> if it cannot determine this if a custom cache was used.  *  * @return the evicted  */ ;/**  * Gets the cache evicted statistic  * <p/>  * Will return <tt>-1</tt> if it cannot determine this if a custom cache was used.  *  * @return the evicted  */ public long getEvicted() {     return producers.getEvicted(). }
true;public;0;6;/**  * Resets the cache statistics  */ ;/**  * Resets the cache statistics  */ public void resetCacheStatistics() {     producers.resetStatistics().     if (statistics != null) {         statistics.clear().     } }
true;public,synchronized;0;11;/**  * Purges this cache  */ ;/**  * Purges this cache  */ public synchronized void purge() {     try {         producers.stop().         producers.start().     } catch (Exception e) {         log.debug("Error restarting producers", e).     }     if (statistics != null) {         statistics.clear().     } }
true;public;0;3;/**  * Cleanup the cache (purging stale entries)  */ ;/**  * Cleanup the cache (purging stale entries)  */ public void cleanUp() {     producers.cleanUp(). }
false;public;0;3;;public EndpointUtilizationStatistics getEndpointUtilizationStatistics() {     return statistics. }
false;public;0;4;;@Override public String toString() {     return "ProducerCache for source: " + source + ", capacity: " + getCapacity(). }
