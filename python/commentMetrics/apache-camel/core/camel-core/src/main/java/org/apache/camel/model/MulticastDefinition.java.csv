commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "Multicast[" + getOutputs() + "]". }
false;public;0;4;;@Override public String getShortName() {     return "multicast". }
false;public;0;4;;@Override public String getLabel() {     return "multicast". }
true;public;0;5;/**  * Sets the AggregationStrategy to be used to assemble the replies from the multicasts, into a single outgoing message from the Multicast using a fluent builder.  */ ;// Fluent API // ------------------------------------------------------------------------- /**  * Sets the AggregationStrategy to be used to assemble the replies from the multicasts, into a single outgoing message from the Multicast using a fluent builder.  */ public AggregationStrategyClause<MulticastDefinition> aggregationStrategy() {     AggregationStrategyClause<MulticastDefinition> clause = new AggregationStrategyClause<>(this).     setAggregationStrategy(clause).     return clause. }
true;public;1;4;/**  * Sets the AggregationStrategy to be used to assemble the replies from the multicasts, into a single outgoing message from the Multicast.  * By default Camel will use the last reply as the outgoing message. You can also use a POJO as the AggregationStrategy.  * If an exception is thrown from the aggregate method in the AggregationStrategy, then by default, that exception  * is not handled by the error handler. The error handler can be enabled to react if enabling the shareUnitOfWork option.  */ ;/**  * Sets the AggregationStrategy to be used to assemble the replies from the multicasts, into a single outgoing message from the Multicast.  * By default Camel will use the last reply as the outgoing message. You can also use a POJO as the AggregationStrategy.  * If an exception is thrown from the aggregate method in the AggregationStrategy, then by default, that exception  * is not handled by the error handler. The error handler can be enabled to react if enabling the shareUnitOfWork option.  */ public MulticastDefinition aggregationStrategy(AggregationStrategy aggregationStrategy) {     setAggregationStrategy(aggregationStrategy).     return this. }
true;public;1;4;/**  * Sets a reference to the AggregationStrategy to be used to assemble the replies from the multicasts, into a single outgoing message from the Multicast.  * By default Camel will use the last reply as the outgoing message. You can also use a POJO as the AggregationStrategy  * If an exception is thrown from the aggregate method in the AggregationStrategy, then by default, that exception  * is not handled by the error handler. The error handler can be enabled to react if enabling the shareUnitOfWork option.  */ ;/**  * Sets a reference to the AggregationStrategy to be used to assemble the replies from the multicasts, into a single outgoing message from the Multicast.  * By default Camel will use the last reply as the outgoing message. You can also use a POJO as the AggregationStrategy  * If an exception is thrown from the aggregate method in the AggregationStrategy, then by default, that exception  * is not handled by the error handler. The error handler can be enabled to react if enabling the shareUnitOfWork option.  */ public MulticastDefinition aggregationStrategyRef(String aggregationStrategyRef) {     setStrategyRef(aggregationStrategyRef).     return this. }
true;public;1;4;/**  * This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.  *  * @param  methodName the method name to call  * @return the builder  */ ;/**  * This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.  *  * @param  methodName the method name to call  * @return the builder  */ public MulticastDefinition aggregationStrategyMethodName(String methodName) {     setStrategyMethodName(methodName).     return this. }
true;public;0;4;/**  * If this option is false then the aggregate method is not used if there was no data to enrich.  * If this option is true then null values is used as the oldExchange (when no data to enrich), when using POJOs as the AggregationStrategy  *  * @return the builder  */ ;/**  * If this option is false then the aggregate method is not used if there was no data to enrich.  * If this option is true then null values is used as the oldExchange (when no data to enrich), when using POJOs as the AggregationStrategy  *  * @return the builder  */ public MulticastDefinition aggregationStrategyMethodAllowNull() {     setStrategyMethodAllowNull(true).     return this. }
true;public;0;4;/**  * If enabled then sending messages to the multicasts occurs concurrently.  * Note the caller thread will still wait until all messages has been fully processed, before it continues.  * Its only the sending and processing the replies from the multicasts which happens concurrently.  *  * @return the builder  */ ;/**  * If enabled then sending messages to the multicasts occurs concurrently.  * Note the caller thread will still wait until all messages has been fully processed, before it continues.  * Its only the sending and processing the replies from the multicasts which happens concurrently.  *  * @return the builder  */ public MulticastDefinition parallelProcessing() {     setParallelProcessing(true).     return this. }
true;public;1;4;/**  * If enabled then sending messages to the multicasts occurs concurrently.  * Note the caller thread will still wait until all messages has been fully processed, before it continues.  * Its only the sending and processing the replies from the multicasts which happens concurrently.  *  * @return the builder  */ ;/**  * If enabled then sending messages to the multicasts occurs concurrently.  * Note the caller thread will still wait until all messages has been fully processed, before it continues.  * Its only the sending and processing the replies from the multicasts which happens concurrently.  *  * @return the builder  */ public MulticastDefinition parallelProcessing(boolean parallelProcessing) {     setParallelProcessing(parallelProcessing).     return this. }
true;public;0;4;/**  * If enabled then the aggregate method on AggregationStrategy can be called concurrently.  * Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe.  * By default this is false meaning that Camel synchronizes the call to the aggregate method.  * Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.  *  * @return the builder  */ ;/**  * If enabled then the aggregate method on AggregationStrategy can be called concurrently.  * Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe.  * By default this is false meaning that Camel synchronizes the call to the aggregate method.  * Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.  *  * @return the builder  */ public MulticastDefinition parallelAggregate() {     setParallelAggregate(true).     return this. }
true;public;0;4;/**  * If enabled, unwind exceptions occurring at aggregation time to the error handler when parallelProcessing is used.  * Currently, aggregation time exceptions do not stop the route processing when parallelProcessing is used.  * Enabling this option allows to work around this behavior.  *  * The default value is <code>false</code> for the sake of backward compatibility.  *  * @return the builder  */ ;/**  * If enabled, unwind exceptions occurring at aggregation time to the error handler when parallelProcessing is used.  * Currently, aggregation time exceptions do not stop the route processing when parallelProcessing is used.  * Enabling this option allows to work around this behavior.  *  * The default value is <code>false</code> for the sake of backward compatibility.  *  * @return the builder  */ public MulticastDefinition stopOnAggregateException() {     setStopOnAggregateException(true).     return this. }
true;public;0;4;/**  * If enabled then Camel will process replies out-of-order, eg in the order they come back.  * If disabled, Camel will process replies in the same order as defined by the multicast.  *  * @return the builder  */ ;/**  * If enabled then Camel will process replies out-of-order, eg in the order they come back.  * If disabled, Camel will process replies in the same order as defined by the multicast.  *  * @return the builder  */ public MulticastDefinition streaming() {     setStreaming(true).     return this. }
true;public;0;4;/**  * Will now stop further processing if an exception or failure occurred during processing of an  * {@link org.apache.camel.Exchange} and the caused exception will be thrown.  * <p/>  * Will also stop if processing the exchange failed (has a fault message) or an exception  * was thrown and handled by the error handler (such as using onException). In all situations  * the multicast will stop further processing. This is the same behavior as in pipeline, which  * is used by the routing engine.  * <p/>  * The default behavior is to <b>not</b> stop but continue processing till the end  *  * @return the builder  */ ;/**  * Will now stop further processing if an exception or failure occurred during processing of an  * {@link org.apache.camel.Exchange} and the caused exception will be thrown.  * <p/>  * Will also stop if processing the exchange failed (has a fault message) or an exception  * was thrown and handled by the error handler (such as using onException). In all situations  * the multicast will stop further processing. This is the same behavior as in pipeline, which  * is used by the routing engine.  * <p/>  * The default behavior is to <b>not</b> stop but continue processing till the end  *  * @return the builder  */ public MulticastDefinition stopOnException() {     setStopOnException(true).     return this. }
true;public;1;4;/**  * To use a custom Thread Pool to be used for parallel processing.  * Notice if you set this option, then parallel processing is automatic implied, and you do not have to enable that option as well.  */ ;/**  * To use a custom Thread Pool to be used for parallel processing.  * Notice if you set this option, then parallel processing is automatic implied, and you do not have to enable that option as well.  */ public MulticastDefinition executorService(ExecutorService executorService) {     setExecutorService(executorService).     return this. }
true;public;1;4;/**  * Refers to a custom Thread Pool to be used for parallel processing.  * Notice if you set this option, then parallel processing is automatic implied, and you do not have to enable that option as well.  */ ;/**  * Refers to a custom Thread Pool to be used for parallel processing.  * Notice if you set this option, then parallel processing is automatic implied, and you do not have to enable that option as well.  */ public MulticastDefinition executorServiceRef(String executorServiceRef) {     setExecutorServiceRef(executorServiceRef).     return this. }
true;public;0;5;/**  * Set the {@link Processor} to use when preparing the {@link org.apache.camel.Exchange} to be send using a fluent builder.  */ ;/**  * Set the {@link Processor} to use when preparing the {@link org.apache.camel.Exchange} to be send using a fluent builder.  */ public ProcessClause<MulticastDefinition> onPrepare() {     ProcessClause<MulticastDefinition> clause = new ProcessClause<>(this).     setOnPrepare(clause).     return clause. }
true;public;1;4;/**  * Uses the {@link Processor} when preparing the {@link org.apache.camel.Exchange} to be send.  * This can be used to deep-clone messages that should be send, or any custom logic needed before  * the exchange is send.  *  * @param onPrepare the processor  * @return the builder  */ ;/**  * Uses the {@link Processor} when preparing the {@link org.apache.camel.Exchange} to be send.  * This can be used to deep-clone messages that should be send, or any custom logic needed before  * the exchange is send.  *  * @param onPrepare the processor  * @return the builder  */ public MulticastDefinition onPrepare(Processor onPrepare) {     setOnPrepare(onPrepare).     return this. }
true;public;1;4;/**  * Uses the {@link Processor} when preparing the {@link org.apache.camel.Exchange} to be send.  * This can be used to deep-clone messages that should be send, or any custom logic needed before  * the exchange is send.  *  * @param onPrepareRef reference to the processor to lookup in the {@link org.apache.camel.spi.Registry}  * @return the builder  */ ;/**  * Uses the {@link Processor} when preparing the {@link org.apache.camel.Exchange} to be send.  * This can be used to deep-clone messages that should be send, or any custom logic needed before  * the exchange is send.  *  * @param onPrepareRef reference to the processor to lookup in the {@link org.apache.camel.spi.Registry}  * @return the builder  */ public MulticastDefinition onPrepareRef(String onPrepareRef) {     setOnPrepareRef(onPrepareRef).     return this. }
true;public;1;4;/**  * Sets a total timeout specified in millis, when using parallel processing.  * If the Multicast hasn't been able to send and process all replies within the given timeframe,  * then the timeout triggers and the Multicast breaks out and continues.  * Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out.  * If the timeout is reached with running tasks still remaining, certain tasks for which it is difficult for Camel  * to shut down in a graceful manner may continue to run. So use this option with a bit of care.  *  * @param timeout timeout in millis  * @return the builder  */ ;/**  * Sets a total timeout specified in millis, when using parallel processing.  * If the Multicast hasn't been able to send and process all replies within the given timeframe,  * then the timeout triggers and the Multicast breaks out and continues.  * Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out.  * If the timeout is reached with running tasks still remaining, certain tasks for which it is difficult for Camel  * to shut down in a graceful manner may continue to run. So use this option with a bit of care.  *  * @param timeout timeout in millis  * @return the builder  */ public MulticastDefinition timeout(long timeout) {     setTimeout(timeout).     return this. }
true;public;0;4;/**  * Shares the {@link org.apache.camel.spi.UnitOfWork} with the parent and each of the sub messages.  * Multicast will by default not share unit of work between the parent exchange and each multicasted exchange.  * This means each sub exchange has its own individual unit of work.  *  * @return the builder.  * @see org.apache.camel.spi.SubUnitOfWork  */ ;/**  * Shares the {@link org.apache.camel.spi.UnitOfWork} with the parent and each of the sub messages.  * Multicast will by default not share unit of work between the parent exchange and each multicasted exchange.  * This means each sub exchange has its own individual unit of work.  *  * @return the builder.  * @see org.apache.camel.spi.SubUnitOfWork  */ public MulticastDefinition shareUnitOfWork() {     setShareUnitOfWork(true).     return this. }
false;public;0;3;;public AggregationStrategy getAggregationStrategy() {     return aggregationStrategy. }
false;public;1;4;;public MulticastDefinition setAggregationStrategy(AggregationStrategy aggregationStrategy) {     this.aggregationStrategy = aggregationStrategy.     return this. }
false;public;0;3;;public Boolean getParallelProcessing() {     return parallelProcessing. }
false;public;1;3;;public void setParallelProcessing(Boolean parallelProcessing) {     this.parallelProcessing = parallelProcessing. }
false;public;0;3;;public Boolean getStreaming() {     return streaming. }
false;public;1;3;;public void setStreaming(Boolean streaming) {     this.streaming = streaming. }
false;public;0;3;;public Boolean getStopOnException() {     return stopOnException. }
false;public;1;3;;public void setStopOnException(Boolean stopOnException) {     this.stopOnException = stopOnException. }
false;public;0;3;;public ExecutorService getExecutorService() {     return executorService. }
false;public;1;3;;public void setExecutorService(ExecutorService executorService) {     this.executorService = executorService. }
false;public;0;3;;public String getStrategyRef() {     return strategyRef. }
true;public;1;3;/**  * Refers to an AggregationStrategy to be used to assemble the replies from the multicasts, into a single outgoing message from the Multicast.  * By default Camel will use the last reply as the outgoing message. You can also use a POJO as the AggregationStrategy  */ ;/**  * Refers to an AggregationStrategy to be used to assemble the replies from the multicasts, into a single outgoing message from the Multicast.  * By default Camel will use the last reply as the outgoing message. You can also use a POJO as the AggregationStrategy  */ public void setStrategyRef(String strategyRef) {     this.strategyRef = strategyRef. }
false;public;0;3;;public String getStrategyMethodName() {     return strategyMethodName. }
true;public;1;3;/**  * This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.  */ ;/**  * This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.  */ public void setStrategyMethodName(String strategyMethodName) {     this.strategyMethodName = strategyMethodName. }
false;public;0;3;;public Boolean getStrategyMethodAllowNull() {     return strategyMethodAllowNull. }
true;public;1;3;/**  * If this option is false then the aggregate method is not used if there was no data to enrich.  * If this option is true then null values is used as the oldExchange (when no data to enrich), when using POJOs as the AggregationStrategy  */ ;/**  * If this option is false then the aggregate method is not used if there was no data to enrich.  * If this option is true then null values is used as the oldExchange (when no data to enrich), when using POJOs as the AggregationStrategy  */ public void setStrategyMethodAllowNull(Boolean strategyMethodAllowNull) {     this.strategyMethodAllowNull = strategyMethodAllowNull. }
false;public;0;3;;public String getExecutorServiceRef() {     return executorServiceRef. }
true;public;1;3;/**  * Refers to a custom Thread Pool to be used for parallel processing.  * Notice if you set this option, then parallel processing is automatic implied, and you do not have to enable that option as well.  */ ;/**  * Refers to a custom Thread Pool to be used for parallel processing.  * Notice if you set this option, then parallel processing is automatic implied, and you do not have to enable that option as well.  */ public void setExecutorServiceRef(String executorServiceRef) {     this.executorServiceRef = executorServiceRef. }
false;public;0;3;;public Long getTimeout() {     return timeout. }
false;public;1;3;;public void setTimeout(Long timeout) {     this.timeout = timeout. }
false;public;0;3;;public String getOnPrepareRef() {     return onPrepareRef. }
false;public;1;3;;public void setOnPrepareRef(String onPrepareRef) {     this.onPrepareRef = onPrepareRef. }
false;public;0;3;;public Processor getOnPrepare() {     return onPrepare. }
false;public;1;3;;public void setOnPrepare(Processor onPrepare) {     this.onPrepare = onPrepare. }
false;public;0;3;;public Boolean getShareUnitOfWork() {     return shareUnitOfWork. }
false;public;1;3;;public void setShareUnitOfWork(Boolean shareUnitOfWork) {     this.shareUnitOfWork = shareUnitOfWork. }
false;public;0;3;;public Boolean getParallelAggregate() {     return parallelAggregate. }
false;public;1;3;;public void setParallelAggregate(Boolean parallelAggregate) {     this.parallelAggregate = parallelAggregate. }
false;public;0;3;;public Boolean getStopOnAggregateException() {     return stopOnAggregateException. }
false;public;1;3;;public void setStopOnAggregateException(Boolean stopOnAggregateException) {     this.stopOnAggregateException = stopOnAggregateException. }
