commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;5;;public static <T extends ExpressionNode> ExpressionClause<T> createAndSetExpression(T result) {     ExpressionClause<T> clause = new ExpressionClause<>(result).     result.setExpression(clause).     return clause. }
true;public;1;3;/**  * Specify an {@link Expression} instance  */ ;// Helper expressions // ------------------------------------------------------------------------- /**  * Specify an {@link Expression} instance  */ public T expression(Expression expression) {     return delegate.expression(expression). }
true;public;1;3;/**  * Specify the constant expression value.  *  * <b>Important:</b> this is a fixed constant value that is only set once during starting up the route,  * do not use this if you want dynamic values during routing.  */ ;/**  * Specify the constant expression value.  *  * <b>Important:</b> this is a fixed constant value that is only set once during starting up the route,  * do not use this if you want dynamic values during routing.  */ public T constant(Object value) {     return delegate.constant(value). }
true;public;0;3;/**  * An expression of the exchange  */ ;/**  * An expression of the exchange  */ public T exchange() {     return delegate.exchange(). }
false;public;1;3;;public Object evaluate(Exchange exchange) {     return function.apply(exchange). }
true;public;1;7;/**  * A functional expression of the exchange  */ ;/**  * A functional expression of the exchange  */ public T exchange(final Function<Exchange, Object> function) {     return delegate.expression(new ExpressionAdapter() {          public Object evaluate(Exchange exchange) {             return function.apply(exchange).         }     }). }
true;public;0;3;/**  * An expression of an inbound message  */ ;/**  * An expression of an inbound message  */ public T message() {     return inMessage(). }
true;public;1;3;/**  * A functional expression of an inbound message  */ ;/**  * A functional expression of an inbound message  */ public T message(final Function<Message, Object> function) {     return inMessage(function). }
true;public;0;3;/**  * An expression of an inbound message  */ ;/**  * An expression of an inbound message  */ public T inMessage() {     return delegate.inMessage(). }
false;public;1;3;;public Object evaluate(Exchange exchange) {     return function.apply(exchange.getIn()). }
true;public;1;7;/**  * A functional expression of an inbound message  */ ;/**  * A functional expression of an inbound message  */ public T inMessage(final Function<Message, Object> function) {     return delegate.expression(new ExpressionAdapter() {          public Object evaluate(Exchange exchange) {             return function.apply(exchange.getIn()).         }     }). }
true;public;0;3;/**  * An expression of an outbound message  */ ;/**  * An expression of an outbound message  */ public T outMessage() {     return delegate.outMessage(). }
false;public;1;3;;public Object evaluate(Exchange exchange) {     return function.apply(exchange.getOut()). }
true;public;1;7;/**  * A functional expression of an outbound message  */ ;/**  * A functional expression of an outbound message  */ public T outMessage(final Function<Message, Object> function) {     return delegate.expression(new ExpressionAdapter() {          public Object evaluate(Exchange exchange) {             return function.apply(exchange.getOut()).         }     }). }
true;public;0;3;/**  * An expression of an inbound message body  */ ;/**  * An expression of an inbound message body  */ public T body() {     return delegate.body(). }
false;public;1;3;;public Object evaluate(Exchange exchange) {     return function.apply(exchange.getIn().getBody()). }
true;public;1;7;/**  * A functional expression of an inbound message body  */ ;/**  * A functional expression of an inbound message body  */ public T body(final Function<Object, Object> function) {     return delegate.expression(new ExpressionAdapter() {          public Object evaluate(Exchange exchange) {             return function.apply(exchange.getIn().getBody()).         }     }). }
false;public;1;3;;public Object evaluate(Exchange exchange) {     return supplier.get(). }
true;public;1;7;/**  * A functional expression of an inbound message body  */ ;/**  * A functional expression of an inbound message body  */ public T body(final Supplier<Object> supplier) {     return delegate.expression(new ExpressionAdapter() {          public Object evaluate(Exchange exchange) {             return supplier.get().         }     }). }
false;public;1;5;;public Object evaluate(Exchange exchange) {     return function.apply(exchange.getIn().getBody(), exchange.getIn().getHeaders()). }
true;public;1;9;/**  * A functional expression of an inbound message body and headers  */ ;/**  * A functional expression of an inbound message body and headers  */ public T body(final BiFunction<Object, Map<String, Object>, Object> function) {     return delegate.expression(new ExpressionAdapter() {          public Object evaluate(Exchange exchange) {             return function.apply(exchange.getIn().getBody(), exchange.getIn().getHeaders()).         }     }). }
true;public;1;3;/**  * An expression of an inbound message body converted to the expected type  */ ;/**  * An expression of an inbound message body converted to the expected type  */ public T body(Class<?> expectedType) {     return delegate.body(expectedType). }
false;public;1;3;;public Object evaluate(Exchange exchange) {     return function.apply(exchange.getIn().getBody(expectedType)). }
true;public;2;7;/**  * A functional expression of an inbound message body converted to the expected type  */ ;/**  * A functional expression of an inbound message body converted to the expected type  */ public <B> T body(Class<B> expectedType, final Function<B, Object> function) {     return delegate.expression(new ExpressionAdapter() {          public Object evaluate(Exchange exchange) {             return function.apply(exchange.getIn().getBody(expectedType)).         }     }). }
false;public;1;5;;public Object evaluate(Exchange exchange) {     return function.apply(exchange.getIn().getBody(expectedType), exchange.getIn().getHeaders()). }
true;public;2;9;/**  * A functional expression of an inbound message body converted to the expected type and headers  */ ;/**  * A functional expression of an inbound message body converted to the expected type and headers  */ public <B> T body(Class<B> expectedType, final BiFunction<B, Map<String, Object>, Object> function) {     return delegate.expression(new ExpressionAdapter() {          public Object evaluate(Exchange exchange) {             return function.apply(exchange.getIn().getBody(expectedType), exchange.getIn().getHeaders()).         }     }). }
true;public;0;3;/**  * An expression of an outbound message body  */ ;/**  * An expression of an outbound message body  */ public T outBody() {     return delegate.outBody(). }
false;public;1;3;;public Object evaluate(Exchange exchange) {     return function.apply(exchange.getOut().getBody()). }
true;public;1;7;/**  * A functional expression of an outbound message body  */ ;/**  * A functional expression of an outbound message body  */ public T outBody(final Function<Object, Object> function) {     return delegate.expression(new ExpressionAdapter() {          public Object evaluate(Exchange exchange) {             return function.apply(exchange.getOut().getBody()).         }     }). }
false;public;1;5;;public Object evaluate(Exchange exchange) {     return function.apply(exchange.getOut().getBody(), exchange.getOut().getHeaders()). }
true;public;1;9;/**  * A functional expression of an outbound message body and headers  */ ;/**  * A functional expression of an outbound message body and headers  */ public T outBody(final BiFunction<Object, Map<String, Object>, Object> function) {     return delegate.expression(new ExpressionAdapter() {          public Object evaluate(Exchange exchange) {             return function.apply(exchange.getOut().getBody(), exchange.getOut().getHeaders()).         }     }). }
true;public;1;3;/**  * An expression of an outbound message body converted to the expected type  */ ;/**  * An expression of an outbound message body converted to the expected type  */ public T outBody(Class<?> expectedType) {     return delegate.outBody(expectedType). }
false;public;1;3;;public Object evaluate(Exchange exchange) {     return function.apply(exchange.getOut().getBody(expectedType)). }
true;public;2;7;/**  * A functional expression of an outbound message body converted to the expected type  */ ;/**  * A functional expression of an outbound message body converted to the expected type  */ public <B> T outBody(Class<B> expectedType, final Function<B, Object> function) {     return delegate.expression(new ExpressionAdapter() {          public Object evaluate(Exchange exchange) {             return function.apply(exchange.getOut().getBody(expectedType)).         }     }). }
false;public;1;5;;public Object evaluate(Exchange exchange) {     return function.apply(exchange.getOut().getBody(expectedType), exchange.getOut().getHeaders()). }
true;public;2;9;/**  * A functional expression of an outbound message body converted to the expected type and headers  */ ;/**  * A functional expression of an outbound message body converted to the expected type and headers  */ public <B> T outBody(Class<B> expectedType, final BiFunction<B, Map<String, Object>, Object> function) {     return delegate.expression(new ExpressionAdapter() {          public Object evaluate(Exchange exchange) {             return function.apply(exchange.getOut().getBody(expectedType), exchange.getOut().getHeaders()).         }     }). }
true;public;1;3;/**  * An expression of an inbound message header of the given name  */ ;/**  * An expression of an inbound message header of the given name  */ public T header(String name) {     return delegate.header(name). }
true;public;0;3;/**  * An expression of the inbound headers  */ ;/**  * An expression of the inbound headers  */ public T headers() {     return delegate.headers(). }
true;public;1;3;/**  * An expression of an outbound message header of the given name  */ ;/**  * An expression of an outbound message header of the given name  */ public T outHeader(String name) {     return delegate.outHeader(name). }
true;public;0;3;/**  * An expression of the outbound headers  */ ;/**  * An expression of the outbound headers  */ public T outHeaders() {     return delegate.outHeaders(). }
true;public;0;3;/**  * An expression of the inbound message attachments  */ ;/**  * An expression of the inbound message attachments  */ public T attachments() {     return delegate.attachments(). }
true;public;1;3;/**  * An expression of an exchange property of the given name  */ ;/**  * An expression of an exchange property of the given name  */ public T exchangeProperty(String name) {     return delegate.exchangeProperty(name). }
true;public;0;3;/**  * An expression of the exchange properties  */ ;/**  * An expression of the exchange properties  */ public T exchangeProperties() {     return delegate.exchangeProperties(). }
true;public;1;3;/**  * Evaluates an expression using the <a  * href="http://camel.apache.org/bean-language.html">bean language</a>  * which basically means the bean is invoked to determine the expression  * value.  *  * @param bean the name of the bean looked up the registry  * @return the builder to continue processing the DSL  */ ;// Languages // ------------------------------------------------------------------------- /**  * Evaluates an expression using the <a  * href="http://camel.apache.org/bean-language.html">bean language</a>  * which basically means the bean is invoked to determine the expression  * value.  *  * @param bean the name of the bean looked up the registry  * @return the builder to continue processing the DSL  */ public T method(String bean) {     return delegate.method(bean). }
true;public;1;3;/**  * Evaluates an expression using the <a  * href="http://camel.apache.org/bean-language.html">bean language</a>  * which basically means the bean is invoked to determine the expression  * value.  *  * @param instance the instance of the bean  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an expression using the <a  * href="http://camel.apache.org/bean-language.html">bean language</a>  * which basically means the bean is invoked to determine the expression  * value.  *  * @param instance the instance of the bean  * @return the builder to continue processing the DSL  */ public T method(Object instance) {     return delegate.method(instance). }
true;public;1;3;/**  * Evaluates an expression using the <a  * href="http://camel.apache.org/bean-language.html">bean language</a>  * which basically means the bean is invoked to determine the expression  * value.  *  * @param beanType the Class of the bean which we want to invoke  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an expression using the <a  * href="http://camel.apache.org/bean-language.html">bean language</a>  * which basically means the bean is invoked to determine the expression  * value.  *  * @param beanType the Class of the bean which we want to invoke  * @return the builder to continue processing the DSL  */ public T method(Class<?> beanType) {     return delegate.method(beanType). }
true;public;2;3;/**  * Evaluates an expression using the <a  * href="http://camel.apache.org/bean-language.html">bean language</a>  * which basically means the bean is invoked to determine the expression  * value.  *  * @param bean the name of the bean looked up the registry  * @param method the name of the method to invoke on the bean  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an expression using the <a  * href="http://camel.apache.org/bean-language.html">bean language</a>  * which basically means the bean is invoked to determine the expression  * value.  *  * @param bean the name of the bean looked up the registry  * @param method the name of the method to invoke on the bean  * @return the builder to continue processing the DSL  */ public T method(String bean, String method) {     return delegate.method(bean, method). }
true;public;2;3;/**  * Evaluates an expression using the <a  * href="http://camel.apache.org/bean-language.html">bean language</a>  * which basically means the bean is invoked to determine the expression  * value.  *  * @param instance the instance of the bean  * @param method the name of the method to invoke on the bean  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an expression using the <a  * href="http://camel.apache.org/bean-language.html">bean language</a>  * which basically means the bean is invoked to determine the expression  * value.  *  * @param instance the instance of the bean  * @param method the name of the method to invoke on the bean  * @return the builder to continue processing the DSL  */ public T method(Object instance, String method) {     return delegate.method(instance, method). }
true;public;2;3;/**  * Evaluates an expression using the <a  * href="http://camel.apache.org/bean-language.html">bean language</a>  * which basically means the bean is invoked to determine the expression  * value.  *  * @param beanType the Class of the bean which we want to invoke  * @param method the name of the method to invoke on the bean  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an expression using the <a  * href="http://camel.apache.org/bean-language.html">bean language</a>  * which basically means the bean is invoked to determine the expression  * value.  *  * @param beanType the Class of the bean which we want to invoke  * @param method the name of the method to invoke on the bean  * @return the builder to continue processing the DSL  */ public T method(Class<?> beanType, String method) {     return delegate.method(beanType, method). }
true;public;1;3;/**  * Evaluates a <a href="http://camel.apache.org/groovy.html">Groovy  * expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a <a href="http://camel.apache.org/groovy.html">Groovy  * expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ public T groovy(String text) {     return delegate.groovy(text). }
true;public;1;4;/**  * Evaluates a <a  * href="http://camel.apache.org/java-script.html">JavaScript  * expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  * @deprecated JavaScript is deprecated in Java 11 onwards  */ ;/**  * Evaluates a <a  * href="http://camel.apache.org/java-script.html">JavaScript  * expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  * @deprecated JavaScript is deprecated in Java 11 onwards  */ @Deprecated public T javaScript(String text) {     return delegate.javaScript(text). }
true;public;1;3;/**  * Evaluates a <a  * href="http://camel.apache.org/jsonpath.html">Json Path  * expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a <a  * href="http://camel.apache.org/jsonpath.html">Json Path  * expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ public T jsonpath(String text) {     return delegate.jsonpath(text). }
true;public;2;3;/**  * Evaluates a <a  * href="http://camel.apache.org/jsonpath.html">Json Path  * expression</a>  *  * @param text the expression to be evaluated  * @param suppressExceptions whether to suppress exceptions such as PathNotFoundException  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a <a  * href="http://camel.apache.org/jsonpath.html">Json Path  * expression</a>  *  * @param text the expression to be evaluated  * @param suppressExceptions whether to suppress exceptions such as PathNotFoundException  * @return the builder to continue processing the DSL  */ public T jsonpath(String text, boolean suppressExceptions) {     return delegate.jsonpath(text, suppressExceptions). }
true;public;2;3;/**  * Evaluates a <a  * href="http://camel.apache.org/jsonpath.html">Json Path  * expression</a>  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a <a  * href="http://camel.apache.org/jsonpath.html">Json Path  * expression</a>  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @return the builder to continue processing the DSL  */ public T jsonpath(String text, Class<?> resultType) {     return delegate.jsonpath(text, resultType). }
true;public;3;3;/**  * Evaluates a <a  * href="http://camel.apache.org/jsonpath.html">Json Path  * expression</a>  *  * @param text the expression to be evaluated  * @param suppressExceptions whether to suppress exceptions such as PathNotFoundException  * @param resultType the return type expected by the expression  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a <a  * href="http://camel.apache.org/jsonpath.html">Json Path  * expression</a>  *  * @param text the expression to be evaluated  * @param suppressExceptions whether to suppress exceptions such as PathNotFoundException  * @param resultType the return type expected by the expression  * @return the builder to continue processing the DSL  */ public T jsonpath(String text, boolean suppressExceptions, Class<?> resultType) {     return delegate.jsonpath(text, suppressExceptions, resultType). }
true;public;4;3;/**  * Evaluates a <a  * href="http://camel.apache.org/jsonpath.html">Json Path  * expression</a>  *  * @param text the expression to be evaluated  * @param suppressExceptions whether to suppress exceptions such as PathNotFoundException  * @param resultType the return type expected by the expression  * @param headerName the name of the header to apply the expression to  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a <a  * href="http://camel.apache.org/jsonpath.html">Json Path  * expression</a>  *  * @param text the expression to be evaluated  * @param suppressExceptions whether to suppress exceptions such as PathNotFoundException  * @param resultType the return type expected by the expression  * @param headerName the name of the header to apply the expression to  * @return the builder to continue processing the DSL  */ public T jsonpath(String text, boolean suppressExceptions, Class<?> resultType, String headerName) {     return delegate.jsonpath(text, suppressExceptions, true, resultType, headerName). }
true;public;1;3;/**  * Evaluates a <a  * href="http://camel.apache.org/jsonpath.html">Json Path  * expression</a> with writeAsString enabled.  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a <a  * href="http://camel.apache.org/jsonpath.html">Json Path  * expression</a> with writeAsString enabled.  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ public T jsonpathWriteAsString(String text) {     return delegate.jsonpathWriteAsString(text). }
true;public;2;3;/**  * Evaluates a <a  * href="http://camel.apache.org/jsonpath.html">Json Path  * expression</a> with writeAsString enabled.  *  * @param text the expression to be evaluated  * @param suppressExceptions whether to suppress exceptions such as PathNotFoundException  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a <a  * href="http://camel.apache.org/jsonpath.html">Json Path  * expression</a> with writeAsString enabled.  *  * @param text the expression to be evaluated  * @param suppressExceptions whether to suppress exceptions such as PathNotFoundException  * @return the builder to continue processing the DSL  */ public T jsonpathWriteAsString(String text, boolean suppressExceptions) {     return delegate.jsonpathWriteAsString(text, suppressExceptions). }
true;public;3;3;/**  * Evaluates a <a  * href="http://camel.apache.org/jsonpath.html">Json Path  * expression</a> with writeAsString enabled.  *  * @param text the expression to be evaluated  * @param suppressExceptions whether to suppress exceptions such as PathNotFoundException  * @param headerName the name of the header to apply the expression to  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a <a  * href="http://camel.apache.org/jsonpath.html">Json Path  * expression</a> with writeAsString enabled.  *  * @param text the expression to be evaluated  * @param suppressExceptions whether to suppress exceptions such as PathNotFoundException  * @param headerName the name of the header to apply the expression to  * @return the builder to continue processing the DSL  */ public T jsonpathWriteAsString(String text, boolean suppressExceptions, String headerName) {     return delegate.jsonpathWriteAsString(text, suppressExceptions, true, headerName). }
true;public;1;3;/**  * Evaluates an <a href="http://camel.apache.org/ognl.html">OGNL  * expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a href="http://camel.apache.org/ognl.html">OGNL  * expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ public T ognl(String text) {     return delegate.ognl(text). }
true;public;1;3;/**  * Evaluates a <a href="http://camel.apache.org/mvel.html">MVEL  * expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a <a href="http://camel.apache.org/mvel.html">MVEL  * expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ public T mvel(String text) {     return delegate.mvel(text). }
true;public;1;3;/**  * Evaluates a <a href="http://camel.apache.org/ref-language.html">Ref  * expression</a>  *  * @param ref refers to the expression to be evaluated  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a <a href="http://camel.apache.org/ref-language.html">Ref  * expression</a>  *  * @param ref refers to the expression to be evaluated  * @return the builder to continue processing the DSL  */ public T ref(String ref) {     return delegate.ref(ref). }
true;public;1;3;/**  * Evaluates a <a href="http://camel.apache.org/spel.html">SpEL  * expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a <a href="http://camel.apache.org/spel.html">SpEL  * expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ public T spel(String text) {     return delegate.spel(text). }
true;public;1;3;/**  * Evaluates a <a href="http://camel.apache.org/simple.html">Simple  * expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a <a href="http://camel.apache.org/simple.html">Simple  * expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ public T simple(String text) {     return delegate.simple(text). }
true;public;2;3;/**  * Evaluates a <a href="http://camel.apache.org/simple.html">Simple  * expression</a>  *  * @param text the expression to be evaluated  * @param resultType the result type  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a <a href="http://camel.apache.org/simple.html">Simple  * expression</a>  *  * @param text the expression to be evaluated  * @param resultType the result type  * @return the builder to continue processing the DSL  */ public T simple(String text, Class<?> resultType) {     return delegate.simple(text, resultType). }
true;public;1;3;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @return the builder to continue processing the DSL  */ public T tokenize(String token) {     return delegate.tokenize(token). }
true;public;2;3;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @param regex whether the token is a regular expression or not  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @param regex whether the token is a regular expression or not  * @return the builder to continue processing the DSL  */ public T tokenize(String token, boolean regex) {     return tokenize(token, regex, false). }
true;public;3;3;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @param regex whether the token is a regular expression or not  * @param skipFirst whether to skip the first element  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @param regex whether the token is a regular expression or not  * @param skipFirst whether to skip the first element  * @return the builder to continue processing the DSL  */ public T tokenize(String token, boolean regex, boolean skipFirst) {     return delegate.tokenize(token, null, regex, skipFirst). }
true;public;3;3;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @param regex whether the token is a regular expression or not  * @param group to group by the given number  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @param regex whether the token is a regular expression or not  * @param group to group by the given number  * @return the builder to continue processing the DSL  */ public T tokenize(String token, boolean regex, int group) {     return tokenize(token, regex, group, false). }
true;public;3;3;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @param regex whether the token is a regular expression or not  * @param group to group by the given number  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @param regex whether the token is a regular expression or not  * @param group to group by the given number  * @return the builder to continue processing the DSL  */ public T tokenize(String token, boolean regex, String group) {     return tokenize(token, regex, group, false). }
true;public;4;3;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @param regex whether the token is a regular expression or not  * @param group to group by the given number  * @param skipFirst whether to skip the first element  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @param regex whether the token is a regular expression or not  * @param group to group by the given number  * @param skipFirst whether to skip the first element  * @return the builder to continue processing the DSL  */ public T tokenize(String token, boolean regex, int group, boolean skipFirst) {     return delegate.tokenize(token, null, regex, group, skipFirst). }
true;public;4;3;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @param regex whether the token is a regular expression or not  * @param group to group by the given number  * @param skipFirst whether to skip the first element  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @param regex whether the token is a regular expression or not  * @param group to group by the given number  * @param skipFirst whether to skip the first element  * @return the builder to continue processing the DSL  */ public T tokenize(String token, boolean regex, String group, boolean skipFirst) {     return delegate.tokenize(token, null, regex, group, skipFirst). }
true;public;2;3;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @param group to group by the given number  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @param group to group by the given number  * @return the builder to continue processing the DSL  */ public T tokenize(String token, int group) {     return delegate.tokenize(token, group). }
true;public;3;3;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @param group to group by the given number  * @param skipFirst whether to skip the first element  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a token expression on the message body  *  * @param token the token  * @param group to group by the given number  * @param skipFirst whether to skip the first element  * @return the builder to continue processing the DSL  */ public T tokenize(String token, int group, boolean skipFirst) {     return delegate.tokenize(token, group, skipFirst). }
true;public;2;3;/**  * Evaluates a token expression on the given header  *  * @param token the token  * @param headerName name of header to tokenize  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a token expression on the given header  *  * @param token the token  * @param headerName name of header to tokenize  * @return the builder to continue processing the DSL  */ public T tokenize(String token, String headerName) {     return delegate.tokenize(token, headerName). }
true;public;3;3;/**  * Evaluates a token expression on the given header  *  * @param token the token  * @param headerName name of header to tokenize  * @param regex whether the token is a regular expression or not  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a token expression on the given header  *  * @param token the token  * @param headerName name of header to tokenize  * @param regex whether the token is a regular expression or not  * @return the builder to continue processing the DSL  */ public T tokenize(String token, String headerName, boolean regex) {     return delegate.tokenize(token, headerName, regex). }
true;public;2;3;/**  * Evaluates a token pair expression on the message body.  * <p/>  * Tokens is not included.  *  * @param startToken the start token  * @param endToken   the end token  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a token pair expression on the message body.  * <p/>  * Tokens is not included.  *  * @param startToken the start token  * @param endToken   the end token  * @return the builder to continue processing the DSL  */ public T tokenizePair(String startToken, String endToken) {     return tokenizePair(startToken, endToken, false). }
true;public;3;3;/**  * Evaluates a token pair expression on the message body  *  * @param startToken the start token  * @param endToken   the end token  * @param includeTokens whether to include tokens  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a token pair expression on the message body  *  * @param startToken the start token  * @param endToken   the end token  * @param includeTokens whether to include tokens  * @return the builder to continue processing the DSL  */ public T tokenizePair(String startToken, String endToken, boolean includeTokens) {     return delegate.tokenizePair(startToken, endToken, includeTokens). }
true;public;1;3;/**  * Evaluates a XML token expression on the message body with XML content  *  * @param tagName the tag name of the child nodes to tokenize  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a XML token expression on the message body with XML content  *  * @param tagName the tag name of the child nodes to tokenize  * @return the builder to continue processing the DSL  */ public T tokenizeXML(String tagName) {     return tokenizeXML(tagName, null). }
true;public;2;3;/**  * Evaluates a XML token expression on the message body with XML content  *  * @param tagName the tag name of the child nodes to tokenize  * @param group to group by the given number  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a XML token expression on the message body with XML content  *  * @param tagName the tag name of the child nodes to tokenize  * @param group to group by the given number  * @return the builder to continue processing the DSL  */ public T tokenizeXML(String tagName, int group) {     return tokenizeXML(tagName, null, group). }
true;public;2;3;/**  * Evaluates a token pair expression on the message body with XML content  *  * @param tagName the tag name of the child nodes to tokenize  * @param inheritNamespaceTagName  parent or root tag name that contains namespace(s) to inherit  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a token pair expression on the message body with XML content  *  * @param tagName the tag name of the child nodes to tokenize  * @param inheritNamespaceTagName  parent or root tag name that contains namespace(s) to inherit  * @return the builder to continue processing the DSL  */ public T tokenizeXML(String tagName, String inheritNamespaceTagName) {     return tokenizeXML(tagName, inheritNamespaceTagName, 0). }
true;public;3;3;/**  * Evaluates a token pair expression on the message body with XML content  *  * @param tagName the tag name of the child nodes to tokenize  * @param inheritNamespaceTagName  parent or root tag name that contains namespace(s) to inherit  * @param group to group by the given number  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a token pair expression on the message body with XML content  *  * @param tagName the tag name of the child nodes to tokenize  * @param inheritNamespaceTagName  parent or root tag name that contains namespace(s) to inherit  * @param group to group by the given number  * @return the builder to continue processing the DSL  */ public T tokenizeXML(String tagName, String inheritNamespaceTagName, int group) {     return delegate.tokenizeXMLPair(tagName, inheritNamespaceTagName, group). }
false;public;2;3;;public T xtokenize(String path, Namespaces namespaces) {     return xtokenize(path, 'i', namespaces). }
false;public;3;3;;public T xtokenize(String path, char mode, Namespaces namespaces) {     return xtokenize(path, mode, namespaces, 0). }
false;public;4;3;;public T xtokenize(String path, char mode, Namespaces namespaces, int group) {     return delegate.xtokenize(path, mode, namespaces, group). }
true;public;1;3;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ public T xpath(String text) {     return delegate.xpath(text). }
true;public;2;3;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> on the supplied header name's contents  *  * @param text the expression to be evaluated  * @param headerName the name of the header to apply the expression to  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> on the supplied header name's contents  *  * @param text the expression to be evaluated  * @param headerName the name of the header to apply the expression to  * @return the builder to continue processing the DSL  */ public T xpath(String text, String headerName) {     return delegate.xpath(text, headerName). }
true;public;2;3;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> with the specified result type  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> with the specified result type  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @return the builder to continue processing the DSL  */ public T xpath(String text, Class<?> resultType) {     return delegate.xpath(text, resultType). }
true;public;3;3;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> with the specified result type on the supplied  * header name's contents  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @param headerName the name of the header to apply the expression to  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> with the specified result type on the supplied  * header name's contents  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @param headerName the name of the header to apply the expression to  * @return the builder to continue processing the DSL  */ public T xpath(String text, Class<?> resultType, String headerName) {     return delegate.xpath(text, resultType, headerName). }
true;public;3;3;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> with the specified result type and set of namespace  * prefixes and URIs  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @param namespaces the namespace prefix and URIs to use  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> with the specified result type and set of namespace  * prefixes and URIs  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @param namespaces the namespace prefix and URIs to use  * @return the builder to continue processing the DSL  */ public T xpath(String text, Class<?> resultType, Namespaces namespaces) {     return delegate.xpath(text, resultType, namespaces). }
true;public;4;3;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> with the specified result type and set of namespace  * prefixes and URIs on the supplied header name's contents  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @param headerName the name of the header to apply the expression to  * @param namespaces the namespace prefix and URIs to use  *  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> with the specified result type and set of namespace  * prefixes and URIs on the supplied header name's contents  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @param headerName the name of the header to apply the expression to  * @param namespaces the namespace prefix and URIs to use  *  * @return the builder to continue processing the DSL  */ public T xpath(String text, Class<?> resultType, Namespaces namespaces, String headerName) {     return delegate.xpath(text, resultType, namespaces, headerName). }
true;public;3;3;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> with the specified result type and set of namespace  * prefixes and URIs  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @param namespaces the namespace prefix and URIs to use  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> with the specified result type and set of namespace  * prefixes and URIs  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @param namespaces the namespace prefix and URIs to use  * @return the builder to continue processing the DSL  */ public T xpath(String text, Class<?> resultType, Map<String, String> namespaces) {     return delegate.xpath(text, resultType, namespaces). }
true;public;2;3;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> with the specified set of namespace prefixes and URIs  *  * @param text the expression to be evaluated  * @param namespaces the namespace prefix and URIs to use  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> with the specified set of namespace prefixes and URIs  *  * @param text the expression to be evaluated  * @param namespaces the namespace prefix and URIs to use  * @return the builder to continue processing the DSL  */ public T xpath(String text, Namespaces namespaces) {     return delegate.xpath(text, namespaces). }
true;public;2;3;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> with the specified set of namespace prefixes and URIs  *  * @param text the expression to be evaluated  * @param namespaces the namespace prefix and URIs to use  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> with the specified set of namespace prefixes and URIs  *  * @param text the expression to be evaluated  * @param namespaces the namespace prefix and URIs to use  * @return the builder to continue processing the DSL  */ public T xpath(String text, Map<String, String> namespaces) {     return delegate.xpath(text, namespaces). }
true;public;1;3;/**  * Evaluates an <a  * href="http://camel.apache.org/xquery.html">XQuery expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a  * href="http://camel.apache.org/xquery.html">XQuery expression</a>  *  * @param text the expression to be evaluated  * @return the builder to continue processing the DSL  */ public T xquery(String text) {     return delegate.xquery(text). }
true;public;2;3;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> on the supplied header name's contents  *  * @param text the expression to be evaluated  * @param headerName the name of the header to apply the expression to  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a href="http://camel.apache.org/xpath.html">XPath  * expression</a> on the supplied header name's contents  *  * @param text the expression to be evaluated  * @param headerName the name of the header to apply the expression to  * @return the builder to continue processing the DSL  */ public T xquery(String text, String headerName) {     return delegate.xquery(text, headerName). }
true;public;2;3;/**  * Evaluates an <a  * href="http://camel.apache.org/xquery.html">XQuery expression</a>  * with the specified result type  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a  * href="http://camel.apache.org/xquery.html">XQuery expression</a>  * with the specified result type  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @return the builder to continue processing the DSL  */ public T xquery(String text, Class<?> resultType) {     return delegate.xquery(text, resultType). }
true;public;3;3;/**  * Evaluates an <a  * href="http://camel.apache.org/xquery.html">XQuery expression</a>  * with the specified result type  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @param headerName the name of the header to apply the expression to  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a  * href="http://camel.apache.org/xquery.html">XQuery expression</a>  * with the specified result type  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @param headerName the name of the header to apply the expression to  * @return the builder to continue processing the DSL  */ public T xquery(String text, Class<?> resultType, String headerName) {     return delegate.xquery(text, resultType, headerName). }
true;public;3;3;/**  * Evaluates an <a  * href="http://camel.apache.org/xquery.html">XQuery expression</a>  * with the specified result type and set of namespace prefixes and URIs  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @param namespaces the namespace prefix and URIs to use  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a  * href="http://camel.apache.org/xquery.html">XQuery expression</a>  * with the specified result type and set of namespace prefixes and URIs  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @param namespaces the namespace prefix and URIs to use  * @return the builder to continue processing the DSL  */ public T xquery(String text, Class<?> resultType, Namespaces namespaces) {     return delegate.xquery(text, resultType, namespaces). }
true;public;4;3;/**  * Evaluates an <a  * href="http://camel.apache.org/xquery.html">XQuery expression</a>  * with the specified result type  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @param headerName the name of the header to apply the expression to  * @param namespaces the namespace prefix and URIs to use  *  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a  * href="http://camel.apache.org/xquery.html">XQuery expression</a>  * with the specified result type  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @param headerName the name of the header to apply the expression to  * @param namespaces the namespace prefix and URIs to use  *  * @return the builder to continue processing the DSL  */ public T xquery(String text, Class<?> resultType, Namespaces namespaces, String headerName) {     return delegate.xquery(text, resultType, namespaces, headerName). }
true;public;3;3;/**  * Evaluates an <a  * href="http://camel.apache.org/xquery.html">XQuery expression</a>  * with the specified result type and set of namespace prefixes and URIs  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @param namespaces the namespace prefix and URIs to use  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a  * href="http://camel.apache.org/xquery.html">XQuery expression</a>  * with the specified result type and set of namespace prefixes and URIs  *  * @param text the expression to be evaluated  * @param resultType the return type expected by the expression  * @param namespaces the namespace prefix and URIs to use  * @return the builder to continue processing the DSL  */ public T xquery(String text, Class<?> resultType, Map<String, String> namespaces) {     return delegate.xquery(text, resultType, namespaces). }
true;public;2;3;/**  * Evaluates an <a  * href="http://camel.apache.org/xquery.html">XQuery expression</a>  * with the specified set of namespace prefixes and URIs  *  * @param text the expression to be evaluated  * @param namespaces the namespace prefix and URIs to use  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a  * href="http://camel.apache.org/xquery.html">XQuery expression</a>  * with the specified set of namespace prefixes and URIs  *  * @param text the expression to be evaluated  * @param namespaces the namespace prefix and URIs to use  * @return the builder to continue processing the DSL  */ public T xquery(String text, Namespaces namespaces) {     return delegate.xquery(text, namespaces). }
true;public;2;3;/**  * Evaluates an <a  * href="http://camel.apache.org/xquery.html">XQuery expression</a>  * with the specified set of namespace prefixes and URIs  *  * @param text the expression to be evaluated  * @param namespaces the namespace prefix and URIs to use  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates an <a  * href="http://camel.apache.org/xquery.html">XQuery expression</a>  * with the specified set of namespace prefixes and URIs  *  * @param text the expression to be evaluated  * @param namespaces the namespace prefix and URIs to use  * @return the builder to continue processing the DSL  */ public T xquery(String text, Map<String, String> namespaces) {     return delegate.xquery(text, namespaces). }
true;public;2;3;/**  * Evaluates a given language name with the expression text  *  * @param language the name of the language  * @param expression the expression in the given language  * @return the builder to continue processing the DSL  */ ;/**  * Evaluates a given language name with the expression text  *  * @param language the name of the language  * @param expression the expression in the given language  * @return the builder to continue processing the DSL  */ public T language(String language, String expression) {     return delegate.language(language, expression). }
false;public;0;4;;// Properties // ------------------------------------------------------------------------- @Override public Expression getExpressionValue() {     return delegate.getExpressionValue(). }
false;protected;1;4;;@Override protected void setExpressionValue(Expression expressionValue) {     delegate.setExpressionValue(expressionValue). }
false;public;0;4;;@Override public ExpressionDefinition getExpressionType() {     return delegate.getExpressionType(). }
false;protected;1;4;;@Override protected void setExpressionType(ExpressionDefinition expressionType) {     delegate.setExpressionType(expressionType). }
