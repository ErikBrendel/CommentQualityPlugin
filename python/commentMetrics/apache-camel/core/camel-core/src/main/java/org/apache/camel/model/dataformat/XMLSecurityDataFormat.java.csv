commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;53;;@Override protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {     if (getSecureTag() != null) {         setProperty(camelContext, dataFormat, "secureTag", getSecureTag()).     } else {         setProperty(camelContext, dataFormat, "secureTag", "").     }     boolean isSecureTagContents = getSecureTagContents() != null && getSecureTagContents().     setProperty(camelContext, dataFormat, "secureTagContents", isSecureTagContents).     if (passPhrase != null || passPhraseByte != null) {         if (passPhraseByte != null) {             setProperty(camelContext, dataFormat, "passPhrase", passPhraseByte).         } else {             setProperty(camelContext, dataFormat, "passPhrase", passPhrase.getBytes()).         }     } else {         setProperty(camelContext, dataFormat, "passPhrase", "Just another 24 Byte key".getBytes()).     }     if (getXmlCipherAlgorithm() != null) {         setProperty(camelContext, dataFormat, "xmlCipherAlgorithm", getXmlCipherAlgorithm()).     } else {         setProperty(camelContext, dataFormat, "xmlCipherAlgorithm", TRIPLEDES).     }     if (getKeyCipherAlgorithm() != null) {         setProperty(camelContext, dataFormat, "keyCipherAlgorithm", getKeyCipherAlgorithm()).     }     if (getRecipientKeyAlias() != null) {         setProperty(camelContext, dataFormat, "recipientKeyAlias", getRecipientKeyAlias()).     }     if (getKeyOrTrustStoreParametersRef() != null) {         setProperty(camelContext, dataFormat, "keyOrTrustStoreParametersRef", getKeyOrTrustStoreParametersRef()).     }     if (keyOrTrustStoreParameters != null) {         setProperty(camelContext, dataFormat, "keyOrTrustStoreParameters", this.keyOrTrustStoreParameters).     }     if (namespaces != null) {         setProperty(camelContext, dataFormat, "namespaces", this.namespaces).     }     if (keyPassword != null) {         setProperty(camelContext, dataFormat, "keyPassword", this.getKeyPassword()).     }     if (digestAlgorithm != null) {         setProperty(camelContext, dataFormat, "digestAlgorithm", this.getDigestAlgorithm()).     }     if (mgfAlgorithm != null) {         setProperty(camelContext, dataFormat, "mgfAlgorithm", this.getMgfAlgorithm()).     }     // should be true by default     boolean isAddKeyValueForEncryptedKey = getAddKeyValueForEncryptedKey() == null || getAddKeyValueForEncryptedKey().     setProperty(camelContext, dataFormat, "addKeyValueForEncryptedKey", isAddKeyValueForEncryptedKey). }
false;public;0;3;;public String getXmlCipherAlgorithm() {     return xmlCipherAlgorithm. }
true;public;1;3;/**  * The cipher algorithm to be used for encryption/decryption of the XML message content. The available choices are:  * <ul>  *     <li>XMLCipher.TRIPLEDES</li>  *     <li>XMLCipher.AES_128</li>  *     <li>XMLCipher.AES_128_GCM</li>  *     <li>XMLCipher.AES_192</li>  *     <li>XMLCipher.AES_192_GCM</li>  *     <li>XMLCipher.AES_256</li>  *     <li>XMLCipher.AES_256_GCM</li>  *     <li>XMLCipher.SEED_128</li>  *     <li>XMLCipher.CAMELLIA_128</li>  *     <li>XMLCipher.CAMELLIA_192</li>  *     <li>XMLCipher.CAMELLIA_256</li>  * </ul>  * The default value is MLCipher.TRIPLEDES  */ ;/**  * The cipher algorithm to be used for encryption/decryption of the XML message content. The available choices are:  * <ul>  *     <li>XMLCipher.TRIPLEDES</li>  *     <li>XMLCipher.AES_128</li>  *     <li>XMLCipher.AES_128_GCM</li>  *     <li>XMLCipher.AES_192</li>  *     <li>XMLCipher.AES_192_GCM</li>  *     <li>XMLCipher.AES_256</li>  *     <li>XMLCipher.AES_256_GCM</li>  *     <li>XMLCipher.SEED_128</li>  *     <li>XMLCipher.CAMELLIA_128</li>  *     <li>XMLCipher.CAMELLIA_192</li>  *     <li>XMLCipher.CAMELLIA_256</li>  * </ul>  * The default value is MLCipher.TRIPLEDES  */ public void setXmlCipherAlgorithm(String xmlCipherAlgorithm) {     this.xmlCipherAlgorithm = xmlCipherAlgorithm. }
false;public;0;3;;public String getPassPhrase() {     return passPhrase. }
true;public;1;3;/**  * A String used as passPhrase to encrypt/decrypt content. The passPhrase has to be provided.  * If no passPhrase is specified, a default passPhrase is used.  * The passPhrase needs to be put together in conjunction with the appropriate encryption algorithm.  * For example using TRIPLEDES the passPhase can be a "Only another 24 Byte key"  */ ;/**  * A String used as passPhrase to encrypt/decrypt content. The passPhrase has to be provided.  * If no passPhrase is specified, a default passPhrase is used.  * The passPhrase needs to be put together in conjunction with the appropriate encryption algorithm.  * For example using TRIPLEDES the passPhase can be a "Only another 24 Byte key"  */ public void setPassPhrase(String passPhrase) {     this.passPhrase = passPhrase. }
false;public;0;3;;public byte[] getPassPhraseByte() {     return passPhraseByte. }
true;public;1;3;/**  * A byte[] used as passPhrase to encrypt/decrypt content. The passPhrase has to be provided.  * If no passPhrase is specified, a default passPhrase is used.  * The passPhrase needs to be put together in conjunction with the appropriate encryption algorithm.  * For example using TRIPLEDES the passPhase can be a "Only another 24 Byte key"  */ ;/**  * A byte[] used as passPhrase to encrypt/decrypt content. The passPhrase has to be provided.  * If no passPhrase is specified, a default passPhrase is used.  * The passPhrase needs to be put together in conjunction with the appropriate encryption algorithm.  * For example using TRIPLEDES the passPhase can be a "Only another 24 Byte key"  */ public void setPassPhraseByte(byte[] passPhraseByte) {     this.passPhraseByte = passPhraseByte. }
false;public;0;3;;public String getSecureTag() {     return secureTag. }
true;public;1;3;/**  * The XPath reference to the XML Element selected for encryption/decryption. If no tag is specified, the entire payload is encrypted/decrypted.  */ ;/**  * The XPath reference to the XML Element selected for encryption/decryption. If no tag is specified, the entire payload is encrypted/decrypted.  */ public void setSecureTag(String secureTag) {     this.secureTag = secureTag. }
false;public;0;3;;public Boolean getSecureTagContents() {     return secureTagContents. }
true;public;1;3;/**  * A boolean value to specify whether the XML Element is to be encrypted or the contents of the XML Element  * false = Element Level  * true = Element Content Level  */ ;/**  * A boolean value to specify whether the XML Element is to be encrypted or the contents of the XML Element  * false = Element Level  * true = Element Content Level  */ public void setSecureTagContents(Boolean secureTagContents) {     this.secureTagContents = secureTagContents. }
true;public;1;3;/**  * The cipher algorithm to be used for encryption/decryption of the asymmetric key. The available choices are:  * <ul>  *     <li>XMLCipher.RSA_v1dot5</li>  *     <li>XMLCipher.RSA_OAEP</li>  *     <li>XMLCipher.RSA_OAEP_11</li>  * </ul>  * The default value is XMLCipher.RSA_OAEP  */ ;/**  * The cipher algorithm to be used for encryption/decryption of the asymmetric key. The available choices are:  * <ul>  *     <li>XMLCipher.RSA_v1dot5</li>  *     <li>XMLCipher.RSA_OAEP</li>  *     <li>XMLCipher.RSA_OAEP_11</li>  * </ul>  * The default value is XMLCipher.RSA_OAEP  */ public void setKeyCipherAlgorithm(String keyCipherAlgorithm) {     this.keyCipherAlgorithm = keyCipherAlgorithm. }
false;public;0;3;;public String getKeyCipherAlgorithm() {     return keyCipherAlgorithm. }
true;public;1;3;/**  * The key alias to be used when retrieving the recipient's public or private key from a KeyStore when performing asymmetric key encryption or decryption.  */ ;/**  * The key alias to be used when retrieving the recipient's public or private key from a KeyStore when performing asymmetric key encryption or decryption.  */ public void setRecipientKeyAlias(String recipientKeyAlias) {     this.recipientKeyAlias = recipientKeyAlias. }
false;public;0;3;;public String getRecipientKeyAlias() {     return recipientKeyAlias. }
true;public;1;3;/**  * Refers to a KeyStore instance to lookup in the registry, which is used for  * configuration options for creating and loading a KeyStore instance that represents the sender's trustStore or recipient's keyStore.  */ ;/**  * Refers to a KeyStore instance to lookup in the registry, which is used for  * configuration options for creating and loading a KeyStore instance that represents the sender's trustStore or recipient's keyStore.  */ public void setKeyOrTrustStoreParametersRef(String id) {     this.keyOrTrustStoreParametersRef = id. }
false;public;0;3;;public String getKeyOrTrustStoreParametersRef() {     return this.keyOrTrustStoreParametersRef. }
false;public;0;3;;public KeyStoreParameters getKeyOrTrustStoreParameters() {     return keyOrTrustStoreParameters. }
true;public;1;3;/**  * Configuration options for creating and loading a KeyStore instance that represents the sender's trustStore or recipient's keyStore.  */ ;/**  * Configuration options for creating and loading a KeyStore instance that represents the sender's trustStore or recipient's keyStore.  */ public void setKeyOrTrustStoreParameters(KeyStoreParameters keyOrTrustStoreParameters) {     this.keyOrTrustStoreParameters = keyOrTrustStoreParameters. }
false;public;0;3;;public String getKeyPassword() {     return this.keyPassword. }
true;public;1;3;/**  * The password to be used for retrieving the private key from the KeyStore. This key is used for asymmetric decryption.  */ ;/**  * The password to be used for retrieving the private key from the KeyStore. This key is used for asymmetric decryption.  */ public void setKeyPassword(String keyPassword) {     this.keyPassword = keyPassword. }
false;public;0;3;;public String getDigestAlgorithm() {     return digestAlgorithm. }
true;public;1;3;/**  * The digest algorithm to use with the RSA OAEP algorithm. The available choices are:  * <ul>  *     <li>XMLCipher.SHA1</li>  *     <li>XMLCipher.SHA256</li>  *     <li>XMLCipher.SHA512</li>  * </ul>  * The default value is XMLCipher.SHA1  */ ;/**  * The digest algorithm to use with the RSA OAEP algorithm. The available choices are:  * <ul>  *     <li>XMLCipher.SHA1</li>  *     <li>XMLCipher.SHA256</li>  *     <li>XMLCipher.SHA512</li>  * </ul>  * The default value is XMLCipher.SHA1  */ public void setDigestAlgorithm(String digestAlgorithm) {     this.digestAlgorithm = digestAlgorithm. }
false;public;0;3;;public String getMgfAlgorithm() {     return mgfAlgorithm. }
true;public;1;3;/**  * The MGF Algorithm to use with the RSA OAEP algorithm. The available choices are:  * <ul>  *     <li>EncryptionConstants.MGF1_SHA1</li>  *     <li>EncryptionConstants.MGF1_SHA256</li>  *     <li>EncryptionConstants.MGF1_SHA512</li>  * </ul>  * The default value is EncryptionConstants.MGF1_SHA1  */ ;/**  * The MGF Algorithm to use with the RSA OAEP algorithm. The available choices are:  * <ul>  *     <li>EncryptionConstants.MGF1_SHA1</li>  *     <li>EncryptionConstants.MGF1_SHA256</li>  *     <li>EncryptionConstants.MGF1_SHA512</li>  * </ul>  * The default value is EncryptionConstants.MGF1_SHA1  */ public void setMgfAlgorithm(String mgfAlgorithm) {     this.mgfAlgorithm = mgfAlgorithm. }
false;public;0;3;;public Boolean getAddKeyValueForEncryptedKey() {     return addKeyValueForEncryptedKey. }
true;public;1;3;/**  * Whether to add the public key used to encrypt the session key as a KeyValue in the EncryptedKey structure or not.  */ ;/**  * Whether to add the public key used to encrypt the session key as a KeyValue in the EncryptedKey structure or not.  */ public void setAddKeyValueForEncryptedKey(Boolean addKeyValueForEncryptedKey) {     this.addKeyValueForEncryptedKey = addKeyValueForEncryptedKey. }
false;public;1;7;;@Override public void setNamespaces(Map<String, String> nspaces) {     if (this.namespaces == null) {         this.namespaces = new HashMap<>().     }     this.namespaces.putAll(nspaces). }
false;public;0;4;;@Override public Map<String, String> getNamespaces() {     return namespaces. }
