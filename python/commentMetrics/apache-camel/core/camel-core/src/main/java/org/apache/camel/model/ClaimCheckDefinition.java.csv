commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Override public String toString() {     if (operation != null) {         return "ClaimCheck[" + operation + "]".     } else {         return "ClaimCheck".     } }
false;public;0;4;;@Override public String getShortName() {     return "claimCheck". }
false;public;0;4;;@Override public String getLabel() {     return "claimCheck". }
true;public;1;4;/**  * The claim check operation to use.  * The following operations is supported:  * <ul>  *     <li>Get</li> - Gets (does not remove) the claim check by the given key.  *     <li>GetAndRemove</li> - Gets and remove the claim check by the given key.  *     <li>Set</li> - Sets a new (will override if key already exists) claim check with the given key.  *     <li>Push</li> - Sets a new claim check on the stack (does not use key).  *     <li>Pop</li> - Gets the latest claim check from the stack (does not use key).  * </ul>  */ ;// Fluent API // ------------------------------------------------------------------------- /**  * The claim check operation to use.  * The following operations is supported:  * <ul>  *     <li>Get</li> - Gets (does not remove) the claim check by the given key.  *     <li>GetAndRemove</li> - Gets and remove the claim check by the given key.  *     <li>Set</li> - Sets a new (will override if key already exists) claim check with the given key.  *     <li>Push</li> - Sets a new claim check on the stack (does not use key).  *     <li>Pop</li> - Gets the latest claim check from the stack (does not use key).  * </ul>  */ public ClaimCheckDefinition operation(ClaimCheckOperation operation) {     setOperation(operation).     return this. }
true;public;1;4;/**  * To use a specific key for claim check id.  */ ;/**  * To use a specific key for claim check id.  */ public ClaimCheckDefinition key(String key) {     setKey(key).     return this. }
true;public;1;4;/**  * Specified a filter to control what data gets merging data back from the claim check repository.  *  * The following syntax is supported:  * <ul>  *     <li>body</li> - to aggregate the message body  *     <li>attachments</li> - to aggregate all the message attachments  *     <li>headers</li> - to aggregate all the message headers  *     <li>header:pattern</li> - to aggregate all the message headers that matches the pattern.  * </ul>  * The pattern uses the following rules are applied in this order:  * <ul>  * <li>exact match, returns true</li>  * <li>wildcard match (pattern ends with a * and the name starts with the pattern), returns true</li>  * <li>regular expression match, returns true</li>  * <li>otherwise returns false</li>  * </ul>  * <p>  * You can specify multiple rules separated by comma. For example to include the message body and all headers starting with foo  * <tt>body,header:foo*</tt>.  * The syntax supports the following prefixes which can be used to specify include,exclude, or remove  * <ul>  *     <li>+</li> - to include (which is the default mode)  *     <li>-</li> - to exclude (exclude takes precedence over include)  *     <li>--</li> - to remove (remove takes precedence)  * </ul>  * For example to exclude a header name foo, and remove all headers starting with bar  * <tt>-header:foo,--headers:bar*</tt>  * Note you cannot have both include and exclude <tt>header:pattern</tt> at the same time.  */ ;/**  * Specified a filter to control what data gets merging data back from the claim check repository.  *  * The following syntax is supported:  * <ul>  *     <li>body</li> - to aggregate the message body  *     <li>attachments</li> - to aggregate all the message attachments  *     <li>headers</li> - to aggregate all the message headers  *     <li>header:pattern</li> - to aggregate all the message headers that matches the pattern.  * </ul>  * The pattern uses the following rules are applied in this order:  * <ul>  * <li>exact match, returns true</li>  * <li>wildcard match (pattern ends with a * and the name starts with the pattern), returns true</li>  * <li>regular expression match, returns true</li>  * <li>otherwise returns false</li>  * </ul>  * <p>  * You can specify multiple rules separated by comma. For example to include the message body and all headers starting with foo  * <tt>body,header:foo*</tt>.  * The syntax supports the following prefixes which can be used to specify include,exclude, or remove  * <ul>  *     <li>+</li> - to include (which is the default mode)  *     <li>-</li> - to exclude (exclude takes precedence over include)  *     <li>--</li> - to remove (remove takes precedence)  * </ul>  * For example to exclude a header name foo, and remove all headers starting with bar  * <tt>-header:foo,--headers:bar*</tt>  * Note you cannot have both include and exclude <tt>header:pattern</tt> at the same time.  */ public ClaimCheckDefinition filter(String filter) {     setFilter(filter).     return this. }
true;public;1;4;/**  * To use a custom {@link AggregationStrategy} instead of the default implementation.  * Notice you cannot use both custom aggregation strategy and configure data at the same time.  */ ;/**  * To use a custom {@link AggregationStrategy} instead of the default implementation.  * Notice you cannot use both custom aggregation strategy and configure data at the same time.  */ public ClaimCheckDefinition aggregationStrategy(AggregationStrategy aggregationStrategy) {     setAggregationStrategy(aggregationStrategy).     return this. }
true;public;1;4;/**  * To use a custom {@link AggregationStrategy} instead of the default implementation.  * Notice you cannot use both custom aggregation strategy and configure data at the same time.  */ ;/**  * To use a custom {@link AggregationStrategy} instead of the default implementation.  * Notice you cannot use both custom aggregation strategy and configure data at the same time.  */ public ClaimCheckDefinition aggregationStrategyRef(String aggregationStrategyRef) {     setAggregationStrategyRef(aggregationStrategyRef).     return this. }
true;public;1;4;/**  * This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.  */ ;/**  * This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.  */ public ClaimCheckDefinition aggregationStrategyMethodName(String aggregationStrategyMethodName) {     setAggregationStrategyMethodName(aggregationStrategyMethodName).     return this. }
false;public;0;3;;// Properties // ------------------------------------------------------------------------- public String getKey() {     return key. }
false;public;1;3;;public void setKey(String key) {     this.key = key. }
false;public;0;3;;public ClaimCheckOperation getOperation() {     return operation. }
false;public;1;3;;public void setOperation(ClaimCheckOperation operation) {     this.operation = operation. }
false;public;0;3;;public String getFilter() {     return filter. }
false;public;1;3;;public void setFilter(String filter) {     this.filter = filter. }
false;public;0;3;;public String getAggregationStrategyRef() {     return aggregationStrategyRef. }
false;public;1;3;;public void setAggregationStrategyRef(String aggregationStrategyRef) {     this.aggregationStrategyRef = aggregationStrategyRef. }
false;public;0;3;;public String getAggregationStrategyMethodName() {     return aggregationStrategyMethodName. }
false;public;1;3;;public void setAggregationStrategyMethodName(String aggregationStrategyMethodName) {     this.aggregationStrategyMethodName = aggregationStrategyMethodName. }
false;public;0;3;;public AggregationStrategy getAggregationStrategy() {     return aggregationStrategy. }
false;public;1;3;;public void setAggregationStrategy(AggregationStrategy aggregationStrategy) {     this.aggregationStrategy = aggregationStrategy. }
