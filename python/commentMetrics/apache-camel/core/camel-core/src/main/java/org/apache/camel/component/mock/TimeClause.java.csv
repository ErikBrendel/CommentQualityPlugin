commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;public TimeClause millis() {     period(TimeUnit.MILLISECONDS).     return clause. }
false;public;0;4;;public TimeClause seconds() {     period(TimeUnit.SECONDS).     return clause. }
false;public;0;4;;public TimeClause minutes() {     period(TimeUnit.MINUTES).     return clause. }
false;private;1;6;;private void period(TimeUnit unit) {     if (from > 0) {         timeFrom = new Time(from, unit).     }     timeTo = new Time(to, unit). }
false;public;1;4;;// DSL // ------------------------------------------------------------------------- public TimeClassUnit noLaterThan(int period) {     TimeClassUnit unit = new TimeClassUnit(this, period).     return unit. }
false;public;2;4;;public TimeClassUnit between(int from, int to) {     TimeClassUnit unit = new TimeClassUnit(this, from, to).     return unit. }
false;public;0;3;;public void beforeNext() {     this.beforeNext = true. }
false;public;0;3;;public void afterPrevious() {     this.beforeNext = false. }
false;public;0;4;;// Implementation // ------------------------------------------------------------------------- @Override public Expression getLeft() {     return left. }
false;public;0;4;;@Override public Expression getRight() {     return right. }
false;public;1;4;;@Override public boolean matches(Exchange exchange) {     return matchesReturningFailureMessage(exchange) == null. }
false;public;1;16;;@Override public String matchesReturningFailureMessage(Exchange exchange) {     // we must not store any state, so we can be thread safe     // and thus we offer this method which returns a failure message if     // we did not match     String answer = null.     // must be thread safe and store result in local objects     Object leftValue = left.evaluate(exchange, Object.class).     Object rightValue = right.evaluate(exchange, Object.class).     if (!matches(exchange, leftValue, rightValue)) {         answer = leftValue + " " + getOperator() + " " + rightValue.     }     return answer. }
false;protected;3;57;;protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {     was = null.     boolean answer = true.     if (timeTo == null) {         throw new IllegalArgumentException("The time period has not been set. Ensure to include the time unit as well.").     }     Date currentDate = exchange.getProperty(Exchange.RECEIVED_TIMESTAMP, Date.class).     // the other date is either the previous or the next     Date otherDate.     if (beforeNext) {         // grab the previous value (left)         if (leftValue != null) {             otherDate = (Date) leftValue.         } else {             // we hit a boundary so grab the other             otherDate = (Date) rightValue.         }     } else {         // grab the next value (right)         if (rightValue != null) {             otherDate = (Date) rightValue.         } else {             // we hit a boundary so grab the other             otherDate = (Date) leftValue.         }     }     // if we could not grab the value, we hit a boundary (ie. either 0 message or last message)     if (otherDate == null) {         return true.     }     // compute if we were within the allowed time range     Time current = new Time(currentDate.getTime(), TimeUnit.MILLISECONDS).     Time other = new Time(otherDate.getTime(), TimeUnit.MILLISECONDS).     // must absolute delta as when we hit the boundaries the delta would negative     long delta = Math.abs(other.toMillis() - current.toMillis()).     was = "delta: " + delta + " millis".     if (timeFrom != null) {         long from = timeFrom.toMillis().         answer = delta >= from.     }     if (answer) {         long to = timeTo.toMillis().         answer = delta <= to.     }     if (LOG.isDebugEnabled()) {         LOG.debug("Evaluated time clause [{}] with current: {}, other: {} -> {}", toString(), currentDate, otherDate, answer).     }     return answer. }
false;public;0;4;;@Override public String getOperator() {     return getOperationText(). }
false;protected;0;3;;protected String getOperationText() {     return beforeNext ? "before next" : "after previous". }
false;public;0;9;;@Override public String toString() {     if (timeFrom == null) {         return "no later than " + timeTo + " " + getOperationText() + " (" + was + ")".     } else {         return "between " + timeFrom.getNumber() + "-" + timeTo.getNumber() + " " + timeTo.getTimeUnit().toString().toLowerCase(Locale.ENGLISH) + " " + getOperationText() + " (" + was + ")".     } }
