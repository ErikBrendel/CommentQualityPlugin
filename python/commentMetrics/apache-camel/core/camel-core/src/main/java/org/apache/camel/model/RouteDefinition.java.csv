commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * This route is created from the REST DSL.  */ ;/**  * This route is created from the REST DSL.  */ public void fromRest(@AsEndpointUri String uri) {     from(uri).     rest = true. }
true;public;1;5;/**  * Prepares the route definition to be ready to be added to {@link CamelContext}  *  * @param context the camel context  */ ;/**  * Prepares the route definition to be ready to be added to {@link CamelContext}  *  * @param context the camel context  */ public void prepare(ModelCamelContext context) {     if (prepared.compareAndSet(false, true)) {         RouteDefinitionHelper.prepareRoute(context, this).     } }
true;public;0;3;/**  * Marks the route definition as prepared.  * <p/>  * This is needed if routes have been created by components such as  * <tt>camel-spring</tt> or <tt>camel-blueprint</tt>.  * Usually they share logic in the <tt>camel-core-xml</tt> module which prepares the routes.  */ ;/**  * Marks the route definition as prepared.  * <p/>  * This is needed if routes have been created by components such as  * <tt>camel-spring</tt> or <tt>camel-blueprint</tt>.  * Usually they share logic in the <tt>camel-core-xml</tt> module which prepares the routes.  */ public void markPrepared() {     prepared.set(true). }
true;public;0;3;/**  * Marks the route definition as un-prepared.  * <p/>  * This is needed if routes have been created by components such as  * <tt>camel-scala</tt>. To unset the prepare so the routes can be prepared  * at a later stage when scala has build the routes completely.  */ ;/**  * Marks the route definition as un-prepared.  * <p/>  * This is needed if routes have been created by components such as  * <tt>camel-scala</tt>. To unset the prepare so the routes can be prepared  * at a later stage when scala has build the routes completely.  */ public void markUnprepared() {     prepared.set(false). }
false;public;0;8;;@Override public String toString() {     if (getId() != null) {         return "Route(" + getId() + ")[" + inputs + " -> " + outputs + "]".     } else {         return "Route[" + inputs + " -> " + outputs + "]".     } }
false;public;0;4;;@Override public String getShortName() {     return "route". }
true;public;1;11;/**  * Returns the status of the route if it has been registered with a {@link CamelContext}  */ ;/**  * Returns the status of the route if it has been registered with a {@link CamelContext}  */ @Deprecated public ServiceStatus getStatus(CamelContext camelContext) {     if (camelContext != null) {         ServiceStatus answer = camelContext.getRouteController().getRouteStatus(this.getId()).         if (answer == null) {             answer = ServiceStatus.Stopped.         }         return answer.     }     return null. }
false;public;1;9;;@Deprecated public boolean isStartable(CamelContext camelContext) {     ServiceStatus status = getStatus(camelContext).     if (status == null) {         return true.     } else {         return status.isStartable().     } }
false;public;1;9;;@Deprecated public boolean isStoppable(CamelContext camelContext) {     ServiceStatus status = getStatus(camelContext).     if (status == null) {         return false.     } else {         return status.isStoppable().     } }
true;public;1;4;/**  * Creates an input to the route  *  * @param uri the from uri  * @return the builder  */ ;// Fluent API // ----------------------------------------------------------------------- /**  * Creates an input to the route  *  * @param uri the from uri  * @return the builder  */ public RouteDefinition from(@AsEndpointUri String uri) {     getInputs().add(new FromDefinition(uri)).     return this. }
true;public;1;4;/**  * Creates an input to the route  *  * @param endpoint the from endpoint  * @return the builder  */ ;/**  * Creates an input to the route  *  * @param endpoint the from endpoint  * @return the builder  */ public RouteDefinition from(Endpoint endpoint) {     getInputs().add(new FromDefinition(endpoint)).     return this. }
true;public;1;6;/**  * Creates inputs to the route  *  * @param uris the from uris  * @return the builder  */ ;/**  * Creates inputs to the route  *  * @param uris the from uris  * @return the builder  */ public RouteDefinition from(@AsEndpointUri String... uris) {     for (String uri : uris) {         getInputs().add(new FromDefinition(uri)).     }     return this. }
true;public;1;6;/**  * Creates inputs to the route  *  * @param endpoints the from endpoints  * @return the builder  */ ;/**  * Creates inputs to the route  *  * @param endpoints the from endpoints  * @return the builder  */ public RouteDefinition from(Endpoint... endpoints) {     for (Endpoint endpoint : endpoints) {         getInputs().add(new FromDefinition(endpoint)).     }     return this. }
true;public;1;4;/**  * Set the group name for this route  *  * @param name the group name  * @return the builder  */ ;/**  * Set the group name for this route  *  * @param name the group name  * @return the builder  */ public RouteDefinition group(String name) {     setGroup(name).     return this. }
true;public;1;4;/**  * Set the route group for this route  *  * @param group the route group  * @return the builder  */ ;/**  * Set the route group for this route  *  * @param group the route group  * @return the builder  */ public RouteDefinition routeGroup(String group) {     setGroup(group).     return this. }
true;public;1;4;/**  * Set the route id for this route  *  * @param id the route id  * @return the builder  */ ;/**  * Set the route id for this route  *  * @param id the route id  * @return the builder  */ public RouteDefinition routeId(String id) {     setId(id).     return this. }
true;public;1;6;/**  * Set the route description for this route  *  * @param description the route description  * @return the builder  */ ;/**  * Set the route description for this route  *  * @param description the route description  * @return the builder  */ public RouteDefinition routeDescription(String description) {     DescriptionDefinition desc = new DescriptionDefinition().     desc.setText(description).     setDescription(desc).     return this. }
true;public;0;4;/**  * Disable stream caching for this route.  *  * @return the builder  */ ;/**  * Disable stream caching for this route.  *  * @return the builder  */ public RouteDefinition noStreamCaching() {     setStreamCache("false").     return this. }
true;public;0;4;/**  * Enable stream caching for this route.  *  * @return the builder  */ ;/**  * Enable stream caching for this route.  *  * @return the builder  */ public RouteDefinition streamCaching() {     setStreamCache("true").     return this. }
true;public;1;4;/**  * Enable stream caching for this route.  *  * @param streamCache whether to use stream caching (true or false), the value can be a property placeholder  * @return the builder  */ ;/**  * Enable stream caching for this route.  *  * @param streamCache whether to use stream caching (true or false), the value can be a property placeholder  * @return the builder  */ public RouteDefinition streamCaching(String streamCache) {     setStreamCache(streamCache).     return this. }
true;public;0;4;/**  * Disable tracing for this route.  *  * @return the builder  */ ;/**  * Disable tracing for this route.  *  * @return the builder  */ public RouteDefinition noTracing() {     setTrace("false").     return this. }
true;public;0;4;/**  * Enable tracing for this route.  *  * @return the builder  */ ;/**  * Enable tracing for this route.  *  * @return the builder  */ public RouteDefinition tracing() {     setTrace("true").     return this. }
true;public;1;4;/**  * Enable tracing for this route.  *  * @param tracing whether to use tracing (true or false), the value can be a property placeholder  * @return the builder  */ ;/**  * Enable tracing for this route.  *  * @param tracing whether to use tracing (true or false), the value can be a property placeholder  * @return the builder  */ public RouteDefinition tracing(String tracing) {     setTrace(tracing).     return this. }
true;public;0;4;/**  * Enable message history for this route.  *  * @return the builder  */ ;/**  * Enable message history for this route.  *  * @return the builder  */ public RouteDefinition messageHistory() {     setMessageHistory("true").     return this. }
true;public;1;4;/**  * Enable message history for this route.  *  * @param messageHistory whether to use message history (true or false), the value can be a property placeholder  * @return the builder  */ ;/**  * Enable message history for this route.  *  * @param messageHistory whether to use message history (true or false), the value can be a property placeholder  * @return the builder  */ public RouteDefinition messageHistory(String messageHistory) {     setMessageHistory(messageHistory).     return this. }
true;public;0;4;/**  * Enable security mask for Logging on this route.  *  * @return the builder  */ ;/**  * Enable security mask for Logging on this route.  *  * @return the builder  */ public RouteDefinition logMask() {     setLogMask("true").     return this. }
true;public;1;4;/**  * Sets whether security mask for logging is enabled on this route.  *  * @param logMask whether to enable security mask for Logging (true or false), the value can be a property placeholder  * @return the builder  */ ;/**  * Sets whether security mask for logging is enabled on this route.  *  * @param logMask whether to enable security mask for Logging (true or false), the value can be a property placeholder  * @return the builder  */ public RouteDefinition logMask(String logMask) {     setLogMask(logMask).     return this. }
true;public;0;4;/**  * Disable message history for this route.  *  * @return the builder  */ ;/**  * Disable message history for this route.  *  * @return the builder  */ public RouteDefinition noMessageHistory() {     setMessageHistory("false").     return this. }
true;public;0;4;/**  * Disable handle fault for this route.  *  * @return the builder  */ ;/**  * Disable handle fault for this route.  *  * @return the builder  */ public RouteDefinition noHandleFault() {     setHandleFault("false").     return this. }
true;public;0;4;/**  * Enable handle fault for this route.  *  * @return the builder  */ ;/**  * Enable handle fault for this route.  *  * @return the builder  */ public RouteDefinition handleFault() {     setHandleFault("true").     return this. }
true;public;0;4;/**  * Disable delayer for this route.  *  * @return the builder  */ ;/**  * Disable delayer for this route.  *  * @return the builder  */ public RouteDefinition noDelayer() {     setDelayer("0").     return this. }
true;public;1;4;/**  * Enable delayer for this route.  *  * @param delay delay in millis  * @return the builder  */ ;/**  * Enable delayer for this route.  *  * @param delay delay in millis  * @return the builder  */ public RouteDefinition delayer(long delay) {     setDelayer("" + delay).     return this. }
true;public;1;6;/**  * Installs the given <a href="http://camel.apache.org/error-handler.html">error handler</a> builder.  *  * @param errorHandlerBuilder the error handler to be used by default for all child routes  * @return the current builder with the error handler configured  */ ;/**  * Installs the given <a href="http://camel.apache.org/error-handler.html">error handler</a> builder.  *  * @param errorHandlerBuilder the error handler to be used by default for all child routes  * @return the current builder with the error handler configured  */ public RouteDefinition errorHandler(ErrorHandlerFactory errorHandlerBuilder) {     setErrorHandlerBuilder(errorHandlerBuilder).     // we are now using a route scoped error handler     contextScopedErrorHandler = false.     return this. }
true;public;0;4;/**  * Disables this route from being auto started when Camel starts.  *  * @return the builder  */ ;/**  * Disables this route from being auto started when Camel starts.  *  * @return the builder  */ public RouteDefinition noAutoStartup() {     setAutoStartup("false").     return this. }
true;public;1;4;/**  * Sets the auto startup property on this route.  *  * @param autoStartup whether to auto startup (true or false), the value can be a property placeholder  * @return the builder  */ ;/**  * Sets the auto startup property on this route.  *  * @param autoStartup whether to auto startup (true or false), the value can be a property placeholder  * @return the builder  */ public RouteDefinition autoStartup(String autoStartup) {     setAutoStartup(autoStartup).     return this. }
true;public;1;4;/**  * Sets the auto startup property on this route.  *  * @param autoStartup - boolean indicator  * @return the builder  */ ;/**  * Sets the auto startup property on this route.  *  * @param autoStartup - boolean indicator  * @return the builder  */ public RouteDefinition autoStartup(boolean autoStartup) {     setAutoStartup(Boolean.toString(autoStartup)).     return this. }
true;public;1;4;/**  * Configures the startup order for this route  * <p/>  * Camel will reorder routes and star them ordered by 0..N where 0 is the lowest number and N the highest number.  * Camel will stop routes in reverse order when its stopping.  *  * @param order the order represented as a number  * @return the builder  */ ;/**  * Configures the startup order for this route  * <p/>  * Camel will reorder routes and star them ordered by 0..N where 0 is the lowest number and N the highest number.  * Camel will stop routes in reverse order when its stopping.  *  * @param order the order represented as a number  * @return the builder  */ public RouteDefinition startupOrder(int order) {     setStartupOrder(order).     return this. }
true;public;1;9;/**  * Configures route policies for this route  *  * @param policies the route policies  * @return the builder  */ ;/**  * Configures route policies for this route  *  * @param policies the route policies  * @return the builder  */ public RouteDefinition routePolicy(RoutePolicy... policies) {     if (routePolicies == null) {         routePolicies = new ArrayList<>().     }     for (RoutePolicy policy : policies) {         routePolicies.add(policy).     }     return this. }
true;public;1;4;/**  * Configures a route policy for this route  *  * @param routePolicyRef reference to a {@link RoutePolicy} to lookup and use.  *                       You can specify multiple references by separating using comma.  * @return the builder  */ ;/**  * Configures a route policy for this route  *  * @param routePolicyRef reference to a {@link RoutePolicy} to lookup and use.  *                       You can specify multiple references by separating using comma.  * @return the builder  */ public RouteDefinition routePolicyRef(String routePolicyRef) {     setRoutePolicyRef(routePolicyRef).     return this. }
true;public;1;4;/**  * Configures a shutdown route option.  *  * @param shutdownRoute the option to use when shutting down this route  * @return the builder  */ ;/**  * Configures a shutdown route option.  *  * @param shutdownRoute the option to use when shutting down this route  * @return the builder  */ public RouteDefinition shutdownRoute(ShutdownRoute shutdownRoute) {     setShutdownRoute(shutdownRoute).     return this. }
true;public;1;4;/**  * Configures a shutdown running task option.  *  * @param shutdownRunningTask the option to use when shutting down and how to act upon running tasks.  * @return the builder  */ ;/**  * Configures a shutdown running task option.  *  * @param shutdownRunningTask the option to use when shutting down and how to act upon running tasks.  * @return the builder  */ public RouteDefinition shutdownRunningTask(ShutdownRunningTask shutdownRunningTask) {     setShutdownRunningTask(shutdownRunningTask).     return this. }
true;public;1;6;/**  * Declare the expected data type of the input message. If the actual message type is different  * at runtime, camel look for a required {@link org.apache.camel.spi.Transformer} and apply if exists.  * The type name consists of two parts, 'scheme' and 'name' connected with ':'. For Java type 'name'  * is a fully qualified class name. For example {@code java:java.lang.String}, {@code json:ABCOrder}.  *  * @see org.apache.camel.spi.Transformer  *  * @param urn input type URN  * @return the builder  */ ;/**  * Declare the expected data type of the input message. If the actual message type is different  * at runtime, camel look for a required {@link org.apache.camel.spi.Transformer} and apply if exists.  * The type name consists of two parts, 'scheme' and 'name' connected with ':'. For Java type 'name'  * is a fully qualified class name. For example {@code java:java.lang.String}, {@code json:ABCOrder}.  *  * @see org.apache.camel.spi.Transformer  *  * @param urn input type URN  * @return the builder  */ public RouteDefinition inputType(String urn) {     inputType = new InputTypeDefinition().     inputType.setUrn(urn).     inputType.setValidate(false).     return this. }
true;public;1;6;/**  * Declare the expected data type of the input message with content validation enabled.  * If the actual message type is different at runtime, camel look for a required  * {@link org.apache.camel.spi.Transformer} and apply if exists, and then applies  * {@link org.apache.camel.spi.Validator} as well.  * The type name consists of two parts, 'scheme' and 'name' connected with ':'. For Java type 'name'  * is a fully qualified class name. For example {@code java:java.lang.String}, {@code json:ABCOrder}.  *  * @see org.apache.camel.spi.Transformer  * @see org.apache.camel.spi.Validator  *  * @param urn input type URN  * @return the builder  */ ;/**  * Declare the expected data type of the input message with content validation enabled.  * If the actual message type is different at runtime, camel look for a required  * {@link org.apache.camel.spi.Transformer} and apply if exists, and then applies  * {@link org.apache.camel.spi.Validator} as well.  * The type name consists of two parts, 'scheme' and 'name' connected with ':'. For Java type 'name'  * is a fully qualified class name. For example {@code java:java.lang.String}, {@code json:ABCOrder}.  *  * @see org.apache.camel.spi.Transformer  * @see org.apache.camel.spi.Validator  *  * @param urn input type URN  * @return the builder  */ public RouteDefinition inputTypeWithValidate(String urn) {     inputType = new InputTypeDefinition().     inputType.setUrn(urn).     inputType.setValidate(true).     return this. }
true;public;1;6;/**  * Declare the expected data type of the input message by Java class.  * If the actual message type is different at runtime, camel look for a required  * {@link org.apache.camel.spi.Transformer} and apply if exists.  *  * @see org.apache.camel.spi.Transformer  *  * @param clazz Class object of the input type  * @return the builder  */ ;/**  * Declare the expected data type of the input message by Java class.  * If the actual message type is different at runtime, camel look for a required  * {@link org.apache.camel.spi.Transformer} and apply if exists.  *  * @see org.apache.camel.spi.Transformer  *  * @param clazz Class object of the input type  * @return the builder  */ public RouteDefinition inputType(Class clazz) {     inputType = new InputTypeDefinition().     inputType.setJavaClass(clazz).     inputType.setValidate(false).     return this. }
true;public;1;6;/**  * Declare the expected data type of the input message by Java class with content validation enabled.  * If the actual message type is different at runtime, camel look for a required  * {@link org.apache.camel.spi.Transformer} and apply if exists, and then applies  * {@link org.apache.camel.spi.Validator} as well.  *  * @see org.apache.camel.spi.Transformer  * @see org.apache.camel.spi.Validator  *  * @param clazz Class object of the input type  * @return the builder  */ ;/**  * Declare the expected data type of the input message by Java class with content validation enabled.  * If the actual message type is different at runtime, camel look for a required  * {@link org.apache.camel.spi.Transformer} and apply if exists, and then applies  * {@link org.apache.camel.spi.Validator} as well.  *  * @see org.apache.camel.spi.Transformer  * @see org.apache.camel.spi.Validator  *  * @param clazz Class object of the input type  * @return the builder  */ public RouteDefinition inputTypeWithValidate(Class clazz) {     inputType = new InputTypeDefinition().     inputType.setJavaClass(clazz).     inputType.setValidate(true).     return this. }
true;public;1;6;/**  * Declare the expected data type of the output message. If the actual message type is different  * at runtime, camel look for a required {@link org.apache.camel.spi.Transformer} and apply if exists.  * The type name consists of two parts, 'scheme' and 'name' connected with ':'. For Java type 'name'  * is a fully qualified class name. For example {@code java:java.lang.String}, {@code json:ABCOrder}.  *  * @see org.apache.camel.spi.Transformer  *  * @param urn output type URN  * @return the builder  */ ;/**  * Declare the expected data type of the output message. If the actual message type is different  * at runtime, camel look for a required {@link org.apache.camel.spi.Transformer} and apply if exists.  * The type name consists of two parts, 'scheme' and 'name' connected with ':'. For Java type 'name'  * is a fully qualified class name. For example {@code java:java.lang.String}, {@code json:ABCOrder}.  *  * @see org.apache.camel.spi.Transformer  *  * @param urn output type URN  * @return the builder  */ public RouteDefinition outputType(String urn) {     outputType = new OutputTypeDefinition().     outputType.setUrn(urn).     outputType.setValidate(false).     return this. }
true;public;1;6;/**  * Declare the expected data type of the output message with content validation enabled.  * If the actual message type is different at runtime, Camel look for a required  * {@link org.apache.camel.spi.Transformer} and apply if exists, and then applies  * {@link org.apache.camel.spi.Validator} as well.  * The type name consists of two parts, 'scheme' and 'name' connected with ':'. For Java type 'name'  * is a fully qualified class name. For example {@code java:java.lang.String}, {@code json:ABCOrder}.  *  * @see org.apache.camel.spi.Transformer  * @see org.apache.camel.spi.Validator  *  * @param urn output type URN  * @return the builder  */ ;/**  * Declare the expected data type of the output message with content validation enabled.  * If the actual message type is different at runtime, Camel look for a required  * {@link org.apache.camel.spi.Transformer} and apply if exists, and then applies  * {@link org.apache.camel.spi.Validator} as well.  * The type name consists of two parts, 'scheme' and 'name' connected with ':'. For Java type 'name'  * is a fully qualified class name. For example {@code java:java.lang.String}, {@code json:ABCOrder}.  *  * @see org.apache.camel.spi.Transformer  * @see org.apache.camel.spi.Validator  *  * @param urn output type URN  * @return the builder  */ public RouteDefinition outputTypeWithValidate(String urn) {     outputType = new OutputTypeDefinition().     outputType.setUrn(urn).     outputType.setValidate(true).     return this. }
true;public;1;6;/**  * Declare the expected data type of the output message by Java class.  * If the actual message type is different at runtime, camel look for a required  * {@link org.apache.camel.spi.Transformer} and apply if exists.  *  * @see org.apache.camel.spi.Transformer  *  * @param clazz Class object of the output type  * @return the builder  */ ;/**  * Declare the expected data type of the output message by Java class.  * If the actual message type is different at runtime, camel look for a required  * {@link org.apache.camel.spi.Transformer} and apply if exists.  *  * @see org.apache.camel.spi.Transformer  *  * @param clazz Class object of the output type  * @return the builder  */ public RouteDefinition outputType(Class clazz) {     outputType = new OutputTypeDefinition().     outputType.setJavaClass(clazz).     outputType.setValidate(false).     return this. }
true;public;1;6;/**  * Declare the expected data type of the ouput message by Java class with content validation enabled.  * If the actual message type is different at runtime, camel look for a required  * {@link org.apache.camel.spi.Transformer} and apply if exists, and then applies  * {@link org.apache.camel.spi.Validator} as well.  *  * @see org.apache.camel.spi.Transformer  * @see org.apache.camel.spi.Validator  * @param clazz Class object of the output type  * @return the builder  */ ;/**  * Declare the expected data type of the ouput message by Java class with content validation enabled.  * If the actual message type is different at runtime, camel look for a required  * {@link org.apache.camel.spi.Transformer} and apply if exists, and then applies  * {@link org.apache.camel.spi.Validator} as well.  *  * @see org.apache.camel.spi.Transformer  * @see org.apache.camel.spi.Validator  * @param clazz Class object of the output type  * @return the builder  */ public RouteDefinition outputTypeWithValidate(Class clazz) {     outputType = new OutputTypeDefinition().     outputType.setJavaClass(clazz).     outputType.setValidate(true).     return this. }
true;public;2;13;/**  * Adds a custom property on the route.  */ ;/**  * Adds a custom property on the route.  */ public RouteDefinition routeProperty(String key, String value) {     if (routeProperties == null) {         routeProperties = new ArrayList<>().     }     PropertyDefinition prop = new PropertyDefinition().     prop.setKey(key).     prop.setValue(value).     routeProperties.add(prop).     return this. }
false;public;0;3;;// Properties // ----------------------------------------------------------------------- public List<FromDefinition> getInputs() {     return inputs. }
true;public;1;4;/**  * Input to the route.  */ ;/**  * Input to the route.  */ @XmlElementRef public void setInputs(List<FromDefinition> inputs) {     this.inputs = inputs. }
false;public;0;3;;public List<ProcessorDefinition<?>> getOutputs() {     return outputs. }
true;public;1;10;/**  * Outputs are processors that determines how messages are processed by this route.  */ ;/**  * Outputs are processors that determines how messages are processed by this route.  */ @XmlElementRef public void setOutputs(List<ProcessorDefinition<?>> outputs) {     this.outputs = outputs.     if (outputs != null) {         for (ProcessorDefinition<?> output : outputs) {             configureChild(output).         }     } }
false;public;0;3;;public boolean isOutputSupported() {     return true. }
true;public;0;3;/**  * The group that this route belongs to. could be the name of the RouteBuilder class  * or be explicitly configured in the XML.  * <p/>  * May be null.  */ ;/**  * The group that this route belongs to. could be the name of the RouteBuilder class  * or be explicitly configured in the XML.  * <p/>  * May be null.  */ public String getGroup() {     return group. }
true;public;1;4;/**  * The group that this route belongs to. could be the name of the RouteBuilder class  * or be explicitly configured in the XML.  * <p/>  * May be null.  */ ;/**  * The group that this route belongs to. could be the name of the RouteBuilder class  * or be explicitly configured in the XML.  * <p/>  * May be null.  */ @XmlAttribute public void setGroup(String group) {     this.group = group. }
true;public;0;3;/**  * Whether stream caching is enabled on this route.  */ ;/**  * Whether stream caching is enabled on this route.  */ public String getStreamCache() {     return streamCache. }
true;public;1;4;/**  * Whether stream caching is enabled on this route.  */ ;/**  * Whether stream caching is enabled on this route.  */ @XmlAttribute public void setStreamCache(String streamCache) {     this.streamCache = streamCache. }
true;public;0;3;/**  * Whether tracing is enabled on this route.  */ ;/**  * Whether tracing is enabled on this route.  */ public String getTrace() {     return trace. }
true;public;1;4;/**  * Whether tracing is enabled on this route.  */ ;/**  * Whether tracing is enabled on this route.  */ @XmlAttribute public void setTrace(String trace) {     this.trace = trace. }
true;public;0;3;/**  * Whether message history is enabled on this route.  */ ;/**  * Whether message history is enabled on this route.  */ public String getMessageHistory() {     return messageHistory. }
true;public;1;4;/**  * Whether message history is enabled on this route.  */ ;/**  * Whether message history is enabled on this route.  */ @XmlAttribute @Metadata(defaultValue = "true") public void setMessageHistory(String messageHistory) {     this.messageHistory = messageHistory. }
true;public;0;3;/**  * Whether security mask for Logging is enabled on this route.  */ ;/**  * Whether security mask for Logging is enabled on this route.  */ public String getLogMask() {     return logMask. }
true;public;1;4;/**  * Whether security mask for Logging is enabled on this route.  */ ;/**  * Whether security mask for Logging is enabled on this route.  */ @XmlAttribute public void setLogMask(String logMask) {     this.logMask = logMask. }
true;public;0;3;/**  * Whether handle fault is enabled on this route.  */ ;/**  * Whether handle fault is enabled on this route.  */ public String getHandleFault() {     return handleFault. }
true;public;1;4;/**  * Whether handle fault is enabled on this route.  */ ;/**  * Whether handle fault is enabled on this route.  */ @XmlAttribute public void setHandleFault(String handleFault) {     this.handleFault = handleFault. }
true;public;0;3;/**  * Whether to slow down processing messages by a given delay in msec.  */ ;/**  * Whether to slow down processing messages by a given delay in msec.  */ public String getDelayer() {     return delayer. }
true;public;1;4;/**  * Whether to slow down processing messages by a given delay in msec.  */ ;/**  * Whether to slow down processing messages by a given delay in msec.  */ @XmlAttribute public void setDelayer(String delayer) {     this.delayer = delayer. }
true;public;0;3;/**  * Whether to auto start this route  */ ;/**  * Whether to auto start this route  */ public String getAutoStartup() {     return autoStartup. }
true;public;1;9;/**  * TODO: move this somewhere else  */ ;/**  * TODO: move this somewhere else  */ @Deprecated public boolean isAutoStartup(CamelContext camelContext) throws Exception {     if (getAutoStartup() == null) {         // should auto startup by default         return true.     }     Boolean isAutoStartup = CamelContextHelper.parseBoolean(camelContext, getAutoStartup()).     return isAutoStartup != null && isAutoStartup. }
true;public;1;4;/**  * Whether to auto start this route  */ ;/**  * Whether to auto start this route  */ @XmlAttribute @Metadata(defaultValue = "true") public void setAutoStartup(String autoStartup) {     this.autoStartup = autoStartup. }
true;public;0;3;/**  * To configure the ordering of the routes being started  */ ;/**  * To configure the ordering of the routes being started  */ public Integer getStartupOrder() {     return startupOrder. }
true;public;1;4;/**  * To configure the ordering of the routes being started  */ ;/**  * To configure the ordering of the routes being started  */ @XmlAttribute public void setStartupOrder(Integer startupOrder) {     this.startupOrder = startupOrder. }
true;public;1;7;/**  * Sets the bean ref name of the error handler builder to use on this route  */ ;/**  * Sets the bean ref name of the error handler builder to use on this route  */ @XmlAttribute public void setErrorHandlerRef(String errorHandlerRef) {     this.errorHandlerRef = errorHandlerRef.     // we use an specific error handler ref (from Spring DSL) then wrap that     // with a error handler build ref so Camel knows its not just the default one     setErrorHandlerBuilder(new ErrorHandlerBuilderRef(errorHandlerRef)). }
true;public;0;3;/**  * Sets the bean ref name of the error handler builder to use on this route  */ ;/**  * Sets the bean ref name of the error handler builder to use on this route  */ public String getErrorHandlerRef() {     return errorHandlerRef. }
true;public;1;5;/**  * Sets the error handler if one is not already set  */ ;/**  * Sets the error handler if one is not already set  */ public void setErrorHandlerBuilderIfNull(ErrorHandlerFactory errorHandlerBuilder) {     if (this.errorHandlerBuilder == null) {         setErrorHandlerBuilder(errorHandlerBuilder).     } }
true;public;1;4;/**  * Reference to custom {@link org.apache.camel.spi.RoutePolicy} to use by the route.  * Multiple policies can be configured by separating values using comma.  */ ;/**  * Reference to custom {@link org.apache.camel.spi.RoutePolicy} to use by the route.  * Multiple policies can be configured by separating values using comma.  */ @XmlAttribute public void setRoutePolicyRef(String routePolicyRef) {     this.routePolicyRef = routePolicyRef. }
true;public;0;3;/**  * Reference to custom {@link org.apache.camel.spi.RoutePolicy} to use by the route.  * Multiple policies can be configured by separating values using comma.  */ ;/**  * Reference to custom {@link org.apache.camel.spi.RoutePolicy} to use by the route.  * Multiple policies can be configured by separating values using comma.  */ public String getRoutePolicyRef() {     return routePolicyRef. }
false;public;0;3;;public List<RoutePolicy> getRoutePolicies() {     return routePolicies. }
false;public;1;4;;@XmlTransient public void setRoutePolicies(List<RoutePolicy> routePolicies) {     this.routePolicies = routePolicies. }
false;public;0;3;;public ShutdownRoute getShutdownRoute() {     return shutdownRoute. }
true;public;1;4;/**  * To control how to shutdown the route.  */ ;/**  * To control how to shutdown the route.  */ @XmlAttribute @Metadata(defaultValue = "Default") public void setShutdownRoute(ShutdownRoute shutdownRoute) {     this.shutdownRoute = shutdownRoute. }
true;public;0;3;/**  * To control how to shutdown the route.  */ ;/**  * To control how to shutdown the route.  */ public ShutdownRunningTask getShutdownRunningTask() {     return shutdownRunningTask. }
true;public;1;4;/**  * To control how to shutdown the route.  */ ;/**  * To control how to shutdown the route.  */ @XmlAttribute @Metadata(defaultValue = "CompleteCurrentTaskOnly") public void setShutdownRunningTask(ShutdownRunningTask shutdownRunningTask) {     this.shutdownRunningTask = shutdownRunningTask. }
false;private;0;8;;private ErrorHandlerFactory createErrorHandlerBuilder() {     if (errorHandlerRef != null) {         return new ErrorHandlerBuilderRef(errorHandlerRef).     }     // return a reference to the default error handler     return new ErrorHandlerBuilderRef(ErrorHandlerBuilderRef.DEFAULT_ERROR_HANDLER_BUILDER). }
false;public;0;7;;@XmlTransient public ErrorHandlerFactory getErrorHandlerBuilder() {     if (errorHandlerBuilder == null) {         errorHandlerBuilder = createErrorHandlerBuilder().     }     return errorHandlerBuilder. }
true;public;1;3;/**  * Sets the error handler to use with processors created by this builder  */ ;/**  * Sets the error handler to use with processors created by this builder  */ public void setErrorHandlerBuilder(ErrorHandlerFactory errorHandlerBuilder) {     this.errorHandlerBuilder = errorHandlerBuilder. }
false;public;0;4;;@XmlAttribute public Boolean isRest() {     return rest. }
false;public;0;3;;public RestDefinition getRestDefinition() {     return restDefinition. }
false;public;1;4;;@XmlTransient public void setRestDefinition(RestDefinition restDefinition) {     this.restDefinition = restDefinition. }
false;public;0;3;;public RestBindingDefinition getRestBindingDefinition() {     return restBindingDefinition. }
false;public;1;4;;@XmlTransient public void setRestBindingDefinition(RestBindingDefinition restBindingDefinition) {     this.restBindingDefinition = restBindingDefinition. }
false;public;1;14;;public boolean isContextScopedErrorHandler(CamelContext context) {     if (!contextScopedErrorHandler) {         return false.     }     // the XML DSL will configure error handlers using refs, so we need this additional test     if (errorHandlerRef != null) {         ErrorHandlerFactory routeScoped = getErrorHandlerBuilder().         ErrorHandlerFactory contextScoped = context.getErrorHandlerFactory().         return routeScoped != null && contextScoped != null && routeScoped == contextScoped.     }     return true. }
false;public;1;4;;@XmlElementRef(required = false) public void setInputType(InputTypeDefinition inputType) {     this.inputType = inputType. }
false;public;0;3;;public InputTypeDefinition getInputType() {     return this.inputType. }
false;public;1;4;;@XmlElementRef(required = false) public void setOutputType(OutputTypeDefinition outputType) {     this.outputType = outputType. }
false;public;0;3;;public OutputTypeDefinition getOutputType() {     return this.outputType. }
false;public;0;3;;public List<PropertyDefinition> getRouteProperties() {     return routeProperties. }
true;public;1;5;/**  * To set metadata as properties on the route.  */ ;/**  * To set metadata as properties on the route.  */ @XmlElement(name = "routeProperty") @Metadata(label = "advanced") public void setRouteProperties(List<PropertyDefinition> routeProperties) {     this.routeProperties = routeProperties. }
false;public,static;1;3;;// **************************** // Static helpers // **************************** public static RouteDefinition fromUri(String uri) {     return new RouteDefinition().from(uri). }
false;public,static;1;3;;public static RouteDefinition fromEndpoint(Endpoint endpoint) {     return new RouteDefinition().from(endpoint). }
