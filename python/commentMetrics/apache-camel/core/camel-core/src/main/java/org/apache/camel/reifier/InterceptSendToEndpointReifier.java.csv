commented;modifiers;parameterAmount;loc;comment;code
false;public;2;16;;public Endpoint registerEndpoint(String uri, Endpoint endpoint) {     if (endpoint instanceof DefaultInterceptSendToEndpoint) {         // endpoint already decorated         return endpoint.     } else if (matchURI == null || matchPattern(routeContext.getCamelContext(), uri, matchURI)) {         // only proxy if the uri is matched decorate endpoint with our proxy         // should be false by default         boolean skip = definition.getSkipSendToOriginalEndpoint() != null && definition.getSkipSendToOriginalEndpoint().         DefaultInterceptSendToEndpoint proxy = new DefaultInterceptSendToEndpoint(endpoint, skip).         proxy.setDetour(detour).         return proxy.     } else {         // no proxy so return regular endpoint         return endpoint.     } }
false;public;1;36;;@Override public Processor createProcessor(final RouteContext routeContext) throws Exception {     // create the detour     final Processor detour = this.createChildProcessor(routeContext, true).     final String matchURI = definition.getUri().     // register endpoint callback so we can proxy the endpoint     routeContext.getCamelContext().addRegisterEndpointCallback(new EndpointStrategy() {          public Endpoint registerEndpoint(String uri, Endpoint endpoint) {             if (endpoint instanceof DefaultInterceptSendToEndpoint) {                 // endpoint already decorated                 return endpoint.             } else if (matchURI == null || matchPattern(routeContext.getCamelContext(), uri, matchURI)) {                 // only proxy if the uri is matched decorate endpoint with our proxy                 // should be false by default                 boolean skip = definition.getSkipSendToOriginalEndpoint() != null && definition.getSkipSendToOriginalEndpoint().                 DefaultInterceptSendToEndpoint proxy = new DefaultInterceptSendToEndpoint(endpoint, skip).                 proxy.setDetour(detour).                 return proxy.             } else {                 // no proxy so return regular endpoint                 return endpoint.             }         }     }).     // remove the original intercepted route from the outputs as we do not intercept as the regular interceptor     // instead we use the proxy endpoints producer do the triggering. That is we trigger when someone sends     // an exchange to the endpoint, see InterceptSendToEndpoint for details.     RouteDefinition route = (RouteDefinition) routeContext.getRoute().     List<ProcessorDefinition<?>> outputs = route.getOutputs().     outputs.remove(this).     return new InterceptEndpointProcessor(matchURI, detour). }
true;protected;3;14;/**  * Does the uri match the pattern.  *  * @param camelContext the CamelContext  * @param uri the uri  * @param pattern the pattern, which can be an endpoint uri as well  * @return <tt>true</tt> if matched and we should intercept, <tt>false</tt> if not matched, and not intercept.  */ ;/**  * Does the uri match the pattern.  *  * @param camelContext the CamelContext  * @param uri the uri  * @param pattern the pattern, which can be an endpoint uri as well  * @return <tt>true</tt> if matched and we should intercept, <tt>false</tt> if not matched, and not intercept.  */ protected boolean matchPattern(CamelContext camelContext, String uri, String pattern) {     // match using the pattern as-is     boolean match = EndpointHelper.matchEndpoint(camelContext, uri, pattern).     if (!match) {         try {             // the pattern could be an uri, so we need to normalize it before matching again             pattern = URISupport.normalizeUri(pattern).             match = EndpointHelper.matchEndpoint(camelContext, uri, pattern).         } catch (Exception e) {         // ignore         }     }     return match. }
