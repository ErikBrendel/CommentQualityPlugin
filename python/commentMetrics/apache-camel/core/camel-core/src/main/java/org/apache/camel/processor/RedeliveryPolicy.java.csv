commented;modifiers;parameterAmount;loc;comment;code
false;public;0;26;;@Override public String toString() {     return "RedeliveryPolicy[maximumRedeliveries=" + maximumRedeliveries + ", redeliveryDelay=" + redeliveryDelay + ", maximumRedeliveryDelay=" + maximumRedeliveryDelay + ", asyncDelayedRedelivery=" + asyncDelayedRedelivery + ", allowRedeliveryWhileStopping=" + allowRedeliveryWhileStopping + ", retriesExhaustedLogLevel=" + retriesExhaustedLogLevel + ", retryAttemptedLogLevel=" + retryAttemptedLogLevel + ", retryAttemptedLogInterval=" + retryAttemptedLogInterval + ", logRetryAttempted=" + logRetryAttempted + ", logStackTrace=" + logStackTrace + ", logRetryStackTrace=" + logRetryStackTrace + ", logHandled=" + logHandled + ", logContinued=" + logContinued + ", logExhausted=" + logExhausted + ", logNewException=" + logNewException + ", logExhaustedMessageHistory=" + logExhaustedMessageHistory + ", logExhaustedMessageBody=" + logExhaustedMessageBody + ", useExponentialBackOff=" + useExponentialBackOff + ", backOffMultiplier=" + backOffMultiplier + ", useCollisionAvoidance=" + useCollisionAvoidance + ", collisionAvoidanceFactor=" + collisionAvoidanceFactor + ", delayPattern=" + delayPattern + ", exchangeFormatterRef=" + exchangeFormatterRef + "]". }
false;public;0;7;;public RedeliveryPolicy copy() {     try {         return (RedeliveryPolicy) clone().     } catch (CloneNotSupportedException e) {         throw new RuntimeException("Could not clone: " + e, e).     } }
true;public;3;13;/**  * Returns true if the policy decides that the message exchange should be  * redelivered.  *  * @param exchange  the current exchange  * @param redeliveryCounter  the current retry counter  * @param retryWhile  an optional predicate to determine if we should redeliver or not  * @return true to redeliver, false to stop  */ ;/**  * Returns true if the policy decides that the message exchange should be  * redelivered.  *  * @param exchange  the current exchange  * @param redeliveryCounter  the current retry counter  * @param retryWhile  an optional predicate to determine if we should redeliver or not  * @return true to redeliver, false to stop  */ public boolean shouldRedeliver(Exchange exchange, int redeliveryCounter, Predicate retryWhile) {     // predicate is always used if provided     if (retryWhile != null) {         return retryWhile.matches(exchange).     }     if (getMaximumRedeliveries() < 0) {         // retry forever if negative value         return true.     }     // redeliver until we hit the max     return redeliveryCounter <= getMaximumRedeliveries(). }
true;public;2;8;/**  * Calculates the new redelivery delay based on the last one and then <b>sleeps</b> for the necessary amount of time.  * <p/>  * This implementation will block while sleeping.  *  * @param redeliveryDelay  previous redelivery delay  * @param redeliveryCounter  number of previous redelivery attempts  * @return the calculate delay  * @throws InterruptedException is thrown if the sleep is interrupted likely because of shutdown  */ ;/**  * Calculates the new redelivery delay based on the last one and then <b>sleeps</b> for the necessary amount of time.  * <p/>  * This implementation will block while sleeping.  *  * @param redeliveryDelay  previous redelivery delay  * @param redeliveryCounter  number of previous redelivery attempts  * @return the calculate delay  * @throws InterruptedException is thrown if the sleep is interrupted likely because of shutdown  */ public long sleep(long redeliveryDelay, int redeliveryCounter) throws InterruptedException {     redeliveryDelay = calculateRedeliveryDelay(redeliveryDelay, redeliveryCounter).     if (redeliveryDelay > 0) {         sleep(redeliveryDelay).     }     return redeliveryDelay. }
true;public;1;4;/**  * Sleeps for the given delay  *  * @param redeliveryDelay  the delay  * @throws InterruptedException is thrown if the sleep is interrupted likely because of shutdown  */ ;/**  * Sleeps for the given delay  *  * @param redeliveryDelay  the delay  * @throws InterruptedException is thrown if the sleep is interrupted likely because of shutdown  */ public void sleep(long redeliveryDelay) throws InterruptedException {     LOG.debug("Sleeping for: {} millis until attempting redelivery", redeliveryDelay).     Thread.sleep(redeliveryDelay). }
true;public;2;35;/**  * Calculates the new redelivery delay based on the last one  *  * @param previousDelay  previous redelivery delay  * @param redeliveryCounter  number of previous redelivery attempts  * @return the calculate delay  */ ;/**  * Calculates the new redelivery delay based on the last one  *  * @param previousDelay  previous redelivery delay  * @param redeliveryCounter  number of previous redelivery attempts  * @return the calculate delay  */ public long calculateRedeliveryDelay(long previousDelay, int redeliveryCounter) {     if (ObjectHelper.isNotEmpty(delayPattern)) {         // calculate delay using the pattern         return calculateRedeliverDelayUsingPattern(delayPattern, redeliveryCounter).     }     // calculate the delay using the conventional parameters     long redeliveryDelayResult.     if (previousDelay == 0) {         redeliveryDelayResult = redeliveryDelay.     } else if (useExponentialBackOff && backOffMultiplier > 1) {         redeliveryDelayResult = Math.round(backOffMultiplier * previousDelay).     } else {         redeliveryDelayResult = previousDelay.     }     if (useCollisionAvoidance) {         /*              * First random determines +/-, second random determines how far to              * go in that direction. -cgs              */         Random random = getRandomNumberGenerator().         double variance = (random.nextBoolean() ? collisionAvoidanceFactor : -collisionAvoidanceFactor) * random.nextDouble().         redeliveryDelayResult += redeliveryDelayResult * variance.     }     // ensure the calculated result is not bigger than the max delay (if configured)     if (maximumRedeliveryDelay > 0 && redeliveryDelayResult > maximumRedeliveryDelay) {         redeliveryDelayResult = maximumRedeliveryDelay.     }     return redeliveryDelayResult. }
true;protected,static;2;16;/**  * Calculates the delay using the delay pattern  */ ;/**  * Calculates the delay using the delay pattern  */ protected static long calculateRedeliverDelayUsingPattern(String delayPattern, int redeliveryCounter) {     String[] groups = delayPattern.split(".").     // find the group where the redelivery counter matches     long answer = 0.     for (String group : groups) {         long delay = Long.valueOf(StringHelper.after(group, ":")).         int count = Integer.valueOf(StringHelper.before(group, ":")).         if (count > redeliveryCounter) {             break.         } else {             answer = delay.         }     }     return answer. }
true;public;1;4;/**  * Sets the initial redelivery delay in milliseconds  */ ;// Builder methods // ------------------------------------------------------------------------- /**  * Sets the initial redelivery delay in milliseconds  */ public RedeliveryPolicy redeliveryDelay(long delay) {     setRedeliveryDelay(delay).     return this. }
true;public;1;4;/**  * Sets the maximum number of times a message exchange will be redelivered  */ ;/**  * Sets the maximum number of times a message exchange will be redelivered  */ public RedeliveryPolicy maximumRedeliveries(int maximumRedeliveries) {     setMaximumRedeliveries(maximumRedeliveries).     return this. }
true;public;0;4;/**  * Enables collision avoidance which adds some randomization to the backoff  * timings to reduce contention probability  */ ;/**  * Enables collision avoidance which adds some randomization to the backoff  * timings to reduce contention probability  */ public RedeliveryPolicy useCollisionAvoidance() {     setUseCollisionAvoidance(true).     return this. }
true;public;0;4;/**  * Enables exponential backoff using the {@link #getBackOffMultiplier()} to  * increase the time between retries  */ ;/**  * Enables exponential backoff using the {@link #getBackOffMultiplier()} to  * increase the time between retries  */ public RedeliveryPolicy useExponentialBackOff() {     setUseExponentialBackOff(true).     return this. }
true;public;1;5;/**  * Enables exponential backoff and sets the multiplier used to increase the  * delay between redeliveries  */ ;/**  * Enables exponential backoff and sets the multiplier used to increase the  * delay between redeliveries  */ public RedeliveryPolicy backOffMultiplier(double multiplier) {     useExponentialBackOff().     setBackOffMultiplier(multiplier).     return this. }
true;public;1;5;/**  * Enables collision avoidance and sets the percentage used  */ ;/**  * Enables collision avoidance and sets the percentage used  */ public RedeliveryPolicy collisionAvoidancePercent(double collisionAvoidancePercent) {     useCollisionAvoidance().     setCollisionAvoidancePercent(collisionAvoidancePercent).     return this. }
true;public;1;4;/**  * Sets the maximum redelivery delay if using exponential back off.  * Use -1 if you wish to have no maximum  */ ;/**  * Sets the maximum redelivery delay if using exponential back off.  * Use -1 if you wish to have no maximum  */ public RedeliveryPolicy maximumRedeliveryDelay(long maximumRedeliveryDelay) {     setMaximumRedeliveryDelay(maximumRedeliveryDelay).     return this. }
true;public;1;4;/**  * Sets the logging level to use for log messages when retries have been exhausted.  */ ;/**  * Sets the logging level to use for log messages when retries have been exhausted.  */ public RedeliveryPolicy retriesExhaustedLogLevel(LoggingLevel retriesExhaustedLogLevel) {     setRetriesExhaustedLogLevel(retriesExhaustedLogLevel).     return this. }
true;public;1;4;/**  * Sets the logging level to use for log messages when retries are attempted.  */ ;/**  * Sets the logging level to use for log messages when retries are attempted.  */ public RedeliveryPolicy retryAttemptedLogLevel(LoggingLevel retryAttemptedLogLevel) {     setRetryAttemptedLogLevel(retryAttemptedLogLevel).     return this. }
true;public;1;4;/**  * Sets the interval to log retry attempts  */ ;/**  * Sets the interval to log retry attempts  */ public RedeliveryPolicy retryAttemptedLogInterval(int logRetryAttemptedInterval) {     setRetryAttemptedLogInterval(logRetryAttemptedInterval).     return this. }
true;public;1;4;/**  * Sets whether to log retry attempts  */ ;/**  * Sets whether to log retry attempts  */ public RedeliveryPolicy logRetryAttempted(boolean logRetryAttempted) {     setLogRetryAttempted(logRetryAttempted).     return this. }
true;public;1;4;/**  * Sets whether to log stacktrace for failed messages.  */ ;/**  * Sets whether to log stacktrace for failed messages.  */ public RedeliveryPolicy logStackTrace(boolean logStackTrace) {     setLogStackTrace(logStackTrace).     return this. }
true;public;1;4;/**  * Sets whether to log stacktrace for failed redelivery attempts  */ ;/**  * Sets whether to log stacktrace for failed redelivery attempts  */ public RedeliveryPolicy logRetryStackTrace(boolean logRetryStackTrace) {     setLogRetryStackTrace(logRetryStackTrace).     return this. }
true;public;1;4;/**  * Sets whether to log errors even if its handled  */ ;/**  * Sets whether to log errors even if its handled  */ public RedeliveryPolicy logHandled(boolean logHandled) {     setLogHandled(logHandled).     return this. }
true;public;1;4;/**  * Sets whether errors should be logged when a new exception occurred during handling a previous exception  */ ;/**  * Sets whether errors should be logged when a new exception occurred during handling a previous exception  */ public RedeliveryPolicy logNewException(boolean logNewException) {     setLogNewException(logNewException).     return this. }
true;public;1;4;/**  * Sets whether to log exhausted errors  */ ;/**  * Sets whether to log exhausted errors  */ public RedeliveryPolicy logExhausted(boolean logExhausted) {     setLogExhausted(logExhausted).     return this. }
true;public;1;4;/**  * Sets whether to log exhausted errors including message history  */ ;/**  * Sets whether to log exhausted errors including message history  */ public RedeliveryPolicy logExhaustedMessageHistory(boolean logExhaustedMessageHistory) {     setLogExhaustedMessageHistory(logExhaustedMessageHistory).     return this. }
true;public;1;4;/**  * Sets whether to log exhausted errors including message body (requires message history to be enabled)  */ ;/**  * Sets whether to log exhausted errors including message body (requires message history to be enabled)  */ public RedeliveryPolicy logExhaustedMessageBody(boolean logExhaustedMessageBody) {     setLogExhaustedMessageBody(logExhaustedMessageBody).     return this. }
true;public;1;4;/**  * Sets the delay pattern with delay intervals.  */ ;/**  * Sets the delay pattern with delay intervals.  */ public RedeliveryPolicy delayPattern(String delayPattern) {     setDelayPattern(delayPattern).     return this. }
true;public;0;4;/**  * Disables redelivery by setting maximum redeliveries to 0.  */ ;/**  * Disables redelivery by setting maximum redeliveries to 0.  */ public RedeliveryPolicy disableRedelivery() {     setMaximumRedeliveries(0).     return this. }
true;public;0;4;/**  * Allow asynchronous delayed redelivery.  *  * @see #setAsyncDelayedRedelivery(boolean)  */ ;/**  * Allow asynchronous delayed redelivery.  *  * @see #setAsyncDelayedRedelivery(boolean)  */ public RedeliveryPolicy asyncDelayedRedelivery() {     setAsyncDelayedRedelivery(true).     return this. }
true;public;1;4;/**  * Controls whether to allow redelivery while stopping/shutting down a route that uses error handling.  *  * @param redeliverWhileStopping <tt>true</tt> to allow redelivery, <tt>false</tt> to reject redeliveries  */ ;/**  * Controls whether to allow redelivery while stopping/shutting down a route that uses error handling.  *  * @param redeliverWhileStopping <tt>true</tt> to allow redelivery, <tt>false</tt> to reject redeliveries  */ public RedeliveryPolicy allowRedeliveryWhileStopping(boolean redeliverWhileStopping) {     setAllowRedeliveryWhileStopping(redeliverWhileStopping).     return this. }
true;public;1;4;/**  * Sets the reference of the instance of {@link org.apache.camel.spi.ExchangeFormatter} to generate the log message from exchange.  *  * @param exchangeFormatterRef name of the instance of {@link org.apache.camel.spi.ExchangeFormatter}  * @return the builder  */ ;/**  * Sets the reference of the instance of {@link org.apache.camel.spi.ExchangeFormatter} to generate the log message from exchange.  *  * @param exchangeFormatterRef name of the instance of {@link org.apache.camel.spi.ExchangeFormatter}  * @return the builder  */ public RedeliveryPolicy exchangeFormatterRef(String exchangeFormatterRef) {     setExchangeFormatterRef(exchangeFormatterRef).     return this. }
false;public;0;3;;// Properties // ------------------------------------------------------------------------- public long getRedeliveryDelay() {     return redeliveryDelay. }
true;public;1;7;/**  * Sets the initial redelivery delay in milliseconds  */ ;/**  * Sets the initial redelivery delay in milliseconds  */ public void setRedeliveryDelay(long redeliverDelay) {     this.redeliveryDelay = redeliverDelay.     // if max enabled then also set max to this value in case max was too low     if (maximumRedeliveryDelay > 0 && redeliverDelay > maximumRedeliveryDelay) {         this.maximumRedeliveryDelay = redeliverDelay.     } }
false;public;0;3;;public double getBackOffMultiplier() {     return backOffMultiplier. }
true;public;1;3;/**  * Sets the multiplier used to increase the delay between redeliveries if  * {@link #setUseExponentialBackOff(boolean)} is enabled  */ ;/**  * Sets the multiplier used to increase the delay between redeliveries if  * {@link #setUseExponentialBackOff(boolean)} is enabled  */ public void setBackOffMultiplier(double backOffMultiplier) {     this.backOffMultiplier = backOffMultiplier. }
false;public;0;3;;public long getCollisionAvoidancePercent() {     return Math.round(collisionAvoidanceFactor * 100). }
true;public;1;3;/**  * Sets the percentage used for collision avoidance if enabled via  * {@link #setUseCollisionAvoidance(boolean)}  */ ;/**  * Sets the percentage used for collision avoidance if enabled via  * {@link #setUseCollisionAvoidance(boolean)}  */ public void setCollisionAvoidancePercent(double collisionAvoidancePercent) {     this.collisionAvoidanceFactor = collisionAvoidancePercent * 0.01d. }
false;public;0;3;;public double getCollisionAvoidanceFactor() {     return collisionAvoidanceFactor. }
true;public;1;3;/**  * Sets the factor used for collision avoidance if enabled via  * {@link #setUseCollisionAvoidance(boolean)}  */ ;/**  * Sets the factor used for collision avoidance if enabled via  * {@link #setUseCollisionAvoidance(boolean)}  */ public void setCollisionAvoidanceFactor(double collisionAvoidanceFactor) {     this.collisionAvoidanceFactor = collisionAvoidanceFactor. }
false;public;0;3;;public int getMaximumRedeliveries() {     return maximumRedeliveries. }
true;public;1;3;/**  * Sets the maximum number of times a message exchange will be redelivered.  * Setting a negative value will retry forever.  */ ;/**  * Sets the maximum number of times a message exchange will be redelivered.  * Setting a negative value will retry forever.  */ public void setMaximumRedeliveries(int maximumRedeliveries) {     this.maximumRedeliveries = maximumRedeliveries. }
false;public;0;3;;public long getMaximumRedeliveryDelay() {     return maximumRedeliveryDelay. }
true;public;1;3;/**  * Sets the maximum redelivery delay.  * Use -1 if you wish to have no maximum  */ ;/**  * Sets the maximum redelivery delay.  * Use -1 if you wish to have no maximum  */ public void setMaximumRedeliveryDelay(long maximumRedeliveryDelay) {     this.maximumRedeliveryDelay = maximumRedeliveryDelay. }
false;public;0;3;;public boolean isUseCollisionAvoidance() {     return useCollisionAvoidance. }
true;public;1;3;/**  * Enables/disables collision avoidance which adds some randomization to the  * backoff timings to reduce contention probability  */ ;/**  * Enables/disables collision avoidance which adds some randomization to the  * backoff timings to reduce contention probability  */ public void setUseCollisionAvoidance(boolean useCollisionAvoidance) {     this.useCollisionAvoidance = useCollisionAvoidance. }
false;public;0;3;;public boolean isUseExponentialBackOff() {     return useExponentialBackOff. }
true;public;1;3;/**  * Enables/disables exponential backoff using the  * {@link #getBackOffMultiplier()} to increase the time between retries  */ ;/**  * Enables/disables exponential backoff using the  * {@link #getBackOffMultiplier()} to increase the time between retries  */ public void setUseExponentialBackOff(boolean useExponentialBackOff) {     this.useExponentialBackOff = useExponentialBackOff. }
false;protected,static,synchronized;0;6;;protected static synchronized Random getRandomNumberGenerator() {     if (randomNumberGenerator == null) {         randomNumberGenerator = new Random().     }     return randomNumberGenerator. }
true;public;1;3;/**  * Sets the logging level to use for log messages when retries have been exhausted.  */ ;/**  * Sets the logging level to use for log messages when retries have been exhausted.  */ public void setRetriesExhaustedLogLevel(LoggingLevel retriesExhaustedLogLevel) {     this.retriesExhaustedLogLevel = retriesExhaustedLogLevel. }
false;public;0;3;;public LoggingLevel getRetriesExhaustedLogLevel() {     return retriesExhaustedLogLevel. }
true;public;1;3;/**  * Sets the logging level to use for log messages when retries are attempted.  */ ;/**  * Sets the logging level to use for log messages when retries are attempted.  */ public void setRetryAttemptedLogLevel(LoggingLevel retryAttemptedLogLevel) {     this.retryAttemptedLogLevel = retryAttemptedLogLevel. }
false;public;0;3;;public LoggingLevel getRetryAttemptedLogLevel() {     return retryAttemptedLogLevel. }
false;public;0;3;;public int getRetryAttemptedLogInterval() {     return retryAttemptedLogInterval. }
true;public;1;3;/**  * Sets the interval to log retry attempts  */ ;/**  * Sets the interval to log retry attempts  */ public void setRetryAttemptedLogInterval(int retryAttemptedLogInterval) {     this.retryAttemptedLogInterval = retryAttemptedLogInterval. }
false;public;0;3;;public String getDelayPattern() {     return delayPattern. }
true;public;1;3;/**  * Sets an optional delay pattern to use instead of fixed delay.  */ ;/**  * Sets an optional delay pattern to use instead of fixed delay.  */ public void setDelayPattern(String delayPattern) {     this.delayPattern = delayPattern. }
false;public;0;3;;public boolean isLogStackTrace() {     return logStackTrace. }
true;public;1;3;/**  * Sets whether stack traces should be logged or not  */ ;/**  * Sets whether stack traces should be logged or not  */ public void setLogStackTrace(boolean logStackTrace) {     this.logStackTrace = logStackTrace. }
false;public;0;3;;public boolean isLogRetryStackTrace() {     return logRetryStackTrace. }
true;public;1;3;/**  * Sets whether stack traces should be logged or not  */ ;/**  * Sets whether stack traces should be logged or not  */ public void setLogRetryStackTrace(boolean logRetryStackTrace) {     this.logRetryStackTrace = logRetryStackTrace. }
false;public;0;3;;public boolean isLogHandled() {     return logHandled. }
true;public;1;3;/**  * Sets whether errors should be logged even if its handled  */ ;/**  * Sets whether errors should be logged even if its handled  */ public void setLogHandled(boolean logHandled) {     this.logHandled = logHandled. }
false;public;0;3;;public boolean isLogNewException() {     return logNewException. }
true;public;1;3;/**  * Sets whether errors should be logged when a new exception occurred during handling a previous exception  */ ;/**  * Sets whether errors should be logged when a new exception occurred during handling a previous exception  */ public void setLogNewException(boolean logNewException) {     this.logNewException = logNewException. }
false;public;0;3;;public boolean isLogContinued() {     return logContinued. }
true;public;1;3;/**  * Sets whether errors should be logged even if its continued  */ ;/**  * Sets whether errors should be logged even if its continued  */ public void setLogContinued(boolean logContinued) {     this.logContinued = logContinued. }
false;public;0;3;;public boolean isLogRetryAttempted() {     return logRetryAttempted. }
true;public;1;3;/**  * Sets whether retry attempts should be logged or not  */ ;/**  * Sets whether retry attempts should be logged or not  */ public void setLogRetryAttempted(boolean logRetryAttempted) {     this.logRetryAttempted = logRetryAttempted. }
false;public;0;3;;public boolean isLogExhausted() {     return logExhausted. }
true;public;1;3;/**  * Sets whether exhausted exceptions should be logged or not  */ ;/**  * Sets whether exhausted exceptions should be logged or not  */ public void setLogExhausted(boolean logExhausted) {     this.logExhausted = logExhausted. }
false;public;0;4;;public boolean isLogExhaustedMessageHistory() {     // should default be enabled     return logExhaustedMessageHistory == null || logExhaustedMessageHistory. }
true;public;0;3;/**  * Whether the option logExhaustedMessageHistory has been configured or not  *  * @return <tt>null</tt> if not configured, or the configured value as true or false  * @see #isLogExhaustedMessageHistory()  */ ;/**  * Whether the option logExhaustedMessageHistory has been configured or not  *  * @return <tt>null</tt> if not configured, or the configured value as true or false  * @see #isLogExhaustedMessageHistory()  */ public Boolean getLogExhaustedMessageHistory() {     return logExhaustedMessageHistory. }
true;public;1;3;/**  * Sets whether exhausted exceptions should be logged with message history included.  */ ;/**  * Sets whether exhausted exceptions should be logged with message history included.  */ public void setLogExhaustedMessageHistory(boolean logExhaustedMessageHistory) {     this.logExhaustedMessageHistory = logExhaustedMessageHistory. }
false;public;0;4;;public boolean isLogExhaustedMessageBody() {     // should default be disabled     return logExhaustedMessageBody != null && logExhaustedMessageBody. }
true;public;0;3;/**  * Whether the option logExhaustedMessageBody has been configured or not  *  * @return <tt>null</tt> if not configured, or the configured value as true or false  * @see #isLogExhaustedMessageBody()  */ ;/**  * Whether the option logExhaustedMessageBody has been configured or not  *  * @return <tt>null</tt> if not configured, or the configured value as true or false  * @see #isLogExhaustedMessageBody()  */ public Boolean getLogExhaustedMessageBody() {     return logExhaustedMessageBody. }
true;public;1;3;/**  * Sets whether exhausted message body/headers should be logged with message history included  * (requires logExhaustedMessageHistory to be enabled).  */ ;/**  * Sets whether exhausted message body/headers should be logged with message history included  * (requires logExhaustedMessageHistory to be enabled).  */ public void setLogExhaustedMessageBody(Boolean logExhaustedMessageBody) {     this.logExhaustedMessageBody = logExhaustedMessageBody. }
false;public;0;3;;public boolean isAsyncDelayedRedelivery() {     return asyncDelayedRedelivery. }
true;public;1;3;/**  * Sets whether asynchronous delayed redelivery is allowed.  * <p/>  * This is disabled by default.  * <p/>  * When enabled it allows Camel to schedule a future task for delayed  * redelivery which prevents current thread from blocking while waiting.  * <p/>  * Exchange which is transacted will however always use synchronous delayed redelivery  * because the transaction must execute in the same thread context.  *  * @param asyncDelayedRedelivery whether asynchronous delayed redelivery is allowed  */ ;/**  * Sets whether asynchronous delayed redelivery is allowed.  * <p/>  * This is disabled by default.  * <p/>  * When enabled it allows Camel to schedule a future task for delayed  * redelivery which prevents current thread from blocking while waiting.  * <p/>  * Exchange which is transacted will however always use synchronous delayed redelivery  * because the transaction must execute in the same thread context.  *  * @param asyncDelayedRedelivery whether asynchronous delayed redelivery is allowed  */ public void setAsyncDelayedRedelivery(boolean asyncDelayedRedelivery) {     this.asyncDelayedRedelivery = asyncDelayedRedelivery. }
false;public;0;3;;public boolean isAllowRedeliveryWhileStopping() {     return allowRedeliveryWhileStopping. }
true;public;1;3;/**  * Controls whether to allow redelivery while stopping/shutting down a route that uses error handling.  *  * @param allowRedeliveryWhileStopping <tt>true</tt> to allow redelivery, <tt>false</tt> to reject redeliveries  */ ;/**  * Controls whether to allow redelivery while stopping/shutting down a route that uses error handling.  *  * @param allowRedeliveryWhileStopping <tt>true</tt> to allow redelivery, <tt>false</tt> to reject redeliveries  */ public void setAllowRedeliveryWhileStopping(boolean allowRedeliveryWhileStopping) {     this.allowRedeliveryWhileStopping = allowRedeliveryWhileStopping. }
false;public;0;3;;public String getExchangeFormatterRef() {     return exchangeFormatterRef. }
true;public;1;3;/**  * Sets the reference of the instance of {@link org.apache.camel.spi.ExchangeFormatter} to generate the log message from exchange.  */ ;/**  * Sets the reference of the instance of {@link org.apache.camel.spi.ExchangeFormatter} to generate the log message from exchange.  */ public void setExchangeFormatterRef(String exchangeFormatterRef) {     this.exchangeFormatterRef = exchangeFormatterRef. }
