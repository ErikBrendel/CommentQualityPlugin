commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;52;/**  * Should we continue processing the exchange?  *  * @param exchange the next exchange  * @param message a message to use when logging that we should not continue processing  * @param log a logger  * @return <tt>true</tt> to continue processing, <tt>false</tt> to break out, for example if an exception occurred.  */ ;/**  * Should we continue processing the exchange?  *  * @param exchange the next exchange  * @param message a message to use when logging that we should not continue processing  * @param log a logger  * @return <tt>true</tt> to continue processing, <tt>false</tt> to break out, for example if an exception occurred.  */ public static boolean continueProcessing(Exchange exchange, String message, Logger log) {     // check for error if so we should break out     boolean exceptionHandled = hasExceptionBeenHandledByErrorHandler(exchange).     if (exchange.isFailed() || exchange.isRollbackOnly() || exceptionHandled) {         // We need to write a warning message when the exception and fault message be set at the same time         Message msg = exchange.hasOut() ? exchange.getOut() : exchange.getIn().         if (msg.isFault() && exchange.getException() != null) {             StringBuilder sb = new StringBuilder().             sb.append("Message exchange has failed: " + message + " for exchange: ").append(exchange).             sb.append(" Warning: Both fault and exception exists on the exchange, its best practice to only set one of them.").             sb.append(" Exception: ").append(exchange.getException()).             sb.append(" Fault: ").append(msg).             if (exceptionHandled) {                 sb.append(" Handled by the error handler.").             }             log.warn(sb.toString()).         }         // by the error handler. It's still an exception, the exchange still failed.         if (log.isDebugEnabled()) {             StringBuilder sb = new StringBuilder().             sb.append("Message exchange has failed: " + message + " for exchange: ").append(exchange).             if (exchange.isRollbackOnly()) {                 sb.append(" Marked as rollback only.").             }             if (exchange.getException() != null) {                 sb.append(" Exception: ").append(exchange.getException()).             }             if (msg.isFault()) {                 sb.append(" Fault: ").append(msg).             }             if (exceptionHandled) {                 sb.append(" Handled by the error handler.").             }             log.debug(sb.toString()).         }         return false.     }     // check for stop     Object stop = exchange.getProperty(Exchange.ROUTE_STOP).     if (stop != null) {         boolean doStop = exchange.getContext().getTypeConverter().convertTo(Boolean.class, exchange, stop).         if (doStop) {             log.debug("ExchangeId: {} is marked to stop routing: {}", exchange.getExchangeId(), exchange).             return false.         }     }     return true. }
true;public,static;1;11;/**  * Strategy method to create the next exchange from the previous exchange.  * <p/>  * Remember to copy the original exchange id otherwise correlation of ids in the log is a problem  *  * @param previousExchange the previous exchange  * @return a new exchange  */ ;/**  * Strategy method to create the next exchange from the previous exchange.  * <p/>  * Remember to copy the original exchange id otherwise correlation of ids in the log is a problem  *  * @param previousExchange the previous exchange  * @return a new exchange  */ public static Exchange createNextExchange(Exchange previousExchange) {     Exchange answer = previousExchange.     // previous message if it is not null     if (answer.hasOut()) {         answer.setIn(answer.getOut()).         answer.setOut(null).     }     return answer. }
