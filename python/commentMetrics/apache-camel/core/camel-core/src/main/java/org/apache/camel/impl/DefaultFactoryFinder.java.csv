commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getResourcePath() {     return path. }
false;public;1;8;;@Override public Object newInstance(String key) throws NoFactoryAvailableException {     try {         return newInstance(key, null).     } catch (Exception e) {         throw new NoFactoryAvailableException(key, e).     } }
false;public;3;7;;@Override public <T> List<T> newInstances(String key, Injector injector, Class<T> type) throws ClassNotFoundException, IOException {     List<Class<T>> list = CastUtils.cast(findClasses(key)).     List<T> answer = new ArrayList<>(list.size()).     answer.add(newInstance(key, injector, type)).     return answer. }
false;public;1;4;;@Override public Class<?> findClass(String key) throws ClassNotFoundException, IOException {     return findClass(key, null). }
false;public;0;4;;@Override public Class<?> get() throws ClassNotFoundException, IOException {     return DefaultFactoryFinder.this.newInstance(DefaultFactoryFinder.this.doFindFactoryProperties(key), prefix). }
false;public;2;12;;@Override public Class<?> findClass(String key, String propertyPrefix) throws ClassNotFoundException, IOException {     final String prefix = propertyPrefix != null ? propertyPrefix : "".     final String classKey = prefix + key.     return addToClassMap(classKey, new ClassSupplier() {          @Override         public Class<?> get() throws ClassNotFoundException, IOException {             return DefaultFactoryFinder.this.newInstance(DefaultFactoryFinder.this.doFindFactoryProperties(key), prefix).         }     }). }
false;public;3;5;;@Override public Class<?> findClass(String key, String propertyPrefix, Class<?> clazz) throws ClassNotFoundException, IOException {     // Just ignore clazz which is only useful for OSGiFactoryFinder     return findClass(key, propertyPrefix). }
false;private;2;5;;private Object newInstance(String key, String propertyPrefix) throws IllegalAccessException, InstantiationException, IOException, ClassNotFoundException {     Class<?> clazz = findClass(key, propertyPrefix).     return clazz.newInstance(). }
false;private;3;4;;private <T> T newInstance(String key, Injector injector, Class<T> expectedType) throws IOException, ClassNotFoundException {     return newInstance(key, injector, null, expectedType). }
false;private;4;10;;private <T> T newInstance(String key, Injector injector, String propertyPrefix, Class<T> expectedType) throws IOException, ClassNotFoundException {     Class<?> type = findClass(key, propertyPrefix).     Object value = injector.newInstance(type).     if (expectedType.isInstance(value)) {         return expectedType.cast(value).     } else {         throw new ClassCastException("Not instanceof " + expectedType.getName() + " value: " + value).     } }
false;private;1;3;;private List<Class<?>> findClasses(String key) throws ClassNotFoundException, IOException {     return findClasses(key, null). }
false;private;2;4;;private List<Class<?>> findClasses(String key, String propertyPrefix) throws ClassNotFoundException, IOException {     Class<?> type = findClass(key, propertyPrefix).     return Collections.<Class<?>>singletonList(type). }
false;private;2;12;;private Class<?> newInstance(Properties properties, String propertyPrefix) throws ClassNotFoundException, IOException {     String className = properties.getProperty(propertyPrefix + "class").     if (className == null) {         throw new IOException("Expected property is missing: " + propertyPrefix + "class").     }     Class<?> clazz = classResolver.resolveClass(className).     if (clazz == null) {         throw new ClassNotFoundException(className).     }     return clazz. }
false;private;1;20;;private Properties doFindFactoryProperties(String key) throws IOException {     String uri = path + key.     InputStream in = classResolver.loadResourceAsStream(uri).     if (in == null) {         throw new NoFactoryAvailableException(uri).     }     // lets load the file     BufferedInputStream reader = null.     try {         reader = IOHelper.buffered(in).         Properties properties = new Properties().         properties.load(reader).         return properties.     } finally {         IOHelper.close(reader, key, null).         IOHelper.close(in, key, null).     } }
false;public;1;12;;@Override public Class<?> apply(String classKey) {     try {         return mappingFunction.get().     } catch (ClassNotFoundException e) {         throw new WrappedRuntimeException(e).     } catch (NoFactoryAvailableException e) {         throw new WrappedRuntimeException(e).     } catch (IOException e) {         throw new WrappedRuntimeException(e).     } }
true;protected;2;28;/*      * This is a wrapper function to deal with exceptions in lambdas: the exception      * is wrapped by a runtime exception (WrappedRuntimeException) which we catch      * later on with the only purpose to re-throw the original exception.      */ ;/*      * This is a wrapper function to deal with exceptions in lambdas: the exception      * is wrapped by a runtime exception (WrappedRuntimeException) which we catch      * later on with the only purpose to re-throw the original exception.      */ protected Class<?> addToClassMap(String key, ClassSupplier mappingFunction) throws ClassNotFoundException, IOException {     try {         return classMap.computeIfAbsent(key, new Function<String, Class<?>>() {              @Override             public Class<?> apply(String classKey) {                 try {                     return mappingFunction.get().                 } catch (ClassNotFoundException e) {                     throw new WrappedRuntimeException(e).                 } catch (NoFactoryAvailableException e) {                     throw new WrappedRuntimeException(e).                 } catch (IOException e) {                     throw new WrappedRuntimeException(e).                 }             }         }).     } catch (WrappedRuntimeException e) {         if (e.getCause() instanceof ClassNotFoundException) {             throw (ClassNotFoundException) e.getCause().         } else if (e.getCause() instanceof NoFactoryAvailableException) {             throw (NoFactoryAvailableException) e.getCause().         } else if (e.getCause() instanceof IOException) {             throw (IOException) e.getCause().         } else {             throw new RuntimeException(e.getCause()).         }     } }
false;;0;1;;Class<?> get() throws ClassNotFoundException, IOException.
