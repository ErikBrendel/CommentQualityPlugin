commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;7;;public static void main(String... args) throws Exception {     Main main = new Main().     instance = main.     main.run(args).     System.exit(main.getExitCode()). }
true;public,static;0;3;/**  * Returns the currently executing main  *  * @return the current running instance  */ ;/**  * Returns the currently executing main  *  * @return the current running instance  */ public static Main getInstance() {     return instance. }
true;public;2;3;/**  * Binds the given <code>name</code> to the <code>bean</code> object, so  * that it can be looked up inside the CamelContext this command line tool  * runs with.  *  * @param name the used name through which we do bind  * @param bean the object to bind  */ ;/**  * Binds the given <code>name</code> to the <code>bean</code> object, so  * that it can be looked up inside the CamelContext this command line tool  * runs with.  *  * @param name the used name through which we do bind  * @param bean the object to bind  */ public void bind(String name, Object bean) {     registry.bind(name, bean). }
true;public;1;3;/**  * Using the given <code>name</code> does lookup for the bean being already  * bound using the {@link #bind(String, Object)} method.  *  * @see Registry#lookupByName(String)  */ ;/**  * Using the given <code>name</code> does lookup for the bean being already  * bound using the {@link #bind(String, Object)} method.  *  * @see Registry#lookupByName(String)  */ public Object lookup(String name) {     return registry.lookupByName(name). }
true;public;2;3;/**  * Using the given <code>name</code> and <code>type</code> does lookup for  * the bean being already bound using the {@link #bind(String, Object)}  * method.  *  * @see Registry#lookupByNameAndType(String, Class)  */ ;/**  * Using the given <code>name</code> and <code>type</code> does lookup for  * the bean being already bound using the {@link #bind(String, Object)}  * method.  *  * @see Registry#lookupByNameAndType(String, Class)  */ public <T> T lookup(String name, Class<T> type) {     return registry.lookupByNameAndType(name, type). }
true;public;1;3;/**  * Using the given <code>type</code> does lookup for the bean being already  * bound using the {@link #bind(String, Object)} method.  *  * @see Registry#findByTypeWithName(Class)  */ ;/**  * Using the given <code>type</code> does lookup for the bean being already  * bound using the {@link #bind(String, Object)} method.  *  * @see Registry#findByTypeWithName(Class)  */ public <T> Map<String, T> lookupByType(Class<T> type) {     return registry.findByTypeWithName(type). }
false;protected;0;15;;// Implementation methods // ------------------------------------------------------------------------- @Override protected void doStart() throws Exception {     super.doStart().     initCamelContext().     if (getCamelContext() != null) {         try {             // if we were veto started then mark as completed             getCamelContext().start().         } finally {             if (getCamelContext().isVetoStarted()) {                 completed().             }         }     } }
false;protected;0;6;;protected void doStop() throws Exception {     super.doStop().     if (getCamelContext() != null) {         getCamelContext().stop().     } }
false;protected;0;7;;protected ProducerTemplate findOrCreateCamelTemplate() {     if (getCamelContext() != null) {         return getCamelContext().createProducerTemplate().     } else {         return null.     } }
false;protected;0;3;;protected CamelContext createCamelContext() {     return new DefaultCamelContext(registry). }
