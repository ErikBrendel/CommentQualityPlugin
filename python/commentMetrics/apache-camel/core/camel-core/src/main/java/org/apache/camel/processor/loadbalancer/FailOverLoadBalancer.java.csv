commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public CamelContext getCamelContext() {     return camelContext. }
false;public;1;4;;@Override public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;0;3;;public int getLastGoodIndex() {     return lastGoodIndex.get(). }
false;public;0;3;;public List<Class<?>> getExceptions() {     return exceptions. }
false;public;0;3;;public boolean isRoundRobin() {     return roundRobin. }
false;public;1;3;;public void setRoundRobin(boolean roundRobin) {     this.roundRobin = roundRobin. }
false;public;0;3;;public boolean isSticky() {     return sticky. }
false;public;1;3;;public void setSticky(boolean sticky) {     this.sticky = sticky. }
false;public;0;3;;public int getMaximumFailoverAttempts() {     return maximumFailoverAttempts. }
false;public;1;3;;public void setMaximumFailoverAttempts(int maximumFailoverAttempts) {     this.maximumFailoverAttempts = maximumFailoverAttempts. }
true;protected;1;31;/**  * Should the given failed Exchange failover?  *  * @param exchange the exchange that failed  * @return <tt>true</tt> to failover  */ ;/**  * Should the given failed Exchange failover?  *  * @param exchange the exchange that failed  * @return <tt>true</tt> to failover  */ protected boolean shouldFailOver(Exchange exchange) {     if (exchange == null) {         return false.     }     boolean answer = false.     if (exchange.getException() != null) {         if (exceptions == null || exceptions.isEmpty()) {             // always failover if no exceptions defined             answer = true.         } else {             for (Class<?> exception : exceptions) {                 // will look in exception hierarchy                 if (exchange.getException(exception) != null) {                     answer = true.                     break.                 }             }         }         if (answer) {             // record the failure in the statistics             statistics.onHandledFailure(exchange.getException()).         }     }     log.trace("Should failover: {} for exchangeId: {}", answer, exchange.getExchangeId()).     return answer. }
false;public;0;9;;@Override public boolean isRunAllowed() {     // determine if we can still run, or the camel context is forcing a shutdown     boolean forceShutdown = camelContext.getShutdownStrategy().forceShutdown(this).     if (forceShutdown) {         log.trace("Run not allowed as ShutdownStrategy is forcing shutting down").     }     return !forceShutdown && super.isRunAllowed(). }
false;public;2;5;;public boolean process(final Exchange exchange, final AsyncCallback callback) {     AsyncProcessor[] processors = doGetProcessors().     ReactiveHelper.schedule(new State(exchange, callback, processors)::run).     return false. }
false;public;0;59;;public void run() {     if (copy != null && !shouldFailOver(copy)) {         // remember last good index         lastGoodIndex.set(index).         // and copy the current result to original so it will contain this result of this eip         ExchangeHelper.copyResults(exchange, copy).         log.debug("Failover complete for exchangeId: {} >>> {}", exchange.getExchangeId(), exchange).         callback.done(false).         return.     }     // can we still run     if (!isRunAllowed()) {         log.trace("Run not allowed, will reject executing exchange: {}", exchange).         if (exchange.getException() == null) {             exchange.setException(new RejectedExecutionException()).         }         // we cannot process so invoke callback         callback.done(false).         return.     }     if (copy != null) {         attempts++.         // are we exhausted by attempts?         if (maximumFailoverAttempts > -1 && attempts > maximumFailoverAttempts) {             log.debug("Breaking out of failover after {} failover attempts", attempts).             ExchangeHelper.copyResults(exchange, copy).             callback.done(false).             return.         }         index++.         counter.incrementAndGet().     }     if (index >= processors.length) {         // out of bounds         if (isRoundRobin()) {             log.trace("Failover is round robin enabled and therefore starting from the first endpoint").             index = 0.             counter.set(0).         } else {             // no more processors to try             log.trace("Breaking out of failover as we reached the end of endpoints to use for failover").             ExchangeHelper.copyResults(exchange, copy).             callback.done(false).             return.         }     }     // try again but copy original exchange before we failover     copy = prepareExchangeForFailover(exchange).     AsyncProcessor processor = processors[index].     // process the exchange     log.debug("Processing failover at attempt {} for {}", attempts, copy).     processor.process(copy, doneSync -> ReactiveHelper.schedule(this::run)). }
true;protected;1;4;/**  * Prepares the exchange for failover  *  * @param exchange the exchange  * @return a copy of the exchange to use for failover  */ ;/**  * Prepares the exchange for failover  *  * @param exchange the exchange  * @return a copy of the exchange to use for failover  */ protected Exchange prepareExchangeForFailover(Exchange exchange) {     // use a copy of the exchange to avoid side effects on the original exchange     return ExchangeHelper.createCopy(exchange, true). }
false;public;0;3;;public String getTraceLabel() {     return "failover". }
false;public;0;3;;public ExceptionFailureStatistics getExceptionFailureStatistics() {     return statistics. }
false;public;0;6;;public void reset() {     // reset state     lastGoodIndex.set(-1).     counter.set(-1).     statistics.reset(). }
false;protected;0;7;;@Override protected void doStart() throws Exception {     super.doStart().     // reset state     reset(). }
false;protected;0;5;;@Override protected void doStop() throws Exception {     super.doStop(). // noop }
