commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;4;/**  * Creates the expression based on the string syntax.  *  * @param expression the string syntax <tt>beanRef.methodName</tt> where methodName can be omitted  * @return the expression  */ ;/**  * Creates the expression based on the string syntax.  *  * @param expression the string syntax <tt>beanRef.methodName</tt> where methodName can be omitted  * @return the expression  */ public static Expression bean(String expression) {     BeanLanguage language = new BeanLanguage().     return language.createExpression(expression). }
true;public,static;2;4;/**  * Creates the expression for invoking the bean type.  *  * @param beanType  the bean type to invoke  * @param method optional name of method to invoke for instance to avoid ambiguity  * @return the expression  */ ;/**  * Creates the expression for invoking the bean type.  *  * @param beanType  the bean type to invoke  * @param method optional name of method to invoke for instance to avoid ambiguity  * @return the expression  */ public static Expression bean(Class<?> beanType, String method) {     Object bean = ObjectHelper.newInstance(beanType).     return bean(bean, method). }
true;public,static;2;4;/**  * Creates the expression for invoking the bean type.  *  * @param bean  the bean to invoke  * @param method optional name of method to invoke for instance to avoid ambiguity  * @return the expression  */ ;/**  * Creates the expression for invoking the bean type.  *  * @param bean  the bean to invoke  * @param method optional name of method to invoke for instance to avoid ambiguity  * @return the expression  */ public static Expression bean(Object bean, String method) {     BeanLanguage language = new BeanLanguage().     return language.createExpression(bean, method). }
false;public;1;3;;public Predicate createPredicate(String expression) {     return ExpressionToPredicateAdapter.toPredicate(createExpression(expression)). }
false;public;1;30;;public Expression createExpression(String expression) {     org.apache.camel.util.ObjectHelper.notNull(expression, "expression").     String beanName = expression.     String method = null.     // as the ?method= syntax is very common for the bean component     if (expression.contains("?method=")) {         beanName = StringHelper.before(expression, "?").         method = StringHelper.after(expression, "?method=").     } else {         // first check case :: because of my.own.Bean::method         int doubleColonIndex = expression.indexOf("::").         // need to check that not inside params         int beginOfParameterDeclaration = expression.indexOf("(").         if (doubleColonIndex > 0 && (expression.indexOf("(") < 0 || doubleColonIndex < beginOfParameterDeclaration)) {             beanName = expression.substring(0, doubleColonIndex).             method = expression.substring(doubleColonIndex + 2).         } else {             int idx = expression.indexOf('.').             if (idx > 0) {                 beanName = expression.substring(0, idx).                 method = expression.substring(idx + 1).             }         }     }     return new BeanExpression(beanName, method). }
false;public;2;4;;public Expression createExpression(Object bean, String method) {     org.apache.camel.util.ObjectHelper.notNull(bean, "bean").     return new BeanExpression(bean, method). }
false;public;0;3;;public boolean isSingleton() {     return true. }
