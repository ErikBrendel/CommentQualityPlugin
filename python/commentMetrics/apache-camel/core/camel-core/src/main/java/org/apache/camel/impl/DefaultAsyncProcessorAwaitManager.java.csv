commented;modifiers;parameterAmount;loc;comment;code
true;public;2;7;/**  * Calls the async version of the processor's process method and waits  * for it to complete before returning. This can be used by {@link AsyncProcessor}  * objects to implement their sync version of the process method.  * <p/>  * <b>Important:</b> This method is discouraged to be used, as its better to invoke the asynchronous  * {@link AsyncProcessor#process(org.apache.camel.Exchange, org.apache.camel.AsyncCallback)} method, whenever possible.  *  * @param processor the processor  * @param exchange  the exchange  * @throws Exception can be thrown if waiting is interrupted  */ ;/**  * Calls the async version of the processor's process method and waits  * for it to complete before returning. This can be used by {@link AsyncProcessor}  * objects to implement their sync version of the process method.  * <p/>  * <b>Important:</b> This method is discouraged to be used, as its better to invoke the asynchronous  * {@link AsyncProcessor#process(org.apache.camel.Exchange, org.apache.camel.AsyncCallback)} method, whenever possible.  *  * @param processor the processor  * @param exchange  the exchange  * @throws Exception can be thrown if waiting is interrupted  */ public void process(final AsyncProcessor processor, final Exchange exchange) {     CountDownLatch latch = new CountDownLatch(1).     processor.process(exchange, doneSync -> countDown(exchange, latch)).     if (latch.getCount() > 0) {         await(exchange, latch).     } }
false;public;2;43;;public void await(Exchange exchange, CountDownLatch latch) {     // Early exit for pending reactive queued work     do {         if (latch.getCount() <= 0) {             return.         }     } while (ReactiveHelper.executeFromQueue()).     log.trace("Waiting for asynchronous callback before continuing for exchangeId: {} -> {}", exchange.getExchangeId(), exchange).     try {         if (statistics.isStatisticsEnabled()) {             blockedCounter.incrementAndGet().         }         inflight.put(exchange, new AwaitThreadEntry(Thread.currentThread(), exchange, latch)).         latch.await().         log.trace("Asynchronous callback received, will continue routing exchangeId: {} -> {}", exchange.getExchangeId(), exchange).     } catch (InterruptedException e) {         log.trace("Interrupted while waiting for callback, will continue routing exchangeId: {} -> {}", exchange.getExchangeId(), exchange).         exchange.setException(e).     } finally {         AwaitThread thread = inflight.remove(exchange).         if (statistics.isStatisticsEnabled() && thread != null) {             long time = thread.getWaitDuration().             long total = totalDuration.get() + time.             totalDuration.set(total).             if (time < minDuration.get()) {                 minDuration.set(time).             } else if (time > maxDuration.get()) {                 maxDuration.set(time).             }             // update mean             long count = blockedCounter.get().             long mean = count > 0 ? total / count : 0.             meanDuration.set(mean).         }     } }
false;public;2;4;;public void countDown(Exchange exchange, CountDownLatch latch) {     log.trace("Asynchronous callback received for exchangeId: {}", exchange.getExchangeId()).     latch.countDown(). }
false;public;0;4;;@Override public int size() {     return inflight.size(). }
false;public;0;4;;@Override public Collection<AwaitThread> browse() {     return Collections.unmodifiableCollection(inflight.values()). }
false;public;1;16;;@Override public void interrupt(String exchangeId) {     // need to find the exchange with the given exchange id     Exchange found = null.     for (AsyncProcessorAwaitManager.AwaitThread entry : browse()) {         Exchange exchange = entry.getExchange().         if (exchangeId.equals(exchange.getExchangeId())) {             found = exchange.             break.         }     }     if (found != null) {         interrupt(found).     } }
false;public;1;31;;@Override public void interrupt(Exchange exchange) {     AwaitThreadEntry entry = (AwaitThreadEntry) inflight.get(exchange).     if (entry != null) {         try {             StringBuilder sb = new StringBuilder().             sb.append("Interrupted while waiting for asynchronous callback, will release the following blocked thread which was waiting for exchange to finish processing with exchangeId: ").             sb.append(exchange.getExchangeId()).             sb.append("\n").             sb.append(dumpBlockedThread(entry)).             // dump a route stack trace of the exchange             String routeStackTrace = MessageHelper.dumpMessageHistoryStacktrace(exchange, exchangeFormatter, false).             if (routeStackTrace != null) {                 sb.append(routeStackTrace).             }             log.warn(sb.toString()).         } catch (Exception e) {             throw RuntimeCamelException.wrapRuntimeCamelException(e).         } finally {             if (statistics.isStatisticsEnabled()) {                 interruptedCounter.incrementAndGet().             }             exchange.setException(new RejectedExecutionException("Interrupted while waiting for asynchronous callback for exchangeId: " + exchange.getExchangeId())).             exchange.setProperty(Exchange.INTERRUPTED, Boolean.TRUE).             entry.getLatch().countDown().         }     } }
false;public;0;3;;public boolean isInterruptThreadsWhileStopping() {     return interruptThreadsWhileStopping. }
false;public;1;3;;public void setInterruptThreadsWhileStopping(boolean interruptThreadsWhileStopping) {     this.interruptThreadsWhileStopping = interruptThreadsWhileStopping. }
false;public;0;3;;public Statistics getStatistics() {     return statistics. }
false;protected;0;4;;@Override protected void doStart() throws Exception { // noop }
false;protected;0;30;;@Override protected void doStop() throws Exception {     Collection<AwaitThread> threads = browse().     int count = threads.size().     if (count > 0) {         log.warn("Shutting down while there are still {} inflight threads currently blocked.", count).         StringBuilder sb = new StringBuilder().         for (AwaitThread entry : threads) {             sb.append(dumpBlockedThread(entry)).         }         if (isInterruptThreadsWhileStopping()) {             log.warn("The following threads are blocked and will be interrupted so the threads are released:\n{}", sb).             for (AwaitThread entry : threads) {                 try {                     interrupt(entry.getExchange()).                 } catch (Throwable e) {                     log.warn("Error while interrupting thread: " + entry.getBlockedThread().getName() + ". This exception is ignored.", e).                 }             }         } else {             log.warn("The following threads are blocked, and may reside in the JVM:\n{}", sb).         }     } else {         log.debug("Shutting down with no inflight threads.").     }     inflight.clear(). }
false;private,static;1;13;;private static String dumpBlockedThread(AwaitThread entry) {     StringBuilder sb = new StringBuilder().     sb.append("\n").     sb.append("Blocked Thread\n").     sb.append("---------------------------------------------------------------------------------------------------------------------------------------\n").     sb.append(style("Id:")).append(entry.getBlockedThread().getId()).append("\n").     sb.append(style("Name:")).append(entry.getBlockedThread().getName()).append("\n").     sb.append(style("RouteId:")).append(safeNull(entry.getRouteId())).append("\n").     sb.append(style("NodeId:")).append(safeNull(entry.getNodeId())).append("\n").     sb.append(style("Duration:")).append(entry.getWaitDuration()).append(" msec.\n").     return sb.toString(). }
false;private,static;1;3;;private static String style(String label) {     return String.format("\t%-20s", label). }
false;private,static;1;3;;private static String safeNull(Object value) {     return value != null ? value.toString() : "". }
false;public;0;4;;@Override public Thread getBlockedThread() {     return thread. }
false;public;0;4;;@Override public Exchange getExchange() {     return exchange. }
false;public;0;4;;@Override public long getWaitDuration() {     return System.currentTimeMillis() - start. }
false;public;0;8;;@Override public String getRouteId() {     MessageHistory lastMessageHistory = getLastMessageHistory().     if (lastMessageHistory == null) {         return null.     }     return lastMessageHistory.getRouteId(). }
false;public;0;8;;@Override public String getNodeId() {     NamedNode node = getNode().     if (node == null) {         return null.     }     return node.getId(). }
false;public;0;3;;public CountDownLatch getLatch() {     return latch. }
false;private;0;7;;private NamedNode getNode() {     MessageHistory lastMessageHistory = getLastMessageHistory().     if (lastMessageHistory == null) {         return null.     }     return lastMessageHistory.getNode(). }
false;private;0;7;;private MessageHistory getLastMessageHistory() {     LinkedList<MessageHistory> list = getMessageHistories().     if (list == null || list.isEmpty()) {         return null.     }     return list.getLast(). }
false;private;0;3;;private LinkedList<MessageHistory> getMessageHistories() {     return exchange.getProperty(Exchange.MESSAGE_HISTORY, LinkedList.class). }
false;public;0;4;;@Override public String toString() {     return "AwaitThreadEntry[name=" + thread.getName() + ", exchangeId=" + exchange.getExchangeId() + "]". }
false;public;0;4;;@Override public long getThreadsBlocked() {     return blockedCounter.get(). }
false;public;0;4;;@Override public long getThreadsInterrupted() {     return interruptedCounter.get(). }
false;public;0;4;;@Override public long getTotalDuration() {     return totalDuration.get(). }
false;public;0;4;;@Override public long getMinDuration() {     return minDuration.get(). }
false;public;0;4;;@Override public long getMaxDuration() {     return maxDuration.get(). }
false;public;0;4;;@Override public long getMeanDuration() {     return meanDuration.get(). }
false;public;0;9;;@Override public void reset() {     blockedCounter.set(0).     interruptedCounter.set(0).     totalDuration.set(0).     minDuration.set(0).     maxDuration.set(0).     meanDuration.set(0). }
false;public;0;4;;@Override public boolean isStatisticsEnabled() {     return statisticsEnabled. }
false;public;1;4;;@Override public void setStatisticsEnabled(boolean statisticsEnabled) {     this.statisticsEnabled = statisticsEnabled. }
false;public;0;5;;@Override public String toString() {     return String.format("AsyncProcessAwaitManager utilization[blocked=%s, interrupted=%s, total=%s min=%s, max=%s, mean=%s]", getThreadsBlocked(), getThreadsInterrupted(), getTotalDuration(), getMinDuration(), getMaxDuration(), getMeanDuration()). }
