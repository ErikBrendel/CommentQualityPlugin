commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;3;/**  * Resolves the expression/predicate whether it refers to an external script on the file/classpath etc.  * This requires to use the prefix <tt>resource:</tt> such as <tt>resource:classpath:com/foo/myscript.groovy</tt>,  * <tt>resource:file:/var/myscript.groovy</tt>.  * <p/>  * If not then the returned value is returned as-is.  */ ;/**  * Resolves the expression/predicate whether it refers to an external script on the file/classpath etc.  * This requires to use the prefix <tt>resource:</tt> such as <tt>resource:classpath:com/foo/myscript.groovy</tt>,  * <tt>resource:file:/var/myscript.groovy</tt>.  * <p/>  * If not then the returned value is returned as-is.  */ public static String resolveOptionalExternalScript(CamelContext camelContext, String expression) {     return resolveOptionalExternalScript(camelContext, null, expression). }
true;public,static;3;38;/**  * Resolves the expression/predicate whether it refers to an external script on the file/classpath etc.  * This requires to use the prefix <tt>resource:</tt> such as <tt>resource:classpath:com/foo/myscript.groovy</tt>,  * <tt>resource:file:/var/myscript.groovy</tt>.  * <p/>  * If not then the returned value is returned as-is.  * <p/>  * If the exchange is provided (not null), then the external script can be referred via simple language for dynamic values, etc.  * <tt>resource:classpath:${header.myFileName}</tt>  */ ;/**  * Resolves the expression/predicate whether it refers to an external script on the file/classpath etc.  * This requires to use the prefix <tt>resource:</tt> such as <tt>resource:classpath:com/foo/myscript.groovy</tt>,  * <tt>resource:file:/var/myscript.groovy</tt>.  * <p/>  * If not then the returned value is returned as-is.  * <p/>  * If the exchange is provided (not null), then the external script can be referred via simple language for dynamic values, etc.  * <tt>resource:classpath:${header.myFileName}</tt>  */ public static String resolveOptionalExternalScript(CamelContext camelContext, Exchange exchange, String expression) {     if (expression == null) {         return null.     }     String external = expression.     // must be one line only     int newLines = StringHelper.countChar(expression, '\n').     if (newLines > 1) {         // okay then just use as-is         return expression.     }     // must start with resource: to denote an external resource     if (external.startsWith("resource:")) {         external = external.substring(9).         if (ResourceHelper.hasScheme(external)) {             if (exchange != null && SimpleLanguage.hasSimpleFunction(external)) {                 Language simple = exchange.getContext().resolveLanguage("simple").                 external = simple.createExpression(external).evaluate(exchange, String.class).             }             InputStream is = null.             try {                 is = ResourceHelper.resolveMandatoryResourceAsInputStream(camelContext, external).                 expression = camelContext.getTypeConverter().convertTo(String.class, is).             } catch (IOException e) {                 throw new RuntimeCamelException("Cannot load resource " + external, e).             } finally {                 IOHelper.close(is).             }         }     }     return expression. }
