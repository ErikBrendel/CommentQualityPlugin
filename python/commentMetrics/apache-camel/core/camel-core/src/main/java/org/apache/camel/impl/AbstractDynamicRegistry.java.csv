commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Override public void start() throws Exception {     if (dynamicMap instanceof LRUCache) {         ((LRUCache) dynamicMap).resetStatistics().     } }
false;public;1;13;;@Override public V get(Object o) {     // try static map first     V answer = staticMap.get(o).     if (answer == null) {         answer = dynamicMap.get(o).         if (answer != null && (context.isSetupRoutes() || context.getRouteController().isStartingRoutes())) {             dynamicMap.remove(o).             staticMap.put((K) o, answer).         }     }     return answer. }
false;public;2;26;;@Override public V put(K key, V transformer) {     // at first we must see if the key already exists and then replace it back, so it stays the same spot     V answer = staticMap.remove(key).     if (answer != null) {         // replace existing         staticMap.put(key, transformer).         return answer.     }     answer = dynamicMap.remove(key).     if (answer != null) {         // replace existing         dynamicMap.put(key, transformer).         return answer.     }     // we want transformers to be static if they are part of setting up or starting routes     if (context.isSetupRoutes() || context.getRouteController().isStartingRoutes()) {         answer = staticMap.put(key, transformer).     } else {         answer = dynamicMap.put(key, transformer).     }     return answer. }
false;public;1;4;;@Override public boolean containsKey(Object o) {     return staticMap.containsKey(o) || dynamicMap.containsKey(o). }
false;public;1;4;;@Override public boolean containsValue(Object o) {     return staticMap.containsValue(o) || dynamicMap.containsValue(o). }
false;public;0;4;;@Override public int size() {     return staticMap.size() + dynamicMap.size(). }
false;public;0;3;;public int staticSize() {     return staticMap.size(). }
false;public;0;3;;public int dynamicSize() {     return dynamicMap.size(). }
false;public;0;4;;@Override public boolean isEmpty() {     return staticMap.isEmpty() && dynamicMap.isEmpty(). }
false;public;1;8;;@Override public V remove(Object o) {     V answer = staticMap.remove(o).     if (answer == null) {         answer = dynamicMap.remove(o).     }     return answer. }
false;public;0;5;;@Override public void clear() {     staticMap.clear().     dynamicMap.clear(). }
false;public;0;6;;@Override public Iterator<Entry<K, V>> iterator() {     return new CompoundIterator<>(Arrays.asList(staticMap.entrySet().iterator(), dynamicMap.entrySet().iterator())). }
false;public;0;4;;@Override public int size() {     return staticMap.size() + dynamicMap.size(). }
false;public;0;16;;@Override public Set<Entry<K, V>> entrySet() {     return new AbstractSet<Entry<K, V>>() {          @Override         public Iterator<Entry<K, V>> iterator() {             return new CompoundIterator<>(Arrays.asList(staticMap.entrySet().iterator(), dynamicMap.entrySet().iterator())).         }          @Override         public int size() {             return staticMap.size() + dynamicMap.size().         }     }. }
false;public;0;3;;public int getMaximumCacheSize() {     return maxCacheSize. }
true;public;0;4;/**  * Purges the cache  */ ;/**  * Purges the cache  */ public void purge() {     // only purge the dynamic part     dynamicMap.clear(). }
false;public;0;5;;public void cleanUp() {     if (dynamicMap instanceof LRUCache) {         ((LRUCache) dynamicMap).cleanUp().     } }
false;public;1;3;;public boolean isStatic(K key) {     return staticMap.containsKey(key). }
false;public;1;3;;public boolean isDynamic(K key) {     return dynamicMap.containsKey(key). }
false;public;0;5;;@Override public void stop() throws Exception {     ServiceHelper.stopService(staticMap.values(), dynamicMap.values()).     purge(). }
false;public;0;4;;@Override public String toString() {     return "Registry for " + context.getName() + ", capacity: " + maxCacheSize. }
