commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;// ********************************* // Properties // ********************************* public BackOff getDefaultBackOff() {     return defaultBackOff. }
true;public;1;3;/**  * Sets the default back-off.  */ ;/**  * Sets the default back-off.  */ public void setDefaultBackOff(BackOff defaultBackOff) {     this.defaultBackOff = defaultBackOff. }
false;public;0;3;;public Map<String, BackOff> getBackOffConfigurations() {     return backOffConfigurations. }
true;public;1;3;/**  * Set the back-off for the given IDs.  */ ;/**  * Set the back-off for the given IDs.  */ public void setBackOffConfigurations(Map<String, BackOff> backOffConfigurations) {     this.backOffConfigurations = backOffConfigurations. }
false;public;1;3;;public BackOff getBackOff(String id) {     return backOffConfigurations.getOrDefault(id, defaultBackOff). }
true;public;2;3;/**  * Sets the back-off to be applied to the given <code>id</code>.  */ ;/**  * Sets the back-off to be applied to the given <code>id</code>.  */ public void setBackOff(String id, BackOff backOff) {     backOffConfigurations.put(id, backOff). }
false;public;0;3;;public Duration getInitialDelay() {     return initialDelay. }
true;public;1;3;/**  * Set the amount of time the route controller should wait before to start  * the routes after the camel context is started or after the route is  * initialized if the route is created after the camel context is started.  *  * @param initialDelay the initial delay.  */ ;/**  * Set the amount of time the route controller should wait before to start  * the routes after the camel context is started or after the route is  * initialized if the route is created after the camel context is started.  *  * @param initialDelay the initial delay.  */ public void setInitialDelay(Duration initialDelay) {     this.initialDelay = initialDelay. }
true;public;2;3;/**  * #see {@link this#setInitialDelay(Duration)}  *  * @param initialDelay the initial delay amount.  */ ;/**  * #see {@link this#setInitialDelay(Duration)}  *  * @param initialDelay the initial delay amount.  */ public void setInitialDelay(long initialDelay, TimeUnit initialDelayUnit) {     this.initialDelay = Duration.ofMillis(initialDelayUnit.toMillis(initialDelay)). }
true;public;1;3;/**  * #see {@link this#setInitialDelay(Duration)}  *  * @param initialDelay the initial delay in milliseconds.  */ ;/**  * #see {@link this#setInitialDelay(Duration)}  *  * @param initialDelay the initial delay in milliseconds.  */ public void setInitialDelay(long initialDelay) {     this.initialDelay = Duration.ofMillis(initialDelay). }
true;public;1;3;/**  * Add a filter used to determine the routes to supervise.  */ ;/**  * Add a filter used to determine the routes to supervise.  */ public void addFilter(Filter filter) {     this.filters.add(filter). }
true;public;1;4;/**  * Sets the filters user to determine the routes to supervise.  */ ;/**  * Sets the filters user to determine the routes to supervise.  */ public void setFilters(Collection<Filter> filters) {     this.filters.clear().     this.filters.addAll(filters). }
false;public;0;3;;public Collection<Filter> getFilters() {     return Collections.unmodifiableList(filters). }
false;public;1;3;;public Optional<BackOffTimer.Task> getBackOffContext(String id) {     return routeManager.getBackOffContext(id). }
false;protected;0;12;;// ********************************* // Lifecycle // ********************************* @Override protected void doStart() throws Exception {     final CamelContext context = getCamelContext().     context.setAutoStartup(false).     context.addRoutePolicyFactory(new ManagedRoutePolicyFactory()).     context.addStartupListener(this.listener).     context.getManagementStrategy().addEventNotifier(this.listener).     executorService = context.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "SupervisingRouteController").     timer = new BackOffTimer(executorService). }
false;protected;0;8;;@Override protected void doStop() throws Exception {     if (getCamelContext() != null && executorService != null) {         getCamelContext().getExecutorServiceManager().shutdown(executorService).         executorService = null.         timer = null.     } }
false;protected;0;6;;@Override protected void doShutdown() throws Exception {     if (getCamelContext() != null) {         getCamelContext().getManagementStrategy().removeEventNotifier(listener).     } }
false;public;1;12;;// ********************************* // Route management // ********************************* @Override public void startRoute(String routeId) throws Exception {     final Optional<RouteHolder> route = routes.stream().filter(r -> r.getId().equals(routeId)).findFirst().     if (!route.isPresent()) {         // This route is unknown to this controller, apply default behaviour         // from super class.         super.startRoute(routeId).     } else {         doStartRoute(route.get(), true, r -> super.startRoute(routeId)).     } }
false;public;1;12;;@Override public void stopRoute(String routeId) throws Exception {     final Optional<RouteHolder> route = routes.stream().filter(r -> r.getId().equals(routeId)).findFirst().     if (!route.isPresent()) {         // This route is unknown to this controller, apply default behaviour         // from super class.         super.stopRoute(routeId).     } else {         doStopRoute(route.get(), true, r -> super.stopRoute(routeId)).     } }
false;public;3;12;;@Override public void stopRoute(String routeId, long timeout, TimeUnit timeUnit) throws Exception {     final Optional<RouteHolder> route = routes.stream().filter(r -> r.getId().equals(routeId)).findFirst().     if (!route.isPresent()) {         // This route is unknown to this controller, apply default behaviour         // from super class.         super.stopRoute(routeId, timeout, timeUnit).     } else {         doStopRoute(route.get(), true, r -> super.stopRoute(r.getId(), timeout, timeUnit)).     } }
false;public;4;15;;@Override public boolean stopRoute(String routeId, long timeout, TimeUnit timeUnit, boolean abortAfterTimeout) throws Exception {     final Optional<RouteHolder> route = routes.stream().filter(r -> r.getId().equals(routeId)).findFirst().     if (!route.isPresent()) {         // from super class.         return super.stopRoute(routeId, timeout, timeUnit, abortAfterTimeout).     } else {         final AtomicBoolean result = new AtomicBoolean(false).         doStopRoute(route.get(), true, r -> result.set(super.stopRoute(r.getId(), timeout, timeUnit, abortAfterTimeout))).         return result.get().     } }
false;public;1;12;;@Override public void suspendRoute(String routeId) throws Exception {     final Optional<RouteHolder> route = routes.stream().filter(r -> r.getId().equals(routeId)).findFirst().     if (!route.isPresent()) {         // This route is unknown to this controller, apply default behaviour         // from super class.         super.suspendRoute(routeId).     } else {         doStopRoute(route.get(), true, r -> super.suspendRoute(r.getId())).     } }
false;public;3;12;;@Override public void suspendRoute(String routeId, long timeout, TimeUnit timeUnit) throws Exception {     final Optional<RouteHolder> route = routes.stream().filter(r -> r.getId().equals(routeId)).findFirst().     if (!route.isPresent()) {         // This route is unknown to this controller, apply default behaviour         // from super class.         super.suspendRoute(routeId, timeout, timeUnit).     } else {         doStopRoute(route.get(), true, r -> super.suspendRoute(r.getId(), timeout, timeUnit)).     } }
false;public;1;12;;@Override public void resumeRoute(String routeId) throws Exception {     final Optional<RouteHolder> route = routes.stream().filter(r -> r.getId().equals(routeId)).findFirst().     if (!route.isPresent()) {         // This route is unknown to this controller, apply default behaviour         // from super class.         super.resumeRoute(routeId).     } else {         doStartRoute(route.get(), true, r -> super.startRoute(routeId)).     } }
false;public;0;6;;@Override public Collection<Route> getControlledRoutes() {     return routes.stream().map(RouteHolder::get).collect(Collectors.toList()). }
false;private;3;17;;// ********************************* // Helpers // ********************************* private void doStopRoute(RouteHolder route, boolean checker, ThrowingConsumer<RouteHolder, Exception> consumer) throws Exception {     synchronized (lock) {         if (checker) {             // remove it from checked routes so the route don't get started             // by the routes manager task as a manual operation on the routes             // indicates that the route is then managed manually             routeManager.release(route).         }         LOGGER.info("Route {} has been requested to stop: stop supervising it", route.getId()).         // Mark the route as un-managed         route.getContext().setRouteController(null).         consumer.accept(route).     } }
false;private;3;26;;private void doStartRoute(RouteHolder route, boolean checker, ThrowingConsumer<RouteHolder, Exception> consumer) throws Exception {     synchronized (lock) {         // If a manual start is triggered, then the controller should take         // care that the route is started         route.getContext().setRouteController(this).         try {             if (checker) {                 // remove it from checked routes as a manual start may trigger                 // a new back off task if start fails                 routeManager.release(route).             }             consumer.accept(route).         } catch (Exception e) {             if (checker) {                 // if start fails the route is moved to controller supervision                 // so its get (eventually) restarted                 routeManager.start(route).             }             throw e.         }     } }
false;private;0;28;;private void startRoutes() {     if (!isRunAllowed()) {         return.     }     final List<String> routeList.     synchronized (lock) {         routeList = routes.stream().filter(r -> r.getStatus() == ServiceStatus.Stopped).map(RouteHolder::getId).collect(Collectors.toList()).     }     for (String route : routeList) {         try {             startRoute(route).         } catch (Exception e) {         // ignored, exception handled by startRoute         }     }     LOGGER.info("Total managed routes: {} of which {} successfully started and {} re-starting", routes.size(), routes.stream().filter(r -> r.getStatus() == ServiceStatus.Started).count(), routeManager.routes.size()). }
false;private,synchronized;0;22;;private synchronized void stopRoutes() {     if (!isRunAllowed()) {         return.     }     final List<String> routeList.     synchronized (lock) {         routeList = routes.stream().filter(r -> r.getStatus() == ServiceStatus.Started).map(RouteHolder::getId).collect(Collectors.toList()).     }     for (String route : routeList) {         try {             stopRoute(route).         } catch (Exception e) {         // ignored, exception handled by stopRoute         }     } }
false;;1;46;;void start(RouteHolder route) {     route.getContext().setRouteController(SupervisingRouteController.this).     routes.computeIfAbsent(route, r -> {         BackOff backOff = getBackOff(r.getId()).         logger.info("Start supervising route: {} with back-off: {}", r.getId(), backOff).         BackOffTimer.Task task = timer.schedule(backOff, context -> {             try {                 logger.info("Try to restart route: {}", r.getId()).                 doStartRoute(r, false, rx -> SupervisingRouteController.super.startRoute(rx.getId())).                 return false.             } catch (Exception e) {                 return true.             }         }).         task.whenComplete((backOffTask, throwable) -> {             if (backOffTask == null || backOffTask.getStatus() != BackOffTimer.Task.Status.Active) {                 synchronized (lock) {                     final ServiceStatus status = route.getStatus().                     final boolean stopped = status.isStopped() || status.isStopping().                     if (backOffTask != null && backOffTask.getStatus() == BackOffTimer.Task.Status.Exhausted && stopped) {                         LOGGER.info("Back-off for route {} is exhausted, no more attempts will be made and stop supervising it", route.getId()).                         r.getContext().setRouteController(null).                     }                 }             }             routes.remove(r).         }).         return task.     }). }
false;;1;9;;boolean release(RouteHolder route) {     BackOffTimer.Task task = routes.remove(route).     if (task != null) {         LOGGER.info("Cancel restart task for route {}", route.getId()).         task.cancel().     }     return task != null. }
false;;0;4;;void clear() {     routes.values().forEach(BackOffTimer.Task::cancel).     routes.clear(). }
false;public;1;6;;public Optional<BackOffTimer.Task> getBackOffContext(String id) {     return routes.entrySet().stream().filter(e -> ObjectHelper.equal(e.getKey().getId(), id)).findFirst().map(Map.Entry::getValue). }
false;public;0;4;;@Override public String getId() {     return this.route.getId(). }
false;public;0;3;;public Route get() {     return this.route. }
false;public;0;3;;public RouteContext getContext() {     return this.route.getRouteContext(). }
false;public;0;3;;public RouteDefinition getDefinition() {     return (RouteDefinition) this.route.getRouteContext().getRoute(). }
false;public;0;3;;public ServiceStatus getStatus() {     return getContext().getCamelContext().getRouteController().getRouteStatus(getId()). }
false;public;0;3;;public int getInitializationOrder() {     return order. }
false;public;0;8;;public int getStartupOrder() {     Integer order = getDefinition().getStartupOrder().     if (order == null) {         order = Integer.MAX_VALUE.     }     return order. }
false;public;1;9;;@Override public int compareTo(RouteHolder o) {     int answer = Integer.compare(getStartupOrder(), o.getStartupOrder()).     if (answer == 0) {         answer = Integer.compare(getInitializationOrder(), o.getInitializationOrder()).     }     return answer. }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     return this.route.equals(((RouteHolder) o).route). }
false;public;0;4;;@Override public int hashCode() {     return route.hashCode(). }
false;public;3;4;;@Override public RoutePolicy createRoutePolicy(CamelContext camelContext, String routeId, NamedNode route) {     return policy. }
false;private;1;11;;private void startRoute(RouteHolder holder) {     try {         SupervisingRouteController.this.doStartRoute(holder, true, r -> SupervisingRouteController.super.startRoute(r.getId())).     } catch (Exception e) {         throw new RuntimeCamelException(e).     } }
false;public;1;37;;@Override public void onInit(Route route) {     final String autoStartup = ((RouteDefinition) route.getRouteContext().getRoute()).getAutoStartup().     if (ObjectHelper.equalIgnoreCase("false", autoStartup)) {         LOGGER.info("Route {} won't be supervised (reason: has explicit auto-startup flag set to false)", route.getId()).         return.     }     for (Filter filter : filters) {         FilterResult result = filter.apply(route).         if (!result.supervised()) {             LOGGER.info("Route {} won't be supervised (reason: {})", route.getId(), result.reason()).             return.         }     }     RouteHolder holder = new RouteHolder(route, routeCount.incrementAndGet()).     if (routes.add(holder)) {         holder.getContext().setRouteController(SupervisingRouteController.this).         holder.getDefinition().setAutoStartup("false").         if (contextStarted.get()) {             LOGGER.info("Context is already started: attempt to start route {}", route.getId()).             // Eventually delay the startup of the route a later time             if (initialDelay.toMillis() > 0) {                 LOGGER.debug("Route {} will be started in {}", holder.getId(), initialDelay).                 executorService.schedule(() -> startRoute(holder), initialDelay.toMillis(), TimeUnit.MILLISECONDS).             } else {                 startRoute(holder).             }         } else {             LOGGER.info("Context is not yet started: defer route {} start", holder.getId()).         }     } }
false;public;1;8;;@Override public void onRemove(Route route) {     synchronized (lock) {         routes.removeIf(r -> ObjectHelper.equal(r.get(), route) || ObjectHelper.equal(r.getId(), route.getId())).     } }
false;public;1;3;;@Override public void onStart(Route route) { }
false;public;1;3;;@Override public void onStop(Route route) { }
false;public;1;3;;@Override public void onSuspend(Route route) { }
false;public;1;3;;@Override public void onResume(Route route) { }
false;public;2;4;;@Override public void onExchangeBegin(Route route, Exchange exchange) { // NO-OP }
false;public;2;4;;@Override public void onExchangeDone(Route route, Exchange exchange) { // NO-OP }
false;public;1;4;;@Override public void notify(CamelEvent event) throws Exception {     onCamelContextStarted(). }
false;public;1;4;;@Override public boolean isEnabled(CamelEvent event) {     return event instanceof CamelContextStartedEvent. }
false;public;2;16;;@Override public void onCamelContextStarted(CamelContext context, boolean alreadyStarted) throws Exception {     if (alreadyStarted) {         // Invoke it only if the context was already started as this         // method is not invoked at last event as documented but after         // routes warm-up so this is useful for routes deployed after         // the camel context has been started-up. For standard routes         // configuration the notification of the camel context started         // is provided by EventNotifier.         //          // We should check why this callback is not invoked at latest         // stage, or maybe rename it as it is misleading and provide a         // better alternative for intercept camel events.         onCamelContextStarted().     } }
false;private;0;15;;private void onCamelContextStarted() {     // startup     if (contextStarted.compareAndSet(false, true)) {         // Eventually delay the startup of the routes a later time         if (initialDelay.toMillis() > 0) {             LOGGER.debug("Routes will be started in {}", initialDelay).             executorService.schedule(SupervisingRouteController.this::startRoutes, initialDelay.toMillis(), TimeUnit.MILLISECONDS).         } else {             startRoutes().         }     } }
false;public;0;3;;public boolean supervised() {     return controlled. }
false;public;0;3;;public String reason() {     return reason. }
