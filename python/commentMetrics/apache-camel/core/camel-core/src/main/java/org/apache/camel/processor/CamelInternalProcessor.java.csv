commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * Adds an {@link CamelInternalProcessorAdvice} advice to the list of advices to execute by this internal processor.  *  * @param advice  the advice to add  */ ;/**  * Adds an {@link CamelInternalProcessorAdvice} advice to the list of advices to execute by this internal processor.  *  * @param advice  the advice to add  */ public void addAdvice(CamelInternalProcessorAdvice<?> advice) {     advices.add(advice).     // ensure advices are sorted so they are in the order we want     advices.sort(OrderedComparator.get()). }
true;public;1;9;/**  * Gets the advice with the given type.  *  * @param type  the type of the advice  * @return the advice if exists, or <tt>null</tt> if no advices has been added with the given type.  */ ;/**  * Gets the advice with the given type.  *  * @param type  the type of the advice  * @return the advice if exists, or <tt>null</tt> if no advices has been added with the given type.  */ public <T> T getAdvice(Class<T> type) {     for (CamelInternalProcessorAdvice task : advices) {         Object advice = CamelInternalProcessorAdvice.unwrap(task).         if (type.isInstance(advice)) {             return type.cast(advice).         }     }     return null. }
false;public;2;119;;@Override public boolean process(Exchange exchange, AsyncCallback ocallback) {     if (processor == null || !continueProcessing(exchange)) {         // no processor or we should not continue then we are done         ocallback.done(true).         return true.     }     // optimise to use object array for states     final Object[] states = new Object[advices.size()].     // optimise for loop using index access to avoid creating iterator object     for (int i = 0. i < advices.size(). i++) {         CamelInternalProcessorAdvice task = advices.get(i).         try {             Object state = task.before(exchange).             states[i] = state.         } catch (Throwable e) {             exchange.setException(e).             ocallback.done(true).             return true.         }     }     // create internal callback which will execute the advices in reverse order when done     AsyncCallback callback = doneSync -> {         try {             for (int i = advices.size() - 1. i >= 0. i--) {                 CamelInternalProcessorAdvice task = advices.get(i).                 Object state = states[i].                 try {                     task.after(exchange, state).                 } catch (Throwable e) {                     exchange.setException(e).                 // allow all advices to complete even if there was an exception                 }             }         } finally {             // ----------------------------------------------------------             // CAMEL END USER - DEBUG ME HERE +++ START +++             // ----------------------------------------------------------             // callback must be called             ReactiveHelper.callback(ocallback).         // ----------------------------------------------------------         // CAMEL END USER - DEBUG ME HERE +++ END +++         // ----------------------------------------------------------         }     }.     if (exchange.isTransacted()) {         // must be synchronized for transacted exchanges         if (log.isTraceEnabled()) {             if (exchange.isTransacted()) {                 log.trace("Transacted Exchange must be routed synchronously for exchangeId: {} -> {}", exchange.getExchangeId(), exchange).             } else {                 log.trace("Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}", exchange.getExchangeId(), exchange).             }         }         // ----------------------------------------------------------         try {             processor.process(exchange).         } catch (Throwable e) {             exchange.setException(e).         }         // ----------------------------------------------------------         // CAMEL END USER - DEBUG ME HERE +++ END +++         // ----------------------------------------------------------         callback.done(true).         return true.     } else {         final UnitOfWork uow = exchange.getUnitOfWork().         // allow unit of work to wrap callback in case it need to do some special work         // for example the MDCUnitOfWork         AsyncCallback async = callback.         if (uow != null) {             async = uow.beforeProcess(processor, exchange, callback).         }         // ----------------------------------------------------------         if (log.isTraceEnabled()) {             log.trace("Processing exchange for exchangeId: {} -> {}", exchange.getExchangeId(), exchange).         }         processor.process(exchange, async).         // ----------------------------------------------------------         // CAMEL END USER - DEBUG ME HERE +++ END +++         // ----------------------------------------------------------         ReactiveHelper.schedule(() -> {             // execute any after processor work (in current thread, not in the callback)             if (uow != null) {                 uow.afterProcess(processor, exchange, callback, false).             }             if (log.isTraceEnabled()) {                 log.trace("Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}", exchange.getExchangeId(), exchange).             }         }, "CamelInternalProcessor - UnitOfWork - afterProcess - " + processor + " - " + exchange.getExchangeId()).         return false.     } }
false;public;0;4;;@Override public String toString() {     return processor != null ? processor.toString() : super.toString(). }
true;protected;1;24;/**  * Strategy to determine if we should continue processing the {@link Exchange}.  */ ;/**  * Strategy to determine if we should continue processing the {@link Exchange}.  */ protected boolean continueProcessing(Exchange exchange) {     Object stop = exchange.getProperty(Exchange.ROUTE_STOP).     if (stop != null) {         boolean doStop = exchange.getContext().getTypeConverter().convertTo(Boolean.class, stop).         if (doStop) {             log.debug("Exchange is marked to stop routing: {}", exchange).             return false.         }     }     // determine if we can still run, or the camel context is forcing a shutdown     boolean forceShutdown = exchange.getContext().getShutdownStrategy().forceShutdown(this).     if (forceShutdown) {         String msg = "Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: " + exchange.         log.debug(msg).         if (exchange.getException() == null) {             exchange.setException(new RejectedExecutionException(msg)).         }         return false.     }     // yes we can continue     return true. }
false;public;1;3;;public void setRoute(Route route) {     this.route = route. }
false;public;1;8;;@Override public Object before(Exchange exchange) throws Exception {     UnitOfWork uow = exchange.getUnitOfWork().     if (uow != null) {         uow.beforeRoute(exchange, route).     }     return null. }
false;public;2;7;;@Override public void after(Exchange exchange, Object object) throws Exception {     UnitOfWork uow = exchange.getUnitOfWork().     if (uow != null) {         uow.afterRoute(exchange, route).     } }
false;public;1;5;;@Override public Object before(Exchange exchange) throws Exception {     inflightRepository.add(exchange, id).     return null. }
false;public;2;4;;@Override public void after(Exchange exchange, Object state) throws Exception {     inflightRepository.remove(exchange, id). }
false;public;1;3;;public void setRoute(Route route) {     this.route = route. }
true;protected;1;7;/**  * Strategy to determine if this policy is allowed to run  *  * @param policy the policy  * @return <tt>true</tt> to run  */ ;/**  * Strategy to determine if this policy is allowed to run  *  * @param policy the policy  * @return <tt>true</tt> to run  */ protected boolean isRoutePolicyRunAllowed(RoutePolicy policy) {     if (policy instanceof StatefulService) {         StatefulService ss = (StatefulService) policy.         return ss.isRunAllowed().     }     return true. }
false;public;1;15;;@Override public Object before(Exchange exchange) throws Exception {     // invoke begin     for (RoutePolicy policy : routePolicies) {         try {             if (isRoutePolicyRunAllowed(policy)) {                 policy.onExchangeBegin(route, exchange).             }         } catch (Exception e) {             log.warn("Error occurred during onExchangeBegin on RoutePolicy: " + policy + ". This exception will be ignored", e).         }     }     return null. }
false;public;2;19;;@Override public void after(Exchange exchange, Object data) throws Exception {     // the policy to start a consumer during Camel is stopping     if (isCamelStopping(exchange.getContext())) {         return.     }     for (RoutePolicy policy : routePolicies) {         try {             if (isRoutePolicyRunAllowed(policy)) {                 policy.onExchangeDone(route, exchange).             }         } catch (Exception e) {             log.warn("Error occurred during onExchangeDone on RoutePolicy: " + policy + ". This exception will be ignored", e).         }     } }
false;private,static;1;7;;private static boolean isCamelStopping(CamelContext context) {     if (context instanceof StatefulService) {         StatefulService ss = (StatefulService) context.         return ss.isStopping() || ss.isStopped().     }     return false. }
false;public;1;22;;@Override public Object before(Exchange exchange) throws Exception {     if (backlogTracer.shouldTrace(processorDefinition, exchange)) {         Date timestamp = new Date().         String toNode = processorDefinition.getId().         String exchangeId = exchange.getExchangeId().         String messageAsXml = MessageHelper.dumpAsXml(exchange.getIn(), true, 4, backlogTracer.isBodyIncludeStreams(), backlogTracer.isBodyIncludeFiles(), backlogTracer.getBodyMaxChars()).         // if first we should add a pseudo trace message as well, so we have a starting message (eg from the route)         String routeId = routeDefinition != null ? routeDefinition.getId() : null.         if (first) {             Date created = exchange.getProperty(Exchange.CREATED_TIMESTAMP, timestamp, Date.class).             DefaultBacklogTracerEventMessage pseudo = new DefaultBacklogTracerEventMessage(backlogTracer.incrementTraceCounter(), created, routeId, null, exchangeId, messageAsXml).             backlogTracer.traceEvent(pseudo).         }         DefaultBacklogTracerEventMessage event = new DefaultBacklogTracerEventMessage(backlogTracer.incrementTraceCounter(), timestamp, routeId, toNode, exchangeId, messageAsXml).         backlogTracer.traceEvent(event).     }     return null. }
false;public;2;4;;@Override public void after(Exchange exchange, Object data) throws Exception { // noop }
false;public;0;5;;@Override public int getOrder() {     // we want tracer just before calling the processor     return Ordered.LOWEST - 1. }
false;public;1;10;;@Override public StopWatch before(Exchange exchange) throws Exception {     if (backlogDebugger.isEnabled() && (backlogDebugger.hasBreakpoint(nodeId) || backlogDebugger.isSingleStepMode())) {         StopWatch watch = new StopWatch().         backlogDebugger.beforeProcess(exchange, target, definition).         return watch.     } else {         return null.     } }
false;public;2;6;;@Override public void after(Exchange exchange, StopWatch stopWatch) throws Exception {     if (stopWatch != null) {         backlogDebugger.afterProcess(exchange, target, definition, stopWatch.taken()).     } }
false;public;0;5;;@Override public int getOrder() {     // we want debugger just before calling the processor     return Ordered.LOWEST. }
false;public;1;33;;@Override public UnitOfWork before(Exchange exchange) throws Exception {     // from this unit of work     if (routeContext != null && exchange.getFromRouteId() == null) {         if (routeId == null) {             RouteDefinition definition = (RouteDefinition) routeContext.getRoute().             routeId = definition.idOrCreate(routeContext.getCamelContext().getNodeIdFactory()).         }         exchange.setFromRouteId(routeId).     }     // only return UnitOfWork if we created a new as then its us that handle the lifecycle to done the created UoW     UnitOfWork created = null.     if (exchange.getUnitOfWork() == null) {         // If there is no existing UoW, then we should start one and         // terminate it once processing is completed for the exchange.         created = createUnitOfWork(exchange).         exchange.setUnitOfWork(created).         created.start().     }     // for any exchange we should push/pop route context so we can keep track of which route we are routing     if (routeContext != null) {         UnitOfWork existing = exchange.getUnitOfWork().         if (existing != null) {             existing.pushRouteContext(routeContext).         }     }     return created. }
false;public;2;14;;@Override public void after(Exchange exchange, UnitOfWork uow) throws Exception {     UnitOfWork existing = exchange.getUnitOfWork().     // execute done on uow if we created it, and the consumer is not doing it     if (uow != null) {         UnitOfWorkHelper.doneUow(uow, exchange).     }     // after UoW is done lets pop the route context which must be done on every existing UoW     if (routeContext != null && existing != null) {         existing.popRouteContext().     } }
false;protected;1;3;;protected UnitOfWork createUnitOfWork(Exchange exchange) {     return exchange.getContext().getUnitOfWorkFactory().createUnitOfWork(exchange). }
false;protected;1;5;;@Override protected UnitOfWork createUnitOfWork(Exchange exchange) {     // let the parent create a child unit of work to be used     return parent.createChildUnitOfWork(exchange). }
false;public;1;6;;@Override public UnitOfWork before(Exchange exchange) throws Exception {     // begin savepoint     exchange.getUnitOfWork().beginSubUnitOfWork(exchange).     return exchange.getUnitOfWork(). }
false;public;2;5;;@Override public void after(Exchange exchange, UnitOfWork unitOfWork) throws Exception {     // end sub unit of work     unitOfWork.endSubUnitOfWork(exchange). }
false;public;1;22;;@Override public MessageHistory before(Exchange exchange) throws Exception {     List<MessageHistory> list = exchange.getProperty(Exchange.MESSAGE_HISTORY, List.class).     if (list == null) {         list = new LinkedList<>().         exchange.setProperty(Exchange.MESSAGE_HISTORY, list).     }     // we may be routing outside a route in an onException or interceptor and if so then grab     // route id from the exchange UoW state     String targetRouteId = this.routeId.     if (targetRouteId == null) {         UnitOfWork uow = exchange.getUnitOfWork().         if (uow != null && uow.getRouteContext() != null) {             targetRouteId = uow.getRouteContext().getRoute().getId().         }     }     MessageHistory history = factory.newMessageHistory(targetRouteId, definition, System.currentTimeMillis()).     list.add(history).     return history. }
false;public;2;6;;@Override public void after(Exchange exchange, MessageHistory history) throws Exception {     if (history != null) {         history.nodeProcessingDone().     } }
false;public;1;19;;@Override public StreamCache before(Exchange exchange) throws Exception {     // check if body is already cached     Object body = exchange.getIn().getBody().     if (body == null) {         return null.     } else if (body instanceof StreamCache) {         StreamCache sc = (StreamCache) body.         // reset so the cache is ready to be used before processing         sc.reset().         return sc.     }     // cache the body and if we could do that replace it as the new body     StreamCache sc = strategy.cache(exchange).     if (sc != null) {         exchange.getIn().setBody(sc).     }     return sc. }
false;public;2;13;;@Override public void after(Exchange exchange, StreamCache sc) throws Exception {     Object body.     if (exchange.hasOut()) {         body = exchange.getOut().getBody().     } else {         body = exchange.getIn().getBody().     }     if (body instanceof StreamCache) {         // reset so the cache is ready to be reused after processing         ((StreamCache) body).reset().     } }
false;public;0;5;;@Override public int getOrder() {     // we want stream caching first     return Ordered.HIGHEST. }
false;public;1;12;;@Override public Object before(Exchange exchange) throws Exception {     try {         log.trace("Sleeping for: {} millis", delay).         Thread.sleep(delay).     } catch (InterruptedException e) {         log.debug("Sleep interrupted").         Thread.currentThread().interrupt().         throw e.     }     return null. }
false;public;2;4;;@Override public void after(Exchange exchange, Object data) throws Exception { // noop }
