commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;19;;@Override protected DataFormat createDataFormat(RouteContext routeContext) {     DataFormat cryptoFormat = super.createDataFormat(routeContext).     if (ObjectHelper.isNotEmpty(keyRef)) {         Key key = CamelContextHelper.mandatoryLookup(routeContext.getCamelContext(), keyRef, Key.class).         setProperty(routeContext.getCamelContext(), cryptoFormat, "key", key).     }     if (ObjectHelper.isNotEmpty(algorithmParameterRef)) {         AlgorithmParameterSpec spec = CamelContextHelper.mandatoryLookup(routeContext.getCamelContext(), algorithmParameterRef, AlgorithmParameterSpec.class).         setProperty(routeContext.getCamelContext(), cryptoFormat, "AlgorithmParameterSpec", spec).     }     if (ObjectHelper.isNotEmpty(initVectorRef)) {         byte[] iv = CamelContextHelper.mandatoryLookup(routeContext.getCamelContext(), initVectorRef, byte[].class).         setProperty(routeContext.getCamelContext(), cryptoFormat, "InitializationVector", iv).     }     return cryptoFormat. }
false;protected;2;27;;@Override protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {     Boolean answer = ObjectHelper.toBoolean(shouldAppendHMAC).     if (answer != null && !answer) {         setProperty(camelContext, dataFormat, "shouldAppendHMAC", Boolean.FALSE).     } else {         setProperty(camelContext, dataFormat, "shouldAppendHMAC", Boolean.TRUE).     }     answer = ObjectHelper.toBoolean(inline).     if (answer != null && answer) {         setProperty(camelContext, dataFormat, "shouldInlineInitializationVector", Boolean.TRUE).     } else {         setProperty(camelContext, dataFormat, "shouldInlineInitializationVector", Boolean.FALSE).     }     if (algorithm != null) {         setProperty(camelContext, dataFormat, "algorithm", algorithm).     }     if (cryptoProvider != null) {         setProperty(camelContext, dataFormat, "cryptoProvider", cryptoProvider).     }     if (macAlgorithm != null) {         setProperty(camelContext, dataFormat, "macAlgorithm", macAlgorithm).     }     if (buffersize != null) {         setProperty(camelContext, dataFormat, "buffersize", buffersize).     } }
false;public;0;3;;public String getAlgorithm() {     return algorithm. }
true;public;1;3;/**  * The JCE algorithm name indicating the cryptographic algorithm that will be used.  * <p/>  * Is by default DES/CBC/PKCS5Padding.  */ ;/**  * The JCE algorithm name indicating the cryptographic algorithm that will be used.  * <p/>  * Is by default DES/CBC/PKCS5Padding.  */ public void setAlgorithm(String algorithm) {     this.algorithm = algorithm. }
false;public;0;3;;public String getCryptoProvider() {     return cryptoProvider. }
true;public;1;3;/**  * The name of the JCE Security Provider that should be used.  */ ;/**  * The name of the JCE Security Provider that should be used.  */ public void setCryptoProvider(String cryptoProvider) {     this.cryptoProvider = cryptoProvider. }
false;public;0;3;;public String getKeyRef() {     return keyRef. }
true;public;1;3;/**  * Refers to the secret key to lookup from the register to use.  */ ;/**  * Refers to the secret key to lookup from the register to use.  */ public void setKeyRef(String keyRef) {     this.keyRef = keyRef. }
false;public;0;3;;public String getInitVectorRef() {     return initVectorRef. }
true;public;1;3;/**  * Refers to a byte array containing the Initialization Vector that will be used to initialize the Cipher.  */ ;/**  * Refers to a byte array containing the Initialization Vector that will be used to initialize the Cipher.  */ public void setInitVectorRef(String initVectorRef) {     this.initVectorRef = initVectorRef. }
false;public;0;3;;public String getAlgorithmParameterRef() {     return algorithmParameterRef. }
true;public;1;3;/**  * A JCE AlgorithmParameterSpec used to initialize the Cipher.  * <p/>  * Will lookup the type using the given name as a {@link java.security.spec.AlgorithmParameterSpec} type.  */ ;/**  * A JCE AlgorithmParameterSpec used to initialize the Cipher.  * <p/>  * Will lookup the type using the given name as a {@link java.security.spec.AlgorithmParameterSpec} type.  */ public void setAlgorithmParameterRef(String algorithmParameterRef) {     this.algorithmParameterRef = algorithmParameterRef. }
false;public;0;3;;public Integer getBuffersize() {     return buffersize. }
true;public;1;3;/**  * The size of the buffer used in the signature process.  */ ;/**  * The size of the buffer used in the signature process.  */ public void setBuffersize(Integer buffersize) {     this.buffersize = buffersize. }
false;public;0;3;;public String getMacAlgorithm() {     return macAlgorithm. }
true;public;1;3;/**  * The JCE algorithm name indicating the Message Authentication algorithm.  */ ;/**  * The JCE algorithm name indicating the Message Authentication algorithm.  */ public void setMacAlgorithm(String macAlgorithm) {     this.macAlgorithm = macAlgorithm. }
false;public;0;3;;public Boolean getShouldAppendHMAC() {     return shouldAppendHMAC. }
true;public;1;3;/**  * Flag indicating that a Message Authentication Code should be calculated and appended to the encrypted data.  */ ;/**  * Flag indicating that a Message Authentication Code should be calculated and appended to the encrypted data.  */ public void setShouldAppendHMAC(Boolean shouldAppendHMAC) {     this.shouldAppendHMAC = shouldAppendHMAC. }
false;public;0;3;;public Boolean getInline() {     return inline. }
true;public;1;3;/**  * Flag indicating that the configured IV should be inlined into the encrypted data stream.  * <p/>  * Is by default false.  */ ;/**  * Flag indicating that the configured IV should be inlined into the encrypted data stream.  * <p/>  * Is by default false.  */ public void setInline(Boolean inline) {     this.inline = inline. }
