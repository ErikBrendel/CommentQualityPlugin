commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;8;;public static Processor newInstance(CamelContext camelContext, List<Processor> processors) {     if (processors.isEmpty()) {         return null.     } else if (processors.size() == 1) {         return processors.get(0).     }     return new Pipeline(camelContext, processors). }
false;public,static;2;16;;public static Processor newInstance(final CamelContext camelContext, final Processor... processors) {     if (processors == null || processors.length == 0) {         return null.     } else if (processors.length == 1) {         return processors[0].     }     final List<Processor> toBeProcessed = new ArrayList<>(processors.length).     for (Processor processor : processors) {         if (processor != null) {             toBeProcessed.add(processor).         }     }     return new Pipeline(camelContext, toBeProcessed). }
false;public;2;11;;@Override public boolean process(Exchange exchange, AsyncCallback callback) {     if (exchange.isTransacted()) {         ReactiveHelper.scheduleSync(() -> Pipeline.this.doProcess(exchange, callback, processors.iterator(), true), "Step[" + exchange.getExchangeId() + "," + Pipeline.this + "]").     } else {         ReactiveHelper.scheduleMain(() -> Pipeline.this.doProcess(exchange, callback, processors.iterator(), true), "Step[" + exchange.getExchangeId() + "," + Pipeline.this + "]").     }     return false. }
false;protected;4;27;;protected void doProcess(Exchange exchange, AsyncCallback callback, Iterator<AsyncProcessor> processors, boolean first) {     if (continueRouting(processors, exchange) && (first || continueProcessing(exchange, "so breaking out of pipeline", log))) {         // prepare for next run         if (exchange.hasOut()) {             exchange.setIn(exchange.getOut()).             exchange.setOut(null).         }         // get the next processor         AsyncProcessor processor = processors.next().         processor.process(exchange, doneSync -> ReactiveHelper.schedule(() -> doProcess(exchange, callback, processors, false), "Step[" + exchange.getExchangeId() + "," + Pipeline.this + "]")).     } else {         ExchangeHelper.copyResults(exchange, exchange).         // logging nextExchange as it contains the exchange that might have altered the payload and since         // we are logging the completion if will be confusing if we log the original instead         // we could also consider logging the original and the nextExchange then we have *before* and *after* snapshots         log.trace("Processing complete for exchangeId: {} >>> {}", exchange.getExchangeId(), exchange).         ReactiveHelper.callback(callback).     } }
false;protected;2;14;;protected boolean continueRouting(Iterator<AsyncProcessor> it, Exchange exchange) {     Object stop = exchange.getProperty(Exchange.ROUTE_STOP).     if (stop != null) {         boolean doStop = exchange.getContext().getTypeConverter().convertTo(Boolean.class, stop).         if (doStop) {             log.debug("ExchangeId: {} is marked to stop routing: {}", exchange.getExchangeId(), exchange).             return false.         }     }     // continue if there are more processors to route     boolean answer = it.hasNext().     log.trace("ExchangeId: {} should continue routing: {}", exchange.getExchangeId(), answer).     return answer. }
false;protected;0;4;;@Override protected void doStart() throws Exception {     ServiceHelper.startService(processors). }
false;protected;0;4;;@Override protected void doStop() throws Exception {     ServiceHelper.stopService(processors). }
false;public;0;4;;@Override public String toString() {     return "Pipeline[" + getProcessors() + "]". }
false;public;0;3;;public List<Processor> getProcessors() {     return (List) processors. }
false;public;0;4;;@Override public String getTraceLabel() {     return "pipeline". }
false;public;0;4;;@Override public String getId() {     return id. }
false;public;1;4;;@Override public void setId(String id) {     this.id = id. }
false;public;0;6;;public List<Processor> next() {     if (!hasNext()) {         return null.     }     return new ArrayList<>(processors). }
false;public;0;3;;public boolean hasNext() {     return processors != null && !processors.isEmpty(). }
