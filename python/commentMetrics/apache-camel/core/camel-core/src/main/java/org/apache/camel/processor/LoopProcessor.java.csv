commented;modifiers;parameterAmount;loc;comment;code
false;public;2;19;;@Override public boolean process(Exchange exchange, AsyncCallback callback) {     try {         LoopState state = new LoopState(exchange, callback).         if (exchange.isTransacted()) {             ReactiveHelper.scheduleSync(state).         } else {             ReactiveHelper.scheduleMain(state).         }         return false.     } catch (Exception e) {         exchange.setException(e).         callback.done(true).         return true.     } }
false;public;0;34;;@Override public void run() {     try {         // check for error if so we should break out         boolean cont = continueProcessing(current, "so breaking out of loop", log).         boolean doWhile = predicate == null || predicate.matches(current).         boolean doLoop = expression == null || index < count.         // iterate         if (cont && doWhile && doLoop) {             // and prepare for next iteration             current = prepareExchange(exchange, index).             // set current index as property             log.debug("LoopProcessor: iteration #{}", index).             current.setProperty(Exchange.LOOP_INDEX, index).             processor.process(current, doneSync -> {                 // increment counter after done                 index++.                 ReactiveHelper.schedule(this).             }).         } else {             // we are done so prepare the result             ExchangeHelper.copyResults(exchange, current).             log.trace("Processing complete for exchangeId: {} >>> {}", exchange.getExchangeId(), exchange).             callback.done(false).         }     } catch (Exception e) {         log.trace("Processing failed for exchangeId: {} >>> {}", exchange.getExchangeId(), e.getMessage()).         exchange.setException(e).         callback.done(false).     } }
false;public;0;3;;public String toString() {     return "LoopState[" + exchange.getExchangeId() + "]". }
true;protected;2;10;/**  * Prepares the exchange for the next iteration  *  * @param exchange the exchange  * @param index the index of the next iteration  * @return the exchange to use  */ ;/**  * Prepares the exchange for the next iteration  *  * @param exchange the exchange  * @param index the index of the next iteration  * @return the exchange to use  */ protected Exchange prepareExchange(Exchange exchange, int index) {     if (copy) {         // use the original exchange rather than the looping exchange (esp. with the async routing engine)         return ExchangeHelper.createCopy(exchange, true).     } else {         ExchangeHelper.prepareOutToIn(exchange).         return exchange.     } }
false;public;0;3;;public Expression getExpression() {     return expression. }
false;public;0;3;;public Predicate getPredicate() {     return predicate. }
false;public;0;3;;public boolean isCopy() {     return copy. }
false;public;0;7;;public String getTraceLabel() {     if (predicate != null) {         return "loopWhile[" + predicate + "]".     } else {         return "loop[" + expression + "]".     } }
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setId(String id) {     this.id = id. }
false;public;0;8;;@Override public String toString() {     if (predicate != null) {         return "Loop[while: " + predicate + " do: " + getProcessor() + "]".     } else {         return "Loop[for: " + expression + " times do: " + getProcessor() + "]".     } }
