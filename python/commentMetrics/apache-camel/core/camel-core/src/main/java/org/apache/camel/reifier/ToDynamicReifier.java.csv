commented;modifiers;parameterAmount;loc;comment;code
false;public;1;17;;@Override public Processor createProcessor(RouteContext routeContext) throws Exception {     StringHelper.notEmpty(definition.getUri(), "uri", this).     Expression exp = createExpression(routeContext).     SendDynamicProcessor processor = new SendDynamicProcessor(definition.getUri(), exp).     processor.setCamelContext(routeContext.getCamelContext()).     processor.setPattern(definition.getPattern()).     if (definition.getCacheSize() != null) {         processor.setCacheSize(definition.getCacheSize()).     }     if (definition.getIgnoreInvalidEndpoint() != null) {         processor.setIgnoreInvalidEndpoint(definition.getIgnoreInvalidEndpoint()).     }     return processor. }
false;protected;1;39;;protected Expression createExpression(RouteContext routeContext) {     List<Expression> list = new ArrayList<>().     String[] parts = safeSplitRaw(definition.getUri()).     for (String part : parts) {         // the part may have optional language to use, so you can mix languages         String value = StringHelper.after(part, "language:").         if (value != null) {             String before = StringHelper.before(value, ":").             String after = StringHelper.after(value, ":").             if (before != null && after != null) {                 // maybe its a language, must have language: as prefix                 try {                     Language partLanguage = routeContext.getCamelContext().resolveLanguage(before).                     if (partLanguage != null) {                         Expression exp = partLanguage.createExpression(after).                         list.add(exp).                         continue.                     }                 } catch (NoSuchLanguageException e) {                 // ignore                 }             }         }         // fallback and use simple language         Language lan = routeContext.getCamelContext().resolveLanguage("simple").         Expression exp = lan.createExpression(part).         list.add(exp).     }     Expression exp.     if (list.size() == 1) {         exp = list.get(0).     } else {         exp = ExpressionBuilder.concatExpression(list).     }     return exp. }
true;private,static;1;29;/**  * We need to split the string safely for each + sign, but avoid splitting within RAW(...).  */ ;// Utilities // ------------------------------------------------------------------------- /**  * We need to split the string safely for each + sign, but avoid splitting within RAW(...).  */ private static String[] safeSplitRaw(String s) {     List<String> list = new ArrayList<>().     if (!s.contains("+")) {         // no plus sign so there is only one part, so no need to split         list.add(s).     } else {         // there is a plus sign so we need to split in a safe manner         List<Pair<Integer>> rawPairs = URISupport.scanRaw(s).         StringBuilder sb = new StringBuilder().         char[] chars = s.toCharArray().         for (int i = 0. i < chars.length. i++) {             char ch = chars[i].             if (ch != '+' || URISupport.isRaw(i, rawPairs)) {                 sb.append(ch).             } else {                 list.add(sb.toString()).                 sb.setLength(0).             }         }         // any leftover?         if (sb.length() > 0) {             list.add(sb.toString()).             sb.setLength(0).         }     }     return list.toArray(new String[list.size()]). }
