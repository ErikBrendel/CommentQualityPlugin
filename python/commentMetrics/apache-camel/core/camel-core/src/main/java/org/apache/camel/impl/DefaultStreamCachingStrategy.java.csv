commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;1;3;;public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;0;3;;public boolean isEnabled() {     return enabled. }
false;public;1;3;;public void setEnabled(boolean enabled) {     this.enabled = enabled. }
false;public;1;3;;public void setSpoolDirectory(String path) {     this.spoolDirectoryName = path. }
false;public;1;3;;public void setSpoolDirectory(File path) {     this.spoolDirectory = path. }
false;public;0;3;;public File getSpoolDirectory() {     return spoolDirectory. }
false;public;0;3;;public long getSpoolThreshold() {     return spoolThreshold. }
false;public;0;3;;public int getSpoolUsedHeapMemoryThreshold() {     return spoolUsedHeapMemoryThreshold. }
false;public;1;3;;public void setSpoolUsedHeapMemoryThreshold(int spoolHeapMemoryWatermarkThreshold) {     this.spoolUsedHeapMemoryThreshold = spoolHeapMemoryWatermarkThreshold. }
false;public;0;3;;public SpoolUsedHeapMemoryLimit getSpoolUsedHeapMemoryLimit() {     return spoolUsedHeapMemoryLimit. }
false;public;1;3;;public void setSpoolUsedHeapMemoryLimit(SpoolUsedHeapMemoryLimit spoolUsedHeapMemoryLimit) {     this.spoolUsedHeapMemoryLimit = spoolUsedHeapMemoryLimit. }
false;public;1;3;;public void setSpoolThreshold(long spoolThreshold) {     this.spoolThreshold = spoolThreshold. }
false;public;0;3;;public String getSpoolChiper() {     return spoolChiper. }
false;public;1;3;;public void setSpoolChiper(String spoolChiper) {     this.spoolChiper = spoolChiper. }
false;public;0;3;;public int getBufferSize() {     return bufferSize. }
false;public;1;3;;public void setBufferSize(int bufferSize) {     this.bufferSize = bufferSize. }
false;public;0;3;;public boolean isRemoveSpoolDirectoryWhenStopping() {     return removeSpoolDirectoryWhenStopping. }
false;public;1;3;;public void setRemoveSpoolDirectoryWhenStopping(boolean removeSpoolDirectoryWhenStopping) {     this.removeSpoolDirectoryWhenStopping = removeSpoolDirectoryWhenStopping. }
false;public;0;3;;public boolean isAnySpoolRules() {     return anySpoolRules. }
false;public;1;3;;public void setAnySpoolRules(boolean anySpoolTasks) {     this.anySpoolRules = anySpoolTasks. }
false;public;0;3;;public Statistics getStatistics() {     return statistics. }
false;public;1;28;;public boolean shouldSpoolCache(long length) {     if (!enabled || spoolRules.isEmpty()) {         return false.     }     boolean all = true.     boolean any = false.     for (SpoolRule rule : spoolRules) {         boolean result = rule.shouldSpoolCache(length).         if (!result) {             all = false.             if (!anySpoolRules) {                 // no need to check anymore                 break.             }         } else {             any = true.             if (anySpoolRules) {                 // no need to check anymore                 break.             }         }     }     boolean answer = anySpoolRules ? any : all.     log.debug("Should spool cache {} -> {}", length, answer).     return answer. }
false;public;1;3;;public void addSpoolRule(SpoolRule rule) {     spoolRules.add(rule). }
false;public;1;21;;public StreamCache cache(Exchange exchange) {     Message message = exchange.hasOut() ? exchange.getOut() : exchange.getIn().     StreamCache cache = message.getBody(StreamCache.class).     if (cache != null) {         if (log.isTraceEnabled()) {             log.trace("Cached stream to {} -> {}", cache.inMemory() ? "memory" : "spool", cache).         }         if (statistics.isStatisticsEnabled()) {             try {                 if (cache.inMemory()) {                     statistics.updateMemory(cache.length()).                 } else {                     statistics.updateSpool(cache.length()).                 }             } catch (Exception e) {                 log.debug("Error updating cache statistics. This exception is ignored.", e).             }         }     }     return cache. }
false;protected;1;11;;protected String resolveSpoolDirectory(String path) {     String name = camelContext.getManagementNameStrategy().resolveManagementName(path, camelContext.getName(), false).     if (name != null) {         name = customResolveManagementName(name).     }     // and then check again with invalid check to ensure all ## is resolved     if (name != null) {         name = camelContext.getManagementNameStrategy().resolveManagementName(name, camelContext.getName(), true).     }     return name. }
false;protected;1;7;;protected String customResolveManagementName(String pattern) {     if (pattern.contains("#uuid#")) {         String uuid = UUID.randomUUID().toString().         pattern = pattern.replaceFirst("#uuid#", uuid).     }     return FilePathResolver.resolvePath(pattern). }
false;protected;0;64;;@Override protected void doStart() throws Exception {     if (!enabled) {         log.debug("StreamCaching is not enabled").         return.     }     if (spoolUsedHeapMemoryThreshold > 99) {         throw new IllegalArgumentException("SpoolHeapMemoryWatermarkThreshold must not be higher than 99, was: " + spoolUsedHeapMemoryThreshold).     }     // if we can overflow to disk then make sure directory exists / is created     if (spoolThreshold > 0 || spoolUsedHeapMemoryThreshold > 0) {         if (spoolDirectory == null && spoolDirectoryName == null) {             throw new IllegalArgumentException("SpoolDirectory must be configured when using SpoolThreshold > 0").         }         if (spoolDirectory == null) {             String name = resolveSpoolDirectory(spoolDirectoryName).             if (name != null) {                 spoolDirectory = new File(name).                 spoolDirectoryName = null.             } else {                 throw new IllegalStateException("Cannot resolve spool directory from pattern: " + spoolDirectoryName).             }         }         if (spoolDirectory.exists()) {             if (spoolDirectory.isDirectory()) {                 log.debug("Using spool directory: {}", spoolDirectory).             } else {                 log.warn("Spool directory: {} is not a directory. This may cause problems spooling to disk for the stream caching!", spoolDirectory).             }         } else {             boolean created = spoolDirectory.mkdirs().             if (!created) {                 log.warn("Cannot create spool directory: {}. This may cause problems spooling to disk for the stream caching!", spoolDirectory).             } else {                 log.debug("Created spool directory: {}", spoolDirectory).             }         }         if (spoolThreshold > 0) {             spoolRules.add(new FixedThresholdSpoolRule()).         }         if (spoolUsedHeapMemoryThreshold > 0) {             if (spoolUsedHeapMemoryLimit == null) {                 // use max by default                 spoolUsedHeapMemoryLimit = SpoolUsedHeapMemoryLimit.Max.             }             spoolRules.add(new UsedHeapMemorySpoolRule(spoolUsedHeapMemoryLimit)).         }     }     log.debug("StreamCaching configuration {}", this).     if (spoolDirectory != null) {         log.info("StreamCaching in use with spool directory: {} and rules: {}", spoolDirectory.getPath(), spoolRules).     } else {         log.info("StreamCaching in use with rules: {}", spoolRules).     } }
false;protected;0;13;;@Override protected void doStop() throws Exception {     if (spoolThreshold > 0 & spoolDirectory != null && isRemoveSpoolDirectoryWhenStopping()) {         log.debug("Removing spool directory: {}", spoolDirectory).         FileUtil.removeDir(spoolDirectory).     }     if (log.isDebugEnabled() && statistics.isStatisticsEnabled()) {         log.debug("Stopping StreamCachingStrategy with statistics: {}", statistics).     }     statistics.reset(). }
false;public;0;10;;@Override public String toString() {     return "DefaultStreamCachingStrategy[" + "spoolDirectory=" + spoolDirectory + ", spoolChiper=" + spoolChiper + ", spoolThreshold=" + spoolThreshold + ", spoolUsedHeapMemoryThreshold=" + spoolUsedHeapMemoryThreshold + ", bufferSize=" + bufferSize + ", anySpoolRules=" + anySpoolRules + "]". }
false;public;1;7;;public boolean shouldSpoolCache(long length) {     if (spoolThreshold > 0 && length > spoolThreshold) {         log.trace("Should spool cache fixed threshold {} > {} -> true", length, spoolThreshold).         return true.     }     return false. }
false;public;0;7;;public String toString() {     if (spoolThreshold < 1024) {         return "Spool > " + spoolThreshold + " bytes body size".     } else {         return "Spool > " + (spoolThreshold >> 10) + "K body size".     } }
false;public;1;23;;public boolean shouldSpoolCache(long length) {     if (spoolUsedHeapMemoryThreshold > 0) {         // must use double to calculate with decimals for the percentage         double used = heapUsage.getHeapMemoryUsage().getUsed().         double upper = limit == SpoolUsedHeapMemoryLimit.Committed ? heapUsage.getHeapMemoryUsage().getCommitted() : heapUsage.getHeapMemoryUsage().getMax().         double calc = (used / upper) * 100.         int percentage = (int) calc.         if (log.isTraceEnabled()) {             long u = heapUsage.getHeapMemoryUsage().getUsed().             long c = heapUsage.getHeapMemoryUsage().getCommitted().             long m = heapUsage.getHeapMemoryUsage().getMax().             log.trace("Heap memory: [used={}M ({}%), committed={}M, max={}M]", u >> 20, percentage, c >> 20, m >> 20).         }         if (percentage > spoolUsedHeapMemoryThreshold) {             log.trace("Should spool cache heap memory threshold {} > {} -> true", percentage, spoolUsedHeapMemoryThreshold).             return true.         }     }     return false. }
false;public;0;3;;public String toString() {     return "Spool > " + spoolUsedHeapMemoryThreshold + "% used of " + limit + " heap memory". }
false;synchronized;1;5;;synchronized void updateMemory(long size) {     memoryCounter++.     memorySize += size.     memoryAverageSize = memorySize / memoryCounter. }
false;synchronized;1;5;;synchronized void updateSpool(long size) {     spoolCounter++.     spoolSize += size.     spoolAverageSize = spoolSize / spoolCounter. }
false;public;0;3;;public long getCacheMemoryCounter() {     return memoryCounter. }
false;public;0;3;;public long getCacheMemorySize() {     return memorySize. }
false;public;0;3;;public long getCacheMemoryAverageSize() {     return memoryAverageSize. }
false;public;0;3;;public long getCacheSpoolCounter() {     return spoolCounter. }
false;public;0;3;;public long getCacheSpoolSize() {     return spoolSize. }
false;public;0;3;;public long getCacheSpoolAverageSize() {     return spoolAverageSize. }
false;public,synchronized;0;8;;public synchronized void reset() {     memoryCounter = 0.     memorySize = 0.     memoryAverageSize = 0.     spoolCounter = 0.     spoolSize = 0.     spoolAverageSize = 0. }
false;public;0;3;;public boolean isStatisticsEnabled() {     return statisticsEnabled. }
false;public;1;3;;public void setStatisticsEnabled(boolean statisticsEnabled) {     this.statisticsEnabled = statisticsEnabled. }
false;public;0;4;;public String toString() {     return String.format("[memoryCounter=%s, memorySize=%s, memoryAverageSize=%s, spoolCounter=%s, spoolSize=%s, spoolAverageSize=%s]", memoryCounter, memorySize, memoryAverageSize, spoolCounter, spoolSize, spoolAverageSize). }
