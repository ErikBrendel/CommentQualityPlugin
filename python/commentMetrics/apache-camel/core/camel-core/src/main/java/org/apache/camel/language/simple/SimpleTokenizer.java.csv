commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;6;/**  * Does the expression include a simple function.  *  * @param expression the expression  * @return <tt>true</tt> if one or more simple function is included in the expression  */ ;/**  * Does the expression include a simple function.  *  * @param expression the expression  * @return <tt>true</tt> if one or more simple function is included in the expression  */ public static boolean hasFunctionStartToken(String expression) {     if (expression != null) {         return expression.contains(FUNCTION_START[0]) || expression.contains(FUNCTION_START[1]).     }     return false. }
true;public,static;1;22;/**  * @see SimpleLanguage#changeFunctionStartToken(String...)  */ ;/**  * @see SimpleLanguage#changeFunctionStartToken(String...)  */ public static void changeFunctionStartToken(String... startToken) {     for (SimpleTokenType type : KNOWN_TOKENS) {         if (type.getType() == TokenType.functionStart) {             KNOWN_TOKENS.remove(type).         }     }     if (startToken.length > 2) {         throw new IllegalArgumentException("At most 2 start tokens is allowed").     }     // reset     FUNCTION_START[0] = "".     FUNCTION_START[1] = "".     // add in start of list as its a more common token to be used     for (int i = 0. i < startToken.length. i++) {         String token = startToken[i].         FUNCTION_START[i] = token.         KNOWN_TOKENS.add(0, new SimpleTokenType(TokenType.functionStart, token)).     } }
true;public,static;1;20;/**  * @see SimpleLanguage#changeFunctionEndToken(String...)  */ ;/**  * @see SimpleLanguage#changeFunctionEndToken(String...)  */ public static void changeFunctionEndToken(String... endToken) {     for (SimpleTokenType type : KNOWN_TOKENS) {         if (type.getType() == TokenType.functionEnd) {             KNOWN_TOKENS.remove(type).         }     }     // add after the start tokens     int pos = 0.     for (SimpleTokenType type : KNOWN_TOKENS) {         if (type.getType() == TokenType.functionStart) {             pos++.         }     }     // add after function start of list as its a more common token to be used     for (String token : endToken) {         KNOWN_TOKENS.add(pos, new SimpleTokenType(TokenType.functionEnd, token)).     } }
true;public,static;4;3;/**  * Create the next token  *  * @param expression  the input expression  * @param index       the current index  * @param allowEscape whether to allow escapes  * @param filter      defines the accepted token types to be returned (character is always used as fallback)  * @return the created token, will always return a token  */ ;/**  * Create the next token  *  * @param expression  the input expression  * @param index       the current index  * @param allowEscape whether to allow escapes  * @param filter      defines the accepted token types to be returned (character is always used as fallback)  * @return the created token, will always return a token  */ public static SimpleToken nextToken(String expression, int index, boolean allowEscape, TokenType... filter) {     return doNextToken(expression, index, allowEscape, filter). }
true;public,static;3;3;/**  * Create the next token  *  * @param expression  the input expression  * @param index       the current index  * @param allowEscape whether to allow escapes  * @return the created token, will always return a token  */ ;/**  * Create the next token  *  * @param expression  the input expression  * @param index       the current index  * @param allowEscape whether to allow escapes  * @return the created token, will always return a token  */ public static SimpleToken nextToken(String expression, int index, boolean allowEscape) {     return doNextToken(expression, index, allowEscape). }
false;private,static;4;78;;private static SimpleToken doNextToken(String expression, int index, boolean allowEscape, TokenType... filters) {     boolean numericAllowed = acceptType(TokenType.numericValue, filters).     if (numericAllowed) {         // is it a numeric value         StringBuilder sb = new StringBuilder().         boolean digit = true.         while (digit && index < expression.length()) {             digit = Character.isDigit(expression.charAt(index)).             if (digit) {                 char ch = expression.charAt(index).                 sb.append(ch).                 index++.                 continue.             }             // is it a dot or comma as part of a floating point number             boolean decimalSeparator = '.' == expression.charAt(index) || ',' == expression.charAt(index).             if (decimalSeparator && sb.length() > 0) {                 char ch = expression.charAt(index).                 sb.append(ch).                 index++.                 // assume its still a digit                 digit = true.                 continue.             }         }         if (sb.length() > 0) {             return new SimpleToken(new SimpleTokenType(TokenType.numericValue, sb.toString()), index).         }     }     boolean escapeAllowed = allowEscape && acceptType(TokenType.escape, filters).     if (escapeAllowed) {         StringBuilder sb = new StringBuilder().         char ch = expression.charAt(index).         boolean escaped = '\\' == ch.         if (escaped && index < expression.length() - 1) {             // grab next character to escape             char next = expression.charAt(++index).             // special for new line, tabs and carriage return             boolean special = false.             if ('n' == next) {                 sb.append("\n").                 special = true.             } else if ('t' == next) {                 sb.append("\t").                 special = true.             } else if ('r' == next) {                 sb.append("\r").                 special = true.             } else if ('}' == next) {                 sb.append("}").                 special = true.             } else {                 // not special just a regular character                 sb.append(ch).             }             // force 2 as length if special             return new SimpleToken(new SimpleTokenType(TokenType.character, sb.toString()), index, special ? 2 : 1).         }     }     // it could be any of the known tokens     String text = expression.substring(index).     for (SimpleTokenType token : KNOWN_TOKENS) {         if (acceptType(token.getType(), filters)) {             if (acceptToken(token, text, expression, index)) {                 return new SimpleToken(token, index).             }         }     }     // fallback and create a character token     char ch = expression.charAt(index).     SimpleToken token = new SimpleToken(new SimpleTokenType(TokenType.character, "" + ch), index).     return token. }
false;private,static;2;11;;private static boolean acceptType(TokenType type, TokenType... filters) {     if (filters == null || filters.length == 0) {         return true.     }     for (TokenType filter : filters) {         if (type == filter) {             return true.         }     }     return false. }
false;private,static;4;23;;private static boolean acceptToken(SimpleTokenType token, String text, String expression, int index) {     if (token.isUnary() && text.startsWith(token.getValue())) {         SimpleTokenType functionEndToken = getFunctionEndToken().         if (functionEndToken != null) {             int endLen = functionEndToken.getValue().length().             // special check for unary as the previous must be a function end, and the next a whitespace             // to ensure unary operators is only applied on functions as intended             int len = token.getValue().length().             String previous = "".             if (index - endLen >= 0) {                 previous = expression.substring(index - endLen, index).             }             String after = text.substring(len).             boolean whiteSpace = ObjectHelper.isEmpty(after) || after.startsWith(" ").             boolean functionEnd = previous.equals(functionEndToken.getValue()).             return functionEnd && whiteSpace.         }     }     return text.startsWith(token.getValue()). }
false;private,static;0;8;;private static SimpleTokenType getFunctionEndToken() {     for (SimpleTokenType token : KNOWN_TOKENS) {         if (token.isFunctionEnd()) {             return token.         }     }     return null. }
