commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Creates a new backlog tracer.  *  * @param context Camel context  * @return a new backlog tracer  */ ;/**  * Creates a new backlog tracer.  *  * @param context Camel context  * @return a new backlog tracer  */ public static BacklogTracer createTracer(CamelContext context) {     return new BacklogTracer(context). }
true;public,static;1;3;/**  * A helper method to return the BacklogTracer instance if one is enabled  *  * @return the backlog tracer or null if none can be found  */ ;/**  * A helper method to return the BacklogTracer instance if one is enabled  *  * @return the backlog tracer or null if none can be found  */ public static BacklogTracer getBacklogTracer(CamelContext context) {     return context.getExtension(BacklogTracer.class). }
true;public;2;20;/**  * Whether or not to trace the given processor definition.  *  * @param definition the processor definition  * @param exchange   the exchange  * @return <tt>true</tt> to trace, <tt>false</tt> to skip tracing  */ ;/**  * Whether or not to trace the given processor definition.  *  * @param definition the processor definition  * @param exchange   the exchange  * @return <tt>true</tt> to trace, <tt>false</tt> to skip tracing  */ public boolean shouldTrace(ProcessorDefinition<?> definition, Exchange exchange) {     if (!enabled) {         return false.     }     boolean pattern = true.     boolean filter = true.     if (patterns != null) {         pattern = shouldTracePattern(definition).     }     if (predicate != null) {         filter = shouldTraceFilter(exchange).     }     if (log.isTraceEnabled()) {         log.trace("Should trace evaluated {} -> pattern: {}, filter: {}", definition.getId(), pattern, filter).     }     return pattern && filter. }
false;private;1;19;;private boolean shouldTracePattern(ProcessorDefinition<?> definition) {     for (String pattern : patterns) {         // match either route id, or node id         String id = definition.getId().         // use matchPattern method from endpoint helper that has a good matcher we use in Camel         if (PatternHelper.matchPattern(id, pattern)) {             return true.         }         RouteDefinition route = ProcessorDefinitionHelper.getRoute(definition).         if (route != null) {             id = route.getId().             if (PatternHelper.matchPattern(id, pattern)) {                 return true.             }         }     }     // not matched the pattern     return false. }
false;public;1;15;;public void traceEvent(DefaultBacklogTracerEventMessage event) {     if (!enabled) {         return.     }     // ensure there is space on the queue by polling until at least single slot is free     int drain = queue.size() - backlogSize + 1.     if (drain > 0) {         for (int i = 0. i < drain. i++) {             queue.poll().         }     }     queue.add(event). }
false;private;1;3;;private boolean shouldTraceFilter(Exchange exchange) {     return predicate.matches(exchange). }
false;public;0;3;;public boolean isEnabled() {     return enabled. }
false;public;1;3;;public void setEnabled(boolean enabled) {     this.enabled = enabled. }
false;public;0;3;;public int getBacklogSize() {     return backlogSize. }
false;public;1;9;;public void setBacklogSize(int backlogSize) {     if (backlogSize <= 0) {         throw new IllegalArgumentException("The backlog size must be a positive number, was: " + backlogSize).     }     if (backlogSize > MAX_BACKLOG_SIZE) {         throw new IllegalArgumentException("The backlog size cannot be greater than the max size of " + MAX_BACKLOG_SIZE + ", was: " + backlogSize).     }     this.backlogSize = backlogSize. }
false;public;0;3;;public boolean isRemoveOnDump() {     return removeOnDump. }
false;public;1;3;;public void setRemoveOnDump(boolean removeOnDump) {     this.removeOnDump = removeOnDump. }
false;public;0;3;;public int getBodyMaxChars() {     return bodyMaxChars. }
false;public;1;3;;public void setBodyMaxChars(int bodyMaxChars) {     this.bodyMaxChars = bodyMaxChars. }
false;public;0;3;;public boolean isBodyIncludeStreams() {     return bodyIncludeStreams. }
false;public;1;3;;public void setBodyIncludeStreams(boolean bodyIncludeStreams) {     this.bodyIncludeStreams = bodyIncludeStreams. }
false;public;0;3;;public boolean isBodyIncludeFiles() {     return bodyIncludeFiles. }
false;public;1;3;;public void setBodyIncludeFiles(boolean bodyIncludeFiles) {     this.bodyIncludeFiles = bodyIncludeFiles. }
false;public;0;3;;public String getTracePattern() {     return tracePattern. }
false;public;1;9;;public void setTracePattern(String tracePattern) {     this.tracePattern = tracePattern.     if (tracePattern != null) {         // the pattern can have multiple nodes separated by comma         this.patterns = tracePattern.split(",").     } else {         this.patterns = null.     } }
false;public;0;3;;public String getTraceFilter() {     return traceFilter. }
false;public;1;12;;public void setTraceFilter(String filter) {     this.traceFilter = filter.     if (filter != null) {         // assume simple language         String name = StringHelper.before(filter, ":").         if (name == null) {             // use simple language by default             name = "simple".         }         predicate = camelContext.resolveLanguage(name).createPredicate(filter).     } }
false;public;0;3;;public long getTraceCounter() {     return traceCounter.get(). }
false;public;0;3;;public void resetTraceCounter() {     traceCounter.set(0). }
false;public;1;16;;public List<BacklogTracerEventMessage> dumpTracedMessages(String nodeId) {     List<BacklogTracerEventMessage> answer = new ArrayList<>().     if (nodeId != null) {         for (BacklogTracerEventMessage message : queue) {             if (nodeId.equals(message.getToNode()) || nodeId.equals(message.getRouteId())) {                 answer.add(message).             }         }     }     if (removeOnDump) {         queue.removeAll(answer).     }     return answer. }
false;public;1;11;;public String dumpTracedMessagesAsXml(String nodeId) {     List<BacklogTracerEventMessage> events = dumpTracedMessages(nodeId).     StringBuilder sb = new StringBuilder().     sb.append("<").append(BacklogTracerEventMessage.ROOT_TAG).append("s>").     for (BacklogTracerEventMessage event : events) {         sb.append("\n").append(event.toXml(2)).     }     sb.append("\n</").append(BacklogTracerEventMessage.ROOT_TAG).append("s>").     return sb.toString(). }
false;public;0;8;;public List<BacklogTracerEventMessage> dumpAllTracedMessages() {     List<BacklogTracerEventMessage> answer = new ArrayList<>().     answer.addAll(queue).     if (isRemoveOnDump()) {         queue.clear().     }     return answer. }
false;public;0;11;;public String dumpAllTracedMessagesAsXml() {     List<BacklogTracerEventMessage> events = dumpAllTracedMessages().     StringBuilder sb = new StringBuilder().     sb.append("<").append(BacklogTracerEventMessage.ROOT_TAG).append("s>").     for (BacklogTracerEventMessage event : events) {         sb.append("\n").append(event.toXml(2)).     }     sb.append("\n</").append(BacklogTracerEventMessage.ROOT_TAG).append("s>").     return sb.toString(). }
false;public;0;3;;public void clear() {     queue.clear(). }
false;public;0;3;;public long incrementTraceCounter() {     return traceCounter.incrementAndGet(). }
false;protected;0;3;;@Override protected void doStart() throws Exception { }
false;protected;0;4;;@Override protected void doStop() throws Exception {     queue.clear(). }
