commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public List<String> getExceptions() {     return exceptions. }
true;public;1;3;/**  * A list of class names for specific exceptions to monitor.  * If no exceptions is configured then all exceptions is monitored  */ ;/**  * A list of class names for specific exceptions to monitor.  * If no exceptions is configured then all exceptions is monitored  */ public void setExceptions(List<String> exceptions) {     this.exceptions = exceptions. }
false;public;0;3;;public List<Class<?>> getExceptionTypes() {     return exceptionTypes. }
true;public;1;3;/**  * A list of specific exceptions to monitor.  * If no exceptions is configured then all exceptions is monitored  */ ;/**  * A list of specific exceptions to monitor.  * If no exceptions is configured then all exceptions is monitored  */ public void setExceptionTypes(List<Class<?>> exceptionTypes) {     this.exceptionTypes = exceptionTypes. }
false;public;0;3;;public Boolean getRoundRobin() {     return roundRobin. }
true;public;1;3;/**  * Whether or not the failover load balancer should operate in round robin mode or not.  * If not, then it will always start from the first endpoint when a new message is to be processed.  * In other words it restart from the top for every message.  * If round robin is enabled, then it keeps state and will continue with the next endpoint in a round robin fashion.  * <p/>  * You can also enable sticky mode together with round robin, if so then it will pick the last known good endpoint  * to use when starting the load balancing (instead of using the next when starting).  */ ;/**  * Whether or not the failover load balancer should operate in round robin mode or not.  * If not, then it will always start from the first endpoint when a new message is to be processed.  * In other words it restart from the top for every message.  * If round robin is enabled, then it keeps state and will continue with the next endpoint in a round robin fashion.  * <p/>  * You can also enable sticky mode together with round robin, if so then it will pick the last known good endpoint  * to use when starting the load balancing (instead of using the next when starting).  */ public void setRoundRobin(Boolean roundRobin) {     this.roundRobin = roundRobin. }
false;public;0;3;;public Boolean getSticky() {     return sticky. }
true;public;1;3;/**  * Whether or not the failover load balancer should operate in sticky mode or not.  * If not, then it will always start from the first endpoint when a new message is to be processed.  * In other words it restart from the top for every message.  * If sticky is enabled, then it keeps state and will continue with the last known good endpoint.  * <p/>  * You can also enable sticky mode together with round robin, if so then it will pick the last known good endpoint  * to use when starting the load balancing (instead of using the next when starting).  */ ;/**  * Whether or not the failover load balancer should operate in sticky mode or not.  * If not, then it will always start from the first endpoint when a new message is to be processed.  * In other words it restart from the top for every message.  * If sticky is enabled, then it keeps state and will continue with the last known good endpoint.  * <p/>  * You can also enable sticky mode together with round robin, if so then it will pick the last known good endpoint  * to use when starting the load balancing (instead of using the next when starting).  */ public void setSticky(Boolean sticky) {     this.sticky = sticky. }
false;public;0;3;;public Integer getMaximumFailoverAttempts() {     return maximumFailoverAttempts. }
true;public;1;3;/**  * A value to indicate after X failover attempts we should exhaust (give up).  * Use -1 to indicate never give up and continuously try to failover. Use 0 to never failover.  * And use e.g. 3 to failover at most 3 times before giving up.  * his option can be used whether or not roundRobin is enabled or not.  */ ;/**  * A value to indicate after X failover attempts we should exhaust (give up).  * Use -1 to indicate never give up and continuously try to failover. Use 0 to never failover.  * And use e.g. 3 to failover at most 3 times before giving up.  * his option can be used whether or not roundRobin is enabled or not.  */ public void setMaximumFailoverAttempts(Integer maximumFailoverAttempts) {     this.maximumFailoverAttempts = maximumFailoverAttempts. }
false;public;0;4;;@Override public String toString() {     return "FailoverLoadBalancer". }
