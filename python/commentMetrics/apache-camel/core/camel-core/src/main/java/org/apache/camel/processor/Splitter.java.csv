commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "Splitter[on: " + expression + " to: " + getProcessors().iterator().next() + " aggregate: " + getAggregationStrategy() + "]". }
false;public;0;4;;@Override public String getTraceLabel() {     return "split[" + expression + "]". }
false;public;2;29;;@Override public boolean process(Exchange exchange, final AsyncCallback callback) {     AggregationStrategy strategy = getAggregationStrategy().     // set original exchange if not already pre-configured     if (strategy instanceof UseOriginalAggregationStrategy) {         // need to create a new private instance, as we can also have concurrency issue so we cannot store state         UseOriginalAggregationStrategy original = (UseOriginalAggregationStrategy) strategy.         AggregationStrategy clone = original.newInstance(exchange).         if (isShareUnitOfWork()) {             clone = new ShareUnitOfWorkAggregationStrategy(clone).         }         setAggregationStrategyOnExchange(exchange, clone).     }     // to ensure it supports async routing     if (strategy == null) {         AggregationStrategy original = new UseOriginalAggregationStrategy(exchange, true).         if (isShareUnitOfWork()) {             original = new ShareUnitOfWorkAggregationStrategy(original).         }         setAggregationStrategyOnExchange(exchange, original).     }     return super.process(exchange, callback). }
false;protected;1;19;;@Override protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {     Object value = expression.evaluate(exchange, Object.class).     if (exchange.getException() != null) {         // force any exceptions occurred during evaluation to be thrown         throw exchange.getException().     }     Iterable<ProcessorExchangePair> answer = isStreaming() ? createProcessorExchangePairsIterable(exchange, value) : createProcessorExchangePairsList(exchange, value).     if (exchange.getException() != null) {         // before returning the answer.         throw exchange.getException().     }     return answer. }
false;private;2;3;;private Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {     return new SplitterIterable(exchange, value). }
false;public;0;18;;public boolean hasNext() {     if (closed) {         return false.     }     boolean answer = iterator.hasNext().     if (!answer) {         // we are now closed         closed = true.         // nothing more so we need to close the expression value in case it needs to be         try {             close().         } catch (IOException e) {             throw new RuntimeCamelException("Scanner aborted because of an IOException!", e).         }     }     return answer. }
false;public;0;29;;public ProcessorExchangePair next() {     Object part = iterator.next().     if (part != null) {         // create a correlated copy as the new exchange to be routed in the splitter from the copy         // and do not share the unit of work         Exchange newExchange = ExchangeHelper.createCorrelatedCopy(copy, false).         // Therefore, set the unit of work of the parent route as stream cache unit of work, if not already set.         if (newExchange.getProperty(Exchange.STREAM_CACHE_UNIT_OF_WORK) == null) {             newExchange.setProperty(Exchange.STREAM_CACHE_UNIT_OF_WORK, original.getUnitOfWork()).         }         // if we share unit of work, we need to prepare the child exchange         if (isShareUnitOfWork()) {             prepareSharedUnitOfWork(newExchange, copy).         }         if (part instanceof Message) {             newExchange.setIn((Message) part).         } else {             Message in = newExchange.getIn().             in.setBody(part).         }         return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange, routeContext).     } else {         return null.     } }
false;public;0;3;;public void remove() {     throw new UnsupportedOperationException("Remove is not supported by this iterator"). }
false;public;0;60;;@Override public Iterator<ProcessorExchangePair> iterator() {     return new Iterator<ProcessorExchangePair>() {          private int index.          private boolean closed.          public boolean hasNext() {             if (closed) {                 return false.             }             boolean answer = iterator.hasNext().             if (!answer) {                 // we are now closed                 closed = true.                 // nothing more so we need to close the expression value in case it needs to be                 try {                     close().                 } catch (IOException e) {                     throw new RuntimeCamelException("Scanner aborted because of an IOException!", e).                 }             }             return answer.         }          public ProcessorExchangePair next() {             Object part = iterator.next().             if (part != null) {                 // create a correlated copy as the new exchange to be routed in the splitter from the copy                 // and do not share the unit of work                 Exchange newExchange = ExchangeHelper.createCorrelatedCopy(copy, false).                 // Therefore, set the unit of work of the parent route as stream cache unit of work, if not already set.                 if (newExchange.getProperty(Exchange.STREAM_CACHE_UNIT_OF_WORK) == null) {                     newExchange.setProperty(Exchange.STREAM_CACHE_UNIT_OF_WORK, original.getUnitOfWork()).                 }                 // if we share unit of work, we need to prepare the child exchange                 if (isShareUnitOfWork()) {                     prepareSharedUnitOfWork(newExchange, copy).                 }                 if (part instanceof Message) {                     newExchange.setIn((Message) part).                 } else {                     Message in = newExchange.getIn().                     in.setBody(part).                 }                 return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange, routeContext).             } else {                 return null.             }         }          public void remove() {             throw new UnsupportedOperationException("Remove is not supported by this iterator").         }     }. }
false;public;0;4;;@Override public void close() throws IOException {     IOHelper.closeIterator(value). }
false;private;2;19;;private Iterable<ProcessorExchangePair> createProcessorExchangePairsList(Exchange exchange, Object value) {     List<ProcessorExchangePair> result = new ArrayList<>().     // reuse iterable and add it to the result list     Iterable<ProcessorExchangePair> pairs = createProcessorExchangePairsIterable(exchange, value).     try {         for (ProcessorExchangePair pair : pairs) {             if (pair != null) {                 result.add(pair).             }         }     } finally {         if (pairs instanceof Closeable) {             IOHelper.close((Closeable) pairs, "Splitter:ProcessorExchangePairs").         }     }     return result. }
false;protected;4;18;;@Override protected void updateNewExchange(Exchange exchange, int index, Iterable<ProcessorExchangePair> allPairs, boolean hasNext) {     // do not share unit of work     exchange.setUnitOfWork(null).     exchange.setProperty(Exchange.SPLIT_INDEX, index).     if (allPairs instanceof Collection) {         // non streaming mode, so we know the total size already         exchange.setProperty(Exchange.SPLIT_SIZE, ((Collection<?>) allPairs).size()).     }     if (hasNext) {         exchange.setProperty(Exchange.SPLIT_COMPLETE, Boolean.FALSE).     } else {         exchange.setProperty(Exchange.SPLIT_COMPLETE, Boolean.TRUE).         // streaming mode, so set total size when we are complete based on the index         exchange.setProperty(Exchange.SPLIT_SIZE, index + 1).     } }
false;protected;1;4;;@Override protected Integer getExchangeIndex(Exchange exchange) {     return exchange.getProperty(Exchange.SPLIT_INDEX, Integer.class). }
false;public;0;3;;public Expression getExpression() {     return expression. }
false;private,static;2;8;;private static Exchange copyExchangeNoAttachments(Exchange exchange, boolean preserveExchangeId) {     Exchange answer = ExchangeHelper.createCopy(exchange, preserveExchangeId).     // we do not want attachments for the splitted sub-messages     answer.getIn().setAttachmentObjects(null).     // we do not want to copy the message history for splitted sub-messages     answer.getProperties().remove(Exchange.MESSAGE_HISTORY).     return answer. }
