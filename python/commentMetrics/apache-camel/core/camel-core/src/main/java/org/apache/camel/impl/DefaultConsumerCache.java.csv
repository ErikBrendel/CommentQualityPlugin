commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isExtendedStatistics() {     return extendedStatistics. }
true;public;1;3;/**  * Whether extended JMX statistics is enabled for {@link org.apache.camel.spi.EndpointUtilizationStatistics}  */ ;/**  * Whether extended JMX statistics is enabled for {@link org.apache.camel.spi.EndpointUtilizationStatistics}  */ public void setExtendedStatistics(boolean extendedStatistics) {     this.extendedStatistics = extendedStatistics. }
true;public;2;3;/**  * Releases an acquired producer back after usage.  *  * @param endpoint the endpoint  * @param pollingConsumer the pollingConsumer to release  */ ;/**  * Releases an acquired producer back after usage.  *  * @param endpoint the endpoint  * @param pollingConsumer the pollingConsumer to release  */ public void releasePollingConsumer(Endpoint endpoint, PollingConsumer pollingConsumer) {     consumers.release(endpoint, pollingConsumer). }
true;public;1;11;/**  * Acquires a pooled PollingConsumer which you <b>must</b> release back again after usage using the  * {@link #releasePollingConsumer(org.apache.camel.Endpoint, org.apache.camel.PollingConsumer)} method.  *  * @param endpoint the endpoint  * @return the PollingConsumer  */ ;/**  * Acquires a pooled PollingConsumer which you <b>must</b> release back again after usage using the  * {@link #releasePollingConsumer(org.apache.camel.Endpoint, org.apache.camel.PollingConsumer)} method.  *  * @param endpoint the endpoint  * @return the PollingConsumer  */ public PollingConsumer acquirePollingConsumer(Endpoint endpoint) {     try {         PollingConsumer consumer = consumers.acquire(endpoint).         if (statistics != null) {             statistics.onHit(endpoint.getEndpointUri()).         }         return consumer.     } catch (Throwable e) {         throw new FailedToCreateConsumerException(endpoint, e).     } }
false;public;1;12;;public Exchange receive(Endpoint endpoint) {     log.debug("<<<< {}", endpoint).     PollingConsumer consumer = null.     try {         consumer = acquirePollingConsumer(endpoint).         return consumer.receive().     } finally {         if (consumer != null) {             releasePollingConsumer(endpoint, consumer).         }     } }
false;public;2;12;;public Exchange receive(Endpoint endpoint, long timeout) {     log.debug("<<<< {}", endpoint).     PollingConsumer consumer = null.     try {         consumer = acquirePollingConsumer(endpoint).         return consumer.receive(timeout).     } finally {         if (consumer != null) {             releasePollingConsumer(endpoint, consumer).         }     } }
false;public;1;12;;public Exchange receiveNoWait(Endpoint endpoint) {     log.debug("<<<< {}", endpoint).     PollingConsumer consumer = null.     try {         consumer = acquirePollingConsumer(endpoint).         return consumer.receiveNoWait().     } finally {         if (consumer != null) {             releasePollingConsumer(endpoint, consumer).         }     } }
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
true;public;0;3;/**  * Gets the source which uses this cache  *  * @return the source  */ ;/**  * Gets the source which uses this cache  *  * @return the source  */ public Object getSource() {     return source. }
true;public;0;5;/**  * Returns the current size of the cache  *  * @return the current size  */ ;/**  * Returns the current size of the cache  *  * @return the current size  */ public int size() {     int size = consumers.size().     log.trace("size = {}", size).     return size. }
true;public;0;3;/**  * Gets the maximum cache size (capacity).  * <p/>  * Will return <tt>-1</tt> if it cannot determine this if a custom cache was used.  *  * @return the capacity  */ ;/**  * Gets the maximum cache size (capacity).  * <p/>  * Will return <tt>-1</tt> if it cannot determine this if a custom cache was used.  *  * @return the capacity  */ public int getCapacity() {     return consumers.getMaxCacheSize(). }
true;public;0;3;/**  * Gets the cache hits statistic  * <p/>  * Will return <tt>-1</tt> if it cannot determine this if a custom cache was used.  *  * @return the hits  */ ;/**  * Gets the cache hits statistic  * <p/>  * Will return <tt>-1</tt> if it cannot determine this if a custom cache was used.  *  * @return the hits  */ public long getHits() {     return consumers.getHits(). }
true;public;0;3;/**  * Gets the cache misses statistic  * <p/>  * Will return <tt>-1</tt> if it cannot determine this if a custom cache was used.  *  * @return the misses  */ ;/**  * Gets the cache misses statistic  * <p/>  * Will return <tt>-1</tt> if it cannot determine this if a custom cache was used.  *  * @return the misses  */ public long getMisses() {     return consumers.getMisses(). }
true;public;0;3;/**  * Gets the cache evicted statistic  * <p/>  * Will return <tt>-1</tt> if it cannot determine this if a custom cache was used.  *  * @return the evicted  */ ;/**  * Gets the cache evicted statistic  * <p/>  * Will return <tt>-1</tt> if it cannot determine this if a custom cache was used.  *  * @return the evicted  */ public long getEvicted() {     return consumers.getEvicted(). }
true;public;0;6;/**  * Resets the cache statistics  */ ;/**  * Resets the cache statistics  */ public void resetCacheStatistics() {     consumers.resetStatistics().     if (statistics != null) {         statistics.clear().     } }
true;public,synchronized;0;11;/**  * Purges this cache  */ ;/**  * Purges this cache  */ public synchronized void purge() {     try {         consumers.stop().         consumers.start().     } catch (Exception e) {         log.debug("Error restarting consumer pool", e).     }     if (statistics != null) {         statistics.clear().     } }
true;public;0;3;/**  * Cleanup the cache (purging stale entries)  */ ;/**  * Cleanup the cache (purging stale entries)  */ public void cleanUp() {     consumers.cleanUp(). }
false;public;0;3;;public EndpointUtilizationStatistics getEndpointUtilizationStatistics() {     return statistics. }
false;public;0;4;;@Override public String toString() {     return "ConsumerCache for source: " + source + ", capacity: " + getCapacity(). }
false;protected;0;7;;protected void doStart() throws Exception {     if (extendedStatistics) {         int max = maxCacheSize == 0 ? CamelContextHelper.getMaximumCachePoolSize(camelContext) : maxCacheSize.         statistics = new DefaultEndpointUtilizationStatistics(max).     }     ServiceHelper.startService(consumers). }
false;protected;0;7;;protected void doStop() throws Exception {     // when stopping we intend to shutdown     ServiceHelper.stopAndShutdownServices(statistics, consumers).     if (statistics != null) {         statistics.clear().     } }
