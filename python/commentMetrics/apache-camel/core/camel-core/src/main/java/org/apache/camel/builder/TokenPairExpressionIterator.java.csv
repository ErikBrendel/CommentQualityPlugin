commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public boolean matches(Exchange exchange) {     // as a predicate we must close the stream, as we do not return an iterator that can be used     // afterwards to iterate the input stream     Object value = doEvaluate(exchange, true).     return ObjectHelper.evaluateValuePredicate(value). }
false;public;1;5;;@Override public Object evaluate(Exchange exchange) {     // as we return an iterator to access the input stream, we should not close it     return doEvaluate(exchange, false). }
true;protected;2;18;/**  * Strategy to evaluate the exchange  *  * @param exchange   the exchange  * @param closeStream whether to close the stream before returning from this method.  * @return the evaluated value  */ ;/**  * Strategy to evaluate the exchange  *  * @param exchange   the exchange  * @param closeStream whether to close the stream before returning from this method.  * @return the evaluated value  */ protected Object doEvaluate(Exchange exchange, boolean closeStream) {     InputStream in = null.     try {         in = exchange.getIn().getMandatoryBody(InputStream.class).         // we may read from a file, and want to support custom charset defined on the exchange         String charset = ExchangeHelper.getCharsetName(exchange).         return createIterator(exchange, in, charset).     } catch (InvalidPayloadException e) {         exchange.setException(e).         // must close input stream         IOHelper.close(in).         return null.     } finally {         if (closeStream) {             IOHelper.close(in).         }     } }
true;protected;3;13;/**  * Strategy to create the iterator  *  * @param exchange the exchange  * @param in input stream to iterate  * @param charset charset  * @return the iterator  */ ;/**  * Strategy to create the iterator  *  * @param exchange the exchange  * @param in input stream to iterate  * @param charset charset  * @return the iterator  */ protected Iterator<?> createIterator(Exchange exchange, InputStream in, String charset) {     String start = startToken.     if (start != null && SimpleLanguage.hasSimpleFunction(start)) {         start = SimpleLanguage.expression(start).evaluate(exchange, String.class).     }     String end = endToken.     if (end != null && SimpleLanguage.hasSimpleFunction(end)) {         end = SimpleLanguage.expression(end).evaluate(exchange, String.class).     }     TokenPairIterator iterator = new TokenPairIterator(start, end, includeTokens, in, charset).     iterator.init().     return iterator. }
false;public;0;4;;@Override public String toString() {     return "tokenize[body() using tokens: " + startToken + "..." + endToken + "]". }
false;;0;8;;void init() {     // use end token as delimiter     this.scanner = new Scanner(in, charset, scanEndToken).     // this iterator will do look ahead as we may have data     // after the last end token, which the scanner would find     // so we need to be one step ahead of the scanner     this.image = scanner.hasNext() ? next(true) : null. }
false;public;0;4;;@Override public boolean hasNext() {     return image != null. }
false;public;0;4;;@Override public Object next() {     return next(false). }
false;;1;15;;Object next(boolean first) {     Object answer = image.     // calculate next     if (scanner.hasNext()) {         image = getNext(first).     } else {         image = null.     }     if (answer == null) {         // first time the image may be null         answer = image.     }     return answer. }
false;;1;20;;Object getNext(boolean first) {     String next = scanner.next().     // only grab text after the start token     if (next != null && next.contains(startToken)) {         next = StringHelper.after(next, startToken).         // include tokens in answer         if (next != null && includeTokens) {             StringBuilder sb = new StringBuilder().             next = sb.append(startToken).append(next).append(endToken).toString().         }     } else {         // and should not return more data         return null.     }     return next. }
false;public;0;4;;@Override public void remove() { // noop }
false;public;0;4;;@Override public void close() throws IOException {     scanner.close(). }
