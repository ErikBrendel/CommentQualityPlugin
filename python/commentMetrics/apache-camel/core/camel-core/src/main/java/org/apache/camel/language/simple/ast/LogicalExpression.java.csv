commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return left + " " + token.getText() + " " + right. }
false;public;1;4;;public boolean acceptLeftNode(SimpleNode lef) {     this.left = lef.     return true. }
false;public;1;4;;public boolean acceptRightNode(SimpleNode right) {     this.right = right.     return true. }
false;public;0;3;;public LogicalOperatorType getOperator() {     return operator. }
false;public;1;16;;@Override public Expression createExpression(String expression) {     ObjectHelper.notNull(left, "left node", this).     ObjectHelper.notNull(right, "right node", this).     final Expression leftExp = left.createExpression(expression).     final Expression rightExp = right.createExpression(expression).     if (operator == LogicalOperatorType.AND) {         return createAndExpression(leftExp, rightExp).     } else if (operator == LogicalOperatorType.OR) {         return createOrExpression(leftExp, rightExp).     }     throw new SimpleParserException("Unknown logical operator " + operator, token.getIndex()). }
false;public;2;8;;@Override public <T> T evaluate(Exchange exchange, Class<T> type) {     Predicate predicate = ExpressionToPredicateAdapter.toPredicate(leftExp).     predicate = PredicateBuilder.and(predicate, ExpressionToPredicateAdapter.toPredicate(rightExp)).     boolean answer = predicate.matches(exchange).     return exchange.getContext().getTypeConverter().convertTo(type, answer). }
false;public;0;4;;@Override public String toString() {     return left + " " + token.getText() + " " + right. }
false;private;2;17;;private Expression createAndExpression(final Expression leftExp, final Expression rightExp) {     return new Expression() {          @Override         public <T> T evaluate(Exchange exchange, Class<T> type) {             Predicate predicate = ExpressionToPredicateAdapter.toPredicate(leftExp).             predicate = PredicateBuilder.and(predicate, ExpressionToPredicateAdapter.toPredicate(rightExp)).             boolean answer = predicate.matches(exchange).             return exchange.getContext().getTypeConverter().convertTo(type, answer).         }          @Override         public String toString() {             return left + " " + token.getText() + " " + right.         }     }. }
false;public;2;8;;@Override public <T> T evaluate(Exchange exchange, Class<T> type) {     Predicate predicate = ExpressionToPredicateAdapter.toPredicate(leftExp).     predicate = PredicateBuilder.or(predicate, ExpressionToPredicateAdapter.toPredicate(rightExp)).     boolean answer = predicate.matches(exchange).     return exchange.getContext().getTypeConverter().convertTo(type, answer). }
false;public;0;4;;@Override public String toString() {     return left + " " + token.getText() + " " + right. }
false;private;2;17;;private Expression createOrExpression(final Expression leftExp, final Expression rightExp) {     return new Expression() {          @Override         public <T> T evaluate(Exchange exchange, Class<T> type) {             Predicate predicate = ExpressionToPredicateAdapter.toPredicate(leftExp).             predicate = PredicateBuilder.or(predicate, ExpressionToPredicateAdapter.toPredicate(rightExp)).             boolean answer = predicate.matches(exchange).             return exchange.getContext().getTypeConverter().convertTo(type, answer).         }          @Override         public String toString() {             return left + " " + token.getText() + " " + right.         }     }. }
