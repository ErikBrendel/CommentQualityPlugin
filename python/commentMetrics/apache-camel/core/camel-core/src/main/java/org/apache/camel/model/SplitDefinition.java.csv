commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "Split[" + getExpression() + " -> " + getOutputs() + "]". }
false;public;0;4;;@Override public String getShortName() {     return "split". }
false;public;0;4;;@Override public String getLabel() {     return "split[" + getExpression() + "]". }
true;public;1;4;/**  * Sets the AggregationStrategy to be used to assemble the replies from the splitted messages, into a single outgoing message from the Splitter.  * By default Camel will use the original incoming message to the splitter (leave it unchanged). You can also use a POJO as the AggregationStrategy  */ ;// Fluent API // ------------------------------------------------------------------------- /**  * Sets the AggregationStrategy to be used to assemble the replies from the splitted messages, into a single outgoing message from the Splitter.  * By default Camel will use the original incoming message to the splitter (leave it unchanged). You can also use a POJO as the AggregationStrategy  */ public SplitDefinition aggregationStrategy(AggregationStrategy aggregationStrategy) {     setAggregationStrategy(aggregationStrategy).     return this. }
true;public;1;4;/**  * Sets a reference to the AggregationStrategy to be used to assemble the replies from the splitted messages, into a single outgoing message from the Splitter.  * By default Camel will use the original incoming message to the splitter (leave it unchanged). You can also use a POJO as the AggregationStrategy  */ ;/**  * Sets a reference to the AggregationStrategy to be used to assemble the replies from the splitted messages, into a single outgoing message from the Splitter.  * By default Camel will use the original incoming message to the splitter (leave it unchanged). You can also use a POJO as the AggregationStrategy  */ public SplitDefinition aggregationStrategyRef(String aggregationStrategyRef) {     setStrategyRef(aggregationStrategyRef).     return this. }
true;public;1;4;/**  * This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.  *  * @param  methodName the method name to call  * @return the builder  */ ;/**  * This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.  *  * @param  methodName the method name to call  * @return the builder  */ public SplitDefinition aggregationStrategyMethodName(String methodName) {     setStrategyMethodName(methodName).     return this. }
true;public;0;4;/**  * If this option is false then the aggregate method is not used if there was no data to enrich.  * If this option is true then null values is used as the oldExchange (when no data to enrich), when using POJOs as the AggregationStrategy  *  * @return the builder  */ ;/**  * If this option is false then the aggregate method is not used if there was no data to enrich.  * If this option is true then null values is used as the oldExchange (when no data to enrich), when using POJOs as the AggregationStrategy  *  * @return the builder  */ public SplitDefinition aggregationStrategyMethodAllowNull() {     setStrategyMethodAllowNull(true).     return this. }
true;public;0;4;/**  * If enabled then processing each splitted messages occurs concurrently.  * Note the caller thread will still wait until all messages has been fully processed, before it continues.  * Its only processing the sub messages from the splitter which happens concurrently.  *  * @return the builder  */ ;/**  * If enabled then processing each splitted messages occurs concurrently.  * Note the caller thread will still wait until all messages has been fully processed, before it continues.  * Its only processing the sub messages from the splitter which happens concurrently.  *  * @return the builder  */ public SplitDefinition parallelProcessing() {     setParallelProcessing(true).     return this. }
true;public;1;4;/**  * If enabled then processing each splitted messages occurs concurrently.  * Note the caller thread will still wait until all messages has been fully processed, before it continues.  * Its only processing the sub messages from the splitter which happens concurrently.  *  * @return the builder  */ ;/**  * If enabled then processing each splitted messages occurs concurrently.  * Note the caller thread will still wait until all messages has been fully processed, before it continues.  * Its only processing the sub messages from the splitter which happens concurrently.  *  * @return the builder  */ public SplitDefinition parallelProcessing(boolean parallelProcessing) {     setParallelProcessing(parallelProcessing).     return this. }
true;public;0;4;/**  * If enabled then the aggregate method on AggregationStrategy can be called concurrently.  * Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe.  * By default this is false meaning that Camel synchronizes the call to the aggregate method.  * Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.  *  * @return the builder  */ ;/**  * If enabled then the aggregate method on AggregationStrategy can be called concurrently.  * Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe.  * By default this is false meaning that Camel synchronizes the call to the aggregate method.  * Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.  *  * @return the builder  */ public SplitDefinition parallelAggregate() {     setParallelAggregate(true).     return this. }
true;public;0;4;/**  * If enabled, unwind exceptions occurring at aggregation time to the error handler when parallelProcessing is used.  * Currently, aggregation time exceptions do not stop the route processing when parallelProcessing is used.  * Enabling this option allows to work around this behavior.  *  * The default value is <code>false</code> for the sake of backward compatibility.  *  * @return the builder  */ ;/**  * If enabled, unwind exceptions occurring at aggregation time to the error handler when parallelProcessing is used.  * Currently, aggregation time exceptions do not stop the route processing when parallelProcessing is used.  * Enabling this option allows to work around this behavior.  *  * The default value is <code>false</code> for the sake of backward compatibility.  *  * @return the builder  */ public SplitDefinition stopOnAggregateException() {     setStopOnAggregateException(true).     return this. }
true;public;0;4;/**  * When in streaming mode, then the splitter splits the original message on-demand, and each splitted  * message is processed one by one. This reduces memory usage as the splitter do not split all the messages first,  * but then we do not know the total size, and therefore the {@link org.apache.camel.Exchange#SPLIT_SIZE} is empty.  * <p/>  * In non-streaming mode (default) the splitter will split each message first, to know the total size, and then  * process each message one by one. This requires to keep all the splitted messages in memory and therefore requires  * more memory. The total size is provided in the {@link org.apache.camel.Exchange#SPLIT_SIZE} header.  * <p/>  * The streaming mode also affects the aggregation behavior.  * If enabled then Camel will process replies out-of-order, eg in the order they come back.  * If disabled, Camel will process replies in the same order as the messages was splitted.  *  * @return the builder  */ ;/**  * When in streaming mode, then the splitter splits the original message on-demand, and each splitted  * message is processed one by one. This reduces memory usage as the splitter do not split all the messages first,  * but then we do not know the total size, and therefore the {@link org.apache.camel.Exchange#SPLIT_SIZE} is empty.  * <p/>  * In non-streaming mode (default) the splitter will split each message first, to know the total size, and then  * process each message one by one. This requires to keep all the splitted messages in memory and therefore requires  * more memory. The total size is provided in the {@link org.apache.camel.Exchange#SPLIT_SIZE} header.  * <p/>  * The streaming mode also affects the aggregation behavior.  * If enabled then Camel will process replies out-of-order, eg in the order they come back.  * If disabled, Camel will process replies in the same order as the messages was splitted.  *  * @return the builder  */ public SplitDefinition streaming() {     setStreaming(true).     return this. }
true;public;0;4;/**  * Will now stop further processing if an exception or failure occurred during processing of an  * {@link org.apache.camel.Exchange} and the caused exception will be thrown.  * <p/>  * Will also stop if processing the exchange failed (has a fault message) or an exception  * was thrown and handled by the error handler (such as using onException). In all situations  * the splitter will stop further processing. This is the same behavior as in pipeline, which  * is used by the routing engine.  * <p/>  * The default behavior is to <b>not</b> stop but continue processing till the end  *  * @return the builder  */ ;/**  * Will now stop further processing if an exception or failure occurred during processing of an  * {@link org.apache.camel.Exchange} and the caused exception will be thrown.  * <p/>  * Will also stop if processing the exchange failed (has a fault message) or an exception  * was thrown and handled by the error handler (such as using onException). In all situations  * the splitter will stop further processing. This is the same behavior as in pipeline, which  * is used by the routing engine.  * <p/>  * The default behavior is to <b>not</b> stop but continue processing till the end  *  * @return the builder  */ public SplitDefinition stopOnException() {     setStopOnException(true).     return this. }
true;public;1;4;/**  * To use a custom Thread Pool to be used for parallel processing.  * Notice if you set this option, then parallel processing is automatic implied, and you do not have to enable that option as well.  */ ;/**  * To use a custom Thread Pool to be used for parallel processing.  * Notice if you set this option, then parallel processing is automatic implied, and you do not have to enable that option as well.  */ public SplitDefinition executorService(ExecutorService executorService) {     setExecutorService(executorService).     return this. }
true;public;1;4;/**  * Refers to a custom Thread Pool to be used for parallel processing.  * Notice if you set this option, then parallel processing is automatic implied, and you do not have to enable that option as well.  */ ;/**  * Refers to a custom Thread Pool to be used for parallel processing.  * Notice if you set this option, then parallel processing is automatic implied, and you do not have to enable that option as well.  */ public SplitDefinition executorServiceRef(String executorServiceRef) {     setExecutorServiceRef(executorServiceRef).     return this. }
true;public;1;4;/**  * Uses the {@link Processor} when preparing the {@link org.apache.camel.Exchange} to be send.  * This can be used to deep-clone messages that should be send, or any custom logic needed before  * the exchange is send.  *  * @param onPrepare the processor  * @return the builder  */ ;/**  * Uses the {@link Processor} when preparing the {@link org.apache.camel.Exchange} to be send.  * This can be used to deep-clone messages that should be send, or any custom logic needed before  * the exchange is send.  *  * @param onPrepare the processor  * @return the builder  */ public SplitDefinition onPrepare(Processor onPrepare) {     setOnPrepare(onPrepare).     return this. }
true;public;1;4;/**  * Uses the {@link Processor} when preparing the {@link org.apache.camel.Exchange} to be send.  * This can be used to deep-clone messages that should be send, or any custom logic needed before  * the exchange is send.  *  * @param onPrepareRef reference to the processor to lookup in the {@link org.apache.camel.spi.Registry}  * @return the builder  */ ;/**  * Uses the {@link Processor} when preparing the {@link org.apache.camel.Exchange} to be send.  * This can be used to deep-clone messages that should be send, or any custom logic needed before  * the exchange is send.  *  * @param onPrepareRef reference to the processor to lookup in the {@link org.apache.camel.spi.Registry}  * @return the builder  */ public SplitDefinition onPrepareRef(String onPrepareRef) {     setOnPrepareRef(onPrepareRef).     return this. }
true;public;1;4;/**  * Sets a total timeout specified in millis, when using parallel processing.  * If the Splitter hasn't been able to split and process all the sub messages within the given timeframe,  * then the timeout triggers and the Splitter breaks out and continues.  * Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out.  * If the timeout is reached with running tasks still remaining, certain tasks for which it is difficult for Camel  * to shut down in a graceful manner may continue to run. So use this option with a bit of care.  *  * @param timeout timeout in millis  * @return the builder  */ ;/**  * Sets a total timeout specified in millis, when using parallel processing.  * If the Splitter hasn't been able to split and process all the sub messages within the given timeframe,  * then the timeout triggers and the Splitter breaks out and continues.  * Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out.  * If the timeout is reached with running tasks still remaining, certain tasks for which it is difficult for Camel  * to shut down in a graceful manner may continue to run. So use this option with a bit of care.  *  * @param timeout timeout in millis  * @return the builder  */ public SplitDefinition timeout(long timeout) {     setTimeout(timeout).     return this. }
true;public;0;4;/**  * Shares the {@link org.apache.camel.spi.UnitOfWork} with the parent and each of the sub messages.  * Splitter will by default not share unit of work between the parent exchange and each splitted exchange.  * This means each splitted exchange has its own individual unit of work.  *  * @return the builder.  * @see org.apache.camel.spi.SubUnitOfWork  */ ;/**  * Shares the {@link org.apache.camel.spi.UnitOfWork} with the parent and each of the sub messages.  * Splitter will by default not share unit of work between the parent exchange and each splitted exchange.  * This means each splitted exchange has its own individual unit of work.  *  * @return the builder.  * @see org.apache.camel.spi.SubUnitOfWork  */ public SplitDefinition shareUnitOfWork() {     setShareUnitOfWork(true).     return this. }
true;public;1;5;/**  * Expression of how to split the message body, such as as-is, using a tokenizer, or using an xpath.  */ ;// Properties // ------------------------------------------------------------------------- /**  * Expression of how to split the message body, such as as-is, using a tokenizer, or using an xpath.  */ @Override public void setExpression(ExpressionDefinition expression) {     // override to include javadoc what the expression is used for     super.setExpression(expression). }
false;public;0;3;;public AggregationStrategy getAggregationStrategy() {     return aggregationStrategy. }
true;public;1;3;/**  * Sets the AggregationStrategy to be used to assemble the replies from the splitted messages, into a single outgoing message from the Splitter.  * By default Camel will use the original incoming message to the splitter (leave it unchanged). You can also use a POJO as the AggregationStrategy  */ ;/**  * Sets the AggregationStrategy to be used to assemble the replies from the splitted messages, into a single outgoing message from the Splitter.  * By default Camel will use the original incoming message to the splitter (leave it unchanged). You can also use a POJO as the AggregationStrategy  */ public void setAggregationStrategy(AggregationStrategy aggregationStrategy) {     this.aggregationStrategy = aggregationStrategy. }
false;public;0;3;;public Boolean getParallelProcessing() {     return parallelProcessing. }
false;public;1;3;;public void setParallelProcessing(Boolean parallelProcessing) {     this.parallelProcessing = parallelProcessing. }
false;public;0;3;;public Boolean getStreaming() {     return streaming. }
false;public;1;3;;public void setStreaming(Boolean streaming) {     this.streaming = streaming. }
false;public;0;3;;public Boolean getParallelAggregate() {     return parallelAggregate. }
false;public;1;3;;public void setParallelAggregate(Boolean parallelAggregate) {     this.parallelAggregate = parallelAggregate. }
false;public;0;3;;public Boolean getStopOnAggregateException() {     return this.stopOnAggregateException. }
false;public;1;3;;public void setStopOnAggregateException(Boolean stopOnAggregateException) {     this.stopOnAggregateException = stopOnAggregateException. }
false;public;0;3;;public Boolean getStopOnException() {     return stopOnException. }
false;public;1;3;;public void setStopOnException(Boolean stopOnException) {     this.stopOnException = stopOnException. }
false;public;0;3;;public Boolean isStopOnException() {     return stopOnException != null && stopOnException. }
false;public;0;3;;public ExecutorService getExecutorService() {     return executorService. }
false;public;1;3;;public void setExecutorService(ExecutorService executorService) {     this.executorService = executorService. }
false;public;0;3;;public String getStrategyRef() {     return strategyRef. }
true;public;1;3;/**  * Sets a reference to the AggregationStrategy to be used to assemble the replies from the splitted messages, into a single outgoing message from the Splitter.  * By default Camel will use the original incoming message to the splitter (leave it unchanged). You can also use a POJO as the AggregationStrategy  */ ;/**  * Sets a reference to the AggregationStrategy to be used to assemble the replies from the splitted messages, into a single outgoing message from the Splitter.  * By default Camel will use the original incoming message to the splitter (leave it unchanged). You can also use a POJO as the AggregationStrategy  */ public void setStrategyRef(String strategyRef) {     this.strategyRef = strategyRef. }
false;public;0;3;;public String getStrategyMethodName() {     return strategyMethodName. }
true;public;1;3;/**  * This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.  */ ;/**  * This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.  */ public void setStrategyMethodName(String strategyMethodName) {     this.strategyMethodName = strategyMethodName. }
false;public;0;3;;public Boolean getStrategyMethodAllowNull() {     return strategyMethodAllowNull. }
true;public;1;3;/**  * If this option is false then the aggregate method is not used if there was no data to enrich.  * If this option is true then null values is used as the oldExchange (when no data to enrich), when using POJOs as the AggregationStrategy  */ ;/**  * If this option is false then the aggregate method is not used if there was no data to enrich.  * If this option is true then null values is used as the oldExchange (when no data to enrich), when using POJOs as the AggregationStrategy  */ public void setStrategyMethodAllowNull(Boolean strategyMethodAllowNull) {     this.strategyMethodAllowNull = strategyMethodAllowNull. }
false;public;0;3;;public String getExecutorServiceRef() {     return executorServiceRef. }
false;public;1;3;;public void setExecutorServiceRef(String executorServiceRef) {     this.executorServiceRef = executorServiceRef. }
false;public;0;3;;public Long getTimeout() {     return timeout. }
false;public;1;3;;public void setTimeout(Long timeout) {     this.timeout = timeout. }
false;public;0;3;;public String getOnPrepareRef() {     return onPrepareRef. }
false;public;1;3;;public void setOnPrepareRef(String onPrepareRef) {     this.onPrepareRef = onPrepareRef. }
false;public;0;3;;public Processor getOnPrepare() {     return onPrepare. }
false;public;1;3;;public void setOnPrepare(Processor onPrepare) {     this.onPrepare = onPrepare. }
false;public;0;3;;public Boolean getShareUnitOfWork() {     return shareUnitOfWork. }
false;public;1;3;;public void setShareUnitOfWork(Boolean shareUnitOfWork) {     this.shareUnitOfWork = shareUnitOfWork. }
