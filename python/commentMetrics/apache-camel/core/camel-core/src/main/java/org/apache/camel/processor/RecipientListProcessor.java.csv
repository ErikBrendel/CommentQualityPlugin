commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public int getIndex() {     return index. }
false;public;0;3;;public Exchange getExchange() {     return exchange. }
false;public;0;3;;public Producer getProducer() {     return producer. }
false;public;0;3;;public Processor getProcessor() {     return prepared. }
false;public;0;13;;public void begin() {     // we have already acquired and prepare the producer     LOG.trace("RecipientProcessorExchangePair #{} begin: {}", index, exchange).     exchange.setProperty(Exchange.RECIPIENT_LIST_ENDPOINT, endpoint.getEndpointUri()).     // ensure stream caching is reset     MessageHelper.resetStreamCache(exchange.getIn()).     // if the MEP on the endpoint is different then     if (pattern != null) {         originalPattern = exchange.getPattern().         LOG.trace("Using exchangePattern: {} on exchange: {}", pattern, exchange).         exchange.setPattern(pattern).     } }
false;public;0;15;;public void done() {     LOG.trace("RecipientProcessorExchangePair #{} done: {}", index, exchange).     try {         // preserve original MEP         if (originalPattern != null) {             exchange.setPattern(originalPattern).         }         // when we are done we should release back in pool         producerCache.releaseProducer(endpoint, producer).     } catch (Exception e) {         if (LOG.isDebugEnabled()) {             LOG.debug("Error releasing producer: " + producer + ". This exception will be ignored.", e).         }     } }
false;public;0;3;;public boolean isIgnoreInvalidEndpoints() {     return ignoreInvalidEndpoints. }
false;public;1;3;;public void setIgnoreInvalidEndpoints(boolean ignoreInvalidEndpoints) {     this.ignoreInvalidEndpoints = ignoreInvalidEndpoints. }
false;protected;1;34;;@Override protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {     // here we iterate the recipient lists and create the exchange pair for each of those     List<ProcessorExchangePair> result = new ArrayList<>().     // at first we must lookup the endpoint and acquire the producer which can send to the endpoint     int index = 0.     while (iter.hasNext()) {         Object recipient = iter.next().         Endpoint endpoint.         Producer producer.         ExchangePattern pattern.         try {             endpoint = resolveEndpoint(exchange, recipient).             pattern = resolveExchangePattern(recipient).             producer = producerCache.acquireProducer(endpoint).         } catch (Exception e) {             if (isIgnoreInvalidEndpoints()) {                 if (log.isDebugEnabled()) {                     log.debug("Endpoint uri is invalid: " + recipient + ". This exception will be ignored.", e).                 }                 continue.             } else {                 // failure so break out                 throw e.             }         }         // then create the exchange pair         result.add(createProcessorExchangePair(index++, endpoint, producer, exchange, pattern)).     }     return result. }
true;protected;5;30;/**  * This logic is similar to MulticastProcessor but we have to return a RecipientProcessorExchangePair instead  */ ;/**  * This logic is similar to MulticastProcessor but we have to return a RecipientProcessorExchangePair instead  */ protected ProcessorExchangePair createProcessorExchangePair(int index, Endpoint endpoint, Producer producer, Exchange exchange, ExchangePattern pattern) {     Processor prepared = producer.     // copy exchange, and do not share the unit of work     Exchange copy = ExchangeHelper.createCorrelatedCopy(exchange, false).     // if we share unit of work, we need to prepare the child exchange     if (isShareUnitOfWork()) {         prepareSharedUnitOfWork(copy, exchange).     }     // set property which endpoint we send to     setToEndpoint(copy, prepared).     // rework error handling to support fine grained error handling     RouteContext routeContext = exchange.getUnitOfWork() != null ? exchange.getUnitOfWork().getRouteContext() : null.     prepared = createErrorHandler(routeContext, copy, prepared).     // invoke on prepare on the exchange if specified     if (onPrepare != null) {         try {             onPrepare.process(copy).         } catch (Exception e) {             copy.setException(e).         }     }     // and create the pair     return new RecipientProcessorExchangePair(index, producerCache, endpoint, producer, prepared, copy, pattern). }
false;protected,static;2;7;;protected static Endpoint resolveEndpoint(Exchange exchange, Object recipient) {     // trim strings as end users might have added spaces between separators     if (recipient instanceof String) {         recipient = ((String) recipient).trim().     }     return ExchangeHelper.resolveEndpoint(exchange, recipient). }
false;protected;1;10;;protected ExchangePattern resolveExchangePattern(Object recipient) throws UnsupportedEncodingException, URISyntaxException, MalformedURLException {     // trim strings as end users might have added spaces between separators     if (recipient instanceof String) {         String s = ((String) recipient).trim().         // see if exchangePattern is a parameter in the url         s = URISupport.normalizeUri(s).         return EndpointHelper.resolveExchangePatternFromUrl(s).     }     return null. }
false;protected;0;7;;protected void doStart() throws Exception {     super.doStart().     if (producerCache == null) {         producerCache = new DefaultProducerCache(this, getCamelContext(), 0).     }     ServiceHelper.startService(producerCache). }
false;protected;0;4;;protected void doStop() throws Exception {     ServiceHelper.stopService(producerCache).     super.doStop(). }
false;protected;0;4;;protected void doShutdown() throws Exception {     ServiceHelper.stopAndShutdownService(producerCache).     super.doShutdown(). }
false;public;0;4;;@Override public String toString() {     return "RecipientList". }
false;public;0;4;;@Override public String getTraceLabel() {     return "recipientList". }
