commented;modifiers;parameterAmount;loc;comment;code
false;public;1;10;;@Override public Object evaluate(Exchange exchange) {     // evaluate arguments on each invocation as the parameters can have changed/updated since last invocation     final Object[] arguments = parametersExpression.evaluate(exchange, Object[].class).     try {         return invoke(method, pojo, arguments, exchange).     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;public;0;4;;@Override public String toString() {     return "DynamicRouter[invoking: " + method + " on bean: " + pojo + "]". }
false;private;2;5;;private Map<Class<?>, Annotation> collectMethodAnnotations(Class<?> c, Method method) {     Map<Class<?>, Annotation> annotations = new HashMap<>().     collectMethodAnnotations(c, method, annotations).     return annotations. }
false;private;3;19;;private void collectMethodAnnotations(Class<?> c, Method method, Map<Class<?>, Annotation> annotations) {     for (Class<?> i : c.getInterfaces()) {         collectMethodAnnotations(i, method, annotations).     }     if (!c.isInterface() && c.getSuperclass() != null) {         collectMethodAnnotations(c.getSuperclass(), method, annotations).     }     // make sure the sub class can override the definition     try {         Annotation[] ma = c.getDeclaredMethod(method.getName(), method.getParameterTypes()).getAnnotations().         for (Annotation a : ma) {             annotations.put(a.annotationType(), a).         }     } catch (SecurityException e) {     // do nothing here     } catch (NoSuchMethodException e) {     // do nothing here     } }
true;private;1;8;/**  * Does the given context match this camel context  */ ;/**  * Does the given context match this camel context  */ private boolean matchContext(String context) {     if (org.apache.camel.util.ObjectHelper.isNotEmpty(context)) {         if (!camelContext.getName().equals(context)) {             return false.         }     }     return true. }
false;public;0;3;;public String toString() {     return method.toString(). }
false;public;0;3;;public Method getMethod() {     return method. }
false;public;0;3;;public Object[] getArguments() {     return arguments. }
false;public;1;18;;public boolean proceed(AsyncCallback callback) {     Object body = exchange.getIn().getBody().     if (body instanceof StreamCache) {         // ensure the stream cache is reset before calling the method         ((StreamCache) body).reset().     }     try {         return doProceed(callback).     } catch (InvocationTargetException e) {         exchange.setException(e.getTargetException()).         callback.done(true).         return true.     } catch (Throwable e) {         exchange.setException(e).         callback.done(true).         return true.     } }
false;private;1;69;;private boolean doProceed(AsyncCallback callback) throws Exception {     // dynamic router should be invoked beforehand     if (dynamicRouter != null) {         if (!dynamicRouter.isStarted()) {             ServiceHelper.startService(dynamicRouter).         }         // use a expression which invokes the method to be used by dynamic router         Expression expression = new DynamicRouterExpression(pojo).         return dynamicRouter.doRoutingSlip(exchange, expression, callback).     }     // invoke pojo     if (LOG.isTraceEnabled()) {         LOG.trace(">>>> invoking: {} on bean: {} with arguments: {} for exchange: {}", method, pojo, asString(arguments), exchange).     }     Object result = invoke(method, pojo, arguments, exchange).     // the method may be a closure or chained method returning a callable which should be called     if (result instanceof Callable) {         LOG.trace("Method returned Callback which will be called: {}", result).         Object callableResult = ((Callable) result).call().         if (callableResult != null) {             result = callableResult.         } else {             // if callable returned null we should not change the body             result = Void.TYPE.         }     }     if (recipientList != null) {         // ensure its started         if (!recipientList.isStarted()) {             ServiceHelper.startService(recipientList).         }         return recipientList.sendToRecipientList(exchange, result, callback).     }     if (routingSlip != null) {         if (!routingSlip.isStarted()) {             ServiceHelper.startService(routingSlip).         }         return routingSlip.doRoutingSlip(exchange, result, callback).     }     // If it's Java 8 async result     if (CompletionStage.class.isAssignableFrom(getMethod().getReturnType())) {         CompletionStage<?> completionStage = (CompletionStage<?>) result.         completionStage.whenComplete((resultObject, e) -> {             if (e != null) {                 exchange.setException(e).             } else if (resultObject != null) {                 fillResult(exchange, resultObject).             }             callback.done(false).         }).         return false.     }     // if the method returns something then set the value returned on the Exchange     if (!getMethod().getReturnType().equals(Void.TYPE) && result != Void.TYPE) {         fillResult(exchange, result).     }     // we did not use any of the eips, but just invoked the bean     // so notify the callback we are done synchronously     callback.done(true).     return true. }
false;public;0;3;;public Object getThis() {     return pojo. }
false;public;0;3;;public AccessibleObject getStaticPart() {     return method. }
false;public;3;115;;public MethodInvocation createMethodInvocation(final Object pojo, boolean hasParameters, final Exchange exchange) {     final Object[] arguments.     if (hasParameters) {         arguments = parametersExpression.evaluate(exchange, Object[].class).     } else {         arguments = null.     }     return new MethodInvocation() {          public Method getMethod() {             return method.         }          public Object[] getArguments() {             return arguments.         }          public boolean proceed(AsyncCallback callback) {             Object body = exchange.getIn().getBody().             if (body instanceof StreamCache) {                 // ensure the stream cache is reset before calling the method                 ((StreamCache) body).reset().             }             try {                 return doProceed(callback).             } catch (InvocationTargetException e) {                 exchange.setException(e.getTargetException()).                 callback.done(true).                 return true.             } catch (Throwable e) {                 exchange.setException(e).                 callback.done(true).                 return true.             }         }          private boolean doProceed(AsyncCallback callback) throws Exception {             // dynamic router should be invoked beforehand             if (dynamicRouter != null) {                 if (!dynamicRouter.isStarted()) {                     ServiceHelper.startService(dynamicRouter).                 }                 // use a expression which invokes the method to be used by dynamic router                 Expression expression = new DynamicRouterExpression(pojo).                 return dynamicRouter.doRoutingSlip(exchange, expression, callback).             }             // invoke pojo             if (LOG.isTraceEnabled()) {                 LOG.trace(">>>> invoking: {} on bean: {} with arguments: {} for exchange: {}", method, pojo, asString(arguments), exchange).             }             Object result = invoke(method, pojo, arguments, exchange).             // the method may be a closure or chained method returning a callable which should be called             if (result instanceof Callable) {                 LOG.trace("Method returned Callback which will be called: {}", result).                 Object callableResult = ((Callable) result).call().                 if (callableResult != null) {                     result = callableResult.                 } else {                     // if callable returned null we should not change the body                     result = Void.TYPE.                 }             }             if (recipientList != null) {                 // ensure its started                 if (!recipientList.isStarted()) {                     ServiceHelper.startService(recipientList).                 }                 return recipientList.sendToRecipientList(exchange, result, callback).             }             if (routingSlip != null) {                 if (!routingSlip.isStarted()) {                     ServiceHelper.startService(routingSlip).                 }                 return routingSlip.doRoutingSlip(exchange, result, callback).             }             // If it's Java 8 async result             if (CompletionStage.class.isAssignableFrom(getMethod().getReturnType())) {                 CompletionStage<?> completionStage = (CompletionStage<?>) result.                 completionStage.whenComplete((resultObject, e) -> {                     if (e != null) {                         exchange.setException(e).                     } else if (resultObject != null) {                         fillResult(exchange, resultObject).                     }                     callback.done(false).                 }).                 return false.             }             // if the method returns something then set the value returned on the Exchange             if (!getMethod().getReturnType().equals(Void.TYPE) && result != Void.TYPE) {                 fillResult(exchange, result).             }             // we did not use any of the eips, but just invoked the bean             // so notify the callback we are done synchronously             callback.done(true).             return true.         }          public Object getThis() {             return pojo.         }          public AccessibleObject getStaticPart() {             return method.         }     }. }
false;private;2;33;;private void fillResult(Exchange exchange, Object result) {     LOG.trace("Setting bean invocation result : {}", result).     // the bean component forces OUT if the MEP is OUT capable     boolean out = ExchangeHelper.isOutCapable(exchange) || exchange.hasOut().     Message old.     if (out) {         old = exchange.getOut().         // propagate headers         exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders()).         // propagate attachments         if (exchange.getIn().hasAttachments()) {             exchange.getOut().getAttachments().putAll(exchange.getIn().getAttachments()).         }     } else {         old = exchange.getIn().     }     // create a new message container so we do not drag specialized message objects along     // but that is only needed if the old message is a specialized message     boolean copyNeeded = !(old.getClass().equals(DefaultMessage.class)).     if (copyNeeded) {         Message msg = new DefaultMessage(exchange.getContext()).         msg.copyFromWithNewBody(old, result).         // replace message on exchange         ExchangeHelper.replaceMessage(exchange, msg, false).     } else {         // no copy needed so set replace value directly         old.setBody(result).     } }
false;public;0;3;;public Class<?> getType() {     return type. }
false;public;0;3;;public Method getMethod() {     return method. }
true;public;0;3;/**  * Returns the {@link org.apache.camel.ExchangePattern} that should be used when invoking this method. This value  * defaults to {@link org.apache.camel.ExchangePattern#InOut} unless some {@link org.apache.camel.Pattern} annotation is used  * to override the message exchange pattern.  *  * @return the exchange pattern to use for invoking this method.  */ ;/**  * Returns the {@link org.apache.camel.ExchangePattern} that should be used when invoking this method. This value  * defaults to {@link org.apache.camel.ExchangePattern#InOut} unless some {@link org.apache.camel.Pattern} annotation is used  * to override the message exchange pattern.  *  * @return the exchange pattern to use for invoking this method.  */ public ExchangePattern getPattern() {     return pattern. }
false;public;0;3;;public Expression getParametersExpression() {     return parametersExpression. }
false;public;0;3;;public List<ParameterInfo> getBodyParameters() {     return bodyParameters. }
false;public;0;7;;public Class<?> getBodyParameterType() {     if (bodyParameters.isEmpty()) {         return null.     }     ParameterInfo parameterInfo = bodyParameters.get(0).     return parameterInfo.getType(). }
false;public;1;4;;public boolean bodyParameterMatches(Class<?> bodyType) {     Class<?> actualType = getBodyParameterType().     return actualType != null && org.apache.camel.util.ObjectHelper.isAssignableFrom(bodyType, actualType). }
false;public;0;3;;public List<ParameterInfo> getParameters() {     return parameters. }
false;public;0;3;;public boolean hasBodyParameter() {     return !bodyParameters.isEmpty(). }
false;public;0;3;;public boolean hasCustomAnnotation() {     return hasCustomAnnotation. }
false;public;0;3;;public boolean hasHandlerAnnotation() {     return hasHandlerAnnotation. }
false;public;0;3;;public boolean hasParameters() {     return !parameters.isEmpty(). }
false;public;0;3;;public boolean isReturnTypeVoid() {     return method.getReturnType().getName().equals("void"). }
false;public;0;3;;public boolean isStaticMethod() {     return Modifier.isStatic(method.getModifiers()). }
true;public;1;7;/**  * Returns true if this method is covariant with the specified method  * (this method may above or below the specified method in the class hierarchy)  */ ;/**  * Returns true if this method is covariant with the specified method  * (this method may above or below the specified method in the class hierarchy)  */ public boolean isCovariantWith(MethodInfo method) {     return method.getMethod().getName().equals(this.getMethod().getName()) && (method.getMethod().getReturnType().isAssignableFrom(this.getMethod().getReturnType()) || this.getMethod().getReturnType().isAssignableFrom(method.getMethod().getReturnType())) && Arrays.deepEquals(method.getMethod().getParameterTypes(), this.getMethod().getParameterTypes()). }
false;protected;4;9;;protected Object invoke(Method mth, Object pojo, Object[] arguments, Exchange exchange) throws InvocationTargetException {     try {         return mth.invoke(pojo, arguments).     } catch (IllegalAccessException e) {         throw new RuntimeExchangeException("IllegalAccessException occurred invoking method: " + mth + " using arguments: " + Arrays.asList(arguments), exchange, e).     } catch (IllegalArgumentException e) {         throw new RuntimeExchangeException("IllegalArgumentException occurred invoking method: " + mth + " using arguments: " + Arrays.asList(arguments), exchange, e).     } }
false;protected;0;13;;protected Expression[] createParameterExpressions() {     final int size = parameters.size().     LOG.trace("Creating parameters expression for {} parameters", size).     final Expression[] expressions = new Expression[size].     for (int i = 0. i < size. i++) {         Expression parameterExpression = parameters.get(i).getExpression().         expressions[i] = parameterExpression.         LOG.trace("Parameter #{} has expression: {}", i, parameterExpression).     }     return expressions. }
false;protected;0;3;;protected Expression createParametersExpression() {     return new ParameterExpression(createParameterExpressions()). }
true;protected;1;21;/**  * Finds the oneway annotation in priority order. look for method level annotations first, then the class level annotations,  * then super class annotations then interface annotations  *  * @param method the method on which to search  * @return the first matching annotation or none if it is not available  */ ;/**  * Finds the oneway annotation in priority order. look for method level annotations first, then the class level annotations,  * then super class annotations then interface annotations  *  * @param method the method on which to search  * @return the first matching annotation or none if it is not available  */ protected Pattern findOneWayAnnotation(Method method) {     Pattern answer = getPatternAnnotation(method).     if (answer == null) {         Class<?> type = method.getDeclaringClass().         // create the search order of types to scan         List<Class<?>> typesToSearch = new ArrayList<>().         addTypeAndSuperTypes(type, typesToSearch).         Class<?>[] interfaces = type.getInterfaces().         for (Class<?> anInterface : interfaces) {             addTypeAndSuperTypes(anInterface, typesToSearch).         }         // now let's scan for a type which the current declared class overloads         answer = findOneWayAnnotationOnMethod(typesToSearch, method).         if (answer == null) {             answer = findOneWayAnnotation(typesToSearch).         }     }     return answer. }
true;protected;1;3;/**  * Returns the pattern annotation on the given annotated element. either as a direct annotation or  * on an annotation which is also annotated  *  * @param annotatedElement the element to look for the annotation  * @return the first matching annotation or null if none could be found  */ ;/**  * Returns the pattern annotation on the given annotated element. either as a direct annotation or  * on an annotation which is also annotated  *  * @param annotatedElement the element to look for the annotation  * @return the first matching annotation or null if none could be found  */ protected Pattern getPatternAnnotation(AnnotatedElement annotatedElement) {     return getPatternAnnotation(annotatedElement, 2). }
true;protected;2;25;/**  * Returns the pattern annotation on the given annotated element. either as a direct annotation or  * on an annotation which is also annotated  *  * @param annotatedElement the element to look for the annotation  * @param depth the current depth  * @return the first matching annotation or null if none could be found  */ ;/**  * Returns the pattern annotation on the given annotated element. either as a direct annotation or  * on an annotation which is also annotated  *  * @param annotatedElement the element to look for the annotation  * @param depth the current depth  * @return the first matching annotation or null if none could be found  */ protected Pattern getPatternAnnotation(AnnotatedElement annotatedElement, int depth) {     Pattern answer = annotatedElement.getAnnotation(Pattern.class).     int nextDepth = depth - 1.     if (nextDepth > 0) {         // look at all the annotations to see if any of those are annotated         Annotation[] annotations = annotatedElement.getAnnotations().         for (Annotation annotation : annotations) {             Class<? extends Annotation> annotationType = annotation.annotationType().             if (annotation instanceof Pattern || annotationType.equals(annotatedElement)) {                 continue.             } else {                 Pattern another = getPatternAnnotation(annotationType, nextDepth).                 if (pattern != null) {                     if (answer == null) {                         answer = another.                     } else {                         LOG.warn("Duplicate pattern annotation: {} found on annotation: {} which will be ignored", another, annotation).                     }                 }             }         }     }     return answer. }
true;protected;2;5;/**  * Adds the current class and all of its base classes (apart from {@link Object} to the given list  */ ;/**  * Adds the current class and all of its base classes (apart from {@link Object} to the given list  */ protected void addTypeAndSuperTypes(Class<?> type, List<Class<?>> result) {     for (Class<?> t = type. t != null && t != Object.class. t = t.getSuperclass()) {         result.add(t).     } }
true;protected;2;14;/**  * Finds the first annotation on the base methods defined in the list of classes  */ ;/**  * Finds the first annotation on the base methods defined in the list of classes  */ protected Pattern findOneWayAnnotationOnMethod(List<Class<?>> classes, Method method) {     for (Class<?> type : classes) {         try {             Method definedMethod = type.getMethod(method.getName(), method.getParameterTypes()).             Pattern answer = getPatternAnnotation(definedMethod).             if (answer != null) {                 return answer.             }         } catch (NoSuchMethodException e) {         // ignore         }     }     return null. }
true;protected;1;9;/**  * Finds the first annotation on the given list of classes  */ ;/**  * Finds the first annotation on the given list of classes  */ protected Pattern findOneWayAnnotation(List<Class<?>> classes) {     for (Class<?> type : classes) {         Pattern answer = getPatternAnnotation(type).         if (answer != null) {             return answer.         }     }     return null. }
false;protected;0;8;;protected boolean hasExceptionParameter() {     for (ParameterInfo parameter : parameters) {         if (Exception.class.isAssignableFrom(parameter.getType())) {             return true.         }     }     return false. }
false;public;2;29;;@SuppressWarnings("unchecked") public <T> T evaluate(Exchange exchange, Class<T> type) {     Object body = exchange.getIn().getBody().     // if there was an explicit method name to invoke, then we should support using     // any provided parameter values in the method name     String methodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, String.class).     // the parameter values is between the parenthesis     String methodParameters = StringHelper.betweenOuterPair(methodName, '(', ')').     // use an iterator to walk the parameter values     Iterator<?> it = null.     if (methodParameters != null) {         // split the parameters safely separated by comma, but beware that we can have         // quoted parameters which contains comma as well, so do a safe quote split         String[] parameters = StringQuoteHelper.splitSafeQuote(methodParameters, ',', true).         it = ObjectHelper.createIterator(parameters, ",", true).     }     // must be removed at this point of time     if (methodName != null) {         exchange.getIn().removeHeader(Exchange.BEAN_METHOD_NAME).     }     Object[] answer = evaluateParameterExpressions(exchange, body, it).     return (T) answer. }
true;private;3;35;/**  * Evaluates all the parameter expressions  */ ;/**  * Evaluates all the parameter expressions  */ private Object[] evaluateParameterExpressions(Exchange exchange, Object body, Iterator<?> it) {     Object[] answer = new Object[expressions.length].     for (int i = 0. i < expressions.length. i++) {         if (body instanceof StreamCache) {             // need to reset stream cache for each expression as you may access the message body in multiple parameters             ((StreamCache) body).reset().         }         // grab the parameter value for the given index         Object parameterValue = it != null && it.hasNext() ? it.next() : null.         // and the expected parameter type         Class<?> parameterType = parameters.get(i).getType().         // the value for the parameter to use         Object value = null.         // we should skip * as its a type placeholder to indicate any type         if (parameterValue != null && !parameterValue.equals("*")) {             // evaluate the parameter value binding             value = evaluateParameterValue(exchange, i, parameterValue, parameterType).         }         // use bean parameter binding, if still no value         Expression expression = expressions[i].         if (value == null && expression != null) {             value = evaluateParameterBinding(exchange, expression, i, parameterType).         }         // remember the value to use         if (value != Void.TYPE) {             answer[i] = value.         }     }     return answer. }
true;private;4;77;/**  * Evaluate using parameter values where the values can be provided in the method name syntax.  * <p/>  * This methods returns accordingly:  * <ul>  *     <li><tt>null</tt> - if not a parameter value</li>  *     <li><tt>Void.TYPE</tt> - if an explicit null, forcing Camel to pass in <tt>null</tt> for that given parameter</li>  *     <li>a non <tt>null</tt> value - if the parameter was a parameter value, and to be used</li>  * </ul>  *  * @since 2.9  */ ;/**  * Evaluate using parameter values where the values can be provided in the method name syntax.  * <p/>  * This methods returns accordingly:  * <ul>  *     <li><tt>null</tt> - if not a parameter value</li>  *     <li><tt>Void.TYPE</tt> - if an explicit null, forcing Camel to pass in <tt>null</tt> for that given parameter</li>  *     <li>a non <tt>null</tt> value - if the parameter was a parameter value, and to be used</li>  * </ul>  *  * @since 2.9  */ private Object evaluateParameterValue(Exchange exchange, int index, Object parameterValue, Class<?> parameterType) {     Object answer = null.     // convert the parameter value to a String     String exp = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, parameterValue).     if (exp != null) {         // check if its a valid parameter value         boolean valid = BeanHelper.isValidParameterValue(exp).         if (!valid) {             // it may be a parameter type instead, and if so, then we should return null,             // as this method is only for evaluating parameter values             Boolean isClass = BeanHelper.isAssignableToExpectedType(exchange.getContext().getClassResolver(), exp, parameterType).             // the method will return a non null value if exp is a class             if (isClass != null) {                 return null.             }         }         // use simple language to evaluate the expression, as it may use the simple language to refer to message body, headers etc.         Expression expression = null.         try {             expression = exchange.getContext().resolveLanguage("simple").createExpression(exp).             parameterValue = expression.evaluate(exchange, Object.class).             // use "null" to indicate the expression returned a null value which is a valid response we need to honor             if (parameterValue == null) {                 parameterValue = "null".             }         } catch (Exception e) {             throw new ExpressionEvaluationException(expression, "Cannot create/evaluate simple expression: " + exp + " to be bound to parameter at index: " + index + " on method: " + getMethod(), exchange, e).         }         // see method javadoc for details         if ("null".equals(parameterValue)) {             return Void.TYPE.         }         // the parameter value may match the expected type, then we use it as-is         if (parameterType.isAssignableFrom(parameterValue.getClass())) {             valid = true.         } else {             // the parameter value was not already valid, but since the simple language have evaluated the expression             // which may change the parameterValue, so we have to check it again to see if its now valid             exp = exchange.getContext().getTypeConverter().tryConvertTo(String.class, parameterValue).             // String values from the simple language is always valid             if (!valid) {                 // re validate if the parameter was not valid the first time (String values should be accepted)                 valid = parameterValue instanceof String || BeanHelper.isValidParameterValue(exp).             }         }         if (valid) {             // we need to unquote String parameters, as the enclosing quotes is there to denote a parameter value             if (parameterValue instanceof String) {                 parameterValue = StringHelper.removeLeadingAndEndingQuotes((String) parameterValue).             }             if (parameterValue != null) {                 try {                     // its a valid parameter value, so convert it to the expected type of the parameter                     answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, exchange, parameterValue).                     if (LOG.isTraceEnabled()) {                         LOG.trace("Parameter #{} evaluated as: {} type: ", index, answer, org.apache.camel.util.ObjectHelper.type(answer)).                     }                 } catch (Exception e) {                     if (LOG.isDebugEnabled()) {                         LOG.debug("Cannot convert from type: {} to type: {} for parameter #{}", org.apache.camel.util.ObjectHelper.type(parameterValue), parameterType, index).                     }                     throw new ParameterBindingException(e, method, index, parameterType, parameterValue).                 }             }         }     }     return answer. }
true;private;4;29;/**  * Evaluate using classic parameter binding using the pre compute expression  */ ;/**  * Evaluate using classic parameter binding using the pre compute expression  */ private Object evaluateParameterBinding(Exchange exchange, Expression expression, int index, Class<?> parameterType) {     Object answer = null.     // use object first to avoid type conversion so we know if there is a value or not     Object result = expression.evaluate(exchange, Object.class).     if (result != null) {         try {             if (parameterType.isInstance(result)) {                 // optimize if the value is already the same type                 answer = result.             } else {                 // we got a value now try to convert it to the expected type                 answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, result).             }             if (LOG.isTraceEnabled()) {                 LOG.trace("Parameter #{} evaluated as: {} type: ", index, answer, org.apache.camel.util.ObjectHelper.type(answer)).             }         } catch (NoTypeConversionAvailableException e) {             if (LOG.isDebugEnabled()) {                 LOG.debug("Cannot convert from type: {} to type: {} for parameter #{}", org.apache.camel.util.ObjectHelper.type(result), parameterType, index).             }             throw new ParameterBindingException(e, method, index, parameterType, result).         }     } else {         LOG.trace("Parameter #{} evaluated as null", index).     }     return answer. }
false;public;0;4;;@Override public String toString() {     return "ParametersExpression: " + Arrays.asList(expressions). }
