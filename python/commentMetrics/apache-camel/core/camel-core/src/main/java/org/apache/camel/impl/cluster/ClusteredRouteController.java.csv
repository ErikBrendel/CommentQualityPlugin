commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Add a filter used to to filter cluster aware routes.  */ ;// ******************************* // Properties. // ******************************* /**  * Add a filter used to to filter cluster aware routes.  */ public void addFilter(ClusteredRouteFilter filter) {     this.filters.add(filter). }
true;public;1;4;/**  * Sets the filters used to filter cluster aware routes.  */ ;/**  * Sets the filters used to filter cluster aware routes.  */ public void setFilters(Collection<ClusteredRouteFilter> filters) {     this.filters.clear().     this.filters.addAll(filters). }
false;public;0;3;;public Collection<ClusteredRouteFilter> getFilters() {     return Collections.unmodifiableList(filters). }
true;public;2;3;/**  * Add a configuration for the given route.  */ ;/**  * Add a configuration for the given route.  */ public void addRouteConfiguration(String routeId, ClusteredRouteConfiguration configuration) {     configurations.put(routeId, configuration). }
true;public;1;4;/**  * Sets the configurations for the routes.  */ ;/**  * Sets the configurations for the routes.  */ public void setRoutesConfiguration(Map<String, ClusteredRouteConfiguration> configurations) {     this.configurations.clear().     this.configurations.putAll(configurations). }
false;public;0;3;;public Map<String, ClusteredRouteConfiguration> getRoutesConfiguration() {     return Collections.unmodifiableMap(this.configurations). }
false;public;0;3;;public Duration getInitialDelay() {     return this.defaultConfiguration.getInitialDelay(). }
true;public;1;3;/**  * Set the amount of time the route controller should wait before to start  * the routes after the camel context is started.  *  * @param initialDelay the initial delay.  */ ;/**  * Set the amount of time the route controller should wait before to start  * the routes after the camel context is started.  *  * @param initialDelay the initial delay.  */ public void setInitialDelay(Duration initialDelay) {     this.defaultConfiguration.setInitialDelay(initialDelay). }
false;public;0;3;;public String getNamespace() {     return this.defaultConfiguration.getNamespace(). }
true;public;1;3;/**  * Set the default namespace.  */ ;/**  * Set the default namespace.  */ public void setNamespace(String namespace) {     this.defaultConfiguration.setNamespace(namespace). }
false;public;0;3;;public CamelClusterService getClusterService() {     return clusterService. }
true;public;1;5;/**  * Set the cluster service to use.  */ ;/**  * Set the cluster service to use.  */ public void setClusterService(CamelClusterService clusterService) {     ObjectHelper.notNull(clusterService, "CamelClusterService").     this.clusterService = clusterService. }
false;public;0;3;;public CamelClusterService.Selector getClusterServiceSelector() {     return clusterServiceSelector. }
true;public;1;5;/**  * Set the selector strategy to look-up a {@link CamelClusterService}  */ ;/**  * Set the selector strategy to look-up a {@link CamelClusterService}  */ public void setClusterServiceSelector(CamelClusterService.Selector clusterServiceSelector) {     ObjectHelper.notNull(clusterService, "CamelClusterService.Selector").     this.clusterServiceSelector = clusterServiceSelector. }
false;public;0;7;;// ******************************* //  // ******************************* @Override public Collection<Route> getControlledRoutes() {     return this.routes.stream().map(getCamelContext()::getRoute).filter(Objects::nonNull).collect(Collectors.toList()). }
false;public;0;23;;@Override public void doStart() throws Exception {     final CamelContext context = getCamelContext().     // Parameters validation     ObjectHelper.notNull(defaultConfiguration.getNamespace(), "Namespace").     ObjectHelper.notNull(defaultConfiguration.getInitialDelay(), "initialDelay").     ObjectHelper.notNull(context, "camelContext").     if (clusterService == null) {         // Finally try to grab it from the camel context.         clusterService = ClusterServiceHelper.mandatoryLookupService(context, clusterServiceSelector).     }     LOGGER.debug("Using ClusterService instance {} (id={}, type={})", clusterService, clusterService.getId(), clusterService.getClass().getName()).     if (!ServiceHelper.isStarted(clusterService)) {         // Start the cluster service if not yet started.         clusterService.start().     }     super.doStart(). }
false;public;0;7;;@Override public void doStop() throws Exception {     if (ServiceHelper.isStarted(clusterService)) {         // Stop the cluster service.         clusterService.stop().     } }
false;public;1;8;;@Override public void setCamelContext(CamelContext camelContext) {     if (!camelContext.getRoutePolicyFactories().contains(this.policyFactory)) {         camelContext.addRoutePolicyFactory(this.policyFactory).     }     super.setCamelContext(camelContext). }
false;public;1;7;;// ******************************* // Route operations are disabled // ******************************* @Override public void startRoute(String routeId) throws Exception {     failIfClustered(routeId).     // Delegate to default impl.     super.startRoute(routeId). }
false;public;1;7;;@Override public void stopRoute(String routeId) throws Exception {     failIfClustered(routeId).     // Delegate to default impl.     super.stopRoute(routeId). }
false;public;3;7;;@Override public void stopRoute(String routeId, long timeout, TimeUnit timeUnit) throws Exception {     failIfClustered(routeId).     // Delegate to default impl.     super.stopRoute(routeId, timeout, timeUnit). }
false;public;4;7;;@Override public boolean stopRoute(String routeId, long timeout, TimeUnit timeUnit, boolean abortAfterTimeout) throws Exception {     failIfClustered(routeId).     // Delegate to default impl.     return super.stopRoute(routeId, timeout, timeUnit, abortAfterTimeout). }
false;public;1;7;;@Override public void suspendRoute(String routeId) throws Exception {     failIfClustered(routeId).     // Delegate to default impl.     super.suspendRoute(routeId). }
false;public;3;7;;@Override public void suspendRoute(String routeId, long timeout, TimeUnit timeUnit) throws Exception {     failIfClustered(routeId).     // Delegate to default impl.     super.suspendRoute(routeId, timeout, timeUnit). }
false;public;1;7;;@Override public void resumeRoute(String routeId) throws Exception {     failIfClustered(routeId).     // Delegate to default impl.     super.resumeRoute(routeId). }
false;private;1;9;;// ******************************* // Helpers // ******************************* private void failIfClustered(String routeId) {     // are clustered and they may be part of the same view.     if (routes.contains(routeId)) {         throw new UnsupportedOperationException("Operation not supported as route " + routeId + " is clustered").     } }
false;public;3;37;;@Override public RoutePolicy createRoutePolicy(CamelContext camelContext, String routeId, NamedNode node) {     RouteDefinition route = (RouteDefinition) node.     // clustering set-up     if (filters.stream().allMatch(filter -> filter.test(camelContext, routeId, route))) {         if (ObjectHelper.isNotEmpty(route.getRoutePolicies())) {             // route policy, in that case exclude it.             if (route.getRoutePolicies().stream().anyMatch(ClusteredRoutePolicy.class::isInstance)) {                 LOGGER.debug("Route '{}' has a ClusteredRoutePolicy already set-up", routeId).                 return null.             }         }         try {             final ClusteredRouteConfiguration configuration = configurations.getOrDefault(routeId, defaultConfiguration).             final String namespace = ObjectHelper.supplyIfEmpty(configuration.getNamespace(), defaultConfiguration::getNamespace).             final Duration initialDelay = ObjectHelper.supplyIfEmpty(configuration.getInitialDelay(), defaultConfiguration::getInitialDelay).             ClusteredRoutePolicy policy = ClusteredRoutePolicy.forNamespace(clusterService, namespace).             policy.setCamelContext(getCamelContext()).             policy.setInitialDelay(initialDelay).             LOGGER.debug("Attaching route '{}' to namespace '{}'", routeId, namespace).             routes.add(routeId).             return policy.         } catch (Exception e) {             throw RuntimeCamelException.wrapRuntimeCamelException(e).         }     }     return null. }
