commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;7;;public static ProcessorReifier<? extends ProcessorDefinition<?>> reifier(ProcessorDefinition<?> definition) {     Function<ProcessorDefinition<?>, ProcessorReifier<? extends ProcessorDefinition<?>>> reifier = PROCESSORS.get(definition.getClass()).     if (reifier != null) {         return reifier.apply(definition).     }     throw new IllegalStateException("Unsupported definition: " + definition). }
true;public,abstract;1;1;/**  * Override this in definition class and implement logic to create the processor  * based on the definition model.  */ ;/**  * Override this in definition class and implement logic to create the processor  * based on the definition model.  */ public abstract Processor createProcessor(RouteContext routeContext) throws Exception.
true;protected;1;4;/**  * Prefer to use {#link #createChildProcessor}.  */ ;/**  * Prefer to use {#link #createChildProcessor}.  */ protected Processor createOutputsProcessor(RouteContext routeContext) throws Exception {     Collection<ProcessorDefinition<?>> outputs = definition.getOutputs().     return createOutputsProcessor(routeContext, outputs). }
true;protected;2;16;/**  * Creates the child processor (outputs) from the current definition  *  * @param routeContext   the route context  * @param mandatory      whether or not children is mandatory (ie the definition should have outputs)  * @return the created children, or <tt>null</tt> if definition had no output  * @throws Exception is thrown if error creating the child or if it was mandatory and there was no output defined on definition  */ ;/**  * Creates the child processor (outputs) from the current definition  *  * @param routeContext   the route context  * @param mandatory      whether or not children is mandatory (ie the definition should have outputs)  * @return the created children, or <tt>null</tt> if definition had no output  * @throws Exception is thrown if error creating the child or if it was mandatory and there was no output defined on definition  */ protected Processor createChildProcessor(RouteContext routeContext, boolean mandatory) throws Exception {     Processor children = null.     // at first use custom factory     if (routeContext.getCamelContext().getProcessorFactory() != null) {         children = routeContext.getCamelContext().getProcessorFactory().createChildProcessor(routeContext, definition, mandatory).     }     // fallback to default implementation if factory did not create the child     if (children == null) {         children = createOutputsProcessor(routeContext).     }     if (children == null && mandatory) {         throw new IllegalArgumentException("Definition has no children on " + definition).     }     return children. }
false;public;2;21;;public void addRoutes(RouteContext routeContext, Collection<Route> routes) throws Exception {     Channel processor = makeProcessor(routeContext).     if (processor == null) {         // no processor to add         return.     }     if (!routeContext.isRouteAdded()) {         // are we routing to an endpoint interceptor, if so we should not add it as an event driven         // processor as we use the producer to trigger the interceptor         boolean endpointInterceptor = processor.getNextProcessor() instanceof InterceptEndpointProcessor.         // only add regular processors as event driven         if (endpointInterceptor) {             log.debug("Endpoint interceptor should not be added as an event driven consumer route: {}", processor).         } else {             log.trace("Adding event driven processor: {}", processor).             routeContext.addEventDrivenProcessor(processor).         }     } }
true;public;2;7;/**  * Wraps the child processor in whatever necessary interceptors and error handlers  */ ;/**  * Wraps the child processor in whatever necessary interceptors and error handlers  */ public Channel wrapProcessor(RouteContext routeContext, Processor processor) throws Exception {     // dont double wrap     if (processor instanceof Channel) {         return (Channel) processor.     }     return wrapChannel(routeContext, processor, null). }
false;protected;3;3;;protected Channel wrapChannel(RouteContext routeContext, Processor processor, ProcessorDefinition<?> child) throws Exception {     return wrapChannel(routeContext, processor, child, definition.isInheritErrorHandler()). }
false;protected;4;58;;protected Channel wrapChannel(RouteContext routeContext, Processor processor, ProcessorDefinition<?> child, Boolean inheritErrorHandler) throws Exception {     // put a channel in between this and each output to control the route flow logic     ModelChannel channel = createChannel(routeContext).     channel.setNextProcessor(processor).     // add interceptor strategies to the channel must be in this order: camel context, route context, local     addInterceptStrategies(routeContext, channel, routeContext.getCamelContext().getInterceptStrategies()).     addInterceptStrategies(routeContext, channel, routeContext.getInterceptStrategies()).     addInterceptStrategies(routeContext, channel, definition.getInterceptStrategies()).     // set the child before init the channel     channel.setChildDefinition(child).     channel.initChannel(definition, routeContext).     // set the error handler, must be done after init as we can set the error handler as first in the chain     if (definition instanceof TryDefinition || definition instanceof CatchDefinition || definition instanceof FinallyDefinition) {         // do not use error handler for try .. catch .. finally blocks as it will handle errors itself         log.trace("{} is part of doTry .. doCatch .. doFinally so no error handler is applied", definition).     } else if (ProcessorDefinitionHelper.isParentOfType(TryDefinition.class, definition, true) || ProcessorDefinitionHelper.isParentOfType(CatchDefinition.class, definition, true) || ProcessorDefinitionHelper.isParentOfType(FinallyDefinition.class, definition, true)) {         // do not use error handler for try .. catch .. finally blocks as it will handle errors itself         // by checking that any of our parent(s) is not a try .. catch or finally type         log.trace("{} is part of doTry .. doCatch .. doFinally so no error handler is applied", definition).     } else if (definition instanceof OnExceptionDefinition || ProcessorDefinitionHelper.isParentOfType(OnExceptionDefinition.class, definition, true)) {         log.trace("{} is part of OnException so no error handler is applied", definition).     // do not use error handler for onExceptions blocks as it will handle errors itself     } else if (definition instanceof HystrixDefinition || ProcessorDefinitionHelper.isParentOfType(HystrixDefinition.class, definition, true)) {         // however if inherit error handler is enabled, we need to wrap an error handler on the hystrix parent         if (inheritErrorHandler != null && inheritErrorHandler && child == null) {             // only wrap the parent (not the children of the hystrix)             wrapChannelInErrorHandler(channel, routeContext, inheritErrorHandler).         } else {             log.trace("{} is part of HystrixCircuitBreaker so no error handler is applied", definition).         }     } else if (definition instanceof MulticastDefinition) {         // do not use error handler for multicast as it offers fine grained error handlers for its outputs         // however if share unit of work is enabled, we need to wrap an error handler on the multicast parent         MulticastDefinition def = (MulticastDefinition) definition.         boolean isShareUnitOfWork = def.getShareUnitOfWork() != null && def.getShareUnitOfWork().         if (isShareUnitOfWork && child == null) {             // only wrap the parent (not the children of the multicast)             wrapChannelInErrorHandler(channel, routeContext, inheritErrorHandler).         } else {             log.trace("{} is part of multicast which have special error handling so no error handler is applied", definition).         }     } else {         // use error handler by default or if configured to do so         wrapChannelInErrorHandler(channel, routeContext, inheritErrorHandler).     }     // do post init at the end     channel.postInitChannel(definition, routeContext).     log.trace("{} wrapped in Channel: {}", definition, channel).     return channel. }
true;private;3;11;/**  * Wraps the given channel in error handler (if error handler is inherited)  *  * @param channel             the channel  * @param routeContext        the route context  * @param inheritErrorHandler whether to inherit error handler  * @throws Exception can be thrown if failed to create error handler builder  */ ;/**  * Wraps the given channel in error handler (if error handler is inherited)  *  * @param channel             the channel  * @param routeContext        the route context  * @param inheritErrorHandler whether to inherit error handler  * @throws Exception can be thrown if failed to create error handler builder  */ private void wrapChannelInErrorHandler(Channel channel, RouteContext routeContext, Boolean inheritErrorHandler) throws Exception {     if (inheritErrorHandler == null || inheritErrorHandler) {         log.trace("{} is configured to inheritErrorHandler", definition).         Processor output = channel.getOutput().         Processor errorHandler = wrapInErrorHandler(routeContext, output).         // set error handler on channel         channel.setErrorHandler(errorHandler).     } else {         log.debug("{} is configured to not inheritErrorHandler.", definition).     } }
true;protected;2;12;/**  * Wraps the given output in an error handler  *  * @param routeContext the route context  * @param output the output  * @return the output wrapped with the error handler  * @throws Exception can be thrown if failed to create error handler builder  */ ;/**  * Wraps the given output in an error handler  *  * @param routeContext the route context  * @param output the output  * @return the output wrapped with the error handler  * @throws Exception can be thrown if failed to create error handler builder  */ protected Processor wrapInErrorHandler(RouteContext routeContext, Processor output) throws Exception {     ErrorHandlerFactory builder = ((RouteDefinition) routeContext.getRoute()).getErrorHandlerBuilder().     // create error handler     Processor errorHandler = builder.createErrorHandler(routeContext, output).     // invoke lifecycles so we can manage this error handler builder     for (LifecycleStrategy strategy : routeContext.getCamelContext().getLifecycleStrategies()) {         strategy.onErrorHandlerAdd(routeContext, errorHandler, builder).     }     return errorHandler. }
true;protected;3;11;/**  * Adds the given list of interceptors to the channel.  *  * @param routeContext  the route context  * @param channel       the channel to add strategies  * @param strategies    list of strategies to add.  */ ;/**  * Adds the given list of interceptors to the channel.  *  * @param routeContext  the route context  * @param channel       the channel to add strategies  * @param strategies    list of strategies to add.  */ protected void addInterceptStrategies(RouteContext routeContext, Channel channel, List<InterceptStrategy> strategies) {     for (InterceptStrategy strategy : strategies) {         if (!routeContext.isHandleFault() && strategy instanceof HandleFault) {             // handle fault is disabled so we should not add it             continue.         }         // add strategy         channel.addInterceptStrategy(strategy).     } }
true;protected;2;3;/**  * Creates a new instance of some kind of composite processor which defaults  * to using a {@link Pipeline} but derived classes could change the behaviour  */ ;/**  * Creates a new instance of some kind of composite processor which defaults  * to using a {@link Pipeline} but derived classes could change the behaviour  */ protected Processor createCompositeProcessor(RouteContext routeContext, List<Processor> list) throws Exception {     return Pipeline.newInstance(routeContext.getCamelContext(), list). }
true;protected;1;3;/**  * Creates a new instance of the {@link Channel}.  */ ;/**  * Creates a new instance of the {@link Channel}.  */ protected ModelChannel createChannel(RouteContext routeContext) throws Exception {     return new DefaultChannel(). }
false;protected;2;9;;protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorDefinition<?>> outputs) throws Exception {     // We will save list of actions to restore the outputs back to the original state.     Runnable propertyPlaceholdersChangeReverter = ProcessorDefinitionHelper.createPropertyPlaceholdersChangeReverter().     try {         return createOutputsProcessorImpl(routeContext, outputs).     } finally {         propertyPlaceholdersChangeReverter.run().     } }
false;protected;2;55;;protected Processor createOutputsProcessorImpl(RouteContext routeContext, Collection<ProcessorDefinition<?>> outputs) throws Exception {     List<Processor> list = new ArrayList<>().     for (ProcessorDefinition<?> output : outputs) {         // allow any custom logic before we create the processor         reifier(output).preCreateProcessor().         // resolve properties before we create the processor         ProcessorDefinitionHelper.resolvePropertyPlaceholders(routeContext.getCamelContext(), output).         // resolve constant fields (eg Exchange.FILE_NAME)         ProcessorDefinitionHelper.resolveKnownConstantFields(output).         // also resolve properties and constant fields on embedded expressions         ProcessorDefinition<?> me = (ProcessorDefinition<?>) output.         if (me instanceof ExpressionNode) {             ExpressionNode exp = (ExpressionNode) me.             ExpressionDefinition expressionDefinition = exp.getExpression().             if (expressionDefinition != null) {                 // resolve properties before we create the processor                 ProcessorDefinitionHelper.resolvePropertyPlaceholders(routeContext.getCamelContext(), expressionDefinition).                 // resolve constant fields (eg Exchange.FILE_NAME)                 ProcessorDefinitionHelper.resolveKnownConstantFields(expressionDefinition).             }         }         Processor processor = createProcessor(routeContext, output).         // inject id         if (processor instanceof IdAware) {             String id = output.idOrCreate(routeContext.getCamelContext().getNodeIdFactory()).             ((IdAware) processor).setId(id).         }         if (output instanceof Channel && processor == null) {             continue.         }         Processor channel = wrapChannel(routeContext, processor, output).         list.add(channel).     }     // if more than one output wrap than in a composite processor else just keep it as is     Processor processor = null.     if (!list.isEmpty()) {         if (list.size() == 1) {             processor = list.get(0).         } else {             processor = createCompositeProcessor(routeContext, list).         }     }     return processor. }
false;protected;2;12;;protected Processor createProcessor(RouteContext routeContext, ProcessorDefinition<?> output) throws Exception {     Processor processor = null.     // at first use custom factory     if (routeContext.getCamelContext().getProcessorFactory() != null) {         processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, output).     }     // fallback to default implementation if factory did not create the processor     if (processor == null) {         processor = reifier(output).createProcessor(routeContext).     }     return processor. }
true;protected;1;10;/**  * Creates the processor and wraps it in any necessary interceptors and error handlers  */ ;/**  * Creates the processor and wraps it in any necessary interceptors and error handlers  */ protected Channel makeProcessor(RouteContext routeContext) throws Exception {     // We will save list of actions to restore the definition back to the original state.     Runnable propertyPlaceholdersChangeReverter = ProcessorDefinitionHelper.createPropertyPlaceholdersChangeReverter().     try {         return makeProcessorImpl(routeContext).     } finally {         // Lets restore         propertyPlaceholdersChangeReverter.run().     } }
false;private;1;47;;private Channel makeProcessorImpl(RouteContext routeContext) throws Exception {     Processor processor = null.     // allow any custom logic before we create the processor     preCreateProcessor().     // resolve properties before we create the processor     ProcessorDefinitionHelper.resolvePropertyPlaceholders(routeContext.getCamelContext(), definition).     // resolve constant fields (eg Exchange.FILE_NAME)     ProcessorDefinitionHelper.resolveKnownConstantFields(definition).     // also resolve properties and constant fields on embedded expressions     ProcessorDefinition<?> me = (ProcessorDefinition<?>) definition.     if (me instanceof ExpressionNode) {         ExpressionNode exp = (ExpressionNode) me.         ExpressionDefinition expressionDefinition = exp.getExpression().         if (expressionDefinition != null) {             // resolve properties before we create the processor             ProcessorDefinitionHelper.resolvePropertyPlaceholders(routeContext.getCamelContext(), expressionDefinition).             // resolve constant fields (eg Exchange.FILE_NAME)             ProcessorDefinitionHelper.resolveKnownConstantFields(expressionDefinition).         }     }     // at first use custom factory     if (routeContext.getCamelContext().getProcessorFactory() != null) {         processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, definition).     }     // fallback to default implementation if factory did not create the processor     if (processor == null) {         processor = createProcessor(routeContext).     }     // inject id     if (processor instanceof IdAware) {         String id = definition.idOrCreate(routeContext.getCamelContext().getNodeIdFactory()).         ((IdAware) processor).setId(id).     }     if (processor == null) {         // no processor to make         return null.     }     return wrapProcessor(routeContext, processor). }
true;protected;0;3;/**  * Strategy to execute any custom logic before the {@link Processor} is created.  */ ;/**  * Strategy to execute any custom logic before the {@link Processor} is created.  */ protected void preCreateProcessor() {     definition.preCreateProcessor(). }
true;public;1;3;/**  * Strategy for children to do any custom configuration  *  * @param output the child to be added as output to this  */ ;/**  * Strategy for children to do any custom configuration  *  * @param output the child to be added as output to this  */ public void configureChild(ProcessorDefinition<?> output) { // noop }
