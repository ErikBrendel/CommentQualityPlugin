commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;public String toString() {     String catchText = catchClauses == null || catchClauses.isEmpty() ? "" : " Catches {" + catchClauses + "}".     String finallyText = (finallyProcessor == null) ? "" : " Finally {" + finallyProcessor + "}".     return "Try {" + tryProcessor + "}" + catchText + finallyText. }
false;public;0;3;;public String getTraceLabel() {     return "doTry". }
false;public;2;5;;public boolean process(Exchange exchange, AsyncCallback callback) {     ReactiveHelper.schedule(new TryState(exchange, callback)).     return false. }
false;public;0;19;;@Override public void run() {     if (continueRouting(processors, exchange)) {         exchange.setProperty(Exchange.TRY_ROUTE_BLOCK, true).         ExchangeHelper.prepareOutToIn(exchange).         // process the next processor         Processor processor = processors.next().         AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor).         log.trace("Processing exchangeId: {} >>> {}", exchange.getExchangeId(), exchange).         async.process(exchange, doneSync -> ReactiveHelper.schedule(this)).     } else {         ExchangeHelper.prepareOutToIn(exchange).         exchange.removeProperty(Exchange.TRY_ROUTE_BLOCK).         exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled).         log.trace("Processing complete for exchangeId: {} >>> {}", exchange.getExchangeId(), exchange).         callback.done(false).     } }
false;public;0;3;;public String toString() {     return "TryState[" + exchange.getExchangeId() + "]". }
false;protected;2;13;;protected boolean continueRouting(Iterator<Processor> it, Exchange exchange) {     Object stop = exchange.getProperty(Exchange.ROUTE_STOP).     if (stop != null) {         boolean doStop = exchange.getContext().getTypeConverter().convertTo(Boolean.class, stop).         if (doStop) {             log.debug("Exchange is marked to stop routing: {}", exchange).             return false.         }     }     // continue if there are more processors to route     return it.hasNext(). }
false;protected;0;3;;protected void doStart() throws Exception {     ServiceHelper.startService(tryProcessor, catchClauses, finallyProcessor). }
false;protected;0;3;;protected void doStop() throws Exception {     ServiceHelper.stopService(tryProcessor, catchClauses, finallyProcessor). }
false;public;0;16;;public List<Processor> next() {     if (!hasNext()) {         return null.     }     List<Processor> answer = new ArrayList<>().     if (tryProcessor != null) {         answer.add(tryProcessor).     }     if (catchClauses != null) {         answer.addAll(catchClauses).     }     if (finallyProcessor != null) {         answer.add(finallyProcessor).     }     return answer. }
false;public;0;3;;public boolean hasNext() {     return tryProcessor != null || catchClauses != null && !catchClauses.isEmpty() || finallyProcessor != null. }
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setId(String id) {     this.id = id. }
