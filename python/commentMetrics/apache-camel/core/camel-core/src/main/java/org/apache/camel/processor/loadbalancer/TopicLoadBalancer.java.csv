commented;modifiers;parameterAmount;loc;comment;code
false;public;2;5;;public boolean process(final Exchange exchange, final AsyncCallback callback) {     AsyncProcessor[] processors = doGetProcessors().     ReactiveHelper.schedule(new State(exchange, callback, processors)::run).     return false. }
false;public;0;9;;public void run() {     if (index < processors.length) {         AsyncProcessor processor = processors[index++].         Exchange copy = copyExchangeStrategy(processor, exchange).         processor.process(copy, doneSync -> done(copy)).     } else {         callback.done(false).     } }
false;public;1;8;;public void done(Exchange current) {     if (current.getException() != null) {         exchange.setException(current.getException()).         callback.done(false).     } else {         ReactiveHelper.schedule(this::run).     } }
true;protected;2;3;/**  * Strategy method to copy the exchange before sending to another endpoint.  * Derived classes such as the {@link org.apache.camel.processor.Pipeline Pipeline}  * will not clone the exchange  *  * @param processor the processor that will send the exchange  * @param exchange  the exchange  * @return the current exchange if no copying is required such as for a  *         pipeline otherwise a new copy of the exchange is returned.  */ ;/**  * Strategy method to copy the exchange before sending to another endpoint.  * Derived classes such as the {@link org.apache.camel.processor.Pipeline Pipeline}  * will not clone the exchange  *  * @param processor the processor that will send the exchange  * @param exchange  the exchange  * @return the current exchange if no copying is required such as for a  *         pipeline otherwise a new copy of the exchange is returned.  */ protected Exchange copyExchangeStrategy(Processor processor, Exchange exchange) {     return exchange.copy(). }
