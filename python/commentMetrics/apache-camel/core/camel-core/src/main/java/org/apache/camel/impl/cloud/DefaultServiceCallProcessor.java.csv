commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;// ************************************* // Properties // ************************************* public ExchangePattern getExchangePattern() {     return exchangePattern. }
false;public;0;3;;public String getName() {     return name. }
false;public;0;3;;public String getScheme() {     return scheme. }
false;public;0;3;;public String getUri() {     return uri. }
false;public;0;3;;public String getContextPath() {     return contextPath. }
false;public;0;3;;public ServiceLoadBalancer getLoadBalancer() {     return loadBalancer. }
false;public;0;3;;public Expression getExpression() {     return expression. }
false;protected;0;17;;// ************************************* // Lifecycle // ************************************* @Override protected void doStart() throws Exception {     StringHelper.notEmpty(name, "name", "service name").     ObjectHelper.notNull(camelContext, "camel context").     ObjectHelper.notNull(expression, "expression").     ObjectHelper.notNull(loadBalancer, "load balancer").     processor = new SendDynamicProcessor(uri, expression).     processor.setCamelContext(camelContext).     if (exchangePattern != null) {         processor.setPattern(exchangePattern).     }     // Start services if needed     ServiceHelper.startService(processor).     ServiceHelper.startService(loadBalancer). }
false;protected;0;6;;@Override protected void doStop() throws Exception {     // Stop services if needed     ServiceHelper.stopService(loadBalancer).     ServiceHelper.stopService(processor). }
false;public;2;22;;// ************************************* // Processor // ************************************* @Override public boolean process(final Exchange exchange, final AsyncCallback callback) {     final Message message = exchange.getIn().     // the values can be dynamic using simple language so compute those     final String serviceName = applySimpleLanguage(name, exchange).     final String serviceUri = applySimpleLanguage(uri, exchange).     final String servicePath = applySimpleLanguage(contextPath, exchange).     final String serviceScheme = applySimpleLanguage(scheme, exchange).     message.setHeader(ServiceCallConstants.SERVICE_CALL_URI, serviceUri).     message.setHeader(ServiceCallConstants.SERVICE_CALL_CONTEXT_PATH, servicePath).     message.setHeader(ServiceCallConstants.SERVICE_CALL_SCHEME, serviceScheme).     message.setHeader(ServiceCallConstants.SERVICE_NAME, serviceName).     try {         return loadBalancer.process(serviceName, server -> execute(server, exchange, callback)).     } catch (Exception e) {         exchange.setException(e).         return true.     } }
false;private;3;29;;private boolean execute(ServiceDefinition service, Exchange exchange, AsyncCallback callback) throws Exception {     final Message message = exchange.getIn().     final String host = service.getHost().     final int port = service.getPort().     final Map<String, String> meta = service.getMetadata().     log.debug("Service {} active at server: {}:{}", name, host, port).     // set selected server as header     message.setHeader(ServiceCallConstants.SERVICE_HOST, host).     message.setHeader(ServiceCallConstants.SERVICE_PORT, port > 0 ? port : null).     message.setHeader(ServiceCallConstants.SERVICE_NAME, service.getName()).     message.setHeader(ServiceCallConstants.SERVICE_META, meta).     // If context path is not set on service call definition, reuse the one from     // ServiceDefinition, if any     message.getHeaders().compute(ServiceCallConstants.SERVICE_CALL_CONTEXT_PATH, (k, v) -> v == null ? meta.get(ServiceDefinition.SERVICE_META_PATH) : v).     // If port is not set on service call definition, reuse the one from     // ServiceDefinition, if any     message.getHeaders().compute(ServiceCallConstants.SERVICE_PORT, (k, v) -> v == null ? meta.get(ServiceDefinition.SERVICE_META_PORT) : v).     // use the dynamic send processor to call the service     return processor.process(exchange, callback). }
true;private;2;5;/**  * This function applies the simple language to the given expression.  *  * @param expression the expression  * @param exchange the exchange  * @return the computed expression  */ ;/**  * This function applies the simple language to the given expression.  *  * @param expression the expression  * @param exchange the exchange  * @return the computed expression  */ private String applySimpleLanguage(String expression, Exchange exchange) {     return SimpleLanguage.hasSimpleFunction(expression) ? SimpleLanguage.simple(expression).evaluate(exchange, String.class) : expression. }
