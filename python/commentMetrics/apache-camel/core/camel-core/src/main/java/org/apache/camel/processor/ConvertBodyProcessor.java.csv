commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "convertBodyTo[" + type.getCanonicalName() + "]". }
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setId(String id) {     this.id = id. }
false;public;1;50;;public void process(Exchange exchange) throws Exception {     boolean out = exchange.hasOut().     Message old = out ? exchange.getOut() : exchange.getIn().     if (old.getBody() == null) {         // only convert if there is a body         return.     }     if (exchange.getException() != null) {         // exception then it will override the existing exception         return.     }     String originalCharsetName = null.     if (charset != null) {         originalCharsetName = exchange.getProperty(Exchange.CHARSET_NAME, String.class).         // override existing charset with configured charset as that is what the user         // have explicit configured and expects to be used         exchange.setProperty(Exchange.CHARSET_NAME, charset).     }     // use mandatory conversion     Object value = old.getMandatoryBody(type).     // create a new message container so we do not drag specialized message objects along     // but that is only needed if the old message is a specialized message     boolean copyNeeded = !(old.getClass().equals(DefaultMessage.class)).     if (copyNeeded) {         Message msg = new DefaultMessage(exchange.getContext()).         msg.copyFromWithNewBody(old, value).         // replace message on exchange         ExchangeHelper.replaceMessage(exchange, msg, false).     } else {         // no copy needed so set replace value directly         old.setBody(value).     }     // as that can lead to double converting later on     if (charset != null) {         if (originalCharsetName != null && !originalCharsetName.isEmpty()) {             exchange.setProperty(Exchange.CHARSET_NAME, originalCharsetName).         } else {             exchange.removeProperty(Exchange.CHARSET_NAME).         }     } }
false;public;1;6;;@Override public CompletableFuture<Exchange> processAsync(Exchange exchange) {     AsyncCallbackToCompletableFutureAdapter<Exchange> callback = new AsyncCallbackToCompletableFutureAdapter<>(exchange).     process(exchange, callback).     return callback.getFuture(). }
false;public;2;10;;@Override public boolean process(Exchange exchange, AsyncCallback callback) {     try {         process(exchange).     } catch (Exception e) {         exchange.setException(e).     }     callback.done(true).     return true. }
false;public;0;3;;public Class<?> getType() {     return type. }
false;public;0;3;;public String getCharset() {     return charset. }
false;protected;0;4;;@Override protected void doStart() throws Exception { // noop }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
