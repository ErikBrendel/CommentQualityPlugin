commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public void start() {     timer = new Timer(ThreadHelper.resolveThreadName("Camel Thread ${counter} - ${name}", "Stream Resequencer Timer"), true). }
true;public;0;3;/**  * Stops this resequencer (i.e. this resequencer's {@link Timer} instance).  */ ;/**  * Stops this resequencer (i.e. this resequencer's {@link Timer} instance).  */ public void stop() {     timer.cancel(). }
true;public,synchronized;0;3;/**  * Returns the number of elements currently maintained by this resequencer.  *  * @return the number of elements currently maintained by this resequencer.  */ ;/**  * Returns the number of elements currently maintained by this resequencer.  *  * @return the number of elements currently maintained by this resequencer.  */ public synchronized int size() {     return sequence.size(). }
true;public;0;3;/**  * Returns this resequencer's timeout value.  *  * @return the timeout in milliseconds.  */ ;/**  * Returns this resequencer's timeout value.  *  * @return the timeout in milliseconds.  */ public long getTimeout() {     return timeout. }
true;public;1;3;/**  * Sets this sequencer's timeout value.  *  * @param timeout the timeout in milliseconds.  */ ;/**  * Sets this sequencer's timeout value.  *  * @param timeout the timeout in milliseconds.  */ public void setTimeout(long timeout) {     this.timeout = timeout. }
false;public;0;3;;public Boolean getRejectOld() {     return rejectOld. }
false;public;1;3;;public void setRejectOld(Boolean rejectOld) {     this.rejectOld = rejectOld. }
true;public;0;3;/**  * Returns the sequence sender.  *  * @return the sequence sender.  */ ;/**  * Returns the sequence sender.  *  * @return the sequence sender.  */ public SequenceSender<E> getSequenceSender() {     return sequenceSender. }
true;public;1;3;/**  * Sets the sequence sender.  *  * @param sequenceSender a sequence element sender.  */ ;/**  * Sets the sequence sender.  *  * @param sequenceSender a sequence element sender.  */ public void setSequenceSender(SequenceSender<E> sequenceSender) {     this.sequenceSender = sequenceSender. }
true;;0;6;/**  * Returns the last delivered element.  *  * @return the last delivered element or <code>null</code> if no delivery  *         has been made yet.  */ ;/**  * Returns the last delivered element.  *  * @return the last delivered element or <code>null</code> if no delivery  *         has been made yet.  */ E getLastDelivered() {     if (lastDelivered == null) {         return null.     }     return lastDelivered.getObject(). }
true;;1;3;/**  * Sets the last delivered element. This is for testing purposes only.  *  * @param o an element.  */ ;/**  * Sets the last delivered element. This is for testing purposes only.  *  * @param o an element.  */ void setLastDelivered(E o) {     lastDelivered = new Element<>(o). }
true;public,synchronized;1;35;/**  * Inserts the given element into this resequencer. If the element is not  * ready for immediate delivery and has no immediate presecessor then it is  * scheduled for timing out. After being timed out it is ready for delivery.  *  * @param o an element.  * @throws IllegalArgumentException if the element cannot be used with this resequencer engine  */ ;/**  * Inserts the given element into this resequencer. If the element is not  * ready for immediate delivery and has no immediate presecessor then it is  * scheduled for timing out. After being timed out it is ready for delivery.  *  * @param o an element.  * @throws IllegalArgumentException if the element cannot be used with this resequencer engine  */ public synchronized void insert(E o) {     // wrap object into internal element     Element<E> element = new Element<>(o).     // validate the exchange has no problem     if (!sequence.comparator().isValid(element)) {         throw new IllegalArgumentException("Element cannot be used in comparator: " + sequence.comparator()).     }     // validate the exchange shouldn't be 'rejected' (if applicable)     if (rejectOld != null && rejectOld.booleanValue() && beforeLastDelivered(element)) {         throw new MessageRejectedException("rejecting message [" + element.getObject() + "], it should have been sent before the last delivered message [" + lastDelivered.getObject() + "]").     }     // add element to sequence in proper order     sequence.add(element).     Element<E> successor = sequence.successor(element).     // timer task (no need to wait any more for timeout)     if (successor != null) {         successor.cancel().     }     // start delivery if current element is successor of last delivered element     if (successorOfLastDelivered(element)) {     // nothing to schedule     } else if (sequence.predecessor(element) != null) {     // nothing to schedule     } else {         element.schedule(defineTimeout()).     } }
true;public,synchronized;0;5;/**  * Delivers all elements which are currently ready to deliver.  *  * @throws Exception thrown by {@link SequenceSender#sendElement(Object)}.  *  * @see ResequencerEngine#deliverNext()  */ ;/**  * Delivers all elements which are currently ready to deliver.  *  * @throws Exception thrown by {@link SequenceSender#sendElement(Object)}.  *  * @see ResequencerEngine#deliverNext()  */ public synchronized void deliver() throws Exception {     while (deliverNext()) {     // do nothing here     } }
true;public;0;24;/**  * Attempts to deliver a single element from the head of the resequencer  * queue (sequence). Only elements which have not been scheduled for timing  * out or which already timed out can be delivered. Elements are delivered via  * {@link SequenceSender#sendElement(Object)}.  *  * @return <code>true</code> if the element has been delivered  *         <code>false</code> otherwise.  *  * @throws Exception thrown by {@link SequenceSender#sendElement(Object)}.  */ ;/**  * Attempts to deliver a single element from the head of the resequencer  * queue (sequence). Only elements which have not been scheduled for timing  * out or which already timed out can be delivered. Elements are delivered via  * {@link SequenceSender#sendElement(Object)}.  *  * @return <code>true</code> if the element has been delivered  *         <code>false</code> otherwise.  *  * @throws Exception thrown by {@link SequenceSender#sendElement(Object)}.  */ public boolean deliverNext() throws Exception {     if (sequence.size() == 0) {         return false.     }     // inspect element with lowest sequence value     Element<E> element = sequence.first().     // if element is scheduled do not deliver and return     if (element.scheduled()) {         return false.     }     // remove deliverable element from sequence     sequence.remove(element).     // set the delivered element to last delivered element     lastDelivered = element.     // deliver the sequence element     sequenceSender.sendElement(element.getObject()).     // element has been delivered     return true. }
true;private;1;9;/**  * Returns <code>true</code> if the given element is the immediate  * successor of the last delivered element.  *  * @param element an element.  * @return <code>true</code> if the given element is the immediate  *         successor of the last delivered element.  */ ;/**  * Returns <code>true</code> if the given element is the immediate  * successor of the last delivered element.  *  * @param element an element.  * @return <code>true</code> if the given element is the immediate  *         successor of the last delivered element.  */ private boolean successorOfLastDelivered(Element<E> element) {     if (lastDelivered == null) {         return false.     }     if (sequence.comparator().successor(element, lastDelivered)) {         return true.     }     return false. }
true;private;1;9;/**  * Retuns <code>true</code> if the given element is before the last delivered element.  *  * @param element an element.  * @return <code>true</code> if the given element is before the last delivered element.  */ ;/**  * Retuns <code>true</code> if the given element is before the last delivered element.  *  * @param element an element.  * @return <code>true</code> if the given element is before the last delivered element.  */ private boolean beforeLastDelivered(Element<E> element) {     if (lastDelivered == null) {         return false.     }     if (sequence.comparator().compare(element, lastDelivered) < 0) {         return true.     }     return false. }
true;private;0;3;/**  * Creates a timeout task based on the timeout setting of this resequencer.  *  * @return a new timeout task.  */ ;/**  * Creates a timeout task based on the timeout setting of this resequencer.  *  * @return a new timeout task.  */ private Timeout defineTimeout() {     return new Timeout(timer, timeout). }
false;private,static;1;3;;private static <E> Sequence<Element<E>> createSequence(SequenceElementComparator<E> comparator) {     return new Sequence<>(new ElementComparator<>(comparator)). }
