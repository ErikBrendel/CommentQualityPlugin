commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public CamelContext getCamelContext() {     return camelContext. }
false;public;1;21;;@Override public void setCamelContext(CamelContext camelContext) {     if (this.camelContext == camelContext) {         return.     }     if (this.camelContext != null && this.camelContext != camelContext) {         throw new IllegalStateException("CamelContext should not be changed: current=" + this.camelContext + ", new=" + camelContext).     }     try {         this.camelContext = camelContext.         this.camelContext.addStartupListener(this.listener).         this.camelContext.getManagementStrategy().addEventNotifier(this.listener).         this.executorService = camelContext.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "ClusteredRoutePolicy").     } catch (Exception e) {         throw new RuntimeException(e).     } }
false;public;0;3;;public Duration getInitialDelay() {     return initialDelay. }
false;public;1;3;;public void setInitialDelay(Duration initialDelay) {     this.initialDelay = initialDelay. }
false;private;1;3;;// **************************************************** // life-cycle // **************************************************** private RouteDefinition definition(Route route) {     return (RouteDefinition) route.getRouteContext().getRoute(). }
false;public;1;12;;@Override public void onInit(Route route) {     super.onInit(route).     log.info("Route managed by {}. Setting route {} AutoStartup flag to false.", getClass(), route.getId()).     definition(route).setAutoStartup("false").     this.refCount.retain().     this.stoppedRoutes.add(route).     startManagedRoutes(). }
false;public;0;17;;@Override public void doStart() throws Exception {     if (clusterService == null) {         clusterService = ClusterServiceHelper.lookupService(camelContext, clusterServiceSelector).orElseThrow(() -> new IllegalStateException("CamelCluster service not found")).     }     log.debug("ClusteredRoutePolicy {} is using ClusterService instance {} (id={}, type={})", this, clusterService, clusterService.getId(), clusterService.getClass().getName()).     clusterView = clusterService.getView(namespace). }
false;public;0;4;;@Override public void doShutdown() throws Exception {     this.refCount.release(). }
false;public;0;4;;// **************************************************** // Management // **************************************************** @ManagedAttribute(description = "Is this route the master or a slave") public boolean isLeader() {     return leader.get(). }
false;private,synchronized;1;9;;// **************************************************** // Route managements // **************************************************** private synchronized void setLeader(boolean isLeader) {     if (isLeader && leader.compareAndSet(false, isLeader)) {         log.debug("Leadership taken").         startManagedRoutes().     } else if (!isLeader && leader.getAndSet(isLeader)) {         log.debug("Leadership lost").         stopManagedRoutes().     } }
false;private;0;9;;private void startManagedRoutes() {     if (isLeader()) {         doStartManagedRoutes().     } else {         // If the leadership has been lost in the meanwhile, stop any         // eventually started route         doStopManagedRoutes().     } }
false;private;0;21;;private void doStartManagedRoutes() {     if (!isRunAllowed()) {         return.     }     try {         for (Route route : stoppedRoutes) {             ServiceStatus status = definition(route).getStatus(getCamelContext()).             if (status.isStartable()) {                 log.debug("Starting route '{}'", route.getId()).                 camelContext.getRouteController().startRoute(route.getId()).                 startedRoutes.add(route).             }         }         stoppedRoutes.removeAll(startedRoutes).     } catch (Exception e) {         handleException(e).     } }
false;private;0;9;;private void stopManagedRoutes() {     if (isLeader()) {         // If became a leader in the meanwhile, start any eventually stopped         // route         doStartManagedRoutes().     } else {         doStopManagedRoutes().     } }
false;private;0;21;;private void doStopManagedRoutes() {     if (!isRunAllowed()) {         return.     }     try {         for (Route route : startedRoutes) {             ServiceStatus status = definition(route).getStatus(getCamelContext()).             if (status.isStoppable()) {                 log.debug("Stopping route '{}'", route.getId()).                 stopRoute(route).                 stoppedRoutes.add(route).             }         }         startedRoutes.removeAll(stoppedRoutes).     } catch (Exception e) {         handleException(e).     } }
false;private;0;8;;private void onCamelContextStarted() {     log.debug("Apply cluster policy (stopped-routes='{}', started-routes='{}')", stoppedRoutes.stream().map(Route::getId).collect(Collectors.joining(",")), startedRoutes.stream().map(Route::getId).collect(Collectors.joining(","))).     clusterView.addEventListener(leadershipEventListener). }
false;public;2;4;;@Override public void leadershipChanged(CamelClusterView view, Optional<CamelClusterMember> leader) {     setLeader(clusterView.getLocalMember().isLeader()). }
false;public;1;4;;@Override public void notify(CamelEvent event) throws Exception {     onCamelContextStarted(). }
false;public;1;4;;@Override public boolean isEnabled(CamelEvent event) {     return event instanceof CamelContextStartedEvent. }
false;public;2;16;;@Override public void onCamelContextStarted(CamelContext context, boolean alreadyStarted) throws Exception {     if (alreadyStarted) {         // Invoke it only if the context was already started as this         // method is not invoked at last event as documented but after         // routes warm-up so this is useful for routes deployed after         // the camel context has been started-up. For standard routes         // configuration the notification of the camel context started         // is provided by EventNotifier.         //          // We should check why this callback is not invoked at latest         // stage, or maybe rename it as it is misleading and provide a         // better alternative for intercept camel events.         onCamelContextStarted().     } }
false;private;0;15;;private void onCamelContextStarted() {     // startup     if (contextStarted.compareAndSet(false, true)) {         // Eventually delay the startup of the routes a later time         if (initialDelay.toMillis() > 0) {             log.debug("Policy will be effective in {}", initialDelay).             executorService.schedule(ClusteredRoutePolicy.this::onCamelContextStarted, initialDelay.toMillis(), TimeUnit.MILLISECONDS).         } else {             ClusteredRoutePolicy.this.onCamelContextStarted().         }     } }
false;public,static;3;6;;// **************************************************** // Static helpers // **************************************************** public static ClusteredRoutePolicy forNamespace(CamelContext camelContext, CamelClusterService.Selector selector, String namespace) throws Exception {     ClusteredRoutePolicy policy = new ClusteredRoutePolicy(null, selector, namespace).     policy.setCamelContext(camelContext).     return policy. }
false;public,static;2;3;;public static ClusteredRoutePolicy forNamespace(CamelContext camelContext, String namespace) throws Exception {     return forNamespace(camelContext, ClusterServiceSelectors.DEFAULT_SELECTOR, namespace). }
false;public,static;2;3;;public static ClusteredRoutePolicy forNamespace(CamelClusterService service, String namespace) throws Exception {     return new ClusteredRoutePolicy(service, ClusterServiceSelectors.DEFAULT_SELECTOR, namespace). }
false;public,static;2;3;;public static ClusteredRoutePolicy forNamespace(CamelClusterService.Selector selector, String namespace) throws Exception {     return new ClusteredRoutePolicy(null, selector, namespace). }
false;public,static;1;3;;public static ClusteredRoutePolicy forNamespace(String namespace) throws Exception {     return forNamespace(ClusterServiceSelectors.DEFAULT_SELECTOR, namespace). }
