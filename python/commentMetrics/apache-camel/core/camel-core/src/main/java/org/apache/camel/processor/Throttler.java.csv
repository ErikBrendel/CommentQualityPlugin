commented;modifiers;parameterAmount;loc;comment;code
false;public;2;91;;@Override public boolean process(final Exchange exchange, final AsyncCallback callback) {     long queuedStart = 0.     if (log.isTraceEnabled()) {         queuedStart = exchange.getProperty(PROPERTY_EXCHANGE_QUEUED_TIMESTAMP, 0L, Long.class).         exchange.removeProperty(PROPERTY_EXCHANGE_QUEUED_TIMESTAMP).     }     State state = exchange.getProperty(PROPERTY_EXCHANGE_STATE, State.SYNC, State.class).     exchange.removeProperty(PROPERTY_EXCHANGE_STATE).     boolean doneSync = state == State.SYNC || state == State.ASYNC_REJECTED.     try {         if (!isRunAllowed()) {             throw new RejectedExecutionException("Run is not allowed").         }         String key = DEFAULT_KEY.         if (correlationExpression != null) {             key = correlationExpression.evaluate(exchange, String.class).         }         ThrottlingState throttlingState = states.computeIfAbsent(key, ThrottlingState::new).         throttlingState.calculateAndSetMaxRequestsPerPeriod(exchange).         ThrottlePermit permit = throttlingState.poll().         if (permit == null) {             if (isRejectExecution()) {                 throw new ThrottlerRejectedExecutionException("Exceeded the max throttle rate of " + throttlingState.getThrottleRate() + " within " + timePeriodMillis + "ms").             } else {                 // delegate to async pool                 if (isAsyncDelayed() && !exchange.isTransacted() && state == State.SYNC) {                     log.debug("Throttle rate exceeded but AsyncDelayed enabled, so queueing for async processing, exchangeId: {}", exchange.getExchangeId()).                     return processAsynchronously(exchange, callback, throttlingState).                 }                 // block waiting for a permit                 long start = 0.                 long elapsed = 0.                 if (log.isTraceEnabled()) {                     start = System.currentTimeMillis().                 }                 permit = throttlingState.take().                 if (log.isTraceEnabled()) {                     elapsed = System.currentTimeMillis() - start.                 }                 throttlingState.enqueue(permit, exchange).                 if (state == State.ASYNC) {                     if (log.isTraceEnabled()) {                         long queuedTime = start - queuedStart.                         log.trace("Queued for {}ms, Throttled for {}ms, exchangeId: {}", queuedTime, elapsed, exchange.getExchangeId()).                     }                 } else {                     log.trace("Throttled for {}ms, exchangeId: {}", elapsed, exchange.getExchangeId()).                 }             }         } else {             throttlingState.enqueue(permit, exchange).             if (state == State.ASYNC) {                 if (log.isTraceEnabled()) {                     long queuedTime = System.currentTimeMillis() - queuedStart.                     log.trace("Queued for {}ms, No throttling applied (throttle cleared while queued), for exchangeId: {}", queuedTime, exchange.getExchangeId()).                 }             } else {                 log.trace("No throttling applied to exchangeId: {}", exchange.getExchangeId()).             }         }         callback.done(doneSync).         return doneSync.     } catch (final InterruptedException e) {         // determine if we can still run, or the camel context is forcing a shutdown         boolean forceShutdown = exchange.getContext().getShutdownStrategy().forceShutdown(this).         if (forceShutdown) {             String msg = "Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: " + exchange.             log.debug(msg).             exchange.setException(new RejectedExecutionException(msg, e)).         } else {             exchange.setException(e).         }         callback.done(doneSync).         return doneSync.     } catch (final Throwable t) {         exchange.setException(t).         callback.done(doneSync).         return doneSync.     } }
true;protected;3;18;/**  * Delegate blocking on the DelayQueue to an asyncExecutor. Except if the executor rejects the submission  * and isCallerRunsWhenRejected() is enabled, then this method will delegate back to process(), but not  * before changing the exchange state to stop any recursion.  */ ;/**  * Delegate blocking on the DelayQueue to an asyncExecutor. Except if the executor rejects the submission  * and isCallerRunsWhenRejected() is enabled, then this method will delegate back to process(), but not  * before changing the exchange state to stop any recursion.  */ protected boolean processAsynchronously(final Exchange exchange, final AsyncCallback callback, ThrottlingState throttlingState) {     try {         if (log.isTraceEnabled()) {             exchange.setProperty(PROPERTY_EXCHANGE_QUEUED_TIMESTAMP, System.currentTimeMillis()).         }         exchange.setProperty(PROPERTY_EXCHANGE_STATE, State.ASYNC).         long delay = throttlingState.peek().getDelay(TimeUnit.NANOSECONDS).         asyncExecutor.schedule(() -> process(exchange, callback), delay, TimeUnit.NANOSECONDS).         return false.     } catch (final RejectedExecutionException e) {         if (isCallerRunsWhenRejected()) {             log.debug("AsyncExecutor is full, rejected exchange will run in the current thread, exchangeId: {}", exchange.getExchangeId()).             exchange.setProperty(PROPERTY_EXCHANGE_STATE, State.ASYNC_REJECTED).             return process(exchange, callback).         }         throw e.     } }
false;protected;0;6;;@Override protected void doStart() throws Exception {     if (isAsyncDelayed()) {         ObjectHelper.notNull(asyncExecutor, "executorService", this).     } }
false;protected;0;3;;@Override protected void doStop() throws Exception { }
false;protected;0;8;;@Override protected void doShutdown() throws Exception {     if (shutdownAsyncExecutor && asyncExecutor != null) {         camelContext.getExecutorServiceManager().shutdownNow(asyncExecutor).     }     states.clear().     super.doShutdown(). }
false;public;0;3;;public String getKey() {     return key. }
false;public;0;3;;public int getThrottleRate() {     return throttleRate. }
false;public;0;3;;public ThrottlePermit poll() {     return delayQueue.poll(). }
false;public;0;3;;public ThrottlePermit peek() {     return delayQueue.peek(). }
false;public;0;3;;public ThrottlePermit take() throws InterruptedException {     return delayQueue.take(). }
false;public;0;3;;public void clean() {     states.remove(key). }
true;public;2;17;/**  * Returns a permit to the DelayQueue, first resetting it's delay to be relative to now.  */ ;/**  * Returns a permit to the DelayQueue, first resetting it's delay to be relative to now.  */ public void enqueue(final ThrottlePermit permit, final Exchange exchange) {     permit.setDelayMs(getTimePeriodMillis()).     delayQueue.put(permit).     try {         ScheduledFuture<?> next = asyncExecutor.schedule(this::clean, cleanPeriodMillis, TimeUnit.MILLISECONDS).         ScheduledFuture<?> prev = cleanFuture.getAndSet(next).         if (prev != null) {             prev.cancel(false).         }         // try and incur the least amount of overhead while releasing permits back to the queue         if (log.isTraceEnabled()) {             log.trace("Permit released, for exchangeId: {}", exchange.getExchangeId()).         }     } catch (RejectedExecutionException e) {         log.debug("Throttling queue cleaning rejected", e).     } }
true;public,synchronized;1;41;/**  * Evaluates the maxRequestsPerPeriodExpression and adjusts the throttle rate up or down.  */ ;/**  * Evaluates the maxRequestsPerPeriodExpression and adjusts the throttle rate up or down.  */ public synchronized void calculateAndSetMaxRequestsPerPeriod(final Exchange exchange) throws Exception {     Integer newThrottle = maxRequestsPerPeriodExpression.evaluate(exchange, Integer.class).     if (newThrottle != null && newThrottle < 0) {         throw new IllegalStateException("The maximumRequestsPerPeriod must be a positive number, was: " + newThrottle).     }     if (newThrottle == null && throttleRate == 0) {         throw new RuntimeExchangeException("The maxRequestsPerPeriodExpression was evaluated as null: " + maxRequestsPerPeriodExpression, exchange).     }     if (newThrottle != null) {         if (newThrottle != throttleRate) {             // decrease             if (throttleRate > newThrottle) {                 int delta = throttleRate - newThrottle.                 // discard any permits that are needed to decrease throttling                 while (delta > 0) {                     delayQueue.take().                     delta--.                     log.trace("Permit discarded due to throttling rate decrease, triggered by ExchangeId: {}", exchange.getExchangeId()).                 }                 log.debug("Throttle rate decreased from {} to {}, triggered by ExchangeId: {}", throttleRate, newThrottle, exchange.getExchangeId()).             // increase             } else if (newThrottle > throttleRate) {                 int delta = newThrottle - throttleRate.                 for (int i = 0. i < delta. i++) {                     delayQueue.put(new ThrottlePermit(-1)).                 }                 if (throttleRate == 0) {                     log.debug("Initial throttle rate set to {}, triggered by ExchangeId: {}", newThrottle, exchange.getExchangeId()).                 } else {                     log.debug("Throttle rate increase from {} to {}, triggered by ExchangeId: {}", throttleRate, newThrottle, exchange.getExchangeId()).                 }             }             throttleRate = newThrottle.         }     } }
false;public;1;3;;public void setDelayMs(final long delayMs) {     this.scheduledTime = System.currentTimeMillis() + delayMs. }
false;public;1;4;;@Override public long getDelay(final TimeUnit unit) {     return unit.convert(scheduledTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS). }
false;public;1;4;;@Override public int compareTo(final Delayed o) {     return (int) (getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS)). }
false;public;0;3;;public boolean isRejectExecution() {     return rejectExecution. }
false;public;1;3;;public void setRejectExecution(boolean rejectExecution) {     this.rejectExecution = rejectExecution. }
false;public;0;3;;public boolean isAsyncDelayed() {     return asyncDelayed. }
false;public;1;3;;public void setAsyncDelayed(boolean asyncDelayed) {     this.asyncDelayed = asyncDelayed. }
false;public;0;3;;public boolean isCallerRunsWhenRejected() {     return callerRunsWhenRejected. }
false;public;1;3;;public void setCallerRunsWhenRejected(boolean callerRunsWhenRejected) {     this.callerRunsWhenRejected = callerRunsWhenRejected. }
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setId(final String id) {     this.id = id. }
true;public;1;3;/**  * Sets the maximum number of requests per time period expression  */ ;/**  * Sets the maximum number of requests per time period expression  */ public void setMaximumRequestsPerPeriodExpression(Expression maxRequestsPerPeriodExpression) {     this.maxRequestsPerPeriodExpression = maxRequestsPerPeriodExpression. }
false;public;0;3;;public Expression getMaximumRequestsPerPeriodExpression() {     return maxRequestsPerPeriodExpression. }
true;public;0;3;/**  * Gets the current maximum request per period value.  * If it is grouped throttling applied with correlationExpression  * than the max per period within the group will return  */ ;/**  * Gets the current maximum request per period value.  * If it is grouped throttling applied with correlationExpression  * than the max per period within the group will return  */ public int getCurrentMaximumRequestsPerPeriod() {     return states.values().stream().mapToInt(ThrottlingState::getThrottleRate).max().orElse(0). }
true;public;1;3;/**  * Sets the time period during which the maximum number of requests apply  */ ;/**  * Sets the time period during which the maximum number of requests apply  */ public void setTimePeriodMillis(final long timePeriodMillis) {     this.timePeriodMillis = timePeriodMillis. }
false;public;0;3;;public long getTimePeriodMillis() {     return timePeriodMillis. }
false;public;0;3;;public String getTraceLabel() {     return "throttle[" + maxRequestsPerPeriodExpression + " per: " + timePeriodMillis + "]". }
false;public;0;4;;@Override public String toString() {     return "Throttler[requests: " + maxRequestsPerPeriodExpression + " per: " + timePeriodMillis + " (ms)]". }
