commented;modifiers;parameterAmount;loc;comment;code
false;public;3;37;;public OnExceptionDefinition getExceptionPolicy(Map<ExceptionPolicyKey, OnExceptionDefinition> exceptionPolicies, Exchange exchange, Throwable exception) {     Map<Integer, OnExceptionDefinition> candidates = new TreeMap<>().     Map<ExceptionPolicyKey, OnExceptionDefinition> routeScoped = new LinkedHashMap<>().     Map<ExceptionPolicyKey, OnExceptionDefinition> contextScoped = new LinkedHashMap<>().     // split policies into route and context scoped     initRouteAndContextScopedExceptionPolicies(exceptionPolicies, routeScoped, contextScoped).     // at first check route scoped as we prefer them over context scoped     // recursive up the tree using the iterator     boolean exactMatch = false.     Iterator<Throwable> it = createExceptionIterator(exception).     while (!exactMatch && it.hasNext()) {         // we should stop looking if we have found an exact match         exactMatch = findMatchedExceptionPolicy(routeScoped, exchange, it.next(), candidates).     }     // fallback to check context scoped (only do this if there was no exact match)     it = createExceptionIterator(exception).     while (!exactMatch && it.hasNext()) {         // we should stop looking if we have found an exact match         exactMatch = findMatchedExceptionPolicy(contextScoped, exchange, it.next(), candidates).     }     // now go through the candidates and find the best     LOG.trace("Found {} candidates", candidates.size()).     if (candidates.isEmpty()) {         // no type found         return null.     } else {         // return the first in the map as its sorted and we checked route scoped first, which we prefer         return candidates.values().iterator().next().     } }
false;private;3;14;;private void initRouteAndContextScopedExceptionPolicies(Map<ExceptionPolicyKey, OnExceptionDefinition> exceptionPolicies, Map<ExceptionPolicyKey, OnExceptionDefinition> routeScoped, Map<ExceptionPolicyKey, OnExceptionDefinition> contextScoped) {     // loop through all the entries and split into route and context scoped     Set<Map.Entry<ExceptionPolicyKey, OnExceptionDefinition>> entries = exceptionPolicies.entrySet().     for (Map.Entry<ExceptionPolicyKey, OnExceptionDefinition> entry : entries) {         if (entry.getKey().getRouteId() != null) {             routeScoped.put(entry.getKey(), entry.getValue()).         } else {             contextScoped.put(entry.getKey(), entry.getValue()).         }     } }
false;private;4;82;;private boolean findMatchedExceptionPolicy(Map<ExceptionPolicyKey, OnExceptionDefinition> exceptionPolicies, Exchange exchange, Throwable exception, Map<Integer, OnExceptionDefinition> candidates) {     if (LOG.isTraceEnabled()) {         LOG.trace("Finding best suited exception policy for thrown exception {}", exception.getClass().getName()).     }     // the goal is to find the exception with the same/closet inheritance level as the target exception being thrown     int targetLevel = getInheritanceLevel(exception.getClass()).     // candidate is the best candidate found so far to return     OnExceptionDefinition candidate = null.     // difference in inheritance level between the current candidate and the thrown exception (target level)     int candidateDiff = Integer.MAX_VALUE.     // loop through all the entries and find the best candidates to use     Set<Map.Entry<ExceptionPolicyKey, OnExceptionDefinition>> entries = exceptionPolicies.entrySet().     for (Map.Entry<ExceptionPolicyKey, OnExceptionDefinition> entry : entries) {         Class<?> clazz = entry.getKey().getExceptionClass().         OnExceptionDefinition type = entry.getValue().         // so we will not pick an OnException from another route         if (exchange != null && exchange.getUnitOfWork() != null && type.isRouteScoped()) {             RouteDefinition route = exchange.getUnitOfWork().getRouteContext() != null ? (RouteDefinition) exchange.getUnitOfWork().getRouteContext().getRoute() : null.             RouteDefinition typeRoute = ProcessorDefinitionHelper.getRoute(type).             if (route != null && typeRoute != null && route != typeRoute) {                 if (LOG.isTraceEnabled()) {                     LOG.trace("The type is scoped for route: {} however Exchange is at route: {}", typeRoute.getId(), route.getId()).                 }                 continue.             }         }         if (filter(type, clazz, exception)) {             // must match             if (!matchesWhen(type, exchange)) {                 LOG.trace("The type did not match when: {}", type).                 continue.             }             // exact match then break             if (clazz.equals(exception.getClass())) {                 candidate = type.                 candidateDiff = 0.                 break.             }             // not an exact match so find the best candidate             int level = getInheritanceLevel(clazz).             int diff = targetLevel - level.             if (diff < candidateDiff) {                 // replace with a much better candidate                 candidate = type.                 candidateDiff = diff.             }         }     }     if (candidate != null) {         if (!candidates.containsKey(candidateDiff)) {             // only add as candidate if we do not already have it registered with that level             LOG.trace("Adding {} as candidate at level {}", candidate, candidateDiff).             candidates.put(candidateDiff, candidate).         } else {             // for example we check route scope before context scope (preferring route scopes)             if (LOG.isTraceEnabled()) {                 LOG.trace("Existing candidate {} takes precedence over{} at level {}", new Object[] { candidates.get(candidateDiff), candidate, candidateDiff }).             }         }     }     // if we found a exact match then we should stop continue looking     boolean exactMatch = candidateDiff == 0.     if (LOG.isTraceEnabled() && exactMatch) {         LOG.trace("Exact match found for candidate: {}", candidate).     }     return exactMatch. }
true;protected;3;4;/**  * Strategy to filter the given type exception class with the thrown exception  *  * @param type           the exception type  * @param exceptionClass the current exception class for testing  * @param exception      the thrown exception  * @return <tt>true</tt> if the to current exception class is a candidate, <tt>false</tt> to skip it.  */ ;/**  * Strategy to filter the given type exception class with the thrown exception  *  * @param type           the exception type  * @param exceptionClass the current exception class for testing  * @param exception      the thrown exception  * @return <tt>true</tt> if the to current exception class is a candidate, <tt>false</tt> to skip it.  */ protected boolean filter(OnExceptionDefinition type, Class<?> exceptionClass, Throwable exception) {     // must be instance of check to ensure that the exceptionClass is one type of the thrown exception     return exceptionClass.isInstance(exception). }
true;protected;2;7;/**  * Strategy method for matching the exception type with the current exchange.  * <p/>  * This default implementation will match as:  * <ul>  * <li>Always true if no when predicate on the exception type  * <li>Otherwise the when predicate is matches against the current exchange  * </ul>  *  * @param definition     the exception definition  * @param exchange the current {@link Exchange}  * @return <tt>true</tt> if matched, <tt>false</tt> otherwise.  */ ;/**  * Strategy method for matching the exception type with the current exchange.  * <p/>  * This default implementation will match as:  * <ul>  * <li>Always true if no when predicate on the exception type  * <li>Otherwise the when predicate is matches against the current exchange  * </ul>  *  * @param definition     the exception definition  * @param exchange the current {@link Exchange}  * @return <tt>true</tt> if matched, <tt>false</tt> otherwise.  */ protected boolean matchesWhen(OnExceptionDefinition definition, Exchange exchange) {     if (definition.getOnWhen() == null || definition.getOnWhen().getExpression() == null) {         // if no predicate then it's always a match         return true.     }     return definition.getOnWhen().getExpression().matches(exchange). }
true;protected;1;3;/**  * Strategy method creating the iterator to walk the exception in the order Camel should use  * for find the {@link OnExceptionDefinition} should be used.  * <p/>  * The default iterator will walk from the bottom upwards  * (the last caused by going upwards to the exception)  *  * @param exception  the exception  * @return the iterator  */ ;/**  * Strategy method creating the iterator to walk the exception in the order Camel should use  * for find the {@link OnExceptionDefinition} should be used.  * <p/>  * The default iterator will walk from the bottom upwards  * (the last caused by going upwards to the exception)  *  * @param exception  the exception  * @return the iterator  */ protected Iterator<Throwable> createExceptionIterator(Throwable exception) {     return ObjectHelper.createExceptionIterator(exception). }
false;private,static;1;6;;private static int getInheritanceLevel(Class<?> clazz) {     if (clazz == null || "java.lang.Object".equals(clazz.getName())) {         return 0.     }     return 1 + getInheritanceLevel(clazz.getSuperclass()). }
