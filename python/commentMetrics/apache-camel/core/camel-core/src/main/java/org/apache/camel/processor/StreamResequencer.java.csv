commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Expression getExpression() {     return expression. }
true;public;0;3;/**  * Returns this resequencer's exception handler.  */ ;/**  * Returns this resequencer's exception handler.  */ public ExceptionHandler getExceptionHandler() {     return exceptionHandler. }
true;public;0;3;/**  * Returns the next processor.  */ ;/**  * Returns the next processor.  */ public Processor getProcessor() {     return processor. }
true;public;0;3;/**  * Returns this resequencer's capacity. The capacity is the maximum number  * of exchanges that can be managed by this resequencer at a given point in  * time. If the capacity if reached, polling from the endpoint will be  * skipped for <code>timeout</code> milliseconds giving exchanges the  * possibility to time out and to be delivered after the waiting period.  *  * @return this resequencer's capacity.  */ ;/**  * Returns this resequencer's capacity. The capacity is the maximum number  * of exchanges that can be managed by this resequencer at a given point in  * time. If the capacity if reached, polling from the endpoint will be  * skipped for <code>timeout</code> milliseconds giving exchanges the  * possibility to time out and to be delivered after the waiting period.  *  * @return this resequencer's capacity.  */ public int getCapacity() {     return capacity. }
true;public;0;3;/**  * Returns this resequencer's timeout. This sets the resequencer engine's  * timeout via {@link ResequencerEngine#setTimeout(long)}. This value is  * also used to define the polling timeout from the endpoint.  *  * @return this resequencer's timeout. (Processor)  * @see ResequencerEngine#setTimeout(long)  */ ;/**  * Returns this resequencer's timeout. This sets the resequencer engine's  * timeout via {@link ResequencerEngine#setTimeout(long)}. This value is  * also used to define the polling timeout from the endpoint.  *  * @return this resequencer's timeout. (Processor)  * @see ResequencerEngine#setTimeout(long)  */ public long getTimeout() {     return engine.getTimeout(). }
false;public;1;3;;public void setCapacity(int capacity) {     this.capacity = capacity. }
false;public;1;3;;public void setTimeout(long timeout) {     engine.setTimeout(timeout). }
false;public;1;3;;public void setDeliveryAttemptInterval(long deliveryAttemptInterval) {     this.deliveryAttemptInterval = deliveryAttemptInterval. }
false;public;0;3;;public boolean isIgnoreInvalidExchanges() {     return ignoreInvalidExchanges. }
false;public;1;3;;public void setRejectOld(Boolean rejectOld) {     engine.setRejectOld(rejectOld). }
false;public;0;3;;public boolean isRejectOld() {     return engine.getRejectOld() != null && engine.getRejectOld(). }
true;public;1;3;/**  * Sets whether to ignore invalid exchanges which cannot be used by this stream resequencer.  * <p/>  * Default is <tt>false</tt>, by which an {@link CamelExchangeException} is thrown if the {@link Exchange}  * is invalid.  */ ;/**  * Sets whether to ignore invalid exchanges which cannot be used by this stream resequencer.  * <p/>  * Default is <tt>false</tt>, by which an {@link CamelExchangeException} is thrown if the {@link Exchange}  * is invalid.  */ public void setIgnoreInvalidExchanges(boolean ignoreInvalidExchanges) {     this.ignoreInvalidExchanges = ignoreInvalidExchanges. }
false;public;0;4;;@Override public String toString() {     return "StreamResequencer[to: " + processor + "]". }
false;public;0;3;;public String getTraceLabel() {     return "streamResequence". }
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setId(String id) {     this.id = id. }
false;protected;0;7;;@Override protected void doStart() throws Exception {     ServiceHelper.startService(processor).     delivery = new Delivery().     engine.start().     delivery.start(). }
false;protected;0;7;;@Override protected void doStop() throws Exception {     // let's stop everything in the reverse order     // no need to stop the worker thread -- it will stop automatically when this service is stopped     engine.stop().     ServiceHelper.stopService(processor). }
true;public;1;3;/**  * Sends the <code>exchange</code> to the next <code>processor</code>.  *  * @param exchange exchange to send.  */ ;/**  * Sends the <code>exchange</code> to the next <code>processor</code>.  *  * @param exchange exchange to send.  */ public void sendElement(Exchange exchange) throws Exception {     processor.process(exchange). }
false;public;2;26;;public boolean process(Exchange exchange, AsyncCallback callback) {     while (engine.size() >= capacity) {         try {             Thread.sleep(getTimeout()).         } catch (InterruptedException e) {             // we was interrupted so break out             exchange.setException(e).             callback.done(true).             return true.         }     }     try {         engine.insert(exchange).         delivery.request().     } catch (Exception e) {         if (isIgnoreInvalidExchanges()) {             log.debug("Invalid Exchange. This Exchange will be ignored: {}", exchange).         } else {             exchange.setException(new CamelExchangeException("Error processing Exchange in StreamResequencer", exchange, e)).         }     }     callback.done(true).     return true. }
false;public;0;3;;public boolean hasNext() {     return processor != null. }
false;public;0;8;;public List<Processor> next() {     if (!hasNext()) {         return null.     }     List<Processor> answer = new ArrayList<>(1).     answer.add(processor).     return answer. }
false;public;0;21;;@Override public void run() {     while (isRunAllowed()) {         try {             deliveryRequestLock.lock().             try {                 deliveryRequestCondition.await(deliveryAttemptInterval, TimeUnit.MILLISECONDS).             } finally {                 deliveryRequestLock.unlock().             }         } catch (InterruptedException e) {             break.         }         try {             engine.deliver().         } catch (Throwable t) {             // a fail safe to handle all exceptions being thrown             getExceptionHandler().handleException(t).         }     } }
false;public;0;3;;public void cancel() {     interrupt(). }
false;public;0;8;;public void request() {     deliveryRequestLock.lock().     try {         deliveryRequestCondition.signal().     } finally {         deliveryRequestLock.unlock().     } }
