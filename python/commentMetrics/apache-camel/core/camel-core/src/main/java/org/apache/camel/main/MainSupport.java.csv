commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;@Override public void run() {     log.info("Received hang up - stopping the main instance.").     try {         mainInstance.stop().     } catch (Exception ex) {         log.warn("Error during stopping the main instance.", ex).     } }
false;protected;2;4;;protected void doProcess(String arg, LinkedList<String> remainingArgs) {     showOptions().     completed(). }
false;protected;3;4;;@Override protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {     setRouteBuilderClasses(parameter). }
false;protected;3;7;;protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {     // skip second marker to be backwards compatible     if (parameter.endsWith("s") || parameter.endsWith("S")) {         parameter = parameter.substring(0, parameter.length() - 1).     }     setDuration(Integer.parseInt(parameter)). }
false;protected;3;3;;protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {     setDurationMaxMessages(Integer.parseInt(parameter)). }
false;protected;3;7;;protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {     // skip second marker to be backwards compatible     if (parameter.endsWith("s") || parameter.endsWith("S")) {         parameter = parameter.substring(0, parameter.length() - 1).     }     setDurationIdle(Integer.parseInt(parameter)). }
false;protected;2;3;;protected void doProcess(String arg, LinkedList<String> remainingArgs) {     enableTrace(). }
false;protected;3;3;;protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {     setDurationHitExitCode(Integer.parseInt(parameter)). }
false;protected;3;4;;@Override protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {     setFileWatchDirectory(parameter). }
false;protected;3;3;;protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {     setPropertyPlaceholderLocations(parameter). }
true;public;0;19;/**  * Runs this process with the given arguments, and will wait until completed, or the JVM terminates.  */ ;/**  * Runs this process with the given arguments, and will wait until completed, or the JVM terminates.  */ public void run() throws Exception {     if (!completed.get()) {         internalBeforeStart().         // if we have an issue starting then propagate the exception to caller         beforeStart().         start().         try {             afterStart().             waitUntilCompleted().             internalBeforeStop().             beforeStop().             stop().             afterStop().         } catch (Exception e) {             // however while running then just log errors             LOG.error("Failed: {}", e, e).         }     } }
true;public;0;3;/**  * Disable the hangup support. No graceful stop by calling stop() on a  * Hangup signal.  */ ;/**  * Disable the hangup support. No graceful stop by calling stop() on a  * Hangup signal.  */ public void disableHangupSupport() {     hangupInterceptorEnabled = false. }
true;public;0;3;/**  * Hangup support is enabled by default.  */ ;/**  * Hangup support is enabled by default.  */ public void enableHangupSupport() {     hangupInterceptorEnabled = true. }
true;public;1;3;/**  * Adds a {@link org.apache.camel.main.MainListener} to receive callbacks when the main is started or stopping  *  * @param listener the listener  */ ;/**  * Adds a {@link org.apache.camel.main.MainListener} to receive callbacks when the main is started or stopping  *  * @param listener the listener  */ public void addMainListener(MainListener listener) {     listeners.add(listener). }
true;public;1;3;/**  * Removes the {@link org.apache.camel.main.MainListener}  *  * @param listener the listener  */ ;/**  * Removes the {@link org.apache.camel.main.MainListener}  *  * @param listener the listener  */ public void removeMainListener(MainListener listener) {     listeners.remove(listener). }
true;protected;0;5;/**  * Callback to run custom logic before CamelContext is being started.  * <p/>  * It is recommended to use {@link org.apache.camel.main.MainListener} instead.  */ ;/**  * Callback to run custom logic before CamelContext is being started.  * <p/>  * It is recommended to use {@link org.apache.camel.main.MainListener} instead.  */ protected void beforeStart() throws Exception {     for (MainListener listener : listeners) {         listener.beforeStart(this).     } }
true;protected;0;5;/**  * Callback to run custom logic after CamelContext has been started.  * <p/>  * It is recommended to use {@link org.apache.camel.main.MainListener} instead.  */ ;/**  * Callback to run custom logic after CamelContext has been started.  * <p/>  * It is recommended to use {@link org.apache.camel.main.MainListener} instead.  */ protected void afterStart() throws Exception {     for (MainListener listener : listeners) {         listener.afterStart(this).     } }
false;private;0;9;;private void internalBeforeStart() {     if (hangupInterceptorEnabled) {         String threadName = ThreadHelper.resolveThreadName(null, "CamelHangupInterceptor").         Thread task = new HangupInterceptor(this).         task.setName(threadName).         Runtime.getRuntime().addShutdownHook(task).     } }
true;protected;0;5;/**  * Callback to run custom logic before CamelContext is being stopped.  * <p/>  * It is recommended to use {@link org.apache.camel.main.MainListener} instead.  */ ;/**  * Callback to run custom logic before CamelContext is being stopped.  * <p/>  * It is recommended to use {@link org.apache.camel.main.MainListener} instead.  */ protected void beforeStop() throws Exception {     for (MainListener listener : listeners) {         listener.beforeStop(this).     } }
true;protected;0;5;/**  * Callback to run custom logic after CamelContext has been stopped.  * <p/>  * It is recommended to use {@link org.apache.camel.main.MainListener} instead.  */ ;/**  * Callback to run custom logic after CamelContext has been stopped.  * <p/>  * It is recommended to use {@link org.apache.camel.main.MainListener} instead.  */ protected void afterStop() throws Exception {     for (MainListener listener : listeners) {         listener.afterStop(this).     } }
false;private;0;10;;private void internalBeforeStop() {     try {         if (camelTemplate != null) {             ServiceHelper.stopService(camelTemplate).             camelTemplate = null.         }     } catch (Exception e) {         LOG.debug("Error stopping camelTemplate due " + e.getMessage() + ". This exception is ignored.", e).     } }
true;public;0;5;/**  * Marks this process as being completed.  */ ;/**  * Marks this process as being completed.  */ public void completed() {     completed.set(true).     exitCode.compareAndSet(UNINITIALIZED_EXIT_CODE, DEFAULT_EXIT_CODE).     latch.countDown(). }
true;public;0;7;/**  * Displays the command line options.  */ ;/**  * Displays the command line options.  */ public void showOptions() {     showOptionsHeader().     for (Option option : options) {         System.out.println(option.getInformation()).     } }
true;public;1;26;/**  * Parses the command line arguments.  */ ;/**  * Parses the command line arguments.  */ public void parseArguments(String[] arguments) {     LinkedList<String> args = new LinkedList<>(Arrays.asList(arguments)).     boolean valid = true.     while (!args.isEmpty()) {         String arg = args.removeFirst().         boolean handled = false.         for (Option option : options) {             if (option.processOption(arg, args)) {                 handled = true.                 break.             }         }         if (!handled) {             System.out.println("Unknown option: " + arg).             System.out.println().             valid = false.             break.         }     }     if (!valid) {         showOptions().         completed().     } }
false;public;1;3;;public void addOption(Option option) {     options.add(option). }
false;public;0;3;;public long getDuration() {     return duration. }
true;public;1;3;/**  * Sets the duration (in seconds) to run the application until it  * should be terminated. Defaults to -1. Any value <= 0 will run forever.  */ ;/**  * Sets the duration (in seconds) to run the application until it  * should be terminated. Defaults to -1. Any value <= 0 will run forever.  */ public void setDuration(long duration) {     this.duration = duration. }
false;public;0;3;;public long getDurationIdle() {     return durationIdle. }
true;public;1;3;/**  * Sets the maximum idle duration (in seconds) when running the application, and  * if there has been no message processed after being idle for more than this duration  * then the application should be terminated.  * Defaults to -1. Any value <= 0 will run forever.  */ ;/**  * Sets the maximum idle duration (in seconds) when running the application, and  * if there has been no message processed after being idle for more than this duration  * then the application should be terminated.  * Defaults to -1. Any value <= 0 will run forever.  */ public void setDurationIdle(long durationIdle) {     this.durationIdle = durationIdle. }
false;public;0;3;;public int getDurationMaxMessages() {     return durationMaxMessages. }
true;public;1;3;/**  * Sets the duration to run the application to process at most max messages until it  * should be terminated. Defaults to -1. Any value <= 0 will run forever.  */ ;/**  * Sets the duration to run the application to process at most max messages until it  * should be terminated. Defaults to -1. Any value <= 0 will run forever.  */ public void setDurationMaxMessages(int durationMaxMessages) {     this.durationMaxMessages = durationMaxMessages. }
false;public;0;3;;public TimeUnit getTimeUnit() {     return timeUnit. }
true;public;1;3;/**  * Sets the time unit duration (seconds by default).  */ ;/**  * Sets the time unit duration (seconds by default).  */ public void setTimeUnit(TimeUnit timeUnit) {     this.timeUnit = timeUnit. }
true;public;1;3;/**  * Sets the exit code for the application if duration was hit  */ ;/**  * Sets the exit code for the application if duration was hit  */ public void setDurationHitExitCode(int durationHitExitCode) {     this.durationHitExitCode = durationHitExitCode. }
false;public;0;3;;public int getDurationHitExitCode() {     return durationHitExitCode. }
false;public;0;3;;public int getExitCode() {     return exitCode.get(). }
false;public;1;3;;public void setRouteBuilderClasses(String builders) {     this.routeBuilderClasses = builders. }
false;public;0;3;;public String getFileWatchDirectory() {     return fileWatchDirectory. }
true;public;1;3;/**  * Sets the directory name to watch XML file changes to trigger live reload of Camel routes.  * <p/>  * Notice you cannot set this value and a custom {@link ReloadStrategy} as well.  */ ;/**  * Sets the directory name to watch XML file changes to trigger live reload of Camel routes.  * <p/>  * Notice you cannot set this value and a custom {@link ReloadStrategy} as well.  */ public void setFileWatchDirectory(String fileWatchDirectory) {     this.fileWatchDirectory = fileWatchDirectory. }
false;public;0;3;;public boolean isFileWatchDirectoryRecursively() {     return fileWatchDirectoryRecursively. }
true;public;1;3;/**  * Sets the flag to watch directory of XML file changes recursively to trigger live reload of Camel routes.  * <p/>  * Notice you cannot set this value and a custom {@link ReloadStrategy} as well.  */ ;/**  * Sets the flag to watch directory of XML file changes recursively to trigger live reload of Camel routes.  * <p/>  * Notice you cannot set this value and a custom {@link ReloadStrategy} as well.  */ public void setFileWatchDirectoryRecursively(boolean fileWatchDirectoryRecursively) {     this.fileWatchDirectoryRecursively = fileWatchDirectoryRecursively. }
false;public;0;3;;public String getRouteBuilderClasses() {     return routeBuilderClasses. }
false;public;0;3;;public ReloadStrategy getReloadStrategy() {     return reloadStrategy. }
true;public;1;3;/**  * Sets a custom {@link ReloadStrategy} to be used.  * <p/>  * Notice you cannot set this value and the fileWatchDirectory as well.  */ ;/**  * Sets a custom {@link ReloadStrategy} to be used.  * <p/>  * Notice you cannot set this value and the fileWatchDirectory as well.  */ public void setReloadStrategy(ReloadStrategy reloadStrategy) {     this.reloadStrategy = reloadStrategy. }
false;public;0;3;;public String getPropertyPlaceholderLocations() {     return propertyPlaceholderLocations. }
true;public;1;3;/**  * A list of locations to add for loading properties.  * You can use comma to separate multiple locations.  */ ;/**  * A list of locations to add for loading properties.  * You can use comma to separate multiple locations.  */ public void setPropertyPlaceholderLocations(String location) {     this.propertyPlaceholderLocations = location. }
false;public;0;3;;public boolean isTrace() {     return trace. }
false;public;0;3;;public void enableTrace() {     this.trace = true. }
false;protected;0;4;;protected void doStop() throws Exception {     // call completed to properly stop as we count down the waiting latch     completed(). }
false;protected;0;2;;protected void doStart() throws Exception { }
false;protected;0;28;;protected void waitUntilCompleted() {     while (!completed.get()) {         try {             if (duration > 0) {                 TimeUnit unit = getTimeUnit().                 LOG.info("Waiting for: {} {}", duration, unit).                 latch.await(duration, unit).                 exitCode.compareAndSet(UNINITIALIZED_EXIT_CODE, durationHitExitCode).                 completed.set(true).             } else if (durationIdle > 0) {                 TimeUnit unit = getTimeUnit().                 LOG.info("Waiting to be idle for: {} {}", duration, unit).                 exitCode.compareAndSet(UNINITIALIZED_EXIT_CODE, durationHitExitCode).                 latch.await().                 completed.set(true).             } else if (durationMaxMessages > 0) {                 LOG.info("Waiting until: {} messages has been processed", durationMaxMessages).                 exitCode.compareAndSet(UNINITIALIZED_EXIT_CODE, durationHitExitCode).                 latch.await().                 completed.set(true).             } else {                 latch.await().             }         } catch (InterruptedException e) {             Thread.currentThread().interrupt().         }     } }
true;public;1;5;/**  * Parses the command line arguments then runs the program.  */ ;/**  * Parses the command line arguments then runs the program.  */ public void run(String[] args) throws Exception {     parseArguments(args).     run().     LOG.info("MainSupport exiting code: {}", getExitCode()). }
true;public;0;4;/**  * Displays the header message for the command line options.  */ ;/**  * Displays the header message for the command line options.  */ public void showOptionsHeader() {     System.out.println("Apache Camel Runner takes the following options").     System.out.println(). }
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;0;3;;public List<RouteBuilder> getRouteBuilders() {     return routeBuilders. }
false;public;1;3;;public void setRouteBuilders(List<RouteBuilder> routeBuilders) {     this.routeBuilders = routeBuilders. }
false;public;0;7;;public List<RouteDefinition> getRouteDefinitions() {     List<RouteDefinition> answer = new ArrayList<>().     if (camelContext != null) {         answer.addAll(camelContext.adapt(ModelCamelContext.class).getRouteDefinitions()).     }     return answer. }
false;public;0;6;;public ProducerTemplate getCamelTemplate() throws Exception {     if (camelTemplate == null) {         camelTemplate = findOrCreateCamelTemplate().     }     return camelTemplate. }
false;protected,abstract;0;1;;protected abstract ProducerTemplate findOrCreateCamelTemplate().
false;protected,abstract;0;1;;protected abstract CamelContext createCamelContext().
false;protected;0;4;;protected void initCamelContext() throws Exception {     camelContext = createCamelContext().     postProcessCamelContext(camelContext). }
false;public;0;3;;public ModelJAXBContextFactory getModelJAXBContextFactory() {     return new DefaultModelJAXBContextFactory(). }
false;protected;1;15;;protected void loadRouteBuilders(CamelContext camelContext) throws Exception {     if (routeBuilderClasses != null) {         String[] routeClasses = routeBuilderClasses.split(",").         for (String routeClass : routeClasses) {             Class<?> routeClazz = camelContext.getClassResolver().resolveClass(routeClass).             // lets use Camel's injector so the class has some support for dependency injection             Object builder = camelContext.getInjector().newInstance(routeClazz).             if (builder instanceof RouteBuilder) {                 getRouteBuilders().add((RouteBuilder) builder).             } else {                 LOG.warn("Class {} is not a RouteBuilder class", routeClazz).             }         }     } }
false;protected;1;62;;protected void postProcessCamelContext(CamelContext camelContext) throws Exception {     if (propertyPlaceholderLocations != null) {         PropertiesComponent pc = camelContext.getPropertiesComponent().         pc.addLocation(propertyPlaceholderLocations).         LOG.info("Using properties from: {}", propertyPlaceholderLocations).     } else {         // lets default to application.properties and ignore if its missing         PropertiesComponent pc = camelContext.getPropertiesComponent().         pc.addLocation("classpath:application.properties").         pc.setIgnoreMissingLocation(true).         LOG.info("Using optional properties from classpath:application.properties").     }     if (trace) {         camelContext.setTracing(true).     }     if (fileWatchDirectory != null) {         ReloadStrategy reload = new FileWatcherReloadStrategy(fileWatchDirectory, fileWatchDirectoryRecursively).         camelContext.setReloadStrategy(reload).         // ensure reload is added as service and started         camelContext.addService(reload).         // and ensure its register in JMX (which requires manually to be added because CamelContext is already started)         Object managedObject = camelContext.getManagementStrategy().getManagementObjectStrategy().getManagedObjectForService(camelContext, reload).         if (managedObject == null) {             // service should not be managed             return.         }         // skip already managed services, for example if a route has been restarted         if (camelContext.getManagementStrategy().isManaged(managedObject)) {             LOG.trace("The service is already managed: {}", reload).             return.         }         try {             camelContext.getManagementStrategy().manageObject(managedObject).         } catch (Exception e) {             LOG.warn("Could not register service: " + reload + " as Service MBean.", e).         }     }     if (durationMaxMessages > 0 || durationIdle > 0) {         // convert to seconds as that is what event notifier uses         long seconds = timeUnit.toSeconds(durationIdle).         // register lifecycle so we can trigger to shutdown the JVM when maximum number of messages has been processed         EventNotifier notifier = new MainDurationEventNotifier(camelContext, durationMaxMessages, seconds, completed, latch, true).         // register our event notifier         ServiceHelper.startService(notifier).         camelContext.getManagementStrategy().addEventNotifier(notifier).     }     // try to load the route builders from the routeBuilderClasses     loadRouteBuilders(camelContext).     for (RouteBuilder routeBuilder : routeBuilders) {         camelContext.addRoutes(routeBuilder).     }     // register lifecycle so we are notified in Camel is stopped from JMX or somewhere else     camelContext.addLifecycleStrategy(new MainLifecycleStrategy(completed, latch)).     // allow to do configuration before its started     for (MainListener listener : listeners) {         listener.configure(camelContext).     } }
false;public;1;3;;public void addRouteBuilder(RouteBuilder routeBuilder) {     getRouteBuilders().add(routeBuilder). }
false;public;1;9;;public void addRouteBuilder(Class routeBuilder) {     String existing = routeBuilderClasses.     if (existing != null) {         existing = existing + "," + routeBuilder.getName().     } else {         existing = routeBuilder.getName().     }     setRouteBuilderClasses(existing). }
false;public;2;7;;public boolean processOption(String arg, LinkedList<String> remainingArgs) {     if (arg.equalsIgnoreCase(abbreviation) || fullName.startsWith(arg)) {         doProcess(arg, remainingArgs).         return true.     }     return false. }
false;public;0;3;;public String getAbbreviation() {     return abbreviation. }
false;public;0;3;;public String getDescription() {     return description. }
false;public;0;3;;public String getFullName() {     return fullName. }
false;public;0;3;;public String getInformation() {     return "  " + getAbbreviation() + " or " + getFullName() + " = " + getDescription(). }
false;protected,abstract;2;1;;protected abstract void doProcess(String arg, LinkedList<String> remainingArgs).
false;protected;2;10;;protected void doProcess(String arg, LinkedList<String> remainingArgs) {     if (remainingArgs.isEmpty()) {         System.err.println("Expected fileName for ").         showOptions().         completed().     } else {         String parameter = remainingArgs.removeFirst().         doProcess(arg, parameter, remainingArgs).     } }
false;public;0;3;;public String getInformation() {     return "  " + getAbbreviation() + " or " + getFullName() + " <" + parameterName + "> = " + getDescription(). }
false;protected,abstract;3;1;;protected abstract void doProcess(String arg, String parameter, LinkedList<String> remainingArgs).
