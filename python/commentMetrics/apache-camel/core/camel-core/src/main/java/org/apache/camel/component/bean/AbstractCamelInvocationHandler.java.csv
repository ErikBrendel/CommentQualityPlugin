commented;modifiers;parameterAmount;loc;comment;code
false;private,static;2;16;;private static Object getBody(Exchange exchange, Class<?> type) throws InvalidPayloadException {     // get the body from the Exchange from either OUT or IN     if (exchange.hasOut()) {         if (exchange.getOut().getBody() != null) {             return exchange.getOut().getMandatoryBody(type).         } else {             return null.         }     } else {         if (exchange.getIn().getBody() != null) {             return exchange.getIn().getMandatoryBody(type).         } else {             return null.         }     } }
false;public,final;3;16;;@Override public final Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {     if (isValidMethod(method)) {         return doInvokeProxy(proxy, method, args).     } else {         // invalid method then invoke methods on this instead         if ("toString".equals(method.getName())) {             return this.toString().         } else if ("hashCode".equals(method.getName())) {             return this.hashCode().         } else if ("equals".equals(method.getName())) {             return Boolean.FALSE.         }         return null.     } }
false;public,abstract;3;1;;public abstract Object doInvokeProxy(Object proxy, Method method, Object[] args) throws Throwable.
false;protected;4;69;;@SuppressWarnings("unchecked") protected Object invokeProxy(final Method method, final ExchangePattern pattern, Object[] args, boolean binding) throws Throwable {     final Exchange exchange = new DefaultExchange(endpoint, pattern).     // Need to check if there are mutiple arguments and the parameters have no annotations for binding,     // then use the original bean invocation.     boolean canUseBinding = method.getParameterCount() == 1.     if (!canUseBinding) {         for (Parameter parameter : method.getParameters()) {             if (parameter.isAnnotationPresent(Header.class) || parameter.isAnnotationPresent(Headers.class) || parameter.isAnnotationPresent(ExchangeProperty.class) || parameter.isAnnotationPresent(Body.class)) {                 canUseBinding = true.             }         }     }     if (binding && canUseBinding) {         // in binding mode we bind the passed in arguments (args) to the created exchange         // using the existing Camel @Body, @Header, @Headers, @ExchangeProperty annotations         // if no annotation then its bound as the message body         int index = 0.         for (Annotation[] row : method.getParameterAnnotations()) {             Object value = args[index].             if (row == null || row.length == 0) {                 // assume its message body when there is no annotations                 exchange.getIn().setBody(value).             } else {                 for (Annotation ann : row) {                     if (ann.annotationType().isAssignableFrom(Header.class)) {                         Header header = (Header) ann.                         String name = header.value().                         exchange.getIn().setHeader(name, value).                     } else if (ann.annotationType().isAssignableFrom(Headers.class)) {                         Map map = exchange.getContext().getTypeConverter().tryConvertTo(Map.class, exchange, value).                         if (map != null) {                             exchange.getIn().getHeaders().putAll(map).                         }                     } else if (ann.annotationType().isAssignableFrom(ExchangeProperty.class)) {                         ExchangeProperty ep = (ExchangeProperty) ann.                         String name = ep.value().                         exchange.setProperty(name, value).                     } else if (ann.annotationType().isAssignableFrom(Body.class)) {                         exchange.getIn().setBody(value).                     } else {                         // assume its message body when there is no annotations                         exchange.getIn().setBody(value).                     }                 }             }             index++.         }     } else {         // no binding so use the old behavior with BeanInvocation as the body         BeanInvocation invocation = new BeanInvocation(method, args).         exchange.getIn().setBody(invocation).     }     if (binding) {         LOG.trace("Binding to service interface as @Body,@Header,@ExchangeProperty detected when calling proxy method: {}", method).     } else {         LOG.trace("No binding to service interface as @Body,@Header,@ExchangeProperty not detected. Using BeanInvocation as message body when calling proxy method: {}").     }     return doInvoke(method, exchange). }
false;protected;3;6;;protected Object invokeWithBody(final Method method, Object body, final ExchangePattern pattern) throws Throwable {     final Exchange exchange = new DefaultExchange(endpoint, pattern).     exchange.getIn().setBody(body).     return doInvoke(method, exchange). }
false;public;0;9;;public Object call() throws Exception {     // process the exchange     LOG.trace("Proxied method call {} invoking producer: {}", method.getName(), producer).     producer.process(exchange).     Object answer = afterInvoke(method, exchange, exchange.getPattern(), isFuture).     LOG.trace("Proxied method call {} returning: {}", method.getName(), answer).     return answer. }
false;protected;2;36;;protected Object doInvoke(final Method method, final Exchange exchange) throws Throwable {     // is the return type a future     final boolean isFuture = method.getReturnType() == Future.class.     // create task to execute the proxy and gather the reply     FutureTask<Object> task = new FutureTask<>(new Callable<Object>() {          public Object call() throws Exception {             // process the exchange             LOG.trace("Proxied method call {} invoking producer: {}", method.getName(), producer).             producer.process(exchange).             Object answer = afterInvoke(method, exchange, exchange.getPattern(), isFuture).             LOG.trace("Proxied method call {} returning: {}", method.getName(), answer).             return answer.         }     }).     if (isFuture) {         // submit task and return future         if (LOG.isTraceEnabled()) {             LOG.trace("Submitting task for exchange id {}", exchange.getExchangeId()).         }         getExecutorService(exchange.getContext()).submit(task).         return task.     } else {         // execute task now         try {             task.run().             return task.get().         } catch (ExecutionException e) {             // we don't want the wrapped exception from JDK             throw e.getCause().         }     } }
false;protected;4;40;;protected Object afterInvoke(Method method, Exchange exchange, ExchangePattern pattern, boolean isFuture) throws Exception {     // check if we had an exception     Throwable cause = exchange.getException().     if (cause != null) {         Throwable found = findSuitableException(cause, method).         if (found != null) {             if (found instanceof Exception) {                 throw (Exception) found.             } else {                 // wrap as exception                 throw new CamelExchangeException("Error processing exchange", exchange, cause).             }         }         // special for runtime camel exceptions as they can be nested         if (cause instanceof RuntimeCamelException) {             // directly             if (cause.getCause() instanceof RuntimeException) {                 throw (RuntimeException) ((RuntimeCamelException) cause).getCause().             }             throw (RuntimeCamelException) cause.         }         // okay just throw the exception as is         if (cause instanceof Exception) {             throw (Exception) cause.         } else {             // wrap as exception             throw new CamelExchangeException("Error processing exchange", exchange, cause).         }     }     Class<?> to = isFuture ? getGenericType(exchange.getContext(), method.getGenericReturnType()) : method.getReturnType().     // do not return a reply if the method is VOID     if (to == Void.TYPE) {         return null.     }     return getBody(exchange, to). }
false;protected,static;2;22;;protected static Class<?> getGenericType(CamelContext context, Type type) throws ClassNotFoundException {     if (type == null) {         // fallback and use object         return Object.class.     }     // unfortunately java dont provide a nice api for getting the generic     // type of the return type     // due type erasure, so we have to gather it based on a String     // representation     String name = StringHelper.between(type.toString(), "<", ">").     if (name != null) {         if (name.contains("<")) {             // we only need the outer type             name = StringHelper.before(name, "<").         }         return context.getClassResolver().resolveMandatoryClass(name).     } else {         // fallback and use object         return Object.class.     } }
false;protected,static,synchronized;1;17;;protected static synchronized ExecutorService getExecutorService(CamelContext context) {     // re-create it (its a shared static instance)     if (executorService == null || executorService.isTerminated() || executorService.isShutdown()) {         // try to lookup a pool first based on id/profile         executorService = context.getRegistry().lookupByNameAndType("CamelInvocationHandler", ExecutorService.class).         if (executorService == null) {             executorService = context.getExecutorServiceManager().newThreadPool(CamelInvocationHandler.class, "CamelInvocationHandler", "CamelInvocationHandler").         }         if (executorService == null) {             executorService = context.getExecutorServiceManager().newDefaultThreadPool(CamelInvocationHandler.class, "CamelInvocationHandler").         }     }     return executorService. }
true;protected;2;16;/**  * Tries to find the best suited exception to throw.  * <p/>  * It looks in the exception hierarchy from the caused exception and matches  * this against the declared exceptions being thrown on the method.  *  * @param cause the caused exception  * @param method the method  * @return the exception to throw, or <tt>null</tt> if not possible to find  *         a suitable exception  */ ;/**  * Tries to find the best suited exception to throw.  * <p/>  * It looks in the exception hierarchy from the caused exception and matches  * this against the declared exceptions being thrown on the method.  *  * @param cause the caused exception  * @param method the method  * @return the exception to throw, or <tt>null</tt> if not possible to find  *         a suitable exception  */ protected Throwable findSuitableException(Throwable cause, Method method) {     if (method.getExceptionTypes() == null || method.getExceptionTypes().length == 0) {         return null.     }     // the method     for (Class<?> type : method.getExceptionTypes()) {         Object fault = ObjectHelper.getException(type, cause).         if (fault != null) {             return Throwable.class.cast(fault).         }     }     return null. }
false;protected;1;10;;protected boolean isValidMethod(Method method) {     // must not be in the excluded list     for (Method excluded : EXCLUDED_METHODS) {         if (ObjectHelper.isOverridingMethod(excluded, method)) {             // the method is overriding an excluded method so its not valid             return false.         }     }     return true. }
