commented;modifiers;parameterAmount;loc;comment;code
false;public;2;3;;public void shutdown(CamelContext context, List<RouteStartupOrder> routes) throws Exception {     shutdown(context, routes, getTimeout(), getTimeUnit()). }
false;public;2;4;;@Override public void shutdownForced(CamelContext context, List<RouteStartupOrder> routes) throws Exception {     doShutdown(context, routes, getTimeout(), getTimeUnit(), false, false, true). }
false;public;2;3;;public void suspend(CamelContext context, List<RouteStartupOrder> routes) throws Exception {     doShutdown(context, routes, getTimeout(), getTimeUnit(), true, false, false). }
false;public;4;3;;public void shutdown(CamelContext context, List<RouteStartupOrder> routes, long timeout, TimeUnit timeUnit) throws Exception {     doShutdown(context, routes, timeout, timeUnit, false, false, false). }
false;public;5;4;;public boolean shutdown(CamelContext context, RouteStartupOrder route, long timeout, TimeUnit timeUnit, boolean abortAfterTimeout) throws Exception {     List<RouteStartupOrder> routes = Collections.singletonList(route).     return doShutdown(context, routes, timeout, timeUnit, false, abortAfterTimeout, false). }
false;public;4;3;;public void suspend(CamelContext context, List<RouteStartupOrder> routes, long timeout, TimeUnit timeUnit) throws Exception {     doShutdown(context, routes, timeout, timeUnit, true, false, false). }
false;protected;7;94;;protected boolean doShutdown(CamelContext context, List<RouteStartupOrder> routes, long timeout, TimeUnit timeUnit, boolean suspendOnly, boolean abortAfterTimeout, boolean forceShutdown) throws Exception {     // timeout must be a positive value     if (timeout <= 0) {         throw new IllegalArgumentException("Timeout must be a positive value").     }     // just return if no routes to shutdown     if (routes.isEmpty()) {         return true.     }     StopWatch watch = new StopWatch().     // at first sort according to route startup order     Comparator<RouteStartupOrder> comparator = Comparator.comparingInt(RouteStartupOrder::getStartupOrder).     if (shutdownRoutesInReverseOrder) {         comparator = comparator.reversed().     }     List<RouteStartupOrder> routesOrdered = new ArrayList<>(routes).     routesOrdered.sort(comparator).     if (suspendOnly) {         log.info("Starting to graceful suspend {} routes (timeout {} {})", routesOrdered.size(), timeout, timeUnit.toString().toLowerCase(Locale.ENGLISH)).     } else {         log.info("Starting to graceful shutdown {} routes (timeout {} {})", routesOrdered.size(), timeout, timeUnit.toString().toLowerCase(Locale.ENGLISH)).     }     // use another thread to perform the shutdowns so we can support timeout     timeoutOccurred.set(false).     currentShutdownTaskFuture = getExecutorService().submit(new ShutdownTask(context, routesOrdered, timeout, timeUnit, suspendOnly, abortAfterTimeout, timeoutOccurred, isLogInflightExchangesOnTimeout())).     try {         currentShutdownTaskFuture.get(timeout, timeUnit).     } catch (ExecutionException e) {         // unwrap execution exception         throw RuntimeCamelException.wrapRuntimeCamelException(e.getCause()).     } catch (Exception e) {         // either timeout or interrupted exception was thrown so this is okay         // as interrupted would mean cancel was called on the currentShutdownTaskFuture to signal a forced timeout         // we hit a timeout, so set the flag         timeoutOccurred.set(true).         // timeout then cancel the task         currentShutdownTaskFuture.cancel(true).         // signal we are forcing shutdown now, since timeout occurred         this.forceShutdown = forceShutdown.         // if set, stop processing and return false to indicate that the shutdown is aborting         if (!forceShutdown && abortAfterTimeout) {             log.warn("Timeout occurred during graceful shutdown. Aborting the shutdown now." + " Notice: some resources may still be running as graceful shutdown did not complete successfully.").             // we attempt to force shutdown so lets log the current inflight exchanges which are affected             logInflightExchanges(context, routes, isLogInflightExchangesOnTimeout()).             return false.         } else {             if (forceShutdown || shutdownNowOnTimeout) {                 log.warn("Timeout occurred during graceful shutdown. Forcing the routes to be shutdown now." + " Notice: some resources may still be running as graceful shutdown did not complete successfully.").                 // we attempt to force shutdown so lets log the current inflight exchanges which are affected                 logInflightExchanges(context, routes, isLogInflightExchangesOnTimeout()).                 // force the routes to shutdown now                 shutdownRoutesNow(routesOrdered).                 // now the route consumers has been shutdown, then prepare route services for shutdown now (forced)                 for (RouteStartupOrder order : routes) {                     for (Service service : order.getServices()) {                         prepareShutdown(service, false, true, true, isSuppressLoggingOnTimeout()).                     }                 }             } else {                 log.warn("Timeout occurred during graceful shutdown. Will ignore shutting down the remainder routes." + " Notice: some resources may still be running as graceful shutdown did not complete successfully.").                 logInflightExchanges(context, routes, isLogInflightExchangesOnTimeout()).             }         }     } finally {         currentShutdownTaskFuture = null.     }     // convert to seconds as its easier to read than a big milli seconds number     long seconds = TimeUnit.SECONDS.convert(watch.taken(), TimeUnit.MILLISECONDS).     log.info("Graceful shutdown of {} routes completed in {} seconds", routesOrdered.size(), seconds).     return true. }
false;public;1;4;;@Override public boolean forceShutdown(Service service) {     return forceShutdown. }
false;public;0;4;;@Override public boolean hasTimeoutOccurred() {     return timeoutOccurred.get(). }
false;public;1;6;;public void setTimeout(long timeout) {     if (timeout <= 0) {         throw new IllegalArgumentException("Timeout must be a positive value").     }     this.timeout = timeout. }
false;public;0;3;;public long getTimeout() {     return timeout. }
false;public;1;3;;public void setTimeUnit(TimeUnit timeUnit) {     this.timeUnit = timeUnit. }
false;public;0;3;;public TimeUnit getTimeUnit() {     return timeUnit. }
false;public;1;3;;public void setShutdownNowOnTimeout(boolean shutdownNowOnTimeout) {     this.shutdownNowOnTimeout = shutdownNowOnTimeout. }
false;public;0;3;;public boolean isShutdownNowOnTimeout() {     return shutdownNowOnTimeout. }
false;public;0;3;;public boolean isShutdownRoutesInReverseOrder() {     return shutdownRoutesInReverseOrder. }
false;public;1;3;;public void setShutdownRoutesInReverseOrder(boolean shutdownRoutesInReverseOrder) {     this.shutdownRoutesInReverseOrder = shutdownRoutesInReverseOrder. }
false;public;0;3;;public boolean isSuppressLoggingOnTimeout() {     return suppressLoggingOnTimeout. }
false;public;1;3;;public void setSuppressLoggingOnTimeout(boolean suppressLoggingOnTimeout) {     this.suppressLoggingOnTimeout = suppressLoggingOnTimeout. }
false;public;0;3;;public boolean isLogInflightExchangesOnTimeout() {     return logInflightExchangesOnTimeout. }
false;public;1;3;;public void setLogInflightExchangesOnTimeout(boolean logInflightExchangesOnTimeout) {     this.logInflightExchangesOnTimeout = logInflightExchangesOnTimeout. }
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;1;3;;public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;0;3;;public Future<?> getCurrentShutdownTaskFuture() {     return currentShutdownTaskFuture. }
true;protected;1;17;/**  * Shutdown all the consumers immediately.  *  * @param routes the routes to shutdown  */ ;/**  * Shutdown all the consumers immediately.  *  * @param routes the routes to shutdown  */ protected void shutdownRoutesNow(List<RouteStartupOrder> routes) {     for (RouteStartupOrder order : routes) {         // set the route to shutdown as fast as possible by stopping after         // it has completed its current task         ShutdownRunningTask current = order.getRoute().getRouteContext().getShutdownRunningTask().         if (current != ShutdownRunningTask.CompleteCurrentTaskOnly) {             log.debug("Changing shutdownRunningTask from {} to " + ShutdownRunningTask.CompleteCurrentTaskOnly + " on route {} to shutdown faster", current, order.getRoute().getId()).             order.getRoute().getRouteContext().setShutdownRunningTask(ShutdownRunningTask.CompleteCurrentTaskOnly).         }         for (Consumer consumer : order.getInputs()) {             shutdownNow(consumer).         }     } }
true;protected;1;5;/**  * Shutdown all the consumers immediately.  *  * @param consumers the consumers to shutdown  */ ;/**  * Shutdown all the consumers immediately.  *  * @param consumers the consumers to shutdown  */ protected void shutdownNow(List<Consumer> consumers) {     for (Consumer consumer : consumers) {         shutdownNow(consumer).     } }
true;protected;1;14;/**  * Shutdown the consumer immediately.  *  * @param consumer the consumer to shutdown  */ ;/**  * Shutdown the consumer immediately.  *  * @param consumer the consumer to shutdown  */ protected void shutdownNow(Consumer consumer) {     log.trace("Shutting down: {}", consumer).     // allow us to do custom work before delegating to service helper     try {         ServiceHelper.stopService(consumer).     } catch (Throwable e) {         log.warn("Error occurred while shutting down route: " + consumer + ". This exception will be ignored.", e).         // fire event         EventHelper.notifyServiceStopFailure(consumer.getEndpoint().getCamelContext(), consumer, e).     }     log.trace("Shutdown complete for: {}", consumer). }
true;protected;1;14;/**  * Suspends/stops the consumer immediately.  *  * @param consumer the consumer to suspend  */ ;/**  * Suspends/stops the consumer immediately.  *  * @param consumer the consumer to suspend  */ protected void suspendNow(Consumer consumer) {     log.trace("Suspending: {}", consumer).     // allow us to do custom work before delegating to service helper     try {         ServiceHelper.suspendService(consumer).     } catch (Throwable e) {         log.warn("Error occurred while suspending route: " + consumer + ". This exception will be ignored.", e).         // fire event         EventHelper.notifyServiceStopFailure(consumer.getEndpoint().getCamelContext(), consumer, e).     }     log.trace("Suspend complete for: {}", consumer). }
false;private;0;7;;private ExecutorService getExecutorService() {     if (executor == null) {         // use a thread pool that allow to terminate idle threads so they do not hang around forever         executor = camelContext.getExecutorServiceManager().newThreadPool(this, "ShutdownTask", 0, 1).     }     return executor. }
false;protected;0;7;;@Override protected void doStart() throws Exception {     ObjectHelper.notNull(camelContext, "CamelContext").     // reset option     forceShutdown = false.     timeoutOccurred.set(false). }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
false;protected;0;9;;@Override protected void doShutdown() throws Exception {     if (executor != null) {         // force shutting down as we are shutting down Camel         camelContext.getExecutorServiceManager().shutdownNow(executor).         // should clear executor so we can restart by creating a new thread pool         executor = null.     } }
true;private;5;25;/**  * Prepares the services for shutdown, by invoking the {@link ShutdownPrepared#prepareShutdown(boolean, boolean)} method  * on the service if it implement this interface.  *  * @param service the service  * @param forced  whether to force shutdown  * @param includeChildren whether to prepare the child of the service as well  */ ;/**  * Prepares the services for shutdown, by invoking the {@link ShutdownPrepared#prepareShutdown(boolean, boolean)} method  * on the service if it implement this interface.  *  * @param service the service  * @param forced  whether to force shutdown  * @param includeChildren whether to prepare the child of the service as well  */ private void prepareShutdown(Service service, boolean suspendOnly, boolean forced, boolean includeChildren, boolean suppressLogging) {     Set<Service> list.     if (includeChildren) {         // include error handlers as we want to prepare them for shutdown as well         list = ServiceHelper.getChildServices(service, true).     } else {         list = new LinkedHashSet<>(1).         list.add(service).     }     for (Service child : list) {         if (child instanceof ShutdownPrepared) {             try {                 log.trace("Preparing {} shutdown on {}", forced ? "forced" : "", child).                 ((ShutdownPrepared) child).prepareShutdown(suspendOnly, forced).             } catch (Exception e) {                 if (suppressLogging) {                     log.trace("Error during prepare shutdown on " + child + ". This exception will be ignored.", e).                 } else {                     log.warn("Error during prepare shutdown on " + child + ". This exception will be ignored.", e).                 }             }         }     } }
false;;0;3;;Route getRoute() {     return route. }
false;;0;3;;Consumer getConsumer() {     return consumer. }
false;public;0;161;;public void run() {     // the strategy in this run method is to     // 1) go over the routes and shutdown those routes which can be shutdown asap     // some routes will be deferred to shutdown at the end, as they are needed     // by other routes so they can complete their tasks     // 2) wait until all inflight and pending exchanges has been completed     // 3) shutdown the deferred routes     log.debug("There are {} routes to {}", routes.size(), suspendOnly ? "suspend" : "shutdown").     // list of deferred consumers to shutdown when all exchanges has been completed routed     // and thus there are no more inflight exchanges so they can be safely shutdown at that time     List<ShutdownDeferredConsumer> deferredConsumers = new ArrayList<>().     for (RouteStartupOrder order : routes) {         ShutdownRoute shutdownRoute = order.getRoute().getRouteContext().getShutdownRoute().         ShutdownRunningTask shutdownRunningTask = order.getRoute().getRouteContext().getShutdownRunningTask().         if (log.isTraceEnabled()) {             log.trace("{}{} with options [{},{}]", suspendOnly ? "Suspending route: " : "Shutting down route: ", order.getRoute().getId(), shutdownRoute, shutdownRunningTask).         }         for (Consumer consumer : order.getInputs()) {             boolean suspend = false.             // assume we should shutdown if we are not deferred             boolean shutdown = shutdownRoute != ShutdownRoute.Defer.             if (shutdown) {                 // if a consumer is suspendable then prefer to use that and then shutdown later                 if (consumer instanceof ShutdownAware) {                     shutdown = !((ShutdownAware) consumer).deferShutdown(shutdownRunningTask).                 }                 if (shutdown && consumer instanceof Suspendable) {                     // we prefer to suspend over shutdown                     suspend = true.                 }             }             // log at info level when a route has been shutdown (otherwise log at debug level to not be too noisy)             if (suspend) {                 // only suspend it and then later shutdown it                 suspendNow(consumer).                 // add it to the deferred list so the route will be shutdown later                 deferredConsumers.add(new ShutdownDeferredConsumer(order.getRoute(), consumer)).                 log.debug("Route: {} suspended and shutdown deferred, was consuming from: {}", order.getRoute().getId(), order.getRoute().getEndpoint()).             } else if (shutdown) {                 shutdownNow(consumer).                 log.info("Route: {} shutdown complete, was consuming from: {}", order.getRoute().getId(), order.getRoute().getEndpoint()).             } else {                 // we will stop it later, but for now it must run to be able to help all inflight messages                 // be safely completed                 deferredConsumers.add(new ShutdownDeferredConsumer(order.getRoute(), consumer)).                 log.debug("Route: " + order.getRoute().getId() + (suspendOnly ? " shutdown deferred." : " suspension deferred.")).             }         }     }     // notify the services we intend to shutdown     for (RouteStartupOrder order : routes) {         for (Service service : order.getServices()) {             // skip the consumer as we handle that specially             if (service instanceof Consumer) {                 continue.             }             prepareShutdown(service, suspendOnly, false, true, false).         }     }     // wait till there are no more pending and inflight messages     boolean done = false.     long loopDelaySeconds = 1.     long loopCount = 0.     while (!done && !timeoutOccurred.get()) {         int size = 0.         // number of inflights per route         final Map<String, Integer> routeInflight = new LinkedHashMap<>().         for (RouteStartupOrder order : routes) {             int inflight = context.getInflightRepository().size(order.getRoute().getId()).             inflight += getPendingInflightExchanges(order).             if (inflight > 0) {                 String routeId = order.getRoute().getId().                 routeInflight.put(routeId, inflight).                 size += inflight.                 log.trace("{} inflight and pending exchanges for route: {}", inflight, routeId).             }         }         if (size > 0) {             try {                 // build a message with inflight per route                 CollectionStringBuffer csb = new CollectionStringBuffer().                 for (Map.Entry<String, Integer> entry : routeInflight.entrySet()) {                     String row = String.format("%s = %s", entry.getKey(), entry.getValue()).                     csb.append(row).                 }                 String msg = "Waiting as there are still " + size + " inflight and pending exchanges to complete, timeout in " + (TimeUnit.SECONDS.convert(timeout, timeUnit) - (loopCount++ * loopDelaySeconds)) + " seconds.".                 msg += " Inflights per route: [" + csb.toString() + "]".                 log.info(msg).                 // log verbose if DEBUG logging is enabled                 logInflightExchanges(context, routes, logInflightExchangesOnTimeout).                 Thread.sleep(loopDelaySeconds * 1000).             } catch (InterruptedException e) {                 if (abortAfterTimeout) {                     log.warn("Interrupted while waiting during graceful shutdown, will abort.").                     return.                 } else {                     log.warn("Interrupted while waiting during graceful shutdown, will force shutdown now.").                     break.                 }             }         } else {             done = true.         }     }     // prepare for shutdown     for (ShutdownDeferredConsumer deferred : deferredConsumers) {         Consumer consumer = deferred.getConsumer().         if (consumer instanceof ShutdownAware) {             log.trace("Route: {} preparing to shutdown.", deferred.getRoute().getId()).             boolean forced = context.getShutdownStrategy().forceShutdown(consumer).             boolean suppress = context.getShutdownStrategy().isSuppressLoggingOnTimeout().             prepareShutdown(consumer, suspendOnly, forced, false, suppress).             log.debug("Route: {} preparing to shutdown complete.", deferred.getRoute().getId()).         }     }     // now all messages has been completed then stop the deferred consumers     for (ShutdownDeferredConsumer deferred : deferredConsumers) {         Consumer consumer = deferred.getConsumer().         if (suspendOnly) {             suspendNow(consumer).             log.info("Route: {} suspend complete, was consuming from: {}", deferred.getRoute().getId(), deferred.getConsumer().getEndpoint()).         } else {             shutdownNow(consumer).             log.info("Route: {} shutdown complete, was consuming from: {}", deferred.getRoute().getId(), deferred.getConsumer().getEndpoint()).         }     }     // now the route consumers has been shutdown, then prepare route services for shutdown     for (RouteStartupOrder order : routes) {         for (Service service : order.getServices()) {             boolean forced = context.getShutdownStrategy().forceShutdown(service).             boolean suppress = context.getShutdownStrategy().isSuppressLoggingOnTimeout().             prepareShutdown(service, suspendOnly, forced, true, suppress).         }     } }
true;protected,static;1;17;/**  * Calculates the total number of inflight exchanges for the given route  *  * @param order the route  * @return number of inflight exchanges  */ ;/**  * Calculates the total number of inflight exchanges for the given route  *  * @param order the route  * @return number of inflight exchanges  */ protected static int getPendingInflightExchanges(RouteStartupOrder order) {     int inflight = 0.     // inflight exchanges (such as the aggregator)     for (Service service : order.getServices()) {         Set<Service> children = ServiceHelper.getChildServices(service).         for (Service child : children) {             if (child instanceof ShutdownAware) {                 inflight += ((ShutdownAware) child).getPendingExchangesSize().             }         }     }     return inflight. }
true;protected;3;47;/**  * Logs information about the inflight exchanges  *  * @param infoLevel <tt>true</tt> to log at INFO level, <tt>false</tt> to log at DEBUG level  */ ;/**  * Logs information about the inflight exchanges  *  * @param infoLevel <tt>true</tt> to log at INFO level, <tt>false</tt> to log at DEBUG level  */ protected void logInflightExchanges(CamelContext camelContext, List<RouteStartupOrder> routes, boolean infoLevel) {     // check if we need to log     if (!infoLevel && !log.isDebugEnabled()) {         return.     }     Collection<InflightRepository.InflightExchange> inflights = camelContext.getInflightRepository().browse().     int size = inflights.size().     if (size == 0) {         return.     }     // filter so inflight must start from any of the routes     Set<String> routeIds = new HashSet<>().     for (RouteStartupOrder route : routes) {         routeIds.add(route.getRoute().getId()).     }     Collection<InflightRepository.InflightExchange> filtered = new ArrayList<>().     for (InflightRepository.InflightExchange inflight : inflights) {         String routeId = inflight.getExchange().getFromRouteId().         if (routeIds.contains(routeId)) {             filtered.add(inflight).         }     }     size = filtered.size().     if (size == 0) {         return.     }     StringBuilder sb = new StringBuilder("There are " + size + " inflight exchanges:").     for (InflightRepository.InflightExchange inflight : filtered) {         sb.append("\n\tInflightExchange: [exchangeId=").append(inflight.getExchange().getExchangeId()).append(", fromRouteId=").append(inflight.getExchange().getFromRouteId()).append(", atRouteId=").append(inflight.getAtRouteId()).append(", nodeId=").append(inflight.getNodeId()).append(", elapsed=").append(inflight.getElapsed()).append(", duration=").append(inflight.getDuration()).append("]").     }     if (infoLevel) {         log.info(sb.toString()).     } else {         log.debug(sb.toString()).     } }
