commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected void doStart() throws Exception {     ServiceHelper.startService(processor). }
false;protected;0;4;;@Override protected void doStop() throws Exception {     ServiceHelper.stopService(processor). }
false;protected;0;7;;@Override protected void doShutdown() throws Exception {     ServiceHelper.stopAndShutdownService(processor).     if (shutdownExecutorService) {         getCamelContext().getExecutorServiceManager().shutdownNow(executorService).     } }
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setId(String id) {     this.id = id. }
false;public;2;13;;public boolean process(Exchange exchange, AsyncCallback callback) {     if (processor != null) {         // register callback         if (afterConsumer) {             exchange.getUnitOfWork().addSynchronization(new OnCompletionSynchronizationAfterConsumer()).         } else {             exchange.getUnitOfWork().addSynchronization(new OnCompletionSynchronizationBeforeConsumer()).         }     }     callback.done(true).     return true. }
false;protected;0;4;;protected boolean isCreateCopy() {     // we need to create a correlated copy if we run in parallel mode or is in after consumer mode (as the UoW would be done on the original exchange otherwise)     return executorService != null || afterConsumer. }
true;protected,static;2;44;/**  * Processes the exchange by the processors  *  * @param processor the processor  * @param exchange the exchange  */ ;/**  * Processes the exchange by the processors  *  * @param processor the processor  * @param exchange the exchange  */ protected static void doProcess(Processor processor, Exchange exchange) {     // must remember some properties which we cannot use during onCompletion processing     // as otherwise we may cause issues     // but keep the caused exception stored as a property (Exchange.EXCEPTION_CAUGHT) on the exchange     Object stop = exchange.removeProperty(Exchange.ROUTE_STOP).     Object failureHandled = exchange.removeProperty(Exchange.FAILURE_HANDLED).     Object errorhandlerHandled = exchange.removeProperty(Exchange.ERRORHANDLER_HANDLED).     Object rollbackOnly = exchange.removeProperty(Exchange.ROLLBACK_ONLY).     Object rollbackOnlyLast = exchange.removeProperty(Exchange.ROLLBACK_ONLY_LAST).     // and we should not be regarded as exhausted as we are in a onCompletion block     Object exhausted = exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED).     Exception cause = exchange.getException().     exchange.setException(null).     try {         processor.process(exchange).     } catch (Exception e) {         exchange.setException(e).     } finally {         // restore the options         if (stop != null) {             exchange.setProperty(Exchange.ROUTE_STOP, stop).         }         if (failureHandled != null) {             exchange.setProperty(Exchange.FAILURE_HANDLED, failureHandled).         }         if (errorhandlerHandled != null) {             exchange.setProperty(Exchange.ERRORHANDLER_HANDLED, errorhandlerHandled).         }         if (rollbackOnly != null) {             exchange.setProperty(Exchange.ROLLBACK_ONLY, rollbackOnly).         }         if (rollbackOnlyLast != null) {             exchange.setProperty(Exchange.ROLLBACK_ONLY_LAST, rollbackOnlyLast).         }         if (exhausted != null) {             exchange.setProperty(Exchange.REDELIVERY_EXHAUSTED, exhausted).         }         if (cause != null) {             exchange.setException(cause).         }     } }
true;protected;1;32;/**  * Prepares the {@link Exchange} to send as onCompletion.  *  * @param exchange the current exchange  * @return the exchange to be routed in onComplete  */ ;/**  * Prepares the {@link Exchange} to send as onCompletion.  *  * @param exchange the current exchange  * @return the exchange to be routed in onComplete  */ protected Exchange prepareExchange(Exchange exchange) {     Exchange answer.     if (isCreateCopy()) {         // for asynchronous routing we must use a copy as we dont want it         // to cause side effects of the original exchange         // (the original thread will run in parallel)         answer = ExchangeHelper.createCorrelatedCopy(exchange, false).         if (answer.hasOut()) {             // move OUT to IN (pipes and filters)             answer.setIn(answer.getOut()).             answer.setOut(null).         }         // set MEP to InOnly as this onCompletion is a fire and forget         answer.setPattern(ExchangePattern.InOnly).     } else {         // use the exchange as-is         answer = exchange.     }     if (useOriginalBody) {         log.trace("Using the original IN message instead of current").         Message original = ExchangeHelper.getOriginalInMessage(exchange).         answer.setIn(original).     }     // add a header flag to indicate its a on completion exchange     answer.setProperty(Exchange.ON_COMPLETION, Boolean.TRUE).     return answer. }
false;public;0;4;;public int getOrder() {     // we want to be last     return Ordered.LOWEST. }
false;public;0;5;;public Exchange call() throws Exception {     log.debug("Processing onComplete: {}", copy).     doProcess(processor, copy).     return copy. }
false;public;1;28;;@Override public void onComplete(final Exchange exchange) {     if (onFailureOnly) {         return.     }     if (onWhen != null && !onWhen.matches(exchange)) {         // predicate did not match so do not route the onComplete         return.     }     // must use a copy as we dont want it to cause side effects of the original exchange     final Exchange copy = prepareExchange(exchange).     if (executorService != null) {         executorService.submit(new Callable<Exchange>() {              public Exchange call() throws Exception {                 log.debug("Processing onComplete: {}", copy).                 doProcess(processor, copy).                 return copy.             }         }).     } else {         // run without thread-pool         log.debug("Processing onComplete: {}", copy).         doProcess(processor, copy).     } }
false;public;0;7;;public Exchange call() throws Exception {     log.debug("Processing onFailure: {}", copy).     doProcess(processor, copy).     // restore exception after processing     copy.setException(original).     return null. }
false;public;1;49;;public void onFailure(final Exchange exchange) {     if (onCompleteOnly) {         return.     }     if (onWhen != null && !onWhen.matches(exchange)) {         // predicate did not match so do not route the onComplete         return.     }     // must use a copy as we dont want it to cause side effects of the original exchange     final Exchange copy = prepareExchange(exchange).     final Exception original = copy.getException().     final boolean originalFault = copy.hasOut() ? copy.getOut().isFault() : copy.getIn().isFault().     // must remove exception otherwise onFailure routing will fail as well     // the caused exception is stored as a property (Exchange.EXCEPTION_CAUGHT) on the exchange     copy.setException(null).     // must clear fault otherwise onFailure routing will fail as well     if (copy.hasOut()) {         copy.getOut().setFault(false).     } else {         copy.getIn().setFault(false).     }     if (executorService != null) {         executorService.submit(new Callable<Exchange>() {              public Exchange call() throws Exception {                 log.debug("Processing onFailure: {}", copy).                 doProcess(processor, copy).                 // restore exception after processing                 copy.setException(original).                 return null.             }         }).     } else {         // run without thread-pool         log.debug("Processing onFailure: {}", copy).         doProcess(processor, copy).         // restore exception after processing         copy.setException(original).         // restore fault after processing         if (copy.hasOut()) {             copy.getOut().setFault(originalFault).         } else {             copy.getIn().setFault(originalFault).         }     } }
false;public;0;10;;@Override public String toString() {     if (!onCompleteOnly && !onFailureOnly) {         return "onCompleteOrFailure".     } else if (onCompleteOnly) {         return "onCompleteOnly".     } else {         return "onFailureOnly".     } }
false;public;0;4;;public int getOrder() {     // we want to be last     return Ordered.LOWEST. }
false;public;0;5;;public Exchange call() throws Exception {     log.debug("Processing onAfterRoute: {}", copy).     doProcess(processor, copy).     return copy. }
false;public;2;32;;@Override public void onAfterRoute(Route route, Exchange exchange) {     if (exchange.isFailed() && onCompleteOnly) {         return.     }     if (!exchange.isFailed() && onFailureOnly) {         return.     }     if (onWhen != null && !onWhen.matches(exchange)) {         // predicate did not match so do not route the onComplete         return.     }     // must use a copy as we dont want it to cause side effects of the original exchange     final Exchange copy = prepareExchange(exchange).     if (executorService != null) {         executorService.submit(new Callable<Exchange>() {              public Exchange call() throws Exception {                 log.debug("Processing onAfterRoute: {}", copy).                 doProcess(processor, copy).                 return copy.             }         }).     } else {         // run without thread-pool         log.debug("Processing onAfterRoute: {}", copy).         doProcess(processor, copy).     } }
false;public;0;4;;@Override public String toString() {     return "onAfterRoute". }
false;public;0;4;;@Override public String toString() {     return "OnCompletionProcessor[" + processor + "]". }
false;public;0;3;;public String getTraceLabel() {     return "onCompletion". }
