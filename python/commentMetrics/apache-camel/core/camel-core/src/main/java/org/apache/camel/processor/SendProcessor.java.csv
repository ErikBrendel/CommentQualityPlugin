commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "sendTo(" + destination + ")". }
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setId(String id) {     this.id = id. }
false;public;0;6;;public String getTraceLabel() {     if (traceLabelToString == null) {         traceLabelToString = URISupport.sanitizeUri(destination.getEndpointUri()).     }     return traceLabelToString. }
false;public;0;4;;@Override public Endpoint getEndpoint() {     return destination. }
false;public;1;14;;@Override public void done(boolean doneSync) {     try {         // restore previous MEP         target.setPattern(existingPattern).         // emit event that the exchange was sent to the endpoint         if (watch != null) {             long timeTaken = watch.taken().             EventHelper.notifyExchangeSent(target.getContext(), target, destination, timeTaken).         }     } finally {         callback.done(doneSync).     } }
false;public;2;64;;public boolean process(Exchange exchange, final AsyncCallback callback) {     if (!isStarted()) {         exchange.setException(new IllegalStateException("SendProcessor has not been started: " + this)).         callback.done(true).         return true.     }     // we should preserve existing MEP so remember old MEP     // if you want to permanently to change the MEP then use .setExchangePattern in the DSL     final ExchangePattern existingPattern = exchange.getPattern().     counter++.     // if we have a producer then use that as its optimized     if (producer != null) {         final Exchange target = configureExchange(exchange, pattern).         final boolean sending = EventHelper.notifyExchangeSending(exchange.getContext(), target, destination).         // record timing for sending the exchange using the producer         StopWatch watch.         if (sending) {             watch = new StopWatch().         } else {             watch = null.         }         try {             log.debug(">>>> {} {}", destination, exchange).             return producer.process(exchange, new AsyncCallback() {                  @Override                 public void done(boolean doneSync) {                     try {                         // restore previous MEP                         target.setPattern(existingPattern).                         // emit event that the exchange was sent to the endpoint                         if (watch != null) {                             long timeTaken = watch.taken().                             EventHelper.notifyExchangeSent(target.getContext(), target, destination, timeTaken).                         }                     } finally {                         callback.done(doneSync).                     }                 }             }).         } catch (Throwable throwable) {             exchange.setException(throwable).             callback.done(true).         }         return true.     }     configureExchange(exchange, pattern).     log.debug(">>>> {} {}", destination, exchange).     // send the exchange to the destination using the producer cache for the non optimized producers     return producerCache.doInAsyncProducer(destination, exchange, callback, (producer, ex, cb) -> producer.process(ex, doneSync -> {         // restore previous MEP         exchange.setPattern(existingPattern).         // signal we are done         cb.done(doneSync).     })). }
false;public;0;3;;public Endpoint getDestination() {     return destination. }
false;public;0;3;;public ExchangePattern getPattern() {     return pattern. }
false;protected;2;11;;protected Exchange configureExchange(Exchange exchange, ExchangePattern pattern) {     // destination exchange pattern overrides pattern     if (destinationExchangePattern != null) {         exchange.setPattern(destinationExchangePattern).     } else if (pattern != null) {         exchange.setPattern(pattern).     }     // set property which endpoint we send to     exchange.setProperty(Exchange.TO_ENDPOINT, destination.getEndpointUri()).     return exchange. }
false;public;0;3;;public long getCounter() {     return counter. }
false;public;0;3;;public void reset() {     counter = 0. }
false;protected;0;30;;protected void doStart() throws Exception {     if (producerCache == null) {         // use a single producer cache as we need to only hold reference for one destination         // and use a regular HashMap as we do not want a soft reference store that may get re-claimed when low on memory         // as we want to ensure the producer is kept around, to ensure its lifecycle is fully managed,         // eg stopping the producer when we stop etc.         producerCache = new DefaultProducerCache(this, camelContext, 1).     // do not add as service as we do not want to manage the producer cache     }     ServiceHelper.startService(producerCache).     // warm up the producer by starting it so we can fail fast if there was a problem     // however must start endpoint first     ServiceHelper.startService(destination).     // this SendProcessor is used a lot in Camel (eg every .to in the route DSL) and therefore we     // want to optimize for regular producers, by using the producer directly instead of the ProducerCache.     // Only for pooled and non-singleton producers we have to use the ProducerCache as it supports these     // kind of producer better (though these kind of producer should be rare)     AsyncProducer producer = producerCache.acquireProducer(destination).     if (!producer.isSingleton()) {         // no we cannot optimize it - so release the producer back to the producer cache         // and use the producer cache for sending         producerCache.releaseProducer(destination, producer).     } else {         // yes we can optimize and use the producer directly for sending         this.producer = producer.     } }
false;protected;0;3;;protected void doStop() throws Exception {     ServiceHelper.stopService(producerCache, producer). }
false;protected;0;3;;protected void doShutdown() throws Exception {     ServiceHelper.stopAndShutdownServices(producerCache, producer). }
