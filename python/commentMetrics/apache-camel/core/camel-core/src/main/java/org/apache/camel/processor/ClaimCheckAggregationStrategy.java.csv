commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getFilter() {     return filter. }
false;public;1;3;;public void setFilter(String filter) {     this.filter = filter. }
false;public;2;113;;@Override public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {     if (newExchange == null) {         return oldExchange.     }     if (org.apache.camel.util.ObjectHelper.isEmpty(filter) || "*".equals(filter)) {         // grab everything         oldExchange.getMessage().setBody(newExchange.getMessage().getBody()).         LOG.trace("Including: body").         if (newExchange.getMessage().hasHeaders()) {             oldExchange.getMessage().getHeaders().putAll(newExchange.getMessage().getHeaders()).             LOG.trace("Including: headers").         }         if (newExchange.getMessage().hasAttachments()) {             oldExchange.getMessage().getAttachments().putAll(newExchange.getMessage().getAttachments()).             LOG.trace("Including: attachments").         }         return oldExchange.     }     // body is by default often included     if (isBodyEnabled()) {         oldExchange.getMessage().setBody(newExchange.getMessage().getBody()).         LOG.trace("Including: body").     }     // attachments is by default often included     if (isAttachmentsEnabled()) {         if (newExchange.getMessage().hasAttachments()) {             oldExchange.getMessage().getAttachments().putAll(newExchange.getMessage().getAttachments()).             LOG.trace("Including: attachments").         }     }     // headers is by default often included     if (isHeadersEnabled()) {         if (newExchange.getMessage().hasHeaders()) {             oldExchange.getMessage().getHeaders().putAll(newExchange.getMessage().getHeaders()).             LOG.trace("Including: headers").         }     }     // filter specific header if they are somehow enabled by the filter     if (hasHeaderPatterns()) {         boolean excludeOnly = isExcludeOnlyHeaderPatterns().         for (Map.Entry<String, Object> header : newExchange.getMessage().getHeaders().entrySet()) {             String key = header.getKey().             if (hasHeaderPattern(key)) {                 boolean include = isIncludedHeader(key).                 boolean exclude = isExcludedHeader(key).                 if (include) {                     LOG.trace("Including: header:{}", key).                     oldExchange.getMessage().getHeaders().put(key, header.getValue()).                 } else if (exclude) {                     LOG.trace("Excluding: header:{}", key).                 } else {                     LOG.trace("Skipping: header:{}", key).                 }             } else if (excludeOnly) {                 LOG.trace("Including: header:{}", key).                 oldExchange.getMessage().getHeaders().put(key, header.getValue()).             }         }     }     // filter body and all headers     if (org.apache.camel.util.ObjectHelper.isNotEmpty(filter)) {         Iterable<?> it = ObjectHelper.createIterable(filter, ",").         for (Object k : it) {             String part = k.toString().             if (("body".equals(part) || "+body".equals(part)) && !"-body".equals(part)) {                 oldExchange.getMessage().setBody(newExchange.getMessage().getBody()).                 LOG.trace("Including: body").             } else if (("headers".equals(part) || "+headers".equals(part)) && !"-headers".equals(part)) {                 oldExchange.getMessage().getHeaders().putAll(newExchange.getMessage().getHeaders()).                 LOG.trace("Including: headers").             }         }     }     // filter with remove (--) take precedence at the end     Iterable<?> it = ObjectHelper.createIterable(filter, ",").     for (Object k : it) {         String part = k.toString().         if ("--body".equals(part)) {             oldExchange.getMessage().setBody(null).         } else if ("--headers".equals(part)) {             oldExchange.getMessage().getHeaders().clear().         } else if (part.startsWith("--header:")) {             // pattern matching for headers, eg header:foo, header:foo*, header:(foo|bar)             String after = StringHelper.after(part, "--header:").             Iterable<?> i = ObjectHelper.createIterable(after, ",").             Set<String> toRemoveKeys = new HashSet<>().             for (Object o : i) {                 String pattern = o.toString().                 for (Map.Entry<String, Object> header : oldExchange.getMessage().getHeaders().entrySet()) {                     String key = header.getKey().                     boolean matched = PatternHelper.matchPattern(key, pattern).                     if (matched) {                         toRemoveKeys.add(key).                     }                 }             }             for (String key : toRemoveKeys) {                 LOG.trace("Removing: header:{}", key).                 oldExchange.getMessage().removeHeader(key).             }         }     }     return oldExchange. }
false;private;0;12;;private boolean hasHeaderPatterns() {     String[] parts = filter.split(",").     for (String pattern : parts) {         if (pattern.startsWith("--")) {             continue.         }         if (pattern.startsWith("header:") || pattern.startsWith("+header:") || pattern.startsWith("-header:")) {             return true.         }     }     return false. }
false;private;0;12;;private boolean isExcludeOnlyHeaderPatterns() {     String[] parts = filter.split(",").     for (String pattern : parts) {         if (pattern.startsWith("--")) {             continue.         }         if (pattern.startsWith("header:") || pattern.startsWith("+header:")) {             return false.         }     }     return true. }
false;private;1;18;;private boolean hasHeaderPattern(String key) {     String[] parts = filter.split(",").     for (String pattern : parts) {         if (pattern.startsWith("--")) {             continue.         }         String header = null.         if (pattern.startsWith("header:") || pattern.startsWith("+header:")) {             header = StringHelper.after(pattern, "header:").         } else if (pattern.startsWith("-header:")) {             header = StringHelper.after(pattern, "-header:").         }         if (header != null && PatternHelper.matchPattern(key, header)) {             return true.         }     }     return false. }
false;private;1;15;;private boolean isIncludedHeader(String key) {     String[] parts = filter.split(",").     for (String pattern : parts) {         if (pattern.startsWith("--")) {             continue.         }         if (pattern.startsWith("header:") || pattern.startsWith("+header:")) {             pattern = StringHelper.after(pattern, "header:").         }         if (PatternHelper.matchPattern(key, pattern)) {             return true.         }     }     return false. }
false;private;1;15;;private boolean isExcludedHeader(String key) {     String[] parts = filter.split(",").     for (String pattern : parts) {         if (pattern.startsWith("--")) {             continue.         }         if (pattern.startsWith("-header:")) {             pattern = StringHelper.after(pattern, "-header:").         }         if (PatternHelper.matchPattern(key, pattern)) {             return true.         }     }     return false. }
false;private;0;19;;private boolean isBodyEnabled() {     // body is always enabled unless excluded     String[] parts = filter.split(",").     boolean onlyExclude = true.     for (String pattern : parts) {         if (pattern.startsWith("--")) {             continue.         }         if ("body".equals(pattern) || "+body".equals(pattern)) {             return true.         } else if ("-body".equals(pattern)) {             return false.         }         onlyExclude &= pattern.startsWith("-").     }     // body is enabled if we only have exclude patterns     return onlyExclude. }
false;private;0;19;;private boolean isAttachmentsEnabled() {     // attachments is always enabled unless excluded     String[] parts = filter.split(",").     boolean onlyExclude = true.     for (String pattern : parts) {         if (pattern.startsWith("--")) {             continue.         }         if ("attachments".equals(pattern) || "+attachments".equals(pattern)) {             return true.         } else if ("-attachments".equals(pattern)) {             return false.         }         onlyExclude &= pattern.startsWith("-").     }     // attachments is enabled if we only have exclude patterns     return onlyExclude. }
false;private;0;23;;private boolean isHeadersEnabled() {     // headers may be enabled unless excluded     String[] parts = filter.split(",").     boolean onlyExclude = true.     for (String pattern : parts) {         if (pattern.startsWith("--")) {             continue.         }         // if there is individual header filters then we cannot rely on this         if (pattern.startsWith("header:") || pattern.startsWith("+header:") || pattern.startsWith("-header:")) {             return false.         }         if ("headers".equals(pattern) || "+headers".equals(pattern)) {             return true.         } else if ("-headers".equals(pattern)) {             return false.         }         onlyExclude &= pattern.startsWith("-").     }     // headers is enabled if we only have exclude patterns     return onlyExclude. }
