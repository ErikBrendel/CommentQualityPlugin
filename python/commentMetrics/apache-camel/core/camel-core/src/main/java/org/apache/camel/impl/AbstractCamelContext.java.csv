commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Set<String> initialValue() {     return new HashSet<>(). }
false;public;0;9;;public void doInit() {     // setup management first since end users may use it to add event notifiers     // using the management strategy before the CamelContext has been started     setupManagement(null).     // Call all registered trackers with this context     // Note, this may use a partially constructed object     CamelContextTracker.notifyContextCreated(this). }
false;public;1;3;;public <T extends CamelContext> T adapt(Class<T> type) {     return type.cast(this). }
false;public;1;9;;@Override public <T> T getExtension(Class<T> type) {     Object extension = extensions.get(type).     if (extension instanceof Supplier) {         extension = ((Supplier) extension).get().         setExtension(type, (T) extension).     }     return (T) extension. }
false;public;2;8;;@Override public <T> void setExtension(Class<T> type, T module) {     try {         extensions.put(type, doAddService(module)).     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;public;2;3;;public <T> void setDefaultExtension(Class<T> type, Supplier<T> module) {     extensions.putIfAbsent(type, module). }
false;public;0;3;;public boolean isVetoStarted() {     return vetoStated.get(). }
false;public;0;3;;public Initialization getInitialization() {     return initialization. }
false;public;1;3;;public void setInitialization(Initialization initialization) {     this.initialization = initialization. }
false;public;0;3;;public String getName() {     return getNameStrategy().getName(). }
true;public;1;4;/**  * Sets the name of the this context.  *  * @param name the name  */ ;/**  * Sets the name of the this context.  *  * @param name the name  */ public void setName(String name) {     // use an explicit name strategy since an explicit name was provided to be used     setNameStrategy(new ExplicitCamelContextNameStrategy(name)). }
false;public;0;10;;public CamelContextNameStrategy getNameStrategy() {     if (nameStrategy == null) {         synchronized (lock) {             if (nameStrategy == null) {                 setNameStrategy(createCamelContextNameStrategy()).             }         }     }     return nameStrategy. }
false;public;1;3;;public void setNameStrategy(CamelContextNameStrategy nameStrategy) {     this.nameStrategy = doAddService(nameStrategy). }
false;public;0;10;;public ManagementNameStrategy getManagementNameStrategy() {     if (managementNameStrategy == null) {         synchronized (lock) {             if (managementNameStrategy == null) {                 setManagementNameStrategy(createManagementNameStrategy()).             }         }     }     return managementNameStrategy. }
false;public;1;3;;public void setManagementNameStrategy(ManagementNameStrategy managementNameStrategy) {     this.managementNameStrategy = doAddService(managementNameStrategy). }
false;public;0;3;;public String getManagementName() {     return managementName. }
false;public;1;3;;public void setManagementName(String managementName) {     this.managementName = managementName. }
false;public;1;3;;public Component hasComponent(String componentName) {     return components.get(componentName). }
false;public;2;9;;public void addComponent(String componentName, final Component component) {     ObjectHelper.notNull(component, "component").     component.setCamelContext(this).     Component oldValue = components.putIfAbsent(componentName, component).     if (oldValue != null) {         throw new IllegalArgumentException("Cannot add component as its already previously added: " + componentName).     }     postInitComponent(componentName, component). }
false;private;2;10;;private void postInitComponent(String componentName, final Component component) {     for (LifecycleStrategy strategy : lifecycleStrategies) {         strategy.onComponentAdd(componentName, component).     }     // keep reference to properties component up to date     if (component instanceof PropertiesComponent && "properties".equals(componentName)) {         propertiesComponent = (PropertiesComponent) component.     } }
false;public;1;3;;public Component getComponent(String name) {     return getComponent(name, autoCreateComponents, true). }
false;public;2;3;;public Component getComponent(String name, boolean autoCreateComponents) {     return getComponent(name, autoCreateComponents, true). }
false;public;1;5;;@Override public Component apply(String comp) {     created.set(true).     return AbstractCamelContext.this.initComponent(name, autoCreateComponents). }
false;public;3;40;;public Component getComponent(String name, boolean autoCreateComponents, boolean autoStart) {     init().     // that the initComponent has triggered a new getComponent     if (componentsInCreation.get().contains(name)) {         throw new IllegalStateException("Circular dependency detected, the component " + name + " is already being created").     }     try {         // Flag used to mark a component of being created.         final AtomicBoolean created = new AtomicBoolean(false).         // atomic operation to get/create a component. Avoid global locks.         final Component component = components.computeIfAbsent(name, new Function<String, Component>() {              @Override             public Component apply(String comp) {                 created.set(true).                 return AbstractCamelContext.this.initComponent(name, autoCreateComponents).             }         }).         // that creates/start a delegated component, we may end up in a deadlock         if (component != null && created.get() && autoStart && (isStarted() || isStarting())) {             // lets start it up.             if (component instanceof Service) {                 startService((Service) component).             }         }         return component.     } catch (Exception e) {         throw new RuntimeCamelException("Cannot auto create component: " + name, e).     } finally {         // remove the reference to the component being created         componentsInCreation.get().remove(name).     } }
true;private;2;50;/**  * Function to initialize a component and auto start. Returns null if the autoCreateComponents is disabled  */ ;/**  * Function to initialize a component and auto start. Returns null if the autoCreateComponents is disabled  */ private Component initComponent(String name, boolean autoCreateComponents) {     Component component = null.     if (autoCreateComponents) {         try {             if (log.isDebugEnabled()) {                 log.debug("Using ComponentResolver: {} to resolve component with name: {}", getComponentResolver(), name).             }             // Mark the component as being created so we can detect circular             // requests.             //              // In spring apps, the component resolver may trigger a new getComponent             // because of the underlying bean factory and as the endpoints are             // registered as singleton, the spring factory creates the bean             // and then check the type so the getComponent is always triggered.             //              // Simple circular dependency:             //              // <camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">             // <route>             // <from id="twitter" uri="twitter://timeline/home?type=polling"/>             // <log message="Got ${body}"/>             // </route>             // </camelContext>             //              // Complex circular dependency:             //              // <camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">             // <route>             // <from id="log" uri="seda:test"/>             // <to id="seda" uri="log:test"/>             // </route>             // </camelContext>             //              // This would freeze the app (lock or infinite loop).             //              // See https://issues.apache.org/jira/browse/CAMEL-11225             componentsInCreation.get().add(name).             component = getComponentResolver().resolveComponent(name, this).             if (component != null) {                 component.setCamelContext(this).                 postInitComponent(name, component).             }         } catch (Exception e) {             throw new RuntimeCamelException("Cannot auto create component: " + name, e).         }     }     return component. }
false;public;2;14;;public <T extends Component> T getComponent(String name, Class<T> componentType) {     Component component = getComponent(name).     if (componentType.isInstance(component)) {         return componentType.cast(component).     } else {         String message.         if (component == null) {             message = "Did not find component given by the name: " + name.         } else {             message = "Found component of type: " + component.getClass() + " instead of expected: " + componentType.         }         throw new IllegalArgumentException(message).     } }
false;public;1;11;;public Component resolveComponent(String name) {     Component answer = hasComponent(name).     if (answer == null) {         try {             answer = getComponentResolver().resolveComponent(name, this).         } catch (Exception e) {             throw new RuntimeCamelException("Cannot resolve component: " + name, e).         }     }     return answer. }
false;public;1;18;;public Component removeComponent(String componentName) {     Component oldComponent = components.remove(componentName).     if (oldComponent != null) {         try {             stopServices(oldComponent).         } catch (Exception e) {             log.warn("Error stopping component " + oldComponent + ". This exception will be ignored.", e).         }         for (LifecycleStrategy strategy : lifecycleStrategies) {             strategy.onComponentRemove(componentName, oldComponent).         }     }     // keep reference to properties component up to date     if (oldComponent != null && "properties".equals(componentName)) {         propertiesComponent = null.     }     return oldComponent. }
false;public;0;3;;// Endpoint Management Methods // ----------------------------------------------------------------------- public EndpointRegistry<EndpointKey> getEndpointRegistry() {     return endpoints. }
false;public;0;3;;public Collection<Endpoint> getEndpoints() {     return new ArrayList<>(endpoints.values()). }
false;public;0;7;;public Map<String, Endpoint> getEndpointMap() {     Map<String, Endpoint> answer = new TreeMap<>().     for (Map.Entry<EndpointKey, Endpoint> entry : endpoints.entrySet()) {         answer.put(entry.getKey().get(), entry.getValue()).     }     return answer. }
false;public;1;3;;public Endpoint hasEndpoint(String uri) {     return endpoints.get(getEndpointKey(uri)). }
false;public;2;15;;public Endpoint addEndpoint(String uri, Endpoint endpoint) throws Exception {     Endpoint oldEndpoint.     startService(endpoint).     oldEndpoint = endpoints.remove(getEndpointKey(uri)).     for (LifecycleStrategy strategy : lifecycleStrategies) {         strategy.onEndpointAdd(endpoint).     }     addEndpointToRegistry(uri, endpoint).     if (oldEndpoint != null && oldEndpoint != endpoint) {         stopServices(oldEndpoint).     }     return oldEndpoint. }
false;public;1;3;;public void removeEndpoint(Endpoint endpoint) throws Exception {     removeEndpoints(endpoint.getEndpointUri()). }
false;public;1;30;;public Collection<Endpoint> removeEndpoints(String uri) throws Exception {     Collection<Endpoint> answer = new ArrayList<>().     Endpoint oldEndpoint = endpoints.remove(getEndpointKey(uri)).     if (oldEndpoint != null) {         answer.add(oldEndpoint).         stopServices(oldEndpoint).     } else {         for (Map.Entry<EndpointKey, Endpoint> entry : endpoints.entrySet()) {             oldEndpoint = entry.getValue().             if (EndpointHelper.matchEndpoint(this, oldEndpoint.getEndpointUri(), uri)) {                 try {                     stopServices(oldEndpoint).                 } catch (Exception e) {                     log.warn("Error stopping endpoint " + oldEndpoint + ". This exception will be ignored.", e).                 }                 answer.add(oldEndpoint).                 endpoints.remove(entry.getKey()).             }         }     }     // notify lifecycle its being removed     for (Endpoint endpoint : answer) {         for (LifecycleStrategy strategy : lifecycleStrategies) {             strategy.onEndpointRemove(endpoint).         }     }     return answer. }
false;public;1;101;;public Endpoint getEndpoint(String uri) {     init().     StringHelper.notEmpty(uri, "uri").     log.trace("Getting endpoint with uri: {}", uri).     // in case path has property placeholders then try to let property component resolve those     try {         uri = resolvePropertyPlaceholders(uri).     } catch (Exception e) {         throw new ResolveEndpointFailedException(uri, e).     }     final String rawUri = uri.     // normalize uri so we can do endpoint hits with minor mistakes and parameters is not in the same order     uri = normalizeEndpointUri(uri).     log.trace("Getting endpoint with raw uri: {}, normalized uri: {}", rawUri, uri).     Endpoint answer.     String scheme = null.     // use optimized method to get the endpoint uri     EndpointKey key = getEndpointKeyPreNormalized(uri).     answer = endpoints.get(key).     if (answer == null) {         try {             // Use the URI prefix to find the component.             String[] splitURI = StringHelper.splitOnCharacter(uri, ":", 2).             if (splitURI[1] != null) {                 scheme = splitURI[0].                 log.trace("Endpoint uri: {} is from component with name: {}", uri, scheme).                 Component component = getComponent(scheme).                 // Ask the component to resolve the endpoint.                 if (component != null) {                     log.trace("Creating endpoint from uri: {} using component: {}", uri, component).                     // Have the component create the endpoint if it can.                     if (component.useRawUri()) {                         answer = component.createEndpoint(rawUri).                     } else {                         answer = component.createEndpoint(uri).                     }                     if (answer != null && log.isDebugEnabled()) {                         log.debug("{} converted to endpoint: {} by component: {}", URISupport.sanitizeUri(uri), answer, component).                     }                 }             }             if (answer == null) {                 // no component then try in registry and elsewhere                 answer = createEndpoint(uri).                 log.trace("No component to create endpoint from uri: {} fallback lookup in registry -> {}", uri, answer).             }             if (answer == null && splitURI[1] == null) {                 // the uri has no context-path which is rare and it was not referring to an endpoint in the registry                 // so try to see if it can be created by a component                 int pos = uri.indexOf('?').                 String componentName = pos > 0 ? uri.substring(0, pos) : uri.                 Component component = getComponent(componentName).                 // Ask the component to resolve the endpoint.                 if (component != null) {                     log.trace("Creating endpoint from uri: {} using component: {}", uri, component).                     // Have the component create the endpoint if it can.                     if (component.useRawUri()) {                         answer = component.createEndpoint(rawUri).                     } else {                         answer = component.createEndpoint(uri).                     }                     if (answer != null && log.isDebugEnabled()) {                         log.debug("{} converted to endpoint: {} by component: {}", URISupport.sanitizeUri(uri), answer, component).                     }                 }             }             if (answer != null) {                 addService(answer).                 answer = addEndpointToRegistry(uri, answer).             }         } catch (Exception e) {             throw new ResolveEndpointFailedException(uri, e).         }     }     // unknown scheme     if (answer == null && scheme != null) {         throw new ResolveEndpointFailedException(uri, "No component found with scheme: " + scheme).     }     return answer. }
false;public;2;15;;public <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType) {     Endpoint endpoint = getEndpoint(name).     if (endpoint == null) {         throw new NoSuchEndpointException(name).     }     if (endpoint instanceof InterceptSendToEndpoint) {         endpoint = ((InterceptSendToEndpoint) endpoint).getOriginalEndpoint().     }     if (endpointType.isInstance(endpoint)) {         return endpointType.cast(endpoint).     } else {         throw new IllegalArgumentException("The endpoint is not of type: " + endpointType + " but is: " + endpoint.getClass().getCanonicalName()).     } }
false;public;1;13;;public void addRegisterEndpointCallback(EndpointStrategy strategy) {     if (!endpointStrategies.contains(strategy)) {         // let it be invoked for already registered endpoints so it can catch-up.         endpointStrategies.add(strategy).         for (Endpoint endpoint : getEndpoints()) {             Endpoint newEndpoint = strategy.registerEndpoint(endpoint.getEndpointUri(), endpoint).             if (newEndpoint != null) {                 // put will replace existing endpoint with the new endpoint                 endpoints.put(getEndpointKey(endpoint.getEndpointUri()), newEndpoint).             }         }     } }
true;protected;2;12;/**  * Strategy to add the given endpoint to the internal endpoint registry  *  * @param uri      uri of the endpoint  * @param endpoint the endpoint to add  * @return the added endpoint  */ ;/**  * Strategy to add the given endpoint to the internal endpoint registry  *  * @param uri      uri of the endpoint  * @param endpoint the endpoint to add  * @return the added endpoint  */ protected Endpoint addEndpointToRegistry(String uri, Endpoint endpoint) {     StringHelper.notEmpty(uri, "uri").     ObjectHelper.notNull(endpoint, "endpoint").     // as this allows to intercept endpoints etc.     for (EndpointStrategy strategy : endpointStrategies) {         endpoint = strategy.registerEndpoint(uri, endpoint).     }     endpoints.put(getEndpointKey(uri, endpoint), endpoint).     return endpoint. }
true;protected,static;1;8;/**  * Normalize uri so we can do endpoint hits with minor mistakes and parameters is not in the same order.  *  * @param uri the uri  * @return normalized uri  * @throws ResolveEndpointFailedException if uri cannot be normalized  */ ;/**  * Normalize uri so we can do endpoint hits with minor mistakes and parameters is not in the same order.  *  * @param uri the uri  * @return normalized uri  * @throws ResolveEndpointFailedException if uri cannot be normalized  */ protected static String normalizeEndpointUri(String uri) {     try {         uri = URISupport.normalizeUri(uri).     } catch (Exception e) {         throw new ResolveEndpointFailedException(uri, e).     }     return uri. }
true;protected;1;3;/**  * Gets the endpoint key to use for lookup or whe adding endpoints to the {@link DefaultEndpointRegistry}  *  * @param uri the endpoint uri  * @return the key  */ ;/**  * Gets the endpoint key to use for lookup or whe adding endpoints to the {@link DefaultEndpointRegistry}  *  * @param uri the endpoint uri  * @return the key  */ protected EndpointKey getEndpointKey(String uri) {     return new EndpointKey(uri). }
true;protected;1;3;/**  * Gets the endpoint key to use for lookup or whe adding endpoints to the {@link DefaultEndpointRegistry}  *  * @param uri the endpoint uri which is pre normalized  * @return the key  */ ;/**  * Gets the endpoint key to use for lookup or whe adding endpoints to the {@link DefaultEndpointRegistry}  *  * @param uri the endpoint uri which is pre normalized  * @return the key  */ protected EndpointKey getEndpointKeyPreNormalized(String uri) {     return new EndpointKey(uri, true). }
true;protected;2;8;/**  * Gets the endpoint key to use for lookup or whe adding endpoints to the {@link DefaultEndpointRegistry}  *  * @param uri      the endpoint uri  * @param endpoint the endpoint  * @return the key  */ ;/**  * Gets the endpoint key to use for lookup or whe adding endpoints to the {@link DefaultEndpointRegistry}  *  * @param uri      the endpoint uri  * @param endpoint the endpoint  * @return the key  */ protected EndpointKey getEndpointKey(String uri, Endpoint endpoint) {     if (endpoint != null && !endpoint.isSingleton()) {         int counter = endpointKeyCounter.incrementAndGet().         return new EndpointKey(uri + ":" + counter).     } else {         return new EndpointKey(uri).     } }
false;public;1;5;;// Route Management Methods // ----------------------------------------------------------------------- @Override public void setRouteController(RouteController routeController) {     this.routeController = routeController.     doAddService(routeController). }
false;public;0;11;;@Override public RouteController getRouteController() {     if (routeController == null) {         synchronized (lock) {             if (routeController == null) {                 setRouteController(createRouteController()).             }         }     }     return routeController. }
false;public;0;3;;public List<RouteStartupOrder> getRouteStartupOrder() {     return routeStartupOrder. }
false;public;0;10;;public List<Route> getRoutes() {     // lets return a copy of the collection as objects are removed later when services are stopped     if (routes.isEmpty()) {         return Collections.emptyList().     } else {         synchronized (routes) {             return new ArrayList<>(routes).         }     } }
false;public;1;10;;public Route getRoute(String id) {     if (id != null) {         for (Route route : getRoutes()) {             if (route.getId().equals(id)) {                 return route.             }         }     }     return null. }
false;public;1;9;;public Processor getProcessor(String id) {     for (Route route : getRoutes()) {         List<Processor> list = route.filter(id).         if (list.size() == 1) {             return list.get(0).         }     }     return null. }
false;public;2;7;;public <T extends Processor> T getProcessor(String id, Class<T> type) {     Processor answer = getProcessor(id).     if (answer != null) {         return type.cast(answer).     }     return null. }
false;public;1;12;;public ProcessorDefinition getProcessorDefinition(String id) {     for (RouteDefinition route : getRouteDefinitions()) {         Iterator<ProcessorDefinition> it = ProcessorDefinitionHelper.filterTypeInOutputs(route.getOutputs(), ProcessorDefinition.class).         while (it.hasNext()) {             ProcessorDefinition proc = it.next().             if (id.equals(proc.getId())) {                 return proc.             }         }     }     return null. }
false;public;2;7;;public <T extends ProcessorDefinition> T getProcessorDefinition(String id, Class<T> type) {     ProcessorDefinition answer = getProcessorDefinition(id).     if (answer != null) {         return type.cast(answer).     }     return null. }
false;;1;5;;void removeRouteCollection(Collection<Route> routes) {     synchronized (this.routes) {         this.routes.removeAll(routes).     } }
false;;1;5;;void addRouteCollection(Collection<Route> routes) throws Exception {     synchronized (this.routes) {         this.routes.addAll(routes).     } }
false;public;1;5;;public void addRoutes(final RoutesBuilder builder) throws Exception {     init().     log.debug("Adding routes from builder: {}", builder).     doWithDefinedClassLoader(() -> builder.addRoutesToCamelContext(AbstractCamelContext.this)). }
false;public,synchronized;1;3;;public synchronized RoutesDefinition loadRoutesDefinition(InputStream is) throws Exception {     return ModelHelper.loadRoutesDefinition(this, is). }
false;public,synchronized;1;23;;public synchronized RestsDefinition loadRestsDefinition(InputStream is) throws Exception {     // load routes using JAXB     Unmarshaller unmarshaller = getModelJAXBContextFactory().newJAXBContext().createUnmarshaller().     Object result = unmarshaller.unmarshal(is).     if (result == null) {         throw new IOException("Cannot unmarshal to rests using JAXB from input stream: " + is).     }     // can either be routes or a single route     RestsDefinition answer.     if (result instanceof RestDefinition) {         RestDefinition rest = (RestDefinition) result.         answer = new RestsDefinition().         answer.getRests().add(rest).     } else if (result instanceof RestsDefinition) {         answer = (RestsDefinition) result.     } else {         throw new IllegalArgumentException("Unmarshalled object is an unsupported type: " + ObjectHelper.className(result) + " -> " + result).     }     return answer. }
false;public,synchronized;1;12;;public synchronized void addRouteDefinitions(Collection<RouteDefinition> routeDefinitions) throws Exception {     if (routeDefinitions == null || routeDefinitions.isEmpty()) {         return.     }     for (RouteDefinition routeDefinition : routeDefinitions) {         removeRouteDefinition(routeDefinition).     }     this.routeDefinitions.addAll(routeDefinitions).     if (shouldStartRoutes()) {         startRouteDefinitions(routeDefinitions).     } }
false;public;1;3;;public void addRouteDefinition(RouteDefinition routeDefinition) throws Exception {     addRouteDefinitions(Collections.singletonList(routeDefinition)). }
true;protected;1;12;/**  * Removes the route definition with the given key.  *  * @return true if one or more routes was removed  */ ;/**  * Removes the route definition with the given key.  *  * @return true if one or more routes was removed  */ protected boolean removeRouteDefinition(String key) {     boolean answer = false.     Iterator<RouteDefinition> iter = routeDefinitions.iterator().     while (iter.hasNext()) {         RouteDefinition route = iter.next().         if (route.idOrCreate(getNodeIdFactory()).equals(key)) {             iter.remove().             answer = true.         }     }     return answer. }
false;public,synchronized;1;5;;public synchronized void removeRouteDefinitions(Collection<RouteDefinition> routeDefinitions) throws Exception {     for (RouteDefinition routeDefinition : routeDefinitions) {         removeRouteDefinition(routeDefinition).     } }
false;public,synchronized;1;11;;public synchronized void removeRouteDefinition(RouteDefinition routeDefinition) throws Exception {     RouteDefinition toBeRemoved = routeDefinition.     String id = routeDefinition.getId().     if (id != null) {         // remove existing route         stopRoute(id).         removeRoute(id).         toBeRemoved = getRouteDefinition(id).     }     this.routeDefinitions.remove(toBeRemoved). }
false;public;1;7;;public ServiceStatus getRouteStatus(String key) {     RouteService routeService = routeServices.get(key).     if (routeService != null) {         return routeService.getStatus().     }     return null. }
false;public;1;24;;public void startRoute(RouteDefinition route) throws Exception {     // assign ids to the routes and validate that the id's is all unique     RouteDefinitionHelper.forceAssignIds(this, routeDefinitions).     String duplicate = RouteDefinitionHelper.validateUniqueIds(route, routeDefinitions).     if (duplicate != null) {         throw new FailedToStartRouteException(route.getId(), "duplicate id detected: " + duplicate + ". Please correct ids to be unique among all your routes.").     }     // indicate we are staring the route using this thread so     // we are able to query this if needed     isStartingRoutes.set(true).     try {         // must ensure route is prepared, before we can start it         route.prepare(this).         List<Route> routes = new ArrayList<>().         List<RouteContext> routeContexts = new RouteReifier(route).addRoutes(this, routes).         RouteService routeService = new RouteService(this, route, routeContexts, routes).         startRouteService(routeService, true).     } finally {         // we are done staring routes         isStartingRoutes.remove().     } }
false;public;0;4;;public boolean isStartingRoutes() {     Boolean answer = isStartingRoutes.get().     return answer != null && answer. }
false;public;0;4;;public boolean isSetupRoutes() {     Boolean answer = isSetupRoutes.get().     return answer != null && answer. }
false;public;0;3;;public void startAllRoutes() throws Exception {     doStartOrResumeRoutes(routeServices, true, true, false, false). }
false;public,synchronized;1;13;;public synchronized void startRoute(String routeId) throws Exception {     DefaultRouteError.reset(this, routeId).     RouteService routeService = routeServices.get(routeId).     if (routeService != null) {         try {             startRouteService(routeService, false).         } catch (Exception e) {             DefaultRouteError.set(this, routeId, Phase.START, e).             throw e.         }     } }
false;public,synchronized;1;22;;public synchronized void resumeRoute(String routeId) throws Exception {     DefaultRouteError.reset(this, routeId).     try {         if (!routeSupportsSuspension(routeId)) {             // start route if suspension is not supported             startRoute(routeId).             return.         }         RouteService routeService = routeServices.get(routeId).         if (routeService != null) {             resumeRouteService(routeService).             // must resume the route as well             Route route = getRoute(routeId).             ServiceHelper.resumeService(route).         }     } catch (Exception e) {         DefaultRouteError.set(this, routeId, Phase.RESUME, e).         throw e.     } }
false;public,synchronized;4;25;;public synchronized boolean stopRoute(String routeId, long timeout, TimeUnit timeUnit, boolean abortAfterTimeout) throws Exception {     DefaultRouteError.reset(this, routeId).     RouteService routeService = routeServices.get(routeId).     if (routeService != null) {         try {             RouteStartupOrder route = new DefaultRouteStartupOrder(1, routeService.getRoutes().iterator().next(), routeService).             boolean completed = getShutdownStrategy().shutdown(this, route, timeout, timeUnit, abortAfterTimeout).             if (completed) {                 // must stop route service as well                 stopRouteService(routeService, false).             } else {                 // shutdown was aborted, make sure route is re-started properly                 startRouteService(routeService, false).             }             return completed.         } catch (Exception e) {             DefaultRouteError.set(this, routeId, Phase.STOP, e).             throw e.         }     }     return false. }
false;public;1;3;;public void stopRoute(String routeId) throws Exception {     doShutdownRoute(routeId, getShutdownStrategy().getTimeout(), getShutdownStrategy().getTimeUnit(), false). }
false;public;3;3;;public void stopRoute(String routeId, long timeout, TimeUnit timeUnit) throws Exception {     doShutdownRoute(routeId, timeout, timeUnit, false). }
false;protected,synchronized;4;19;;protected synchronized void doShutdownRoute(String routeId, long timeout, TimeUnit timeUnit, boolean removingRoutes) throws Exception {     DefaultRouteError.reset(this, routeId).     RouteService routeService = routeServices.get(routeId).     if (routeService != null) {         try {             List<RouteStartupOrder> routes = new ArrayList<>(1).             RouteStartupOrder order = new DefaultRouteStartupOrder(1, routeService.getRoutes().iterator().next(), routeService).             routes.add(order).             getShutdownStrategy().shutdown(this, routes, timeout, timeUnit).             // must stop route service as well (and remove the routes from management)             stopRouteService(routeService, removingRoutes).         } catch (Exception e) {             DefaultRouteError.set(this, routeId, removingRoutes ? Phase.SHUTDOWN : Phase.STOP, e).             throw e.         }     } }
false;public,synchronized;1;59;;public synchronized boolean removeRoute(String routeId) throws Exception {     DefaultRouteError.reset(this, routeId).     // remove the route from ErrorHandlerBuilder if possible     if (getErrorHandlerFactory() instanceof ErrorHandlerBuilderSupport) {         ErrorHandlerBuilderSupport builder = (ErrorHandlerBuilderSupport) getErrorHandlerFactory().         builder.removeOnExceptionList(routeId).     }     // gather a map of all the endpoints in use by the routes, so we can known if a given endpoints is in use     // by one or more routes, when we remove the route     Map<String, Set<Endpoint>> endpointsInUse = new HashMap<>().     for (Map.Entry<String, RouteService> entry : routeServices.entrySet()) {         endpointsInUse.put(entry.getKey(), entry.getValue().gatherEndpoints()).     }     RouteService routeService = routeServices.get(routeId).     if (routeService != null) {         if (getRouteStatus(routeId).isStopped()) {             try {                 routeService.setRemovingRoutes(true).                 shutdownRouteService(routeService).                 removeRouteDefinition(routeId).                 routeServices.remove(routeId).                 // remove route from startup order as well, as it was removed                 routeStartupOrder.removeIf(order -> order.getRoute().getId().equals(routeId)).                 // from the route which we have removed, then remove all its private endpoints                 // (eg the endpoints which are not in use by other routes)                 Set<Endpoint> toRemove = new LinkedHashSet<>().                 for (Endpoint endpoint : endpointsInUse.get(routeId)) {                     // how many times is the endpoint in use                     int count = 0.                     for (Set<Endpoint> endpoints : endpointsInUse.values()) {                         if (endpoints.contains(endpoint)) {                             count++.                         }                     }                     // notice we will count ourselves so if there is only 1 then its safe to remove                     if (count <= 1) {                         toRemove.add(endpoint).                     }                 }                 for (Endpoint endpoint : toRemove) {                     log.debug("Removing: {} which was only in use by route: {}", endpoint, routeId).                     removeEndpoint(endpoint).                 }             } catch (Exception e) {                 DefaultRouteError.set(this, routeId, Phase.REMOVE, e).                 throw e.             }             return true.         } else {             return false.         }     }     return false. }
false;public;1;3;;public void suspendRoute(String routeId) throws Exception {     suspendRoute(routeId, getShutdownStrategy().getTimeout(), getShutdownStrategy().getTimeUnit()). }
false;public,synchronized;3;29;;public synchronized void suspendRoute(String routeId, long timeout, TimeUnit timeUnit) throws Exception {     DefaultRouteError.reset(this, routeId).     try {         if (!routeSupportsSuspension(routeId)) {             stopRoute(routeId, timeout, timeUnit).             return.         }         RouteService routeService = routeServices.get(routeId).         if (routeService != null) {             List<RouteStartupOrder> routes = new ArrayList<>(1).             Route route = routeService.getRoutes().iterator().next().             RouteStartupOrder order = new DefaultRouteStartupOrder(1, route, routeService).             routes.add(order).             getShutdownStrategy().suspend(this, routes, timeout, timeUnit).             // must suspend route service as well             suspendRouteService(routeService).             // must suspend the route as well             if (route instanceof SuspendableService) {                 ((SuspendableService) route).suspend().             }         }     } catch (Exception e) {         DefaultRouteError.set(this, routeId, Phase.SUSPEND, e).         throw e.     } }
false;public;1;3;;public void addService(Object object) throws Exception {     addService(object, true). }
false;public;2;3;;public void addService(Object object, boolean stopOnShutdown) throws Exception {     addService(object, stopOnShutdown, false). }
false;public;3;4;;@Override public void addService(Object object, boolean stopOnShutdown, boolean forceStart) throws Exception {     internalAddService(object, stopOnShutdown, forceStart). }
false;protected;1;3;;protected <T> T doAddService(T object) {     return doAddService(object, true). }
false;protected;2;3;;protected <T> T doAddService(T object, boolean stopOnShutdown) {     return doAddService(object, stopOnShutdown, true). }
false;protected;3;8;;protected <T> T doAddService(T object, boolean stopOnShutdown, boolean forceStart) {     try {         internalAddService(object, stopOnShutdown, forceStart).     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     }     return object. }
false;private;3;41;;private void internalAddService(Object object, boolean stopOnShutdown, boolean forceStart) throws Exception {     // inject CamelContext     if (object instanceof CamelContextAware) {         CamelContextAware aware = (CamelContextAware) object.         aware.setCamelContext(this).     }     if (object instanceof Service) {         Service service = (Service) object.         for (LifecycleStrategy strategy : lifecycleStrategies) {             if (service instanceof Endpoint) {                 // use specialized endpoint add                 strategy.onEndpointAdd((Endpoint) service).             } else {                 strategy.onServiceAdd(this, service, null).             }         }         if (!forceStart) {             // now start the service (and defer starting if CamelContext is starting up itself)             deferStartService(object, stopOnShutdown).         } else {             // only add to services to close if its a singleton             // otherwise we could for example end up with a lot of prototype scope endpoints             // assume singleton by default             boolean singleton = true.             if (object instanceof IsSingleton) {                 singleton = ((IsSingleton) service).isSingleton().             }             // do not add endpoints as they have their own list             if (singleton && !(service instanceof Endpoint)) {                 // only add to list of services to stop if its not already there                 if (stopOnShutdown && !hasService(service)) {                     servicesToStop.add(service).                 }             }             ServiceHelper.startService(service).         }     } }
false;public;1;14;;public boolean removeService(Object object) throws Exception {     if (object instanceof Endpoint) {         removeEndpoint((Endpoint) object).         return true.     }     if (object instanceof Service) {         Service service = (Service) object.         for (LifecycleStrategy strategy : lifecycleStrategies) {             strategy.onServiceRemove(this, service, null).         }         return servicesToStop.remove(service).     }     return false. }
false;public;1;7;;public boolean hasService(Object object) {     if (object instanceof Service) {         Service service = (Service) object.         return servicesToStop.contains(service).     }     return false. }
false;public;1;9;;@Override public <T> T hasService(Class<T> type) {     for (Service service : servicesToStop) {         if (type.isInstance(service)) {             return type.cast(service).         }     }     return null. }
false;public;1;10;;@Override public <T> Set<T> hasServices(Class<T> type) {     Set<T> set = new HashSet<>().     for (Service service : servicesToStop) {         if (type.isInstance(service)) {             set.add((T) service).         }     }     return set. }
false;public;2;25;;public void deferStartService(Object object, boolean stopOnShutdown) throws Exception {     if (object instanceof Service) {         Service service = (Service) object.         // only add to services to close if its a singleton         // otherwise we could for example end up with a lot of prototype scope endpoints         // assume singleton by default         boolean singleton = true.         if (object instanceof IsSingleton) {             singleton = ((IsSingleton) service).isSingleton().         }         // do not add endpoints as they have their own list         if (singleton && !(service instanceof Endpoint)) {             // only add to list of services to stop if its not already there             if (stopOnShutdown && !hasService(service)) {                 servicesToStop.add(service).             }         }         // are we already started?         if (isStarted()) {             ServiceHelper.startService(service).         } else {             deferStartupListener.addService(service).         }     } }
false;public;1;9;;public void addStartupListener(StartupListener listener) throws Exception {     // or invoke the callback right now     if (isStarted()) {         listener.onCamelContextStarted(this, true).     } else {         startupListeners.add(listener).     } }
false;public;1;26;;public String resolveComponentDefaultName(String javaType) {     // try to find the component by its java type from the in-use components     if (javaType != null) {         // find all the components which will include the default component name         try {             Map<String, Properties> all = CamelContextHelper.findComponents(this).             for (Map.Entry<String, Properties> entry : all.entrySet()) {                 String fqn = (String) entry.getValue().get("class").                 if (javaType.equals(fqn)) {                     // is there component docs for that name?                     String name = entry.getKey().                     String json = getComponentParameterJsonSchema(name).                     if (json != null) {                         return name.                     }                 }             }         } catch (Exception e) {             // ignore             return null.         }     }     // could not find a component with that name     return null. }
false;public;0;3;;public Map<String, Properties> findComponents() throws LoadPropertiesException, IOException {     return CamelContextHelper.findComponents(this). }
false;public;0;3;;public Map<String, Properties> findEips() throws LoadPropertiesException, IOException {     return CamelContextHelper.findEips(this). }
false;public;1;47;;public String getComponentParameterJsonSchema(String componentName) throws IOException {     // use the component factory finder to find the package name of the component class, which is the location     // where the documentation exists as well     FactoryFinder finder = getFactoryFinder(DefaultComponentResolver.RESOURCE_PATH).     try {         Class<?> clazz = null.         try {             clazz = finder.findClass(componentName).         } catch (NoFactoryAvailableException e) {         // ignore, i.e. if a component is an auto-configured spring-boot         // component         }         if (clazz == null) {             // fallback and find existing component             Component existing = hasComponent(componentName).             if (existing != null) {                 clazz = existing.getClass().             } else {                 return null.             }         }         String packageName = clazz.getPackage().getName().         packageName = packageName.replace('.', '/').         String path = packageName + "/" + componentName + ".json".         ClassResolver resolver = getClassResolver().         InputStream inputStream = resolver.loadResourceAsStream(path).         log.debug("Loading component JSON Schema for: {} using class resolver: {} -> {}", componentName, resolver, inputStream).         if (inputStream != null) {             try {                 return IOHelper.loadText(inputStream).             } finally {                 IOHelper.close(inputStream).             }         }         // special for ActiveMQ as it is really just JMS         if ("ActiveMQComponent".equals(clazz.getSimpleName())) {             return getComponentParameterJsonSchema("jms").         } else {             return null.         }     } catch (ClassNotFoundException e) {         return null.     } }
false;public;1;37;;public String getDataFormatParameterJsonSchema(String dataFormatName) throws IOException {     // use the dataformat factory finder to find the package name of the dataformat class, which is the location     // where the documentation exists as well     FactoryFinder finder = getFactoryFinder(DefaultDataFormatResolver.DATAFORMAT_RESOURCE_PATH).     try {         Class<?> clazz = null.         try {             clazz = finder.findClass(dataFormatName).         } catch (NoFactoryAvailableException e) {         // ignore, i.e. if a component is an auto-configured spring-boot         // data-formats         }         if (clazz == null) {             return null.         }         String packageName = clazz.getPackage().getName().         packageName = packageName.replace('.', '/').         String path = packageName + "/" + dataFormatName + ".json".         ClassResolver resolver = getClassResolver().         InputStream inputStream = resolver.loadResourceAsStream(path).         log.debug("Loading dataformat JSON Schema for: {} using class resolver: {} -> {}", dataFormatName, resolver, inputStream).         if (inputStream != null) {             try {                 return IOHelper.loadText(inputStream).             } finally {                 IOHelper.close(inputStream).             }         }         return null.     } catch (ClassNotFoundException e) {         return null.     } }
false;public;1;37;;public String getLanguageParameterJsonSchema(String languageName) throws IOException {     // use the language factory finder to find the package name of the language class, which is the location     // where the documentation exists as well     FactoryFinder finder = getFactoryFinder(DefaultLanguageResolver.LANGUAGE_RESOURCE_PATH).     try {         Class<?> clazz = null.         try {             clazz = finder.findClass(languageName).         } catch (NoFactoryAvailableException e) {         // ignore, i.e. if a component is an auto-configured spring-boot         // languages         }         if (clazz == null) {             return null.         }         String packageName = clazz.getPackage().getName().         packageName = packageName.replace('.', '/').         String path = packageName + "/" + languageName + ".json".         ClassResolver resolver = getClassResolver().         InputStream inputStream = resolver.loadResourceAsStream(path).         log.debug("Loading language JSON Schema for: {} using class resolver: {} -> {}", languageName, resolver, inputStream).         if (inputStream != null) {             try {                 return IOHelper.loadText(inputStream).             } finally {                 IOHelper.close(inputStream).             }         }         return null.     } catch (ClassNotFoundException e) {         return null.     } }
false;public;1;18;;public String getEipParameterJsonSchema(String eipName) throws IOException {     // the eip json schema may be in some of the sub-packages so look until we find it     String[] subPackages = new String[] { "", "/config", "/dataformat", "/language", "/loadbalancer", "/rest" }.     for (String sub : subPackages) {         String path = CamelContextHelper.MODEL_DOCUMENTATION_PREFIX + sub + "/" + eipName + ".json".         ClassResolver resolver = getClassResolver().         InputStream inputStream = resolver.loadResourceAsStream(path).         if (inputStream != null) {             log.debug("Loading eip JSON Schema for: {} using class resolver: {} -> {}", eipName, resolver, inputStream).             try {                 return IOHelper.loadText(inputStream).             } finally {                 IOHelper.close(inputStream).             }         }     }     return null. }
false;public;2;153;;public String explainEipJson(String nameOrId, boolean includeAllOptions) {     try {         // try to find the id within all known routes and their eips         String eipName = nameOrId.         NamedNode target = null.         for (RouteDefinition route : getRouteDefinitions()) {             if (route.getId().equals(nameOrId)) {                 target = route.                 break.             }             for (FromDefinition from : route.getInputs()) {                 if (nameOrId.equals(from.getId())) {                     target = route.                     break.                 }             }             Iterator<ProcessorDefinition> it = ProcessorDefinitionHelper.filterTypeInOutputs(route.getOutputs(), ProcessorDefinition.class).             while (it.hasNext()) {                 ProcessorDefinition def = it.next().                 if (nameOrId.equals(def.getId())) {                     target = def.                     break.                 }             }             if (target != null) {                 break.             }         }         if (target != null) {             eipName = target.getShortName().         }         String json = getEipParameterJsonSchema(eipName).         if (json == null) {             return null.         }         // overlay with runtime parameters that id uses at runtime         if (target != null) {             List<Map<String, String>> rows = JSonSchemaHelper.parseJsonSchema("properties", json, true).             // selected rows to use for answer             Map<String, String[]> selected = new LinkedHashMap<>().             // extract options from the node             Map<String, Object> options = new LinkedHashMap<>().             IntrospectionSupport.getProperties(target, options, "", false).             // remove outputs which we do not want to include             options.remove("outputs").             // include other rows             for (Map<String, String> row : rows) {                 String name = row.get("name").                 String kind = row.get("kind").                 String label = row.get("label").                 String required = row.get("required").                 String value = row.get("value").                 String defaultValue = row.get("defaultValue").                 String type = row.get("type").                 String javaType = row.get("javaType").                 String deprecated = row.get("deprecated").                 String description = row.get("description").                 // find the configured option                 Object o = options.get(name).                 if (o != null) {                     value = o.toString().                 }                 value = URISupport.sanitizePath(value).                 if (includeAllOptions || o != null) {                     // add as selected row                     if (!selected.containsKey(name)) {                         selected.put(name, new String[] { name, kind, label, required, type, javaType, deprecated, value, defaultValue, description }).                     }                 }             }             json = StringHelper.before(json, "  \"properties\": {").             StringBuilder buffer = new StringBuilder("  \"properties\": {").             boolean first = true.             for (String[] row : selected.values()) {                 if (first) {                     first = false.                 } else {                     buffer.append(",").                 }                 buffer.append("\n    ").                 String name = row[0].                 String kind = row[1].                 String label = row[2].                 String required = row[3].                 String type = row[4].                 String javaType = row[5].                 String deprecated = row[6].                 String value = row[7].                 String defaultValue = row[8].                 String description = row[9].                 // add json of the option                 buffer.append(StringQuoteHelper.doubleQuote(name)).append(": { ").                 CollectionStringBuffer csb = new CollectionStringBuffer().                 if (kind != null) {                     csb.append("\"kind\": \"" + kind + "\"").                 }                 if (label != null) {                     csb.append("\"label\": \"" + label + "\"").                 }                 if (required != null) {                     csb.append("\"required\": \"" + required + "\"").                 }                 if (type != null) {                     csb.append("\"type\": \"" + type + "\"").                 }                 if (javaType != null) {                     csb.append("\"javaType\": \"" + javaType + "\"").                 }                 if (deprecated != null) {                     csb.append("\"deprecated\": \"" + deprecated + "\"").                 }                 if (value != null) {                     csb.append("\"value\": \"" + value + "\"").                 }                 if (defaultValue != null) {                     csb.append("\"defaultValue\": \"" + defaultValue + "\"").                 }                 if (description != null) {                     csb.append("\"description\": \"" + description + "\"").                 }                 if (!csb.isEmpty()) {                     buffer.append(csb.toString()).                 }                 buffer.append(" }").             }             buffer.append("\n  }\n}\n").             // insert the original first part of the json into the start of the buffer             buffer.insert(0, json).             return buffer.toString().         }         return json.     } catch (Exception e) {         // ignore and return empty response         return null.     } }
false;public;3;166;;public String explainDataFormatJson(String dataFormatName, DataFormat dataFormat, boolean includeAllOptions) {     try {         String json = getDataFormatParameterJsonSchema(dataFormatName).         if (json == null) {             // the model may be shared for multiple data formats such as bindy, json (xstream, jackson, gson)             if (dataFormatName.contains("-")) {                 dataFormatName = StringHelper.before(dataFormatName, "-").                 json = getDataFormatParameterJsonSchema(dataFormatName).             }             if (json == null) {                 return null.             }         }         List<Map<String, String>> rows = JSonSchemaHelper.parseJsonSchema("properties", json, true).         // selected rows to use for answer         Map<String, String[]> selected = new LinkedHashMap<>().         Map<String, String[]> dataFormatOptions = new LinkedHashMap<>().         // extract options from the data format         Map<String, Object> options = new LinkedHashMap<>().         IntrospectionSupport.getProperties(dataFormat, options, "", false).         for (Map.Entry<String, Object> entry : options.entrySet()) {             String name = entry.getKey().             String value = "".             if (entry.getValue() != null) {                 value = entry.getValue().toString().             }             value = URISupport.sanitizePath(value).             // find type and description from the json schema             String type = null.             String kind = null.             String label = null.             String required = null.             String javaType = null.             String deprecated = null.             String secret = null.             String defaultValue = null.             String description = null.             for (Map<String, String> row : rows) {                 if (name.equals(row.get("name"))) {                     type = row.get("type").                     kind = row.get("kind").                     label = row.get("label").                     required = row.get("required").                     javaType = row.get("javaType").                     deprecated = row.get("deprecated").                     secret = row.get("secret").                     defaultValue = row.get("defaultValue").                     description = row.get("description").                     break.                 }             }             // remember this option from the uri             dataFormatOptions.put(name, new String[] { name, kind, label, required, type, javaType, deprecated, secret, value, defaultValue, description }).         }         // include other rows         for (Map<String, String> row : rows) {             String name = row.get("name").             String kind = row.get("kind").             String label = row.get("label").             String required = row.get("required").             String value = row.get("value").             String defaultValue = row.get("defaultValue").             String type = row.get("type").             String javaType = row.get("javaType").             String deprecated = row.get("deprecated").             String secret = row.get("secret").             value = URISupport.sanitizePath(value).             String description = row.get("description").             boolean isDataFormatOption = dataFormatOptions.containsKey(name).             // always include from uri or path options             if (includeAllOptions || isDataFormatOption) {                 if (!selected.containsKey(name)) {                     // add as selected row, but take the value from uri options if it was from there                     if (isDataFormatOption) {                         selected.put(name, dataFormatOptions.get(name)).                     } else {                         selected.put(name, new String[] { name, kind, label, required, type, javaType, deprecated, secret, value, defaultValue, description }).                     }                 }             }         }         json = StringHelper.before(json, "  \"properties\": {").         StringBuilder buffer = new StringBuilder("  \"properties\": {").         boolean first = true.         for (String[] row : selected.values()) {             if (first) {                 first = false.             } else {                 buffer.append(",").             }             buffer.append("\n    ").             String name = row[0].             String kind = row[1].             String label = row[2].             String required = row[3].             String type = row[4].             String javaType = row[5].             String deprecated = row[6].             String secret = row[7].             String value = row[8].             String defaultValue = row[9].             String description = row[10].             // add json of the option             buffer.append(StringQuoteHelper.doubleQuote(name)).append(": { ").             CollectionStringBuffer csb = new CollectionStringBuffer().             if (kind != null) {                 csb.append("\"kind\": \"" + kind + "\"").             }             if (label != null) {                 csb.append("\"label\": \"" + label + "\"").             }             if (required != null) {                 csb.append("\"required\": \"" + required + "\"").             }             if (type != null) {                 csb.append("\"type\": \"" + type + "\"").             }             if (javaType != null) {                 csb.append("\"javaType\": \"" + javaType + "\"").             }             if (deprecated != null) {                 csb.append("\"deprecated\": \"" + deprecated + "\"").             }             if (secret != null) {                 csb.append("\"secret\": \"" + secret + "\"").             }             if (value != null) {                 csb.append("\"value\": \"" + value + "\"").             }             if (defaultValue != null) {                 csb.append("\"defaultValue\": \"" + defaultValue + "\"").             }             if (description != null) {                 csb.append("\"description\": \"" + description + "\"").             }             if (!csb.isEmpty()) {                 buffer.append(csb.toString()).             }             buffer.append(" }").         }         buffer.append("\n  }\n}\n").         // insert the original first part of the json into the start of the buffer         buffer.insert(0, json).         return buffer.toString().     } catch (Exception e) {         // ignore and return empty response         return null.     } }
false;public;2;157;;public String explainComponentJson(String componentName, boolean includeAllOptions) {     try {         String json = getComponentParameterJsonSchema(componentName).         if (json == null) {             return null.         }         List<Map<String, String>> rows = JSonSchemaHelper.parseJsonSchema("componentProperties", json, true).         // selected rows to use for answer         Map<String, String[]> selected = new LinkedHashMap<>().         // insert values from component         Component component = getComponent(componentName).         Map<String, Object> options = new HashMap<>().         IntrospectionSupport.getProperties(component, options, null).         for (Map.Entry<String, Object> entry : options.entrySet()) {             String name = entry.getKey().             // skip unwanted options which is default inherited from DefaultComponent             if ("camelContext".equals(name) || "endpointClass".equals(name)) {                 continue.             }             String value = "".             if (entry.getValue() != null) {                 value = entry.getValue().toString().             }             value = URISupport.sanitizePath(value).             // find type and description from the json schema             String type = null.             String kind = null.             String group = null.             String label = null.             String required = null.             String javaType = null.             String deprecated = null.             String secret = null.             String defaultValue = null.             String description = null.             for (Map<String, String> row : rows) {                 if (name.equals(row.get("name"))) {                     type = row.get("type").                     kind = row.get("kind").                     group = row.get("group").                     label = row.get("label").                     required = row.get("required").                     javaType = row.get("javaType").                     deprecated = row.get("deprecated").                     secret = row.get("secret").                     defaultValue = row.get("defaultValue").                     description = row.get("description").                     break.                 }             }             // add as selected row             selected.put(name, new String[] { name, kind, group, label, required, type, javaType, deprecated, secret, value, defaultValue, description }).         }         // include other rows         for (Map<String, String> row : rows) {             String name = row.get("name").             String kind = row.get("kind").             String group = row.get("group").             String label = row.get("label").             String required = row.get("required").             String value = row.get("value").             String defaultValue = row.get("defaultValue").             String type = row.get("type").             String javaType = row.get("javaType").             String deprecated = row.get("deprecated").             String secret = row.get("secret").             value = URISupport.sanitizePath(value).             String description = row.get("description").             // always include path options             if (includeAllOptions) {                 // add as selected row                 if (!selected.containsKey(name)) {                     selected.put(name, new String[] { name, kind, group, label, required, type, javaType, deprecated, secret, value, defaultValue, description }).                 }             }         }         json = StringHelper.before(json, "  \"componentProperties\": {").         StringBuilder buffer = new StringBuilder("  \"componentProperties\": {").         boolean first = true.         for (String[] row : selected.values()) {             if (first) {                 first = false.             } else {                 buffer.append(",").             }             buffer.append("\n    ").             String name = row[0].             String kind = row[1].             String group = row[2].             String label = row[3].             String required = row[4].             String type = row[5].             String javaType = row[6].             String deprecated = row[7].             String secret = row[8].             String value = row[9].             String defaultValue = row[10].             String description = row[11].             // add json of the option             buffer.append(StringQuoteHelper.doubleQuote(name)).append(": { ").             CollectionStringBuffer csb = new CollectionStringBuffer().             if (kind != null) {                 csb.append("\"kind\": \"" + kind + "\"").             }             if (group != null) {                 csb.append("\"group\": \"" + group + "\"").             }             if (label != null) {                 csb.append("\"label\": \"" + label + "\"").             }             if (required != null) {                 csb.append("\"required\": \"" + required + "\"").             }             if (type != null) {                 csb.append("\"type\": \"" + type + "\"").             }             if (javaType != null) {                 csb.append("\"javaType\": \"" + javaType + "\"").             }             if (deprecated != null) {                 csb.append("\"deprecated\": \"" + deprecated + "\"").             }             if (secret != null) {                 csb.append("\"secret\": \"" + secret + "\"").             }             if (value != null) {                 csb.append("\"value\": \"" + value + "\"").             }             if (defaultValue != null) {                 csb.append("\"defaultValue\": \"" + defaultValue + "\"").             }             if (description != null) {                 csb.append("\"description\": \"" + description + "\"").             }             if (!csb.isEmpty()) {                 buffer.append(csb.toString()).             }             buffer.append(" }").         }         buffer.append("\n  }\n}\n").         // insert the original first part of the json into the start of the buffer         buffer.insert(0, json).         return buffer.toString().     } catch (Exception e) {         // ignore and return empty response         return null.     } }
true;public;2;164;// CHECKSTYLE:OFF ;// CHECKSTYLE:OFF public String explainEndpointJson(String uri, boolean includeAllOptions) {     try {         URI u = new URI(uri).         String json = getComponentParameterJsonSchema(u.getScheme()).         if (json == null) {             return null.         }         List<Map<String, String>> rows = JSonSchemaHelper.parseJsonSchema("properties", json, true).         // selected rows to use for answer         Map<String, String[]> selected = new LinkedHashMap<>().         Map<String, String[]> uriOptions = new LinkedHashMap<>().         // insert values from uri         Map<String, Object> options = new HashMap<>(getExtension(RuntimeCamelCatalog.class).endpointProperties(uri)).         // extract consumer. prefix options         Map<String, Object> consumerOptions = IntrospectionSupport.extractProperties(options, "consumer.").         // and add back again without the consumer. prefix as that json schema omits that         options.putAll(consumerOptions).         for (Map.Entry<String, Object> entry : options.entrySet()) {             String name = entry.getKey().             String value = "".             if (entry.getValue() != null) {                 value = entry.getValue().toString().             }             value = URISupport.sanitizePath(value).             // find type and description from the json schema             String type = null.             String kind = null.             String group = null.             String label = null.             String required = null.             String javaType = null.             String deprecated = null.             String secret = null.             String defaultValue = null.             String description = null.             for (Map<String, String> row : rows) {                 if (name.equals(row.get("name"))) {                     type = row.get("type").                     kind = row.get("kind").                     group = row.get("group").                     label = row.get("label").                     required = row.get("required").                     javaType = row.get("javaType").                     deprecated = row.get("deprecated").                     secret = row.get("secret").                     defaultValue = row.get("defaultValue").                     description = row.get("description").                     break.                 }             }             // remember this option from the uri             uriOptions.put(name, new String[] { name, kind, group, label, required, type, javaType, deprecated, secret, value, defaultValue, description }).         }         // include other rows         for (Map<String, String> row : rows) {             String name = row.get("name").             String kind = row.get("kind").             String group = row.get("group").             String label = row.get("label").             String required = row.get("required").             String value = row.get("value").             String defaultValue = row.get("defaultValue").             String type = row.get("type").             String javaType = row.get("javaType").             String deprecated = row.get("deprecated").             String secret = row.get("secret").             value = URISupport.sanitizePath(value).             String description = row.get("description").             boolean isUriOption = uriOptions.containsKey(name).             // always include from uri or path options             if (includeAllOptions || isUriOption || "path".equals(kind)) {                 if (!selected.containsKey(name)) {                     // add as selected row, but take the value from uri options if it was from there                     if (isUriOption) {                         selected.put(name, uriOptions.get(name)).                     } else {                         selected.put(name, new String[] { name, kind, group, label, required, type, javaType, deprecated, secret, value, defaultValue, description }).                     }                 }             }         }         // skip component properties         json = StringHelper.before(json, "  \"componentProperties\": {").         // and rewrite properties         StringBuilder buffer = new StringBuilder("  \"properties\": {").         boolean first = true.         for (String[] row : selected.values()) {             if (first) {                 first = false.             } else {                 buffer.append(",").             }             buffer.append("\n    ").             String name = row[0].             String kind = row[1].             String group = row[2].             String label = row[3].             String required = row[4].             String type = row[5].             String javaType = row[6].             String deprecated = row[7].             String secret = row[8].             String value = row[9].             String defaultValue = row[10].             String description = row[11].             // add json of the option             buffer.append(StringQuoteHelper.doubleQuote(name)).append(": { ").             CollectionStringBuffer csb = new CollectionStringBuffer().             if (kind != null) {                 csb.append("\"kind\": \"" + kind + "\"").             }             if (group != null) {                 csb.append("\"group\": \"" + group + "\"").             }             if (label != null) {                 csb.append("\"label\": \"" + label + "\"").             }             if (required != null) {                 csb.append("\"required\": \"" + required + "\"").             }             if (type != null) {                 csb.append("\"type\": \"" + type + "\"").             }             if (javaType != null) {                 csb.append("\"javaType\": \"" + javaType + "\"").             }             if (deprecated != null) {                 csb.append("\"deprecated\": \"" + deprecated + "\"").             }             if (secret != null) {                 csb.append("\"secret\": \"" + secret + "\"").             }             if (value != null) {                 csb.append("\"value\": \"" + value + "\"").             }             if (defaultValue != null) {                 csb.append("\"defaultValue\": \"" + defaultValue + "\"").             }             if (description != null) {                 csb.append("\"description\": \"" + description + "\"").             }             if (!csb.isEmpty()) {                 buffer.append(csb.toString()).             }             buffer.append(" }").         }         buffer.append("\n  }\n}\n").         // insert the original first part of the json into the start of the buffer         buffer.insert(0, json).         return buffer.toString().     } catch (Exception e) {         // ignore and return empty response         return null.     } }
false;public;1;4;;// CHECKSTYLE:ON public String createRouteStaticEndpointJson(String routeId) {     // lets include dynamic as well as we want as much data as possible     return createRouteStaticEndpointJson(routeId, true). }
false;public;2;60;;public String createRouteStaticEndpointJson(String routeId, boolean includeDynamic) {     List<RouteDefinition> routes = new ArrayList<>().     if (routeId != null) {         RouteDefinition route = getRouteDefinition(routeId).         if (route == null) {             throw new IllegalArgumentException("Route with id " + routeId + " does not exist").         }         routes.add(route).     } else {         routes.addAll(getRouteDefinitions()).     }     StringBuilder buffer = new StringBuilder("{\n  \"routes\": {").     boolean firstRoute = true.     for (RouteDefinition route : routes) {         if (!firstRoute) {             buffer.append("\n    },").         } else {             firstRoute = false.         }         String id = route.getId().         buffer.append("\n    \"").append(id).append("\": {").         buffer.append("\n      \"inputs\": [").         // for inputs we do not need to check dynamic as we have the data from the route definition         Set<String> inputs = RouteDefinitionHelper.gatherAllStaticEndpointUris(this, route, true, false).         boolean first = true.         for (String input : inputs) {             if (!first) {                 buffer.append(",").             } else {                 first = false.             }             buffer.append("\n        ").             buffer.append(StringHelper.toJson("uri", input, true)).         }         buffer.append("\n      ]").         buffer.append(",").         buffer.append("\n      \"outputs\": [").         Set<String> outputs = RouteDefinitionHelper.gatherAllEndpointUris(this, route, false, true, includeDynamic).         first = true.         for (String output : outputs) {             if (!first) {                 buffer.append(",").             } else {                 first = false.             }             buffer.append("\n        ").             buffer.append(StringHelper.toJson("uri", output, true)).         }         buffer.append("\n      ]").     }     if (!firstRoute) {         buffer.append("\n    }").     }     buffer.append("\n  }\n}\n").     return buffer.toString(). }
false;public;1;35;;// Helper methods // ----------------------------------------------------------------------- public Language resolveLanguage(String language) {     Language answer.     synchronized (languages) {         answer = languages.get(language).         // check if the language is singleton, if so return the shared instance         if (answer instanceof IsSingleton) {             boolean singleton = ((IsSingleton) answer).isSingleton().             if (singleton) {                 return answer.             }         }         // language not known or not singleton, then use resolver         answer = getLanguageResolver().resolveLanguage(language, this).         // inject CamelContext if aware         if (answer != null) {             if (answer instanceof CamelContextAware) {                 ((CamelContextAware) answer).setCamelContext(this).             }             if (answer instanceof Service) {                 try {                     startService((Service) answer).                 } catch (Exception e) {                     throw RuntimeCamelException.wrapRuntimeCamelException(e).                 }             }             languages.put(language, answer).         }     }     return answer. }
false;public;0;9;;public String getPropertyPrefixToken() {     PropertiesComponent pc = getPropertiesComponent(false).     if (pc != null) {         return pc.getPrefixToken().     } else {         return null.     } }
false;public;0;9;;public String getPropertySuffixToken() {     PropertiesComponent pc = getPropertiesComponent(false).     if (pc != null) {         return pc.getSuffixToken().     } else {         return null.     } }
false;public;1;25;;public String resolvePropertyPlaceholders(String text) throws Exception {     // While it is more efficient to only do the lookup if we are sure we need the component,     // with custom tokens, we cannot know if the URI contains a property or not without having     // the component.  We also lose fail-fast behavior for the missing component with this change.     PropertiesComponent pc = getPropertiesComponent(false).     // Do not parse uris that are designated for the properties component as it will handle that itself     if (text != null && !text.startsWith("properties:")) {         // No component, assume default tokens.         if (pc == null && text.contains(PropertiesComponent.DEFAULT_PREFIX_TOKEN)) {             // lookup existing properties component, or force create a new default component             pc = getPropertiesComponent(true).         }         if (pc != null && text.contains(pc.getPrefixToken())) {             // the parser will throw exception if property key was not found             String answer = pc.parseUri(text).             log.debug("Resolved text: {} -> {}", text, answer).             return answer.         }     }     // return original text as is     return text. }
false;public;0;10;;// Properties // ----------------------------------------------------------------------- public TypeConverter getTypeConverter() {     if (typeConverter == null) {         synchronized (lock) {             if (typeConverter == null) {                 setTypeConverter(createTypeConverter()).             }         }     }     return typeConverter. }
false;public;1;3;;public void setTypeConverter(TypeConverter typeConverter) {     this.typeConverter = doAddService(typeConverter). }
false;public;0;10;;public TypeConverterRegistry getTypeConverterRegistry() {     if (typeConverterRegistry == null) {         synchronized (lock) {             if (typeConverterRegistry == null) {                 setTypeConverterRegistry(createTypeConverterRegistry()).             }         }     }     return typeConverterRegistry. }
false;public;1;3;;public void setTypeConverterRegistry(TypeConverterRegistry typeConverterRegistry) {     this.typeConverterRegistry = doAddService(typeConverterRegistry). }
false;public;0;10;;public Injector getInjector() {     if (injector == null) {         synchronized (lock) {             if (injector == null) {                 setInjector(createInjector()).             }         }     }     return injector. }
false;public;1;3;;public void setInjector(Injector injector) {     this.injector = doAddService(injector). }
false;public;0;3;;public ManagementMBeanAssembler getManagementMBeanAssembler() {     return managementMBeanAssembler. }
false;public;1;3;;public void setManagementMBeanAssembler(ManagementMBeanAssembler managementMBeanAssembler) {     this.managementMBeanAssembler = doAddService(managementMBeanAssembler, false). }
false;public;0;10;;public ComponentResolver getComponentResolver() {     if (componentResolver == null) {         synchronized (lock) {             if (componentResolver == null) {                 setComponentResolver(createComponentResolver()).             }         }     }     return componentResolver. }
false;public;1;3;;public void setComponentResolver(ComponentResolver componentResolver) {     this.componentResolver = doAddService(componentResolver). }
false;public;0;10;;public LanguageResolver getLanguageResolver() {     if (languageResolver == null) {         synchronized (lock) {             if (languageResolver == null) {                 setLanguageResolver(createLanguageResolver()).             }         }     }     return languageResolver. }
false;public;1;3;;public void setLanguageResolver(LanguageResolver languageResolver) {     this.languageResolver = doAddService(languageResolver). }
false;public;0;3;;public boolean isAutoCreateComponents() {     return autoCreateComponents. }
false;public;1;3;;public void setAutoCreateComponents(boolean autoCreateComponents) {     this.autoCreateComponents = autoCreateComponents. }
false;public;0;10;;public Registry getRegistry() {     if (registry == null) {         synchronized (lock) {             if (registry == null) {                 setRegistry(createRegistry()).             }         }     }     return registry. }
false;public;1;8;;public <T> T getRegistry(Class<T> type) {     Registry reg = getRegistry().     if (type.isAssignableFrom(reg.getClass())) {         return type.cast(reg).     }     return null. }
false;public;1;6;;public void setRegistry(Registry registry) {     if (registry instanceof CamelContextAware) {         ((CamelContextAware) registry).setCamelContext(this).     }     this.registry = registry. }
false;public;0;3;;public List<LifecycleStrategy> getLifecycleStrategies() {     return lifecycleStrategies. }
false;public;1;3;;public void addLifecycleStrategy(LifecycleStrategy lifecycleStrategy) {     getLifecycleStrategies().add(lifecycleStrategy). }
false;public;1;7;;public void setupRoutes(boolean done) {     if (done) {         isSetupRoutes.remove().     } else {         isSetupRoutes.set(true).     } }
false;public,synchronized;0;3;;public synchronized List<RouteDefinition> getRouteDefinitions() {     return routeDefinitions. }
false;public,synchronized;1;8;;public synchronized RouteDefinition getRouteDefinition(String id) {     for (RouteDefinition route : routeDefinitions) {         if (route.idOrCreate(getNodeIdFactory()).equals(id)) {             return route.         }     }     return null. }
false;public,synchronized;0;3;;public synchronized List<RestDefinition> getRestDefinitions() {     return restDefinitions. }
false;public;1;7;;public void addRestDefinitions(Collection<RestDefinition> restDefinitions) throws Exception {     if (restDefinitions == null || restDefinitions.isEmpty()) {         return.     }     this.restDefinitions.addAll(restDefinitions). }
false;public;0;3;;public RestConfiguration getRestConfiguration() {     return restConfigurations.get(""). }
false;public;1;3;;public void setRestConfiguration(RestConfiguration restConfiguration) {     restConfigurations.put("", restConfiguration). }
false;public;0;3;;public Collection<RestConfiguration> getRestConfigurations() {     return restConfigurations.values(). }
false;public;1;3;;public void addRestConfiguration(RestConfiguration restConfiguration) {     restConfigurations.put(restConfiguration.getComponent(), restConfiguration). }
false;public;2;15;;public RestConfiguration getRestConfiguration(String component, boolean defaultIfNotExist) {     if (component == null) {         component = "".     }     RestConfiguration config = restConfigurations.get(component).     if (config == null && defaultIfNotExist) {         // grab the default configuration         config = getRestConfiguration().         if (config == null || (config.getComponent() != null && !config.getComponent().equals(component))) {             config = new RestConfiguration().             restConfigurations.put(component, config).         }     }     return config. }
false;public;1;8;;@Override public ServiceCallConfigurationDefinition getServiceCallConfiguration(String serviceName) {     if (serviceName == null) {         serviceName = "".     }     return serviceCallConfigurations.get(serviceName). }
false;public;1;4;;@Override public void setServiceCallConfiguration(ServiceCallConfigurationDefinition configuration) {     serviceCallConfigurations.put("", configuration). }
false;public;1;8;;@Override public void setServiceCallConfigurations(List<ServiceCallConfigurationDefinition> configurations) {     if (configurations != null) {         for (ServiceCallConfigurationDefinition configuration : configurations) {             serviceCallConfigurations.put(configuration.getId(), configuration).         }     } }
false;public;2;4;;@Override public void addServiceCallConfiguration(String serviceName, ServiceCallConfigurationDefinition configuration) {     serviceCallConfigurations.put(serviceName, configuration). }
false;public;1;8;;@Override public HystrixConfigurationDefinition getHystrixConfiguration(String id) {     if (id == null) {         id = "".     }     return hystrixConfigurations.get(id). }
false;public;1;4;;@Override public void setHystrixConfiguration(HystrixConfigurationDefinition configuration) {     hystrixConfigurations.put("", configuration). }
false;public;1;8;;@Override public void setHystrixConfigurations(List<HystrixConfigurationDefinition> configurations) {     if (configurations != null) {         for (HystrixConfigurationDefinition configuration : configurations) {             hystrixConfigurations.put(configuration.getId(), configuration).         }     } }
false;public;2;4;;@Override public void addHystrixConfiguration(String id, HystrixConfigurationDefinition configuration) {     hystrixConfigurations.put(id, configuration). }
false;public;0;3;;public List<InterceptStrategy> getInterceptStrategies() {     return interceptStrategies. }
false;public;1;3;;public void setInterceptStrategies(List<InterceptStrategy> interceptStrategies) {     this.interceptStrategies = interceptStrategies. }
false;public;1;9;;public void addInterceptStrategy(InterceptStrategy interceptStrategy) {     getInterceptStrategies().add(interceptStrategy).     if (interceptStrategy instanceof HandleFault) {         setHandleFault(true).     } }
false;public;0;3;;public List<RoutePolicyFactory> getRoutePolicyFactories() {     return routePolicyFactories. }
false;public;1;3;;public void setRoutePolicyFactories(List<RoutePolicyFactory> routePolicyFactories) {     this.routePolicyFactories = routePolicyFactories. }
false;public;1;3;;public void addRoutePolicyFactory(RoutePolicyFactory routePolicyFactory) {     getRoutePolicyFactories().add(routePolicyFactory). }
false;public;0;3;;public Set<LogListener> getLogListeners() {     return logListeners. }
false;public;1;3;;public void addLogListener(LogListener listener) {     logListeners.add(listener). }
false;public;1;3;;public void setStreamCaching(Boolean cache) {     this.streamCache = cache. }
false;public;0;3;;public Boolean isStreamCaching() {     return streamCache. }
false;public;1;3;;public void setTracing(Boolean tracing) {     this.trace = tracing. }
false;public;0;3;;public Boolean isTracing() {     return trace. }
false;public;0;3;;public Boolean isMessageHistory() {     return messageHistory. }
false;public;1;3;;public void setMessageHistory(Boolean messageHistory) {     this.messageHistory = messageHistory. }
false;public;1;3;;public void setLogMask(Boolean logMask) {     this.logMask = logMask. }
false;public;0;3;;public Boolean isLogMask() {     return logMask != null && logMask. }
false;public;0;3;;public Boolean isLogExhaustedMessageBody() {     return logExhaustedMessageBody. }
false;public;1;3;;public void setLogExhaustedMessageBody(Boolean logExhaustedMessageBody) {     this.logExhaustedMessageBody = logExhaustedMessageBody. }
false;public;0;3;;public Boolean isHandleFault() {     return handleFault. }
false;public;1;3;;public void setHandleFault(Boolean handleFault) {     this.handleFault = handleFault. }
false;public;0;3;;public Long getDelayer() {     return delay. }
false;public;1;3;;public void setDelayer(Long delay) {     this.delay = delay. }
false;public;0;3;;public ProducerTemplate createProducerTemplate() {     return createProducerTemplate(0). }
false;public;1;11;;public ProducerTemplate createProducerTemplate(int maximumCacheSize) {     DefaultProducerTemplate answer = new DefaultProducerTemplate(this).     answer.setMaximumCacheSize(maximumCacheSize).     // start it so its ready to use     try {         startService(answer).     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     }     return answer. }
false;public;0;3;;public FluentProducerTemplate createFluentProducerTemplate() {     return createFluentProducerTemplate(0). }
false;public;1;11;;public FluentProducerTemplate createFluentProducerTemplate(int maximumCacheSize) {     DefaultFluentProducerTemplate answer = new DefaultFluentProducerTemplate(this).     answer.setMaximumCacheSize(maximumCacheSize).     // start it so its ready to use     try {         startService(answer).     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     }     return answer. }
false;public;0;3;;public ConsumerTemplate createConsumerTemplate() {     return createConsumerTemplate(0). }
false;public;1;11;;public ConsumerTemplate createConsumerTemplate(int maximumCacheSize) {     DefaultConsumerTemplate answer = new DefaultConsumerTemplate(this).     answer.setMaximumCacheSize(maximumCacheSize).     // start it so its ready to use     try {         startService(answer).     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     }     return answer. }
false;public;3;6;;@Override public AsyncProcessor createMulticast(Collection<Processor> processors, ExecutorService executor, boolean shutdownExecutorService) {     return new MulticastProcessor(this, processors, null, true, executor, shutdownExecutorService, false, false, 0, null, false, false). }
false;public;0;3;;public ErrorHandlerBuilder getErrorHandlerFactory() {     return (ErrorHandlerBuilder) errorHandlerBuilder. }
false;public;1;3;;public void setErrorHandlerFactory(ErrorHandlerFactory errorHandlerFactory) {     this.errorHandlerBuilder = errorHandlerFactory. }
false;public;0;11;;public ScheduledExecutorService getErrorHandlerExecutorService() {     if (errorHandlerExecutorService == null) {         synchronized (lock) {             if (errorHandlerExecutorService == null) {                 // setup default thread pool for error handler                 errorHandlerExecutorService = createErrorHandlerExecutorService().             }         }     }     return errorHandlerExecutorService. }
false;protected;0;3;;protected ScheduledExecutorService createErrorHandlerExecutorService() {     return getExecutorServiceManager().newDefaultScheduledThreadPool("ErrorHandlerRedeliveryThreadPool", "ErrorHandlerRedeliveryTask"). }
false;public;1;3;;public void setErrorHandlerExecutorService(ScheduledExecutorService errorHandlerExecutorService) {     this.errorHandlerExecutorService = errorHandlerExecutorService. }
false;public;1;3;;public void setProducerServicePool(ServicePool<Producer> producerServicePool) {     this.producerServicePool = doAddService(producerServicePool). }
false;public;0;10;;public ServicePool<Producer> getProducerServicePool() {     if (producerServicePool == null) {         synchronized (lock) {             if (producerServicePool == null) {                 setProducerServicePool(createProducerServicePool()).             }         }     }     return producerServicePool. }
false;public;0;10;;public ServicePool<PollingConsumer> getPollingConsumerServicePool() {     if (pollingConsumerServicePool == null) {         synchronized (lock) {             if (pollingConsumerServicePool == null) {                 setPollingConsumerServicePool(createPollingConsumerServicePool()).             }         }     }     return pollingConsumerServicePool. }
false;public;1;3;;public void setPollingConsumerServicePool(ServicePool<PollingConsumer> pollingConsumerServicePool) {     this.pollingConsumerServicePool = doAddService(pollingConsumerServicePool). }
false;public;0;10;;public UnitOfWorkFactory getUnitOfWorkFactory() {     if (unitOfWorkFactory == null) {         synchronized (lock) {             if (unitOfWorkFactory == null) {                 setUnitOfWorkFactory(createUnitOfWorkFactory()).             }         }     }     return unitOfWorkFactory. }
false;public;1;3;;public void setUnitOfWorkFactory(UnitOfWorkFactory unitOfWorkFactory) {     this.unitOfWorkFactory = doAddService(unitOfWorkFactory). }
false;public;0;3;;public RuntimeEndpointRegistry getRuntimeEndpointRegistry() {     return runtimeEndpointRegistry. }
false;public;1;3;;public void setRuntimeEndpointRegistry(RuntimeEndpointRegistry runtimeEndpointRegistry) {     this.runtimeEndpointRegistry = doAddService(runtimeEndpointRegistry). }
false;public;0;7;;public String getUptime() {     long delta = getUptimeMillis().     if (delta == 0) {         return "".     }     return TimeUtils.printDuration(delta). }
false;public;0;6;;public long getUptimeMillis() {     if (startDate == null) {         return 0.     }     return new Date().getTime() - startDate.getTime(). }
false;public;0;10;;public String getVersion() {     if (version == null) {         synchronized (lock) {             if (version == null) {                 version = doGetVersion().             }         }     }     return version. }
false;private;0;38;;private String doGetVersion() {     String version = null.     InputStream is = null.     // try to load from maven properties first     try {         Properties p = new Properties().         is = getClass().getResourceAsStream("/META-INF/maven/org.apache.camel/camel-core/pom.properties").         if (is != null) {             p.load(is).             version = p.getProperty("version", "").         }     } catch (Exception e) {     // ignore     } finally {         if (is != null) {             IOHelper.close(is).         }     }     // fallback to using Java API     if (version == null) {         Package aPackage = getClass().getPackage().         if (aPackage != null) {             version = aPackage.getImplementationVersion().             if (version == null) {                 version = aPackage.getSpecificationVersion().             }         }     }     if (version == null) {         // we could not compute the version so use a blank         version = "".     }     return version. }
false;protected;0;47;;@Override protected void doSuspend() throws Exception {     EventHelper.notifyCamelContextSuspending(this).     log.info("Apache Camel {} (CamelContext: {}) is suspending", getVersion(), getName()).     StopWatch watch = new StopWatch().     // (so when we resume we only resume the routes which actually was suspended)     for (Map.Entry<String, RouteService> entry : getRouteServices().entrySet()) {         if (entry.getValue().getStatus().isStarted()) {             suspendedRouteServices.put(entry.getKey(), entry.getValue()).         }     }     // assemble list of startup ordering so routes can be shutdown accordingly     List<RouteStartupOrder> orders = new ArrayList<>().     for (Map.Entry<String, RouteService> entry : suspendedRouteServices.entrySet()) {         Route route = entry.getValue().getRoutes().iterator().next().         Integer order = entry.getValue().getRouteDefinition().getStartupOrder().         if (order == null) {             order = defaultRouteStartupOrder++.         }         orders.add(new DefaultRouteStartupOrder(order, route, entry.getValue())).     }     // suspend routes using the shutdown strategy so it can shutdown in correct order     // routes which doesn't support suspension will be stopped instead     getShutdownStrategy().suspend(this, orders).     // mark the route services as suspended or stopped     for (RouteService service : suspendedRouteServices.values()) {         if (routeSupportsSuspension(service.getId())) {             service.suspend().         } else {             service.stop().         }     }     watch.taken().     if (log.isInfoEnabled()) {         log.info("Apache Camel {} (CamelContext: {}) is suspended in {}", getVersion(), getName(), TimeUtils.printDuration(watch.taken())).     }     EventHelper.notifyCamelContextSuspended(this). }
false;protected;0;34;;@Override protected void doResume() throws Exception {     try {         EventHelper.notifyCamelContextResuming(this).         log.info("Apache Camel {} (CamelContext: {}) is resuming", getVersion(), getName()).         StopWatch watch = new StopWatch().         // start the suspended routes (do not check for route clashes, and indicate)         doStartOrResumeRoutes(suspendedRouteServices, false, true, true, false).         // mark the route services as resumed (will be marked as started) as well         for (RouteService service : suspendedRouteServices.values()) {             if (routeSupportsSuspension(service.getId())) {                 service.resume().             } else {                 service.start().             }         }         if (log.isInfoEnabled()) {             log.info("Resumed {} routes", suspendedRouteServices.size()).             log.info("Apache Camel {} (CamelContext: {}) resumed in {}", getVersion(), getName(), TimeUtils.printDuration(watch.taken())).         }         // and clear the list as they have been resumed         suspendedRouteServices.clear().         EventHelper.notifyCamelContextResumed(this).     } catch (Exception e) {         EventHelper.notifyCamelContextResumeFailed(this, e).         throw e.     } }
false;public;0;75;;@Override public void start() throws Exception {     try (MDCHelper mdcHelper = new MDCHelper()) {         init().         vetoStated.set(false).         startDate = new Date().         stopWatch.restart().         log.info("Apache Camel {} (CamelContext: {}) is starting", getVersion(), getName()).         // Start the route controller         ServiceHelper.startService(this.routeController).         doNotStartRoutesOnFirstStart = !firstStartDone && !isAutoStartup().         // then we may need to start the routes on the 2nd start call         if (firstStartDone && !isAutoStartup() && isStarted()) {             // invoke this logic to warm up the routes and if possible also start the routes             doStartOrResumeRoutes(routeServices, true, true, false, true).         }         // super will invoke doStart which will prepare internal services and start routes etc.         try {             firstStartDone = true.             super.start().         } catch (VetoCamelContextStartException e) {             // mark we veto against starting Camel             vetoStated.set(true).             if (e.isRethrowException()) {                 throw e.             } else {                 log.info("CamelContext ({}) vetoed to not start due {}", getName(), e.getMessage()).                 // swallow exception and change state of this camel context to stopped                 stop().                 return.             }         }         if (log.isInfoEnabled()) {             // count how many routes are actually started             int started = 0.             for (Route route : getRoutes()) {                 ServiceStatus status = getRouteStatus(route.getId()).                 if (status != null && status.isStarted()) {                     started++.                 }             }             final Collection<Route> controlledRoutes = getRouteController().getControlledRoutes().             if (controlledRoutes.isEmpty()) {                 log.info("Total {} routes, of which {} are started", getRoutes().size(), started).             } else {                 log.info("Total {} routes, of which {} are started, and {} are managed by RouteController: {}", getRoutes().size(), started, controlledRoutes.size(), getRouteController().getClass().getName()).             }             log.info("Apache Camel {} (CamelContext: {}) started in {}", getVersion(), getName(), TimeUtils.printDuration(stopWatch.taken())).         }         // okay the routes has been started so emit event that CamelContext has started (here at the end)         EventHelper.notifyCamelContextStarted(this).         // now call the startup listeners where the routes has been started         for (StartupListener startup : startupListeners) {             if (startup instanceof ExtendedStartupListener) {                 ((ExtendedStartupListener) startup).onCamelContextFullyStarted(this, isStarted()).             }         }     } }
false;public;0;6;;@Override public void stop() throws Exception {     try (MDCHelper mdcHelper = new MDCHelper()) {         super.stop().     } }
false;public;0;6;;@Override public void suspend() throws Exception {     try (MDCHelper mdcHelper = new MDCHelper()) {         super.suspend().     } }
false;public;0;6;;@Override public void resume() throws Exception {     try (MDCHelper mdcHelper = new MDCHelper()) {         super.resume().     } }
false;public;0;6;;@Override public void shutdown() throws Exception {     try (MDCHelper mdcHelper = new MDCHelper()) {         super.shutdown().     } }
false;protected,synchronized;0;12;;// Implementation methods // ----------------------------------------------------------------------- protected synchronized void doStart() throws Exception {     doWithDefinedClassLoader(() -> {         try {             doStartCamel().         } catch (Exception e) {             // fire event that we failed to start             EventHelper.notifyCamelContextStartupFailed(AbstractCamelContext.this, e).             // rethrow cause             throw e.         }     }). }
false;private;1;12;;private <T extends Throwable> void doWithDefinedClassLoader(ThrowingRunnable<T> callable) throws T {     ClassLoader tccl = Thread.currentThread().getContextClassLoader().     try {         // Using the ApplicationClassLoader as the default for TCCL         if (applicationContextClassLoader != null) {             Thread.currentThread().setContextClassLoader(applicationContextClassLoader).         }         callable.run().     } finally {         Thread.currentThread().setContextClassLoader(tccl).     } }
false;protected;0;184;;protected void doStartCamel() throws Exception {     // custom properties may use property placeholders so resolve those early on     if (globalOptions != null && !globalOptions.isEmpty()) {         for (Map.Entry<String, String> entry : globalOptions.entrySet()) {             String key = entry.getKey().             String value = entry.getValue().             if (value != null) {                 String replaced = resolvePropertyPlaceholders(value).                 if (!value.equals(replaced)) {                     if (log.isDebugEnabled()) {                         log.debug("Camel property with key {} replaced value from {} -> {}", key, value, replaced).                     }                     entry.setValue(replaced).                 }             }         }     }     if (log.isDebugEnabled()) {         log.debug("Using ClassResolver={}, PackageScanClassResolver={}, ApplicationContextClassLoader={}, RouteController={}", getClassResolver(), getPackageScanClassResolver(), getApplicationContextClassLoader(), getRouteController()).     }     if (isStreamCaching()) {         log.info("StreamCaching is enabled on CamelContext: {}", getName()).     }     if (isTracing()) {         // tracing is added in the DefaultChannel so we can enable it on the fly         log.info("Tracing is enabled on CamelContext: {}", getName()).     }     if (isUseMDCLogging()) {         // log if MDC has been enabled         log.info("MDC logging is enabled on CamelContext: {}", getName()).     }     if (isHandleFault()) {         // only add a new handle fault if not already configured         if (HandleFault.getHandleFault(this) == null) {             log.info("HandleFault is enabled on CamelContext: {}", getName()).             addInterceptStrategy(new HandleFault()).         }     }     if (getDelayer() != null && getDelayer() > 0) {         log.info("Delayer is enabled with: {} ms. on CamelContext: {}", getDelayer(), getName()).     }     // register debugger     if (getDebugger() != null) {         log.info("Debugger: {} is enabled on CamelContext: {}", getDebugger(), getName()).         addInterceptStrategy(new Debug(getDebugger())).     }     // start management strategy before lifecycles are started     ManagementStrategy managementStrategy = getManagementStrategy().     startService(managementStrategy).     // start lifecycle strategies     ServiceHelper.startService(lifecycleStrategies).     Iterator<LifecycleStrategy> it = lifecycleStrategies.iterator().     while (it.hasNext()) {         LifecycleStrategy strategy = it.next().         try {             strategy.onContextStart(this).         } catch (VetoCamelContextStartException e) {             // okay we should not start Camel since it was vetoed             log.warn("Lifecycle strategy vetoed starting CamelContext ({}) due: {}", getName(), e.getMessage()).             throw e.         } catch (Exception e) {             log.warn("Lifecycle strategy " + strategy + " failed starting CamelContext ({}) due: {}", getName(), e.getMessage()).             throw e.         }     }     // start notifiers as services     for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {         if (notifier instanceof Service) {             Service service = (Service) notifier.             for (LifecycleStrategy strategy : lifecycleStrategies) {                 strategy.onServiceAdd(this, service, null).             }             startService((Service) notifier).         }     }     // must let some bootstrap service be started before we can notify the starting event     EventHelper.notifyCamelContextStarting(this).     forceLazyInitialization().     if (reloadStrategy != null) {         log.info("Using ReloadStrategy: {}", reloadStrategy).         addService(reloadStrategy, true, true).     }     // Start runtime catalog     getExtension(RuntimeCamelCatalog.class).     // re-create endpoint registry as the cache size limit may be set after the constructor of this instance was called.     // and we needed to create endpoints up-front as it may be accessed before this context is started     endpoints = doAddService(createEndpointRegistry(endpoints)).     // Initialize declarative transformer registry     transformerRegistry = doAddService(createTransformerRegistry(transformers)).     // Initialize declarative validator registry     validatorRegistry = doAddService(createValidatorRegistry(validators)).     // optimised to not include runtimeEndpointRegistry unlesstartServices its enabled or JMX statistics is in extended mode     if (runtimeEndpointRegistry == null && getManagementStrategy() != null && getManagementStrategy().getManagementAgent() != null) {         Boolean isEnabled = getManagementStrategy().getManagementAgent().getEndpointRuntimeStatisticsEnabled().         boolean isExtended = getManagementStrategy().getManagementAgent().getStatisticsLevel().isExtended().         // extended mode is either if we use Extended statistics level or the option is explicit enabled         boolean extended = isExtended || isEnabled != null && isEnabled.         if (extended) {             runtimeEndpointRegistry = new DefaultRuntimeEndpointRegistry().         }     }     if (runtimeEndpointRegistry != null) {         if (runtimeEndpointRegistry instanceof EventNotifier) {             getManagementStrategy().addEventNotifier((EventNotifier) runtimeEndpointRegistry).         }         addService(runtimeEndpointRegistry, true, true).     }     // eager lookup any configured properties component to avoid subsequent lookup attempts which may impact performance     // due we use properties component for property placeholder resolution at runtime     PropertiesComponent existing = getPropertiesComponent(false).     if (existing != null) {         // store reference to the existing properties component         propertiesComponent = existing.     }     // start components     startServices(components.values()).     // start the route definitions before the routes is started     startRouteDefinitions(routeDefinitions).     if (isUseDataType()) {         // log if DataType has been enabled         log.info("Message DataType is enabled on CamelContext: {}", getName()).     }     // is there any stream caching enabled then log an info about this and its limit of spooling to disk, so people is aware of this     boolean streamCachingInUse = isStreamCaching().     if (!streamCachingInUse) {         for (RouteDefinition route : routeDefinitions) {             Boolean routeCache = CamelContextHelper.parseBoolean(this, route.getStreamCache()).             if (routeCache != null && routeCache) {                 streamCachingInUse = true.                 break.             }         }     }     if (streamCachingInUse) {         // stream caching is in use so enable the strategy         getStreamCachingStrategy().setEnabled(true).     } else {         // log if stream caching is not in use as this can help people to enable it if they use streams         log.info("StreamCaching is not in use. If using streams then its recommended to enable stream caching." + " See more details at http://camel.apache.org/stream-caching.html").     }     if (isAllowUseOriginalMessage()) {         log.debug("AllowUseOriginalMessage enabled because UseOriginalMessage is in use").     }     log.debug("Using HeadersMapFactory: {}", getHeadersMapFactory()).     if (!getHeadersMapFactory().isCaseInsensitive()) {         log.info("HeadersMapFactory: {} is case-sensitive which can cause problems for protocols such as HTTP based, which rely on case-insensitive headers.", getHeadersMapFactory()).     }     // start routes     if (doNotStartRoutesOnFirstStart) {         log.debug("Skip starting routes as CamelContext has been configured with autoStartup=false").     }     // invoke this logic to warmup the routes and if possible also start the routes     doStartOrResumeRoutes(routeServices, true, !doNotStartRoutesOnFirstStart, false, true). // starting will continue in the start method }
false;protected,synchronized;0;103;;protected synchronized void doStop() throws Exception {     stopWatch.restart().     log.info("Apache Camel {} (CamelContext: {}) is shutting down", getVersion(), getName()).     EventHelper.notifyCamelContextStopping(this).     // Stop the route controller     ServiceHelper.stopAndShutdownService(this.routeController).     // stop route inputs in the same order as they was started so we stop the very first inputs first     try {         // force shutting down routes as they may otherwise cause shutdown to hang         shutdownStrategy.shutdownForced(this, getRouteStartupOrder()).     } catch (Throwable e) {         log.warn("Error occurred while shutting down routes. This exception will be ignored.", e).     }     // shutdown await manager to trigger interrupt of blocked threads to attempt to free these threads graceful     shutdownServices(asyncProcessorAwaitManager).     routeStartupOrder.sort(Comparator.comparingInt(RouteStartupOrder::getStartupOrder).reversed()).     List<RouteService> list = new ArrayList<>().     for (RouteStartupOrder startupOrder : routeStartupOrder) {         DefaultRouteStartupOrder order = (DefaultRouteStartupOrder) startupOrder.         RouteService routeService = order.getRouteService().         list.add(routeService).     }     shutdownServices(list, false).     // do not clear route services or startup listeners as we can start Camel again and get the route back as before     routeStartupOrder.clear().     // but clear any suspend routes     suspendedRouteServices.clear().     // which we need to stop after the routes, as a POJO consumer is essentially a route also     for (Service service : servicesToStop) {         if (service instanceof Consumer) {             shutdownServices(service).         }     }     // shutdown default error handler thread pool     if (errorHandlerExecutorService != null) {         // force shutting down the thread pool         getExecutorServiceManager().shutdownNow(errorHandlerExecutorService).         errorHandlerExecutorService = null.     }     // shutdown debugger     ServiceHelper.stopAndShutdownService(getDebugger()).     shutdownServices(endpoints.values()).     endpoints.clear().     shutdownServices(components.values()).     components.clear().     shutdownServices(languages.values()).     languages.clear().     try {         for (LifecycleStrategy strategy : lifecycleStrategies) {             strategy.onContextStop(this).         }     } catch (Throwable e) {         log.warn("Error occurred while stopping lifecycle strategies. This exception will be ignored.", e).     }     // shutdown services as late as possible     shutdownServices(servicesToStop).     servicesToStop.clear().     // must notify that we are stopped before stopping the management strategy     EventHelper.notifyCamelContextStopped(this).     // stop the notifier service     for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {         shutdownServices(notifier).     }     // shutdown executor service and management as the last one     shutdownServices(executorServiceManager).     shutdownServices(managementStrategy).     shutdownServices(managementMBeanAssembler).     shutdownServices(lifecycleStrategies).     // do not clear lifecycleStrategies as we can start Camel again and get the route back as before     // stop the lazy created so they can be re-created on restart     forceStopLazyInitialization().     // stop to clear introspection cache     IntrospectionSupport.stop().     if (log.isInfoEnabled()) {         log.info("Apache Camel " + getVersion() + " (CamelContext: " + getName() + ") uptime {}", getUptime()).         log.info("Apache Camel {} (CamelContext: {}) is shutdown in {}", getVersion(), getName(), TimeUtils.printDuration(stopWatch.taken())).     }     // and clear start date     startDate = null. }
true;protected;5;35;/**  * Starts or resumes the routes  *  * @param routeServices  the routes to start (will only start a route if its not already started)  * @param checkClash     whether to check for startup ordering clash  * @param startConsumer  whether the route consumer should be started. Can be used to warmup the route without starting the consumer.  * @param resumeConsumer whether the route consumer should be resumed.  * @param addingRoutes   whether we are adding new routes  * @throws Exception is thrown if error starting routes  */ ;/**  * Starts or resumes the routes  *  * @param routeServices  the routes to start (will only start a route if its not already started)  * @param checkClash     whether to check for startup ordering clash  * @param startConsumer  whether the route consumer should be started. Can be used to warmup the route without starting the consumer.  * @param resumeConsumer whether the route consumer should be resumed.  * @param addingRoutes   whether we are adding new routes  * @throws Exception is thrown if error starting routes  */ protected void doStartOrResumeRoutes(Map<String, RouteService> routeServices, boolean checkClash, boolean startConsumer, boolean resumeConsumer, boolean addingRoutes) throws Exception {     isStartingRoutes.set(true).     try {         // filter out already started routes         Map<String, RouteService> filtered = new LinkedHashMap<>().         for (Map.Entry<String, RouteService> entry : routeServices.entrySet()) {             boolean startable = false.             Consumer consumer = entry.getValue().getRoutes().iterator().next().getConsumer().             if (consumer instanceof SuspendableService) {                 // consumer could be suspended, which is not reflected in the RouteService status                 startable = ((SuspendableService) consumer).isSuspended().             }             if (!startable && consumer instanceof StatefulService) {                 // consumer could be stopped, which is not reflected in the RouteService status                 startable = ((StatefulService) consumer).getStatus().isStartable().             } else if (!startable) {                 // no consumer so use state from route service                 startable = entry.getValue().getStatus().isStartable().             }             if (startable) {                 filtered.put(entry.getKey(), entry.getValue()).             }         }         // the context is in last phase of staring, so lets start the routes         safelyStartRouteServices(checkClash, startConsumer, resumeConsumer, addingRoutes, filtered.values()).     } finally {         isStartingRoutes.remove().     } }
false;protected;1;7;;protected boolean routeSupportsSuspension(String routeId) {     RouteService routeService = routeServices.get(routeId).     if (routeService != null) {         return routeService.getRoutes().iterator().next().supportsSuspension().     }     return false. }
false;private;1;16;;private void shutdownServices(Object service) {     // allow us to do custom work before delegating to service helper     try {         if (service instanceof Service) {             ServiceHelper.stopAndShutdownService(service).         } else if (service instanceof Collection) {             ServiceHelper.stopAndShutdownServices((Collection<?>) service).         }     } catch (Throwable e) {         log.warn("Error occurred while shutting down service: " + service + ". This exception will be ignored.", e).         // fire event         EventHelper.notifyServiceStopFailure(this, service, e).     } }
false;private;1;4;;private void shutdownServices(Collection<?> services) {     // reverse stopping by default     shutdownServices(services, true). }
false;private;2;12;;private void shutdownServices(Collection<?> services, boolean reverse) {     Collection<?> list = services.     if (reverse) {         List<Object> reverseList = new ArrayList<>(services).         Collections.reverse(reverseList).         list = reverseList.     }     for (Object service : list) {         shutdownServices(service).     } }
false;private;1;15;;private void startService(Service service) throws Exception {     // camel context has been started     if (service instanceof StartupListener) {         StartupListener listener = (StartupListener) service.         addStartupListener(listener).     }     if (service instanceof CamelContextAware) {         CamelContextAware aware = (CamelContextAware) service.         aware.setCamelContext(this).     }     service.start(). }
false;private;1;7;;private void startServices(Collection<?> services) throws Exception {     for (Object element : services) {         if (element instanceof Service) {             startService((Service) element).         }     } }
false;private;1;11;;private void stopServices(Object service) throws Exception {     // allow us to do custom work before delegating to service helper     try {         ServiceHelper.stopService(service).     } catch (Exception e) {         // fire event         EventHelper.notifyServiceStopFailure(this, service, e).         // rethrow to signal error with stopping         throw e.     } }
false;protected;1;7;;protected void startRouteDefinitions(Collection<RouteDefinition> list) throws Exception {     if (list != null) {         for (RouteDefinition route : list) {             startRoute(route).         }     } }
true;protected,synchronized;2;31;/**  * Starts the given route service  */ ;/**  * Starts the given route service  */ protected synchronized void startRouteService(RouteService routeService, boolean addingRoutes) throws Exception {     // we may already be starting routes so remember this, so we can unset accordingly in finally block     boolean alreadyStartingRoutes = isStartingRoutes().     if (!alreadyStartingRoutes) {         isStartingRoutes.set(true).     }     try {         // the route service could have been suspended, and if so then resume it instead         if (routeService.getStatus().isSuspended()) {             resumeRouteService(routeService).         } else {             // start the route service             routeServices.put(routeService.getId(), routeService).             if (shouldStartRoutes()) {                 // this method will log the routes being started                 safelyStartRouteServices(true, true, true, false, addingRoutes, routeService).                 // start route services if it was configured to auto startup and we are not adding routes                 boolean autoStartup = routeService.getRouteDefinition().isAutoStartup(this) && this.isAutoStartup().                 if (!addingRoutes || autoStartup) {                     // start the route since auto start is enabled or we are starting a route (not adding new routes)                     routeService.start().                 }             }         }     } finally {         if (!alreadyStartingRoutes) {             isStartingRoutes.remove().         }     } }
true;protected,synchronized;1;14;/**  * Resumes the given route service  */ ;/**  * Resumes the given route service  */ protected synchronized void resumeRouteService(RouteService routeService) throws Exception {     // the route service could have been stopped, and if so then start it instead     if (!routeService.getStatus().isSuspended()) {         startRouteService(routeService, false).     } else {         // resume the route service         if (shouldStartRoutes()) {             // this method will log the routes being started             safelyStartRouteServices(true, false, true, true, false, routeService).             // must resume route service as well             routeService.resume().         }     } }
false;protected,synchronized;2;4;;protected synchronized void stopRouteService(RouteService routeService, boolean removingRoutes) throws Exception {     routeService.setRemovingRoutes(removingRoutes).     stopRouteService(routeService). }
false;protected;2;9;;protected void logRouteState(Route route, String state) {     if (log.isInfoEnabled()) {         if (route.getConsumer() != null) {             log.info("Route: {} is {}, was consuming from: {}", route.getId(), state, route.getConsumer().getEndpoint()).         } else {             log.info("Route: {} is {}.", route.getId(), state).         }     } }
false;protected,synchronized;1;6;;protected synchronized void stopRouteService(RouteService routeService) throws Exception {     routeService.stop().     for (Route route : routeService.getRoutes()) {         logRouteState(route, "stopped").     } }
false;protected,synchronized;1;6;;protected synchronized void shutdownRouteService(RouteService routeService) throws Exception {     routeService.shutdown().     for (Route route : routeService.getRoutes()) {         logRouteState(route, "shutdown and removed").     } }
false;protected,synchronized;1;7;;protected synchronized void suspendRouteService(RouteService routeService) throws Exception {     routeService.setRemovingRoutes(false).     routeService.suspend().     for (Route route : routeService.getRoutes()) {         logRouteState(route, "suspended").     } }
true;protected,synchronized;5;56;/**  * Starts the routes services in a proper manner which ensures the routes will be started in correct order,  * check for clash and that the routes will also be shutdown in correct order as well.  * <p/>  * This method <b>must</b> be used to start routes in a safe manner.  *  * @param checkClash     whether to check for startup order clash  * @param startConsumer  whether the route consumer should be started. Can be used to warmup the route without starting the consumer.  * @param resumeConsumer whether the route consumer should be resumed.  * @param addingRoutes   whether we are adding new routes  * @param routeServices  the routes  * @throws Exception is thrown if error starting the routes  */ ;/**  * Starts the routes services in a proper manner which ensures the routes will be started in correct order,  * check for clash and that the routes will also be shutdown in correct order as well.  * <p/>  * This method <b>must</b> be used to start routes in a safe manner.  *  * @param checkClash     whether to check for startup order clash  * @param startConsumer  whether the route consumer should be started. Can be used to warmup the route without starting the consumer.  * @param resumeConsumer whether the route consumer should be resumed.  * @param addingRoutes   whether we are adding new routes  * @param routeServices  the routes  * @throws Exception is thrown if error starting the routes  */ protected synchronized void safelyStartRouteServices(boolean checkClash, boolean startConsumer, boolean resumeConsumer, boolean addingRoutes, Collection<RouteService> routeServices) throws Exception {     // list of inputs to start when all the routes have been prepared for starting     // we use a tree map so the routes will be ordered according to startup order defined on the route     Map<Integer, DefaultRouteStartupOrder> inputs = new TreeMap<>().     // figure out the order in which the routes should be started     for (RouteService routeService : routeServices) {         DefaultRouteStartupOrder order = doPrepareRouteToBeStarted(routeService).         // check for clash before we add it as input         if (checkClash) {             doCheckStartupOrderClash(order, inputs).         }         inputs.put(order.getStartupOrder(), order).     }     // warm up routes before we start them     doWarmUpRoutes(inputs, startConsumer).     // sort the startup listeners so they are started in the right order     startupListeners.sort(OrderedComparator.get()).     // (only the actual route consumer has not yet been started)     for (StartupListener startup : startupListeners) {         startup.onCamelContextStarted(this, isStarted()).     }     // because the consumers may also register startup listeners we need to reset     // the already started listeners     List<StartupListener> backup = new ArrayList<>(startupListeners).     startupListeners.clear().     // now start the consumers     if (startConsumer) {         if (resumeConsumer) {             // and now resume the routes             doResumeRouteConsumers(inputs, addingRoutes).         } else {             // and now start the routes             // and check for clash with multiple consumers of the same endpoints which is not allowed             doStartRouteConsumers(inputs, addingRoutes).         }     }     // sort the startup listeners so they are started in the right order     startupListeners.sort(OrderedComparator.get()).     // so we need to ensure they get started as well     for (StartupListener startup : startupListeners) {         startup.onCamelContextStarted(this, isStarted()).     }     // and add the previous started startup listeners to the list so we have them all     startupListeners.addAll(0, backup).     // inputs no longer needed     inputs.clear(). }
true;protected,synchronized;6;4;/**  * @see #safelyStartRouteServices(boolean,boolean,boolean,boolean,Collection)  */ ;/**  * @see #safelyStartRouteServices(boolean,boolean,boolean,boolean,Collection)  */ protected synchronized void safelyStartRouteServices(boolean forceAutoStart, boolean checkClash, boolean startConsumer, boolean resumeConsumer, boolean addingRoutes, RouteService... routeServices) throws Exception {     safelyStartRouteServices(checkClash, startConsumer, resumeConsumer, addingRoutes, Arrays.asList(routeServices)). }
false;private;1;13;;private DefaultRouteStartupOrder doPrepareRouteToBeStarted(RouteService routeService) {     // add the inputs from this route service to the list to start afterwards     // should be ordered according to the startup number     Integer startupOrder = routeService.getRouteDefinition().getStartupOrder().     if (startupOrder == null) {         // auto assign a default startup order         startupOrder = defaultRouteStartupOrder++.     }     // create holder object that contains information about this route to be started     Route route = routeService.getRoutes().iterator().next().     return new DefaultRouteStartupOrder(startupOrder, route, routeService). }
false;private;2;20;;private boolean doCheckStartupOrderClash(DefaultRouteStartupOrder answer, Map<Integer, DefaultRouteStartupOrder> inputs) throws FailedToStartRouteException {     // check for clash by startupOrder id     DefaultRouteStartupOrder other = inputs.get(answer.getStartupOrder()).     if (other != null && answer != other) {         String otherId = other.getRoute().getId().         throw new FailedToStartRouteException(answer.getRoute().getId(), "startupOrder clash. Route " + otherId + " already has startupOrder " + answer.getStartupOrder() + " configured which this route have as well. Please correct startupOrder to be unique among all your routes.").     }     // check in existing already started as well     for (RouteStartupOrder order : routeStartupOrder) {         String otherId = order.getRoute().getId().         if (answer.getRoute().getId().equals(otherId)) {         // its the same route id so skip clash check as its the same route (can happen when using suspend/resume)         } else if (answer.getStartupOrder() == order.getStartupOrder()) {             throw new FailedToStartRouteException(answer.getRoute().getId(), "startupOrder clash. Route " + otherId + " already has startupOrder " + answer.getStartupOrder() + " configured which this route have as well. Please correct startupOrder to be unique among all your routes.").         }     }     return true. }
false;private;2;13;;private void doWarmUpRoutes(Map<Integer, DefaultRouteStartupOrder> inputs, boolean autoStartup) throws Exception {     // now prepare the routes by starting its services before we start the input     for (Map.Entry<Integer, DefaultRouteStartupOrder> entry : inputs.entrySet()) {         // defer starting inputs till later as we want to prepare the routes by starting         // all their processors and child services etc.         // then later we open the floods to Camel by starting the inputs         // what this does is to ensure Camel is more robust on starting routes as all routes         // will then be prepared in time before we start inputs which will consume messages to be routed         RouteService routeService = entry.getValue().getRouteService().         log.debug("Warming up route id: {} having autoStartup={}", routeService.getId(), autoStartup).         routeService.warmUp().     } }
false;private;2;3;;private void doResumeRouteConsumers(Map<Integer, DefaultRouteStartupOrder> inputs, boolean addingRoutes) throws Exception {     doStartOrResumeRouteConsumers(inputs, true, addingRoutes). }
false;private;2;3;;private void doStartRouteConsumers(Map<Integer, DefaultRouteStartupOrder> inputs, boolean addingRoutes) throws Exception {     doStartOrResumeRouteConsumers(inputs, false, addingRoutes). }
false;private;3;102;;private void doStartOrResumeRouteConsumers(Map<Integer, DefaultRouteStartupOrder> inputs, boolean resumeOnly, boolean addingRoute) throws Exception {     List<Endpoint> routeInputs = new ArrayList<>().     for (Map.Entry<Integer, DefaultRouteStartupOrder> entry : inputs.entrySet()) {         Integer order = entry.getKey().         Route route = entry.getValue().getRoute().         RouteService routeService = entry.getValue().getRouteService().         // if we are starting camel, then skip routes which are configured to not be auto started         boolean autoStartup = routeService.getRouteDefinition().isAutoStartup(this) && this.isAutoStartup().         if (addingRoute && !autoStartup) {             log.info("Skipping starting of route {} as its configured with autoStartup=false", routeService.getId()).             continue.         }         // start the service         for (Consumer consumer : routeService.getInputs().values()) {             Endpoint endpoint = consumer.getEndpoint().             // check multiple consumer violation, with the other routes to be started             if (!doCheckMultipleConsumerSupportClash(endpoint, routeInputs)) {                 throw new FailedToStartRouteException(routeService.getId(), "Multiple consumers for the same endpoint is not allowed: " + endpoint).             }             // check for multiple consumer violations with existing routes which             // have already been started, or is currently starting             List<Endpoint> existingEndpoints = new ArrayList<>().             for (Route existingRoute : getRoutes()) {                 if (route.getId().equals(existingRoute.getId())) {                     // skip ourselves                     continue.                 }                 Endpoint existing = existingRoute.getEndpoint().                 ServiceStatus status = getRouteStatus(existingRoute.getId()).                 if (status != null && (status.isStarted() || status.isStarting())) {                     existingEndpoints.add(existing).                 }             }             if (!doCheckMultipleConsumerSupportClash(endpoint, existingEndpoints)) {                 throw new FailedToStartRouteException(routeService.getId(), "Multiple consumers for the same endpoint is not allowed: " + endpoint).             }             // start the consumer on the route             log.debug("Route: {} >>> {}", route.getId(), route).             if (resumeOnly) {                 log.debug("Resuming consumer (order: {}) on route: {}", order, route.getId()).             } else {                 log.debug("Starting consumer (order: {}) on route: {}", order, route.getId()).             }             if (resumeOnly && route.supportsSuspension()) {                 // if we are resuming and the route can be resumed                 ServiceHelper.resumeService(consumer).                 log.info("Route: {} resumed and consuming from: {}", route.getId(), endpoint).             } else {                 // when starting we should invoke the lifecycle strategies                 for (LifecycleStrategy strategy : lifecycleStrategies) {                     strategy.onServiceAdd(this, consumer, route).                 }                 try {                     startService(consumer).                     route.getProperties().remove("route.start.exception").                 } catch (Exception e) {                     route.getProperties().put("route.start.exception", e).                     throw e.                 }                 log.info("Route: {} started and consuming from: {}", route.getId(), endpoint).             }             routeInputs.add(endpoint).             // add to the order which they was started, so we know how to stop them in reverse order             // but only add if we haven't already registered it before (we dont want to double add when restarting)             boolean found = false.             for (RouteStartupOrder other : routeStartupOrder) {                 if (other.getRoute().getId().equals(route.getId())) {                     found = true.                     break.                 }             }             if (!found) {                 routeStartupOrder.add(entry.getValue()).             }         }         if (resumeOnly) {             routeService.resume().         } else {             // and start the route service (no need to start children as they are already warmed up)             try {                 routeService.start().                 route.getProperties().remove("route.start.exception").             } catch (Exception e) {                 route.getProperties().put("route.start.exception", e).                 throw e.             }         }     } }
false;private;2;19;;private boolean doCheckMultipleConsumerSupportClash(Endpoint endpoint, List<Endpoint> routeInputs) {     // is multiple consumers supported     boolean multipleConsumersSupported = false.     if (endpoint instanceof MultipleConsumersSupport) {         multipleConsumersSupported = ((MultipleConsumersSupport) endpoint).isMultipleConsumersSupported().     }     if (multipleConsumersSupported) {         // multiple consumer allowed, so return true         return true.     }     // check in progress list     if (routeInputs.contains(endpoint)) {         return false.     }     return true. }
true;protected;0;46;/**  * Force some lazy initialization to occur upfront before we start any  * components and create routes  */ ;/**  * Force some lazy initialization to occur upfront before we start any  * components and create routes  */ protected void forceLazyInitialization() {     if (initialization != Initialization.Lazy) {         getTypeConverter().         getTypeConverterRegistry().         getInjector().         getRegistry().         getLanguageResolver().         getExecutorServiceManager().         getInflightRepository().         getAsyncProcessorAwaitManager().         getShutdownStrategy().         getPackageScanClassResolver().         getProducerServicePool().         getPollingConsumerServicePool().         getRestRegistry().         if (isTypeConverterStatisticsEnabled() != null) {             getTypeConverterRegistry().getStatistics().setStatisticsEnabled(isTypeConverterStatisticsEnabled()).         }         // resolve simple language to initialize it         resolveLanguage("simple").         // Start runtime catalog         getExtension(RuntimeCamelCatalog.class).         if (initialization == Initialization.Eager) {             getExtension(HealthCheckRegistry.class).             getComponentResolver().             getDataFormatResolver().             getManagementStrategy().             getHeadersMapFactory().             getClassResolver().             getNodeIdFactory().             getProcessorFactory().             getMessageHistoryFactory().             getFactoryFinderResolver().             getDefaultFactoryFinder().             getStreamCachingStrategy().             getModelJAXBContextFactory().             getUuidGenerator().             getUnitOfWorkFactory().             getRouteController().         }     } }
true;protected;0;6;/**  * Force clear lazy initialization so they can be re-created on restart  */ ;/**  * Force clear lazy initialization so they can be re-created on restart  */ protected void forceStopLazyInitialization() {     injector = null.     languageResolver = null.     typeConverterRegistry = null.     typeConverter = null. }
true;protected;1;11;/**  * A pluggable strategy to allow an endpoint to be created without requiring  * a component to be its factory, such as for looking up the URI inside some  * {@link Registry}  *  * @param uri the uri for the endpoint to be created  * @return the newly created endpoint or null if it could not be resolved  */ ;/**  * A pluggable strategy to allow an endpoint to be created without requiring  * a component to be its factory, such as for looking up the URI inside some  * {@link Registry}  *  * @param uri the uri for the endpoint to be created  * @return the newly created endpoint or null if it could not be resolved  */ protected Endpoint createEndpoint(String uri) {     Object value = getRegistry().lookupByName(uri).     if (value instanceof Endpoint) {         return (Endpoint) value.     } else if (value instanceof Processor) {         return new ProcessorEndpoint(uri, this, (Processor) value).     } else if (value != null) {         return convertBeanToEndpoint(uri, value).     }     return null. }
true;protected;2;4;/**  * Strategy method for attempting to convert the bean from a {@link Registry} to an endpoint using  * some kind of transformation or wrapper  *  * @param uri  the uri for the endpoint (and name in the registry)  * @param bean the bean to be converted to an endpoint, which will be not null  * @return a new endpoint  */ ;/**  * Strategy method for attempting to convert the bean from a {@link Registry} to an endpoint using  * some kind of transformation or wrapper  *  * @param uri  the uri for the endpoint (and name in the registry)  * @param bean the bean to be converted to an endpoint, which will be not null  * @return a new endpoint  */ protected Endpoint convertBeanToEndpoint(String uri, Object bean) {     throw new IllegalArgumentException("uri: " + uri + " bean: " + bean + " could not be converted to an Endpoint"). }
true;protected;0;3;/**  * Should we start newly added routes?  */ ;/**  * Should we start newly added routes?  */ protected boolean shouldStartRoutes() {     return isStarted() && !isStarting(). }
true;public;0;3;/**  * Gets the properties component in use, eventually creating it.  */ ;/**  * Gets the properties component in use, eventually creating it.  */ public PropertiesComponent getPropertiesComponent() {     return getPropertiesComponent(true). }
false;public;1;24;;public PropertiesComponent getPropertiesComponent(boolean autoCreate) {     if (propertiesComponent == null && autoCreate) {         Object comp = ResolverHelper.lookupComponentInRegistryWithFallback(this, "properties").         if (comp == null) {             try {                 Class<?> type = getFactoryFinder(DefaultComponentResolver.RESOURCE_PATH).findClass("properties").                 if (type != null) {                     log.info("No existing PropertiesComponent has been configured, creating a new default PropertiesComponent with name: properties").                     comp = type.newInstance().                     globalOptions.put(PropertiesComponent.DEFAULT_CREATED, "true").                 }             } catch (Exception e) {                 throw new IllegalArgumentException("No Component registered for scheme: " + "properties", e).             }         }         if (comp instanceof PropertiesComponent) {             addComponent("properties", (PropertiesComponent) comp).         }         if (propertiesComponent == null) {             throw new IllegalStateException().         }     }     return propertiesComponent. }
false;public;1;3;;public void setDataFormats(Map<String, DataFormatDefinition> dataFormats) {     this.dataFormats = dataFormats. }
false;public;0;3;;public Map<String, DataFormatDefinition> getDataFormats() {     return dataFormats. }
false;public;0;4;;@Override public Map<String, String> getGlobalOptions() {     return globalOptions. }
false;public;1;3;;public void setGlobalOptions(Map<String, String> globalOptions) {     this.globalOptions = globalOptions. }
false;public;0;10;;public FactoryFinder getDefaultFactoryFinder() {     if (defaultFactoryFinder == null) {         synchronized (lock) {             if (defaultFactoryFinder == null) {                 defaultFactoryFinder = getFactoryFinderResolver().resolveDefaultFactoryFinder(getClassResolver()).             }         }     }     return defaultFactoryFinder. }
false;public;0;10;;public FactoryFinderResolver getFactoryFinderResolver() {     if (factoryFinderResolver == null) {         synchronized (lock) {             if (factoryFinderResolver == null) {                 factoryFinderResolver = createFactoryFinderResolver().             }         }     }     return factoryFinderResolver. }
false;public;1;3;;public void setFactoryFinderResolver(FactoryFinderResolver factoryFinderResolver) {     this.factoryFinderResolver = doAddService(factoryFinderResolver). }
false;public;1;3;;public FactoryFinder getFactoryFinder(String path) throws NoFactoryAvailableException {     return factories.computeIfAbsent(path, this::createFactoryFinder). }
false;protected;1;3;;protected FactoryFinder createFactoryFinder(String path) {     return getFactoryFinderResolver().resolveFactoryFinder(getClassResolver(), path). }
false;public;0;10;;public ClassResolver getClassResolver() {     if (classResolver == null) {         synchronized (lock) {             if (classResolver == null) {                 setClassResolver(createClassResolver()).             }         }     }     return classResolver. }
false;public;1;3;;public void setClassResolver(ClassResolver classResolver) {     this.classResolver = doAddService(classResolver). }
false;public;0;10;;public PackageScanClassResolver getPackageScanClassResolver() {     if (packageScanClassResolver == null) {         synchronized (lock) {             if (packageScanClassResolver == null) {                 setPackageScanClassResolver(createPackageScanClassResolver()).             }         }     }     return packageScanClassResolver. }
false;public;1;3;;public void setPackageScanClassResolver(PackageScanClassResolver packageScanClassResolver) {     this.packageScanClassResolver = doAddService(packageScanClassResolver). }
false;public;0;3;;public List<String> getComponentNames() {     return new ArrayList<>(components.keySet()). }
false;public;0;3;;public List<String> getLanguageNames() {     return new ArrayList<>(languages.keySet()). }
false;public;0;10;;public ModelJAXBContextFactory getModelJAXBContextFactory() {     if (modelJAXBContextFactory == null) {         synchronized (lock) {             if (modelJAXBContextFactory == null) {                 setModelJAXBContextFactory(createModelJAXBContextFactory()).             }         }     }     return modelJAXBContextFactory. }
false;public;1;3;;public void setModelJAXBContextFactory(final ModelJAXBContextFactory modelJAXBContextFactory) {     this.modelJAXBContextFactory = doAddService(modelJAXBContextFactory). }
false;public;0;10;;public NodeIdFactory getNodeIdFactory() {     if (nodeIdFactory == null) {         synchronized (lock) {             if (nodeIdFactory == null) {                 setNodeIdFactory(createNodeIdFactory()).             }         }     }     return nodeIdFactory. }
false;public;1;3;;public void setNodeIdFactory(NodeIdFactory idFactory) {     this.nodeIdFactory = doAddService(idFactory). }
false;public;0;3;;public ManagementStrategy getManagementStrategy() {     return managementStrategy. }
false;public;1;3;;public void setManagementStrategy(ManagementStrategy managementStrategy) {     this.managementStrategy = managementStrategy. }
false;public;0;11;;public void disableJMX() {     if (isNew()) {         disableJMX = true.     } else if (isInit()) {         disableJMX = true.         // we are still in initializing mode, so we can disable JMX, by setting up management again         setupManagement(null).     } else {         throw new IllegalStateException("Disabling JMX can only be done when CamelContext has not been started").     } }
false;public;0;3;;public boolean isJMXDisabled() {     return disableJMX. }
false;public;1;24;;public void setupManagement(Map<String, Object> options) {     ManagementStrategyFactory factory = new DefaultManagementStrategyFactory().     if (!isJMXDisabled()) {         try {             ServiceLoader<ManagementStrategyFactory> loader = ServiceLoader.load(ManagementStrategyFactory.class).             Iterator<ManagementStrategyFactory> iterator = loader.iterator().             if (iterator.hasNext()) {                 factory = iterator.next().             }         } catch (Exception e) {             log.warn("Cannot create JMX lifecycle strategy. Will fallback and disable JMX.", e).         }     }     log.debug("Setting up management with factory: {}", factory).     try {         ManagementStrategy strategy = factory.create(this, options).         LifecycleStrategy lifecycle = factory.createLifecycle(this).         factory.setupManagement(this, strategy, lifecycle).     } catch (Exception e) {         log.warn("Error setting up management due " + e.getMessage()).         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;public;0;10;;public InflightRepository getInflightRepository() {     if (inflightRepository == null) {         synchronized (lock) {             if (inflightRepository == null) {                 setInflightRepository(createInflightRepository()).             }         }     }     return inflightRepository. }
false;public;1;3;;public void setInflightRepository(InflightRepository repository) {     this.inflightRepository = doAddService(repository). }
false;public;0;10;;public AsyncProcessorAwaitManager getAsyncProcessorAwaitManager() {     if (asyncProcessorAwaitManager == null) {         synchronized (lock) {             if (asyncProcessorAwaitManager == null) {                 setAsyncProcessorAwaitManager(createAsyncProcessorAwaitManager()).             }         }     }     return asyncProcessorAwaitManager. }
false;public;1;3;;public void setAsyncProcessorAwaitManager(AsyncProcessorAwaitManager asyncProcessorAwaitManager) {     this.asyncProcessorAwaitManager = doAddService(asyncProcessorAwaitManager). }
false;public;1;3;;public void setAutoStartup(Boolean autoStartup) {     this.autoStartup = autoStartup. }
false;public;0;3;;public Boolean isAutoStartup() {     return autoStartup != null && autoStartup. }
false;public;0;3;;public Boolean isLoadTypeConverters() {     return loadTypeConverters != null && loadTypeConverters. }
false;public;1;3;;public void setLoadTypeConverters(Boolean loadTypeConverters) {     this.loadTypeConverters = loadTypeConverters. }
false;public;0;3;;public Boolean isTypeConverterStatisticsEnabled() {     return typeConverterStatisticsEnabled != null && typeConverterStatisticsEnabled. }
false;public;1;3;;public void setTypeConverterStatisticsEnabled(Boolean typeConverterStatisticsEnabled) {     this.typeConverterStatisticsEnabled = typeConverterStatisticsEnabled. }
false;public;0;3;;public Boolean isUseMDCLogging() {     return useMDCLogging != null && useMDCLogging. }
false;public;1;3;;public void setUseMDCLogging(Boolean useMDCLogging) {     this.useMDCLogging = useMDCLogging. }
false;public;0;3;;public Boolean isUseDataType() {     return useDataType. }
false;public;1;4;;@Override public void setUseDataType(Boolean useDataType) {     this.useDataType = useDataType. }
false;public;0;3;;public Boolean isUseBreadcrumb() {     return useBreadcrumb != null && useBreadcrumb. }
false;public;1;3;;public void setUseBreadcrumb(Boolean useBreadcrumb) {     this.useBreadcrumb = useBreadcrumb. }
false;public;0;3;;public ClassLoader getApplicationContextClassLoader() {     return applicationContextClassLoader. }
false;public;1;3;;public void setApplicationContextClassLoader(ClassLoader classLoader) {     applicationContextClassLoader = classLoader. }
false;public;0;10;;public DataFormatResolver getDataFormatResolver() {     if (dataFormatResolver == null) {         synchronized (lock) {             if (dataFormatResolver == null) {                 setDataFormatResolver(createDataFormatResolver()).             }         }     }     return dataFormatResolver. }
false;public;1;3;;public void setDataFormatResolver(DataFormatResolver dataFormatResolver) {     this.dataFormatResolver = doAddService(dataFormatResolver). }
false;public;1;10;;public DataFormat resolveDataFormat(String name) {     DataFormat answer = getDataFormatResolver().resolveDataFormat(name, this).     // inject CamelContext if aware     if (answer instanceof CamelContextAware) {         ((CamelContextAware) answer).setCamelContext(this).     }     return answer. }
false;public;1;10;;public DataFormat createDataFormat(String name) {     DataFormat answer = getDataFormatResolver().createDataFormat(name, this).     // inject CamelContext if aware     if (answer instanceof CamelContextAware) {         ((CamelContextAware) answer).setCamelContext(this).     }     return answer. }
false;public;1;8;;public DataFormatDefinition resolveDataFormatDefinition(String name) {     // lookup type and create the data format from it     DataFormatDefinition type = lookup(this, name, DataFormatDefinition.class).     if (type == null && getDataFormats() != null) {         type = getDataFormats().get(name).     }     return type. }
false;private,static;3;8;;private static <T> T lookup(CamelContext context, String ref, Class<T> type) {     try {         return context.getRegistry().lookupByNameAndType(ref, type).     } catch (Exception e) {         // need to ignore not same type and return it as null         return null.     } }
false;public;0;10;;public ShutdownStrategy getShutdownStrategy() {     if (shutdownStrategy == null) {         synchronized (lock) {             if (shutdownStrategy == null) {                 setShutdownStrategy(createShutdownStrategy()).             }         }     }     return shutdownStrategy. }
false;public;1;3;;public void setShutdownStrategy(ShutdownStrategy shutdownStrategy) {     this.shutdownStrategy = doAddService(shutdownStrategy). }
false;public;0;3;;public ShutdownRoute getShutdownRoute() {     return shutdownRoute. }
false;public;1;3;;public void setShutdownRoute(ShutdownRoute shutdownRoute) {     this.shutdownRoute = shutdownRoute. }
false;public;0;3;;public ShutdownRunningTask getShutdownRunningTask() {     return shutdownRunningTask. }
false;public;1;3;;public void setShutdownRunningTask(ShutdownRunningTask shutdownRunningTask) {     this.shutdownRunningTask = shutdownRunningTask. }
false;public;1;3;;public void setAllowUseOriginalMessage(Boolean allowUseOriginalMessage) {     this.allowUseOriginalMessage = allowUseOriginalMessage. }
false;public;0;3;;public Boolean isAllowUseOriginalMessage() {     return allowUseOriginalMessage != null && allowUseOriginalMessage. }
false;public;0;10;;public ExecutorServiceManager getExecutorServiceManager() {     if (executorServiceManager == null) {         synchronized (lock) {             if (executorServiceManager == null) {                 setExecutorServiceManager(createExecutorServiceManager()).             }         }     }     return this.executorServiceManager. }
false;public;1;4;;public void setExecutorServiceManager(ExecutorServiceManager executorServiceManager) {     // special for executorServiceManager as want to stop it manually so false in stopOnShutdown     this.executorServiceManager = doAddService(executorServiceManager, false). }
false;public;0;10;;public ProcessorFactory getProcessorFactory() {     if (processorFactory == null) {         synchronized (lock) {             if (processorFactory == null) {                 setProcessorFactory(createProcessorFactory()).             }         }     }     return processorFactory. }
false;public;1;3;;public void setProcessorFactory(ProcessorFactory processorFactory) {     this.processorFactory = doAddService(processorFactory). }
false;public;0;10;;public MessageHistoryFactory getMessageHistoryFactory() {     if (messageHistoryFactory == null) {         synchronized (lock) {             if (messageHistoryFactory == null) {                 setMessageHistoryFactory(createMessageHistoryFactory()).             }         }     }     return messageHistoryFactory. }
false;public;1;3;;public void setMessageHistoryFactory(MessageHistoryFactory messageHistoryFactory) {     this.messageHistoryFactory = doAddService(messageHistoryFactory). }
false;public;0;3;;public Debugger getDebugger() {     return debugger. }
false;public;1;6;;public void setDebugger(Debugger debugger) {     if (isStartingOrStarted()) {         throw new IllegalStateException("Can not set debugger on a started CamelContext").     }     this.debugger = doAddService(debugger). }
false;public;0;10;;public UuidGenerator getUuidGenerator() {     if (uuidGenerator == null) {         synchronized (lock) {             if (uuidGenerator == null) {                 setUuidGenerator(createUuidGenerator()).             }         }     }     return uuidGenerator. }
false;public;1;3;;public void setUuidGenerator(UuidGenerator uuidGenerator) {     this.uuidGenerator = doAddService(uuidGenerator). }
false;public;0;10;;public StreamCachingStrategy getStreamCachingStrategy() {     if (streamCachingStrategy == null) {         synchronized (lock) {             if (streamCachingStrategy == null) {                 setStreamCachingStrategy(createStreamCachingStrategy()).             }         }     }     return streamCachingStrategy. }
false;public;1;3;;public void setStreamCachingStrategy(StreamCachingStrategy streamCachingStrategy) {     this.streamCachingStrategy = doAddService(streamCachingStrategy, true, false). }
false;public;0;10;;public RestRegistry getRestRegistry() {     if (restRegistry == null) {         synchronized (lock) {             if (restRegistry == null) {                 setRestRegistry(createRestRegistry()).             }         }     }     return restRegistry. }
false;public;1;3;;public void setRestRegistry(RestRegistry restRegistry) {     this.restRegistry = doAddService(restRegistry). }
false;public;1;12;;@Override public String getGlobalOption(String key) {     String value = getGlobalOptions().get(key).     if (ObjectHelper.isNotEmpty(value)) {         try {             value = resolvePropertyPlaceholders(value).         } catch (Exception e) {             throw new RuntimeCamelException("Error getting global option: " + key, e).         }     }     return value. }
false;public;0;4;;@Override public ReloadStrategy getReloadStrategy() {     return reloadStrategy. }
false;public;1;4;;@Override public void setReloadStrategy(ReloadStrategy reloadStrategy) {     this.reloadStrategy = doAddService(reloadStrategy). }
false;public;1;4;;@Override public void setTransformers(List<TransformerDefinition> transformers) {     this.transformers = transformers. }
false;public;0;4;;@Override public List<TransformerDefinition> getTransformers() {     return transformers. }
false;public;1;4;;@Override public Transformer resolveTransformer(String scheme) {     return transformerRegistry.resolveTransformer(new TransformerKey(scheme)). }
false;public;2;4;;@Override public Transformer resolveTransformer(DataType from, DataType to) {     return transformerRegistry.resolveTransformer(new TransformerKey(from, to)). }
false;public;0;4;;@Override public TransformerRegistry<TransformerKey> getTransformerRegistry() {     return transformerRegistry. }
false;public;1;4;;@Override public void setValidators(List<ValidatorDefinition> validators) {     this.validators = validators. }
false;public;0;4;;@Override public List<ValidatorDefinition> getValidators() {     return validators. }
false;public;1;4;;@Override public Validator resolveValidator(DataType type) {     return validatorRegistry.resolveValidator(new ValidatorKey(type)). }
false;public;0;4;;@Override public ValidatorRegistry<ValidatorKey> getValidatorRegistry() {     return validatorRegistry. }
false;public;1;4;;@Override public void setSSLContextParameters(SSLContextParameters sslContextParameters) {     this.sslContextParameters = sslContextParameters. }
false;public;0;4;;@Override public SSLContextParameters getSSLContextParameters() {     return this.sslContextParameters. }
false;public;0;11;;@Override public HeadersMapFactory getHeadersMapFactory() {     if (headersMapFactory == null) {         synchronized (lock) {             if (headersMapFactory == null) {                 setHeadersMapFactory(createHeadersMapFactory()).             }         }     }     return headersMapFactory. }
false;public;1;4;;@Override public void setHeadersMapFactory(HeadersMapFactory headersMapFactory) {     this.headersMapFactory = doAddService(headersMapFactory). }
false;protected;0;3;;protected Map<String, RouteService> getRouteServices() {     return routeServices. }
true;public,static;1;4;/**  * Reset context counter to a preset value. Mostly used for tests to ensure a predictable getName()  *  * @param value new value for the context counter  */ ;/**  * Reset context counter to a preset value. Mostly used for tests to ensure a predictable getName()  *  * @param value new value for the context counter  */ public static void setContextCounter(int value) {     DefaultCamelContextNameStrategy.setCounter(value).     DefaultManagementNameStrategy.setCounter(value). }
false;public;0;4;;@Override public String toString() {     return "CamelContext(" + getName() + ")". }
false;public;0;10;;@Override public void close() {     if (isUseMDCLogging()) {         if (originalContextMap != null) {             MDC.setContextMap(originalContextMap).         } else {             MDC.clear().         }     } }
false;protected,abstract;0;1;;protected abstract StreamCachingStrategy createStreamCachingStrategy().
false;protected,abstract;0;1;;protected abstract TypeConverter createTypeConverter().
false;protected,abstract;0;1;;protected abstract TypeConverterRegistry createTypeConverterRegistry().
false;protected,abstract;0;1;;protected abstract Injector createInjector().
false;protected,abstract;0;1;;protected abstract ComponentResolver createComponentResolver().
false;protected,abstract;0;1;;protected abstract Registry createRegistry().
false;protected,abstract;0;1;;protected abstract UuidGenerator createUuidGenerator().
false;protected,abstract;0;1;;protected abstract ModelJAXBContextFactory createModelJAXBContextFactory().
false;protected,abstract;0;1;;protected abstract NodeIdFactory createNodeIdFactory().
false;protected,abstract;0;1;;protected abstract FactoryFinderResolver createFactoryFinderResolver().
false;protected,abstract;0;1;;protected abstract ClassResolver createClassResolver().
false;protected,abstract;0;1;;protected abstract ProcessorFactory createProcessorFactory().
false;protected,abstract;0;1;;protected abstract DataFormatResolver createDataFormatResolver().
false;protected,abstract;0;1;;protected abstract MessageHistoryFactory createMessageHistoryFactory().
false;protected,abstract;0;1;;protected abstract InflightRepository createInflightRepository().
false;protected,abstract;0;1;;protected abstract AsyncProcessorAwaitManager createAsyncProcessorAwaitManager().
false;protected,abstract;0;1;;protected abstract RouteController createRouteController().
false;protected,abstract;0;1;;protected abstract HealthCheckRegistry createHealthCheckRegistry().
false;protected,abstract;0;1;;protected abstract ShutdownStrategy createShutdownStrategy().
false;protected,abstract;0;1;;protected abstract PackageScanClassResolver createPackageScanClassResolver().
false;protected,abstract;0;1;;protected abstract ExecutorServiceManager createExecutorServiceManager().
false;protected,abstract;0;1;;protected abstract ServicePool<Producer> createProducerServicePool().
false;protected,abstract;0;1;;protected abstract ServicePool<PollingConsumer> createPollingConsumerServicePool().
false;protected,abstract;0;1;;protected abstract UnitOfWorkFactory createUnitOfWorkFactory().
false;protected,abstract;0;1;;protected abstract RuntimeCamelCatalog createRuntimeCamelCatalog().
false;protected,abstract;0;1;;protected abstract CamelContextNameStrategy createCamelContextNameStrategy().
false;protected,abstract;0;1;;protected abstract ManagementNameStrategy createManagementNameStrategy().
false;protected,abstract;0;1;;protected abstract HeadersMapFactory createHeadersMapFactory().
false;protected,abstract;0;1;;protected abstract LanguageResolver createLanguageResolver().
false;protected,abstract;0;1;;protected abstract RestRegistry createRestRegistry().
false;protected,abstract;1;1;;protected abstract EndpointRegistry<EndpointKey> createEndpointRegistry(Map<EndpointKey, Endpoint> endpoints).
false;protected,abstract;1;1;;protected abstract ValidatorRegistry<ValidatorKey> createValidatorRegistry(List<ValidatorDefinition> validators) throws Exception.
false;protected,abstract;1;1;;protected abstract TransformerRegistry<TransformerKey> createTransformerRegistry(List<TransformerDefinition> transformers) throws Exception.
