commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Creates a new file based repository using as 1st level cache  *  * @param fileStore the file store  */ ;/**  * Creates a new file based repository using as 1st level cache  *  * @param fileStore the file store  */ public static FileStateRepository fileStateRepository(File fileStore) {     return fileStateRepository(fileStore, new HashMap<>()). }
true;public,static;2;5;/**  * Creates a new file based repository using a {@link HashMap} as 1st level cache.  *  * @param fileStore the file store  * @param maxFileStoreSize the max size in bytes for the fileStore file  */ ;/**  * Creates a new file based repository using a {@link HashMap} as 1st level cache.  *  * @param fileStore the file store  * @param maxFileStoreSize the max size in bytes for the fileStore file  */ public static FileStateRepository fileStateRepository(File fileStore, long maxFileStoreSize) {     FileStateRepository repository = new FileStateRepository(fileStore, new HashMap<>()).     repository.setMaxFileStoreSize(maxFileStoreSize).     return repository. }
true;public,static;2;3;/**  * Creates a new file based repository using the given {@link java.util.Map} as 1st level cache.  * <p/>  * Care should be taken to use a suitable underlying {@link java.util.Map} to avoid this class being a  * memory leak.  *  * @param store the file store  * @param cache the cache to use as 1st level cache  */ ;/**  * Creates a new file based repository using the given {@link java.util.Map} as 1st level cache.  * <p/>  * Care should be taken to use a suitable underlying {@link java.util.Map} to avoid this class being a  * memory leak.  *  * @param store the file store  * @param cache the cache to use as 1st level cache  */ public static FileStateRepository fileStateRepository(File store, Map<String, String> cache) {     return new FileStateRepository(store, cache). }
false;public;2;23;;@Override @ManagedOperation(description = "Adds the value of the given key to the store") public void setState(String key, String value) {     if (key.contains(KEY_VALUE_DELIMITER)) {         throw new IllegalArgumentException("Key " + key + " contains illegal character: " + KEY_VALUE_DELIMITER).     }     if (key.contains(STORE_DELIMITER)) {         throw new IllegalArgumentException("Key " + key + " contains illegal character: <newline>").     }     if (value.contains(STORE_DELIMITER)) {         throw new IllegalArgumentException("Value " + value + " contains illegal character: <newline>").     }     synchronized (cache) {         cache.put(key, value).         if (fileStore.length() < maxFileStoreSize) {             // just append to store             appendToStore(key, value).         } else {             // trunk store and flush the cache             trunkStore().         }     } }
false;public;1;7;;@Override @ManagedOperation(description = "Gets the value of the given key from store") public String getState(String key) {     synchronized (cache) {         return cache.get(key).     } }
true;public,synchronized;0;9;/**  * Resets and clears the store to force it to reload from file  */ ;/**  * Resets and clears the store to force it to reload from file  */ @ManagedOperation(description = "Reset and reloads the file store") public synchronized void reset() throws IOException {     synchronized (cache) {         // trunk and clear, before we reload the store         trunkStore().         cache.clear().         loadStore().     } }
true;private;2;32;/**  * Appends the {@code <key,value>} pair to the file store  *  * @param key the state key  */ ;/**  * Appends the {@code <key,value>} pair to the file store  *  * @param key the state key  */ private void appendToStore(String key, String value) {     if (log.isDebugEnabled()) {         log.debug("Appending {}={} to state filestore: {}", key, value, fileStore).     }     FileOutputStream fos = null.     try {         // create store parent directory if missing         File storeParentDirectory = fileStore.getParentFile().         if (storeParentDirectory != null && !storeParentDirectory.exists()) {             log.info("Parent directory of file store {} doesn't exist. Creating.", fileStore).             if (fileStore.getParentFile().mkdirs()) {                 log.info("Parent directory of file store {} successfully created.", fileStore).             } else {                 log.warn("Parent directory of file store {} cannot be created.", fileStore).             }         }         // create store if missing         if (!fileStore.exists()) {             FileUtil.createNewFile(fileStore).         }         // append to store         fos = new FileOutputStream(fileStore, true).         fos.write(key.getBytes()).         fos.write(KEY_VALUE_DELIMITER.getBytes()).         fos.write(value.getBytes()).         fos.write(STORE_DELIMITER.getBytes()).     } catch (IOException e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } finally {         IOHelper.close(fos, "Appending to file state repository", log).     } }
true;protected;0;17;/**  * Trunks the file store when the max store size is hit by rewriting the 1st level cache  * to the file store.  */ ;/**  * Trunks the file store when the max store size is hit by rewriting the 1st level cache  * to the file store.  */ protected void trunkStore() {     log.info("Trunking state filestore: {}", fileStore).     FileOutputStream fos = null.     try {         fos = new FileOutputStream(fileStore).         for (Map.Entry<String, String> entry : cache.entrySet()) {             fos.write(entry.getKey().getBytes()).             fos.write(KEY_VALUE_DELIMITER.getBytes()).             fos.write(entry.getValue().getBytes()).             fos.write(STORE_DELIMITER.getBytes()).         }     } catch (IOException e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } finally {         IOHelper.close(fos, "Trunking file state repository", log).     } }
true;protected;0;31;/**  * Loads the given file store into the 1st level cache  */ ;/**  * Loads the given file store into the 1st level cache  */ protected void loadStore() throws IOException {     // auto create starting directory if needed     if (!fileStore.exists()) {         log.debug("Creating filestore: {}", fileStore).         File parent = fileStore.getParentFile().         if (parent != null) {             parent.mkdirs().         }         boolean created = FileUtil.createNewFile(fileStore).         if (!created) {             throw new IOException("Cannot create filestore: " + fileStore).         }     }     log.trace("Loading to 1st level cache from state filestore: {}", fileStore).     cache.clear().     try (Scanner scanner = new Scanner(fileStore, null, STORE_DELIMITER)) {         while (scanner.hasNext()) {             String line = scanner.next().             int separatorIndex = line.indexOf(KEY_VALUE_DELIMITER).             String key = line.substring(0, separatorIndex).             String value = line.substring(separatorIndex + KEY_VALUE_DELIMITER.length()).             cache.put(key, value).         }     } catch (IOException e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     }     log.debug("Loaded {} to the 1st level cache from state filestore: {}", cache.size(), fileStore). }
false;protected;0;9;;@Override protected void doStart() throws Exception {     ObjectHelper.notNull(fileStore, "fileStore", this).     // init store if not loaded before     if (init.compareAndSet(false, true)) {         loadStore().     } }
false;protected;0;7;;@Override protected void doStop() throws Exception {     // reset will trunk and clear the cache     trunkStore().     cache.clear().     init.set(false). }
false;public;0;3;;public File getFileStore() {     return fileStore. }
false;public;1;3;;public void setFileStore(File fileStore) {     this.fileStore = fileStore. }
false;public;0;4;;@ManagedAttribute(description = "The file path for the store") public String getFilePath() {     return fileStore.getPath(). }
false;public;0;3;;public Map<String, String> getCache() {     return cache. }
false;public;1;3;;public void setCache(Map<String, String> cache) {     this.cache = cache. }
false;public;0;4;;@ManagedAttribute(description = "The maximum file size for the file store in bytes") public long getMaxFileStoreSize() {     return maxFileStoreSize. }
true;public;1;4;/**  * Sets the maximum file size for the file store in bytes.  * <p/>  * The default is 1mb.  */ ;/**  * Sets the maximum file size for the file store in bytes.  * <p/>  * The default is 1mb.  */ @ManagedAttribute(description = "The maximum file size for the file store in bytes") public void setMaxFileStoreSize(long maxFileStoreSize) {     this.maxFileStoreSize = maxFileStoreSize. }
