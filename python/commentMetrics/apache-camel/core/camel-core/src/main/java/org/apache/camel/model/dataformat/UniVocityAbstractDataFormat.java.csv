commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getNullValue() {     return nullValue. }
true;public;1;3;/**  * The string representation of a null value.  * <p/>  * The default value is null  */ ;/**  * The string representation of a null value.  * <p/>  * The default value is null  */ public void setNullValue(String nullValue) {     this.nullValue = nullValue. }
false;public;0;3;;public Boolean getSkipEmptyLines() {     return skipEmptyLines. }
true;public;1;3;/**  * Whether or not the empty lines must be ignored.  * <p/>  * The default value is true  */ ;/**  * Whether or not the empty lines must be ignored.  * <p/>  * The default value is true  */ public void setSkipEmptyLines(Boolean skipEmptyLines) {     this.skipEmptyLines = skipEmptyLines. }
false;public;0;3;;public Boolean getIgnoreTrailingWhitespaces() {     return ignoreTrailingWhitespaces. }
true;public;1;3;/**  * Whether or not the trailing white spaces must ignored.  * <p/>  * The default value is true  */ ;/**  * Whether or not the trailing white spaces must ignored.  * <p/>  * The default value is true  */ public void setIgnoreTrailingWhitespaces(Boolean ignoreTrailingWhitespaces) {     this.ignoreTrailingWhitespaces = ignoreTrailingWhitespaces. }
false;public;0;3;;public Boolean getIgnoreLeadingWhitespaces() {     return ignoreLeadingWhitespaces. }
true;public;1;3;/**  * Whether or not the leading white spaces must be ignored.  * <p/>  * The default value is true  */ ;/**  * Whether or not the leading white spaces must be ignored.  * <p/>  * The default value is true  */ public void setIgnoreLeadingWhitespaces(Boolean ignoreLeadingWhitespaces) {     this.ignoreLeadingWhitespaces = ignoreLeadingWhitespaces. }
false;public;0;3;;public Boolean getHeadersDisabled() {     return headersDisabled. }
true;public;1;3;/**  * Whether or not the headers are disabled. When defined, this option explicitly sets the headers as null which indicates that there is no header.  * <p/>  * The default value is false  */ ;/**  * Whether or not the headers are disabled. When defined, this option explicitly sets the headers as null which indicates that there is no header.  * <p/>  * The default value is false  */ public void setHeadersDisabled(Boolean headersDisabled) {     this.headersDisabled = headersDisabled. }
false;public;0;3;;public List<UniVocityHeader> getHeaders() {     return headers. }
true;public;1;3;/**  * The headers to use.  */ ;/**  * The headers to use.  */ public void setHeaders(List<UniVocityHeader> headers) {     this.headers = headers. }
false;public;0;3;;public Boolean getHeaderExtractionEnabled() {     return headerExtractionEnabled. }
true;public;1;3;/**  * Whether or not the header must be read in the first line of the test document  * <p/>  * The default value is false  */ ;/**  * Whether or not the header must be read in the first line of the test document  * <p/>  * The default value is false  */ public void setHeaderExtractionEnabled(Boolean headerExtractionEnabled) {     this.headerExtractionEnabled = headerExtractionEnabled. }
false;public;0;3;;public Integer getNumberOfRecordsToRead() {     return numberOfRecordsToRead. }
true;public;1;3;/**  * The maximum number of record to read.  */ ;/**  * The maximum number of record to read.  */ public void setNumberOfRecordsToRead(Integer numberOfRecordsToRead) {     this.numberOfRecordsToRead = numberOfRecordsToRead. }
false;public;0;3;;public String getEmptyValue() {     return emptyValue. }
true;public;1;3;/**  * The String representation of an empty value  */ ;/**  * The String representation of an empty value  */ public void setEmptyValue(String emptyValue) {     this.emptyValue = emptyValue. }
false;public;0;3;;public String getLineSeparator() {     return lineSeparator. }
true;public;1;3;/**  * The line separator of the files  * <p/>  * The default value is to use the JVM platform line separator  */ ;/**  * The line separator of the files  * <p/>  * The default value is to use the JVM platform line separator  */ public void setLineSeparator(String lineSeparator) {     this.lineSeparator = lineSeparator. }
false;public;0;3;;public String getNormalizedLineSeparator() {     return normalizedLineSeparator. }
true;public;1;3;/**  * The normalized line separator of the files  * <p/>  * The default value is a new line character.  */ ;/**  * The normalized line separator of the files  * <p/>  * The default value is a new line character.  */ public void setNormalizedLineSeparator(String normalizedLineSeparator) {     this.normalizedLineSeparator = normalizedLineSeparator. }
false;public;0;3;;public String getComment() {     return comment. }
true;public;1;3;/**  * The comment symbol.  * <p/>  * The default value is #  */ ;/**  * The comment symbol.  * <p/>  * The default value is #  */ public void setComment(String comment) {     this.comment = comment. }
false;public;0;3;;public Boolean getLazyLoad() {     return lazyLoad. }
true;public;1;3;/**  * Whether the unmarshalling should produce an iterator that reads the lines on the fly or if all the lines must be read at one.  * <p/>  * The default value is false  */ ;/**  * Whether the unmarshalling should produce an iterator that reads the lines on the fly or if all the lines must be read at one.  * <p/>  * The default value is false  */ public void setLazyLoad(Boolean lazyLoad) {     this.lazyLoad = lazyLoad. }
false;public;0;3;;public Boolean getAsMap() {     return asMap. }
true;public;1;3;/**  * Whether the unmarshalling should produce maps for the lines values instead of lists.  * It requires to have header (either defined or collected).  * <p/>  * The default value is false  */ ;/**  * Whether the unmarshalling should produce maps for the lines values instead of lists.  * It requires to have header (either defined or collected).  * <p/>  * The default value is false  */ public void setAsMap(Boolean asMap) {     this.asMap = asMap. }
false;protected;2;48;;@Override protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {     super.configureDataFormat(dataFormat, camelContext).     if (nullValue != null) {         setProperty(camelContext, dataFormat, "nullValue", nullValue).     }     if (skipEmptyLines != null) {         setProperty(camelContext, dataFormat, "skipEmptyLines", skipEmptyLines).     }     if (ignoreTrailingWhitespaces != null) {         setProperty(camelContext, dataFormat, "ignoreTrailingWhitespaces", ignoreTrailingWhitespaces).     }     if (ignoreLeadingWhitespaces != null) {         setProperty(camelContext, dataFormat, "ignoreLeadingWhitespaces", ignoreLeadingWhitespaces).     }     if (headersDisabled != null) {         setProperty(camelContext, dataFormat, "headersDisabled", headersDisabled).     }     String[] validHeaderNames = getValidHeaderNames().     if (validHeaderNames != null) {         setProperty(camelContext, dataFormat, "headers", validHeaderNames).     }     if (headerExtractionEnabled != null) {         setProperty(camelContext, dataFormat, "headerExtractionEnabled", headerExtractionEnabled).     }     if (numberOfRecordsToRead != null) {         setProperty(camelContext, dataFormat, "numberOfRecordsToRead", numberOfRecordsToRead).     }     if (emptyValue != null) {         setProperty(camelContext, dataFormat, "emptyValue", emptyValue).     }     if (lineSeparator != null) {         setProperty(camelContext, dataFormat, "lineSeparator", lineSeparator).     }     if (normalizedLineSeparator != null) {         setProperty(camelContext, dataFormat, "normalizedLineSeparator", singleCharOf("normalizedLineSeparator", normalizedLineSeparator)).     }     if (comment != null) {         setProperty(camelContext, dataFormat, "comment", singleCharOf("comment", comment)).     }     if (lazyLoad != null) {         setProperty(camelContext, dataFormat, "lazyLoad", lazyLoad).     }     if (asMap != null) {         setProperty(camelContext, dataFormat, "asMap", asMap).     } }
false;protected,static;2;6;;protected static Character singleCharOf(String attributeName, String string) {     if (string.length() != 1) {         throw new IllegalArgumentException("Only one character must be defined for " + attributeName).     }     return string.charAt(0). }
true;private;0;12;/**  * Gets only the headers with non-null and non-empty names. It returns {@code null} if there's no such headers.  *  * @return The headers with non-null and non-empty names  */ ;/**  * Gets only the headers with non-null and non-empty names. It returns {@code null} if there's no such headers.  *  * @return The headers with non-null and non-empty names  */ private String[] getValidHeaderNames() {     if (headers == null) {         return null.     }     List<String> names = new ArrayList<>(headers.size()).     for (UniVocityHeader header : headers) {         if (header.getName() != null && !header.getName().isEmpty()) {             names.add(header.getName()).         }     }     return names.isEmpty() ? null : names.toArray(new String[names.size()]). }
