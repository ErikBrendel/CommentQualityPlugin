commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;@Override public void done(boolean doneSync) {     if (existing != null) {         exchange.setProperty(Exchange.FILTER_MATCHED, existing).     } else {         exchange.removeProperty(Exchange.FILTER_MATCHED).     }     callback.done(doneSync). }
false;public;2;62;;public boolean process(final Exchange exchange, final AsyncCallback callback) {     Iterator<Processor> processors = next().iterator().     // callback to restore existing FILTER_MATCHED property on the Exchange     final Object existing = exchange.getProperty(Exchange.FILTER_MATCHED).     final AsyncCallback choiceCallback = new AsyncCallback() {          @Override         public void done(boolean doneSync) {             if (existing != null) {                 exchange.setProperty(Exchange.FILTER_MATCHED, existing).             } else {                 exchange.removeProperty(Exchange.FILTER_MATCHED).             }             callback.done(doneSync).         }     }.     // and if not, we just continue without using any processor     while (processors.hasNext()) {         // get the next processor         Processor processor = processors.next().         // evaluate the predicate on filter predicate early to be faster         // and avoid issues when having nested choices         // as we should only pick one processor         boolean matches = false.         if (processor instanceof FilterProcessor) {             FilterProcessor filter = (FilterProcessor) processor.             try {                 matches = filter.matches(exchange).                 // as we have pre evaluated the predicate then use its processor directly when routing                 processor = filter.getProcessor().             } catch (Throwable e) {                 exchange.setException(e).             }         } else {             // its the otherwise processor, so its a match             notFiltered++.             matches = true.         }         // check for error if so we should break out         if (!continueProcessing(exchange, "so breaking out of choice", log)) {             break.         }         // if we did not match then continue to next filter         if (!matches) {             continue.         }         // okay we found a filter or its the otherwise we are processing         AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor).         return async.process(exchange, choiceCallback).     }     // when no filter matches and there is no otherwise, then just continue     choiceCallback.done(true).     return true. }
false;public;0;20;;@Override public String toString() {     StringBuilder builder = new StringBuilder("choice{").     boolean first = true.     for (Processor processor : filters) {         if (first) {             first = false.         } else {             builder.append(", ").         }         builder.append("when ").         builder.append(processor).     }     if (otherwise != null) {         builder.append(", otherwise: ").         builder.append(otherwise).     }     builder.append("}").     return builder.toString(). }
false;public;0;3;;public String getTraceLabel() {     return "choice". }
false;public;0;3;;public List<FilterProcessor> getFilters() {     return filters. }
false;public;0;3;;public Processor getOtherwise() {     return otherwise. }
true;public;0;3;/**  * Gets the number of Exchanges that did not match any predicate and are routed using otherwise  */ ;/**  * Gets the number of Exchanges that did not match any predicate and are routed using otherwise  */ public long getNotFilteredCount() {     return notFiltered. }
true;public;0;6;/**  * Reset counters.  */ ;/**  * Reset counters.  */ public void reset() {     for (FilterProcessor filter : getFilters()) {         filter.reset().     }     notFiltered = 0. }
false;public;0;13;;public List<Processor> next() {     if (!hasNext()) {         return null.     }     List<Processor> answer = new ArrayList<>().     if (filters != null) {         answer.addAll(filters).     }     if (otherwise != null) {         answer.add(otherwise).     }     return answer. }
false;public;0;3;;public boolean hasNext() {     return otherwise != null || (filters != null && !filters.isEmpty()). }
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setId(String id) {     this.id = id. }
false;protected;0;3;;protected void doStart() throws Exception {     ServiceHelper.startService(filters, otherwise). }
false;protected;0;3;;protected void doStop() throws Exception {     ServiceHelper.stopService(otherwise, filters). }
