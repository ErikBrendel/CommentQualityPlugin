commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;// Getter/Setter // ------------------------------------------------------------------------- public String getGroupKey() {     return groupKey. }
true;public;1;3;/**  * Sets the group key to use. The default value is CamelHystrix.  */ ;/**  * Sets the group key to use. The default value is CamelHystrix.  */ public void setGroupKey(String groupKey) {     this.groupKey = groupKey. }
false;public;0;3;;public String getThreadPoolKey() {     return threadPoolKey. }
true;public;1;3;/**  * Sets the thread pool key to use. Will by default use the same value as groupKey has been configured to use.  */ ;/**  * Sets the thread pool key to use. Will by default use the same value as groupKey has been configured to use.  */ public void setThreadPoolKey(String threadPoolKey) {     this.threadPoolKey = threadPoolKey. }
false;public;0;3;;public Boolean getCircuitBreakerEnabled() {     return circuitBreakerEnabled. }
true;public;1;3;/**  * Whether to use a HystrixCircuitBreaker or not. If false no circuit-breaker logic will be used and all requests permitted.  * <p>  * This is similar in effect to circuitBreakerForceClosed() except that continues tracking metrics and knowing whether it  * should be open/closed, this property results in not even instantiating a circuit-breaker.  */ ;/**  * Whether to use a HystrixCircuitBreaker or not. If false no circuit-breaker logic will be used and all requests permitted.  * <p>  * This is similar in effect to circuitBreakerForceClosed() except that continues tracking metrics and knowing whether it  * should be open/closed, this property results in not even instantiating a circuit-breaker.  */ public void setCircuitBreakerEnabled(Boolean circuitBreakerEnabled) {     this.circuitBreakerEnabled = circuitBreakerEnabled. }
false;public;0;3;;public Integer getCircuitBreakerErrorThresholdPercentage() {     return circuitBreakerErrorThresholdPercentage. }
true;public;1;3;/**  * Error percentage threshold (as whole number such as 50) at which point the circuit breaker will trip open and reject requests.  * <p>  * It will stay tripped for the duration defined in circuitBreakerSleepWindowInMilliseconds.  * <p>  * The error percentage this is compared against comes from HystrixCommandMetrics.getHealthCounts().  */ ;/**  * Error percentage threshold (as whole number such as 50) at which point the circuit breaker will trip open and reject requests.  * <p>  * It will stay tripped for the duration defined in circuitBreakerSleepWindowInMilliseconds.  * <p>  * The error percentage this is compared against comes from HystrixCommandMetrics.getHealthCounts().  */ public void setCircuitBreakerErrorThresholdPercentage(Integer circuitBreakerErrorThresholdPercentage) {     this.circuitBreakerErrorThresholdPercentage = circuitBreakerErrorThresholdPercentage. }
false;public;0;3;;public Boolean getCircuitBreakerForceClosed() {     return circuitBreakerForceClosed. }
true;public;1;3;/**  * If true the HystrixCircuitBreaker#allowRequest() will always return true to allow requests regardless of  * the error percentage from HystrixCommandMetrics.getHealthCounts().  * <p>  * The circuitBreakerForceOpen() property takes precedence so if it set to true this property does nothing.  */ ;/**  * If true the HystrixCircuitBreaker#allowRequest() will always return true to allow requests regardless of  * the error percentage from HystrixCommandMetrics.getHealthCounts().  * <p>  * The circuitBreakerForceOpen() property takes precedence so if it set to true this property does nothing.  */ public void setCircuitBreakerForceClosed(Boolean circuitBreakerForceClosed) {     this.circuitBreakerForceClosed = circuitBreakerForceClosed. }
false;public;0;3;;public Boolean getCircuitBreakerForceOpen() {     return circuitBreakerForceOpen. }
true;public;1;3;/**  * If true the HystrixCircuitBreaker.allowRequest() will always return false, causing the circuit to be open (tripped) and reject all requests.  * <p>  * This property takes precedence over circuitBreakerForceClosed().  */ ;/**  * If true the HystrixCircuitBreaker.allowRequest() will always return false, causing the circuit to be open (tripped) and reject all requests.  * <p>  * This property takes precedence over circuitBreakerForceClosed().  */ public void setCircuitBreakerForceOpen(Boolean circuitBreakerForceOpen) {     this.circuitBreakerForceOpen = circuitBreakerForceOpen. }
false;public;0;3;;public Integer getCircuitBreakerRequestVolumeThreshold() {     return circuitBreakerRequestVolumeThreshold. }
true;public;1;3;/**  * Minimum number of requests in the metricsRollingStatisticalWindowInMilliseconds() that must exist before the HystrixCircuitBreaker will trip.  * <p>  * If below this number the circuit will not trip regardless of error percentage.  */ ;/**  * Minimum number of requests in the metricsRollingStatisticalWindowInMilliseconds() that must exist before the HystrixCircuitBreaker will trip.  * <p>  * If below this number the circuit will not trip regardless of error percentage.  */ public void setCircuitBreakerRequestVolumeThreshold(Integer circuitBreakerRequestVolumeThreshold) {     this.circuitBreakerRequestVolumeThreshold = circuitBreakerRequestVolumeThreshold. }
false;public;0;3;;public Integer getCircuitBreakerSleepWindowInMilliseconds() {     return circuitBreakerSleepWindowInMilliseconds. }
true;public;1;3;/**  * The time in milliseconds after a HystrixCircuitBreaker trips open that it should wait before trying requests again.  */ ;/**  * The time in milliseconds after a HystrixCircuitBreaker trips open that it should wait before trying requests again.  */ public void setCircuitBreakerSleepWindowInMilliseconds(Integer circuitBreakerSleepWindowInMilliseconds) {     this.circuitBreakerSleepWindowInMilliseconds = circuitBreakerSleepWindowInMilliseconds. }
false;public;0;3;;public Integer getExecutionIsolationSemaphoreMaxConcurrentRequests() {     return executionIsolationSemaphoreMaxConcurrentRequests. }
true;public;1;3;/**  * Number of concurrent requests permitted to HystrixCommand.run(). Requests beyond the concurrent limit will be rejected.  * <p>  * Applicable only when executionIsolationStrategy == SEMAPHORE.  */ ;/**  * Number of concurrent requests permitted to HystrixCommand.run(). Requests beyond the concurrent limit will be rejected.  * <p>  * Applicable only when executionIsolationStrategy == SEMAPHORE.  */ public void setExecutionIsolationSemaphoreMaxConcurrentRequests(Integer executionIsolationSemaphoreMaxConcurrentRequests) {     this.executionIsolationSemaphoreMaxConcurrentRequests = executionIsolationSemaphoreMaxConcurrentRequests. }
false;public;0;3;;public String getExecutionIsolationStrategy() {     return executionIsolationStrategy. }
true;public;1;3;/**  * What isolation strategy HystrixCommand.run() will be executed with.  * <p>  * If THREAD then it will be executed on a separate thread and concurrent requests limited by the number of threads in the thread-pool.  * <p>  * If SEMAPHORE then it will be executed on the calling thread and concurrent requests limited by the semaphore count.  */ ;/**  * What isolation strategy HystrixCommand.run() will be executed with.  * <p>  * If THREAD then it will be executed on a separate thread and concurrent requests limited by the number of threads in the thread-pool.  * <p>  * If SEMAPHORE then it will be executed on the calling thread and concurrent requests limited by the semaphore count.  */ public void setExecutionIsolationStrategy(String executionIsolationStrategy) {     this.executionIsolationStrategy = executionIsolationStrategy. }
false;public;0;3;;public Boolean getExecutionIsolationThreadInterruptOnTimeout() {     return executionIsolationThreadInterruptOnTimeout. }
true;public;1;3;/**  * Whether the execution thread should attempt an interrupt (using {@link Future#cancel}) when a thread times out.  * <p>  * Applicable only when executionIsolationStrategy() == THREAD.  */ ;/**  * Whether the execution thread should attempt an interrupt (using {@link Future#cancel}) when a thread times out.  * <p>  * Applicable only when executionIsolationStrategy() == THREAD.  */ public void setExecutionIsolationThreadInterruptOnTimeout(Boolean executionIsolationThreadInterruptOnTimeout) {     this.executionIsolationThreadInterruptOnTimeout = executionIsolationThreadInterruptOnTimeout. }
false;public;0;3;;public Integer getExecutionTimeoutInMilliseconds() {     return executionTimeoutInMilliseconds. }
true;public;1;3;/**  * Time in milliseconds at which point the command will timeout and halt execution.  * <p>  * If {@link #executionIsolationThreadInterruptOnTimeout} == true and the command is thread-isolated, the executing thread will be interrupted.  * If the command is semaphore-isolated and a HystrixObservableCommand, that command will get unsubscribed.  */ ;/**  * Time in milliseconds at which point the command will timeout and halt execution.  * <p>  * If {@link #executionIsolationThreadInterruptOnTimeout} == true and the command is thread-isolated, the executing thread will be interrupted.  * If the command is semaphore-isolated and a HystrixObservableCommand, that command will get unsubscribed.  */ public void setExecutionTimeoutInMilliseconds(Integer executionTimeoutInMilliseconds) {     this.executionTimeoutInMilliseconds = executionTimeoutInMilliseconds. }
false;public;0;3;;public Boolean getExecutionTimeoutEnabled() {     return executionTimeoutEnabled. }
true;public;1;3;/**  * Whether the timeout mechanism is enabled for this command  */ ;/**  * Whether the timeout mechanism is enabled for this command  */ public void setExecutionTimeoutEnabled(Boolean executionTimeoutEnabled) {     this.executionTimeoutEnabled = executionTimeoutEnabled. }
false;public;0;3;;public Integer getFallbackIsolationSemaphoreMaxConcurrentRequests() {     return fallbackIsolationSemaphoreMaxConcurrentRequests. }
true;public;1;3;/**  * Number of concurrent requests permitted to HystrixCommand.getFallback().  * Requests beyond the concurrent limit will fail-fast and not attempt retrieving a fallback.  */ ;/**  * Number of concurrent requests permitted to HystrixCommand.getFallback().  * Requests beyond the concurrent limit will fail-fast and not attempt retrieving a fallback.  */ public void setFallbackIsolationSemaphoreMaxConcurrentRequests(Integer fallbackIsolationSemaphoreMaxConcurrentRequests) {     this.fallbackIsolationSemaphoreMaxConcurrentRequests = fallbackIsolationSemaphoreMaxConcurrentRequests. }
false;public;0;3;;public Boolean getFallbackEnabled() {     return fallbackEnabled. }
true;public;1;3;/**  * Whether HystrixCommand.getFallback() should be attempted when failure occurs.  */ ;/**  * Whether HystrixCommand.getFallback() should be attempted when failure occurs.  */ public void setFallbackEnabled(Boolean fallbackEnabled) {     this.fallbackEnabled = fallbackEnabled. }
false;public;0;3;;public Integer getMetricsHealthSnapshotIntervalInMilliseconds() {     return metricsHealthSnapshotIntervalInMilliseconds. }
true;public;1;3;/**  * Time in milliseconds to wait between allowing health snapshots to be taken that calculate success and error  * percentages and affect HystrixCircuitBreaker.isOpen() status.  * <p>  * On high-volume circuits the continual calculation of error percentage can become CPU intensive thus this controls how often it is calculated.  */ ;/**  * Time in milliseconds to wait between allowing health snapshots to be taken that calculate success and error  * percentages and affect HystrixCircuitBreaker.isOpen() status.  * <p>  * On high-volume circuits the continual calculation of error percentage can become CPU intensive thus this controls how often it is calculated.  */ public void setMetricsHealthSnapshotIntervalInMilliseconds(Integer metricsHealthSnapshotIntervalInMilliseconds) {     this.metricsHealthSnapshotIntervalInMilliseconds = metricsHealthSnapshotIntervalInMilliseconds. }
false;public;0;3;;public Integer getMetricsRollingPercentileBucketSize() {     return metricsRollingPercentileBucketSize. }
true;public;1;3;/**  * Maximum number of values stored in each bucket of the rolling percentile.  * This is passed into HystrixRollingPercentile inside HystrixCommandMetrics.  */ ;/**  * Maximum number of values stored in each bucket of the rolling percentile.  * This is passed into HystrixRollingPercentile inside HystrixCommandMetrics.  */ public void setMetricsRollingPercentileBucketSize(Integer metricsRollingPercentileBucketSize) {     this.metricsRollingPercentileBucketSize = metricsRollingPercentileBucketSize. }
false;public;0;3;;public Boolean getMetricsRollingPercentileEnabled() {     return metricsRollingPercentileEnabled. }
true;public;1;3;/**  * Whether percentile metrics should be captured using HystrixRollingPercentile inside HystrixCommandMetrics.  */ ;/**  * Whether percentile metrics should be captured using HystrixRollingPercentile inside HystrixCommandMetrics.  */ public void setMetricsRollingPercentileEnabled(Boolean metricsRollingPercentileEnabled) {     this.metricsRollingPercentileEnabled = metricsRollingPercentileEnabled. }
false;public;0;3;;public Integer getMetricsRollingPercentileWindowInMilliseconds() {     return metricsRollingPercentileWindowInMilliseconds. }
true;public;1;3;/**  * Duration of percentile rolling window in milliseconds.  * This is passed into HystrixRollingPercentile inside HystrixCommandMetrics.  */ ;/**  * Duration of percentile rolling window in milliseconds.  * This is passed into HystrixRollingPercentile inside HystrixCommandMetrics.  */ public void setMetricsRollingPercentileWindowInMilliseconds(Integer metricsRollingPercentileWindowInMilliseconds) {     this.metricsRollingPercentileWindowInMilliseconds = metricsRollingPercentileWindowInMilliseconds. }
false;public;0;3;;public Integer getMetricsRollingPercentileWindowBuckets() {     return metricsRollingPercentileWindowBuckets. }
true;public;1;3;/**  * Number of buckets the rolling percentile window is broken into.  * This is passed into HystrixRollingPercentile inside HystrixCommandMetrics.  */ ;/**  * Number of buckets the rolling percentile window is broken into.  * This is passed into HystrixRollingPercentile inside HystrixCommandMetrics.  */ public void setMetricsRollingPercentileWindowBuckets(Integer metricsRollingPercentileWindowBuckets) {     this.metricsRollingPercentileWindowBuckets = metricsRollingPercentileWindowBuckets. }
false;public;0;3;;public Integer getMetricsRollingStatisticalWindowInMilliseconds() {     return metricsRollingStatisticalWindowInMilliseconds. }
true;public;1;3;/**  * This property sets the duration of the statistical rolling window, in milliseconds. This is how long metrics are kept for the thread pool.  *  * The window is divided into buckets and “rolls” by those increments.  */ ;/**  * This property sets the duration of the statistical rolling window, in milliseconds. This is how long metrics are kept for the thread pool.  *  * The window is divided into buckets and “rolls” by those increments.  */ public void setMetricsRollingStatisticalWindowInMilliseconds(Integer metricsRollingStatisticalWindowInMilliseconds) {     this.metricsRollingStatisticalWindowInMilliseconds = metricsRollingStatisticalWindowInMilliseconds. }
false;public;0;3;;public Integer getMetricsRollingStatisticalWindowBuckets() {     return metricsRollingStatisticalWindowBuckets. }
true;public;1;3;/**  * Number of buckets the rolling statistical window is broken into.  * This is passed into HystrixRollingNumber inside HystrixCommandMetrics.  */ ;/**  * Number of buckets the rolling statistical window is broken into.  * This is passed into HystrixRollingNumber inside HystrixCommandMetrics.  */ public void setMetricsRollingStatisticalWindowBuckets(Integer metricsRollingStatisticalWindowBuckets) {     this.metricsRollingStatisticalWindowBuckets = metricsRollingStatisticalWindowBuckets. }
false;public;0;3;;public Boolean getRequestLogEnabled() {     return requestLogEnabled. }
true;public;1;3;/**  * Whether HystrixCommand execution and events should be logged to HystrixRequestLog.  */ ;/**  * Whether HystrixCommand execution and events should be logged to HystrixRequestLog.  */ public void setRequestLogEnabled(Boolean requestLogEnabled) {     this.requestLogEnabled = requestLogEnabled. }
false;public;0;3;;public Integer getCorePoolSize() {     return corePoolSize. }
true;public;1;3;/**  * Core thread-pool size that gets passed to {@link java.util.concurrent.ThreadPoolExecutor#setCorePoolSize(int)}  */ ;/**  * Core thread-pool size that gets passed to {@link java.util.concurrent.ThreadPoolExecutor#setCorePoolSize(int)}  */ public void setCorePoolSize(Integer corePoolSize) {     this.corePoolSize = corePoolSize. }
false;public;0;3;;public Integer getMaximumSize() {     return maximumSize. }
true;public;1;3;/**  * Maximum thread-pool size that gets passed to {@link ThreadPoolExecutor#setMaximumPoolSize(int)}.  * This is the maximum amount of concurrency that can be supported without starting to reject HystrixCommands.  * Please note that this setting only takes effect if you also set allowMaximumSizeToDivergeFromCoreSize  */ ;/**  * Maximum thread-pool size that gets passed to {@link ThreadPoolExecutor#setMaximumPoolSize(int)}.  * This is the maximum amount of concurrency that can be supported without starting to reject HystrixCommands.  * Please note that this setting only takes effect if you also set allowMaximumSizeToDivergeFromCoreSize  */ public void setMaximumSize(Integer maximumSize) {     this.maximumSize = maximumSize. }
false;public;0;3;;public Integer getKeepAliveTime() {     return keepAliveTime. }
true;public;1;3;/**  * Keep-alive time in minutes that gets passed to {@link ThreadPoolExecutor#setKeepAliveTime(long, TimeUnit)}  */ ;/**  * Keep-alive time in minutes that gets passed to {@link ThreadPoolExecutor#setKeepAliveTime(long, TimeUnit)}  */ public void setKeepAliveTime(Integer keepAliveTime) {     this.keepAliveTime = keepAliveTime. }
false;public;0;3;;public Integer getMaxQueueSize() {     return maxQueueSize. }
true;public;1;3;/**  * Max queue size that gets passed to {@link BlockingQueue} in HystrixConcurrencyStrategy.getBlockingQueue(int)  *  * This should only affect the instantiation of a threadpool - it is not eliglible to change a queue size on the fly.  * For that, use queueSizeRejectionThreshold().  */ ;/**  * Max queue size that gets passed to {@link BlockingQueue} in HystrixConcurrencyStrategy.getBlockingQueue(int)  *  * This should only affect the instantiation of a threadpool - it is not eliglible to change a queue size on the fly.  * For that, use queueSizeRejectionThreshold().  */ public void setMaxQueueSize(Integer maxQueueSize) {     this.maxQueueSize = maxQueueSize. }
false;public;0;3;;public Integer getQueueSizeRejectionThreshold() {     return queueSizeRejectionThreshold. }
true;public;1;3;/**  * Queue size rejection threshold is an artificial "max" size at which rejections will occur even  * if {@link #maxQueueSize} has not been reached. This is done because the {@link #maxQueueSize}  * of a {@link BlockingQueue} can not be dynamically changed and we want to support dynamically  * changing the queue size that affects rejections.  * <p>  * This is used by HystrixCommand when queuing a thread for execution.  */ ;/**  * Queue size rejection threshold is an artificial "max" size at which rejections will occur even  * if {@link #maxQueueSize} has not been reached. This is done because the {@link #maxQueueSize}  * of a {@link BlockingQueue} can not be dynamically changed and we want to support dynamically  * changing the queue size that affects rejections.  * <p>  * This is used by HystrixCommand when queuing a thread for execution.  */ public void setQueueSizeRejectionThreshold(Integer queueSizeRejectionThreshold) {     this.queueSizeRejectionThreshold = queueSizeRejectionThreshold. }
false;public;0;3;;public Integer getThreadPoolRollingNumberStatisticalWindowInMilliseconds() {     return threadPoolRollingNumberStatisticalWindowInMilliseconds. }
true;public;1;3;/**  * Duration of statistical rolling window in milliseconds.  * This is passed into HystrixRollingNumber inside each HystrixThreadPoolMetrics instance.  */ ;/**  * Duration of statistical rolling window in milliseconds.  * This is passed into HystrixRollingNumber inside each HystrixThreadPoolMetrics instance.  */ public void setThreadPoolRollingNumberStatisticalWindowInMilliseconds(Integer threadPoolRollingNumberStatisticalWindowInMilliseconds) {     this.threadPoolRollingNumberStatisticalWindowInMilliseconds = threadPoolRollingNumberStatisticalWindowInMilliseconds. }
false;public;0;3;;public Integer getThreadPoolRollingNumberStatisticalWindowBuckets() {     return threadPoolRollingNumberStatisticalWindowBuckets. }
true;public;1;3;/**  * Number of buckets the rolling statistical window is broken into.  * This is passed into HystrixRollingNumber inside each HystrixThreadPoolMetrics instance.  */ ;/**  * Number of buckets the rolling statistical window is broken into.  * This is passed into HystrixRollingNumber inside each HystrixThreadPoolMetrics instance.  */ public void setThreadPoolRollingNumberStatisticalWindowBuckets(Integer threadPoolRollingNumberStatisticalWindowBuckets) {     this.threadPoolRollingNumberStatisticalWindowBuckets = threadPoolRollingNumberStatisticalWindowBuckets. }
false;public;0;3;;public Boolean getAllowMaximumSizeToDivergeFromCoreSize() {     return allowMaximumSizeToDivergeFromCoreSize. }
true;public;1;3;/**  * Allows the configuration for maximumSize to take effect. That value can then be equal to, or higher, than coreSize  */ ;/**  * Allows the configuration for maximumSize to take effect. That value can then be equal to, or higher, than coreSize  */ public void setAllowMaximumSizeToDivergeFromCoreSize(Boolean allowMaximumSizeToDivergeFromCoreSize) {     this.allowMaximumSizeToDivergeFromCoreSize = allowMaximumSizeToDivergeFromCoreSize. }
