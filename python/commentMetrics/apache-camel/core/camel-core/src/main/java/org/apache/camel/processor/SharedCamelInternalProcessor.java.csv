commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public boolean process(Exchange exchange, AsyncCallback callback) {     return SharedCamelInternalProcessor.this.process(exchange, callback, processor, resultProcessor). }
false;public;1;6;;@Override public CompletableFuture<Exchange> processAsync(Exchange exchange) {     AsyncCallbackToCompletableFutureAdapter<Exchange> callback = new AsyncCallbackToCompletableFutureAdapter<>(exchange).     process(exchange, callback).     return callback.getFuture(). }
false;public;1;4;;@Override public void process(Exchange exchange) throws Exception {     throw new IllegalStateException(). }
true;public;3;21;/**  * Synchronous API  */ ;/**  * Synchronous API  */ public void process(Exchange exchange, AsyncProcessor processor, Processor resultProcessor) {     final AsyncProcessorAwaitManager awaitManager = exchange.getContext().getAsyncProcessorAwaitManager().     awaitManager.process(new AsyncProcessor() {          @Override         public boolean process(Exchange exchange, AsyncCallback callback) {             return SharedCamelInternalProcessor.this.process(exchange, callback, processor, resultProcessor).         }          @Override         public CompletableFuture<Exchange> processAsync(Exchange exchange) {             AsyncCallbackToCompletableFutureAdapter<Exchange> callback = new AsyncCallbackToCompletableFutureAdapter<>(exchange).             process(exchange, callback).             return callback.getFuture().         }          @Override         public void process(Exchange exchange) throws Exception {             throw new IllegalStateException().         }     }, exchange). }
true;public;4;98;/**  * Asynchronous API  */ ;/**  * Asynchronous API  */ public boolean process(Exchange exchange, AsyncCallback ocallback, AsyncProcessor processor, Processor resultProcessor) {     if (processor == null || !continueProcessing(exchange, processor)) {         // no processor or we should not continue then we are done         ocallback.done(true).         return true.     }     // optimise to use object array for states     final Object[] states = new Object[advices.size()].     // optimise for loop using index access to avoid creating iterator object     for (int i = 0. i < advices.size(). i++) {         CamelInternalProcessorAdvice task = advices.get(i).         try {             Object state = task.before(exchange).             states[i] = state.         } catch (Throwable e) {             exchange.setException(e).             ocallback.done(true).             return true.         }     }     // create internal callback which will execute the advices in reverse order when done     AsyncCallback callback = new InternalCallback(states, exchange, ocallback, resultProcessor).     // UNIT_OF_WORK_PROCESS_SYNC is @deprecated and we should remove it from Camel 3.0     Object synchronous = exchange.removeProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC).     if (exchange.isTransacted() || synchronous != null) {         // must be synchronized for transacted exchanges         if (LOG.isTraceEnabled()) {             if (exchange.isTransacted()) {                 LOG.trace("Transacted Exchange must be routed synchronously for exchangeId: {} -> {}", exchange.getExchangeId(), exchange).             } else {                 LOG.trace("Synchronous UnitOfWork Exchange must be routed synchronously for exchangeId: {} -> {}", exchange.getExchangeId(), exchange).             }         }         // ----------------------------------------------------------         try {             processor.process(exchange).         } catch (Throwable e) {             exchange.setException(e).         }         // ----------------------------------------------------------         // CAMEL END USER - DEBUG ME HERE +++ END +++         // ----------------------------------------------------------         callback.done(true).         return true.     } else {         final UnitOfWork uow = exchange.getUnitOfWork().         // allow unit of work to wrap callback in case it need to do some special work         // for example the MDCUnitOfWork         AsyncCallback async = callback.         if (uow != null) {             async = uow.beforeProcess(processor, exchange, callback).         }         // ----------------------------------------------------------         if (LOG.isTraceEnabled()) {             LOG.trace("Processing exchange for exchangeId: {} -> {}", exchange.getExchangeId(), exchange).         }         boolean sync = processor.process(exchange, async).         // ----------------------------------------------------------         // CAMEL END USER - DEBUG ME HERE +++ END +++         // ----------------------------------------------------------         ReactiveHelper.schedule(() -> {             // execute any after processor work (in current thread, not in the callback)             if (uow != null) {                 uow.afterProcess(processor, exchange, callback, sync).             }             if (LOG.isTraceEnabled()) {                 LOG.trace("Exchange processed and is continued routed asynchronously for exchangeId: {} -> {}", exchange.getExchangeId(), exchange).             }         }, "SharedCamelInternalProcessor - UnitOfWork - afterProcess - " + processor + " - " + exchange.getExchangeId()).         return sync.     } }
false;public;1;37;;@Override @SuppressWarnings("unchecked") public void done(boolean doneSync) {     if (resultProcessor != null) {         try {             resultProcessor.process(exchange).         } catch (Throwable e) {             exchange.setException(e).         }     }     // we should call after in reverse order     try {         for (int i = advices.size() - 1. i >= 0. i--) {             CamelInternalProcessorAdvice task = advices.get(i).             Object state = states[i].             try {                 task.after(exchange, state).             } catch (Throwable e) {                 exchange.setException(e).             // allow all advices to complete even if there was an exception             }         }     } finally {         // ----------------------------------------------------------         // CAMEL END USER - DEBUG ME HERE +++ START +++         // ----------------------------------------------------------         // callback must be called         ReactiveHelper.callback(callback).     // ----------------------------------------------------------     // CAMEL END USER - DEBUG ME HERE +++ END +++     // ----------------------------------------------------------     } }
true;protected;2;26;/**  * Strategy to determine if we should continue processing the {@link Exchange}.  */ ;/**  * Strategy to determine if we should continue processing the {@link Exchange}.  */ protected boolean continueProcessing(Exchange exchange, AsyncProcessor processor) {     Object stop = exchange.getProperty(Exchange.ROUTE_STOP).     if (stop != null) {         boolean doStop = exchange.getContext().getTypeConverter().convertTo(Boolean.class, stop).         if (doStop) {             LOG.debug("Exchange is marked to stop routing: {}", exchange).             return false.         }     }     // determine if we can still run, or the camel context is forcing a shutdown     if (processor instanceof Service) {         boolean forceShutdown = exchange.getContext().getShutdownStrategy().forceShutdown((Service) processor).         if (forceShutdown) {             String msg = "Run not allowed as ShutdownStrategy is forcing shutting down, will reject executing exchange: " + exchange.             LOG.debug(msg).             if (exchange.getException() == null) {                 exchange.setException(new RejectedExecutionException(msg)).             }             return false.         }     }     // yes we can continue     return true. }
