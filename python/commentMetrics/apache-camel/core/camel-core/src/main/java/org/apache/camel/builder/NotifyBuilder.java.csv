commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override public boolean isAbstract() {     // is abstract as its a filter     return true. }
false;public;1;5;;@Override public boolean onExchange(Exchange exchange) {     // filter non matching exchanges     return EndpointHelper.matchEndpoint(context, exchange.getFromEndpoint().getEndpointUri(), endpointUri). }
false;public;0;4;;public boolean matches() {     // should be true as we use the onExchange to filter     return true. }
false;public;0;4;;@Override public String toString() {     return "from(" + endpointUri + ")". }
true;public;1;27;/**  * Optionally a <tt>from</tt> endpoint which means that this expression should only be based  * on {@link Exchange} which is originated from the particular endpoint(s).  *  * @param endpointUri uri of endpoint or pattern (see the EndpointHelper javadoc)  * @return the builder  * @see EndpointHelper#matchEndpoint(org.apache.camel.CamelContext, String, String)  */ ;/**  * Optionally a <tt>from</tt> endpoint which means that this expression should only be based  * on {@link Exchange} which is originated from the particular endpoint(s).  *  * @param endpointUri uri of endpoint or pattern (see the EndpointHelper javadoc)  * @return the builder  * @see EndpointHelper#matchEndpoint(org.apache.camel.CamelContext, String, String)  */ public NotifyBuilder from(final String endpointUri) {     stack.add(new EventPredicateSupport() {          @Override         public boolean isAbstract() {             // is abstract as its a filter             return true.         }          @Override         public boolean onExchange(Exchange exchange) {             // filter non matching exchanges             return EndpointHelper.matchEndpoint(context, exchange.getFromEndpoint().getEndpointUri(), endpointUri).         }          public boolean matches() {             // should be true as we use the onExchange to filter             return true.         }          @Override         public String toString() {             return "from(" + endpointUri + ")".         }     }).     return this. }
false;public;0;5;;@Override public boolean isAbstract() {     // is abstract as its a filter     return true. }
false;public;1;11;;@Override public boolean onExchange(Exchange exchange) {     String id = EndpointHelper.getRouteIdFromEndpoint(exchange.getFromEndpoint()).     if (id == null) {         id = exchange.getFromRouteId().     }     // filter non matching exchanges     return PatternHelper.matchPattern(id, routeId). }
false;public;0;4;;public boolean matches() {     // should be true as we use the onExchange to filter     return true. }
false;public;0;4;;@Override public String toString() {     return "fromRoute(" + routeId + ")". }
true;public;1;33;/**  * Optionally a <tt>from</tt> route which means that this expression should only be based  * on {@link Exchange} which is originated from the particular route(s).  *  * @param routeId id of route or pattern (see the EndpointHelper javadoc)  * @return the builder  * @see EndpointHelper#matchEndpoint(org.apache.camel.CamelContext, String, String)  */ ;/**  * Optionally a <tt>from</tt> route which means that this expression should only be based  * on {@link Exchange} which is originated from the particular route(s).  *  * @param routeId id of route or pattern (see the EndpointHelper javadoc)  * @return the builder  * @see EndpointHelper#matchEndpoint(org.apache.camel.CamelContext, String, String)  */ public NotifyBuilder fromRoute(final String routeId) {     stack.add(new EventPredicateSupport() {          @Override         public boolean isAbstract() {             // is abstract as its a filter             return true.         }          @Override         public boolean onExchange(Exchange exchange) {             String id = EndpointHelper.getRouteIdFromEndpoint(exchange.getFromEndpoint()).             if (id == null) {                 id = exchange.getFromRouteId().             }             // filter non matching exchanges             return PatternHelper.matchPattern(id, routeId).         }          public boolean matches() {             // should be true as we use the onExchange to filter             return true.         }          @Override         public String toString() {             return "fromRoute(" + routeId + ")".         }     }).     return this. }
false;public;0;5;;@Override public boolean isAbstract() {     // is abstract as its a filter     return true. }
false;public;1;11;;@Override public boolean onExchange(Exchange exchange) {     // ProducerTemplate which creates the UoW before producing messages.     if (exchange.getFromEndpoint().getEndpointUri().startsWith("direct:")) {         return true.     }     return PatternHelper.matchPattern(exchange.getFromRouteId(), "*"). }
false;public;0;4;;public boolean matches() {     // should be true as we use the onExchange to filter     return true. }
false;public;0;5;;@Override public String toString() {     // we dont want any to string output as this is an internal predicate to match only from routes     return "". }
false;private;0;35;;private NotifyBuilder fromRoutesOnly() {     // internal and should always be in top of stack     stack.add(0, new EventPredicateSupport() {          @Override         public boolean isAbstract() {             // is abstract as its a filter             return true.         }          @Override         public boolean onExchange(Exchange exchange) {             // ProducerTemplate which creates the UoW before producing messages.             if (exchange.getFromEndpoint().getEndpointUri().startsWith("direct:")) {                 return true.             }             return PatternHelper.matchPattern(exchange.getFromRouteId(), "*").         }          public boolean matches() {             // should be true as we use the onExchange to filter             return true.         }          @Override         public String toString() {             // we dont want any to string output as this is an internal predicate to match only from routes             return "".         }     }).     return this. }
false;public;0;5;;@Override public boolean isAbstract() {     // is abstract as its a filter     return true. }
false;public;1;5;;@Override public boolean onExchange(Exchange exchange) {     // filter non matching exchanges     return predicate.matches(exchange). }
false;public;0;4;;public boolean matches() {     // should be true as we use the onExchange to filter     return true. }
false;public;0;4;;@Override public String toString() {     return "filter(" + predicate + ")". }
true;public;1;27;/**  * Optionally a filter to only allow matching {@link Exchange} to be used for matching.  *  * @param predicate the predicate to use for the filter  * @return the builder  */ ;/**  * Optionally a filter to only allow matching {@link Exchange} to be used for matching.  *  * @param predicate the predicate to use for the filter  * @return the builder  */ public NotifyBuilder filter(final Predicate predicate) {     stack.add(new EventPredicateSupport() {          @Override         public boolean isAbstract() {             // is abstract as its a filter             return true.         }          @Override         public boolean onExchange(Exchange exchange) {             // filter non matching exchanges             return predicate.matches(exchange).         }          public boolean matches() {             // should be true as we use the onExchange to filter             return true.         }          @Override         public String toString() {             return "filter(" + predicate + ")".         }     }).     return this. }
false;public;0;5;;@Override public boolean isAbstract() {     // is abstract as its a filter     return true. }
false;public;1;6;;@Override public boolean onExchange(Exchange exchange) {     // filter non matching exchanges     Expression exp = clause.createExpression(exchange.getContext()).     return exp.evaluate(exchange, Boolean.class). }
false;public;0;4;;public boolean matches() {     // should be true as we use the onExchange to filter     return true. }
false;public;0;4;;@Override public String toString() {     return "filter(" + clause + ")". }
true;public;0;29;/**  * Optionally a filter to only allow matching {@link Exchange} to be used for matching.  *  * @return the builder  */ ;/**  * Optionally a filter to only allow matching {@link Exchange} to be used for matching.  *  * @return the builder  */ public ExpressionClauseSupport<NotifyBuilder> filter() {     final ExpressionClauseSupport<NotifyBuilder> clause = new ExpressionClauseSupport<>(this).     stack.add(new EventPredicateSupport() {          @Override         public boolean isAbstract() {             // is abstract as its a filter             return true.         }          @Override         public boolean onExchange(Exchange exchange) {             // filter non matching exchanges             Expression exp = clause.createExpression(exchange.getContext()).             return exp.evaluate(exchange, Boolean.class).         }          public boolean matches() {             // should be true as we use the onExchange to filter             return true.         }          @Override         public String toString() {             return "filter(" + clause + ")".         }     }).     return clause. }
false;public;0;5;;@Override public boolean isAbstract() {     // is abstract as its a filter     return true. }
false;public;3;7;;@Override public boolean onExchangeSent(Exchange exchange, Endpoint endpoint, long timeTaken) {     if (EndpointHelper.matchEndpoint(context, endpoint.getEndpointUri(), endpointUri)) {         sentTo.put(exchange.getExchangeId(), exchange.getExchangeId()).     }     return onExchange(exchange). }
false;public;1;6;;@Override public boolean onExchange(Exchange exchange) {     // filter only when sentTo     String sent = sentTo.get(exchange.getExchangeId()).     return sent != null. }
false;public;0;4;;public boolean matches() {     // should be true as we use the onExchange to filter     return true. }
false;public;0;4;;@Override public void reset() {     sentTo.clear(). }
false;public;0;4;;@Override public String toString() {     return "wereSentTo(" + endpointUri + ")". }
true;public;1;43;/**  * Optionally a <tt>sent to</tt> endpoint which means that this expression should only be based  * on {@link Exchange} which has been sent to the given endpoint uri.  * <p/>  * Notice the {@link Exchange} may have been sent to other endpoints as well. This condition will match  * if the {@link Exchange} has been sent at least once to the given endpoint.  *  * @param endpointUri uri of endpoint or pattern (see the EndpointHelper javadoc)  * @return the builder  * @see EndpointHelper#matchEndpoint(org.apache.camel.CamelContext, String, String)  */ ;/**  * Optionally a <tt>sent to</tt> endpoint which means that this expression should only be based  * on {@link Exchange} which has been sent to the given endpoint uri.  * <p/>  * Notice the {@link Exchange} may have been sent to other endpoints as well. This condition will match  * if the {@link Exchange} has been sent at least once to the given endpoint.  *  * @param endpointUri uri of endpoint or pattern (see the EndpointHelper javadoc)  * @return the builder  * @see EndpointHelper#matchEndpoint(org.apache.camel.CamelContext, String, String)  */ public NotifyBuilder wereSentTo(final String endpointUri) {     // insert in start of stack but after the previous wereSentTo     stack.add(wereSentToIndex++, new EventPredicateSupport() {          private ConcurrentMap<String, String> sentTo = new ConcurrentHashMap<>().          @Override         public boolean isAbstract() {             // is abstract as its a filter             return true.         }          @Override         public boolean onExchangeSent(Exchange exchange, Endpoint endpoint, long timeTaken) {             if (EndpointHelper.matchEndpoint(context, endpoint.getEndpointUri(), endpointUri)) {                 sentTo.put(exchange.getExchangeId(), exchange.getExchangeId()).             }             return onExchange(exchange).         }          @Override         public boolean onExchange(Exchange exchange) {             // filter only when sentTo             String sent = sentTo.get(exchange.getExchangeId()).             return sent != null.         }          public boolean matches() {             // should be true as we use the onExchange to filter             return true.         }          @Override         public void reset() {             sentTo.clear().         }          @Override         public String toString() {             return "wereSentTo(" + endpointUri + ")".         }     }).     return this. }
false;public;1;5;;@Override public boolean onExchangeCreated(Exchange exchange) {     current.incrementAndGet().     return true. }
false;public;0;3;;public boolean matches() {     return current.get() >= number. }
false;public;0;4;;@Override public void reset() {     current.set(0). }
false;public;0;4;;@Override public String toString() {     return "whenReceived(" + number + ")". }
true;public;1;26;/**  * Sets a condition when <tt>number</tt> of {@link Exchange} has been received.  * <p/>  * The number matching is <i>at least</i> based which means that if more messages received  * it will match also.  *  * @param number at least number of messages  * @return the builder  */ ;/**  * Sets a condition when <tt>number</tt> of {@link Exchange} has been received.  * <p/>  * The number matching is <i>at least</i> based which means that if more messages received  * it will match also.  *  * @param number at least number of messages  * @return the builder  */ public NotifyBuilder whenReceived(final int number) {     stack.add(new EventPredicateSupport() {          private AtomicInteger current = new AtomicInteger().          @Override         public boolean onExchangeCreated(Exchange exchange) {             current.incrementAndGet().             return true.         }          public boolean matches() {             return current.get() >= number.         }          @Override         public void reset() {             current.set(0).         }          @Override         public String toString() {             return "whenReceived(" + number + ")".         }     }).     return this. }
false;public;1;5;;@Override public boolean onExchangeCompleted(Exchange exchange) {     current.incrementAndGet().     return true. }
false;public;1;5;;@Override public boolean onExchangeFailed(Exchange exchange) {     current.incrementAndGet().     return true. }
false;public;0;3;;public boolean matches() {     return current.get() >= number. }
false;public;0;4;;@Override public void reset() {     current.set(0). }
false;public;0;4;;@Override public String toString() {     return "whenDone(" + number + ")". }
true;public;1;32;/**  * Sets a condition when <tt>number</tt> of {@link Exchange} is done being processed.  * <p/>  * The number matching is <i>at least</i> based which means that if more messages received  * it will match also.  * <p/>  * The difference between <i>done</i> and <i>completed</i> is that done can also include failed  * messages, where as completed is only successful processed messages.  *  * @param number at least number of messages  * @return the builder  */ ;/**  * Sets a condition when <tt>number</tt> of {@link Exchange} is done being processed.  * <p/>  * The number matching is <i>at least</i> based which means that if more messages received  * it will match also.  * <p/>  * The difference between <i>done</i> and <i>completed</i> is that done can also include failed  * messages, where as completed is only successful processed messages.  *  * @param number at least number of messages  * @return the builder  */ public NotifyBuilder whenDone(final int number) {     stack.add(new EventPredicateSupport() {          private final AtomicInteger current = new AtomicInteger().          @Override         public boolean onExchangeCompleted(Exchange exchange) {             current.incrementAndGet().             return true.         }          @Override         public boolean onExchangeFailed(Exchange exchange) {             current.incrementAndGet().             return true.         }          public boolean matches() {             return current.get() >= number.         }          @Override         public void reset() {             current.set(0).         }          @Override         public String toString() {             return "whenDone(" + number + ")".         }     }).     return this. }
false;public;1;8;;@Override public boolean onExchangeCreated(Exchange exchange) {     if (current.get() == index) {         id = exchange.getExchangeId().     }     current.incrementAndGet().     return true. }
false;public;1;7;;@Override public boolean onExchangeCompleted(Exchange exchange) {     if (exchange.getExchangeId().equals(id)) {         done.set(true).     }     return true. }
false;public;1;7;;@Override public boolean onExchangeFailed(Exchange exchange) {     if (exchange.getExchangeId().equals(id)) {         done.set(true).     }     return true. }
false;public;0;3;;public boolean matches() {     return done.get(). }
false;public;0;6;;@Override public void reset() {     current.set(0).     id = null.     done.set(false). }
false;public;0;4;;@Override public String toString() {     return "whenDoneByIndex(" + index + ")". }
true;public;1;49;/**  * Sets a condition when tne <tt>n'th</tt> (by index) {@link Exchange} is done being processed.  * <p/>  * The difference between <i>done</i> and <i>completed</i> is that done can also include failed  * messages, where as completed is only successful processed messages.  *  * @param index the message by index to be done  * @return the builder  */ ;/**  * Sets a condition when tne <tt>n'th</tt> (by index) {@link Exchange} is done being processed.  * <p/>  * The difference between <i>done</i> and <i>completed</i> is that done can also include failed  * messages, where as completed is only successful processed messages.  *  * @param index the message by index to be done  * @return the builder  */ public NotifyBuilder whenDoneByIndex(final int index) {     stack.add(new EventPredicateSupport() {          private AtomicInteger current = new AtomicInteger().          private String id.          private AtomicBoolean done = new AtomicBoolean().          @Override         public boolean onExchangeCreated(Exchange exchange) {             if (current.get() == index) {                 id = exchange.getExchangeId().             }             current.incrementAndGet().             return true.         }          @Override         public boolean onExchangeCompleted(Exchange exchange) {             if (exchange.getExchangeId().equals(id)) {                 done.set(true).             }             return true.         }          @Override         public boolean onExchangeFailed(Exchange exchange) {             if (exchange.getExchangeId().equals(id)) {                 done.set(true).             }             return true.         }          public boolean matches() {             return done.get().         }          @Override         public void reset() {             current.set(0).             id = null.             done.set(false).         }          @Override         public String toString() {             return "whenDoneByIndex(" + index + ")".         }     }).     return this. }
false;public;1;5;;@Override public boolean onExchangeCompleted(Exchange exchange) {     current.incrementAndGet().     return true. }
false;public;0;3;;public boolean matches() {     return current.get() >= number. }
false;public;0;4;;@Override public void reset() {     current.set(0). }
false;public;0;4;;@Override public String toString() {     return "whenCompleted(" + number + ")". }
true;public;1;26;/**  * Sets a condition when <tt>number</tt> of {@link Exchange} has been completed.  * <p/>  * The number matching is <i>at least</i> based which means that if more messages received  * it will match also.  * <p/>  * The difference between <i>done</i> and <i>completed</i> is that done can also include failed  * messages, where as completed is only successful processed messages.  *  * @param number at least number of messages  * @return the builder  */ ;/**  * Sets a condition when <tt>number</tt> of {@link Exchange} has been completed.  * <p/>  * The number matching is <i>at least</i> based which means that if more messages received  * it will match also.  * <p/>  * The difference between <i>done</i> and <i>completed</i> is that done can also include failed  * messages, where as completed is only successful processed messages.  *  * @param number at least number of messages  * @return the builder  */ public NotifyBuilder whenCompleted(final int number) {     stack.add(new EventPredicateSupport() {          private AtomicInteger current = new AtomicInteger().          @Override         public boolean onExchangeCompleted(Exchange exchange) {             current.incrementAndGet().             return true.         }          public boolean matches() {             return current.get() >= number.         }          @Override         public void reset() {             current.set(0).         }          @Override         public String toString() {             return "whenCompleted(" + number + ")".         }     }).     return this. }
false;public;1;5;;@Override public boolean onExchangeFailed(Exchange exchange) {     current.incrementAndGet().     return true. }
false;public;0;3;;public boolean matches() {     return current.get() >= number. }
false;public;0;4;;@Override public void reset() {     current.set(0). }
false;public;0;4;;@Override public String toString() {     return "whenFailed(" + number + ")". }
true;public;1;26;/**  * Sets a condition when <tt>number</tt> of {@link Exchange} has failed.  * <p/>  * The number matching is <i>at least</i> based which means that if more messages received  * it will match also.  *  * @param number at least number of messages  * @return the builder  */ ;/**  * Sets a condition when <tt>number</tt> of {@link Exchange} has failed.  * <p/>  * The number matching is <i>at least</i> based which means that if more messages received  * it will match also.  *  * @param number at least number of messages  * @return the builder  */ public NotifyBuilder whenFailed(final int number) {     stack.add(new EventPredicateSupport() {          private AtomicInteger current = new AtomicInteger().          @Override         public boolean onExchangeFailed(Exchange exchange) {             current.incrementAndGet().             return true.         }          public boolean matches() {             return current.get() >= number.         }          @Override         public void reset() {             current.set(0).         }          @Override         public String toString() {             return "whenFailed(" + number + ")".         }     }).     return this. }
false;public;1;5;;@Override public boolean onExchangeCompleted(Exchange exchange) {     current.incrementAndGet().     return true. }
false;public;1;5;;@Override public boolean onExchangeFailed(Exchange exchange) {     current.incrementAndGet().     return true. }
false;public;0;3;;public boolean matches() {     return current.get() == number. }
false;public;0;4;;@Override public void reset() {     current.set(0). }
false;public;0;4;;@Override public String toString() {     return "whenExactlyDone(" + number + ")". }
true;public;1;32;/**  * Sets a condition when <tt>number</tt> of {@link Exchange} is done being processed.  * <p/>  * messages, where as completed is only successful processed messages.  *  * @param number exactly number of messages  * @return the builder  */ ;/**  * Sets a condition when <tt>number</tt> of {@link Exchange} is done being processed.  * <p/>  * messages, where as completed is only successful processed messages.  *  * @param number exactly number of messages  * @return the builder  */ public NotifyBuilder whenExactlyDone(final int number) {     stack.add(new EventPredicateSupport() {          private AtomicInteger current = new AtomicInteger().          @Override         public boolean onExchangeCompleted(Exchange exchange) {             current.incrementAndGet().             return true.         }          @Override         public boolean onExchangeFailed(Exchange exchange) {             current.incrementAndGet().             return true.         }          public boolean matches() {             return current.get() == number.         }          @Override         public void reset() {             current.set(0).         }          @Override         public String toString() {             return "whenExactlyDone(" + number + ")".         }     }).     return this. }
false;public;1;5;;@Override public boolean onExchangeCompleted(Exchange exchange) {     current.incrementAndGet().     return true. }
false;public;0;3;;public boolean matches() {     return current.get() == number. }
false;public;0;4;;@Override public void reset() {     current.set(0). }
false;public;0;4;;@Override public String toString() {     return "whenExactlyCompleted(" + number + ")". }
true;public;1;26;/**  * Sets a condition when <tt>number</tt> of {@link Exchange} has been completed.  * <p/>  * The difference between <i>done</i> and <i>completed</i> is that done can also include failed  * messages, where as completed is only successful processed messages.  *  * @param number exactly number of messages  * @return the builder  */ ;/**  * Sets a condition when <tt>number</tt> of {@link Exchange} has been completed.  * <p/>  * The difference between <i>done</i> and <i>completed</i> is that done can also include failed  * messages, where as completed is only successful processed messages.  *  * @param number exactly number of messages  * @return the builder  */ public NotifyBuilder whenExactlyCompleted(final int number) {     stack.add(new EventPredicateSupport() {          private AtomicInteger current = new AtomicInteger().          @Override         public boolean onExchangeCompleted(Exchange exchange) {             current.incrementAndGet().             return true.         }          public boolean matches() {             return current.get() == number.         }          @Override         public void reset() {             current.set(0).         }          @Override         public String toString() {             return "whenExactlyCompleted(" + number + ")".         }     }).     return this. }
false;public;1;5;;@Override public boolean onExchangeFailed(Exchange exchange) {     current.incrementAndGet().     return true. }
false;public;0;3;;public boolean matches() {     return current.get() == number. }
false;public;0;4;;@Override public void reset() {     current.set(0). }
false;public;0;4;;@Override public String toString() {     return "whenExactlyFailed(" + number + ")". }
true;public;1;26;/**  * Sets a condition when <tt>number</tt> of {@link Exchange} has failed.  *  * @param number exactly number of messages  * @return the builder  */ ;/**  * Sets a condition when <tt>number</tt> of {@link Exchange} has failed.  *  * @param number exactly number of messages  * @return the builder  */ public NotifyBuilder whenExactlyFailed(final int number) {     stack.add(new EventPredicateSupport() {          private AtomicInteger current = new AtomicInteger().          @Override         public boolean onExchangeFailed(Exchange exchange) {             current.incrementAndGet().             return true.         }          public boolean matches() {             return current.get() == number.         }          @Override         public void reset() {             current.set(0).         }          @Override         public String toString() {             return "whenExactlyFailed(" + number + ")".         }     }).     return this. }
true;public;1;3;/**  * Sets a condition that <b>any received</b> {@link Exchange} should match the {@link Predicate}  *  * @param predicate the predicate  * @return the builder  */ ;/**  * Sets a condition that <b>any received</b> {@link Exchange} should match the {@link Predicate}  *  * @param predicate the predicate  * @return the builder  */ public NotifyBuilder whenAnyReceivedMatches(final Predicate predicate) {     return doWhenAnyMatches(predicate, true). }
true;public;1;3;/**  * Sets a condition that <b>any done</b> {@link Exchange} should match the {@link Predicate}  *  * @param predicate the predicate  * @return the builder  */ ;/**  * Sets a condition that <b>any done</b> {@link Exchange} should match the {@link Predicate}  *  * @param predicate the predicate  * @return the builder  */ public NotifyBuilder whenAnyDoneMatches(final Predicate predicate) {     return doWhenAnyMatches(predicate, false). }
false;public;1;7;;@Override public boolean onExchangeCompleted(Exchange exchange) {     if (!received && !matches.get()) {         matches.set(predicate.matches(exchange)).     }     return true. }
false;public;1;7;;@Override public boolean onExchangeFailed(Exchange exchange) {     if (!received && !matches.get()) {         matches.set(predicate.matches(exchange)).     }     return true. }
false;public;1;7;;@Override public boolean onExchangeCreated(Exchange exchange) {     if (received && !matches.get()) {         matches.set(predicate.matches(exchange)).     }     return true. }
false;public;0;3;;public boolean matches() {     return matches.get(). }
false;public;0;4;;@Override public void reset() {     matches.set(false). }
false;public;0;8;;@Override public String toString() {     if (received) {         return "whenAnyReceivedMatches(" + predicate + ")".     } else {         return "whenAnyDoneMatches(" + predicate + ")".     } }
false;private;2;48;;private NotifyBuilder doWhenAnyMatches(final Predicate predicate, final boolean received) {     stack.add(new EventPredicateSupport() {          private final AtomicBoolean matches = new AtomicBoolean().          @Override         public boolean onExchangeCompleted(Exchange exchange) {             if (!received && !matches.get()) {                 matches.set(predicate.matches(exchange)).             }             return true.         }          @Override         public boolean onExchangeFailed(Exchange exchange) {             if (!received && !matches.get()) {                 matches.set(predicate.matches(exchange)).             }             return true.         }          @Override         public boolean onExchangeCreated(Exchange exchange) {             if (received && !matches.get()) {                 matches.set(predicate.matches(exchange)).             }             return true.         }          public boolean matches() {             return matches.get().         }          @Override         public void reset() {             matches.set(false).         }          @Override         public String toString() {             if (received) {                 return "whenAnyReceivedMatches(" + predicate + ")".             } else {                 return "whenAnyDoneMatches(" + predicate + ")".             }         }     }).     return this. }
true;public;1;3;/**  * Sets a condition that <b>all received</b> {@link Exchange} should match the {@link Predicate}  *  * @param predicate the predicate  * @return the builder  */ ;/**  * Sets a condition that <b>all received</b> {@link Exchange} should match the {@link Predicate}  *  * @param predicate the predicate  * @return the builder  */ public NotifyBuilder whenAllReceivedMatches(final Predicate predicate) {     return doWhenAllMatches(predicate, true). }
true;public;1;3;/**  * Sets a condition that <b>all done</b> {@link Exchange} should match the {@link Predicate}  *  * @param predicate the predicate  * @return the builder  */ ;/**  * Sets a condition that <b>all done</b> {@link Exchange} should match the {@link Predicate}  *  * @param predicate the predicate  * @return the builder  */ public NotifyBuilder whenAllDoneMatches(final Predicate predicate) {     return doWhenAllMatches(predicate, false). }
false;public;1;7;;@Override public boolean onExchangeCompleted(Exchange exchange) {     if (!received && matches.get()) {         matches.set(predicate.matches(exchange)).     }     return true. }
false;public;1;7;;@Override public boolean onExchangeFailed(Exchange exchange) {     if (!received && matches.get()) {         matches.set(predicate.matches(exchange)).     }     return true. }
false;public;1;7;;@Override public boolean onExchangeCreated(Exchange exchange) {     if (received && matches.get()) {         matches.set(predicate.matches(exchange)).     }     return true. }
false;public;0;3;;public boolean matches() {     return matches.get(). }
false;public;0;4;;@Override public void reset() {     matches.set(true). }
false;public;0;8;;@Override public String toString() {     if (received) {         return "whenAllReceivedMatches(" + predicate + ")".     } else {         return "whenAllDoneMatches(" + predicate + ")".     } }
false;private;2;48;;private NotifyBuilder doWhenAllMatches(final Predicate predicate, final boolean received) {     stack.add(new EventPredicateSupport() {          private final AtomicBoolean matches = new AtomicBoolean(true).          @Override         public boolean onExchangeCompleted(Exchange exchange) {             if (!received && matches.get()) {                 matches.set(predicate.matches(exchange)).             }             return true.         }          @Override         public boolean onExchangeFailed(Exchange exchange) {             if (!received && matches.get()) {                 matches.set(predicate.matches(exchange)).             }             return true.         }          @Override         public boolean onExchangeCreated(Exchange exchange) {             if (received && matches.get()) {                 matches.set(predicate.matches(exchange)).             }             return true.         }          public boolean matches() {             return matches.get().         }          @Override         public void reset() {             matches.set(true).         }          @Override         public String toString() {             if (received) {                 return "whenAllReceivedMatches(" + predicate + ")".             } else {                 return "whenAllDoneMatches(" + predicate + ")".             }         }     }).     return this. }
true;public;1;3;/**  * Sets a condition when the provided mock is satisfied based on {@link Exchange}  * being sent to it when they are <b>done</b>.  * <p/>  * The idea is that you can use Mock for setting fine grained expectations  * and then use that together with this builder. The mock provided does <b>NOT</b>  * have to already exist in the route. You can just create a new pseudo mock  * and this builder will send the done {@link Exchange} to it. So its like  * adding the mock to the end of your route(s).  *  * @param mock the mock  * @return the builder  */ ;/**  * Sets a condition when the provided mock is satisfied based on {@link Exchange}  * being sent to it when they are <b>done</b>.  * <p/>  * The idea is that you can use Mock for setting fine grained expectations  * and then use that together with this builder. The mock provided does <b>NOT</b>  * have to already exist in the route. You can just create a new pseudo mock  * and this builder will send the done {@link Exchange} to it. So its like  * adding the mock to the end of your route(s).  *  * @param mock the mock  * @return the builder  */ public NotifyBuilder whenDoneSatisfied(final MockEndpoint mock) {     return doWhenSatisfied(mock, false). }
true;public;1;3;/**  * Sets a condition when the provided mock is satisfied based on {@link Exchange}  * being sent to it when they are <b>received</b>.  * <p/>  * The idea is that you can use Mock for setting fine grained expectations  * and then use that together with this builder. The mock provided does <b>NOT</b>  * have to already exist in the route. You can just create a new pseudo mock  * and this builder will send the done {@link Exchange} to it. So its like  * adding the mock to the end of your route(s).  *  * @param mock the mock  * @return the builder  */ ;/**  * Sets a condition when the provided mock is satisfied based on {@link Exchange}  * being sent to it when they are <b>received</b>.  * <p/>  * The idea is that you can use Mock for setting fine grained expectations  * and then use that together with this builder. The mock provided does <b>NOT</b>  * have to already exist in the route. You can just create a new pseudo mock  * and this builder will send the done {@link Exchange} to it. So its like  * adding the mock to the end of your route(s).  *  * @param mock the mock  * @return the builder  */ public NotifyBuilder whenReceivedSatisfied(final MockEndpoint mock) {     return doWhenSatisfied(mock, true). }
false;public;1;7;;@Override public boolean onExchangeCreated(Exchange exchange) {     if (received) {         sendToMock(exchange).     }     return true. }
false;public;1;7;;@Override public boolean onExchangeFailed(Exchange exchange) {     if (!received) {         sendToMock(exchange).     }     return true. }
false;public;1;7;;@Override public boolean onExchangeCompleted(Exchange exchange) {     if (!received) {         sendToMock(exchange).     }     return true. }
false;private;1;11;;private void sendToMock(Exchange exchange) {     // send the exchange when its completed to the mock     try {         if (producer == null) {             producer = mock.createProducer().         }         producer.process(exchange).     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;public;0;7;;public boolean matches() {     try {         return mock.await(0, TimeUnit.SECONDS).     } catch (InterruptedException e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;public;0;4;;@Override public void reset() {     mock.reset(). }
false;public;0;8;;@Override public String toString() {     if (received) {         return "whenReceivedSatisfied(" + mock + ")".     } else {         return "whenDoneSatisfied(" + mock + ")".     } }
false;private;2;64;;private NotifyBuilder doWhenSatisfied(final MockEndpoint mock, final boolean received) {     stack.add(new EventPredicateSupport() {          private Producer producer.          @Override         public boolean onExchangeCreated(Exchange exchange) {             if (received) {                 sendToMock(exchange).             }             return true.         }          @Override         public boolean onExchangeFailed(Exchange exchange) {             if (!received) {                 sendToMock(exchange).             }             return true.         }          @Override         public boolean onExchangeCompleted(Exchange exchange) {             if (!received) {                 sendToMock(exchange).             }             return true.         }          private void sendToMock(Exchange exchange) {             // send the exchange when its completed to the mock             try {                 if (producer == null) {                     producer = mock.createProducer().                 }                 producer.process(exchange).             } catch (Exception e) {                 throw RuntimeCamelException.wrapRuntimeCamelException(e).             }         }          public boolean matches() {             try {                 return mock.await(0, TimeUnit.SECONDS).             } catch (InterruptedException e) {                 throw RuntimeCamelException.wrapRuntimeCamelException(e).             }         }          @Override         public void reset() {             mock.reset().         }          @Override         public String toString() {             if (received) {                 return "whenReceivedSatisfied(" + mock + ")".             } else {                 return "whenDoneSatisfied(" + mock + ")".             }         }     }).     return this. }
true;public;1;3;/**  * Sets a condition when the provided mock is <b>not</b> satisfied based on {@link Exchange}  * being sent to it when they are <b>received</b>.  * <p/>  * The idea is that you can use Mock for setting fine grained expectations  * and then use that together with this builder. The mock provided does <b>NOT</b>  * have to already exist in the route. You can just create a new pseudo mock  * and this builder will send the done {@link Exchange} to it. So its like  * adding the mock to the end of your route(s).  *  * @param mock the mock  * @return the builder  */ ;/**  * Sets a condition when the provided mock is <b>not</b> satisfied based on {@link Exchange}  * being sent to it when they are <b>received</b>.  * <p/>  * The idea is that you can use Mock for setting fine grained expectations  * and then use that together with this builder. The mock provided does <b>NOT</b>  * have to already exist in the route. You can just create a new pseudo mock  * and this builder will send the done {@link Exchange} to it. So its like  * adding the mock to the end of your route(s).  *  * @param mock the mock  * @return the builder  */ public NotifyBuilder whenReceivedNotSatisfied(final MockEndpoint mock) {     return doWhenNotSatisfied(mock, true). }
true;public;1;3;/**  * Sets a condition when the provided mock is <b>not</b> satisfied based on {@link Exchange}  * being sent to it when they are <b>done</b>.  * <p/>  * The idea is that you can use Mock for setting fine grained expectations  * and then use that together with this builder. The mock provided does <b>NOT</b>  * have to already exist in the route. You can just create a new pseudo mock  * and this builder will send the done {@link Exchange} to it. So its like  * adding the mock to the end of your route(s).  *  * @param mock the mock  * @return the builder  */ ;/**  * Sets a condition when the provided mock is <b>not</b> satisfied based on {@link Exchange}  * being sent to it when they are <b>done</b>.  * <p/>  * The idea is that you can use Mock for setting fine grained expectations  * and then use that together with this builder. The mock provided does <b>NOT</b>  * have to already exist in the route. You can just create a new pseudo mock  * and this builder will send the done {@link Exchange} to it. So its like  * adding the mock to the end of your route(s).  *  * @param mock the mock  * @return the builder  */ public NotifyBuilder whenDoneNotSatisfied(final MockEndpoint mock) {     return doWhenNotSatisfied(mock, false). }
false;public;1;7;;@Override public boolean onExchangeCreated(Exchange exchange) {     if (received) {         sendToMock(exchange).     }     return true. }
false;public;1;7;;@Override public boolean onExchangeFailed(Exchange exchange) {     if (!received) {         sendToMock(exchange).     }     return true. }
false;public;1;7;;@Override public boolean onExchangeCompleted(Exchange exchange) {     if (!received) {         sendToMock(exchange).     }     return true. }
false;private;1;11;;private void sendToMock(Exchange exchange) {     // send the exchange when its completed to the mock     try {         if (producer == null) {             producer = mock.createProducer().         }         producer.process(exchange).     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;public;0;7;;public boolean matches() {     try {         return !mock.await(0, TimeUnit.SECONDS).     } catch (InterruptedException e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;public;0;4;;@Override public void reset() {     mock.reset(). }
false;public;0;8;;@Override public String toString() {     if (received) {         return "whenReceivedNotSatisfied(" + mock + ")".     } else {         return "whenDoneNotSatisfied(" + mock + ")".     } }
false;private;2;64;;private NotifyBuilder doWhenNotSatisfied(final MockEndpoint mock, final boolean received) {     stack.add(new EventPredicateSupport() {          private Producer producer.          @Override         public boolean onExchangeCreated(Exchange exchange) {             if (received) {                 sendToMock(exchange).             }             return true.         }          @Override         public boolean onExchangeFailed(Exchange exchange) {             if (!received) {                 sendToMock(exchange).             }             return true.         }          @Override         public boolean onExchangeCompleted(Exchange exchange) {             if (!received) {                 sendToMock(exchange).             }             return true.         }          private void sendToMock(Exchange exchange) {             // send the exchange when its completed to the mock             try {                 if (producer == null) {                     producer = mock.createProducer().                 }                 producer.process(exchange).             } catch (Exception e) {                 throw RuntimeCamelException.wrapRuntimeCamelException(e).             }         }          public boolean matches() {             try {                 return !mock.await(0, TimeUnit.SECONDS).             } catch (InterruptedException e) {                 throw RuntimeCamelException.wrapRuntimeCamelException(e).             }         }          @Override         public void reset() {             mock.reset().         }          @Override         public String toString() {             if (received) {                 return "whenReceivedNotSatisfied(" + mock + ")".             } else {                 return "whenDoneNotSatisfied(" + mock + ")".             }         }     }).     return this. }
true;public;1;5;/**  * Sets a condition that the bodies is expected to be <b>received</b> in the order as well.  * <p/>  * This condition will discard any additional messages. If you need a more strict condition  * then use {@link #whenExactBodiesReceived(Object...)}  *  * @param bodies the expected bodies  * @return the builder  * @see #whenExactBodiesReceived(Object...)  */ ;/**  * Sets a condition that the bodies is expected to be <b>received</b> in the order as well.  * <p/>  * This condition will discard any additional messages. If you need a more strict condition  * then use {@link #whenExactBodiesReceived(Object...)}  *  * @param bodies the expected bodies  * @return the builder  * @see #whenExactBodiesReceived(Object...)  */ public NotifyBuilder whenBodiesReceived(Object... bodies) {     List<Object> bodyList = new ArrayList<>().     bodyList.addAll(Arrays.asList(bodies)).     return doWhenBodies(bodyList, true, false). }
true;public;1;5;/**  * Sets a condition that the bodies is expected to be <b>done</b> in the order as well.  * <p/>  * This condition will discard any additional messages. If you need a more strict condition  * then use {@link #whenExactBodiesDone(Object...)}  *  * @param bodies the expected bodies  * @return the builder  * @see #whenExactBodiesDone(Object...)  */ ;/**  * Sets a condition that the bodies is expected to be <b>done</b> in the order as well.  * <p/>  * This condition will discard any additional messages. If you need a more strict condition  * then use {@link #whenExactBodiesDone(Object...)}  *  * @param bodies the expected bodies  * @return the builder  * @see #whenExactBodiesDone(Object...)  */ public NotifyBuilder whenBodiesDone(Object... bodies) {     List<Object> bodyList = new ArrayList<>().     bodyList.addAll(Arrays.asList(bodies)).     return doWhenBodies(bodyList, false, false). }
true;public;1;5;/**  * Sets a condition that the bodies is expected to be <b>received</b> in the order as well.  * <p/>  * This condition is strict which means that it only expect that exact number of bodies  *  * @param bodies the expected bodies  * @return the builder  * @see #whenBodiesReceived(Object...)  */ ;/**  * Sets a condition that the bodies is expected to be <b>received</b> in the order as well.  * <p/>  * This condition is strict which means that it only expect that exact number of bodies  *  * @param bodies the expected bodies  * @return the builder  * @see #whenBodiesReceived(Object...)  */ public NotifyBuilder whenExactBodiesReceived(Object... bodies) {     List<Object> bodyList = new ArrayList<>().     bodyList.addAll(Arrays.asList(bodies)).     return doWhenBodies(bodyList, true, true). }
true;public;1;5;/**  * Sets a condition that the bodies is expected to be <b>done</b> in the order as well.  * <p/>  * This condition is strict which means that it only expect that exact number of bodies  *  * @param bodies the expected bodies  * @return the builder  * @see #whenExactBodiesDone(Object...)  */ ;/**  * Sets a condition that the bodies is expected to be <b>done</b> in the order as well.  * <p/>  * This condition is strict which means that it only expect that exact number of bodies  *  * @param bodies the expected bodies  * @return the builder  * @see #whenExactBodiesDone(Object...)  */ public NotifyBuilder whenExactBodiesDone(Object... bodies) {     List<Object> bodyList = new ArrayList<>().     bodyList.addAll(Arrays.asList(bodies)).     return doWhenBodies(bodyList, false, true). }
false;public;1;7;;@Override public boolean onExchangeCreated(Exchange exchange) {     if (received) {         matchBody(exchange).     }     return true. }
false;public;1;7;;@Override public boolean onExchangeFailed(Exchange exchange) {     if (!received) {         matchBody(exchange).     }     return true. }
false;public;1;7;;@Override public boolean onExchangeCompleted(Exchange exchange) {     if (!received) {         matchBody(exchange).     }     return true. }
false;private;1;10;;private void matchBody(Exchange exchange) {     if (current.incrementAndGet() > bodies.size()) {         // out of bounds         return.     }     Object actual = exchange.getIn().getBody().     Object expected = bodies.get(current.get() - 1).     matches = ObjectHelper.equal(expected, actual). }
false;public;0;7;;public boolean matches() {     if (exact) {         return matches && current.get() == bodies.size().     } else {         return matches && current.get() >= bodies.size().     } }
false;public;0;5;;@Override public void reset() {     matches = false.     current.set(0). }
false;public;0;8;;@Override public String toString() {     if (received) {         return "" + (exact ? "whenExactBodiesReceived(" : "whenBodiesReceived(") + bodies + ")".     } else {         return "" + (exact ? "whenExactBodiesDone(" : "whenBodiesDone(") + bodies + ")".     } }
false;private;3;65;;private NotifyBuilder doWhenBodies(final List<?> bodies, final boolean received, final boolean exact) {     stack.add(new EventPredicateSupport() {          private volatile boolean matches.          private final AtomicInteger current = new AtomicInteger().          @Override         public boolean onExchangeCreated(Exchange exchange) {             if (received) {                 matchBody(exchange).             }             return true.         }          @Override         public boolean onExchangeFailed(Exchange exchange) {             if (!received) {                 matchBody(exchange).             }             return true.         }          @Override         public boolean onExchangeCompleted(Exchange exchange) {             if (!received) {                 matchBody(exchange).             }             return true.         }          private void matchBody(Exchange exchange) {             if (current.incrementAndGet() > bodies.size()) {                 // out of bounds                 return.             }             Object actual = exchange.getIn().getBody().             Object expected = bodies.get(current.get() - 1).             matches = ObjectHelper.equal(expected, actual).         }          public boolean matches() {             if (exact) {                 return matches && current.get() == bodies.size().             } else {                 return matches && current.get() >= bodies.size().             }         }          @Override         public void reset() {             matches = false.             current.set(0).         }          @Override         public String toString() {             if (received) {                 return "" + (exact ? "whenExactBodiesReceived(" : "whenBodiesReceived(") + bodies + ")".             } else {                 return "" + (exact ? "whenExactBodiesDone(" : "whenBodiesDone(") + bodies + ")".             }         }     }).     return this. }
true;public;0;4;/**  * Prepares to append an additional expression using the <i>and</i> operator.  *  * @return the builder  */ ;/**  * Prepares to append an additional expression using the <i>and</i> operator.  *  * @return the builder  */ public NotifyBuilder and() {     doCreate(EventOperation.and).     return this. }
true;public;0;4;/**  * Prepares to append an additional expression using the <i>or</i> operator.  *  * @return the builder  */ ;/**  * Prepares to append an additional expression using the <i>or</i> operator.  *  * @return the builder  */ public NotifyBuilder or() {     doCreate(EventOperation.or).     return this. }
true;public;0;4;/**  * Prepares to append an additional expression using the <i>not</i> operator.  *  * @return the builder  */ ;/**  * Prepares to append an additional expression using the <i>not</i> operator.  *  * @return the builder  */ public NotifyBuilder not() {     doCreate(EventOperation.not).     return this. }
true;public;0;8;/**  * Creates the expression this builder should use for matching.  * <p/>  * You must call this method when you are finished building the expressions.  *  * @return the created builder ready for matching  */ ;/**  * Creates the expression this builder should use for matching.  * <p/>  * You must call this method when you are finished building the expressions.  *  * @return the created builder ready for matching  */ public NotifyBuilder create() {     doCreate(EventOperation.and).     if (eventNotifier.isStopped()) {         throw new IllegalStateException("A destroyed NotifyBuilder cannot be re-created.").     }     created = true.     return this. }
true;public;0;9;/**  * De-registers this builder from its {@link CamelContext}.  * <p/>  * Once destroyed, this instance will not function again.  */ ;/**  * De-registers this builder from its {@link CamelContext}.  * <p/>  * Once destroyed, this instance will not function again.  */ public void destroy() {     context.getManagementStrategy().removeEventNotifier(eventNotifier).     try {         ServiceHelper.stopService(eventNotifier).     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     }     created = false. }
true;public;0;6;/**  * Does all the expression match?  * <p/>  * This operation will return immediately which means it can be used for testing at this very moment.  *  * @return <tt>true</tt> if matching, <tt>false</tt> otherwise  */ ;/**  * Does all the expression match?  * <p/>  * This operation will return immediately which means it can be used for testing at this very moment.  *  * @return <tt>true</tt> if matching, <tt>false</tt> otherwise  */ public boolean matches() {     if (!created) {         throw new IllegalStateException("NotifyBuilder has not been created. Invoke the create() method before matching.").     }     return matches. }
true;public;2;11;/**  * Does all the expression match?  * <p/>  * This operation will wait until the match is <tt>true</tt> or otherwise a timeout occur  * which means <tt>false</tt> will be returned.  *  * @param timeout  the timeout value  * @param timeUnit the time unit  * @return <tt>true</tt> if matching, <tt>false</tt> otherwise due to timeout  */ ;/**  * Does all the expression match?  * <p/>  * This operation will wait until the match is <tt>true</tt> or otherwise a timeout occur  * which means <tt>false</tt> will be returned.  *  * @param timeout  the timeout value  * @param timeUnit the time unit  * @return <tt>true</tt> if matching, <tt>false</tt> otherwise due to timeout  */ public boolean matches(long timeout, TimeUnit timeUnit) {     if (!created) {         throw new IllegalStateException("NotifyBuilder has not been created. Invoke the create() method before matching.").     }     try {         latch.await(timeout, timeUnit).     } catch (InterruptedException e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     }     return matches(). }
true;public;0;21;/**  * Does all the expressions match?  * <p/>  * This operation will wait until the match is <tt>true</tt> or otherwise a timeout occur  * which means <tt>false</tt> will be returned.  * <p/>  * The timeout value is by default 10 seconds. But it will use the highest <i>maximum result wait time</i>  * from the configured mocks, if such a value has been configured.  * <p/>  * This method is convenient to use in unit tests to have it adhere and wait  * as long as the mock endpoints.  *  * @return <tt>true</tt> if matching, <tt>false</tt> otherwise due to timeout  */ ;/**  * Does all the expressions match?  * <p/>  * This operation will wait until the match is <tt>true</tt> or otherwise a timeout occur  * which means <tt>false</tt> will be returned.  * <p/>  * The timeout value is by default 10 seconds. But it will use the highest <i>maximum result wait time</i>  * from the configured mocks, if such a value has been configured.  * <p/>  * This method is convenient to use in unit tests to have it adhere and wait  * as long as the mock endpoints.  *  * @return <tt>true</tt> if matching, <tt>false</tt> otherwise due to timeout  */ public boolean matchesMockWaitTime() {     if (!created) {         throw new IllegalStateException("NotifyBuilder has not been created. Invoke the create() method before matching.").     }     long timeout = 0.     for (Endpoint endpoint : context.getEndpoints()) {         if (endpoint instanceof MockEndpoint) {             long waitTime = ((MockEndpoint) endpoint).getResultWaitTime().             if (waitTime > 0) {                 timeout = Math.max(timeout, waitTime).             }         }     }     // use 10 sec as default     if (timeout == 0) {         timeout = 10000.     }     return matches(timeout, TimeUnit.MILLISECONDS). }
true;public;0;7;/**  * Resets the notifier.  */ ;/**  * Resets the notifier.  */ public void reset() {     for (EventPredicateHolder predicate : predicates) {         predicate.reset().     }     latch = new CountDownLatch(1).     matches = false. }
false;public;0;12;;@Override public String toString() {     StringBuilder sb = new StringBuilder().     for (EventPredicateHolder eventPredicateHolder : predicates) {         if (sb.length() > 0) {             sb.append(".").         }         sb.append(eventPredicateHolder.toString()).     }     // a crude way of skipping the first invisible operation     return StringHelper.after(sb.toString(), "()."). }
false;private;1;35;;private void doCreate(EventOperation newOperation) {     // init operation depending on the newOperation     if (operation == null) {         // if the first new operation is an or then this operation must be an or as well         // otherwise it should be and based         operation = newOperation == EventOperation.or ? EventOperation.or : EventOperation.and.     }     // we have some predicates     if (!stack.isEmpty()) {         // we only want to match from routes, so skip for example events         // which is triggered by producer templates etc.         fromRoutesOnly().         // the stack must have at least one non abstract         boolean found = false.         for (EventPredicate predicate : stack) {             if (!predicate.isAbstract()) {                 found = true.                 break.             }         }         if (!found) {             throw new IllegalArgumentException("NotifyBuilder must contain at least one non-abstract predicate (such as whenDone)").         }         CompoundEventPredicate compound = new CompoundEventPredicate(stack).         stack.clear().         predicates.add(new EventPredicateHolder(operation, compound)).     }     operation = newOperation.     // reset wereSentTo index position as this its a new group     wereSentToIndex = 0. }
false;public;1;14;;public void notify(CamelEvent event) throws Exception {     if (event instanceof ExchangeCreatedEvent) {         onExchangeCreated((ExchangeCreatedEvent) event).     } else if (event instanceof ExchangeCompletedEvent) {         onExchangeCompleted((ExchangeCompletedEvent) event).     } else if (event instanceof ExchangeFailedEvent) {         onExchangeFailed((ExchangeFailedEvent) event).     } else if (event instanceof ExchangeSentEvent) {         onExchangeSent((ExchangeSentEvent) event).     }     // now compute whether we matched     computeMatches(). }
false;public;1;3;;public boolean isEnabled(CamelEvent event) {     return true. }
false;private;1;5;;private void onExchangeCreated(ExchangeCreatedEvent event) {     for (EventPredicateHolder predicate : predicates) {         predicate.getPredicate().onExchangeCreated(event.getExchange()).     } }
false;private;1;5;;private void onExchangeCompleted(ExchangeCompletedEvent event) {     for (EventPredicateHolder predicate : predicates) {         predicate.getPredicate().onExchangeCompleted(event.getExchange()).     } }
false;private;1;5;;private void onExchangeFailed(ExchangeFailedEvent event) {     for (EventPredicateHolder predicate : predicates) {         predicate.getPredicate().onExchangeFailed(event.getExchange()).     } }
false;private;1;5;;private void onExchangeSent(ExchangeSentEvent event) {     for (EventPredicateHolder predicate : predicates) {         predicate.getPredicate().onExchangeSent(event.getExchange(), event.getEndpoint(), event.getTimeTaken()).     } }
false;private,synchronized;0;38;;private synchronized void computeMatches() {     // use a temporary answer until we have computed the value to assign     Boolean answer = null.     for (EventPredicateHolder holder : predicates) {         EventOperation operation = holder.getOperation().         if (EventOperation.and == operation) {             if (holder.getPredicate().matches()) {                 answer = true.             } else {                 answer = false.                 // and break out since its an AND so it must match                 break.             }         } else if (EventOperation.or == operation) {             if (holder.getPredicate().matches()) {                 answer = true.             }         } else if (EventOperation.not == operation) {             if (holder.getPredicate().matches()) {                 answer = false.                 // and break out since its a NOT so it must not match                 break.             } else {                 answer = true.             }         }     }     // if we did compute a value then assign that     if (answer != null) {         matches = answer.         if (matches) {             // signal completion             latch.countDown().         }     } }
false;protected;0;7;;@Override protected void doStart() throws Exception {     // we only care about Exchange events     setIgnoreCamelContextEvents(true).     setIgnoreRouteEvents(true).     setIgnoreServiceEvents(true). }
true;;0;1;/**  * Evaluates whether the predicate matched or not.  *  * @return <tt>true</tt> if matched, <tt>false</tt> otherwise  */ ;/**  * Evaluates whether the predicate matched or not.  *  * @return <tt>true</tt> if matched, <tt>false</tt> otherwise  */ boolean matches().
true;;0;1;/**  * Resets the predicate  */ ;/**  * Resets the predicate  */ void reset().
true;;0;1;/**  * Whether the predicate is abstract  */ ;/**  * Whether the predicate is abstract  */ boolean isAbstract().
true;;1;1;/**  * Callback for {@link Exchange} lifecycle  *  * @param exchange the exchange  * @return <tt>true</tt> to allow continue evaluating, <tt>false</tt> to stop immediately  */ ;/**  * Callback for {@link Exchange} lifecycle  *  * @param exchange the exchange  * @return <tt>true</tt> to allow continue evaluating, <tt>false</tt> to stop immediately  */ boolean onExchangeCreated(Exchange exchange).
true;;1;1;/**  * Callback for {@link Exchange} lifecycle  *  * @param exchange the exchange  * @return <tt>true</tt> to allow continue evaluating, <tt>false</tt> to stop immediately  */ ;/**  * Callback for {@link Exchange} lifecycle  *  * @param exchange the exchange  * @return <tt>true</tt> to allow continue evaluating, <tt>false</tt> to stop immediately  */ boolean onExchangeCompleted(Exchange exchange).
true;;1;1;/**  * Callback for {@link Exchange} lifecycle  *  * @param exchange the exchange  * @return <tt>true</tt> to allow continue evaluating, <tt>false</tt> to stop immediately  */ ;/**  * Callback for {@link Exchange} lifecycle  *  * @param exchange the exchange  * @return <tt>true</tt> to allow continue evaluating, <tt>false</tt> to stop immediately  */ boolean onExchangeFailed(Exchange exchange).
true;;3;1;/**  * Callback for {@link Exchange} lifecycle  *  * @param exchange the exchange  * @param endpoint the endpoint sent to  * @param timeTaken time taken in millis to send the to endpoint  * @return <tt>true</tt> to allow continue evaluating, <tt>false</tt> to stop immediately  */ ;/**  * Callback for {@link Exchange} lifecycle  *  * @param exchange the exchange  * @param endpoint the endpoint sent to  * @param timeTaken time taken in millis to send the to endpoint  * @return <tt>true</tt> to allow continue evaluating, <tt>false</tt> to stop immediately  */ boolean onExchangeSent(Exchange exchange, Endpoint endpoint, long timeTaken).
false;public;0;3;;public boolean isAbstract() {     return false. }
false;public;0;3;;public void reset() { // noop }
false;public;1;3;;public boolean onExchangeCreated(Exchange exchange) {     return onExchange(exchange). }
false;public;1;3;;public boolean onExchangeCompleted(Exchange exchange) {     return onExchange(exchange). }
false;public;1;3;;public boolean onExchangeFailed(Exchange exchange) {     return onExchange(exchange). }
false;public;3;5;;public boolean onExchangeSent(Exchange exchange, Endpoint endpoint, long timeTaken) {     // was sent to a specific endpoint     return true. }
false;public;1;3;;public boolean onExchange(Exchange exchange) {     return true. }
false;public;0;3;;public EventOperation getOperation() {     return operation. }
false;public;0;3;;public EventPredicate getPredicate() {     return predicate. }
false;public;0;3;;public void reset() {     predicate.reset(). }
false;public;0;4;;@Override public String toString() {     return operation.name() + "()." + predicate. }
false;public;0;3;;public boolean isAbstract() {     return false. }
false;public;0;11;;public boolean matches() {     for (EventPredicate predicate : predicates) {         boolean answer = predicate.matches().         LOG.trace("matches() {} -> {}", predicate, answer).         if (!answer) {             // break at first false             return false.         }     }     return true. }
false;public;0;6;;public void reset() {     for (EventPredicate predicate : predicates) {         LOG.trace("reset() {}", predicate).         predicate.reset().     } }
false;public;1;11;;public boolean onExchangeCreated(Exchange exchange) {     for (EventPredicate predicate : predicates) {         boolean answer = predicate.onExchangeCreated(exchange).         LOG.trace("onExchangeCreated() {} -> {}", predicate, answer).         if (!answer) {             // break at first false             return false.         }     }     return true. }
false;public;1;11;;public boolean onExchangeCompleted(Exchange exchange) {     for (EventPredicate predicate : predicates) {         boolean answer = predicate.onExchangeCompleted(exchange).         LOG.trace("onExchangeCompleted() {} -> {}", predicate, answer).         if (!answer) {             // break at first false             return false.         }     }     return true. }
false;public;1;11;;public boolean onExchangeFailed(Exchange exchange) {     for (EventPredicate predicate : predicates) {         boolean answer = predicate.onExchangeFailed(exchange).         LOG.trace("onExchangeFailed() {} -> {}", predicate, answer).         if (!answer) {             // break at first false             return false.         }     }     return true. }
false;public;3;12;;@Override public boolean onExchangeSent(Exchange exchange, Endpoint endpoint, long timeTaken) {     for (EventPredicate predicate : predicates) {         boolean answer = predicate.onExchangeSent(exchange, endpoint, timeTaken).         LOG.trace("onExchangeSent() {} {} -> {}", endpoint, predicate, answer).         if (!answer) {             // break at first false             return false.         }     }     return true. }
false;public;0;11;;@Override public String toString() {     StringBuilder sb = new StringBuilder().     for (EventPredicate eventPredicate : predicates) {         if (sb.length() > 0) {             sb.append(".").         }         sb.append(eventPredicate.toString()).     }     return sb.toString(). }
