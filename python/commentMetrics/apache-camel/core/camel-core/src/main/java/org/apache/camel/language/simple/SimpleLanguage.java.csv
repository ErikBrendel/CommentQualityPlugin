commented;modifiers;parameterAmount;loc;comment;code
false;public;0;15;;@Override @SuppressWarnings("unchecked") public void start() throws Exception {     // setup cache which requires CamelContext to be set first     if (cacheExpression == null && cachePredicate == null && getCamelContext() != null) {         int maxSize = CamelContextHelper.getMaximumSimpleCacheSize(getCamelContext()).         if (maxSize > 0) {             cacheExpression = LRUCacheFactory.newLRUCache(16, maxSize, false).             cachePredicate = LRUCacheFactory.newLRUCache(16, maxSize, false).             LOG.debug("Simple language predicate/expression cache size: {}", maxSize).         } else {             LOG.debug("Simple language disabled predicate/expression cache").         }     } }
false;public;0;17;;@Override public void stop() throws Exception {     if (cachePredicate instanceof LRUCache) {         if (LOG.isDebugEnabled()) {             LRUCache cache = (LRUCache) cachePredicate.             LOG.debug("Clearing simple language predicate cache[size={}, hits={}, misses={}, evicted={}]", cache.size(), cache.getHits(), cache.getMisses(), cache.getEvicted()).         }     }     if (cacheExpression instanceof LRUCache) {         if (LOG.isDebugEnabled()) {             LRUCache cache = (LRUCache) cacheExpression.             LOG.debug("Clearing simple language expression cache[size={}, hits={}, misses={}, evicted={}]", cache.size(), cache.getHits(), cache.getMisses(), cache.getEvicted()).         }     } }
false;public;1;18;;public Predicate createPredicate(String expression) {     ObjectHelper.notNull(expression, "expression").     Predicate answer = cachePredicate != null ? cachePredicate.get(expression) : null.     if (answer == null) {         expression = loadResource(expression).         SimplePredicateParser parser = new SimplePredicateParser(expression, allowEscape, cacheExpression).         answer = parser.parsePredicate().         if (cachePredicate != null && answer != null) {             cachePredicate.put(expression, answer).         }     }     return answer. }
false;public;1;18;;public Expression createExpression(String expression) {     ObjectHelper.notNull(expression, "expression").     Expression answer = cacheExpression != null ? cacheExpression.get(expression) : null.     if (answer == null) {         expression = loadResource(expression).         SimpleExpressionParser parser = new SimpleExpressionParser(expression, allowEscape, cacheExpression).         answer = parser.parseExpression().         if (cacheExpression != null && answer != null) {             cacheExpression.put(expression, answer).         }     }     return answer. }
true;public,static;1;3;/**  * Creates a new {@link Expression}.  * <p/>  * <b>Important:</b> If you need to use a predicate (function to return true|false) then use  * {@link #predicate(String)} instead.  */ ;/**  * Creates a new {@link Expression}.  * <p/>  * <b>Important:</b> If you need to use a predicate (function to return true|false) then use  * {@link #predicate(String)} instead.  */ public static Expression simple(String expression) {     return expression(expression). }
true;public,static;2;3;/**  * Creates a new {@link Expression} (or {@link Predicate}  * if the resultType is a <tt>Boolean</tt>, or <tt>boolean</tt> type).  */ ;/**  * Creates a new {@link Expression} (or {@link Predicate}  * if the resultType is a <tt>Boolean</tt>, or <tt>boolean</tt> type).  */ public static Expression simple(String expression, Class<?> resultType) {     return new SimpleLanguage().createExpression(expression, resultType). }
false;public;2;13;;public Expression createExpression(String expression, Class<?> resultType) {     if (resultType == Boolean.class || resultType == boolean.class) {         // if its a boolean as result then its a predicate         Predicate predicate = createPredicate(expression).         return PredicateToExpressionAdapter.toExpression(predicate).     } else {         Expression exp = createExpression(expression).         if (resultType != null) {             exp = ExpressionBuilder.convertToExpression(exp, resultType).         }         return exp.     } }
true;public,static;1;3;/**  * Creates a new {@link Expression}.  * <p/>  * <b>Important:</b> If you need to use a predicate (function to return true|false) then use  * {@link #predicate(String)} instead.  */ ;/**  * Creates a new {@link Expression}.  * <p/>  * <b>Important:</b> If you need to use a predicate (function to return true|false) then use  * {@link #predicate(String)} instead.  */ public static Expression expression(String expression) {     return SIMPLE.createExpression(expression). }
true;public,static;1;3;/**  * Creates a new {@link Predicate}.  */ ;/**  * Creates a new {@link Predicate}.  */ public static Predicate predicate(String predicate) {     return SIMPLE.createPredicate(predicate). }
true;public,static;1;3;/**  * Does the expression include a simple function.  *  * @param expression the expression  * @return <tt>true</tt> if one or more simple function is included in the expression  */ ;/**  * Does the expression include a simple function.  *  * @param expression the expression  * @return <tt>true</tt> if one or more simple function is included in the expression  */ public static boolean hasSimpleFunction(String expression) {     return SimpleTokenizer.hasFunctionStartToken(expression). }
true;public,static;1;3;/**  * Change the start tokens used for functions.  * <p/>  * This can be used to alter the function tokens to avoid clashes with other  * frameworks etc.  * <p/>  * The default start tokens is <tt>${</tt> and <tt>$simple{</tt>.  *  * @param startToken new start token(s) to be used for functions  */ ;/**  * Change the start tokens used for functions.  * <p/>  * This can be used to alter the function tokens to avoid clashes with other  * frameworks etc.  * <p/>  * The default start tokens is <tt>${</tt> and <tt>$simple{</tt>.  *  * @param startToken new start token(s) to be used for functions  */ public static void changeFunctionStartToken(String... startToken) {     SimpleTokenizer.changeFunctionStartToken(startToken). }
true;public,static;1;3;/**  * Change the end tokens used for functions.  * <p/>  * This can be used to alter the function tokens to avoid clashes with other  * frameworks etc.  * <p/>  * The default end token is <tt>}</tt>  *  * @param endToken new end token(s) to be used for functions  */ ;/**  * Change the end tokens used for functions.  * <p/>  * This can be used to alter the function tokens to avoid clashes with other  * frameworks etc.  * <p/>  * The default end token is <tt>}</tt>  *  * @param endToken new end token(s) to be used for functions  */ public static void changeFunctionEndToken(String... endToken) {     SimpleTokenizer.changeFunctionEndToken(endToken). }
true;public;1;3;/**  * Change the start token used for functions.  * <p/>  * This can be used to alter the function tokens to avoid clashes with other  * frameworks etc.  * <p/>  * The default start tokens is <tt>${</tt> and <tt>$simple{</tt>.  *  * @param startToken new start token to be used for functions  */ ;/**  * Change the start token used for functions.  * <p/>  * This can be used to alter the function tokens to avoid clashes with other  * frameworks etc.  * <p/>  * The default start tokens is <tt>${</tt> and <tt>$simple{</tt>.  *  * @param startToken new start token to be used for functions  */ public void setFunctionStartToken(String startToken) {     changeFunctionStartToken(startToken). }
true;public;1;3;/**  * Change the end token used for functions.  * <p/>  * This can be used to alter the function tokens to avoid clashes with other  * frameworks etc.  * <p/>  * The default end token is <tt>}</tt>  *  * @param endToken new end token to be used for functions  */ ;/**  * Change the end token used for functions.  * <p/>  * This can be used to alter the function tokens to avoid clashes with other  * frameworks etc.  * <p/>  * The default end token is <tt>}</tt>  *  * @param endToken new end token to be used for functions  */ public void setFunctionEndToken(String endToken) {     changeFunctionEndToken(endToken). }
