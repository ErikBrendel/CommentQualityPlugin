commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Endpoint getEndpoint() {     return producer.getEndpoint(). }
false;public;2;4;;@Override public boolean process(Exchange exchange, AsyncCallback callback) {     return callback(exchange, callback, true). }
false;public;2;23;;@Override public boolean process(Exchange exchange, AsyncCallback callback) {     // process the detour so we do the detour routing     if (log.isDebugEnabled()) {         log.debug("Sending to endpoint: {} is intercepted and detoured to: {} for exchange: {}", getEndpoint(), endpoint.getDetour(), exchange).     }     // add header with the real endpoint uri     exchange.getIn().setHeader(Exchange.INTERCEPTED_ENDPOINT, delegate.getEndpointUri()).     if (endpoint.getDetour() != null) {         // detour the exchange using synchronous processing         AsyncProcessor detour = AsyncProcessorConverterHelper.convert(endpoint.getDetour()).         AsyncProcessor ascb = new AsyncProcessorSupport() {              @Override             public boolean process(Exchange exchange, AsyncCallback callback) {                 return callback(exchange, callback, true).             }         }.         return new Pipeline(exchange.getContext(), Arrays.asList(detour, ascb)).process(exchange, callback).     }     return callback(exchange, callback, true). }
false;private;3;37;;private boolean callback(Exchange exchange, AsyncCallback callback, boolean doneSync) {     // check for error if so we should break out     if (!continueProcessing(exchange, "skip sending to original intended destination: " + getEndpoint(), log)) {         callback.done(doneSync).         return doneSync.     }     // determine if we should skip or not     boolean shouldSkip = skip.     // if then interceptor had a when predicate, then we should only skip if it matched     Boolean whenMatches = (Boolean) exchange.removeProperty(Exchange.INTERCEPT_SEND_TO_ENDPOINT_WHEN_MATCHED).     if (whenMatches != null) {         shouldSkip = skip && whenMatches.     }     if (!shouldSkip) {         if (exchange.hasOut()) {             // replace OUT with IN as detour changed something             exchange.setIn(exchange.getOut()).             exchange.setOut(null).         }         // route to original destination leveraging the asynchronous routing engine if possible         boolean s = producer.process(exchange, ds -> {             callback.done(doneSync && ds).         }).         return doneSync && s.     } else {         if (log.isDebugEnabled()) {             log.debug("Stop() means skip sending exchange to original intended destination: {} for exchange: {}", getEndpoint(), exchange).         }         callback.done(doneSync).         return doneSync.     } }
false;public;0;3;;public boolean isSingleton() {     return producer.isSingleton(). }
false;public;0;5;;public void start() throws Exception {     ServiceHelper.startService(endpoint.getDetour()).     // here we also need to start the producer     ServiceHelper.startService(producer). }
false;public;0;5;;public void stop() throws Exception {     // do not stop detour as it should only be stopped when the interceptor stops     // we should stop the producer here     ServiceHelper.stopService(producer). }
