commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public <T> T evaluate(Exchange exchange, Class<T> type) {     return expression.evaluate(exchange, type). }
false;public;1;4;;@Override public boolean matches(Exchange exchange) {     return PredicateBuilder.toPredicate(getExpression()).matches(exchange). }
false;public;0;3;;public Expression getExpression() {     return expression. }
false;public;0;4;;@Override public String toString() {     return expression.toString(). }
false;public;1;3;;// Predicate builders // ------------------------------------------------------------------------- public Predicate matches(Expression expression) {     return onNewPredicate(ExpressionToPredicateAdapter.toPredicate(expression)). }
false;public;1;6;;@Override public boolean matches(Exchange exchange) {     Expression left = expression.     Expression right = ref.get().     return PredicateBuilder.isEqualTo(left, right).matches(exchange). }
false;public;0;4;;@Override public String toString() {     return expression + " == " + ref.get(). }
false;public;1;8;;@Override public Object evaluate(Exchange exchange) {     if (answer.getExpressionValue() != null) {         return answer.getExpressionValue().evaluate(exchange, Object.class).     } else {         return answer.getExpressionType().evaluate(exchange).     } }
false;public;0;38;;public ExpressionClause<Predicate> matches() {     // chicken-and-egg situation as we need to return an ExpressionClause     // which needs a right-hand side that is being built via the fluent     // builder that is returned, and therefore we need to use a ref     // to the expression (right hand side) that will be used below     // in the onNewPredicate where the actual matching is executed     final AtomicReference<Expression> ref = new AtomicReference<>().     final ExpressionClause<Predicate> answer = new ExpressionClause<>(onNewPredicate(new Predicate() {          @Override         public boolean matches(Exchange exchange) {             Expression left = expression.             Expression right = ref.get().             return PredicateBuilder.isEqualTo(left, right).matches(exchange).         }          @Override         public String toString() {             return expression + " == " + ref.get().         }     })).     final Expression right = new ExpressionAdapter() {          @Override         public Object evaluate(Exchange exchange) {             if (answer.getExpressionValue() != null) {                 return answer.getExpressionValue().evaluate(exchange, Object.class).             } else {                 return answer.getExpressionType().evaluate(exchange).             }         }     }.     // okay now we can set the reference to the right-hand-side     ref.set(right).     return answer. }
false;public;1;4;;public Predicate isNotEqualTo(Object value) {     Expression right = asExpression(value).     return onNewPredicate(PredicateBuilder.isNotEqualTo(expression, right)). }
false;public;1;4;;public Predicate isEqualTo(Object value) {     Expression right = asExpression(value).     return onNewPredicate(PredicateBuilder.isEqualTo(expression, right)). }
false;public;1;4;;public Predicate isEqualToIgnoreCase(Object value) {     Expression right = asExpression(value).     return onNewPredicate(PredicateBuilder.isEqualToIgnoreCase(expression, right)). }
false;public;1;4;;public Predicate isLessThan(Object value) {     Expression right = asExpression(value).     return onNewPredicate(PredicateBuilder.isLessThan(expression, right)). }
false;public;1;4;;public Predicate isLessThanOrEqualTo(Object value) {     Expression right = asExpression(value).     return onNewPredicate(PredicateBuilder.isLessThanOrEqualTo(expression, right)). }
false;public;1;4;;public Predicate isGreaterThan(Object value) {     Expression right = asExpression(value).     return onNewPredicate(PredicateBuilder.isGreaterThan(expression, right)). }
false;public;1;4;;public Predicate isGreaterThanOrEqualTo(Object value) {     Expression right = asExpression(value).     return onNewPredicate(PredicateBuilder.isGreaterThanOrEqualTo(expression, right)). }
false;public;1;3;;public Predicate isInstanceOf(Class<?> type) {     return onNewPredicate(PredicateBuilder.isInstanceOf(expression, type)). }
false;public;0;3;;public Predicate isNull() {     return onNewPredicate(PredicateBuilder.isNull(expression)). }
false;public;0;3;;public Predicate isNotNull() {     return onNewPredicate(PredicateBuilder.isNotNull(expression)). }
false;public;1;3;;public Predicate not(Predicate predicate) {     return onNewPredicate(PredicateBuilder.not(predicate)). }
false;public;1;10;;public Predicate in(Object... values) {     List<Predicate> predicates = new ArrayList<>().     for (Object value : values) {         Expression right = asExpression(value).         right = ExpressionBuilder.convertToExpression(right, expression).         Predicate predicate = onNewPredicate(PredicateBuilder.isEqualTo(expression, right)).         predicates.add(predicate).     }     return in(predicates.toArray(new Predicate[predicates.size()])). }
false;public;1;3;;public Predicate in(Predicate... predicates) {     return onNewPredicate(PredicateBuilder.in(predicates)). }
false;public;1;4;;public Predicate startsWith(Object value) {     Expression right = asExpression(value).     return onNewPredicate(PredicateBuilder.startsWith(expression, right)). }
false;public;1;4;;public Predicate endsWith(Object value) {     Expression right = asExpression(value).     return onNewPredicate(PredicateBuilder.endsWith(expression, right)). }
true;public;1;4;/**  * Create a predicate that the left hand expression contains the value of  * the right hand expression  *  * @param value the element which is compared to be contained within this  *                expression  * @return a predicate which evaluates to true if the given value expression  *         is contained within this expression value  */ ;/**  * Create a predicate that the left hand expression contains the value of  * the right hand expression  *  * @param value the element which is compared to be contained within this  *                expression  * @return a predicate which evaluates to true if the given value expression  *         is contained within this expression value  */ public Predicate contains(Object value) {     Expression right = asExpression(value).     return onNewPredicate(PredicateBuilder.contains(expression, right)). }
true;public;1;3;/**  * Creates a predicate which is true if this expression matches the given  * regular expression  *  * @param regex the regular expression to match  * @return a predicate which evaluates to true if the expression matches the  *         regex  */ ;/**  * Creates a predicate which is true if this expression matches the given  * regular expression  *  * @param regex the regular expression to match  * @return a predicate which evaluates to true if the expression matches the  *         regex  */ public Predicate regex(String regex) {     return onNewPredicate(PredicateBuilder.regex(expression, regex)). }
false;public;0;3;;// Expression builders // ------------------------------------------------------------------------- public ValueBuilder tokenize() {     return tokenize("\n"). }
false;public;1;4;;public ValueBuilder tokenize(String token) {     Expression newExp = ExpressionBuilder.tokenizeExpression(expression, token).     return onNewValueBuilder(newExp). }
false;public;3;3;;public ValueBuilder tokenize(String token, int group, boolean skipFirst) {     return tokenize(token, "" + group, skipFirst). }
false;public;3;9;;public ValueBuilder tokenize(String token, String group, boolean skipFirst) {     Expression newExp = ExpressionBuilder.tokenizeExpression(expression, token).     if (group == null && skipFirst) {         // wrap in skip first (if group then it has its own skip first logic)         newExp = ExpressionBuilder.skipFirstExpression(newExp).     }     newExp = ExpressionBuilder.groupIteratorExpression(newExp, token, group, skipFirst).     return onNewValueBuilder(newExp). }
false;public;2;4;;public ValueBuilder tokenizeXML(String tagName, String inheritNamespaceTagName) {     Expression newExp = ExpressionBuilder.tokenizeXMLExpression(tagName, inheritNamespaceTagName).     return onNewValueBuilder(newExp). }
false;public;2;3;;public ValueBuilder xtokenize(String path, Namespaces namespaces) {     return xtokenize(path, 'i', namespaces). }
false;public;3;5;;public ValueBuilder xtokenize(String path, char mode, Namespaces namespaces) {     Expression newExp = ExpressionBuilder.tokenizeXMLAwareExpression(path, mode).     ((NamespaceAware) newExp).setNamespaces(namespaces.getNamespaces()).     return onNewValueBuilder(newExp). }
false;public;3;4;;public ValueBuilder tokenizePair(String startToken, String endToken, boolean includeTokens) {     Expression newExp = ExpressionBuilder.tokenizePairExpression(startToken, endToken, includeTokens).     return onNewValueBuilder(newExp). }
true;public;1;4;/**  * Tokenizes the string conversion of this expression using the given  * regular expression  */ ;/**  * Tokenizes the string conversion of this expression using the given  * regular expression  */ public ValueBuilder regexTokenize(String regex) {     Expression newExp = ExpressionBuilder.regexTokenizeExpression(expression, regex).     return onNewValueBuilder(newExp). }
true;public;2;4;/**  * Replaces all occurrences of the regular expression with the given  * replacement  */ ;/**  * Replaces all occurrences of the regular expression with the given  * replacement  */ public ValueBuilder regexReplaceAll(String regex, String replacement) {     Expression newExp = ExpressionBuilder.regexReplaceAll(expression, regex, replacement).     return onNewValueBuilder(newExp). }
true;public;2;4;/**  * Replaces all occurrences of the regular expression with the given  * replacement  */ ;/**  * Replaces all occurrences of the regular expression with the given  * replacement  */ public ValueBuilder regexReplaceAll(String regex, Expression replacement) {     Expression newExp = ExpressionBuilder.regexReplaceAll(expression, regex, replacement).     return onNewValueBuilder(newExp). }
true;public;1;4;/**  * Converts the current value to the given type using the registered type  * converters  *  * @param type the type to convert the value to  * @return the current builder  */ ;/**  * Converts the current value to the given type using the registered type  * converters  *  * @param type the type to convert the value to  * @return the current builder  */ public ValueBuilder convertTo(Class<?> type) {     Expression newExp = ExpressionBuilder.convertToExpression(expression, type).     return onNewValueBuilder(newExp). }
true;public;0;3;/**  * Converts the current value to a String using the registered type converters  *  * @return the current builder  */ ;/**  * Converts the current value to a String using the registered type converters  *  * @return the current builder  */ public ValueBuilder convertToString() {     return convertTo(String.class). }
true;public;1;4;/**  * Appends the string evaluation of this expression with the given value  *  * @param value the value or expression to append  * @return the current builder  */ ;/**  * Appends the string evaluation of this expression with the given value  *  * @param value the value or expression to append  * @return the current builder  */ public ValueBuilder append(Object value) {     Expression newExp = ExpressionBuilder.append(expression, asExpression(value)).     return onNewValueBuilder(newExp). }
true;public;1;4;/**  * Prepends the string evaluation of this expression with the given value  *  * @param value the value or expression to prepend  * @return the current builder  */ ;/**  * Prepends the string evaluation of this expression with the given value  *  * @param value the value or expression to prepend  * @return the current builder  */ public ValueBuilder prepend(Object value) {     Expression newExp = ExpressionBuilder.prepend(expression, asExpression(value)).     return onNewValueBuilder(newExp). }
true;public;1;4;/**  * Sorts the current value using the given comparator. The current value must be convertable  * to a {@link List} to allow sorting using the comparator.  *  * @param comparator  the comparator used by sorting  * @return the current builder  */ ;/**  * Sorts the current value using the given comparator. The current value must be convertable  * to a {@link List} to allow sorting using the comparator.  *  * @param comparator  the comparator used by sorting  * @return the current builder  */ public ValueBuilder sort(Comparator<?> comparator) {     Expression newExp = ExpressionBuilder.sortExpression(expression, comparator).     return onNewValueBuilder(newExp). }
true;public;1;4;/**  * Invokes the method with the given name (supports OGNL syntax).  *  * @param methodName  name of method to invoke.  * @return the current builder  */ ;/**  * Invokes the method with the given name (supports OGNL syntax).  *  * @param methodName  name of method to invoke.  * @return the current builder  */ public ValueBuilder method(String methodName) {     Expression newExp = ExpressionBuilder.ognlExpression(expression, methodName).     return onNewValueBuilder(newExp). }
true;public;0;4;/**  * Negates the built expression.  *  * @return the current builder  */ ;/**  * Negates the built expression.  *  * @return the current builder  */ public ValueBuilder not() {     not = true.     return this. }
true;protected;1;7;/**  * A strategy method to allow derived classes to deal with the newly created  * predicate in different ways  */ ;// Implementation methods // ------------------------------------------------------------------------- /**  * A strategy method to allow derived classes to deal with the newly created  * predicate in different ways  */ protected Predicate onNewPredicate(Predicate predicate) {     if (not) {         return PredicateBuilder.not(predicate).     } else {         return predicate.     } }
false;protected;1;7;;protected Expression asExpression(Object value) {     if (value instanceof Expression) {         return (Expression) value.     } else {         return ExpressionBuilder.constantExpression(value).     } }
false;protected;1;3;;protected ValueBuilder onNewValueBuilder(Expression exp) {     return new ValueBuilder(exp). }
