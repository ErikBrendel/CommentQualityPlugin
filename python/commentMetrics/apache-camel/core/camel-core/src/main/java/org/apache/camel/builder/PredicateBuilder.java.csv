commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Converts the given expression into an {@link Predicate}  */ ;/**  * Converts the given expression into an {@link Predicate}  */ public static Predicate toPredicate(final Expression expression) {     return ExpressionToPredicateAdapter.toPredicate(expression). }
false;public;1;3;;public boolean matches(Exchange exchange) {     return !predicate.matches(exchange). }
false;public;0;4;;@Override public String toString() {     return "not (" + predicate + ")". }
true;public,static;1;13;/**  * A helper method to return the logical not of the given predicate  */ ;/**  * A helper method to return the logical not of the given predicate  */ public static Predicate not(final Predicate predicate) {     notNull(predicate, "predicate").     return new Predicate() {          public boolean matches(Exchange exchange) {             return !predicate.matches(exchange).         }          @Override         public String toString() {             return "not (" + predicate + ")".         }     }. }
false;public;1;3;;public boolean matches(Exchange exchange) {     return left.matches(exchange) && right.matches(exchange). }
false;public;0;4;;@Override public String toString() {     return "(" + left + ") and (" + right + ")". }
true;public,static;2;14;/**  * A helper method to combine multiple predicates by a logical AND  */ ;/**  * A helper method to combine multiple predicates by a logical AND  */ public static Predicate and(final Predicate left, final Predicate right) {     notNull(left, "left").     notNull(right, "right").     return new Predicate() {          public boolean matches(Exchange exchange) {             return left.matches(exchange) && right.matches(exchange).         }          @Override         public String toString() {             return "(" + left + ") and (" + right + ")".         }     }. }
false;public;1;3;;public boolean matches(Exchange exchange) {     return left.matches(exchange) || right.matches(exchange). }
false;public;0;4;;@Override public String toString() {     return "(" + left + ") or (" + right + ")". }
true;public,static;2;14;/**  * A helper method to combine two predicates by a logical OR.  * If you want to combine multiple predicates see {@link #in(Predicate...)}  */ ;/**  * A helper method to combine two predicates by a logical OR.  * If you want to combine multiple predicates see {@link #in(Predicate...)}  */ public static Predicate or(final Predicate left, final Predicate right) {     notNull(left, "left").     notNull(right, "right").     return new Predicate() {          public boolean matches(Exchange exchange) {             return left.matches(exchange) || right.matches(exchange).         }          @Override         public String toString() {             return "(" + left + ") or (" + right + ")".         }     }. }
true;public,static;1;11;/**  * Concat the given predicates into a single predicate, which matches  * if at least one predicates matches.  *  * @param predicates predicates  * @return a single predicate containing all the predicates  */ ;/**  * Concat the given predicates into a single predicate, which matches  * if at least one predicates matches.  *  * @param predicates predicates  * @return a single predicate containing all the predicates  */ public static Predicate or(List<Predicate> predicates) {     Predicate answer = null.     for (Predicate predicate : predicates) {         if (answer == null) {             answer = predicate.         } else {             answer = or(answer, predicate).         }     }     return answer. }
true;public,static;1;3;/**  * Concat the given predicates into a single predicate, which matches  * if at least one predicates matches.  *  * @param predicates predicates  * @return a single predicate containing all the predicates  */ ;/**  * Concat the given predicates into a single predicate, which matches  * if at least one predicates matches.  *  * @param predicates predicates  * @return a single predicate containing all the predicates  */ public static Predicate or(Predicate... predicates) {     return or(Arrays.asList(predicates)). }
false;public;1;8;;public boolean matches(Exchange exchange) {     for (Predicate in : predicates) {         if (in.matches(exchange)) {             return true.         }     }     return false. }
false;public;0;4;;@Override public String toString() {     return "in (" + Arrays.asList(predicates) + ")". }
true;public,static;1;19;/**  * A helper method to return true if any of the predicates matches.  */ ;/**  * A helper method to return true if any of the predicates matches.  */ public static Predicate in(final Predicate... predicates) {     notNull(predicates, "predicates").     return new Predicate() {          public boolean matches(Exchange exchange) {             for (Predicate in : predicates) {                 if (in.matches(exchange)) {                     return true.                 }             }             return false.         }          @Override         public String toString() {             return "in (" + Arrays.asList(predicates) + ")".         }     }. }
true;public,static;1;3;/**  * A helper method to return true if any of the predicates matches.  */ ;/**  * A helper method to return true if any of the predicates matches.  */ public static Predicate in(List<Predicate> predicates) {     return in(predicates.toArray(new Predicate[0])). }
false;protected;3;11;;protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {     if (leftValue == null && rightValue == null) {         // they are equal         return true.     } else if (leftValue == null || rightValue == null) {         // only one of them is null so they are not equal         return false.     }     return ObjectHelper.typeCoerceEquals(exchange.getContext().getTypeConverter(), leftValue, rightValue). }
false;protected;0;3;;protected String getOperationText() {     return "==". }
false;public,static;2;20;;public static Predicate isEqualTo(final Expression left, final Expression right) {     return new BinaryPredicateSupport(left, right) {          protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {             if (leftValue == null && rightValue == null) {                 // they are equal                 return true.             } else if (leftValue == null || rightValue == null) {                 // only one of them is null so they are not equal                 return false.             }             return ObjectHelper.typeCoerceEquals(exchange.getContext().getTypeConverter(), leftValue, rightValue).         }          protected String getOperationText() {             return "==".         }     }. }
false;protected;3;11;;protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {     if (leftValue == null && rightValue == null) {         // they are equal         return true.     } else if (leftValue == null || rightValue == null) {         // only one of them is null so they are not equal         return false.     }     return ObjectHelper.typeCoerceEquals(exchange.getContext().getTypeConverter(), leftValue, rightValue, true). }
false;protected;0;3;;protected String getOperationText() {     return "=~". }
false;public,static;2;20;;public static Predicate isEqualToIgnoreCase(final Expression left, final Expression right) {     return new BinaryPredicateSupport(left, right) {          protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {             if (leftValue == null && rightValue == null) {                 // they are equal                 return true.             } else if (leftValue == null || rightValue == null) {                 // only one of them is null so they are not equal                 return false.             }             return ObjectHelper.typeCoerceEquals(exchange.getContext().getTypeConverter(), leftValue, rightValue, true).         }          protected String getOperationText() {             return "=~".         }     }. }
false;protected;3;11;;protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {     if (leftValue == null && rightValue == null) {         // they are equal         return false.     } else if (leftValue == null || rightValue == null) {         // only one of them is null so they are not equal         return true.     }     return ObjectHelper.typeCoerceNotEquals(exchange.getContext().getTypeConverter(), leftValue, rightValue). }
false;protected;0;3;;protected String getOperationText() {     return "!=". }
false;public,static;2;20;;public static Predicate isNotEqualTo(final Expression left, final Expression right) {     return new BinaryPredicateSupport(left, right) {          protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {             if (leftValue == null && rightValue == null) {                 // they are equal                 return false.             } else if (leftValue == null || rightValue == null) {                 // only one of them is null so they are not equal                 return true.             }             return ObjectHelper.typeCoerceNotEquals(exchange.getContext().getTypeConverter(), leftValue, rightValue).         }          protected String getOperationText() {             return "!=".         }     }. }
false;protected;3;11;;protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {     if (leftValue == null && rightValue == null) {         // they are equal         return true.     } else if (leftValue == null || rightValue == null) {         // only one of them is null so they are not equal         return false.     }     return ObjectHelper.typeCoerceCompare(exchange.getContext().getTypeConverter(), leftValue, rightValue) < 0. }
false;protected;0;3;;protected String getOperationText() {     return "<". }
false;public,static;2;20;;public static Predicate isLessThan(final Expression left, final Expression right) {     return new BinaryPredicateSupport(left, right) {          protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {             if (leftValue == null && rightValue == null) {                 // they are equal                 return true.             } else if (leftValue == null || rightValue == null) {                 // only one of them is null so they are not equal                 return false.             }             return ObjectHelper.typeCoerceCompare(exchange.getContext().getTypeConverter(), leftValue, rightValue) < 0.         }          protected String getOperationText() {             return "<".         }     }. }
false;protected;3;11;;protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {     if (leftValue == null && rightValue == null) {         // they are equal         return true.     } else if (leftValue == null || rightValue == null) {         // only one of them is null so they are not equal         return false.     }     return ObjectHelper.typeCoerceCompare(exchange.getContext().getTypeConverter(), leftValue, rightValue) <= 0. }
false;protected;0;3;;protected String getOperationText() {     return "<=". }
false;public,static;2;20;;public static Predicate isLessThanOrEqualTo(final Expression left, final Expression right) {     return new BinaryPredicateSupport(left, right) {          protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {             if (leftValue == null && rightValue == null) {                 // they are equal                 return true.             } else if (leftValue == null || rightValue == null) {                 // only one of them is null so they are not equal                 return false.             }             return ObjectHelper.typeCoerceCompare(exchange.getContext().getTypeConverter(), leftValue, rightValue) <= 0.         }          protected String getOperationText() {             return "<=".         }     }. }
false;protected;3;11;;protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {     if (leftValue == null && rightValue == null) {         // they are equal         return false.     } else if (leftValue == null || rightValue == null) {         // only one of them is null so they are not equal         return false.     }     return ObjectHelper.typeCoerceCompare(exchange.getContext().getTypeConverter(), leftValue, rightValue) > 0. }
false;protected;0;3;;protected String getOperationText() {     return ">". }
false;public,static;2;20;;public static Predicate isGreaterThan(final Expression left, final Expression right) {     return new BinaryPredicateSupport(left, right) {          protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {             if (leftValue == null && rightValue == null) {                 // they are equal                 return false.             } else if (leftValue == null || rightValue == null) {                 // only one of them is null so they are not equal                 return false.             }             return ObjectHelper.typeCoerceCompare(exchange.getContext().getTypeConverter(), leftValue, rightValue) > 0.         }          protected String getOperationText() {             return ">".         }     }. }
false;protected;3;11;;protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {     if (leftValue == null && rightValue == null) {         // they are equal         return true.     } else if (leftValue == null || rightValue == null) {         // only one of them is null so they are not equal         return false.     }     return ObjectHelper.typeCoerceCompare(exchange.getContext().getTypeConverter(), leftValue, rightValue) >= 0. }
false;protected;0;3;;protected String getOperationText() {     return ">=". }
false;public,static;2;20;;public static Predicate isGreaterThanOrEqualTo(final Expression left, final Expression right) {     return new BinaryPredicateSupport(left, right) {          protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {             if (leftValue == null && rightValue == null) {                 // they are equal                 return true.             } else if (leftValue == null || rightValue == null) {                 // only one of them is null so they are not equal                 return false.             }             return ObjectHelper.typeCoerceCompare(exchange.getContext().getTypeConverter(), leftValue, rightValue) >= 0.         }          protected String getOperationText() {             return ">=".         }     }. }
false;protected;3;11;;protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {     if (leftValue == null && rightValue == null) {         // they are equal         return true.     } else if (leftValue == null || rightValue == null) {         // only one of them is null so they are not equal         return false.     }     return ObjectHelper.contains(leftValue, rightValue). }
false;protected;0;3;;protected String getOperationText() {     return "contains". }
false;public,static;2;20;;public static Predicate contains(final Expression left, final Expression right) {     return new BinaryPredicateSupport(left, right) {          protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {             if (leftValue == null && rightValue == null) {                 // they are equal                 return true.             } else if (leftValue == null || rightValue == null) {                 // only one of them is null so they are not equal                 return false.             }             return ObjectHelper.contains(leftValue, rightValue).         }          protected String getOperationText() {             return "contains".         }     }. }
false;protected;3;11;;protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {     if (leftValue == null && rightValue == null) {         // they are equal         return true.     } else if (leftValue == null || rightValue == null) {         // only one of them is null so they are not equal         return false.     }     return ObjectHelper.containsIgnoreCase(leftValue, rightValue). }
false;protected;0;3;;protected String getOperationText() {     return "~~". }
false;public,static;2;20;;public static Predicate containsIgnoreCase(final Expression left, final Expression right) {     return new BinaryPredicateSupport(left, right) {          protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {             if (leftValue == null && rightValue == null) {                 // they are equal                 return true.             } else if (leftValue == null || rightValue == null) {                 // only one of them is null so they are not equal                 return false.             }             return ObjectHelper.containsIgnoreCase(leftValue, rightValue).         }          protected String getOperationText() {             return "~~".         }     }. }
false;protected;3;8;;protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {     if (leftValue == null) {         // the left operator is null so its true         return true.     }     return ObjectHelper.typeCoerceEquals(exchange.getContext().getTypeConverter(), leftValue, rightValue). }
false;protected;0;5;;protected String getOperationText() {     // so it will be displayed as: XXX is null     return "is". }
false;public,static;1;19;;public static Predicate isNull(final Expression expression) {     return new BinaryPredicateSupport(expression, ExpressionBuilder.constantExpression(null)) {          protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {             if (leftValue == null) {                 // the left operator is null so its true                 return true.             }             return ObjectHelper.typeCoerceEquals(exchange.getContext().getTypeConverter(), leftValue, rightValue).         }          protected String getOperationText() {             // so it will be displayed as: XXX is null             return "is".         }     }. }
false;protected;3;8;;protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {     if (leftValue != null) {         // the left operator is not null so its true         return true.     }     return ObjectHelper.typeCoerceNotEquals(exchange.getContext().getTypeConverter(), leftValue, rightValue). }
false;protected;0;5;;protected String getOperationText() {     // so it will be displayed as: XXX is not null     return "is not". }
false;public,static;1;19;;public static Predicate isNotNull(final Expression expression) {     return new BinaryPredicateSupport(expression, ExpressionBuilder.constantExpression(null)) {          protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {             if (leftValue != null) {                 // the left operator is not null so its true                 return true.             }             return ObjectHelper.typeCoerceNotEquals(exchange.getContext().getTypeConverter(), leftValue, rightValue).         }          protected String getOperationText() {             // so it will be displayed as: XXX is not null             return "is not".         }     }. }
false;public;1;4;;public boolean matches(Exchange exchange) {     Object value = expression.evaluate(exchange, Object.class).     return type.isInstance(value). }
false;public;0;4;;@Override public String toString() {     return expression + " instanceof " + type.getCanonicalName(). }
false;public,static;2;16;;public static Predicate isInstanceOf(final Expression expression, final Class<?> type) {     notNull(expression, "expression").     notNull(type, "type").     return new Predicate() {          public boolean matches(Exchange exchange) {             Object value = expression.evaluate(exchange, Object.class).             return type.isInstance(value).         }          @Override         public String toString() {             return expression + " instanceof " + type.getCanonicalName().         }     }. }
false;protected;3;16;;protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {     if (leftValue == null && rightValue == null) {         // they are equal         return true.     } else if (leftValue == null || rightValue == null) {         // only one of them is null so they are not equal         return false.     }     String leftStr = exchange.getContext().getTypeConverter().convertTo(String.class, leftValue).     String rightStr = exchange.getContext().getTypeConverter().convertTo(String.class, rightValue).     if (leftStr != null && rightStr != null) {         return leftStr.startsWith(rightStr).     } else {         return false.     } }
false;protected;0;3;;protected String getOperationText() {     return "startsWith". }
false;public,static;2;25;;public static Predicate startsWith(final Expression left, final Expression right) {     return new BinaryPredicateSupport(left, right) {          protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {             if (leftValue == null && rightValue == null) {                 // they are equal                 return true.             } else if (leftValue == null || rightValue == null) {                 // only one of them is null so they are not equal                 return false.             }             String leftStr = exchange.getContext().getTypeConverter().convertTo(String.class, leftValue).             String rightStr = exchange.getContext().getTypeConverter().convertTo(String.class, rightValue).             if (leftStr != null && rightStr != null) {                 return leftStr.startsWith(rightStr).             } else {                 return false.             }         }          protected String getOperationText() {             return "startsWith".         }     }. }
false;protected;3;16;;protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {     if (leftValue == null && rightValue == null) {         // they are equal         return true.     } else if (leftValue == null || rightValue == null) {         // only one of them is null so they are not equal         return false.     }     String leftStr = exchange.getContext().getTypeConverter().convertTo(String.class, leftValue).     String rightStr = exchange.getContext().getTypeConverter().convertTo(String.class, rightValue).     if (leftStr != null && rightStr != null) {         return leftStr.endsWith(rightStr).     } else {         return false.     } }
false;protected;0;3;;protected String getOperationText() {     return "endsWith". }
false;public,static;2;25;;public static Predicate endsWith(final Expression left, final Expression right) {     return new BinaryPredicateSupport(left, right) {          protected boolean matches(Exchange exchange, Object leftValue, Object rightValue) {             if (leftValue == null && rightValue == null) {                 // they are equal                 return true.             } else if (leftValue == null || rightValue == null) {                 // only one of them is null so they are not equal                 return false.             }             String leftStr = exchange.getContext().getTypeConverter().convertTo(String.class, leftValue).             String rightStr = exchange.getContext().getTypeConverter().convertTo(String.class, rightValue).             if (leftStr != null && rightStr != null) {                 return leftStr.endsWith(rightStr).             } else {                 return false.             }         }          protected String getOperationText() {             return "endsWith".         }     }. }
true;public,static;2;3;/**  * Returns a predicate which is true if the expression matches the given  * regular expression  *  * @param expression the expression to evaluate  * @param regex the regular expression to match against  * @return a new predicate  */ ;/**  * Returns a predicate which is true if the expression matches the given  * regular expression  *  * @param expression the expression to evaluate  * @param regex the regular expression to match against  * @return a new predicate  */ public static Predicate regex(final Expression expression, final String regex) {     return regex(expression, Pattern.compile(regex)). }
false;public;1;8;;public boolean matches(Exchange exchange) {     String value = expression.evaluate(exchange, String.class).     if (value != null) {         Matcher matcher = pattern.matcher(value).         return matcher.matches().     }     return false. }
false;public;0;4;;@Override public String toString() {     return expression + ".matches('" + pattern + "')". }
true;public,static;2;20;/**  * Returns a predicate which is true if the expression matches the given  * regular expression  *  * @param expression the expression to evaluate  * @param pattern the regular expression to match against  * @return a new predicate  */ ;/**  * Returns a predicate which is true if the expression matches the given  * regular expression  *  * @param expression the expression to evaluate  * @param pattern the regular expression to match against  * @return a new predicate  */ public static Predicate regex(final Expression expression, final Pattern pattern) {     notNull(expression, "expression").     notNull(pattern, "pattern").     return new Predicate() {          public boolean matches(Exchange exchange) {             String value = expression.evaluate(exchange, String.class).             if (value != null) {                 Matcher matcher = pattern.matcher(value).                 return matcher.matches().             }             return false.         }          @Override         public String toString() {             return expression + ".matches('" + pattern + "')".         }     }. }
true;public,static;1;11;/**  * Concat the given predicates into a single predicate, which  * only matches if all the predicates matches.  *  * @param predicates predicates  * @return a single predicate containing all the predicates  */ ;/**  * Concat the given predicates into a single predicate, which  * only matches if all the predicates matches.  *  * @param predicates predicates  * @return a single predicate containing all the predicates  */ public static Predicate and(List<Predicate> predicates) {     Predicate answer = null.     for (Predicate predicate : predicates) {         if (answer == null) {             answer = predicate.         } else {             answer = and(answer, predicate).         }     }     return answer. }
true;public,static;1;3;/**  * Concat the given predicates into a single predicate, which only matches  * if all the predicates matches.  *  * @param predicates predicates  * @return a single predicate containing all the predicates  */ ;/**  * Concat the given predicates into a single predicate, which only matches  * if all the predicates matches.  *  * @param predicates predicates  * @return a single predicate containing all the predicates  */ public static Predicate and(Predicate... predicates) {     return and(Arrays.asList(predicates)). }
false;public;1;4;;@Override public boolean matches(Exchange exchange) {     return answer. }
false;public;0;4;;@Override public String toString() {     return "" + answer. }
true;public,static;1;13;/**  * A constant predicate.  *  * @param answer the constant matches  * @return a predicate that always returns the given answer.  */ ;/**  * A constant predicate.  *  * @param answer the constant matches  * @return a predicate that always returns the given answer.  */ public static Predicate constant(final boolean answer) {     return new Predicate() {          @Override         public boolean matches(Exchange exchange) {             return answer.         }          @Override         public String toString() {             return "" + answer.         }     }. }
