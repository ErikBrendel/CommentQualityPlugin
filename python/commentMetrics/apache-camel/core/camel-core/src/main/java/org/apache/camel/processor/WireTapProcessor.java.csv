commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "WireTap[" + uri + "]". }
false;public;0;4;;@Override public String getTraceLabel() {     return "wireTap(" + uri + ")". }
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setId(String id) {     this.id = id. }
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;1;3;;public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;1;5;;@Override public boolean deferShutdown(ShutdownRunningTask shutdownRunningTask) {     // not in use     return true. }
false;public;0;4;;@Override public int getPendingExchangesSize() {     return taskCount.intValue(). }
false;public;2;4;;@Override public void prepareShutdown(boolean suspendOnly, boolean forced) { // noop }
false;public;0;3;;public EndpointUtilizationStatistics getEndpointUtilizationStatistics() {     return dynamicProcessor.getEndpointUtilizationStatistics(). }
false;public;2;33;;public boolean process(final Exchange exchange, final AsyncCallback callback) {     if (!isStarted()) {         throw new IllegalStateException("WireTapProcessor has not been started: " + this).     }     // must configure the wire tap beforehand     Exchange target.     try {         target = configureExchange(exchange, exchangePattern).     } catch (Exception e) {         exchange.setException(e).         callback.done(true).         return true.     }     final Exchange wireTapExchange = target.     // send the exchange to the destination using an executor service     executorService.submit(() -> {         taskCount.increment().         log.debug(">>>> (wiretap) {} {}", uri, wireTapExchange).         AsyncProcessorConverterHelper.convert(processor).process(wireTapExchange, doneSync -> {             if (wireTapExchange.getException() != null) {                 log.warn("Error occurred during processing " + wireTapExchange + " wiretap to " + uri + ". This exception will be ignored.", wireTapExchange.getException()).             }             taskCount.decrement().         }).     }).     // continue routing this synchronously     callback.done(true).     return true. }
false;protected;2;50;;protected Exchange configureExchange(Exchange exchange, ExchangePattern pattern) throws IOException {     Exchange answer.     if (copy) {         // use a copy of the original exchange         answer = configureCopyExchange(exchange).     } else {         // use a new exchange         answer = configureNewExchange(exchange).     }     // prepare the exchange     if (newExchangeExpression != null) {         Object body = newExchangeExpression.evaluate(answer, Object.class).         if (body != null) {             answer.getIn().setBody(body).         }     }     if (newExchangeProcessors != null) {         for (Processor processor : newExchangeProcessors) {             try {                 processor.process(answer).             } catch (Exception e) {                 throw RuntimeCamelException.wrapRuntimeCamelException(e).             }         }     }     // if the body is a stream cache we must use a copy of the stream in the wire tapped exchange     Message msg = answer.hasOut() ? answer.getOut() : answer.getIn().     if (msg.getBody() instanceof StreamCache) {         // in parallel processing case, the stream must be copied, therefore get the stream         StreamCache cache = (StreamCache) msg.getBody().         StreamCache copied = cache.copy(answer).         if (copied != null) {             msg.setBody(copied).         }     }     // invoke on prepare on the exchange if specified     if (onPrepare != null) {         try {             onPrepare.process(answer).         } catch (Exception e) {             throw RuntimeCamelException.wrapRuntimeCamelException(e).         }     }     return answer. }
false;private;1;10;;private Exchange configureCopyExchange(Exchange exchange) {     // must use a copy as we dont want it to cause side effects of the original exchange     Exchange copy = ExchangeHelper.createCorrelatedCopy(exchange, false).     // set MEP to InOnly as this wire tap is a fire and forget     copy.setPattern(ExchangePattern.InOnly).     // remove STREAM_CACHE_UNIT_OF_WORK property because this wire tap will     // close its own created stream cache(s)     copy.removeProperty(Exchange.STREAM_CACHE_UNIT_OF_WORK).     return copy. }
false;private;1;3;;private Exchange configureNewExchange(Exchange exchange) {     return new DefaultExchange(exchange.getFromEndpoint(), ExchangePattern.InOnly). }
false;public;0;3;;public List<Processor> getNewExchangeProcessors() {     return newExchangeProcessors. }
false;public;1;3;;public void setNewExchangeProcessors(List<Processor> newExchangeProcessors) {     this.newExchangeProcessors = newExchangeProcessors. }
false;public;0;3;;public Expression getNewExchangeExpression() {     return newExchangeExpression. }
false;public;1;3;;public void setNewExchangeExpression(Expression newExchangeExpression) {     this.newExchangeExpression = newExchangeExpression. }
false;public;1;6;;public void addNewExchangeProcessor(Processor processor) {     if (newExchangeProcessors == null) {         newExchangeProcessors = new ArrayList<>().     }     newExchangeProcessors.add(processor). }
false;public;0;3;;public boolean isCopy() {     return copy. }
false;public;1;3;;public void setCopy(boolean copy) {     this.copy = copy. }
false;public;0;3;;public Processor getOnPrepare() {     return onPrepare. }
false;public;1;3;;public void setOnPrepare(Processor onPrepare) {     this.onPrepare = onPrepare. }
false;public;0;3;;public String getUri() {     return uri. }
false;public;0;3;;public int getCacheSize() {     return dynamicProcessor.getCacheSize(). }
false;public;0;3;;public boolean isIgnoreInvalidEndpoint() {     return dynamicProcessor.isIgnoreInvalidEndpoint(). }
false;public;0;3;;public boolean isDynamicUri() {     return dynamicUri. }
false;protected;0;4;;@Override protected void doStart() throws Exception {     ServiceHelper.startService(processor). }
false;protected;0;4;;@Override protected void doStop() throws Exception {     ServiceHelper.stopService(processor). }
false;protected;0;7;;@Override protected void doShutdown() throws Exception {     ServiceHelper.stopAndShutdownService(processor).     if (shutdownExecutorService) {         getCamelContext().getExecutorServiceManager().shutdownNow(executorService).     } }
