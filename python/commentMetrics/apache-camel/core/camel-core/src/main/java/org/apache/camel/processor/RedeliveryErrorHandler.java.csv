commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;public void process(Exchange exchange) {     if (output == null) {         // no output then just return         return.     }     awaitManager.process(this, exchange). }
true;public;2;11;/**  * Process the exchange using redelivery error handling.  */ ;/**  * Process the exchange using redelivery error handling.  */ public boolean process(final Exchange exchange, final AsyncCallback callback) {     // Create the redelivery state object for this exchange     RedeliveryState state = new RedeliveryState(exchange, callback).     // Run it     if (exchange.isTransacted()) {         ReactiveHelper.scheduleSync(state).     } else {         ReactiveHelper.scheduleMain(state).     }     return false. }
false;public;1;5;;public CompletableFuture<Exchange> processAsync(Exchange exchange) {     AsyncCallbackToCompletableFutureAdapter<Exchange> callback = new AsyncCallbackToCompletableFutureAdapter<>(exchange).     process(exchange, callback).     return callback.getFuture(). }
true;public;1;4;/**  * Allows to change the output of the error handler which are used when optimising the  * JMX instrumentation to use either an advice or wrapped processor when calling a processor.  * The former is faster and therefore preferred, however if the error handler supports  * redelivery we need fine grained instrumentation which then must be wrapped and therefore  * need to change the output on the error handler.  */ ;/**  * Allows to change the output of the error handler which are used when optimising the  * JMX instrumentation to use either an advice or wrapped processor when calling a processor.  * The former is faster and therefore preferred, however if the error handler supports  * redelivery we need fine grained instrumentation which then must be wrapped and therefore  * need to change the output on the error handler.  */ public void changeOutput(Processor output) {     this.output = output.     this.outputAsync = AsyncProcessorConverterHelper.convert(output). }
false;public;0;3;;public boolean supportTransacted() {     return false. }
false;public;0;4;;@Override public boolean hasNext() {     return output != null. }
false;public;0;9;;@Override public List<Processor> next() {     if (!hasNext()) {         return null.     }     List<Processor> answer = new ArrayList<>(1).     answer.add(output).     return answer. }
false;protected;0;3;;protected boolean isRunAllowedOnPreparingShutdown() {     return false. }
false;public;2;6;;@Override public void prepareShutdown(boolean suspendOnly, boolean forced) {     // prepare for shutdown, eg do not allow redelivery if configured     log.trace("Prepare shutdown on error handler {}", this).     preparingShutdown = true. }
true;protected;4;11;/**  * <p>Determines the redelivery delay time by first inspecting the Message header {@link Exchange#REDELIVERY_DELAY}  * and if not present, defaulting to {@link RedeliveryPolicy#calculateRedeliveryDelay(long, int)}</p>  *  * <p>In order to prevent manipulation of the RedeliveryData state, the values of {@link RedeliveryState#redeliveryDelay}  * and {@link RedeliveryState#redeliveryCounter} are copied in.</p>  *  * @param exchange The current exchange in question.  * @param redeliveryPolicy The RedeliveryPolicy to use in the calculation.  * @param redeliveryDelay The default redelivery delay from RedeliveryData  * @param redeliveryCounter The redeliveryCounter  * @return The time to wait before the next redelivery.  */ ;/**  * <p>Determines the redelivery delay time by first inspecting the Message header {@link Exchange#REDELIVERY_DELAY}  * and if not present, defaulting to {@link RedeliveryPolicy#calculateRedeliveryDelay(long, int)}</p>  *  * <p>In order to prevent manipulation of the RedeliveryData state, the values of {@link RedeliveryState#redeliveryDelay}  * and {@link RedeliveryState#redeliveryCounter} are copied in.</p>  *  * @param exchange The current exchange in question.  * @param redeliveryPolicy The RedeliveryPolicy to use in the calculation.  * @param redeliveryDelay The default redelivery delay from RedeliveryData  * @param redeliveryCounter The redeliveryCounter  * @return The time to wait before the next redelivery.  */ protected long determineRedeliveryDelay(Exchange exchange, RedeliveryPolicy redeliveryPolicy, long redeliveryDelay, int redeliveryCounter) {     Message message = exchange.getIn().     Long delay = message.getHeader(Exchange.REDELIVERY_DELAY, Long.class).     if (delay == null) {         delay = redeliveryPolicy.calculateRedeliveryDelay(redeliveryDelay, redeliveryCounter).         log.debug("Redelivery delay calculated as {}", delay).     } else {         log.debug("Redelivery delay is {} from Message Header [{}]", delay, Exchange.REDELIVERY_DELAY).     }     return delay. }
true;protected;1;8;/**  * Performs a defensive copy of the exchange if needed  *  * @param exchange the exchange  * @return the defensive copy, or <tt>null</tt> if not needed (redelivery is not enabled).  */ ;/**  * Performs a defensive copy of the exchange if needed  *  * @param exchange the exchange  * @return the defensive copy, or <tt>null</tt> if not needed (redelivery is not enabled).  */ protected Exchange defensiveCopyExchangeIfNeeded(Exchange exchange) {     // only do a defensive copy if redelivery is enabled     if (redeliveryEnabled) {         return ExchangeHelper.createCopy(exchange, true).     } else {         return null.     } }
true;protected;1;3;/**  * Strategy whether the exchange has an exception that we should try to handle.  * <p/>  * Standard implementations should just look for an exception.  */ ;/**  * Strategy whether the exchange has an exception that we should try to handle.  * <p/>  * Standard implementations should just look for an exception.  */ protected boolean shouldHandleException(Exchange exchange) {     return exchange.getException() != null. }
true;protected;1;15;/**  * Strategy to determine if the exchange is done so we can continue  */ ;/**  * Strategy to determine if the exchange is done so we can continue  */ protected boolean isDone(Exchange exchange) {     boolean answer = isCancelledOrInterrupted(exchange).     // or we are exhausted     if (!answer) {         answer = exchange.getException() == null || ExchangeHelper.isFailureHandled(exchange) || ExchangeHelper.isRedeliveryExhausted(exchange).     }     log.trace("Is exchangeId: {} done? {}", exchange.getExchangeId(), answer).     return answer. }
true;protected;1;13;/**  * Strategy to determine if the exchange was cancelled or interrupted  */ ;/**  * Strategy to determine if the exchange was cancelled or interrupted  */ protected boolean isCancelledOrInterrupted(Exchange exchange) {     boolean answer = false.     if (ExchangeHelper.isInterrupted(exchange)) {         // mark the exchange to stop continue routing when interrupted         // as we do not want to continue routing (for example a task has been cancelled)         exchange.setProperty(Exchange.ROUTE_STOP, Boolean.TRUE).         answer = true.     }     log.trace("Is exchangeId: {} interrupted? {}", exchange.getExchangeId(), answer).     return answer. }
true;public;0;3;/**  * Returns the output processor  */ ;/**  * Returns the output processor  */ public Processor getOutput() {     return output. }
true;public;0;3;/**  * Returns the dead letter that message exchanges will be sent to if the  * redelivery attempts fail  */ ;/**  * Returns the dead letter that message exchanges will be sent to if the  * redelivery attempts fail  */ public Processor getDeadLetter() {     return deadLetter. }
false;public;0;3;;public String getDeadLetterUri() {     return deadLetterUri. }
false;public;0;3;;public boolean isUseOriginalMessagePolicy() {     return useOriginalMessagePolicy. }
false;public;0;3;;public boolean isDeadLetterHandleNewException() {     return deadLetterHandleNewException. }
false;public;0;3;;public RedeliveryPolicy getRedeliveryPolicy() {     return redeliveryPolicy. }
false;public;0;3;;public CamelLogger getLogger() {     return logger. }
false;protected;0;4;;protected Predicate getDefaultHandledPredicate() {     // Default is not not handle errors     return null. }
false;public;0;3;;public String toString() {     return "Step[" + exchange.getExchangeId() + "," + RedeliveryErrorHandler.this + "]". }
true;public;0;112;/**  * Redelivery logic.  */ ;/**  * Redelivery logic.  */ public void run() {     // can we still run     if (!isRunAllowed()) {         log.trace("Run not allowed, will reject executing exchange: {}", exchange).         if (exchange.getException() == null) {             exchange.setException(new RejectedExecutionException()).         }         callback.done(false).         return.     }     // did previous processing cause an exception?     boolean handle = shouldHandleException(exchange).     if (handle) {         handleException().         onExceptionOccurred().     }     // compute if we are exhausted or not     boolean exhausted = isExhausted(exchange).     boolean redeliverAllowed = isRedeliveryAllowed().     // if we are exhausted or redelivery is not allowed, then deliver to failure processor (eg such as DLC)     if (!redeliverAllowed || exhausted) {         Processor target = null.         boolean deliver = true.         // the unit of work may have an optional callback associated we need to leverage         UnitOfWork uow = exchange.getUnitOfWork().         if (uow != null) {             SubUnitOfWorkCallback uowCallback = uow.getSubUnitOfWorkCallback().             if (uowCallback != null) {                 // signal to the callback we are exhausted                 uowCallback.onExhausted(exchange).                 // do not deliver to the failure processor as its been handled by the callback instead                 deliver = false.             }         }         if (deliver) {             // should deliver to failure processor (either from onException or the dead letter channel)             target = failureProcessor != null ? failureProcessor : deadLetter.         }         // we should always invoke the deliverToFailureProcessor as it prepares, logs and does a fair         // bit of work for exhausted exchanges (its only the target processor which may be null if handled by a savepoint)         boolean isDeadLetterChannel = isDeadLetterChannel() && target == deadLetter.         deliverToFailureProcessor(target, isDeadLetterChannel, exchange).     // we are breaking out     } else if (redeliveryCounter > 0) {         // calculate the redelivery delay         redeliveryDelay = determineRedeliveryDelay(exchange, currentRedeliveryPolicy, redeliveryDelay, redeliveryCounter).         if (redeliveryDelay > 0) {             if (currentRedeliveryPolicy.isAsyncDelayedRedelivery() && !exchange.isTransacted()) {                 // we are doing a redelivery then a thread pool must be configured (see the doStart method)                 ObjectHelper.notNull(executorService, "Redelivery is enabled but ExecutorService has not been configured.", this).                 // schedule the redelivery task                 if (log.isTraceEnabled()) {                     log.trace("Scheduling redelivery task to run in {} millis for exchangeId: {}", redeliveryDelay, exchange.getExchangeId()).                 }                 executorService.schedule(() -> ReactiveHelper.schedule(this::redeliver), redeliveryDelay, TimeUnit.MILLISECONDS).             } else {                 // as the transaction manager requires to execute in the same thread context                 try {                     // we are doing synchronous redelivery and use thread sleep, so we keep track using a counter how many are sleeping                     redeliverySleepCounter.incrementAndGet().                     boolean complete = sleep().                     redeliverySleepCounter.decrementAndGet().                     if (!complete) {                         // the task was rejected                         exchange.setException(new RejectedExecutionException("Redelivery not allowed while stopping")).                         // mark the exchange as redelivery exhausted so the failure processor / dead letter channel can process the exchange                         exchange.setProperty(Exchange.REDELIVERY_EXHAUSTED, Boolean.TRUE).                         // jump to start of loop which then detects that we are failed and exhausted                         ReactiveHelper.schedule(this).                     } else {                         ReactiveHelper.schedule(this::redeliver).                     }                 } catch (InterruptedException e) {                     redeliverySleepCounter.decrementAndGet().                     // we was interrupted so break out                     exchange.setException(e).                     // mark the exchange to stop continue routing when interrupted                     // as we do not want to continue routing (for example a task has been cancelled)                     exchange.setProperty(Exchange.ROUTE_STOP, Boolean.TRUE).                     ReactiveHelper.callback(callback).                 }             }         } else {             // execute the task immediately             ReactiveHelper.schedule(this::redeliver).         }     } else {         // Simple delivery         outputAsync.process(exchange, doneSync -> {             // and it has not been handled by the error processor             if (isDone(exchange)) {                 ReactiveHelper.callback(callback).             } else {                 // error occurred so loop back around which we do by invoking the processAsyncErrorHandler                 ReactiveHelper.schedule(this).             }         }).     } }
false;protected;0;27;;protected boolean isRunAllowed() {     // if camel context is forcing a shutdown then do not allow running     boolean forceShutdown = camelContext.getShutdownStrategy().forceShutdown(RedeliveryErrorHandler.this).     if (forceShutdown) {         log.trace("isRunAllowed() -> false (Run not allowed as ShutdownStrategy is forcing shutting down)").         return false.     }     // but this only applies during a redelivery (counter must > 0)     if (redeliveryCounter > 0) {         if (currentRedeliveryPolicy.allowRedeliveryWhileStopping) {             log.trace("isRunAllowed() -> true (Run allowed as RedeliverWhileStopping is enabled)").             return true.         } else if (preparingShutdown) {             // we are preparing for shutdown, now determine if we can still run             boolean answer = isRunAllowedOnPreparingShutdown().             log.trace("isRunAllowed() -> {} (Run not allowed as we are preparing for shutdown)", answer).             return answer.         }     }     // we cannot run if we are stopping/stopped     boolean answer = !isStoppingOrStopped().     log.trace("isRunAllowed() -> {} (Run allowed if we are not stopped/stopping)", answer).     return answer. }
false;protected;0;22;;protected boolean isRedeliveryAllowed() {     // but this only applies during a redelivery (counter must > 0)     if (redeliveryCounter > 0) {         boolean stopping = isStoppingOrStopped().         if (!preparingShutdown && !stopping) {             log.trace("isRedeliveryAllowed() -> true (we are not stopping/stopped)").             return true.         } else {             // we are stopping or preparing to shutdown             if (currentRedeliveryPolicy.allowRedeliveryWhileStopping) {                 log.trace("isRedeliveryAllowed() -> true (Redelivery allowed as RedeliverWhileStopping is enabled)").                 return true.             } else {                 log.trace("isRedeliveryAllowed() -> false (Redelivery not allowed as RedeliverWhileStopping is disabled)").                 return false.             }         }     }     return true. }
false;protected;0;29;;protected void redeliver() {     // prepare for redelivery     prepareExchangeForRedelivery().     // letting onRedeliver be executed at first     deliverToOnRedeliveryProcessor().     if (log.isTraceEnabled()) {         log.trace("Redelivering exchangeId: {} -> {} for Exchange: {}", exchange.getExchangeId(), outputAsync, exchange).     }     // emmit event we are doing redelivery     EventHelper.notifyExchangeRedelivery(exchange.getContext(), exchange, redeliveryCounter).     // process the exchange (also redelivery)     outputAsync.process(exchange, doneSync -> {         log.trace("Redelivering exchangeId: {}", exchange.getExchangeId()).         // and it has not been handled by the error processor         if (isDone(exchange)) {             ReactiveHelper.callback(callback).             return.         } else {             // error occurred so loop back around which we do by invoking the processAsyncErrorHandler             ReactiveHelper.schedule(this).         }     }). }
false;protected;2;25;;protected void prepareExchangeForContinue(Exchange exchange, boolean isDeadLetterChannel) {     Exception caught = exchange.getException().     // we continue so clear any exceptions     exchange.setException(null).     // clear rollback flags     exchange.setProperty(Exchange.ROLLBACK_ONLY, null).     // reset cached streams so they can be read again     MessageHelper.resetStreamCache(exchange.getIn()).     // its continued then remove traces of redelivery attempted and caught exception     exchange.getIn().removeHeader(Exchange.REDELIVERED).     exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER).     exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER).     exchange.removeProperty(Exchange.FAILURE_HANDLED).     // keep the Exchange.EXCEPTION_CAUGHT as property so end user knows the caused exception     // create log message     String msg = "Failed delivery for " + ExchangeHelper.logIds(exchange).     msg = msg + ". Exhausted after delivery attempt: " + redeliveryCounter + " caught: " + caught.     msg = msg + ". Handled and continue routing.".     // log that we failed but want to continue     logFailedDelivery(false, false, false, true, isDeadLetterChannel, exchange, msg, null). }
false;protected;0;38;;protected void prepareExchangeForRedelivery() {     if (!redeliveryEnabled) {         throw new IllegalStateException("Redelivery is not enabled on " + RedeliveryErrorHandler.this + ". Make sure you have configured the error handler properly.").     }     // there must be a defensive copy of the exchange     ObjectHelper.notNull(this.original, "Defensive copy of Exchange is null", RedeliveryErrorHandler.this).     // okay we will give it another go so clear the exception so we can try again     exchange.setException(null).     // clear rollback flags     exchange.setProperty(Exchange.ROLLBACK_ONLY, null).     // TODO: We may want to store these as state on RedeliveryData so we keep them in case end user messes with Exchange     // and then put these on the exchange when doing a redelivery / fault processor     // preserve these headers     Integer redeliveryCounter = exchange.getIn().getHeader(Exchange.REDELIVERY_COUNTER, Integer.class).     Integer redeliveryMaxCounter = exchange.getIn().getHeader(Exchange.REDELIVERY_MAX_COUNTER, Integer.class).     Boolean redelivered = exchange.getIn().getHeader(Exchange.REDELIVERED, Boolean.class).     // we are redelivering so copy from original back to exchange     exchange.getIn().copyFrom(this.original.getIn()).     exchange.setOut(null).     // reset cached streams so they can be read again     MessageHelper.resetStreamCache(exchange.getIn()).     // put back headers     if (redeliveryCounter != null) {         exchange.getIn().setHeader(Exchange.REDELIVERY_COUNTER, redeliveryCounter).     }     if (redeliveryMaxCounter != null) {         exchange.getIn().setHeader(Exchange.REDELIVERY_MAX_COUNTER, redeliveryMaxCounter).     }     if (redelivered != null) {         exchange.getIn().setHeader(Exchange.REDELIVERED, redelivered).     } }
false;protected;0;70;;protected void handleException() {     Exception e = exchange.getException().     // e is never null     Throwable previous = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Throwable.class).     if (previous != null && previous != e) {         // a 2nd exception was thrown while handling a previous exception         // so we need to add the previous as suppressed by the new exception         // see also FatalFallbackErrorHandler         Throwable[] suppressed = e.getSuppressed().         boolean found = false.         for (Throwable t : suppressed) {             if (t == previous) {                 found = true.             }         }         if (!found) {             e.addSuppressed(previous).         }     }     // store the original caused exception in a property, so we can restore it later     exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e).     // find the error handler to use (if any)     OnExceptionDefinition exceptionPolicy = getExceptionPolicy(exchange, e).     if (exceptionPolicy != null) {         currentRedeliveryPolicy = ErrorHandlerReifier.createRedeliveryPolicy(exceptionPolicy, exchange.getContext(), currentRedeliveryPolicy).         handledPredicate = exceptionPolicy.getHandledPolicy().         continuedPredicate = exceptionPolicy.getContinuedPolicy().         retryWhilePredicate = exceptionPolicy.getRetryWhilePolicy().         useOriginalInMessage = exceptionPolicy.getUseOriginalMessagePolicy() != null && exceptionPolicy.getUseOriginalMessagePolicy().         // route specific failure handler?         Processor processor = null.         UnitOfWork uow = exchange.getUnitOfWork().         if (uow != null && uow.getRouteContext() != null) {             String routeId = uow.getRouteContext().getRoute().getId().             processor = exceptionPolicy.getErrorHandler(routeId).         } else if (!exceptionPolicy.getErrorHandlers().isEmpty()) {             // note this should really not happen, but we have this code as a fail safe             // to be backwards compatible with the old behavior             log.warn("Cannot determine current route from Exchange with id: {}, will fallback and use first error handler.", exchange.getExchangeId()).             processor = exceptionPolicy.getErrorHandlers().iterator().next().         }         if (processor != null) {             failureProcessor = processor.         }         // route specific on redelivery?         processor = exceptionPolicy.getOnRedelivery().         if (processor != null) {             onRedeliveryProcessor = processor.         }         // route specific on exception occurred?         processor = exceptionPolicy.getOnExceptionOccurred().         if (processor != null) {             onExceptionProcessor = processor.         }     }     // only log if not failure handled or not an exhausted unit of work     if (!ExchangeHelper.isFailureHandled(exchange) && !ExchangeHelper.isUnitOfWorkExhausted(exchange)) {         String msg = "Failed delivery for " + ExchangeHelper.logIds(exchange) + ". On delivery attempt: " + redeliveryCounter + " caught: " + e.         logFailedDelivery(true, false, false, false, isDeadLetterChannel(), exchange, msg, e).     }     redeliveryCounter = incrementRedeliveryCounter(exchange, e). }
true;protected;0;17;/**  * Gives an optional configured OnExceptionOccurred processor a chance to process just after an exception  * was thrown while processing the Exchange. This allows to execute the processor at the same time the exception was thrown.  */ ;/**  * Gives an optional configured OnExceptionOccurred processor a chance to process just after an exception  * was thrown while processing the Exchange. This allows to execute the processor at the same time the exception was thrown.  */ protected void onExceptionOccurred() {     if (onExceptionProcessor == null) {         return.     }     // run this synchronously as its just a Processor     try {         if (log.isTraceEnabled()) {             log.trace("OnExceptionOccurred processor {} is processing Exchange: {} due exception occurred", onExceptionProcessor, exchange).         }         onExceptionProcessor.process(exchange).     } catch (Throwable e) {         // we dont not want new exception to override existing, so log it as a WARN         log.warn("Error during processing OnExceptionOccurred. This exception is ignored.", e).     }     log.trace("OnExceptionOccurred processor done"). }
true;protected;0;18;/**  * Gives an optional configured redelivery processor a chance to process before the Exchange  * will be redelivered. This can be used to alter the Exchange.  */ ;/**  * Gives an optional configured redelivery processor a chance to process before the Exchange  * will be redelivered. This can be used to alter the Exchange.  */ protected void deliverToOnRedeliveryProcessor() {     if (onRedeliveryProcessor == null) {         return.     }     if (log.isTraceEnabled()) {         log.trace("Redelivery processor {} is processing Exchange: {} before its redelivered", onRedeliveryProcessor, exchange).     }     // run this synchronously as its just a Processor     try {         onRedeliveryProcessor.process(exchange).     } catch (Throwable e) {         exchange.setException(e).     }     log.trace("Redelivery processor done"). }
true;protected;3;128;/**  * All redelivery attempts failed so move the exchange to the dead letter queue  */ ;/**  * All redelivery attempts failed so move the exchange to the dead letter queue  */ protected void deliverToFailureProcessor(final Processor processor, final boolean isDeadLetterChannel, final Exchange exchange) {     Exception caught = exchange.getException().     // we did not success with the redelivery so now we let the failure processor handle it     // clear exception as we let the failure processor handle it     exchange.setException(null).     final boolean shouldHandle = shouldHandle(exchange).     final boolean shouldContinue = shouldContinue(exchange).     // regard both handled or continued as being handled     boolean handled = false.     // always handle if dead letter channel     boolean handleOrContinue = isDeadLetterChannel || shouldHandle || shouldContinue.     if (handleOrContinue) {         // its handled then remove traces of redelivery attempted         exchange.getIn().removeHeader(Exchange.REDELIVERED).         exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER).         exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER).         exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED).         // and remove traces of rollback only and uow exhausted markers         exchange.removeProperty(Exchange.ROLLBACK_ONLY).         exchange.removeProperty(Exchange.UNIT_OF_WORK_EXHAUSTED).         handled = true.     } else {         // must decrement the redelivery counter as we didn't process the redelivery but is         // handling by the failure handler. So we must -1 to not let the counter be out-of-sync         decrementRedeliveryCounter(exchange).     }     // we should allow using the failure processor if we should not continue     // or in case of continue then the failure processor is NOT a dead letter channel     // because you can continue and still let the failure processor do some routing     // before continue in the main route.     boolean allowFailureProcessor = !shouldContinue || !isDeadLetterChannel.     if (allowFailureProcessor && processor != null) {         // prepare original IN body if it should be moved instead of current body         if (useOriginalInMessage) {             log.trace("Using the original IN message instead of current").             Message original = ExchangeHelper.getOriginalInMessage(exchange).             exchange.setIn(original).             if (exchange.hasOut()) {                 log.trace("Removing the out message to avoid some uncertain behavior").                 exchange.setOut(null).             }         }         // reset cached streams so they can be read again         MessageHelper.resetStreamCache(exchange.getIn()).         // invoke custom on prepare         if (onPrepareProcessor != null) {             try {                 log.trace("OnPrepare processor {} is processing Exchange: {}", onPrepareProcessor, exchange).                 onPrepareProcessor.process(exchange).             } catch (Exception e) {                 // a new exception was thrown during prepare                 exchange.setException(e).             }         }         log.trace("Failure processor {} is processing Exchange: {}", processor, exchange).         // store the last to endpoint as the failure endpoint         exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT)).         // and store the route id so we know in which route we failed         UnitOfWork uow = exchange.getUnitOfWork().         if (uow != null && uow.getRouteContext() != null) {             exchange.setProperty(Exchange.FAILURE_ROUTE_ID, uow.getRouteContext().getRoute().getId()).         }         // fire event as we had a failure processor to handle it, which there is a event for         final boolean deadLetterChannel = processor == deadLetter.         EventHelper.notifyExchangeFailureHandling(exchange.getContext(), exchange, processor, deadLetterChannel, deadLetterUri).         // the failure processor could also be asynchronous         AsyncProcessor afp = AsyncProcessorConverterHelper.convert(processor).         afp.process(exchange, sync -> {             log.trace("Failure processor done: {} processing Exchange: {}", processor, exchange).             try {                 prepareExchangeAfterFailure(exchange, isDeadLetterChannel, shouldHandle, shouldContinue).                 // fire event as we had a failure processor to handle it, which there is a event for                 EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel, deadLetterUri).             } finally {                 // if the fault was handled asynchronously, this should be reflected in the callback as well                 ReactiveHelper.callback(callback).             }         }).     } else {         try {             // invoke custom on prepare             if (onPrepareProcessor != null) {                 try {                     log.trace("OnPrepare processor {} is processing Exchange: {}", onPrepareProcessor, exchange).                     onPrepareProcessor.process(exchange).                 } catch (Exception e) {                     // a new exception was thrown during prepare                     exchange.setException(e).                 }             }             // no processor but we need to prepare after failure as well             prepareExchangeAfterFailure(exchange, isDeadLetterChannel, shouldHandle, shouldContinue).         } finally {             // callback we are done             ReactiveHelper.callback(callback).         }     }     // create log message     String msg = "Failed delivery for " + ExchangeHelper.logIds(exchange).     msg = msg + ". Exhausted after delivery attempt: " + redeliveryCounter + " caught: " + caught.     if (processor != null) {         if (isDeadLetterChannel && deadLetterUri != null) {             msg = msg + ". Handled by DeadLetterChannel: [" + URISupport.sanitizeUri(deadLetterUri) + "]".         } else {             msg = msg + ". Processed by failure processor: " + processor.         }     }     // log that we failed delivery as we are exhausted     logFailedDelivery(false, false, handled, false, isDeadLetterChannel, exchange, msg, null). }
false;protected;4;64;;protected void prepareExchangeAfterFailure(final Exchange exchange, final boolean isDeadLetterChannel, final boolean shouldHandle, final boolean shouldContinue) {     Exception newException = exchange.getException().     // we could not process the exchange so we let the failure processor handled it     ExchangeHelper.setFailureHandled(exchange).     // honor if already set a handling     boolean alreadySet = exchange.getProperty(Exchange.ERRORHANDLER_HANDLED) != null.     if (alreadySet) {         boolean handled = exchange.getProperty(Exchange.ERRORHANDLER_HANDLED, Boolean.class).         log.trace("This exchange has already been marked for handling: {}", handled).         if (!handled) {             // exception not handled, put exception back in the exchange             exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class)).             // and put failure endpoint back as well             exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT)).         }         return.     }     // dead letter channel is special     if (shouldContinue) {         log.trace("This exchange is continued: {}", exchange).         // okay we want to continue then prepare the exchange for that as well         prepareExchangeForContinue(exchange, isDeadLetterChannel).     } else if (shouldHandle) {         log.trace("This exchange is handled so its marked as not failed: {}", exchange).         exchange.setProperty(Exchange.ERRORHANDLER_HANDLED, Boolean.TRUE).     } else {         // special situations when using dead letter channel         if (isDeadLetterChannel) {             // DLC is always handling the first thrown exception,             // but if its a new exception then use the configured option             boolean handled = newException == null || deadLetterHandleNewException.             // to avoid causing endless poison messages that fails forever)             if (newException != null && currentRedeliveryPolicy.isLogNewException()) {                 String uri = URISupport.sanitizeUri(deadLetterUri).                 String msg = "New exception occurred during processing by the DeadLetterChannel[" + uri + "] due " + newException.getMessage().                 if (handled) {                     msg += ". The new exception is being handled as deadLetterHandleNewException=true.".                 } else {                     msg += ". The new exception is not handled as deadLetterHandleNewException=false.".                 }                 logFailedDelivery(false, true, handled, false, true, exchange, msg, newException).             }             if (handled) {                 log.trace("This exchange is handled so its marked as not failed: {}", exchange).                 exchange.setProperty(Exchange.ERRORHANDLER_HANDLED, Boolean.TRUE).                 return.             }         }         // not handled by default         prepareExchangeAfterFailureNotHandled(exchange).     } }
false;private;1;13;;private void prepareExchangeAfterFailureNotHandled(Exchange exchange) {     log.trace("This exchange is not handled or continued so its marked as failed: {}", exchange).     // exception not handled, put exception back in the exchange     exchange.setProperty(Exchange.ERRORHANDLER_HANDLED, Boolean.FALSE).     exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class)).     // and put failure endpoint back as well     exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT)).     // and store the route id so we know in which route we failed     UnitOfWork uow = exchange.getUnitOfWork().     if (uow != null && uow.getRouteContext() != null) {         exchange.setProperty(Exchange.FAILURE_ROUTE_ID, uow.getRouteContext().getRoute().getId()).     } }
false;private;8;128;;private void logFailedDelivery(boolean shouldRedeliver, boolean newException, boolean handled, boolean continued, boolean isDeadLetterChannel, Exchange exchange, String message, Throwable e) {     if (logger == null) {         return.     }     if (!exchange.isRollbackOnly()) {         if (newException && !currentRedeliveryPolicy.isLogNewException()) {             // do not log new exception             return.         }         if (!newException && handled && !currentRedeliveryPolicy.isLogHandled()) {             // do not log handled             return.         }         if (!newException && continued && !currentRedeliveryPolicy.isLogContinued()) {             // do not log handled             return.         }         if (!newException && shouldRedeliver && !currentRedeliveryPolicy.isLogRetryAttempted()) {             // do not log retry attempts             return.         }         if (!newException && shouldRedeliver) {             if (currentRedeliveryPolicy.isLogRetryAttempted()) {                 if ((currentRedeliveryPolicy.getRetryAttemptedLogInterval() > 1) && (redeliveryCounter % currentRedeliveryPolicy.getRetryAttemptedLogInterval()) != 0) {                     // do not log retry attempt because it is excluded by the retryAttemptedLogInterval                     return.                 }             } else {                 // do not log retry attempts                 return.             }         }         if (!newException && !shouldRedeliver && !currentRedeliveryPolicy.isLogExhausted()) {             // do not log exhausted             return.         }     }     LoggingLevel newLogLevel.     boolean logStackTrace.     if (exchange.isRollbackOnly()) {         newLogLevel = currentRedeliveryPolicy.getRetriesExhaustedLogLevel().         logStackTrace = currentRedeliveryPolicy.isLogStackTrace().     } else if (shouldRedeliver) {         newLogLevel = currentRedeliveryPolicy.getRetryAttemptedLogLevel().         logStackTrace = currentRedeliveryPolicy.isLogRetryStackTrace().     } else {         newLogLevel = currentRedeliveryPolicy.getRetriesExhaustedLogLevel().         logStackTrace = currentRedeliveryPolicy.isLogStackTrace().     }     if (e == null) {         e = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class).     }     if (newException) {         // log at most WARN level         if (newLogLevel == LoggingLevel.ERROR) {             newLogLevel = LoggingLevel.WARN.         }         String msg = message.         if (msg == null) {             msg = "New exception " + ExchangeHelper.logIds(exchange).             // special for logging the new exception             Throwable cause = e.             if (cause != null) {                 msg = msg + " due: " + cause.getMessage().             }         }         if (e != null && logStackTrace) {             logger.log(msg, e, newLogLevel).         } else {             logger.log(msg, newLogLevel).         }     } else if (exchange.isRollbackOnly()) {         String msg = "Rollback " + ExchangeHelper.logIds(exchange).         Throwable cause = exchange.getException() != null ? exchange.getException() : exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Throwable.class).         if (cause != null) {             msg = msg + " due: " + cause.getMessage().         }         // should we include message history         if (!shouldRedeliver && currentRedeliveryPolicy.isLogExhaustedMessageHistory()) {             // only use the exchange formatter if we should log exhausted message body (and if using a custom formatter then always use it)             ExchangeFormatter formatter = customExchangeFormatter ? exchangeFormatter : (currentRedeliveryPolicy.isLogExhaustedMessageBody() || camelContext.isLogExhaustedMessageBody() ? exchangeFormatter : null).             String routeStackTrace = MessageHelper.dumpMessageHistoryStacktrace(exchange, formatter, false).             if (routeStackTrace != null) {                 msg = msg + "\n" + routeStackTrace.             }         }         if (newLogLevel == LoggingLevel.ERROR) {             // log intended rollback on maximum WARN level (not ERROR)             logger.log(msg, LoggingLevel.WARN).         } else {             // otherwise use the desired logging level             logger.log(msg, newLogLevel).         }     } else {         String msg = message.         // should we include message history         if (!shouldRedeliver && currentRedeliveryPolicy.isLogExhaustedMessageHistory()) {             // only use the exchange formatter if we should log exhausted message body (and if using a custom formatter then always use it)             ExchangeFormatter formatter = customExchangeFormatter ? exchangeFormatter : (currentRedeliveryPolicy.isLogExhaustedMessageBody() || camelContext.isLogExhaustedMessageBody() ? exchangeFormatter : null).             String routeStackTrace = MessageHelper.dumpMessageHistoryStacktrace(exchange, formatter, e != null && logStackTrace).             if (routeStackTrace != null) {                 msg = msg + "\n" + routeStackTrace.             }         }         if (e != null && logStackTrace) {             logger.log(msg, e, newLogLevel).         } else {             logger.log(msg, newLogLevel).         }     } }
true;private;1;22;/**  * Determines whether the exchange is exhausted (or anyway marked to not continue such as rollback).  * <p/>  * If the exchange is exhausted, then we will not continue processing, but let the  * failure processor deal with the exchange.  *  * @param exchange the current exchange  * @return <tt>false</tt> to continue/redeliver, or <tt>true</tt> to exhaust.  */ ;/**  * Determines whether the exchange is exhausted (or anyway marked to not continue such as rollback).  * <p/>  * If the exchange is exhausted, then we will not continue processing, but let the  * failure processor deal with the exchange.  *  * @param exchange the current exchange  * @return <tt>false</tt> to continue/redeliver, or <tt>true</tt> to exhaust.  */ private boolean isExhausted(Exchange exchange) {     // if marked as rollback only then do not continue/redeliver     boolean exhausted = exchange.getProperty(Exchange.REDELIVERY_EXHAUSTED, false, Boolean.class).     if (exhausted) {         log.trace("This exchange is marked as redelivery exhausted: {}", exchange).         return true.     }     // if marked as rollback only then do not continue/redeliver     boolean rollbackOnly = exchange.getProperty(Exchange.ROLLBACK_ONLY, false, Boolean.class).     if (rollbackOnly) {         log.trace("This exchange is marked as rollback only, so forcing it to be exhausted: {}", exchange).         return true.     }     // its the first original call so continue     if (redeliveryCounter == 0) {         return false.     }     // its a potential redelivery so determine if we should redeliver or not     boolean redeliver = currentRedeliveryPolicy.shouldRedeliver(exchange, redeliveryCounter, retryWhilePredicate).     return !redeliver. }
true;private;1;7;/**  * Determines whether or not to continue if we are exhausted.  *  * @param exchange the current exchange  * @return <tt>true</tt> to continue, or <tt>false</tt> to exhaust.  */ ;/**  * Determines whether or not to continue if we are exhausted.  *  * @param exchange the current exchange  * @return <tt>true</tt> to continue, or <tt>false</tt> to exhaust.  */ private boolean shouldContinue(Exchange exchange) {     if (continuedPredicate != null) {         return continuedPredicate.matches(exchange).     }     // do not continue by default     return false. }
true;private;1;7;/**  * Determines whether or not to handle if we are exhausted.  *  * @param exchange the current exchange  * @return <tt>true</tt> to handle, or <tt>false</tt> to exhaust.  */ ;/**  * Determines whether or not to handle if we are exhausted.  *  * @param exchange the current exchange  * @return <tt>true</tt> to handle, or <tt>false</tt> to exhaust.  */ private boolean shouldHandle(Exchange exchange) {     if (handledPredicate != null) {         return handledPredicate.matches(exchange).     }     // do not handle by default     return false. }
true;private;2;12;/**  * Increments the redelivery counter and adds the redelivered flag if the  * message has been redelivered  */ ;/**  * Increments the redelivery counter and adds the redelivered flag if the  * message has been redelivered  */ private int incrementRedeliveryCounter(Exchange exchange, Throwable e) {     Message in = exchange.getIn().     Integer counter = in.getHeader(Exchange.REDELIVERY_COUNTER, Integer.class).     int next = counter != null ? counter + 1 : 1.     in.setHeader(Exchange.REDELIVERY_COUNTER, next).     in.setHeader(Exchange.REDELIVERED, Boolean.TRUE).     // if maximum redeliveries is used, then provide that information as well     if (currentRedeliveryPolicy.getMaximumRedeliveries() > 0) {         in.setHeader(Exchange.REDELIVERY_MAX_COUNTER, currentRedeliveryPolicy.getMaximumRedeliveries()).     }     return next. }
true;public;0;29;/**  * Method for sleeping during redelivery attempts.  * <p/>  * This task is for the synchronous blocking. If using async delayed then a scheduled thread pool  * is used for sleeping and trigger redeliveries.  */ ;/**  * Method for sleeping during redelivery attempts.  * <p/>  * This task is for the synchronous blocking. If using async delayed then a scheduled thread pool  * is used for sleeping and trigger redeliveries.  */ public boolean sleep() throws InterruptedException {     // for small delays then just sleep     if (redeliveryDelay < 1000) {         currentRedeliveryPolicy.sleep(redeliveryDelay).         return true.     }     StopWatch watch = new StopWatch().     log.debug("Sleeping for: {} millis until attempting redelivery", redeliveryDelay).     while (watch.taken() < redeliveryDelay) {         // sleep using 1 sec interval         long delta = redeliveryDelay - watch.taken().         long max = Math.min(1000, delta).         if (max > 0) {             log.trace("Sleeping for: {} millis until waking up for re-check", max).             Thread.sleep(max).         }         // are we preparing for shutdown then only do redelivery if allowed         if (preparingShutdown && !currentRedeliveryPolicy.isAllowRedeliveryWhileStopping()) {             log.debug("Rejected redelivery while stopping").             return false.         }     }     return true. }
true;private;1;14;/**  * Prepares the redelivery counter and boolean flag for the failure handle processor  */ ;/**  * Prepares the redelivery counter and boolean flag for the failure handle processor  */ private void decrementRedeliveryCounter(Exchange exchange) {     Message in = exchange.getIn().     Integer counter = in.getHeader(Exchange.REDELIVERY_COUNTER, Integer.class).     if (counter != null) {         int prev = counter - 1.         in.setHeader(Exchange.REDELIVERY_COUNTER, prev).         // set boolean flag according to counter         in.setHeader(Exchange.REDELIVERED, prev > 0 ? Boolean.TRUE : Boolean.FALSE).     } else {         // not redelivered         in.setHeader(Exchange.REDELIVERY_COUNTER, 0).         in.setHeader(Exchange.REDELIVERED, Boolean.FALSE).     } }
true;public;0;39;/**  * Determines if redelivery is enabled by checking if any of the redelivery policy  * settings may allow redeliveries.  *  * @return <tt>true</tt> if redelivery is possible, <tt>false</tt> otherwise  * @throws Exception can be thrown  */ ;/**  * Determines if redelivery is enabled by checking if any of the redelivery policy  * settings may allow redeliveries.  *  * @return <tt>true</tt> if redelivery is possible, <tt>false</tt> otherwise  * @throws Exception can be thrown  */ public boolean determineIfRedeliveryIsEnabled() throws Exception {     // determine if redeliver is enabled either on error handler     if (getRedeliveryPolicy().getMaximumRedeliveries() != 0) {         // must check for != 0 as (-1 means redeliver forever)         return true.     }     if (retryWhilePolicy != null) {         return true.     }     // or on the exception policies     if (!exceptionPolicies.isEmpty()) {         // walk them to see if any of them have a maximum redeliveries > 0 or retry until set         for (OnExceptionDefinition def : exceptionPolicies.values()) {             String ref = def.getRedeliveryPolicyRef().             if (ref != null) {                 // lookup in registry if ref provided                 RedeliveryPolicy policy = CamelContextHelper.mandatoryLookup(camelContext, ref, RedeliveryPolicy.class).                 if (policy.getMaximumRedeliveries() != 0) {                     // must check for != 0 as (-1 means redeliver forever)                     return true.                 }             } else if (def.getRedeliveryPolicyType() != null) {                 Integer max = CamelContextHelper.parseInteger(camelContext, def.getRedeliveryPolicyType().getMaximumRedeliveries()).                 if (max != null && max != 0) {                     // must check for != 0 as (-1 means redeliver forever)                     return true.                 }             }             if (def.getRetryWhilePolicy() != null || def.getRetryWhile() != null) {                 return true.             }         }     }     return false. }
true;public;0;8;/**  * Gets the number of exchanges that are pending for redelivery  */ ;/**  * Gets the number of exchanges that are pending for redelivery  */ public int getPendingRedeliveryCount() {     int answer = redeliverySleepCounter.get().     if (executorService instanceof ThreadPoolExecutor) {         answer += ((ThreadPoolExecutor) executorService).getQueue().size().     }     return answer. }
false;protected;0;25;;@Override protected void doStart() throws Exception {     ServiceHelper.startService(output, outputAsync, deadLetter).     // determine if redeliver is enabled or not     redeliveryEnabled = determineIfRedeliveryIsEnabled().     if (log.isTraceEnabled()) {         log.trace("Redelivery enabled: {} on error handler: {}", redeliveryEnabled, this).     }     // we only need thread pool if redelivery is enabled     if (redeliveryEnabled) {         if (executorService == null) {             // use default shared executor service             executorService = camelContext.getErrorHandlerExecutorService().         }         if (log.isDebugEnabled()) {             log.debug("Using ExecutorService: {} for redeliveries on error handler: {}", executorService, this).         }     }     // reset flag when starting     preparingShutdown = false.     redeliverySleepCounter.set(0). }
false;protected;0;6;;@Override protected void doStop() throws Exception { // noop, do not stop any services which we only do when shutting down // as the error handler can be context scoped, and should not stop in case // a route stops }
false;protected;0;4;;@Override protected void doShutdown() throws Exception {     ServiceHelper.stopAndShutdownServices(deadLetter, output, outputAsync). }
