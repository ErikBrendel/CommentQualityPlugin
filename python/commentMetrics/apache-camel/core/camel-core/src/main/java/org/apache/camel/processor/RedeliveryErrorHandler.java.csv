# id;timestamp;commentText;codeText;commentWords;codeWords
RedeliveryErrorHandler -> public Processor getDeadLetter();1549264559;Returns the dead letter that message exchanges will be sent to if the_redelivery attempts fail;public Processor getDeadLetter() {_        return deadLetter__    };returns,the,dead,letter,that,message,exchanges,will,be,sent,to,if,the,redelivery,attempts,fail;public,processor,get,dead,letter,return,dead,letter
RedeliveryErrorHandler -> public Processor getDeadLetter();1549967797;Returns the dead letter that message exchanges will be sent to if the_redelivery attempts fail;public Processor getDeadLetter() {_        return deadLetter__    };returns,the,dead,letter,that,message,exchanges,will,be,sent,to,if,the,redelivery,attempts,fail;public,processor,get,dead,letter,return,dead,letter
RedeliveryErrorHandler -> public Processor getDeadLetter();1549968092;Returns the dead letter that message exchanges will be sent to if the_redelivery attempts fail;public Processor getDeadLetter() {_        return deadLetter__    };returns,the,dead,letter,that,message,exchanges,will,be,sent,to,if,the,redelivery,attempts,fail;public,processor,get,dead,letter,return,dead,letter
RedeliveryErrorHandler -> RedeliveryState -> protected void deliverToFailureProcessor(final Processor processor, final boolean isDeadLetterChannel, final Exchange exchange);1549264559;All redelivery attempts failed so move the exchange to the dead letter queue;protected void deliverToFailureProcessor(final Processor processor, final boolean isDeadLetterChannel, final Exchange exchange) {_            Exception caught = exchange.getException()___            _            _            exchange.setException(null)___            final boolean shouldHandle = shouldHandle(exchange)__            final boolean shouldContinue = shouldContinue(exchange)___            _            boolean handled = false___            _            boolean handleOrContinue = isDeadLetterChannel || shouldHandle || shouldContinue__            if (handleOrContinue) {_                _                exchange.getIn().removeHeader(Exchange.REDELIVERED)__                exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER)__                exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER)__                exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED)___                _                exchange.removeProperty(Exchange.ROLLBACK_ONLY)__                exchange.removeProperty(Exchange.UNIT_OF_WORK_EXHAUSTED)___                handled = true__            } else {_                _                _                decrementRedeliveryCounter(exchange)__            }__            _            _            _            _            boolean allowFailureProcessor = !shouldContinue || !isDeadLetterChannel___            if (allowFailureProcessor && processor != null) {__                _                if (useOriginalInMessage) {_                    log.trace("Using the original IN message instead of current")__                    Message original = ExchangeHelper.getOriginalInMessage(exchange)__                    exchange.setIn(original)__                    if (exchange.hasOut()) {_                        log.trace("Removing the out message to avoid some uncertain behavior")__                        exchange.setOut(null)__                    }_                }__                _                MessageHelper.resetStreamCache(exchange.getIn())___                _                if (onPrepareProcessor != null) {_                    try {_                        log.trace("OnPrepare processor {} is processing Exchange: {}", onPrepareProcessor, exchange)__                        onPrepareProcessor.process(exchange)__                    } catch (Exception e) {_                        _                        exchange.setException(e)__                    }_                }__                log.trace("Failure processor {} is processing Exchange: {}", processor, exchange)___                _                exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT))__                _                UnitOfWork uow = exchange.getUnitOfWork()__                if (uow != null && uow.getRouteContext() != null) {_                    exchange.setProperty(Exchange.FAILURE_ROUTE_ID, uow.getRouteContext().getRoute().getId())__                }__                _                final boolean deadLetterChannel = processor == deadLetter___                EventHelper.notifyExchangeFailureHandling(exchange.getContext(), exchange, processor, deadLetterChannel, deadLetterUri)___                _                AsyncProcessor afp = AsyncProcessorConverterHelper.convert(processor)__                afp.process(exchange, sync -> {_                    log.trace("Failure processor done: {} processing Exchange: {}", processor, exchange)__                    try {_                        prepareExchangeAfterFailure(exchange, isDeadLetterChannel, shouldHandle, shouldContinue)__                        _                        EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel, deadLetterUri)__                    } finally {_                        _                        ReactiveHelper.callback(callback)__                    }_                })__            } else {_                try {_                    _                    if (onPrepareProcessor != null) {_                        try {_                            log.trace("OnPrepare processor {} is processing Exchange: {}", onPrepareProcessor, exchange)__                            onPrepareProcessor.process(exchange)__                        } catch (Exception e) {_                            _                            exchange.setException(e)__                        }_                    }_                    _                    prepareExchangeAfterFailure(exchange, isDeadLetterChannel, shouldHandle, shouldContinue)__                } finally {_                    _                    ReactiveHelper.callback(callback)__                }_            }__            _            String msg = "Failed delivery for " + ExchangeHelper.logIds(exchange)__            msg = msg + ". Exhausted after delivery attempt: " + redeliveryCounter + " caught: " + caught__            if (processor != null) {_                if (isDeadLetterChannel && deadLetterUri != null) {_                    msg = msg + ". Handled by DeadLetterChannel: [" + URISupport.sanitizeUri(deadLetterUri) + "]"__                } else {_                    msg = msg + ". Processed by failure processor: " + processor__                }_            }__            _            logFailedDelivery(false, false, handled, false, isDeadLetterChannel, exchange, msg, null)__        };all,redelivery,attempts,failed,so,move,the,exchange,to,the,dead,letter,queue;protected,void,deliver,to,failure,processor,final,processor,processor,final,boolean,is,dead,letter,channel,final,exchange,exchange,exception,caught,exchange,get,exception,exchange,set,exception,null,final,boolean,should,handle,should,handle,exchange,final,boolean,should,continue,should,continue,exchange,boolean,handled,false,boolean,handle,or,continue,is,dead,letter,channel,should,handle,should,continue,if,handle,or,continue,exchange,get,in,remove,header,exchange,redelivered,exchange,get,in,remove,header,exchange,exchange,get,in,remove,header,exchange,exchange,remove,property,exchange,exchange,remove,property,exchange,exchange,remove,property,exchange,handled,true,else,decrement,redelivery,counter,exchange,boolean,allow,failure,processor,should,continue,is,dead,letter,channel,if,allow,failure,processor,processor,null,if,use,original,in,message,log,trace,using,the,original,in,message,instead,of,current,message,original,exchange,helper,get,original,in,message,exchange,exchange,set,in,original,if,exchange,has,out,log,trace,removing,the,out,message,to,avoid,some,uncertain,behavior,exchange,set,out,null,message,helper,reset,stream,cache,exchange,get,in,if,on,prepare,processor,null,try,log,trace,on,prepare,processor,is,processing,exchange,on,prepare,processor,exchange,on,prepare,processor,process,exchange,catch,exception,e,exchange,set,exception,e,log,trace,failure,processor,is,processing,exchange,processor,exchange,exchange,set,property,exchange,exchange,get,property,exchange,unit,of,work,uow,exchange,get,unit,of,work,if,uow,null,uow,get,route,context,null,exchange,set,property,exchange,uow,get,route,context,get,route,get,id,final,boolean,dead,letter,channel,processor,dead,letter,event,helper,notify,exchange,failure,handling,exchange,get,context,exchange,processor,dead,letter,channel,dead,letter,uri,async,processor,afp,async,processor,converter,helper,convert,processor,afp,process,exchange,sync,log,trace,failure,processor,done,processing,exchange,processor,exchange,try,prepare,exchange,after,failure,exchange,is,dead,letter,channel,should,handle,should,continue,event,helper,notify,exchange,failure,handled,exchange,get,context,exchange,processor,dead,letter,channel,dead,letter,uri,finally,reactive,helper,callback,callback,else,try,if,on,prepare,processor,null,try,log,trace,on,prepare,processor,is,processing,exchange,on,prepare,processor,exchange,on,prepare,processor,process,exchange,catch,exception,e,exchange,set,exception,e,prepare,exchange,after,failure,exchange,is,dead,letter,channel,should,handle,should,continue,finally,reactive,helper,callback,callback,string,msg,failed,delivery,for,exchange,helper,log,ids,exchange,msg,msg,exhausted,after,delivery,attempt,redelivery,counter,caught,caught,if,processor,null,if,is,dead,letter,channel,dead,letter,uri,null,msg,msg,handled,by,dead,letter,channel,urisupport,sanitize,uri,dead,letter,uri,else,msg,msg,processed,by,failure,processor,processor,log,failed,delivery,false,false,handled,false,is,dead,letter,channel,exchange,msg,null
RedeliveryErrorHandler -> RedeliveryState -> protected void deliverToFailureProcessor(final Processor processor, final boolean isDeadLetterChannel, final Exchange exchange);1549967797;All redelivery attempts failed so move the exchange to the dead letter queue;protected void deliverToFailureProcessor(final Processor processor, final boolean isDeadLetterChannel, final Exchange exchange) {_            Exception caught = exchange.getException()___            _            _            exchange.setException(null)___            final boolean shouldHandle = shouldHandle(exchange)__            final boolean shouldContinue = shouldContinue(exchange)___            _            boolean handled = false___            _            boolean handleOrContinue = isDeadLetterChannel || shouldHandle || shouldContinue__            if (handleOrContinue) {_                _                exchange.getIn().removeHeader(Exchange.REDELIVERED)__                exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER)__                exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER)__                exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED)___                _                exchange.removeProperty(Exchange.ROLLBACK_ONLY)__                exchange.removeProperty(Exchange.UNIT_OF_WORK_EXHAUSTED)___                handled = true__            } else {_                _                _                decrementRedeliveryCounter(exchange)__            }__            _            _            _            _            boolean allowFailureProcessor = !shouldContinue || !isDeadLetterChannel___            if (allowFailureProcessor && processor != null) {__                _                if (useOriginalInMessage) {_                    log.trace("Using the original IN message instead of current")__                    Message original = ExchangeHelper.getOriginalInMessage(exchange)__                    exchange.setIn(original)__                    if (exchange.hasOut()) {_                        log.trace("Removing the out message to avoid some uncertain behavior")__                        exchange.setOut(null)__                    }_                }__                _                MessageHelper.resetStreamCache(exchange.getIn())___                _                if (onPrepareProcessor != null) {_                    try {_                        log.trace("OnPrepare processor {} is processing Exchange: {}", onPrepareProcessor, exchange)__                        onPrepareProcessor.process(exchange)__                    } catch (Exception e) {_                        _                        exchange.setException(e)__                    }_                }__                log.trace("Failure processor {} is processing Exchange: {}", processor, exchange)___                _                exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT))__                _                UnitOfWork uow = exchange.getUnitOfWork()__                if (uow != null && uow.getRouteContext() != null) {_                    exchange.setProperty(Exchange.FAILURE_ROUTE_ID, uow.getRouteContext().getRoute().getId())__                }__                _                final boolean deadLetterChannel = processor == deadLetter___                EventHelper.notifyExchangeFailureHandling(exchange.getContext(), exchange, processor, deadLetterChannel, deadLetterUri)___                _                AsyncProcessor afp = AsyncProcessorConverterHelper.convert(processor)__                afp.process(exchange, sync -> {_                    log.trace("Failure processor done: {} processing Exchange: {}", processor, exchange)__                    try {_                        prepareExchangeAfterFailure(exchange, isDeadLetterChannel, shouldHandle, shouldContinue)__                        _                        EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel, deadLetterUri)__                    } finally {_                        _                        ReactiveHelper.callback(callback)__                    }_                })__            } else {_                try {_                    _                    if (onPrepareProcessor != null) {_                        try {_                            log.trace("OnPrepare processor {} is processing Exchange: {}", onPrepareProcessor, exchange)__                            onPrepareProcessor.process(exchange)__                        } catch (Exception e) {_                            _                            exchange.setException(e)__                        }_                    }_                    _                    prepareExchangeAfterFailure(exchange, isDeadLetterChannel, shouldHandle, shouldContinue)__                } finally {_                    _                    ReactiveHelper.callback(callback)__                }_            }__            _            String msg = "Failed delivery for " + ExchangeHelper.logIds(exchange)__            msg = msg + ". Exhausted after delivery attempt: " + redeliveryCounter + " caught: " + caught__            if (processor != null) {_                if (isDeadLetterChannel && deadLetterUri != null) {_                    msg = msg + ". Handled by DeadLetterChannel: [" + URISupport.sanitizeUri(deadLetterUri) + "]"__                } else {_                    msg = msg + ". Processed by failure processor: " + processor__                }_            }__            _            logFailedDelivery(false, false, handled, false, isDeadLetterChannel, exchange, msg, null)__        };all,redelivery,attempts,failed,so,move,the,exchange,to,the,dead,letter,queue;protected,void,deliver,to,failure,processor,final,processor,processor,final,boolean,is,dead,letter,channel,final,exchange,exchange,exception,caught,exchange,get,exception,exchange,set,exception,null,final,boolean,should,handle,should,handle,exchange,final,boolean,should,continue,should,continue,exchange,boolean,handled,false,boolean,handle,or,continue,is,dead,letter,channel,should,handle,should,continue,if,handle,or,continue,exchange,get,in,remove,header,exchange,redelivered,exchange,get,in,remove,header,exchange,exchange,get,in,remove,header,exchange,exchange,remove,property,exchange,exchange,remove,property,exchange,exchange,remove,property,exchange,handled,true,else,decrement,redelivery,counter,exchange,boolean,allow,failure,processor,should,continue,is,dead,letter,channel,if,allow,failure,processor,processor,null,if,use,original,in,message,log,trace,using,the,original,in,message,instead,of,current,message,original,exchange,helper,get,original,in,message,exchange,exchange,set,in,original,if,exchange,has,out,log,trace,removing,the,out,message,to,avoid,some,uncertain,behavior,exchange,set,out,null,message,helper,reset,stream,cache,exchange,get,in,if,on,prepare,processor,null,try,log,trace,on,prepare,processor,is,processing,exchange,on,prepare,processor,exchange,on,prepare,processor,process,exchange,catch,exception,e,exchange,set,exception,e,log,trace,failure,processor,is,processing,exchange,processor,exchange,exchange,set,property,exchange,exchange,get,property,exchange,unit,of,work,uow,exchange,get,unit,of,work,if,uow,null,uow,get,route,context,null,exchange,set,property,exchange,uow,get,route,context,get,route,get,id,final,boolean,dead,letter,channel,processor,dead,letter,event,helper,notify,exchange,failure,handling,exchange,get,context,exchange,processor,dead,letter,channel,dead,letter,uri,async,processor,afp,async,processor,converter,helper,convert,processor,afp,process,exchange,sync,log,trace,failure,processor,done,processing,exchange,processor,exchange,try,prepare,exchange,after,failure,exchange,is,dead,letter,channel,should,handle,should,continue,event,helper,notify,exchange,failure,handled,exchange,get,context,exchange,processor,dead,letter,channel,dead,letter,uri,finally,reactive,helper,callback,callback,else,try,if,on,prepare,processor,null,try,log,trace,on,prepare,processor,is,processing,exchange,on,prepare,processor,exchange,on,prepare,processor,process,exchange,catch,exception,e,exchange,set,exception,e,prepare,exchange,after,failure,exchange,is,dead,letter,channel,should,handle,should,continue,finally,reactive,helper,callback,callback,string,msg,failed,delivery,for,exchange,helper,log,ids,exchange,msg,msg,exhausted,after,delivery,attempt,redelivery,counter,caught,caught,if,processor,null,if,is,dead,letter,channel,dead,letter,uri,null,msg,msg,handled,by,dead,letter,channel,urisupport,sanitize,uri,dead,letter,uri,else,msg,msg,processed,by,failure,processor,processor,log,failed,delivery,false,false,handled,false,is,dead,letter,channel,exchange,msg,null
RedeliveryErrorHandler -> RedeliveryState -> protected void deliverToFailureProcessor(final Processor processor, final boolean isDeadLetterChannel, final Exchange exchange);1549968092;All redelivery attempts failed so move the exchange to the dead letter queue;protected void deliverToFailureProcessor(final Processor processor, final boolean isDeadLetterChannel, final Exchange exchange) {_            Exception caught = exchange.getException()___            _            _            exchange.setException(null)___            final boolean shouldHandle = shouldHandle(exchange)__            final boolean shouldContinue = shouldContinue(exchange)___            _            boolean handled = false___            _            boolean handleOrContinue = isDeadLetterChannel || shouldHandle || shouldContinue__            if (handleOrContinue) {_                _                exchange.getIn().removeHeader(Exchange.REDELIVERED)__                exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER)__                exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER)__                exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED)___                _                exchange.removeProperty(Exchange.ROLLBACK_ONLY)__                exchange.removeProperty(Exchange.UNIT_OF_WORK_EXHAUSTED)___                handled = true__            } else {_                _                _                decrementRedeliveryCounter(exchange)__            }__            _            _            _            _            boolean allowFailureProcessor = !shouldContinue || !isDeadLetterChannel___            if (allowFailureProcessor && processor != null) {__                _                if (useOriginalInMessage) {_                    log.trace("Using the original IN message instead of current")__                    Message original = ExchangeHelper.getOriginalInMessage(exchange)__                    exchange.setIn(original)__                    if (exchange.hasOut()) {_                        log.trace("Removing the out message to avoid some uncertain behavior")__                        exchange.setOut(null)__                    }_                }__                _                MessageHelper.resetStreamCache(exchange.getIn())___                _                if (onPrepareProcessor != null) {_                    try {_                        log.trace("OnPrepare processor {} is processing Exchange: {}", onPrepareProcessor, exchange)__                        onPrepareProcessor.process(exchange)__                    } catch (Exception e) {_                        _                        exchange.setException(e)__                    }_                }__                log.trace("Failure processor {} is processing Exchange: {}", processor, exchange)___                _                exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT))__                _                UnitOfWork uow = exchange.getUnitOfWork()__                if (uow != null && uow.getRouteContext() != null) {_                    exchange.setProperty(Exchange.FAILURE_ROUTE_ID, uow.getRouteContext().getRoute().getId())__                }__                _                final boolean deadLetterChannel = processor == deadLetter___                EventHelper.notifyExchangeFailureHandling(exchange.getContext(), exchange, processor, deadLetterChannel, deadLetterUri)___                _                AsyncProcessor afp = AsyncProcessorConverterHelper.convert(processor)__                afp.process(exchange, sync -> {_                    log.trace("Failure processor done: {} processing Exchange: {}", processor, exchange)__                    try {_                        prepareExchangeAfterFailure(exchange, isDeadLetterChannel, shouldHandle, shouldContinue)__                        _                        EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel, deadLetterUri)__                    } finally {_                        _                        ReactiveHelper.callback(callback)__                    }_                })__            } else {_                try {_                    _                    if (onPrepareProcessor != null) {_                        try {_                            log.trace("OnPrepare processor {} is processing Exchange: {}", onPrepareProcessor, exchange)__                            onPrepareProcessor.process(exchange)__                        } catch (Exception e) {_                            _                            exchange.setException(e)__                        }_                    }_                    _                    prepareExchangeAfterFailure(exchange, isDeadLetterChannel, shouldHandle, shouldContinue)__                } finally {_                    _                    ReactiveHelper.callback(callback)__                }_            }__            _            String msg = "Failed delivery for " + ExchangeHelper.logIds(exchange)__            msg = msg + ". Exhausted after delivery attempt: " + redeliveryCounter + " caught: " + caught__            if (processor != null) {_                if (isDeadLetterChannel && deadLetterUri != null) {_                    msg = msg + ". Handled by DeadLetterChannel: [" + URISupport.sanitizeUri(deadLetterUri) + "]"__                } else {_                    msg = msg + ". Processed by failure processor: " + processor__                }_            }__            _            logFailedDelivery(false, false, handled, false, isDeadLetterChannel, exchange, msg, null)__        };all,redelivery,attempts,failed,so,move,the,exchange,to,the,dead,letter,queue;protected,void,deliver,to,failure,processor,final,processor,processor,final,boolean,is,dead,letter,channel,final,exchange,exchange,exception,caught,exchange,get,exception,exchange,set,exception,null,final,boolean,should,handle,should,handle,exchange,final,boolean,should,continue,should,continue,exchange,boolean,handled,false,boolean,handle,or,continue,is,dead,letter,channel,should,handle,should,continue,if,handle,or,continue,exchange,get,in,remove,header,exchange,redelivered,exchange,get,in,remove,header,exchange,exchange,get,in,remove,header,exchange,exchange,remove,property,exchange,exchange,remove,property,exchange,exchange,remove,property,exchange,handled,true,else,decrement,redelivery,counter,exchange,boolean,allow,failure,processor,should,continue,is,dead,letter,channel,if,allow,failure,processor,processor,null,if,use,original,in,message,log,trace,using,the,original,in,message,instead,of,current,message,original,exchange,helper,get,original,in,message,exchange,exchange,set,in,original,if,exchange,has,out,log,trace,removing,the,out,message,to,avoid,some,uncertain,behavior,exchange,set,out,null,message,helper,reset,stream,cache,exchange,get,in,if,on,prepare,processor,null,try,log,trace,on,prepare,processor,is,processing,exchange,on,prepare,processor,exchange,on,prepare,processor,process,exchange,catch,exception,e,exchange,set,exception,e,log,trace,failure,processor,is,processing,exchange,processor,exchange,exchange,set,property,exchange,exchange,get,property,exchange,unit,of,work,uow,exchange,get,unit,of,work,if,uow,null,uow,get,route,context,null,exchange,set,property,exchange,uow,get,route,context,get,route,get,id,final,boolean,dead,letter,channel,processor,dead,letter,event,helper,notify,exchange,failure,handling,exchange,get,context,exchange,processor,dead,letter,channel,dead,letter,uri,async,processor,afp,async,processor,converter,helper,convert,processor,afp,process,exchange,sync,log,trace,failure,processor,done,processing,exchange,processor,exchange,try,prepare,exchange,after,failure,exchange,is,dead,letter,channel,should,handle,should,continue,event,helper,notify,exchange,failure,handled,exchange,get,context,exchange,processor,dead,letter,channel,dead,letter,uri,finally,reactive,helper,callback,callback,else,try,if,on,prepare,processor,null,try,log,trace,on,prepare,processor,is,processing,exchange,on,prepare,processor,exchange,on,prepare,processor,process,exchange,catch,exception,e,exchange,set,exception,e,prepare,exchange,after,failure,exchange,is,dead,letter,channel,should,handle,should,continue,finally,reactive,helper,callback,callback,string,msg,failed,delivery,for,exchange,helper,log,ids,exchange,msg,msg,exhausted,after,delivery,attempt,redelivery,counter,caught,caught,if,processor,null,if,is,dead,letter,channel,dead,letter,uri,null,msg,msg,handled,by,dead,letter,channel,urisupport,sanitize,uri,dead,letter,uri,else,msg,msg,processed,by,failure,processor,processor,log,failed,delivery,false,false,handled,false,is,dead,letter,channel,exchange,msg,null
RedeliveryErrorHandler -> public Processor getOutput();1549264559;Returns the output processor;public Processor getOutput() {_        return output__    };returns,the,output,processor;public,processor,get,output,return,output
RedeliveryErrorHandler -> public Processor getOutput();1549967797;Returns the output processor;public Processor getOutput() {_        return output__    };returns,the,output,processor;public,processor,get,output,return,output
RedeliveryErrorHandler -> public Processor getOutput();1549968092;Returns the output processor;public Processor getOutput() {_        return output__    };returns,the,output,processor;public,processor,get,output,return,output
RedeliveryErrorHandler -> RedeliveryState -> public boolean sleep() throws InterruptedException;1549264559;Method for sleeping during redelivery attempts._<p/>_This task is for the synchronous blocking. If using async delayed then a scheduled thread pool_is used for sleeping and trigger redeliveries.;public boolean sleep() throws InterruptedException {_            _            if (redeliveryDelay < 1000) {_                currentRedeliveryPolicy.sleep(redeliveryDelay)__                return true__            }__            StopWatch watch = new StopWatch()___            log.debug("Sleeping for: {} millis until attempting redelivery", redeliveryDelay)__            while (watch.taken() < redeliveryDelay) {_                __                long delta = redeliveryDelay - watch.taken()__                long max = Math.min(1000, delta)__                if (max > 0) {_                    log.trace("Sleeping for: {} millis until waking up for re-check", max)__                    Thread.sleep(max)__                }__                _                if (preparingShutdown && !currentRedeliveryPolicy.isAllowRedeliveryWhileStopping()) {_                    log.debug("Rejected redelivery while stopping")__                    return false__                }_            }__            return true__        };method,for,sleeping,during,redelivery,attempts,p,this,task,is,for,the,synchronous,blocking,if,using,async,delayed,then,a,scheduled,thread,pool,is,used,for,sleeping,and,trigger,redeliveries;public,boolean,sleep,throws,interrupted,exception,if,redelivery,delay,1000,current,redelivery,policy,sleep,redelivery,delay,return,true,stop,watch,watch,new,stop,watch,log,debug,sleeping,for,millis,until,attempting,redelivery,redelivery,delay,while,watch,taken,redelivery,delay,long,delta,redelivery,delay,watch,taken,long,max,math,min,1000,delta,if,max,0,log,trace,sleeping,for,millis,until,waking,up,for,re,check,max,thread,sleep,max,if,preparing,shutdown,current,redelivery,policy,is,allow,redelivery,while,stopping,log,debug,rejected,redelivery,while,stopping,return,false,return,true
RedeliveryErrorHandler -> RedeliveryState -> public boolean sleep() throws InterruptedException;1549967797;Method for sleeping during redelivery attempts._<p/>_This task is for the synchronous blocking. If using async delayed then a scheduled thread pool_is used for sleeping and trigger redeliveries.;public boolean sleep() throws InterruptedException {_            _            if (redeliveryDelay < 1000) {_                currentRedeliveryPolicy.sleep(redeliveryDelay)__                return true__            }__            StopWatch watch = new StopWatch()___            log.debug("Sleeping for: {} millis until attempting redelivery", redeliveryDelay)__            while (watch.taken() < redeliveryDelay) {_                __                long delta = redeliveryDelay - watch.taken()__                long max = Math.min(1000, delta)__                if (max > 0) {_                    log.trace("Sleeping for: {} millis until waking up for re-check", max)__                    Thread.sleep(max)__                }__                _                if (preparingShutdown && !currentRedeliveryPolicy.isAllowRedeliveryWhileStopping()) {_                    log.debug("Rejected redelivery while stopping")__                    return false__                }_            }__            return true__        };method,for,sleeping,during,redelivery,attempts,p,this,task,is,for,the,synchronous,blocking,if,using,async,delayed,then,a,scheduled,thread,pool,is,used,for,sleeping,and,trigger,redeliveries;public,boolean,sleep,throws,interrupted,exception,if,redelivery,delay,1000,current,redelivery,policy,sleep,redelivery,delay,return,true,stop,watch,watch,new,stop,watch,log,debug,sleeping,for,millis,until,attempting,redelivery,redelivery,delay,while,watch,taken,redelivery,delay,long,delta,redelivery,delay,watch,taken,long,max,math,min,1000,delta,if,max,0,log,trace,sleeping,for,millis,until,waking,up,for,re,check,max,thread,sleep,max,if,preparing,shutdown,current,redelivery,policy,is,allow,redelivery,while,stopping,log,debug,rejected,redelivery,while,stopping,return,false,return,true
RedeliveryErrorHandler -> RedeliveryState -> public boolean sleep() throws InterruptedException;1549968092;Method for sleeping during redelivery attempts._<p/>_This task is for the synchronous blocking. If using async delayed then a scheduled thread pool_is used for sleeping and trigger redeliveries.;public boolean sleep() throws InterruptedException {_            _            if (redeliveryDelay < 1000) {_                currentRedeliveryPolicy.sleep(redeliveryDelay)__                return true__            }__            StopWatch watch = new StopWatch()___            log.debug("Sleeping for: {} millis until attempting redelivery", redeliveryDelay)__            while (watch.taken() < redeliveryDelay) {_                __                long delta = redeliveryDelay - watch.taken()__                long max = Math.min(1000, delta)__                if (max > 0) {_                    log.trace("Sleeping for: {} millis until waking up for re-check", max)__                    Thread.sleep(max)__                }__                _                if (preparingShutdown && !currentRedeliveryPolicy.isAllowRedeliveryWhileStopping()) {_                    log.debug("Rejected redelivery while stopping")__                    return false__                }_            }__            return true__        };method,for,sleeping,during,redelivery,attempts,p,this,task,is,for,the,synchronous,blocking,if,using,async,delayed,then,a,scheduled,thread,pool,is,used,for,sleeping,and,trigger,redeliveries;public,boolean,sleep,throws,interrupted,exception,if,redelivery,delay,1000,current,redelivery,policy,sleep,redelivery,delay,return,true,stop,watch,watch,new,stop,watch,log,debug,sleeping,for,millis,until,attempting,redelivery,redelivery,delay,while,watch,taken,redelivery,delay,long,delta,redelivery,delay,watch,taken,long,max,math,min,1000,delta,if,max,0,log,trace,sleeping,for,millis,until,waking,up,for,re,check,max,thread,sleep,max,if,preparing,shutdown,current,redelivery,policy,is,allow,redelivery,while,stopping,log,debug,rejected,redelivery,while,stopping,return,false,return,true
RedeliveryErrorHandler -> RedeliveryState -> public void run();1549264559;Redelivery logic.;public void run() {_            _            if (!isRunAllowed()) {_                log.trace("Run not allowed, will reject executing exchange: {}", exchange)__                if (exchange.getException() == null) {_                    exchange.setException(new RejectedExecutionException())__                }_                callback.done(false)__                return__            }__            _            boolean handle = shouldHandleException(exchange)__            if (handle) {_                handleException()__                onExceptionOccurred()__            }__            _            boolean exhausted = isExhausted(exchange)__            boolean redeliverAllowed = isRedeliveryAllowed()___            _            if (!redeliverAllowed || exhausted) {_                Processor target = null__                boolean deliver = true___                _                UnitOfWork uow = exchange.getUnitOfWork()__                if (uow != null) {_                    SubUnitOfWorkCallback uowCallback = uow.getSubUnitOfWorkCallback()__                    if (uowCallback != null) {_                        _                        uowCallback.onExhausted(exchange)__                        _                        deliver = false__                    }_                }__                if (deliver) {_                    _                    target = failureProcessor != null ? failureProcessor : deadLetter__                }_                _                _                boolean isDeadLetterChannel = isDeadLetterChannel() && target == deadLetter__                deliverToFailureProcessor(target, isDeadLetterChannel, exchange)__                _            } else if (redeliveryCounter > 0) {_                _                redeliveryDelay = determineRedeliveryDelay(exchange, currentRedeliveryPolicy, redeliveryDelay, redeliveryCounter)___                if (redeliveryDelay > 0) {_                    __                    if (currentRedeliveryPolicy.isAsyncDelayedRedelivery() && !exchange.isTransacted()) {__                        _                        ObjectHelper.notNull(executorService, "Redelivery is enabled but ExecutorService has not been configured.", this)___                        _                        if (log.isTraceEnabled()) {_                            log.trace("Scheduling redelivery task to run in {} millis for exchangeId: {}", redeliveryDelay, exchange.getExchangeId())__                        }_                        executorService.schedule(() -> ReactiveHelper.schedule(this::redeliver), redeliveryDelay, TimeUnit.MILLISECONDS)___                    } else {_                        _                        _                        try {_                            _                            redeliverySleepCounter.incrementAndGet()__                            boolean complete = sleep()__                            redeliverySleepCounter.decrementAndGet()__                            if (!complete) {_                                _                                exchange.setException(new RejectedExecutionException("Redelivery not allowed while stopping"))__                                _                                exchange.setProperty(Exchange.REDELIVERY_EXHAUSTED, Boolean.TRUE)__                                _                                ReactiveHelper.schedule(this)__                            } else {_                                ReactiveHelper.schedule(this::redeliver)__                            }_                        } catch (InterruptedException e) {_                            redeliverySleepCounter.decrementAndGet()__                            _                            exchange.setException(e)__                            _                            _                            exchange.setProperty(Exchange.ROUTE_STOP, Boolean.TRUE)__                            ReactiveHelper.callback(callback)__                        }_                    }_                } else {_                    _                    ReactiveHelper.schedule(this::redeliver)__                }_            } else {_                _                outputAsync.process(exchange, doneSync -> {_                    _                    _                    if (isDone(exchange)) {_                        ReactiveHelper.callback(callback)__                    } else {_                        _                        ReactiveHelper.schedule(this)__                    }_                })__            }_        };redelivery,logic;public,void,run,if,is,run,allowed,log,trace,run,not,allowed,will,reject,executing,exchange,exchange,if,exchange,get,exception,null,exchange,set,exception,new,rejected,execution,exception,callback,done,false,return,boolean,handle,should,handle,exception,exchange,if,handle,handle,exception,on,exception,occurred,boolean,exhausted,is,exhausted,exchange,boolean,redeliver,allowed,is,redelivery,allowed,if,redeliver,allowed,exhausted,processor,target,null,boolean,deliver,true,unit,of,work,uow,exchange,get,unit,of,work,if,uow,null,sub,unit,of,work,callback,uow,callback,uow,get,sub,unit,of,work,callback,if,uow,callback,null,uow,callback,on,exhausted,exchange,deliver,false,if,deliver,target,failure,processor,null,failure,processor,dead,letter,boolean,is,dead,letter,channel,is,dead,letter,channel,target,dead,letter,deliver,to,failure,processor,target,is,dead,letter,channel,exchange,else,if,redelivery,counter,0,redelivery,delay,determine,redelivery,delay,exchange,current,redelivery,policy,redelivery,delay,redelivery,counter,if,redelivery,delay,0,if,current,redelivery,policy,is,async,delayed,redelivery,exchange,is,transacted,object,helper,not,null,executor,service,redelivery,is,enabled,but,executor,service,has,not,been,configured,this,if,log,is,trace,enabled,log,trace,scheduling,redelivery,task,to,run,in,millis,for,exchange,id,redelivery,delay,exchange,get,exchange,id,executor,service,schedule,reactive,helper,schedule,this,redeliver,redelivery,delay,time,unit,milliseconds,else,try,redelivery,sleep,counter,increment,and,get,boolean,complete,sleep,redelivery,sleep,counter,decrement,and,get,if,complete,exchange,set,exception,new,rejected,execution,exception,redelivery,not,allowed,while,stopping,exchange,set,property,exchange,boolean,true,reactive,helper,schedule,this,else,reactive,helper,schedule,this,redeliver,catch,interrupted,exception,e,redelivery,sleep,counter,decrement,and,get,exchange,set,exception,e,exchange,set,property,exchange,boolean,true,reactive,helper,callback,callback,else,reactive,helper,schedule,this,redeliver,else,output,async,process,exchange,done,sync,if,is,done,exchange,reactive,helper,callback,callback,else,reactive,helper,schedule,this
RedeliveryErrorHandler -> RedeliveryState -> public void run();1549967797;Redelivery logic.;public void run() {_            _            if (!isRunAllowed()) {_                log.trace("Run not allowed, will reject executing exchange: {}", exchange)__                if (exchange.getException() == null) {_                    exchange.setException(new RejectedExecutionException())__                }_                callback.done(false)__                return__            }__            _            boolean handle = shouldHandleException(exchange)__            if (handle) {_                handleException()__                onExceptionOccurred()__            }__            _            boolean exhausted = isExhausted(exchange)__            boolean redeliverAllowed = isRedeliveryAllowed()___            _            if (!redeliverAllowed || exhausted) {_                Processor target = null__                boolean deliver = true___                _                UnitOfWork uow = exchange.getUnitOfWork()__                if (uow != null) {_                    SubUnitOfWorkCallback uowCallback = uow.getSubUnitOfWorkCallback()__                    if (uowCallback != null) {_                        _                        uowCallback.onExhausted(exchange)__                        _                        deliver = false__                    }_                }__                if (deliver) {_                    _                    target = failureProcessor != null ? failureProcessor : deadLetter__                }_                _                _                boolean isDeadLetterChannel = isDeadLetterChannel() && target == deadLetter__                deliverToFailureProcessor(target, isDeadLetterChannel, exchange)__                _            } else if (redeliveryCounter > 0) {_                _                redeliveryDelay = determineRedeliveryDelay(exchange, currentRedeliveryPolicy, redeliveryDelay, redeliveryCounter)___                if (redeliveryDelay > 0) {_                    __                    if (currentRedeliveryPolicy.isAsyncDelayedRedelivery() && !exchange.isTransacted()) {__                        _                        ObjectHelper.notNull(executorService, "Redelivery is enabled but ExecutorService has not been configured.", this)___                        _                        if (log.isTraceEnabled()) {_                            log.trace("Scheduling redelivery task to run in {} millis for exchangeId: {}", redeliveryDelay, exchange.getExchangeId())__                        }_                        executorService.schedule(() -> ReactiveHelper.schedule(this::redeliver), redeliveryDelay, TimeUnit.MILLISECONDS)___                    } else {_                        _                        _                        try {_                            _                            redeliverySleepCounter.incrementAndGet()__                            boolean complete = sleep()__                            redeliverySleepCounter.decrementAndGet()__                            if (!complete) {_                                _                                exchange.setException(new RejectedExecutionException("Redelivery not allowed while stopping"))__                                _                                exchange.setProperty(Exchange.REDELIVERY_EXHAUSTED, Boolean.TRUE)__                                _                                ReactiveHelper.schedule(this)__                            } else {_                                ReactiveHelper.schedule(this::redeliver)__                            }_                        } catch (InterruptedException e) {_                            redeliverySleepCounter.decrementAndGet()__                            _                            exchange.setException(e)__                            _                            _                            exchange.setProperty(Exchange.ROUTE_STOP, Boolean.TRUE)__                            ReactiveHelper.callback(callback)__                        }_                    }_                } else {_                    _                    ReactiveHelper.schedule(this::redeliver)__                }_            } else {_                _                outputAsync.process(exchange, doneSync -> {_                    _                    _                    if (isDone(exchange)) {_                        ReactiveHelper.callback(callback)__                    } else {_                        _                        ReactiveHelper.schedule(this)__                    }_                })__            }_        };redelivery,logic;public,void,run,if,is,run,allowed,log,trace,run,not,allowed,will,reject,executing,exchange,exchange,if,exchange,get,exception,null,exchange,set,exception,new,rejected,execution,exception,callback,done,false,return,boolean,handle,should,handle,exception,exchange,if,handle,handle,exception,on,exception,occurred,boolean,exhausted,is,exhausted,exchange,boolean,redeliver,allowed,is,redelivery,allowed,if,redeliver,allowed,exhausted,processor,target,null,boolean,deliver,true,unit,of,work,uow,exchange,get,unit,of,work,if,uow,null,sub,unit,of,work,callback,uow,callback,uow,get,sub,unit,of,work,callback,if,uow,callback,null,uow,callback,on,exhausted,exchange,deliver,false,if,deliver,target,failure,processor,null,failure,processor,dead,letter,boolean,is,dead,letter,channel,is,dead,letter,channel,target,dead,letter,deliver,to,failure,processor,target,is,dead,letter,channel,exchange,else,if,redelivery,counter,0,redelivery,delay,determine,redelivery,delay,exchange,current,redelivery,policy,redelivery,delay,redelivery,counter,if,redelivery,delay,0,if,current,redelivery,policy,is,async,delayed,redelivery,exchange,is,transacted,object,helper,not,null,executor,service,redelivery,is,enabled,but,executor,service,has,not,been,configured,this,if,log,is,trace,enabled,log,trace,scheduling,redelivery,task,to,run,in,millis,for,exchange,id,redelivery,delay,exchange,get,exchange,id,executor,service,schedule,reactive,helper,schedule,this,redeliver,redelivery,delay,time,unit,milliseconds,else,try,redelivery,sleep,counter,increment,and,get,boolean,complete,sleep,redelivery,sleep,counter,decrement,and,get,if,complete,exchange,set,exception,new,rejected,execution,exception,redelivery,not,allowed,while,stopping,exchange,set,property,exchange,boolean,true,reactive,helper,schedule,this,else,reactive,helper,schedule,this,redeliver,catch,interrupted,exception,e,redelivery,sleep,counter,decrement,and,get,exchange,set,exception,e,exchange,set,property,exchange,boolean,true,reactive,helper,callback,callback,else,reactive,helper,schedule,this,redeliver,else,output,async,process,exchange,done,sync,if,is,done,exchange,reactive,helper,callback,callback,else,reactive,helper,schedule,this
RedeliveryErrorHandler -> RedeliveryState -> public void run();1549968092;Redelivery logic.;public void run() {_            _            if (!isRunAllowed()) {_                log.trace("Run not allowed, will reject executing exchange: {}", exchange)__                if (exchange.getException() == null) {_                    exchange.setException(new RejectedExecutionException())__                }_                callback.done(false)__                return__            }__            _            boolean handle = shouldHandleException(exchange)__            if (handle) {_                handleException()__                onExceptionOccurred()__            }__            _            boolean exhausted = isExhausted(exchange)__            boolean redeliverAllowed = isRedeliveryAllowed()___            _            if (!redeliverAllowed || exhausted) {_                Processor target = null__                boolean deliver = true___                _                UnitOfWork uow = exchange.getUnitOfWork()__                if (uow != null) {_                    SubUnitOfWorkCallback uowCallback = uow.getSubUnitOfWorkCallback()__                    if (uowCallback != null) {_                        _                        uowCallback.onExhausted(exchange)__                        _                        deliver = false__                    }_                }__                if (deliver) {_                    _                    target = failureProcessor != null ? failureProcessor : deadLetter__                }_                _                _                boolean isDeadLetterChannel = isDeadLetterChannel() && target == deadLetter__                deliverToFailureProcessor(target, isDeadLetterChannel, exchange)__                _            } else if (redeliveryCounter > 0) {_                _                redeliveryDelay = determineRedeliveryDelay(exchange, currentRedeliveryPolicy, redeliveryDelay, redeliveryCounter)___                if (redeliveryDelay > 0) {_                    __                    if (currentRedeliveryPolicy.isAsyncDelayedRedelivery() && !exchange.isTransacted()) {__                        _                        ObjectHelper.notNull(executorService, "Redelivery is enabled but ExecutorService has not been configured.", this)___                        _                        if (log.isTraceEnabled()) {_                            log.trace("Scheduling redelivery task to run in {} millis for exchangeId: {}", redeliveryDelay, exchange.getExchangeId())__                        }_                        executorService.schedule(() -> ReactiveHelper.schedule(this::redeliver), redeliveryDelay, TimeUnit.MILLISECONDS)___                    } else {_                        _                        _                        try {_                            _                            redeliverySleepCounter.incrementAndGet()__                            boolean complete = sleep()__                            redeliverySleepCounter.decrementAndGet()__                            if (!complete) {_                                _                                exchange.setException(new RejectedExecutionException("Redelivery not allowed while stopping"))__                                _                                exchange.setProperty(Exchange.REDELIVERY_EXHAUSTED, Boolean.TRUE)__                                _                                ReactiveHelper.schedule(this)__                            } else {_                                ReactiveHelper.schedule(this::redeliver)__                            }_                        } catch (InterruptedException e) {_                            redeliverySleepCounter.decrementAndGet()__                            _                            exchange.setException(e)__                            _                            _                            exchange.setProperty(Exchange.ROUTE_STOP, Boolean.TRUE)__                            ReactiveHelper.callback(callback)__                        }_                    }_                } else {_                    _                    ReactiveHelper.schedule(this::redeliver)__                }_            } else {_                _                outputAsync.process(exchange, doneSync -> {_                    _                    _                    if (isDone(exchange)) {_                        ReactiveHelper.callback(callback)__                    } else {_                        _                        ReactiveHelper.schedule(this)__                    }_                })__            }_        };redelivery,logic;public,void,run,if,is,run,allowed,log,trace,run,not,allowed,will,reject,executing,exchange,exchange,if,exchange,get,exception,null,exchange,set,exception,new,rejected,execution,exception,callback,done,false,return,boolean,handle,should,handle,exception,exchange,if,handle,handle,exception,on,exception,occurred,boolean,exhausted,is,exhausted,exchange,boolean,redeliver,allowed,is,redelivery,allowed,if,redeliver,allowed,exhausted,processor,target,null,boolean,deliver,true,unit,of,work,uow,exchange,get,unit,of,work,if,uow,null,sub,unit,of,work,callback,uow,callback,uow,get,sub,unit,of,work,callback,if,uow,callback,null,uow,callback,on,exhausted,exchange,deliver,false,if,deliver,target,failure,processor,null,failure,processor,dead,letter,boolean,is,dead,letter,channel,is,dead,letter,channel,target,dead,letter,deliver,to,failure,processor,target,is,dead,letter,channel,exchange,else,if,redelivery,counter,0,redelivery,delay,determine,redelivery,delay,exchange,current,redelivery,policy,redelivery,delay,redelivery,counter,if,redelivery,delay,0,if,current,redelivery,policy,is,async,delayed,redelivery,exchange,is,transacted,object,helper,not,null,executor,service,redelivery,is,enabled,but,executor,service,has,not,been,configured,this,if,log,is,trace,enabled,log,trace,scheduling,redelivery,task,to,run,in,millis,for,exchange,id,redelivery,delay,exchange,get,exchange,id,executor,service,schedule,reactive,helper,schedule,this,redeliver,redelivery,delay,time,unit,milliseconds,else,try,redelivery,sleep,counter,increment,and,get,boolean,complete,sleep,redelivery,sleep,counter,decrement,and,get,if,complete,exchange,set,exception,new,rejected,execution,exception,redelivery,not,allowed,while,stopping,exchange,set,property,exchange,boolean,true,reactive,helper,schedule,this,else,reactive,helper,schedule,this,redeliver,catch,interrupted,exception,e,redelivery,sleep,counter,decrement,and,get,exchange,set,exception,e,exchange,set,property,exchange,boolean,true,reactive,helper,callback,callback,else,reactive,helper,schedule,this,redeliver,else,output,async,process,exchange,done,sync,if,is,done,exchange,reactive,helper,callback,callback,else,reactive,helper,schedule,this
RedeliveryErrorHandler -> RedeliveryState -> protected void deliverToOnRedeliveryProcessor();1549264559;Gives an optional configured redelivery processor a chance to process before the Exchange_will be redelivered. This can be used to alter the Exchange.;protected void deliverToOnRedeliveryProcessor() {_            if (onRedeliveryProcessor == null) {_                return__            }__            if (log.isTraceEnabled()) {_                log.trace("Redelivery processor {} is processing Exchange: {} before its redelivered",_                        onRedeliveryProcessor, exchange)__            }__            _            try {_                onRedeliveryProcessor.process(exchange)__            } catch (Throwable e) {_                exchange.setException(e)__            }_            log.trace("Redelivery processor done")__        };gives,an,optional,configured,redelivery,processor,a,chance,to,process,before,the,exchange,will,be,redelivered,this,can,be,used,to,alter,the,exchange;protected,void,deliver,to,on,redelivery,processor,if,on,redelivery,processor,null,return,if,log,is,trace,enabled,log,trace,redelivery,processor,is,processing,exchange,before,its,redelivered,on,redelivery,processor,exchange,try,on,redelivery,processor,process,exchange,catch,throwable,e,exchange,set,exception,e,log,trace,redelivery,processor,done
RedeliveryErrorHandler -> RedeliveryState -> protected void deliverToOnRedeliveryProcessor();1549967797;Gives an optional configured redelivery processor a chance to process before the Exchange_will be redelivered. This can be used to alter the Exchange.;protected void deliverToOnRedeliveryProcessor() {_            if (onRedeliveryProcessor == null) {_                return__            }__            if (log.isTraceEnabled()) {_                log.trace("Redelivery processor {} is processing Exchange: {} before its redelivered",_                        onRedeliveryProcessor, exchange)__            }__            _            try {_                onRedeliveryProcessor.process(exchange)__            } catch (Throwable e) {_                exchange.setException(e)__            }_            log.trace("Redelivery processor done")__        };gives,an,optional,configured,redelivery,processor,a,chance,to,process,before,the,exchange,will,be,redelivered,this,can,be,used,to,alter,the,exchange;protected,void,deliver,to,on,redelivery,processor,if,on,redelivery,processor,null,return,if,log,is,trace,enabled,log,trace,redelivery,processor,is,processing,exchange,before,its,redelivered,on,redelivery,processor,exchange,try,on,redelivery,processor,process,exchange,catch,throwable,e,exchange,set,exception,e,log,trace,redelivery,processor,done
RedeliveryErrorHandler -> RedeliveryState -> protected void deliverToOnRedeliveryProcessor();1549968092;Gives an optional configured redelivery processor a chance to process before the Exchange_will be redelivered. This can be used to alter the Exchange.;protected void deliverToOnRedeliveryProcessor() {_            if (onRedeliveryProcessor == null) {_                return__            }__            if (log.isTraceEnabled()) {_                log.trace("Redelivery processor {} is processing Exchange: {} before its redelivered",_                        onRedeliveryProcessor, exchange)__            }__            _            try {_                onRedeliveryProcessor.process(exchange)__            } catch (Throwable e) {_                exchange.setException(e)__            }_            log.trace("Redelivery processor done")__        };gives,an,optional,configured,redelivery,processor,a,chance,to,process,before,the,exchange,will,be,redelivered,this,can,be,used,to,alter,the,exchange;protected,void,deliver,to,on,redelivery,processor,if,on,redelivery,processor,null,return,if,log,is,trace,enabled,log,trace,redelivery,processor,is,processing,exchange,before,its,redelivered,on,redelivery,processor,exchange,try,on,redelivery,processor,process,exchange,catch,throwable,e,exchange,set,exception,e,log,trace,redelivery,processor,done
RedeliveryErrorHandler -> RedeliveryState -> private boolean shouldHandle(Exchange exchange);1549264559;Determines whether or not to handle if we are exhausted.__@param exchange the current exchange_@return <tt>true</tt> to handle, or <tt>false</tt> to exhaust.;private boolean shouldHandle(Exchange exchange) {_            if (handledPredicate != null) {_                return handledPredicate.matches(exchange)__            }_            _            return false__        };determines,whether,or,not,to,handle,if,we,are,exhausted,param,exchange,the,current,exchange,return,tt,true,tt,to,handle,or,tt,false,tt,to,exhaust;private,boolean,should,handle,exchange,exchange,if,handled,predicate,null,return,handled,predicate,matches,exchange,return,false
RedeliveryErrorHandler -> RedeliveryState -> private boolean shouldHandle(Exchange exchange);1549967797;Determines whether or not to handle if we are exhausted.__@param exchange the current exchange_@return <tt>true</tt> to handle, or <tt>false</tt> to exhaust.;private boolean shouldHandle(Exchange exchange) {_            if (handledPredicate != null) {_                return handledPredicate.matches(exchange)__            }_            _            return false__        };determines,whether,or,not,to,handle,if,we,are,exhausted,param,exchange,the,current,exchange,return,tt,true,tt,to,handle,or,tt,false,tt,to,exhaust;private,boolean,should,handle,exchange,exchange,if,handled,predicate,null,return,handled,predicate,matches,exchange,return,false
RedeliveryErrorHandler -> RedeliveryState -> private boolean shouldHandle(Exchange exchange);1549968092;Determines whether or not to handle if we are exhausted.__@param exchange the current exchange_@return <tt>true</tt> to handle, or <tt>false</tt> to exhaust.;private boolean shouldHandle(Exchange exchange) {_            if (handledPredicate != null) {_                return handledPredicate.matches(exchange)__            }_            _            return false__        };determines,whether,or,not,to,handle,if,we,are,exhausted,param,exchange,the,current,exchange,return,tt,true,tt,to,handle,or,tt,false,tt,to,exhaust;private,boolean,should,handle,exchange,exchange,if,handled,predicate,null,return,handled,predicate,matches,exchange,return,false
RedeliveryErrorHandler -> public boolean process(final Exchange exchange, final AsyncCallback callback);1549264559;Process the exchange using redelivery error handling.;public boolean process(final Exchange exchange, final AsyncCallback callback) {_        _        RedeliveryState state = new RedeliveryState(exchange, callback)__        _        if (exchange.isTransacted()) {_            ReactiveHelper.scheduleSync(state)__        } else {_            ReactiveHelper.scheduleMain(state)__        }_        return false__    };process,the,exchange,using,redelivery,error,handling;public,boolean,process,final,exchange,exchange,final,async,callback,callback,redelivery,state,state,new,redelivery,state,exchange,callback,if,exchange,is,transacted,reactive,helper,schedule,sync,state,else,reactive,helper,schedule,main,state,return,false
RedeliveryErrorHandler -> public boolean process(final Exchange exchange, final AsyncCallback callback);1549967797;Process the exchange using redelivery error handling.;public boolean process(final Exchange exchange, final AsyncCallback callback) {_        _        RedeliveryState state = new RedeliveryState(exchange, callback)__        _        if (exchange.isTransacted()) {_            ReactiveHelper.scheduleSync(state)__        } else {_            ReactiveHelper.scheduleMain(state)__        }_        return false__    };process,the,exchange,using,redelivery,error,handling;public,boolean,process,final,exchange,exchange,final,async,callback,callback,redelivery,state,state,new,redelivery,state,exchange,callback,if,exchange,is,transacted,reactive,helper,schedule,sync,state,else,reactive,helper,schedule,main,state,return,false
RedeliveryErrorHandler -> public boolean process(final Exchange exchange, final AsyncCallback callback);1549968092;Process the exchange using redelivery error handling.;public boolean process(final Exchange exchange, final AsyncCallback callback) {_        _        RedeliveryState state = new RedeliveryState(exchange, callback)__        _        if (exchange.isTransacted()) {_            ReactiveHelper.scheduleSync(state)__        } else {_            ReactiveHelper.scheduleMain(state)__        }_        return false__    };process,the,exchange,using,redelivery,error,handling;public,boolean,process,final,exchange,exchange,final,async,callback,callback,redelivery,state,state,new,redelivery,state,exchange,callback,if,exchange,is,transacted,reactive,helper,schedule,sync,state,else,reactive,helper,schedule,main,state,return,false
RedeliveryErrorHandler -> public void changeOutput(Processor output);1549264559;Allows to change the output of the error handler which are used when optimising the_JMX instrumentation to use either an advice or wrapped processor when calling a processor._The former is faster and therefore preferred, however if the error handler supports_redelivery we need fine grained instrumentation which then must be wrapped and therefore_need to change the output on the error handler.;public void changeOutput(Processor output) {_        this.output = output__        this.outputAsync = AsyncProcessorConverterHelper.convert(output)__    };allows,to,change,the,output,of,the,error,handler,which,are,used,when,optimising,the,jmx,instrumentation,to,use,either,an,advice,or,wrapped,processor,when,calling,a,processor,the,former,is,faster,and,therefore,preferred,however,if,the,error,handler,supports,redelivery,we,need,fine,grained,instrumentation,which,then,must,be,wrapped,and,therefore,need,to,change,the,output,on,the,error,handler;public,void,change,output,processor,output,this,output,output,this,output,async,async,processor,converter,helper,convert,output
RedeliveryErrorHandler -> public void changeOutput(Processor output);1549967797;Allows to change the output of the error handler which are used when optimising the_JMX instrumentation to use either an advice or wrapped processor when calling a processor._The former is faster and therefore preferred, however if the error handler supports_redelivery we need fine grained instrumentation which then must be wrapped and therefore_need to change the output on the error handler.;public void changeOutput(Processor output) {_        this.output = output__        this.outputAsync = AsyncProcessorConverterHelper.convert(output)__    };allows,to,change,the,output,of,the,error,handler,which,are,used,when,optimising,the,jmx,instrumentation,to,use,either,an,advice,or,wrapped,processor,when,calling,a,processor,the,former,is,faster,and,therefore,preferred,however,if,the,error,handler,supports,redelivery,we,need,fine,grained,instrumentation,which,then,must,be,wrapped,and,therefore,need,to,change,the,output,on,the,error,handler;public,void,change,output,processor,output,this,output,output,this,output,async,async,processor,converter,helper,convert,output
RedeliveryErrorHandler -> public void changeOutput(Processor output);1549968092;Allows to change the output of the error handler which are used when optimising the_JMX instrumentation to use either an advice or wrapped processor when calling a processor._The former is faster and therefore preferred, however if the error handler supports_redelivery we need fine grained instrumentation which then must be wrapped and therefore_need to change the output on the error handler.;public void changeOutput(Processor output) {_        this.output = output__        this.outputAsync = AsyncProcessorConverterHelper.convert(output)__    };allows,to,change,the,output,of,the,error,handler,which,are,used,when,optimising,the,jmx,instrumentation,to,use,either,an,advice,or,wrapped,processor,when,calling,a,processor,the,former,is,faster,and,therefore,preferred,however,if,the,error,handler,supports,redelivery,we,need,fine,grained,instrumentation,which,then,must,be,wrapped,and,therefore,need,to,change,the,output,on,the,error,handler;public,void,change,output,processor,output,this,output,output,this,output,async,async,processor,converter,helper,convert,output
RedeliveryErrorHandler -> public int getPendingRedeliveryCount();1549264559;Gets the number of exchanges that are pending for redelivery;public int getPendingRedeliveryCount() {_        int answer = redeliverySleepCounter.get()__        if (executorService instanceof ThreadPoolExecutor) {_            answer += ((ThreadPoolExecutor) executorService).getQueue().size()__        }__        return answer__    };gets,the,number,of,exchanges,that,are,pending,for,redelivery;public,int,get,pending,redelivery,count,int,answer,redelivery,sleep,counter,get,if,executor,service,instanceof,thread,pool,executor,answer,thread,pool,executor,executor,service,get,queue,size,return,answer
RedeliveryErrorHandler -> public int getPendingRedeliveryCount();1549967797;Gets the number of exchanges that are pending for redelivery;public int getPendingRedeliveryCount() {_        int answer = redeliverySleepCounter.get()__        if (executorService instanceof ThreadPoolExecutor) {_            answer += ((ThreadPoolExecutor) executorService).getQueue().size()__        }__        return answer__    };gets,the,number,of,exchanges,that,are,pending,for,redelivery;public,int,get,pending,redelivery,count,int,answer,redelivery,sleep,counter,get,if,executor,service,instanceof,thread,pool,executor,answer,thread,pool,executor,executor,service,get,queue,size,return,answer
RedeliveryErrorHandler -> public int getPendingRedeliveryCount();1549968092;Gets the number of exchanges that are pending for redelivery;public int getPendingRedeliveryCount() {_        int answer = redeliverySleepCounter.get()__        if (executorService instanceof ThreadPoolExecutor) {_            answer += ((ThreadPoolExecutor) executorService).getQueue().size()__        }__        return answer__    };gets,the,number,of,exchanges,that,are,pending,for,redelivery;public,int,get,pending,redelivery,count,int,answer,redelivery,sleep,counter,get,if,executor,service,instanceof,thread,pool,executor,answer,thread,pool,executor,executor,service,get,queue,size,return,answer
RedeliveryErrorHandler -> protected long determineRedeliveryDelay(Exchange exchange, RedeliveryPolicy redeliveryPolicy, long redeliveryDelay, int redeliveryCounter);1549264559;<p>Determines the redelivery delay time by first inspecting the Message header {@link Exchange#REDELIVERY_DELAY}_and if not present, defaulting to {@link RedeliveryPolicy#calculateRedeliveryDelay(long, int)}</p>__<p>In order to prevent manipulation of the RedeliveryData state, the values of {@link RedeliveryState#redeliveryDelay}_and {@link RedeliveryState#redeliveryCounter} are copied in.</p>__@param exchange The current exchange in question._@param redeliveryPolicy The RedeliveryPolicy to use in the calculation._@param redeliveryDelay The default redelivery delay from RedeliveryData_@param redeliveryCounter The redeliveryCounter_@return The time to wait before the next redelivery.;protected long determineRedeliveryDelay(Exchange exchange, RedeliveryPolicy redeliveryPolicy, long redeliveryDelay, int redeliveryCounter) {_        Message message = exchange.getIn()__        Long delay = message.getHeader(Exchange.REDELIVERY_DELAY, Long.class)__        if (delay == null) {_            delay = redeliveryPolicy.calculateRedeliveryDelay(redeliveryDelay, redeliveryCounter)__            log.debug("Redelivery delay calculated as {}", delay)__        } else {_            log.debug("Redelivery delay is {} from Message Header [{}]", delay, Exchange.REDELIVERY_DELAY)__        }_        return delay__    };p,determines,the,redelivery,delay,time,by,first,inspecting,the,message,header,link,exchange,and,if,not,present,defaulting,to,link,redelivery,policy,calculate,redelivery,delay,long,int,p,p,in,order,to,prevent,manipulation,of,the,redelivery,data,state,the,values,of,link,redelivery,state,redelivery,delay,and,link,redelivery,state,redelivery,counter,are,copied,in,p,param,exchange,the,current,exchange,in,question,param,redelivery,policy,the,redelivery,policy,to,use,in,the,calculation,param,redelivery,delay,the,default,redelivery,delay,from,redelivery,data,param,redelivery,counter,the,redelivery,counter,return,the,time,to,wait,before,the,next,redelivery;protected,long,determine,redelivery,delay,exchange,exchange,redelivery,policy,redelivery,policy,long,redelivery,delay,int,redelivery,counter,message,message,exchange,get,in,long,delay,message,get,header,exchange,long,class,if,delay,null,delay,redelivery,policy,calculate,redelivery,delay,redelivery,delay,redelivery,counter,log,debug,redelivery,delay,calculated,as,delay,else,log,debug,redelivery,delay,is,from,message,header,delay,exchange,return,delay
RedeliveryErrorHandler -> protected long determineRedeliveryDelay(Exchange exchange, RedeliveryPolicy redeliveryPolicy, long redeliveryDelay, int redeliveryCounter);1549967797;<p>Determines the redelivery delay time by first inspecting the Message header {@link Exchange#REDELIVERY_DELAY}_and if not present, defaulting to {@link RedeliveryPolicy#calculateRedeliveryDelay(long, int)}</p>__<p>In order to prevent manipulation of the RedeliveryData state, the values of {@link RedeliveryState#redeliveryDelay}_and {@link RedeliveryState#redeliveryCounter} are copied in.</p>__@param exchange The current exchange in question._@param redeliveryPolicy The RedeliveryPolicy to use in the calculation._@param redeliveryDelay The default redelivery delay from RedeliveryData_@param redeliveryCounter The redeliveryCounter_@return The time to wait before the next redelivery.;protected long determineRedeliveryDelay(Exchange exchange, RedeliveryPolicy redeliveryPolicy, long redeliveryDelay, int redeliveryCounter) {_        Message message = exchange.getIn()__        Long delay = message.getHeader(Exchange.REDELIVERY_DELAY, Long.class)__        if (delay == null) {_            delay = redeliveryPolicy.calculateRedeliveryDelay(redeliveryDelay, redeliveryCounter)__            log.debug("Redelivery delay calculated as {}", delay)__        } else {_            log.debug("Redelivery delay is {} from Message Header [{}]", delay, Exchange.REDELIVERY_DELAY)__        }_        return delay__    };p,determines,the,redelivery,delay,time,by,first,inspecting,the,message,header,link,exchange,and,if,not,present,defaulting,to,link,redelivery,policy,calculate,redelivery,delay,long,int,p,p,in,order,to,prevent,manipulation,of,the,redelivery,data,state,the,values,of,link,redelivery,state,redelivery,delay,and,link,redelivery,state,redelivery,counter,are,copied,in,p,param,exchange,the,current,exchange,in,question,param,redelivery,policy,the,redelivery,policy,to,use,in,the,calculation,param,redelivery,delay,the,default,redelivery,delay,from,redelivery,data,param,redelivery,counter,the,redelivery,counter,return,the,time,to,wait,before,the,next,redelivery;protected,long,determine,redelivery,delay,exchange,exchange,redelivery,policy,redelivery,policy,long,redelivery,delay,int,redelivery,counter,message,message,exchange,get,in,long,delay,message,get,header,exchange,long,class,if,delay,null,delay,redelivery,policy,calculate,redelivery,delay,redelivery,delay,redelivery,counter,log,debug,redelivery,delay,calculated,as,delay,else,log,debug,redelivery,delay,is,from,message,header,delay,exchange,return,delay
RedeliveryErrorHandler -> protected long determineRedeliveryDelay(Exchange exchange, RedeliveryPolicy redeliveryPolicy, long redeliveryDelay, int redeliveryCounter);1549968092;<p>Determines the redelivery delay time by first inspecting the Message header {@link Exchange#REDELIVERY_DELAY}_and if not present, defaulting to {@link RedeliveryPolicy#calculateRedeliveryDelay(long, int)}</p>__<p>In order to prevent manipulation of the RedeliveryData state, the values of {@link RedeliveryState#redeliveryDelay}_and {@link RedeliveryState#redeliveryCounter} are copied in.</p>__@param exchange The current exchange in question._@param redeliveryPolicy The RedeliveryPolicy to use in the calculation._@param redeliveryDelay The default redelivery delay from RedeliveryData_@param redeliveryCounter The redeliveryCounter_@return The time to wait before the next redelivery.;protected long determineRedeliveryDelay(Exchange exchange, RedeliveryPolicy redeliveryPolicy, long redeliveryDelay, int redeliveryCounter) {_        Message message = exchange.getIn()__        Long delay = message.getHeader(Exchange.REDELIVERY_DELAY, Long.class)__        if (delay == null) {_            delay = redeliveryPolicy.calculateRedeliveryDelay(redeliveryDelay, redeliveryCounter)__            log.debug("Redelivery delay calculated as {}", delay)__        } else {_            log.debug("Redelivery delay is {} from Message Header [{}]", delay, Exchange.REDELIVERY_DELAY)__        }_        return delay__    };p,determines,the,redelivery,delay,time,by,first,inspecting,the,message,header,link,exchange,and,if,not,present,defaulting,to,link,redelivery,policy,calculate,redelivery,delay,long,int,p,p,in,order,to,prevent,manipulation,of,the,redelivery,data,state,the,values,of,link,redelivery,state,redelivery,delay,and,link,redelivery,state,redelivery,counter,are,copied,in,p,param,exchange,the,current,exchange,in,question,param,redelivery,policy,the,redelivery,policy,to,use,in,the,calculation,param,redelivery,delay,the,default,redelivery,delay,from,redelivery,data,param,redelivery,counter,the,redelivery,counter,return,the,time,to,wait,before,the,next,redelivery;protected,long,determine,redelivery,delay,exchange,exchange,redelivery,policy,redelivery,policy,long,redelivery,delay,int,redelivery,counter,message,message,exchange,get,in,long,delay,message,get,header,exchange,long,class,if,delay,null,delay,redelivery,policy,calculate,redelivery,delay,redelivery,delay,redelivery,counter,log,debug,redelivery,delay,calculated,as,delay,else,log,debug,redelivery,delay,is,from,message,header,delay,exchange,return,delay
RedeliveryErrorHandler -> protected Exchange defensiveCopyExchangeIfNeeded(Exchange exchange);1549264559;Performs a defensive copy of the exchange if needed__@param exchange the exchange_@return the defensive copy, or <tt>null</tt> if not needed (redelivery is not enabled).;protected Exchange defensiveCopyExchangeIfNeeded(Exchange exchange) {_        _        if (redeliveryEnabled) {_            return ExchangeHelper.createCopy(exchange, true)__        } else {_            return null__        }_    };performs,a,defensive,copy,of,the,exchange,if,needed,param,exchange,the,exchange,return,the,defensive,copy,or,tt,null,tt,if,not,needed,redelivery,is,not,enabled;protected,exchange,defensive,copy,exchange,if,needed,exchange,exchange,if,redelivery,enabled,return,exchange,helper,create,copy,exchange,true,else,return,null
RedeliveryErrorHandler -> protected Exchange defensiveCopyExchangeIfNeeded(Exchange exchange);1549967797;Performs a defensive copy of the exchange if needed__@param exchange the exchange_@return the defensive copy, or <tt>null</tt> if not needed (redelivery is not enabled).;protected Exchange defensiveCopyExchangeIfNeeded(Exchange exchange) {_        _        if (redeliveryEnabled) {_            return ExchangeHelper.createCopy(exchange, true)__        } else {_            return null__        }_    };performs,a,defensive,copy,of,the,exchange,if,needed,param,exchange,the,exchange,return,the,defensive,copy,or,tt,null,tt,if,not,needed,redelivery,is,not,enabled;protected,exchange,defensive,copy,exchange,if,needed,exchange,exchange,if,redelivery,enabled,return,exchange,helper,create,copy,exchange,true,else,return,null
RedeliveryErrorHandler -> protected Exchange defensiveCopyExchangeIfNeeded(Exchange exchange);1549968092;Performs a defensive copy of the exchange if needed__@param exchange the exchange_@return the defensive copy, or <tt>null</tt> if not needed (redelivery is not enabled).;protected Exchange defensiveCopyExchangeIfNeeded(Exchange exchange) {_        _        if (redeliveryEnabled) {_            return ExchangeHelper.createCopy(exchange, true)__        } else {_            return null__        }_    };performs,a,defensive,copy,of,the,exchange,if,needed,param,exchange,the,exchange,return,the,defensive,copy,or,tt,null,tt,if,not,needed,redelivery,is,not,enabled;protected,exchange,defensive,copy,exchange,if,needed,exchange,exchange,if,redelivery,enabled,return,exchange,helper,create,copy,exchange,true,else,return,null
RedeliveryErrorHandler -> public boolean determineIfRedeliveryIsEnabled() throws Exception;1549264559;Determines if redelivery is enabled by checking if any of the redelivery policy_settings may allow redeliveries.__@return <tt>true</tt> if redelivery is possible, <tt>false</tt> otherwise_@throws Exception can be thrown;public boolean determineIfRedeliveryIsEnabled() throws Exception {_        _        if (getRedeliveryPolicy().getMaximumRedeliveries() != 0) {_            _            return true__        }_        if (retryWhilePolicy != null) {_            return true__        }__        _        if (!exceptionPolicies.isEmpty()) {_            _            for (OnExceptionDefinition def : exceptionPolicies.values()) {__                String ref = def.getRedeliveryPolicyRef()__                if (ref != null) {_                    _                    RedeliveryPolicy policy = CamelContextHelper.mandatoryLookup(camelContext, ref, RedeliveryPolicy.class)__                    if (policy.getMaximumRedeliveries() != 0) {_                        _                        return true__                    }_                } else if (def.getRedeliveryPolicyType() != null) {_                    Integer max = CamelContextHelper.parseInteger(camelContext, def.getRedeliveryPolicyType().getMaximumRedeliveries())__                    if (max != null && max != 0) {_                        _                        return true__                    }_                }__                if (def.getRetryWhilePolicy() != null || def.getRetryWhile() != null) {_                    return true__                }_            }_        }__        return false__    };determines,if,redelivery,is,enabled,by,checking,if,any,of,the,redelivery,policy,settings,may,allow,redeliveries,return,tt,true,tt,if,redelivery,is,possible,tt,false,tt,otherwise,throws,exception,can,be,thrown;public,boolean,determine,if,redelivery,is,enabled,throws,exception,if,get,redelivery,policy,get,maximum,redeliveries,0,return,true,if,retry,while,policy,null,return,true,if,exception,policies,is,empty,for,on,exception,definition,def,exception,policies,values,string,ref,def,get,redelivery,policy,ref,if,ref,null,redelivery,policy,policy,camel,context,helper,mandatory,lookup,camel,context,ref,redelivery,policy,class,if,policy,get,maximum,redeliveries,0,return,true,else,if,def,get,redelivery,policy,type,null,integer,max,camel,context,helper,parse,integer,camel,context,def,get,redelivery,policy,type,get,maximum,redeliveries,if,max,null,max,0,return,true,if,def,get,retry,while,policy,null,def,get,retry,while,null,return,true,return,false
RedeliveryErrorHandler -> public boolean determineIfRedeliveryIsEnabled() throws Exception;1549967797;Determines if redelivery is enabled by checking if any of the redelivery policy_settings may allow redeliveries.__@return <tt>true</tt> if redelivery is possible, <tt>false</tt> otherwise_@throws Exception can be thrown;public boolean determineIfRedeliveryIsEnabled() throws Exception {_        _        if (getRedeliveryPolicy().getMaximumRedeliveries() != 0) {_            _            return true__        }_        if (retryWhilePolicy != null) {_            return true__        }__        _        if (!exceptionPolicies.isEmpty()) {_            _            for (OnExceptionDefinition def : exceptionPolicies.values()) {__                String ref = def.getRedeliveryPolicyRef()__                if (ref != null) {_                    _                    RedeliveryPolicy policy = CamelContextHelper.mandatoryLookup(camelContext, ref, RedeliveryPolicy.class)__                    if (policy.getMaximumRedeliveries() != 0) {_                        _                        return true__                    }_                } else if (def.getRedeliveryPolicyType() != null) {_                    Integer max = CamelContextHelper.parseInteger(camelContext, def.getRedeliveryPolicyType().getMaximumRedeliveries())__                    if (max != null && max != 0) {_                        _                        return true__                    }_                }__                if (def.getRetryWhilePolicy() != null || def.getRetryWhile() != null) {_                    return true__                }_            }_        }__        return false__    };determines,if,redelivery,is,enabled,by,checking,if,any,of,the,redelivery,policy,settings,may,allow,redeliveries,return,tt,true,tt,if,redelivery,is,possible,tt,false,tt,otherwise,throws,exception,can,be,thrown;public,boolean,determine,if,redelivery,is,enabled,throws,exception,if,get,redelivery,policy,get,maximum,redeliveries,0,return,true,if,retry,while,policy,null,return,true,if,exception,policies,is,empty,for,on,exception,definition,def,exception,policies,values,string,ref,def,get,redelivery,policy,ref,if,ref,null,redelivery,policy,policy,camel,context,helper,mandatory,lookup,camel,context,ref,redelivery,policy,class,if,policy,get,maximum,redeliveries,0,return,true,else,if,def,get,redelivery,policy,type,null,integer,max,camel,context,helper,parse,integer,camel,context,def,get,redelivery,policy,type,get,maximum,redeliveries,if,max,null,max,0,return,true,if,def,get,retry,while,policy,null,def,get,retry,while,null,return,true,return,false
RedeliveryErrorHandler -> public boolean determineIfRedeliveryIsEnabled() throws Exception;1549968092;Determines if redelivery is enabled by checking if any of the redelivery policy_settings may allow redeliveries.__@return <tt>true</tt> if redelivery is possible, <tt>false</tt> otherwise_@throws Exception can be thrown;public boolean determineIfRedeliveryIsEnabled() throws Exception {_        _        if (getRedeliveryPolicy().getMaximumRedeliveries() != 0) {_            _            return true__        }_        if (retryWhilePolicy != null) {_            return true__        }__        _        if (!exceptionPolicies.isEmpty()) {_            _            for (OnExceptionDefinition def : exceptionPolicies.values()) {__                String ref = def.getRedeliveryPolicyRef()__                if (ref != null) {_                    _                    RedeliveryPolicy policy = CamelContextHelper.mandatoryLookup(camelContext, ref, RedeliveryPolicy.class)__                    if (policy.getMaximumRedeliveries() != 0) {_                        _                        return true__                    }_                } else if (def.getRedeliveryPolicyType() != null) {_                    Integer max = CamelContextHelper.parseInteger(camelContext, def.getRedeliveryPolicyType().getMaximumRedeliveries())__                    if (max != null && max != 0) {_                        _                        return true__                    }_                }__                if (def.getRetryWhilePolicy() != null || def.getRetryWhile() != null) {_                    return true__                }_            }_        }__        return false__    };determines,if,redelivery,is,enabled,by,checking,if,any,of,the,redelivery,policy,settings,may,allow,redeliveries,return,tt,true,tt,if,redelivery,is,possible,tt,false,tt,otherwise,throws,exception,can,be,thrown;public,boolean,determine,if,redelivery,is,enabled,throws,exception,if,get,redelivery,policy,get,maximum,redeliveries,0,return,true,if,retry,while,policy,null,return,true,if,exception,policies,is,empty,for,on,exception,definition,def,exception,policies,values,string,ref,def,get,redelivery,policy,ref,if,ref,null,redelivery,policy,policy,camel,context,helper,mandatory,lookup,camel,context,ref,redelivery,policy,class,if,policy,get,maximum,redeliveries,0,return,true,else,if,def,get,redelivery,policy,type,null,integer,max,camel,context,helper,parse,integer,camel,context,def,get,redelivery,policy,type,get,maximum,redeliveries,if,max,null,max,0,return,true,if,def,get,retry,while,policy,null,def,get,retry,while,null,return,true,return,false
RedeliveryErrorHandler -> protected boolean shouldHandleException(Exchange exchange);1549264559;Strategy whether the exchange has an exception that we should try to handle._<p/>_Standard implementations should just look for an exception.;protected boolean shouldHandleException(Exchange exchange) {_        return exchange.getException() != null__    };strategy,whether,the,exchange,has,an,exception,that,we,should,try,to,handle,p,standard,implementations,should,just,look,for,an,exception;protected,boolean,should,handle,exception,exchange,exchange,return,exchange,get,exception,null
RedeliveryErrorHandler -> protected boolean shouldHandleException(Exchange exchange);1549967797;Strategy whether the exchange has an exception that we should try to handle._<p/>_Standard implementations should just look for an exception.;protected boolean shouldHandleException(Exchange exchange) {_        return exchange.getException() != null__    };strategy,whether,the,exchange,has,an,exception,that,we,should,try,to,handle,p,standard,implementations,should,just,look,for,an,exception;protected,boolean,should,handle,exception,exchange,exchange,return,exchange,get,exception,null
RedeliveryErrorHandler -> protected boolean shouldHandleException(Exchange exchange);1549968092;Strategy whether the exchange has an exception that we should try to handle._<p/>_Standard implementations should just look for an exception.;protected boolean shouldHandleException(Exchange exchange) {_        return exchange.getException() != null__    };strategy,whether,the,exchange,has,an,exception,that,we,should,try,to,handle,p,standard,implementations,should,just,look,for,an,exception;protected,boolean,should,handle,exception,exchange,exchange,return,exchange,get,exception,null
RedeliveryErrorHandler -> RedeliveryState -> private boolean shouldContinue(Exchange exchange);1549264559;Determines whether or not to continue if we are exhausted.__@param exchange the current exchange_@return <tt>true</tt> to continue, or <tt>false</tt> to exhaust.;private boolean shouldContinue(Exchange exchange) {_            if (continuedPredicate != null) {_                return continuedPredicate.matches(exchange)__            }_            _            return false__        };determines,whether,or,not,to,continue,if,we,are,exhausted,param,exchange,the,current,exchange,return,tt,true,tt,to,continue,or,tt,false,tt,to,exhaust;private,boolean,should,continue,exchange,exchange,if,continued,predicate,null,return,continued,predicate,matches,exchange,return,false
RedeliveryErrorHandler -> RedeliveryState -> private boolean shouldContinue(Exchange exchange);1549967797;Determines whether or not to continue if we are exhausted.__@param exchange the current exchange_@return <tt>true</tt> to continue, or <tt>false</tt> to exhaust.;private boolean shouldContinue(Exchange exchange) {_            if (continuedPredicate != null) {_                return continuedPredicate.matches(exchange)__            }_            _            return false__        };determines,whether,or,not,to,continue,if,we,are,exhausted,param,exchange,the,current,exchange,return,tt,true,tt,to,continue,or,tt,false,tt,to,exhaust;private,boolean,should,continue,exchange,exchange,if,continued,predicate,null,return,continued,predicate,matches,exchange,return,false
RedeliveryErrorHandler -> RedeliveryState -> private boolean shouldContinue(Exchange exchange);1549968092;Determines whether or not to continue if we are exhausted.__@param exchange the current exchange_@return <tt>true</tt> to continue, or <tt>false</tt> to exhaust.;private boolean shouldContinue(Exchange exchange) {_            if (continuedPredicate != null) {_                return continuedPredicate.matches(exchange)__            }_            _            return false__        };determines,whether,or,not,to,continue,if,we,are,exhausted,param,exchange,the,current,exchange,return,tt,true,tt,to,continue,or,tt,false,tt,to,exhaust;private,boolean,should,continue,exchange,exchange,if,continued,predicate,null,return,continued,predicate,matches,exchange,return,false
RedeliveryErrorHandler -> private void decrementRedeliveryCounter(Exchange exchange);1549264559;Prepares the redelivery counter and boolean flag for the failure handle processor;private void decrementRedeliveryCounter(Exchange exchange) {_        Message in = exchange.getIn()__        Integer counter = in.getHeader(Exchange.REDELIVERY_COUNTER, Integer.class)__        if (counter != null) {_            int prev = counter - 1__            in.setHeader(Exchange.REDELIVERY_COUNTER, prev)__            _            in.setHeader(Exchange.REDELIVERED, prev > 0 ? Boolean.TRUE : Boolean.FALSE)__        } else {_            _            in.setHeader(Exchange.REDELIVERY_COUNTER, 0)__            in.setHeader(Exchange.REDELIVERED, Boolean.FALSE)__        }_    };prepares,the,redelivery,counter,and,boolean,flag,for,the,failure,handle,processor;private,void,decrement,redelivery,counter,exchange,exchange,message,in,exchange,get,in,integer,counter,in,get,header,exchange,integer,class,if,counter,null,int,prev,counter,1,in,set,header,exchange,prev,in,set,header,exchange,redelivered,prev,0,boolean,true,boolean,false,else,in,set,header,exchange,0,in,set,header,exchange,redelivered,boolean,false
RedeliveryErrorHandler -> private void decrementRedeliveryCounter(Exchange exchange);1549967797;Prepares the redelivery counter and boolean flag for the failure handle processor;private void decrementRedeliveryCounter(Exchange exchange) {_        Message in = exchange.getIn()__        Integer counter = in.getHeader(Exchange.REDELIVERY_COUNTER, Integer.class)__        if (counter != null) {_            int prev = counter - 1__            in.setHeader(Exchange.REDELIVERY_COUNTER, prev)__            _            in.setHeader(Exchange.REDELIVERED, prev > 0 ? Boolean.TRUE : Boolean.FALSE)__        } else {_            _            in.setHeader(Exchange.REDELIVERY_COUNTER, 0)__            in.setHeader(Exchange.REDELIVERED, Boolean.FALSE)__        }_    };prepares,the,redelivery,counter,and,boolean,flag,for,the,failure,handle,processor;private,void,decrement,redelivery,counter,exchange,exchange,message,in,exchange,get,in,integer,counter,in,get,header,exchange,integer,class,if,counter,null,int,prev,counter,1,in,set,header,exchange,prev,in,set,header,exchange,redelivered,prev,0,boolean,true,boolean,false,else,in,set,header,exchange,0,in,set,header,exchange,redelivered,boolean,false
RedeliveryErrorHandler -> private void decrementRedeliveryCounter(Exchange exchange);1549968092;Prepares the redelivery counter and boolean flag for the failure handle processor;private void decrementRedeliveryCounter(Exchange exchange) {_        Message in = exchange.getIn()__        Integer counter = in.getHeader(Exchange.REDELIVERY_COUNTER, Integer.class)__        if (counter != null) {_            int prev = counter - 1__            in.setHeader(Exchange.REDELIVERY_COUNTER, prev)__            _            in.setHeader(Exchange.REDELIVERED, prev > 0 ? Boolean.TRUE : Boolean.FALSE)__        } else {_            _            in.setHeader(Exchange.REDELIVERY_COUNTER, 0)__            in.setHeader(Exchange.REDELIVERED, Boolean.FALSE)__        }_    };prepares,the,redelivery,counter,and,boolean,flag,for,the,failure,handle,processor;private,void,decrement,redelivery,counter,exchange,exchange,message,in,exchange,get,in,integer,counter,in,get,header,exchange,integer,class,if,counter,null,int,prev,counter,1,in,set,header,exchange,prev,in,set,header,exchange,redelivered,prev,0,boolean,true,boolean,false,else,in,set,header,exchange,0,in,set,header,exchange,redelivered,boolean,false
RedeliveryErrorHandler -> protected boolean isDone(Exchange exchange);1549264559;Strategy to determine if the exchange is done so we can continue;protected boolean isDone(Exchange exchange) {_        boolean answer = isCancelledOrInterrupted(exchange)___        _        _        _        if (!answer) {_            answer = exchange.getException() == null_                || ExchangeHelper.isFailureHandled(exchange)_                || ExchangeHelper.isRedeliveryExhausted(exchange)__        }__        log.trace("Is exchangeId: {} done? {}", exchange.getExchangeId(), answer)__        return answer__    };strategy,to,determine,if,the,exchange,is,done,so,we,can,continue;protected,boolean,is,done,exchange,exchange,boolean,answer,is,cancelled,or,interrupted,exchange,if,answer,answer,exchange,get,exception,null,exchange,helper,is,failure,handled,exchange,exchange,helper,is,redelivery,exhausted,exchange,log,trace,is,exchange,id,done,exchange,get,exchange,id,answer,return,answer
RedeliveryErrorHandler -> protected boolean isDone(Exchange exchange);1549967797;Strategy to determine if the exchange is done so we can continue;protected boolean isDone(Exchange exchange) {_        boolean answer = isCancelledOrInterrupted(exchange)___        _        _        _        if (!answer) {_            answer = exchange.getException() == null_                || ExchangeHelper.isFailureHandled(exchange)_                || ExchangeHelper.isRedeliveryExhausted(exchange)__        }__        log.trace("Is exchangeId: {} done? {}", exchange.getExchangeId(), answer)__        return answer__    };strategy,to,determine,if,the,exchange,is,done,so,we,can,continue;protected,boolean,is,done,exchange,exchange,boolean,answer,is,cancelled,or,interrupted,exchange,if,answer,answer,exchange,get,exception,null,exchange,helper,is,failure,handled,exchange,exchange,helper,is,redelivery,exhausted,exchange,log,trace,is,exchange,id,done,exchange,get,exchange,id,answer,return,answer
RedeliveryErrorHandler -> protected boolean isDone(Exchange exchange);1549968092;Strategy to determine if the exchange is done so we can continue;protected boolean isDone(Exchange exchange) {_        boolean answer = isCancelledOrInterrupted(exchange)___        _        _        _        if (!answer) {_            answer = exchange.getException() == null_                || ExchangeHelper.isFailureHandled(exchange)_                || ExchangeHelper.isRedeliveryExhausted(exchange)__        }__        log.trace("Is exchangeId: {} done? {}", exchange.getExchangeId(), answer)__        return answer__    };strategy,to,determine,if,the,exchange,is,done,so,we,can,continue;protected,boolean,is,done,exchange,exchange,boolean,answer,is,cancelled,or,interrupted,exchange,if,answer,answer,exchange,get,exception,null,exchange,helper,is,failure,handled,exchange,exchange,helper,is,redelivery,exhausted,exchange,log,trace,is,exchange,id,done,exchange,get,exchange,id,answer,return,answer
RedeliveryErrorHandler -> RedeliveryState -> protected void onExceptionOccurred();1549264559;Gives an optional configured OnExceptionOccurred processor a chance to process just after an exception_was thrown while processing the Exchange. This allows to execute the processor at the same time the exception was thrown.;protected void onExceptionOccurred() {_            if (onExceptionProcessor == null) {_                return__            }__            _            try {_                if (log.isTraceEnabled()) {_                    log.trace("OnExceptionOccurred processor {} is processing Exchange: {} due exception occurred", onExceptionProcessor, exchange)__                }_                onExceptionProcessor.process(exchange)__            } catch (Throwable e) {_                _                log.warn("Error during processing OnExceptionOccurred. This exception is ignored.", e)__            }_            log.trace("OnExceptionOccurred processor done")__        };gives,an,optional,configured,on,exception,occurred,processor,a,chance,to,process,just,after,an,exception,was,thrown,while,processing,the,exchange,this,allows,to,execute,the,processor,at,the,same,time,the,exception,was,thrown;protected,void,on,exception,occurred,if,on,exception,processor,null,return,try,if,log,is,trace,enabled,log,trace,on,exception,occurred,processor,is,processing,exchange,due,exception,occurred,on,exception,processor,exchange,on,exception,processor,process,exchange,catch,throwable,e,log,warn,error,during,processing,on,exception,occurred,this,exception,is,ignored,e,log,trace,on,exception,occurred,processor,done
RedeliveryErrorHandler -> RedeliveryState -> protected void onExceptionOccurred();1549967797;Gives an optional configured OnExceptionOccurred processor a chance to process just after an exception_was thrown while processing the Exchange. This allows to execute the processor at the same time the exception was thrown.;protected void onExceptionOccurred() {_            if (onExceptionProcessor == null) {_                return__            }__            _            try {_                if (log.isTraceEnabled()) {_                    log.trace("OnExceptionOccurred processor {} is processing Exchange: {} due exception occurred", onExceptionProcessor, exchange)__                }_                onExceptionProcessor.process(exchange)__            } catch (Throwable e) {_                _                log.warn("Error during processing OnExceptionOccurred. This exception is ignored.", e)__            }_            log.trace("OnExceptionOccurred processor done")__        };gives,an,optional,configured,on,exception,occurred,processor,a,chance,to,process,just,after,an,exception,was,thrown,while,processing,the,exchange,this,allows,to,execute,the,processor,at,the,same,time,the,exception,was,thrown;protected,void,on,exception,occurred,if,on,exception,processor,null,return,try,if,log,is,trace,enabled,log,trace,on,exception,occurred,processor,is,processing,exchange,due,exception,occurred,on,exception,processor,exchange,on,exception,processor,process,exchange,catch,throwable,e,log,warn,error,during,processing,on,exception,occurred,this,exception,is,ignored,e,log,trace,on,exception,occurred,processor,done
RedeliveryErrorHandler -> RedeliveryState -> protected void onExceptionOccurred();1549968092;Gives an optional configured OnExceptionOccurred processor a chance to process just after an exception_was thrown while processing the Exchange. This allows to execute the processor at the same time the exception was thrown.;protected void onExceptionOccurred() {_            if (onExceptionProcessor == null) {_                return__            }__            _            try {_                if (log.isTraceEnabled()) {_                    log.trace("OnExceptionOccurred processor {} is processing Exchange: {} due exception occurred", onExceptionProcessor, exchange)__                }_                onExceptionProcessor.process(exchange)__            } catch (Throwable e) {_                _                log.warn("Error during processing OnExceptionOccurred. This exception is ignored.", e)__            }_            log.trace("OnExceptionOccurred processor done")__        };gives,an,optional,configured,on,exception,occurred,processor,a,chance,to,process,just,after,an,exception,was,thrown,while,processing,the,exchange,this,allows,to,execute,the,processor,at,the,same,time,the,exception,was,thrown;protected,void,on,exception,occurred,if,on,exception,processor,null,return,try,if,log,is,trace,enabled,log,trace,on,exception,occurred,processor,is,processing,exchange,due,exception,occurred,on,exception,processor,exchange,on,exception,processor,process,exchange,catch,throwable,e,log,warn,error,during,processing,on,exception,occurred,this,exception,is,ignored,e,log,trace,on,exception,occurred,processor,done
RedeliveryErrorHandler -> RedeliveryState -> private boolean isExhausted(Exchange exchange);1549264559;Determines whether the exchange is exhausted (or anyway marked to not continue such as rollback)._<p/>_If the exchange is exhausted, then we will not continue processing, but let the_failure processor deal with the exchange.__@param exchange the current exchange_@return <tt>false</tt> to continue/redeliver, or <tt>true</tt> to exhaust.;private boolean isExhausted(Exchange exchange) {_            _            boolean exhausted = exchange.getProperty(Exchange.REDELIVERY_EXHAUSTED, false, Boolean.class)__            if (exhausted) {_                log.trace("This exchange is marked as redelivery exhausted: {}", exchange)__                return true__            }__            _            boolean rollbackOnly = exchange.getProperty(Exchange.ROLLBACK_ONLY, false, Boolean.class)__            if (rollbackOnly) {_                log.trace("This exchange is marked as rollback only, so forcing it to be exhausted: {}", exchange)__                return true__            }_            _            if (redeliveryCounter == 0) {_                return false__            }_            _            boolean redeliver = currentRedeliveryPolicy.shouldRedeliver(exchange, redeliveryCounter, retryWhilePredicate)__            return !redeliver__        };determines,whether,the,exchange,is,exhausted,or,anyway,marked,to,not,continue,such,as,rollback,p,if,the,exchange,is,exhausted,then,we,will,not,continue,processing,but,let,the,failure,processor,deal,with,the,exchange,param,exchange,the,current,exchange,return,tt,false,tt,to,continue,redeliver,or,tt,true,tt,to,exhaust;private,boolean,is,exhausted,exchange,exchange,boolean,exhausted,exchange,get,property,exchange,false,boolean,class,if,exhausted,log,trace,this,exchange,is,marked,as,redelivery,exhausted,exchange,return,true,boolean,rollback,only,exchange,get,property,exchange,false,boolean,class,if,rollback,only,log,trace,this,exchange,is,marked,as,rollback,only,so,forcing,it,to,be,exhausted,exchange,return,true,if,redelivery,counter,0,return,false,boolean,redeliver,current,redelivery,policy,should,redeliver,exchange,redelivery,counter,retry,while,predicate,return,redeliver
RedeliveryErrorHandler -> RedeliveryState -> private boolean isExhausted(Exchange exchange);1549967797;Determines whether the exchange is exhausted (or anyway marked to not continue such as rollback)._<p/>_If the exchange is exhausted, then we will not continue processing, but let the_failure processor deal with the exchange.__@param exchange the current exchange_@return <tt>false</tt> to continue/redeliver, or <tt>true</tt> to exhaust.;private boolean isExhausted(Exchange exchange) {_            _            boolean exhausted = exchange.getProperty(Exchange.REDELIVERY_EXHAUSTED, false, Boolean.class)__            if (exhausted) {_                log.trace("This exchange is marked as redelivery exhausted: {}", exchange)__                return true__            }__            _            boolean rollbackOnly = exchange.getProperty(Exchange.ROLLBACK_ONLY, false, Boolean.class)__            if (rollbackOnly) {_                log.trace("This exchange is marked as rollback only, so forcing it to be exhausted: {}", exchange)__                return true__            }_            _            if (redeliveryCounter == 0) {_                return false__            }_            _            boolean redeliver = currentRedeliveryPolicy.shouldRedeliver(exchange, redeliveryCounter, retryWhilePredicate)__            return !redeliver__        };determines,whether,the,exchange,is,exhausted,or,anyway,marked,to,not,continue,such,as,rollback,p,if,the,exchange,is,exhausted,then,we,will,not,continue,processing,but,let,the,failure,processor,deal,with,the,exchange,param,exchange,the,current,exchange,return,tt,false,tt,to,continue,redeliver,or,tt,true,tt,to,exhaust;private,boolean,is,exhausted,exchange,exchange,boolean,exhausted,exchange,get,property,exchange,false,boolean,class,if,exhausted,log,trace,this,exchange,is,marked,as,redelivery,exhausted,exchange,return,true,boolean,rollback,only,exchange,get,property,exchange,false,boolean,class,if,rollback,only,log,trace,this,exchange,is,marked,as,rollback,only,so,forcing,it,to,be,exhausted,exchange,return,true,if,redelivery,counter,0,return,false,boolean,redeliver,current,redelivery,policy,should,redeliver,exchange,redelivery,counter,retry,while,predicate,return,redeliver
RedeliveryErrorHandler -> RedeliveryState -> private boolean isExhausted(Exchange exchange);1549968092;Determines whether the exchange is exhausted (or anyway marked to not continue such as rollback)._<p/>_If the exchange is exhausted, then we will not continue processing, but let the_failure processor deal with the exchange.__@param exchange the current exchange_@return <tt>false</tt> to continue/redeliver, or <tt>true</tt> to exhaust.;private boolean isExhausted(Exchange exchange) {_            _            boolean exhausted = exchange.getProperty(Exchange.REDELIVERY_EXHAUSTED, false, Boolean.class)__            if (exhausted) {_                log.trace("This exchange is marked as redelivery exhausted: {}", exchange)__                return true__            }__            _            boolean rollbackOnly = exchange.getProperty(Exchange.ROLLBACK_ONLY, false, Boolean.class)__            if (rollbackOnly) {_                log.trace("This exchange is marked as rollback only, so forcing it to be exhausted: {}", exchange)__                return true__            }_            _            if (redeliveryCounter == 0) {_                return false__            }_            _            boolean redeliver = currentRedeliveryPolicy.shouldRedeliver(exchange, redeliveryCounter, retryWhilePredicate)__            return !redeliver__        };determines,whether,the,exchange,is,exhausted,or,anyway,marked,to,not,continue,such,as,rollback,p,if,the,exchange,is,exhausted,then,we,will,not,continue,processing,but,let,the,failure,processor,deal,with,the,exchange,param,exchange,the,current,exchange,return,tt,false,tt,to,continue,redeliver,or,tt,true,tt,to,exhaust;private,boolean,is,exhausted,exchange,exchange,boolean,exhausted,exchange,get,property,exchange,false,boolean,class,if,exhausted,log,trace,this,exchange,is,marked,as,redelivery,exhausted,exchange,return,true,boolean,rollback,only,exchange,get,property,exchange,false,boolean,class,if,rollback,only,log,trace,this,exchange,is,marked,as,rollback,only,so,forcing,it,to,be,exhausted,exchange,return,true,if,redelivery,counter,0,return,false,boolean,redeliver,current,redelivery,policy,should,redeliver,exchange,redelivery,counter,retry,while,predicate,return,redeliver
RedeliveryErrorHandler -> RedeliveryState -> private int incrementRedeliveryCounter(Exchange exchange, Throwable e);1549264559;Increments the redelivery counter and adds the redelivered flag if the_message has been redelivered;private int incrementRedeliveryCounter(Exchange exchange, Throwable e) {_            Message in = exchange.getIn()__            Integer counter = in.getHeader(Exchange.REDELIVERY_COUNTER, Integer.class)__            int next = counter != null ? counter + 1 : 1__            in.setHeader(Exchange.REDELIVERY_COUNTER, next)__            in.setHeader(Exchange.REDELIVERED, Boolean.TRUE)__            _            if (currentRedeliveryPolicy.getMaximumRedeliveries() > 0) {_                in.setHeader(Exchange.REDELIVERY_MAX_COUNTER, currentRedeliveryPolicy.getMaximumRedeliveries())__            }_            return next__        };increments,the,redelivery,counter,and,adds,the,redelivered,flag,if,the,message,has,been,redelivered;private,int,increment,redelivery,counter,exchange,exchange,throwable,e,message,in,exchange,get,in,integer,counter,in,get,header,exchange,integer,class,int,next,counter,null,counter,1,1,in,set,header,exchange,next,in,set,header,exchange,redelivered,boolean,true,if,current,redelivery,policy,get,maximum,redeliveries,0,in,set,header,exchange,current,redelivery,policy,get,maximum,redeliveries,return,next
RedeliveryErrorHandler -> RedeliveryState -> private int incrementRedeliveryCounter(Exchange exchange, Throwable e);1549967797;Increments the redelivery counter and adds the redelivered flag if the_message has been redelivered;private int incrementRedeliveryCounter(Exchange exchange, Throwable e) {_            Message in = exchange.getIn()__            Integer counter = in.getHeader(Exchange.REDELIVERY_COUNTER, Integer.class)__            int next = counter != null ? counter + 1 : 1__            in.setHeader(Exchange.REDELIVERY_COUNTER, next)__            in.setHeader(Exchange.REDELIVERED, Boolean.TRUE)__            _            if (currentRedeliveryPolicy.getMaximumRedeliveries() > 0) {_                in.setHeader(Exchange.REDELIVERY_MAX_COUNTER, currentRedeliveryPolicy.getMaximumRedeliveries())__            }_            return next__        };increments,the,redelivery,counter,and,adds,the,redelivered,flag,if,the,message,has,been,redelivered;private,int,increment,redelivery,counter,exchange,exchange,throwable,e,message,in,exchange,get,in,integer,counter,in,get,header,exchange,integer,class,int,next,counter,null,counter,1,1,in,set,header,exchange,next,in,set,header,exchange,redelivered,boolean,true,if,current,redelivery,policy,get,maximum,redeliveries,0,in,set,header,exchange,current,redelivery,policy,get,maximum,redeliveries,return,next
RedeliveryErrorHandler -> RedeliveryState -> private int incrementRedeliveryCounter(Exchange exchange, Throwable e);1549968092;Increments the redelivery counter and adds the redelivered flag if the_message has been redelivered;private int incrementRedeliveryCounter(Exchange exchange, Throwable e) {_            Message in = exchange.getIn()__            Integer counter = in.getHeader(Exchange.REDELIVERY_COUNTER, Integer.class)__            int next = counter != null ? counter + 1 : 1__            in.setHeader(Exchange.REDELIVERY_COUNTER, next)__            in.setHeader(Exchange.REDELIVERED, Boolean.TRUE)__            _            if (currentRedeliveryPolicy.getMaximumRedeliveries() > 0) {_                in.setHeader(Exchange.REDELIVERY_MAX_COUNTER, currentRedeliveryPolicy.getMaximumRedeliveries())__            }_            return next__        };increments,the,redelivery,counter,and,adds,the,redelivered,flag,if,the,message,has,been,redelivered;private,int,increment,redelivery,counter,exchange,exchange,throwable,e,message,in,exchange,get,in,integer,counter,in,get,header,exchange,integer,class,int,next,counter,null,counter,1,1,in,set,header,exchange,next,in,set,header,exchange,redelivered,boolean,true,if,current,redelivery,policy,get,maximum,redeliveries,0,in,set,header,exchange,current,redelivery,policy,get,maximum,redeliveries,return,next
RedeliveryErrorHandler -> protected boolean isCancelledOrInterrupted(Exchange exchange);1549264559;Strategy to determine if the exchange was cancelled or interrupted;protected boolean isCancelledOrInterrupted(Exchange exchange) {_        boolean answer = false___        if (ExchangeHelper.isInterrupted(exchange)) {_            _            _            exchange.setProperty(Exchange.ROUTE_STOP, Boolean.TRUE)__            answer = true__        }__        log.trace("Is exchangeId: {} interrupted? {}", exchange.getExchangeId(), answer)__        return answer__    };strategy,to,determine,if,the,exchange,was,cancelled,or,interrupted;protected,boolean,is,cancelled,or,interrupted,exchange,exchange,boolean,answer,false,if,exchange,helper,is,interrupted,exchange,exchange,set,property,exchange,boolean,true,answer,true,log,trace,is,exchange,id,interrupted,exchange,get,exchange,id,answer,return,answer
RedeliveryErrorHandler -> protected boolean isCancelledOrInterrupted(Exchange exchange);1549967797;Strategy to determine if the exchange was cancelled or interrupted;protected boolean isCancelledOrInterrupted(Exchange exchange) {_        boolean answer = false___        if (ExchangeHelper.isInterrupted(exchange)) {_            _            _            exchange.setProperty(Exchange.ROUTE_STOP, Boolean.TRUE)__            answer = true__        }__        log.trace("Is exchangeId: {} interrupted? {}", exchange.getExchangeId(), answer)__        return answer__    };strategy,to,determine,if,the,exchange,was,cancelled,or,interrupted;protected,boolean,is,cancelled,or,interrupted,exchange,exchange,boolean,answer,false,if,exchange,helper,is,interrupted,exchange,exchange,set,property,exchange,boolean,true,answer,true,log,trace,is,exchange,id,interrupted,exchange,get,exchange,id,answer,return,answer
RedeliveryErrorHandler -> protected boolean isCancelledOrInterrupted(Exchange exchange);1549968092;Strategy to determine if the exchange was cancelled or interrupted;protected boolean isCancelledOrInterrupted(Exchange exchange) {_        boolean answer = false___        if (ExchangeHelper.isInterrupted(exchange)) {_            _            _            exchange.setProperty(Exchange.ROUTE_STOP, Boolean.TRUE)__            answer = true__        }__        log.trace("Is exchangeId: {} interrupted? {}", exchange.getExchangeId(), answer)__        return answer__    };strategy,to,determine,if,the,exchange,was,cancelled,or,interrupted;protected,boolean,is,cancelled,or,interrupted,exchange,exchange,boolean,answer,false,if,exchange,helper,is,interrupted,exchange,exchange,set,property,exchange,boolean,true,answer,true,log,trace,is,exchange,id,interrupted,exchange,get,exchange,id,answer,return,answer
