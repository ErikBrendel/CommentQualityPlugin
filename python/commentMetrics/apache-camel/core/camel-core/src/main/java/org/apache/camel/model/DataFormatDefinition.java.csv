commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;21;/**  * Factory method to create the data format  *  * @param routeContext route context  * @param type         the data format type  * @param ref          reference to lookup for a data format  * @return the data format or null if not possible to create  */ ;/**  * Factory method to create the data format  *  * @param routeContext route context  * @param type         the data format type  * @param ref          reference to lookup for a data format  * @return the data format or null if not possible to create  */ public static DataFormat getDataFormat(RouteContext routeContext, DataFormatDefinition type, String ref) {     if (type == null) {         ObjectHelper.notNull(ref, "ref or type").         // try to let resolver see if it can resolve it, its not always possible         type = routeContext.getCamelContext().adapt(ModelCamelContext.class).resolveDataFormatDefinition(ref).         if (type != null) {             return type.getDataFormat(routeContext).         }         DataFormat dataFormat = routeContext.getCamelContext().resolveDataFormat(ref).         if (dataFormat == null) {             throw new IllegalArgumentException("Cannot find data format in registry with ref: " + ref).         }         return dataFormat.     } else {         return type.getDataFormat(routeContext).     } }
false;public;1;33;;public DataFormat getDataFormat(RouteContext routeContext) {     if (dataFormat == null) {         Runnable propertyPlaceholdersChangeReverter = ProcessorDefinitionHelper.createPropertyPlaceholdersChangeReverter().         // resolve properties before we create the data format         try {             ProcessorDefinitionHelper.resolvePropertyPlaceholders(routeContext.getCamelContext(), this).         } catch (Exception e) {             throw new IllegalArgumentException("Error resolving property placeholders on data format: " + this, e).         }         try {             dataFormat = createDataFormat(routeContext).             if (dataFormat != null) {                 // is enabled by default so assume true if null                 final boolean contentTypeHeader = this.contentTypeHeader == null || this.contentTypeHeader.                 try {                     setProperty(routeContext.getCamelContext(), dataFormat, "contentTypeHeader", contentTypeHeader).                 } catch (Exception e) {                 // ignore as this option is optional and not all data formats support this                 }                 // configure the rest of the options                 configureDataFormat(dataFormat, routeContext.getCamelContext()).             } else {                 throw new IllegalArgumentException("Data format '" + (dataFormatName != null ? dataFormatName : "<null>") + "' could not be created. " + "Ensure that the data format is valid and the associated Camel component is present on the classpath").             }         } finally {             propertyPlaceholdersChangeReverter.run().         }     }     return dataFormat. }
true;protected;1;7;/**  * Factory method to create the data format instance  */ ;/**  * Factory method to create the data format instance  */ protected DataFormat createDataFormat(RouteContext routeContext) {     // must use getDataFormatName() as we need special logic in json dataformat     if (getDataFormatName() != null) {         return routeContext.getCamelContext().createDataFormat(getDataFormatName()).     }     return null. }
true;protected;2;2;/**  * Allows derived classes to customize the data format  */ ;/**  * Allows derived classes to customize the data format  */ protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) { }
true;protected;4;12;/**  * Sets a named property on the data format instance using introspection  */ ;/**  * Sets a named property on the data format instance using introspection  */ protected void setProperty(CamelContext camelContext, Object bean, String name, Object value) {     try {         String ref = value instanceof String ? value.toString() : null.         if (isReferenceParameter(ref) && camelContext != null) {             IntrospectionSupport.setProperty(camelContext, camelContext.getTypeConverter(), bean, name, null, ref, true).         } else {             IntrospectionSupport.setProperty(bean, name, value).         }     } catch (Exception e) {         throw new IllegalArgumentException("Failed to set property: " + name + " on: " + bean + ". Reason: " + e, e).     } }
false;public;0;3;;public String getDataFormatName() {     return dataFormatName. }
false;public;1;3;;public void setDataFormatName(String dataFormatName) {     this.dataFormatName = dataFormatName. }
false;public;0;3;;public DataFormat getDataFormat() {     return dataFormat. }
false;public;1;3;;public void setDataFormat(DataFormat dataFormat) {     this.dataFormat = dataFormat. }
false;public;0;3;;public Map<QName, Object> getOtherAttributes() {     return otherAttributes. }
true;public;1;3;/**  * Adds an optional attribute  */ ;/**  * Adds an optional attribute  */ public void setOtherAttributes(Map<QName, Object> otherAttributes) {     this.otherAttributes = otherAttributes. }
false;public;0;3;;public Boolean getContentTypeHeader() {     return contentTypeHeader. }
true;public;1;3;/**  * Whether the data format should set the <tt>Content-Type</tt> header with the type from the data format if the  * data format is capable of doing so.  * <p/>  * For example <tt>application/xml</tt> for data formats marshalling to XML, or <tt>application/json</tt>  * for data formats marshalling to JSon etc.  */ ;/**  * Whether the data format should set the <tt>Content-Type</tt> header with the type from the data format if the  * data format is capable of doing so.  * <p/>  * For example <tt>application/xml</tt> for data formats marshalling to XML, or <tt>application/json</tt>  * for data formats marshalling to JSon etc.  */ public void setContentTypeHeader(Boolean contentTypeHeader) {     this.contentTypeHeader = contentTypeHeader. }
false;public;0;7;;public String getShortName() {     String name = getClass().getSimpleName().     if (name.endsWith("DataFormat")) {         name = name.substring(0, name.indexOf("DataFormat")).     }     return name. }
