commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {     return ObjectHelper.notNull(strategy, "AggregationStrategy").aggregate(oldExchange, newExchange). }
true;public;1;4;/**  * Define an aggregation strategy which targets the exchnage.  */ ;// ******************************* // Exchange // ******************************* /**  * Define an aggregation strategy which targets the exchnage.  */ public T exchange(final BiFunction<Exchange, Exchange, Exchange> function) {     strategy = function::apply.     return parent. }
true;public;1;15;/**  * Define an aggregation strategy which targets Exchanges In Message.  *  * <blockquote><pre>{@code  * from("direct:aggregate")  *     .aggregate()  *         .message((old, new) -> {  *             if (old == null) {  *                 return new.  *             }  *  *             String oldBody = old.getBody(String.class).  *             String newBody = new.getBody(String.class).  *  *             old.setBody(oldBody + "+" + newBody).  *  *             return old.  *         }).  * }</pre></blockquote>  */ ;// ******************************* // Message // ******************************* /**  * Define an aggregation strategy which targets Exchanges In Message.  *  * <blockquote><pre>{@code  * from("direct:aggregate")  *     .aggregate()  *         .message((old, new) -> {  *             if (old == null) {  *                 return new.  *             }  *  *             String oldBody = old.getBody(String.class).  *             String newBody = new.getBody(String.class).  *  *             old.setBody(oldBody + "+" + newBody).  *  *             return old.  *         }).  * }</pre></blockquote>  */ public T message(final BiFunction<Message, Message, Message> function) {     return exchange((Exchange oldExchange, Exchange newExchange) -> {         Message oldMessage = oldExchange != null ? oldExchange.getIn() : null.         Message newMessage = ObjectHelper.notNull(newExchange, "NewExchange").getIn().         Message result = function.apply(oldMessage, newMessage).         if (oldExchange != null) {             oldExchange.setIn(result).             return oldExchange.         } else {             newExchange.setIn(result).             return newExchange.         }     }). }
true;public;1;3;/**  * Define an aggregation strategy which targets Exchanges In Body.  *  * <blockquote><pre>{@code  * from("direct:aggregate")  *     .aggregate()  *         .body((old, new) -> {  *             if (old == null) {  *                 return new.  *             }  *  *             return old.toString() + new.toString().  *         }).  * }</pre></blockquote>  */ ;// ******************************* // Body // ******************************* /**  * Define an aggregation strategy which targets Exchanges In Body.  *  * <blockquote><pre>{@code  * from("direct:aggregate")  *     .aggregate()  *         .body((old, new) -> {  *             if (old == null) {  *                 return new.  *             }  *  *             return old.toString() + new.toString().  *         }).  * }</pre></blockquote>  */ public T body(final BiFunction<Object, Object, Object> function) {     return body(Object.class, function). }
true;public;2;3;/**  * Define an aggregation strategy which targets Exchanges In Body.  *  * <blockquote><pre>{@code  * from("direct:aggregate")  *     .aggregate()  *         .body(String.class, (old, new) -> {  *             if (old == null) {  *                 return new.  *             }  *  *             return old + new.  *         }).  * }</pre></blockquote>  */ ;/**  * Define an aggregation strategy which targets Exchanges In Body.  *  * <blockquote><pre>{@code  * from("direct:aggregate")  *     .aggregate()  *         .body(String.class, (old, new) -> {  *             if (old == null) {  *                 return new.  *             }  *  *             return old + new.  *         }).  * }</pre></blockquote>  */ public <B> T body(final Class<B> type, final BiFunction<B, B, Object> function) {     return body(type, type, function). }
true;public;3;18;/**  * Define an aggregation strategy which targets Exchanges In Body.  */ ;/**  * Define an aggregation strategy which targets Exchanges In Body.  */ public <O, N> T body(final Class<O> oldType, final Class<N> newType, final BiFunction<O, N, Object> function) {     return exchange((Exchange oldExchange, Exchange newExchange) -> {         Message oldMessage = oldExchange != null ? oldExchange.getIn() : null.         Message newMessage = ObjectHelper.notNull(newExchange, "NewExchange").getIn().         Object result = function.apply(oldMessage != null ? oldMessage.getBody(oldType) : null, newMessage != null ? newMessage.getBody(newType) : null).         if (oldExchange != null) {             oldExchange.getIn().setBody(result).             return oldExchange.         } else {             newExchange.getIn().setBody(result).             return newExchange.         }     }). }
