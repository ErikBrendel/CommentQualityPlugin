commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "DoTry[" + getOutputs() + "]". }
false;public;0;4;;@Override public String getShortName() {     return "doTry". }
false;public;0;4;;@Override public String getLabel() {     return "doTry". }
true;public;1;7;/**  * Handles the given exception  *  * @param exceptionType  the exception  * @return the try builder  */ ;// Fluent API // ------------------------------------------------------------------------- /**  * Handles the given exception  *  * @param exceptionType  the exception  * @return the try builder  */ @SuppressWarnings("unchecked") public TryDefinition doCatch(Class<? extends Throwable> exceptionType) {     // to build a TryDefinition for     return doCatch(new Class[] { exceptionType }). }
true;public;1;8;/**  * Handles the given exception(s)  *  * @param exceptionType  the exception(s)  * @return the try builder  */ ;/**  * Handles the given exception(s)  *  * @param exceptionType  the exception(s)  * @return the try builder  */ public TryDefinition doCatch(Class<? extends Throwable>... exceptionType) {     popBlock().     List<Class<? extends Throwable>> list = Arrays.asList(exceptionType).     CatchDefinition answer = new CatchDefinition(list).     addOutput(answer).     pushBlock(answer).     return this. }
true;public;0;7;/**  * The finally block for a given handle  *  * @return  the try builder  */ ;/**  * The finally block for a given handle  *  * @return  the try builder  */ public TryDefinition doFinally() {     popBlock().     FinallyDefinition answer = new FinallyDefinition().     addOutput(answer).     pushBlock(answer).     return this. }
true;public;1;11;/**  * Sets an additional predicate that should be true before the onCatch is triggered.  * <p/>  * To be used for fine grained controlling whether a thrown exception should be intercepted  * by this exception type or not.  *  * @param predicate  predicate that determines true or false  * @return the builder  */ ;/**  * Sets an additional predicate that should be true before the onCatch is triggered.  * <p/>  * To be used for fine grained controlling whether a thrown exception should be intercepted  * by this exception type or not.  *  * @param predicate  predicate that determines true or false  * @return the builder  */ public TryDefinition onWhen(@AsPredicate Predicate predicate) {     // we must use a delegate so we can use the fluent builder based on TryDefinition     // to configure all with try .. catch .. finally     // set the onWhen predicate on all the catch definitions     Iterator<CatchDefinition> it = ProcessorDefinitionHelper.filterTypeInOutputs(getOutputs(), CatchDefinition.class).     while (it.hasNext()) {         CatchDefinition doCatch = it.next().         doCatch.setOnWhen(new WhenDefinition(predicate)).     }     return this. }
false;public;0;6;;// Properties // ------------------------------------------------------------------------- public List<CatchDefinition> getCatchClauses() {     if (catchClauses == null) {         checkInitialized().     }     return catchClauses. }
false;public;0;6;;public FinallyDefinition getFinallyClause() {     if (finallyClause == null) {         checkInitialized().     }     return finallyClause. }
false;public;0;6;;public List<ProcessorDefinition<?>> getOutputsWithoutCatches() {     if (outputsWithoutCatches == null) {         checkInitialized().     }     return outputsWithoutCatches. }
false;public;1;4;;public void setOutputs(List<ProcessorDefinition<?>> outputs) {     initialized = false.     super.setOutputs(outputs). }
false;public;1;5;;@Override public void addOutput(ProcessorDefinition<?> output) {     initialized = false.     super.addOutput(output). }
false;public;0;6;;@Override public void preCreateProcessor() {     // force re-creating initialization to ensure its up-to-date     initialized = false.     checkInitialized(). }
true;protected;0;23;/**  * Checks whether or not this object has been initialized  */ ;/**  * Checks whether or not this object has been initialized  */ protected void checkInitialized() {     if (!initialized) {         initialized = true.         outputsWithoutCatches = new ArrayList<>().         catchClauses = new ArrayList<>().         finallyClause = null.         for (ProcessorDefinition<?> output : outputs) {             if (output instanceof CatchDefinition) {                 catchClauses.add((CatchDefinition) output).             } else if (output instanceof FinallyDefinition) {                 if (finallyClause != null) {                     throw new IllegalArgumentException("Multiple finally clauses added: " + finallyClause + " and " + output).                 } else {                     finallyClause = (FinallyDefinition) output.                 }             } else {                 outputsWithoutCatches.add(output).             }         }     } }
