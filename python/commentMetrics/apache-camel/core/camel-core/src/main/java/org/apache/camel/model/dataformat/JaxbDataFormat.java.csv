commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getContextPath() {     return contextPath. }
true;public;1;3;/**  * Package name where your JAXB classes are located.  */ ;/**  * Package name where your JAXB classes are located.  */ public void setContextPath(String contextPath) {     this.contextPath = contextPath. }
false;public;0;3;;public String getSchema() {     return schema. }
true;public;1;3;/**  * To validate against an existing schema.  * Your can use the prefix classpath:, file:* or *http: to specify how the resource should by resolved.  * You can separate multiple schema files by using the ',' character.  */ ;/**  * To validate against an existing schema.  * Your can use the prefix classpath:, file:* or *http: to specify how the resource should by resolved.  * You can separate multiple schema files by using the ',' character.  */ public void setSchema(String schema) {     this.schema = schema. }
false;public;0;3;;public Integer getSchemaSeverityLevel() {     return schemaSeverityLevel. }
true;public;1;3;/**  * Sets the schema severity level to use when validating against a schema.  * This level determines the minimum severity error that triggers JAXB to stop continue parsing.  * The default value of 0 (warning) means that any error (warning, error or fatal error) will trigger  * JAXB to stop. There are the following three levels: 0=warning, 1=error, 2=fatal error.  */ ;/**  * Sets the schema severity level to use when validating against a schema.  * This level determines the minimum severity error that triggers JAXB to stop continue parsing.  * The default value of 0 (warning) means that any error (warning, error or fatal error) will trigger  * JAXB to stop. There are the following three levels: 0=warning, 1=error, 2=fatal error.  */ public void setSchemaSeverityLevel(Integer schemaSeverityLevel) {     this.schemaSeverityLevel = schemaSeverityLevel. }
false;public;0;3;;public Boolean getPrettyPrint() {     return prettyPrint. }
true;public;1;3;/**  * To enable pretty printing output nicely formatted.  * <p/>  * Is by default false.  */ ;/**  * To enable pretty printing output nicely formatted.  * <p/>  * Is by default false.  */ public void setPrettyPrint(Boolean prettyPrint) {     this.prettyPrint = prettyPrint. }
false;public;0;3;;public Boolean getObjectFactory() {     return objectFactory. }
true;public;1;3;/**  * Whether to allow using ObjectFactory classes to create the POJO classes during marshalling.  * This only applies to POJO classes that has not been annotated with JAXB and providing jaxb.index descriptor files.  */ ;/**  * Whether to allow using ObjectFactory classes to create the POJO classes during marshalling.  * This only applies to POJO classes that has not been annotated with JAXB and providing jaxb.index descriptor files.  */ public void setObjectFactory(Boolean objectFactory) {     this.objectFactory = objectFactory. }
false;public;0;3;;public Boolean getIgnoreJAXBElement() {     return ignoreJAXBElement. }
true;public;1;3;/**  * Whether to ignore JAXBElement elements - only needed to be set to false in very special use-cases.  */ ;/**  * Whether to ignore JAXBElement elements - only needed to be set to false in very special use-cases.  */ public void setIgnoreJAXBElement(Boolean ignoreJAXBElement) {     this.ignoreJAXBElement = ignoreJAXBElement. }
false;public;0;3;;public Boolean getMustBeJAXBElement() {     return mustBeJAXBElement. }
true;public;1;3;/**  * Whether marhsalling must be java objects with JAXB annotations. And if not then it fails.  * This option can be set to false to relax that, such as when the data is already in XML format.  */ ;/**  * Whether marhsalling must be java objects with JAXB annotations. And if not then it fails.  * This option can be set to false to relax that, such as when the data is already in XML format.  */ public void setMustBeJAXBElement(Boolean mustBeJAXBElement) {     this.mustBeJAXBElement = mustBeJAXBElement. }
true;public;1;3;/**  * To turn on marshalling XML fragment trees.  * By default JAXB looks for @XmlRootElement annotation on given class to operate on whole XML tree.  * This is useful but not always - sometimes generated code does not have @XmlRootElement annotation,  * sometimes you need unmarshall only part of tree.  * In that case you can use partial unmarshalling. To enable this behaviours you need set property partClass.  * Camel will pass this class to JAXB's unmarshaler.  */ ;/**  * To turn on marshalling XML fragment trees.  * By default JAXB looks for @XmlRootElement annotation on given class to operate on whole XML tree.  * This is useful but not always - sometimes generated code does not have @XmlRootElement annotation,  * sometimes you need unmarshall only part of tree.  * In that case you can use partial unmarshalling. To enable this behaviours you need set property partClass.  * Camel will pass this class to JAXB's unmarshaler.  */ public void setFragment(Boolean fragment) {     this.fragment = fragment. }
false;public;0;3;;public Boolean getFragment() {     return fragment. }
false;public;0;3;;public Boolean getFilterNonXmlChars() {     return filterNonXmlChars. }
true;public;1;3;/**  * To ignore non xml characheters and replace them with an empty space.  */ ;/**  * To ignore non xml characheters and replace them with an empty space.  */ public void setFilterNonXmlChars(Boolean filterNonXmlChars) {     this.filterNonXmlChars = filterNonXmlChars. }
false;public;0;3;;public String getEncoding() {     return encoding. }
true;public;1;3;/**  * To overrule and use a specific encoding  */ ;/**  * To overrule and use a specific encoding  */ public void setEncoding(String encoding) {     this.encoding = encoding. }
false;public;0;3;;public String getPartClass() {     return partClass. }
true;public;1;3;/**  * Name of class used for fragment parsing.  * <p/>  * See more details at the fragment option.  */ ;/**  * Name of class used for fragment parsing.  * <p/>  * See more details at the fragment option.  */ public void setPartClass(String partClass) {     this.partClass = partClass. }
false;public;0;3;;public String getPartNamespace() {     return partNamespace. }
true;public;1;3;/**  * XML namespace to use for fragment parsing.  * <p/>  * See more details at the fragment option.  */ ;/**  * XML namespace to use for fragment parsing.  * <p/>  * See more details at the fragment option.  */ public void setPartNamespace(String partNamespace) {     this.partNamespace = partNamespace. }
false;public;0;3;;public String getNamespacePrefixRef() {     return namespacePrefixRef. }
true;public;1;3;/**  * When marshalling using JAXB or SOAP then the JAXB implementation will automatic assign namespace prefixes,  * such as ns2, ns3, ns4 etc. To control this mapping, Camel allows you to refer to a map which contains the desired mapping.  */ ;/**  * When marshalling using JAXB or SOAP then the JAXB implementation will automatic assign namespace prefixes,  * such as ns2, ns3, ns4 etc. To control this mapping, Camel allows you to refer to a map which contains the desired mapping.  */ public void setNamespacePrefixRef(String namespacePrefixRef) {     this.namespacePrefixRef = namespacePrefixRef. }
false;public;0;3;;public String getXmlStreamWriterWrapper() {     return xmlStreamWriterWrapper. }
true;public;1;3;/**  * To use a custom xml stream writer.  */ ;/**  * To use a custom xml stream writer.  */ public void setXmlStreamWriterWrapper(String xmlStreamWriterWrapperRef) {     this.xmlStreamWriterWrapper = xmlStreamWriterWrapperRef. }
false;public;0;3;;public String getSchemaLocation() {     return schemaLocation. }
true;public;1;3;/**  * To define the location of the schema  */ ;/**  * To define the location of the schema  */ public void setSchemaLocation(String schemaLocation) {     this.schemaLocation = schemaLocation. }
false;public;0;3;;public String getNoNamespaceSchemaLocation() {     return noNamespaceSchemaLocation. }
true;public;1;3;/**  * To define the location of the namespaceless schema  */ ;/**  * To define the location of the namespaceless schema  */ public void setNoNamespaceSchemaLocation(String schemaLocation) {     this.noNamespaceSchemaLocation = schemaLocation. }
false;public;0;3;;public String getJaxbProviderProperties() {     return jaxbProviderProperties. }
true;public;1;3;/**  * Refers to a custom java.util.Map to lookup in the registry containing custom JAXB provider properties  * to be used with the JAXB marshaller.  */ ;/**  * Refers to a custom java.util.Map to lookup in the registry containing custom JAXB provider properties  * to be used with the JAXB marshaller.  */ public void setJaxbProviderProperties(String jaxbProviderProperties) {     this.jaxbProviderProperties = jaxbProviderProperties. }
false;protected;2;72;;@Override protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {     Boolean answer = ObjectHelper.toBoolean(getPrettyPrint()).     if (answer != null && !answer) {         setProperty(camelContext, dataFormat, "prettyPrint", Boolean.FALSE).     } else {         // the default value is true         setProperty(camelContext, dataFormat, "prettyPrint", Boolean.TRUE).     }     answer = ObjectHelper.toBoolean(getObjectFactory()).     if (answer != null && !answer) {         setProperty(camelContext, dataFormat, "objectFactory", Boolean.FALSE).     } else {         // the default value is true         setProperty(camelContext, dataFormat, "objectFactory", Boolean.TRUE).     }     answer = ObjectHelper.toBoolean(getIgnoreJAXBElement()).     if (answer != null && !answer) {         setProperty(camelContext, dataFormat, "ignoreJAXBElement", Boolean.FALSE).     } else {         // the default value is true         setProperty(camelContext, dataFormat, "ignoreJAXBElement", Boolean.TRUE).     }     answer = ObjectHelper.toBoolean(getMustBeJAXBElement()).     if (answer != null && answer) {         setProperty(camelContext, dataFormat, "mustBeJAXBElement", Boolean.TRUE).     } else {         // the default value is false         setProperty(camelContext, dataFormat, "mustBeJAXBElement", Boolean.FALSE).     }     answer = ObjectHelper.toBoolean(getFilterNonXmlChars()).     if (answer != null && answer) {         setProperty(camelContext, dataFormat, "filterNonXmlChars", Boolean.TRUE).     } else {         // the default value is false         setProperty(camelContext, dataFormat, "filterNonXmlChars", Boolean.FALSE).     }     answer = ObjectHelper.toBoolean(getFragment()).     if (answer != null && answer) {         setProperty(camelContext, dataFormat, "fragment", Boolean.TRUE).     } else {         // the default value is false         setProperty(camelContext, dataFormat, "fragment", Boolean.FALSE).     }     setProperty(camelContext, dataFormat, "contextPath", contextPath).     if (partClass != null) {         setProperty(camelContext, dataFormat, "partClass", partClass).     }     if (partNamespace != null) {         setProperty(camelContext, dataFormat, "partNamespace", QName.valueOf(partNamespace)).     }     if (encoding != null) {         setProperty(camelContext, dataFormat, "encoding", encoding).     }     if (namespacePrefixRef != null) {         setProperty(camelContext, dataFormat, "namespacePrefixRef", namespacePrefixRef).     }     if (schema != null) {         setProperty(camelContext, dataFormat, "schema", schema).     }     if (schemaSeverityLevel != null) {         setProperty(camelContext, dataFormat, "schemaSeverityLevel", schemaSeverityLevel).     }     if (xmlStreamWriterWrapper != null) {         setProperty(camelContext, dataFormat, "xmlStreamWriterWrapper", xmlStreamWriterWrapper).     }     if (schemaLocation != null) {         setProperty(camelContext, dataFormat, "schemaLocation", schemaLocation).     }     if (noNamespaceSchemaLocation != null) {         setProperty(camelContext, dataFormat, "noNamespaceSchemaLocation", noNamespaceSchemaLocation).     }     if (jaxbProviderProperties != null) {         Map map = CamelContextHelper.mandatoryLookup(camelContext, jaxbProviderProperties, Map.class).         setProperty(camelContext, dataFormat, "jaxbProviderProperties", map).     } }
