commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;// ***************************** // Properties // ***************************** @Override public BackOff getBackOff() {     return backOff. }
false;public;0;4;;@Override public Status getStatus() {     return status. }
false;public;0;4;;@Override public long getCurrentAttempts() {     return currentAttempts. }
false;public;0;4;;@Override public long getCurrentDelay() {     return currentDelay. }
false;public;0;4;;@Override public long getCurrentElapsedTime() {     return currentElapsedTime. }
false;public;0;4;;@Override public long getLastAttemptTime() {     return lastAttemptTime. }
false;public;0;4;;@Override public long getNextAttemptTime() {     return nextAttemptTime. }
false;public;0;9;;@Override public void reset() {     this.currentAttempts = 0.     this.currentDelay = 0.     this.currentElapsedTime = 0.     this.lastAttemptTime = BackOff.NEVER.     this.nextAttemptTime = BackOff.NEVER.     this.status = Status.Active. }
false;public;0;12;;@Override public void cancel() {     stop().     ScheduledFuture<?> future = futureRef.get().     if (future != null) {         future.cancel(true).     }     // signal task completion on cancel.     complete(null). }
false;public;1;6;;@Override public void whenComplete(BiConsumer<BackOffTimer.Task, Throwable> whenCompleted) {     synchronized (this.consumers) {         consumers.add(whenCompleted).     } }
false;public;0;33;;// ***************************** // Task execution // ***************************** @Override public void run() {     if (status == Status.Active) {         try {             lastAttemptTime = System.currentTimeMillis().             if (function.apply(this)) {                 long delay = next().                 if (status != Status.Active) {                     // if the call to next makes the context not more                     // active, signal task completion.                     complete(null).                 } else {                     nextAttemptTime = lastAttemptTime + delay.                     // Cache the scheduled future so it can be cancelled                     // later by Task.cancel()                     futureRef.lazySet(scheduler.schedule(this, delay, TimeUnit.MILLISECONDS)).                 }             } else {                 stop().                 // if the function return false no more attempts should                 // be made so stop the context.                 complete(null).             }         } catch (Exception e) {             stop().             complete(e).         }     } }
false;;0;8;;void stop() {     this.currentAttempts = 0.     this.currentDelay = BackOff.NEVER.     this.currentElapsedTime = 0.     this.lastAttemptTime = BackOff.NEVER.     this.nextAttemptTime = BackOff.NEVER.     this.status = Status.Inactive. }
false;;1;5;;void complete(Throwable throwable) {     synchronized (this.consumers) {         consumers.forEach(c -> c.accept(this, throwable)).     } }
true;;0;25;/**  * Return the number of milliseconds to wait before retrying the operation  * or ${@link BackOff#NEVER} to indicate that no further attempt should be  * made.  */ ;// ***************************** // Impl // ***************************** /**  * Return the number of milliseconds to wait before retrying the operation  * or ${@link BackOff#NEVER} to indicate that no further attempt should be  * made.  */ long next() {     // stopped     if (status == Status.Active) {         currentAttempts++.         if (currentAttempts > backOff.getMaxAttempts()) {             currentDelay = BackOff.NEVER.             status = Status.Exhausted.         } else if (currentElapsedTime > backOff.getMaxElapsedTime().toMillis()) {             currentDelay = BackOff.NEVER.             status = Status.Exhausted.         } else {             if (currentDelay <= backOff.getMaxDelay().toMillis()) {                 currentDelay = (long) (currentDelay * backOff.getMultiplier()).             }             currentElapsedTime += currentDelay.         }     }     return currentDelay. }
false;public;0;11;;@Override public String toString() {     return "BackOffTimerTask[" + "status=" + status + ", currentAttempts=" + currentAttempts + ", currentDelay=" + currentDelay + ", currentElapsedTime=" + currentElapsedTime + ", lastAttemptTime=" + lastAttemptTime + ", nextAttemptTime=" + nextAttemptTime + ']'. }
