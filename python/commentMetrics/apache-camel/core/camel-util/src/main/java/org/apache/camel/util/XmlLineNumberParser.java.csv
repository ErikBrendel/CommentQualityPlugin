commented;modifiers;parameterAmount;loc;comment;code
false;;1;1;;String transform(String text).
true;public,static;1;3;/**  * Parses the XML.  *  * @param is the XML content as an input stream  * @return the DOM model  * @throws Exception is thrown if error parsing  */ ;/**  * Parses the XML.  *  * @param is the XML content as an input stream  * @return the DOM model  * @throws Exception is thrown if error parsing  */ public static Document parseXml(final InputStream is) throws Exception {     return parseXml(is, null). }
true;public,static;2;3;/**  * Parses the XML.  *  * @param is             the XML content as an input stream  * @param xmlTransformer the XML transformer  * @return the DOM model  * @throws Exception is thrown if error parsing  */ ;/**  * Parses the XML.  *  * @param is             the XML content as an input stream  * @param xmlTransformer the XML transformer  * @return the DOM model  * @throws Exception is thrown if error parsing  */ public static Document parseXml(final InputStream is, final XmlTextTransformer xmlTransformer) throws Exception {     return parseXml(is, xmlTransformer, null, null). }
false;public;1;5;;@Override public void setDocumentLocator(final Locator locator) {     // Save the locator, so that it can be used later for line tracking when traversing nodes.     this.locator = locator.     this.found = rootNames == null. }
false;private;1;8;;private boolean isRootName(String qName) {     for (String root : rootNames.split(",")) {         if (qName.equals(root)) {             return true.         }     }     return false. }
false;public;4;27;;@Override public void startElement(final String uri, final String localName, final String qName, final Attributes attributes) throws SAXException {     addTextIfNeeded().     if (rootNames != null && !found) {         if (isRootName(qName)) {             found = true.         }     }     if (found) {         Element el.         if (forceNamespace != null) {             el = doc.createElementNS(forceNamespace, qName).         } else {             el = doc.createElement(qName).         }         for (int i = 0. i < attributes.getLength(). i++) {             el.setAttribute(transformer.transform(attributes.getQName(i)), transformer.transform(attributes.getValue(i))).         }         el.setUserData(LINE_NUMBER, String.valueOf(this.locator.getLineNumber()), null).         el.setUserData(COLUMN_NUMBER, String.valueOf(this.locator.getColumnNumber()), null).         elementStack.push(el).     } }
false;public;3;22;;@Override public void endElement(final String uri, final String localName, final String qName) {     if (!found) {         return.     }     addTextIfNeeded().     final Element closedEl = elementStack.isEmpty() ? null : elementStack.pop().     if (closedEl != null) {         if (elementStack.isEmpty()) {             // Is this the root element?             doc.appendChild(closedEl).         } else {             final Element parentEl = elementStack.peek().             parentEl.appendChild(closedEl).         }         closedEl.setUserData(LINE_NUMBER_END, String.valueOf(this.locator.getLineNumber()), null).         closedEl.setUserData(COLUMN_NUMBER_END, String.valueOf(this.locator.getColumnNumber()), null).     } }
false;public;3;8;;@Override public void characters(final char[] ch, final int start, final int length) throws SAXException {     char[] chars = new char[length].     System.arraycopy(ch, start, chars, 0, length).     String s = new String(chars).     s = transformer.transform(s).     textBuffer.append(s). }
false;public;2;5;;@Override public InputSource resolveEntity(String publicId, String systemId) throws IOException, SAXException {     // do not resolve external dtd     return new InputSource(new StringReader("")). }
true;private;0;10;// Outputs text accumulated under the current node ;// Outputs text accumulated under the current node private void addTextIfNeeded() {     if (textBuffer.length() > 0) {         final Element el = elementStack.isEmpty() ? null : elementStack.peek().         if (el != null) {             final Node textNode = doc.createTextNode(textBuffer.toString()).             el.appendChild(textNode).             textBuffer.delete(0, textBuffer.length()).         }     } }
true;public,static;4;126;/**  * Parses the XML.  *  * @param is              the XML content as an input stream  * @param xmlTransformer  the XML transformer  * @param rootNames       one or more root names that is used as baseline for beginning the parsing, for example camelContext to start parsing  *                        when Camel is discovered. Multiple names can be defined separated by comma  * @param forceNamespace  an optional namespaces to force assign to each node. This may be needed for JAXB unmarshalling from XML -> POJO.  * @return the DOM model  * @throws Exception is thrown if error parsing  */ ;/**  * Parses the XML.  *  * @param is              the XML content as an input stream  * @param xmlTransformer  the XML transformer  * @param rootNames       one or more root names that is used as baseline for beginning the parsing, for example camelContext to start parsing  *                        when Camel is discovered. Multiple names can be defined separated by comma  * @param forceNamespace  an optional namespaces to force assign to each node. This may be needed for JAXB unmarshalling from XML -> POJO.  * @return the DOM model  * @throws Exception is thrown if error parsing  */ public static Document parseXml(final InputStream is, XmlTextTransformer xmlTransformer, String rootNames, final String forceNamespace) throws Exception {     ObjectHelper.notNull(is, "is").     final XmlTextTransformer transformer = xmlTransformer == null ? new NoopTransformer() : xmlTransformer.     final Document doc.     SAXParser parser.     final SAXParserFactory factory = SAXParserFactory.newInstance().     factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE).     parser = factory.newSAXParser().     final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance().     // turn off validator and loading external dtd     dbf.setValidating(false).     dbf.setNamespaceAware(true).     dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE).     dbf.setFeature("http://xml.org/sax/features/namespaces", false).     dbf.setFeature("http://xml.org/sax/features/validation", false).     dbf.setFeature("http://apache.org/xml/features/nonvalidating/load-dtd-grammar", false).     dbf.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false).     dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false).     dbf.setFeature("http://xml.org/sax/features/external-general-entities", false).     final DocumentBuilder docBuilder = dbf.newDocumentBuilder().     doc = docBuilder.newDocument().     final Stack<Element> elementStack = new Stack<>().     final StringBuilder textBuffer = new StringBuilder().     final DefaultHandler handler = new DefaultHandler() {          private Locator locator.          private boolean found.          @Override         public void setDocumentLocator(final Locator locator) {             // Save the locator, so that it can be used later for line tracking when traversing nodes.             this.locator = locator.             this.found = rootNames == null.         }          private boolean isRootName(String qName) {             for (String root : rootNames.split(",")) {                 if (qName.equals(root)) {                     return true.                 }             }             return false.         }          @Override         public void startElement(final String uri, final String localName, final String qName, final Attributes attributes) throws SAXException {             addTextIfNeeded().             if (rootNames != null && !found) {                 if (isRootName(qName)) {                     found = true.                 }             }             if (found) {                 Element el.                 if (forceNamespace != null) {                     el = doc.createElementNS(forceNamespace, qName).                 } else {                     el = doc.createElement(qName).                 }                 for (int i = 0. i < attributes.getLength(). i++) {                     el.setAttribute(transformer.transform(attributes.getQName(i)), transformer.transform(attributes.getValue(i))).                 }                 el.setUserData(LINE_NUMBER, String.valueOf(this.locator.getLineNumber()), null).                 el.setUserData(COLUMN_NUMBER, String.valueOf(this.locator.getColumnNumber()), null).                 elementStack.push(el).             }         }          @Override         public void endElement(final String uri, final String localName, final String qName) {             if (!found) {                 return.             }             addTextIfNeeded().             final Element closedEl = elementStack.isEmpty() ? null : elementStack.pop().             if (closedEl != null) {                 if (elementStack.isEmpty()) {                     // Is this the root element?                     doc.appendChild(closedEl).                 } else {                     final Element parentEl = elementStack.peek().                     parentEl.appendChild(closedEl).                 }                 closedEl.setUserData(LINE_NUMBER_END, String.valueOf(this.locator.getLineNumber()), null).                 closedEl.setUserData(COLUMN_NUMBER_END, String.valueOf(this.locator.getColumnNumber()), null).             }         }          @Override         public void characters(final char[] ch, final int start, final int length) throws SAXException {             char[] chars = new char[length].             System.arraycopy(ch, start, chars, 0, length).             String s = new String(chars).             s = transformer.transform(s).             textBuffer.append(s).         }          @Override         public InputSource resolveEntity(String publicId, String systemId) throws IOException, SAXException {             // do not resolve external dtd             return new InputSource(new StringReader("")).         }          // Outputs text accumulated under the current node         private void addTextIfNeeded() {             if (textBuffer.length() > 0) {                 final Element el = elementStack.isEmpty() ? null : elementStack.peek().                 if (el != null) {                     final Node textNode = doc.createTextNode(textBuffer.toString()).                     el.appendChild(textNode).                     textBuffer.delete(0, textBuffer.length()).                 }             }         }     }.     parser.parse(is, handler).     return doc. }
false;public;1;4;;@Override public String transform(String text) {     return text. }
