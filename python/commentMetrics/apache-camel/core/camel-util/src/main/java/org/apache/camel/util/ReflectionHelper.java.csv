commented;modifiers;parameterAmount;loc;comment;code
true;;1;1;/**  * Perform an operation using the given field.  *  * @param field the field to operate on  */ ;/**  * Perform an operation using the given field.  *  * @param field the field to operate on  */ void doWith(Field field) throws IllegalArgumentException, IllegalAccessException.
true;;1;1;/**  * Perform an operation using the given method.  *  * @param method the method to operate on  */ ;/**  * Perform an operation using the given method.  *  * @param method the method to operate on  */ void doWith(Method method) throws IllegalArgumentException, IllegalAccessException.
true;public,static;2;16;/**  * Invoke the given callback on all fields in the target class, going up the  * class hierarchy to get all declared fields.  * @param clazz the target class to analyze  * @param fc the callback to invoke for each field  */ ;/**  * Invoke the given callback on all fields in the target class, going up the  * class hierarchy to get all declared fields.  * @param clazz the target class to analyze  * @param fc the callback to invoke for each field  */ public static void doWithFields(Class<?> clazz, FieldCallback fc) throws IllegalArgumentException {     // Keep backing up the inheritance hierarchy.     Class<?> targetClass = clazz.     do {         Field[] fields = targetClass.getDeclaredFields().         for (Field field : fields) {             try {                 fc.doWith(field).             } catch (IllegalAccessException ex) {                 throw new IllegalStateException("Shouldn't be illegal to access field '" + field.getName() + "': " + ex).             }         }         targetClass = targetClass.getSuperclass().     } while (targetClass != null && targetClass != Object.class). }
true;public,static;2;23;/**  * Perform the given callback operation on all matching methods of the given  * class and superclasses (or given interface and super-interfaces).  * <p/>  * <b>Important:</b> This method does not take the  * {@link java.lang.reflect.Method#isBridge() bridge methods} into account.  *  * @param clazz class to start looking at  * @param mc the callback to invoke for each method  */ ;/**  * Perform the given callback operation on all matching methods of the given  * class and superclasses (or given interface and super-interfaces).  * <p/>  * <b>Important:</b> This method does not take the  * {@link java.lang.reflect.Method#isBridge() bridge methods} into account.  *  * @param clazz class to start looking at  * @param mc the callback to invoke for each method  */ public static void doWithMethods(Class<?> clazz, MethodCallback mc) throws IllegalArgumentException {     // Keep backing up the inheritance hierarchy.     Method[] methods = clazz.getDeclaredMethods().     for (Method method : methods) {         if (method.isBridge()) {             // see https://bugs.openjdk.java.net/browse/JDK-6695379             continue.         }         try {             mc.doWith(method).         } catch (IllegalAccessException ex) {             throw new IllegalStateException("Shouldn't be illegal to access method '" + method.getName() + "': " + ex).         }     }     if (clazz.getSuperclass() != null) {         doWithMethods(clazz.getSuperclass(), mc).     } else if (clazz.isInterface()) {         for (Class<?> superIfc : clazz.getInterfaces()) {             doWithMethods(superIfc, mc).         }     } }
true;public,static;3;15;/**  * Attempt to find a {@link Method} on the supplied class with the supplied name  * and parameter types. Searches all superclasses up to {@code Object}.  * <p>Returns {@code null} if no {@link Method} can be found.  * @param clazz the class to introspect  * @param name the name of the method  * @param paramTypes the parameter types of the method  * (may be {@code null} to indicate any signature)  * @return the Method object, or {@code null} if none found  */ ;/**  * Attempt to find a {@link Method} on the supplied class with the supplied name  * and parameter types. Searches all superclasses up to {@code Object}.  * <p>Returns {@code null} if no {@link Method} can be found.  * @param clazz the class to introspect  * @param name the name of the method  * @param paramTypes the parameter types of the method  * (may be {@code null} to indicate any signature)  * @return the Method object, or {@code null} if none found  */ public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes) {     ObjectHelper.notNull(clazz, "Class must not be null").     ObjectHelper.notNull(name, "Method name must not be null").     Class<?> searchType = clazz.     while (searchType != null) {         Method[] methods = searchType.isInterface() ? searchType.getMethods() : searchType.getDeclaredMethods().         for (Method method : methods) {             if (name.equals(method.getName()) && (paramTypes == null || Arrays.equals(paramTypes, method.getParameterTypes()))) {                 return method.             }         }         searchType = searchType.getSuperclass().     }     return null. }
false;public,static;3;15;;public static void setField(Field f, Object instance, Object value) {     try {         boolean oldAccessible = f.isAccessible().         boolean shouldSetAccessible = !Modifier.isPublic(f.getModifiers()) && !oldAccessible.         if (shouldSetAccessible) {             f.setAccessible(true).         }         f.set(instance, value).         if (shouldSetAccessible) {             f.setAccessible(oldAccessible).         }     } catch (Exception ex) {         throw new UnsupportedOperationException("Cannot inject value of class: " + value.getClass() + " into: " + f).     } }
