commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;20;/**  * Returns the size of the collection if it can be determined to be a collection  *  * @param value the collection  * @return the size, or <tt>null</tt> if not a collection  */ ;/**  * Returns the size of the collection if it can be determined to be a collection  *  * @param value the collection  * @return the size, or <tt>null</tt> if not a collection  */ public static Integer size(Object value) {     if (value != null) {         if (value instanceof Collection) {             Collection<?> collection = (Collection<?>) value.             return collection.size().         } else if (value instanceof Map) {             Map<?, ?> map = (Map<?, ?>) value.             return map.size().         } else if (value instanceof Object[]) {             Object[] array = (Object[]) value.             return array.length.         } else if (value.getClass().isArray()) {             return Array.getLength(value).         } else if (value instanceof NodeList) {             NodeList nodeList = (NodeList) value.             return nodeList.getLength().         }     }     return null. }
true;public,static;3;19;/**  * Sets the value of the entry in the map for the given key, though if the  * map already contains a value for the given key then the value is appended  * to a list of values.  *  * @param map the map to add the entry to  * @param key the key in the map  * @param value the value to put in the map  */ ;/**  * Sets the value of the entry in the map for the given key, though if the  * map already contains a value for the given key then the value is appended  * to a list of values.  *  * @param map the map to add the entry to  * @param key the key in the map  * @param value the value to put in the map  */ @SuppressWarnings("unchecked") public static void appendValue(Map<String, Object> map, String key, Object value) {     Object oldValue = map.get(key).     if (oldValue != null) {         List<Object> list.         if (oldValue instanceof List) {             list = (List<Object>) oldValue.         } else {             list = new ArrayList<>().             list.add(oldValue).             // replace old entry with list             map.remove(key).             map.put(key, list).         }         list.add(value).     } else {         map.put(key, value).     } }
false;public,static;1;3;;public static <T> Set<T> createSetContaining(T... contents) {     return new HashSet<>(Arrays.asList(contents)). }
false;public,static;1;16;;public static String collectionAsCommaDelimitedString(Collection<?> col) {     if (col == null || col.isEmpty()) {         return "".     }     StringBuilder sb = new StringBuilder().     Iterator<?> it = col.iterator().     while (it.hasNext()) {         sb.append(it.next().toString()).         if (it.hasNext()) {             sb.append(",").         }     }     return sb.toString(). }
true;public,static;2;5;/**  * Traverses the given map recursively and flattern the keys by combining them with the optional separator.  *  * @param map  the map  * @param separator optional separator to use in key name, for example a hyphen or dot.  * @return the map with flattern keys  */ ;/**  * Traverses the given map recursively and flattern the keys by combining them with the optional separator.  *  * @param map  the map  * @param separator optional separator to use in key name, for example a hyphen or dot.  * @return the map with flattern keys  */ public static Map<String, Object> flattenKeysInMap(Map<String, Object> map, String separator) {     Map<String, Object> answer = new LinkedHashMap<>().     doFlattenKeysInMap(map, "", ObjectHelper.isNotEmpty(separator) ? separator : "", answer).     return answer. }
false;private,static;4;14;;private static void doFlattenKeysInMap(Map<String, Object> source, String prefix, String separator, Map<String, Object> target) {     for (Map.Entry<String, Object> entry : source.entrySet()) {         String key = entry.getKey().         Object value = entry.getValue().         String newKey = prefix.isEmpty() ? key : prefix + separator + key.         if (value instanceof Map) {             Map map = (Map) value.             doFlattenKeysInMap(map, newKey, separator, target).         } else {             target.put(newKey, value).         }     } }
true;public,static;1;5;/**  * Build an unmodifiable map on top of a given map. Note tha thew given map is  * copied if not null.  *  * @param map a map  * @return an unmodifiable map.  */ ;/**  * Build an unmodifiable map on top of a given map. Note tha thew given map is  * copied if not null.  *  * @param map a map  * @return an unmodifiable map.  */ public static <K, V> Map<K, V> unmodifiableMap(Map<K, V> map) {     return map == null ? Collections.emptyMap() : Collections.unmodifiableMap(new HashMap<>(map)). }
true;public,static;4;13;/**  * Build a map from varargs.  */ ;/**  * Build a map from varargs.  */ public static <K, V> Map<K, V> mapOf(Supplier<Map<K, V>> creator, K key, V value, Object... keyVals) {     Map<K, V> map = creator.get().     map.put(key, value).     for (int i = 0. i < keyVals.length. i += 2) {         map.put((K) keyVals[i], (V) keyVals[i + 1]).     }     return map. }
true;public,static;4;5;/**  * Build an immutable map from varargs.  */ ;/**  * Build an immutable map from varargs.  */ public static <K, V> Map<K, V> immutableMapOf(Supplier<Map<K, V>> creator, K key, V value, Object... keyVals) {     return Collections.unmodifiableMap(mapOf(creator, key, value, keyVals)). }
true;public,static;3;3;/**  * Build a map from varargs.  */ ;/**  * Build a map from varargs.  */ public static <K, V> Map<K, V> mapOf(K key, V value, Object... keyVals) {     return mapOf(HashMap::new, key, value, keyVals). }
true;public,static;3;5;/**  * Build an immutable map from varargs.  */ ;/**  * Build an immutable map from varargs.  */ public static <K, V> Map<K, V> immutableMapOf(K key, V value, Object... keyVals) {     return Collections.unmodifiableMap(mapOf(HashMap::new, key, value, keyVals)). }
