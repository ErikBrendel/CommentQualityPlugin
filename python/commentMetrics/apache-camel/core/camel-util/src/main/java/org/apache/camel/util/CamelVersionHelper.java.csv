commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;5;/**  * Checks whether other >= base  *  * @param base the base version  * @param other the other version  * @return <tt>true</tt> if GE, <tt>false</tt> otherwise  */ ;/**  * Checks whether other >= base  *  * @param base the base version  * @param other the other version  * @return <tt>true</tt> if GE, <tt>false</tt> otherwise  */ public static boolean isGE(String base, String other) {     ComparableVersion v1 = new ComparableVersion(base).     ComparableVersion v2 = new ComparableVersion(other).     return v2.compareTo(v1) >= 0. }
false;;1;1;;int compareTo(Item item).
false;;0;1;;int getType().
false;;0;1;;boolean isNull().
false;public;0;3;;public int getType() {     return INTEGER_ITEM. }
false;public;0;3;;public boolean isNull() {     return BIG_INTEGER_ZERO.equals(value). }
false;public;1;20;;public int compareTo(Item item) {     if (item == null) {         // 1.0 == 1,         return BIG_INTEGER_ZERO.equals(value) ? 0 : 1.     // 1.1 > 1     }     switch(item.getType()) {         case INTEGER_ITEM:             return value.compareTo(((IntegerItem) item).value).         case STRING_ITEM:             // 1.1 > 1-sp             return 1.         case LIST_ITEM:             // 1.1 > 1-1             return 1.         default:             throw new RuntimeException("invalid item: " + item.getClass()).     } }
false;public;0;3;;public String toString() {     return value.toString(). }
false;public;0;3;;public int getType() {     return STRING_ITEM. }
false;public;0;3;;public boolean isNull() {     return comparableQualifier(value).compareTo(RELEASE_VERSION_INDEX) == 0. }
true;public,static;1;5;/**  * Returns a comparable value for a qualifier. This method takes  * into account the ordering of known qualifiers then unknown  * qualifiers with lexical ordering. just returning an Integer with  * the index here is faster, but requires a lot of if/then/else to  * check for -1 or QUALIFIERS.size and then resort to lexical  * ordering. Most comparisons are decided by the first character, so  * this is still fast. If more characters are needed then it  * requires a lexical sort anyway.  *  * @param qualifier  * @return an equivalent value that can be used with lexical  *         comparison  */ ;/**  * Returns a comparable value for a qualifier. This method takes  * into account the ordering of known qualifiers then unknown  * qualifiers with lexical ordering. just returning an Integer with  * the index here is faster, but requires a lot of if/then/else to  * check for -1 or QUALIFIERS.size and then resort to lexical  * ordering. Most comparisons are decided by the first character, so  * this is still fast. If more characters are needed then it  * requires a lexical sort anyway.  *  * @param qualifier  * @return an equivalent value that can be used with lexical  *         comparison  */ public static String comparableQualifier(String qualifier) {     int i = QUALIFIERS_LIST.indexOf(qualifier).     return i == -1 ? (QUALIFIERS_LIST.size() + "-" + qualifier) : String.valueOf(i). }
false;public;1;19;;public int compareTo(Item item) {     if (item == null) {         // 1-rc < 1, 1-ga > 1         return comparableQualifier(value).compareTo(RELEASE_VERSION_INDEX).     }     switch(item.getType()) {         case INTEGER_ITEM:             // 1.any < 1.1 ?             return -1.         case STRING_ITEM:             return comparableQualifier(value).compareTo(comparableQualifier(((StringItem) item).value)).         case LIST_ITEM:             // 1.any < 1-1             return -1.         default:             throw new RuntimeException("invalid item: " + item.getClass()).     } }
false;public;0;3;;public String toString() {     return value. }
false;public;0;3;;public int getType() {     return LIST_ITEM. }
false;public;0;3;;public boolean isNull() {     return size() == 0. }
false;;0;12;;void normalize() {     for (int i = size() - 1. i >= 0. i--) {         Item lastItem = get(i).         if (lastItem.isNull()) {             // remove null trailing items: 0, "", empty list             remove(i).         } else if (!(lastItem instanceof ListItem)) {             break.         }     } }
false;public;1;38;;public int compareTo(Item item) {     if (item == null) {         if (size() == 0) {             // 1-0 = 1- (normalize) = 1             return 0.         }         Item first = get(0).         return first.compareTo(null).     }     switch(item.getType()) {         case INTEGER_ITEM:             // 1-1 < 1.0.x             return -1.         case STRING_ITEM:             // 1-1 > 1-sp             return 1.         case LIST_ITEM:             Iterator<Item> left = iterator().             Iterator<Item> right = ((ListItem) item).iterator().             while (left.hasNext() || right.hasNext()) {                 Item l = left.hasNext() ? left.next() : null.                 Item r = right.hasNext() ? right.next() : null.                 // if this is shorter, then invert the compare and mul                 // with -1                 int result = l == null ? (r == null ? 0 : -1 * r.compareTo(l)) : l.compareTo(r).                 if (result != 0) {                     return result.                 }             }             return 0.         default:             throw new RuntimeException("invalid item: " + item.getClass()).     } }
false;public;0;10;;public String toString() {     StringBuilder buffer = new StringBuilder().     for (Item item : this) {         if (buffer.length() > 0) {             buffer.append((item instanceof ListItem) ? '-' : '.').         }         buffer.append(item).     }     return buffer.toString(). }
false;private;1;70;;private void parseVersion(String version) {     this.value = version.     items = new ListItem().     version = version.toLowerCase(Locale.ENGLISH).     ListItem list = items.     Stack<Item> stack = new Stack<>().     stack.push(list).     boolean isDigit = false.     int startIndex = 0.     for (int i = 0. i < version.length(). i++) {         char c = version.charAt(i).         if (c == '.') {             if (i == startIndex) {                 list.add(IntegerItem.ZERO).             } else {                 list.add(parseItem(isDigit, version.substring(startIndex, i))).             }             startIndex = i + 1.         } else if (c == '-') {             if (i == startIndex) {                 list.add(IntegerItem.ZERO).             } else {                 list.add(parseItem(isDigit, version.substring(startIndex, i))).             }             startIndex = i + 1.             list.add(list = new ListItem()).             stack.push(list).         } else if (Character.isDigit(c)) {             if (!isDigit && i > startIndex) {                 list.add(new StringItem(version.substring(startIndex, i), true)).                 startIndex = i.                 list.add(list = new ListItem()).                 stack.push(list).             }             isDigit = true.         } else {             if (isDigit && i > startIndex) {                 list.add(parseItem(true, version.substring(startIndex, i))).                 startIndex = i.                 list.add(list = new ListItem()).                 stack.push(list).             }             isDigit = false.         }     }     if (version.length() > startIndex) {         list.add(parseItem(isDigit, version.substring(startIndex))).     }     while (!stack.isEmpty()) {         list = (ListItem) stack.pop().         list.normalize().     }     canonical = items.toString(). }
false;private,static;2;3;;private static Item parseItem(boolean isDigit, String buf) {     return isDigit ? new IntegerItem(buf) : new StringItem(buf, false). }
false;public;1;3;;public int compareTo(ComparableVersion o) {     return items.compareTo(o.items). }
false;public;0;3;;public String toString() {     return value. }
false;public;1;3;;public boolean equals(Object o) {     return (o instanceof ComparableVersion) && canonical.equals(((ComparableVersion) o).canonical). }
false;public;0;3;;public int hashCode() {     return canonical.hashCode(). }
