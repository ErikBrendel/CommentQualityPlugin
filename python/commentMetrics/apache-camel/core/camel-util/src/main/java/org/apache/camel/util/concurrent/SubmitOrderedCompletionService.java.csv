commented;modifiers;parameterAmount;loc;comment;code
false;public;1;16;;public long getDelay(TimeUnit unit) {     // if the answer is 0 then this task is ready to be taken     long answer = id - index.get().     if (answer <= 0) {         return answer.     }     // so we have to return a delay value of one time unit     if (TimeUnit.NANOSECONDS == unit) {         // okay this is too fast so use a little more delay to avoid CPU burning cycles         answer = unit.convert(1, TimeUnit.MICROSECONDS).     } else {         answer = unit.convert(1, unit).     }     return answer. }
false;public;1;5;;@SuppressWarnings("unchecked") public int compareTo(Delayed o) {     SubmitOrderFutureTask other = (SubmitOrderFutureTask) o.     return (int) (this.id - other.id). }
false;protected;0;5;;@Override protected void done() {     // when we are done add to the completion queue     completionQueue.add(this). }
false;public;0;5;;@Override public String toString() {     // output using zero-based index     return "SubmitOrderedFutureTask[" + (id - 1) + "]". }
false;public;1;8;;public Future<V> submit(Callable<V> task) {     if (task == null) {         throw new IllegalArgumentException("Task must be provided").     }     SubmitOrderFutureTask f = new SubmitOrderFutureTask(id.incrementAndGet(), task).     executor.execute(f).     return f. }
false;public;2;8;;public Future<V> submit(Runnable task, Object result) {     if (task == null) {         throw new IllegalArgumentException("Task must be provided").     }     SubmitOrderFutureTask f = new SubmitOrderFutureTask(id.incrementAndGet(), task, null).     executor.execute(f).     return f. }
false;public;0;4;;public Future<V> take() throws InterruptedException {     index.incrementAndGet().     return completionQueue.take(). }
false;public;0;9;;public Future<V> poll() {     index.incrementAndGet().     Future<V> answer = completionQueue.poll().     if (answer == null) {         // decrease counter if we didnt get any data         index.decrementAndGet().     }     return answer. }
false;public;2;9;;public Future<V> poll(long timeout, TimeUnit unit) throws InterruptedException {     index.incrementAndGet().     Future<V> answer = completionQueue.poll(timeout, unit).     if (answer == null) {         // decrease counter if we didnt get any data         index.decrementAndGet().     }     return answer. }
true;public;0;3;/**  * Marks the current task as timeout, which allows you to poll the next  * tasks which may already have been completed.  */ ;/**  * Marks the current task as timeout, which allows you to poll the next  * tasks which may already have been completed.  */ public void timeoutTask() {     index.incrementAndGet(). }
