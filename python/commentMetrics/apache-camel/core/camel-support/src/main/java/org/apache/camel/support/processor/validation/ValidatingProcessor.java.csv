commented;modifiers;parameterAmount;loc;comment;code
false;public;2;9;;public boolean process(Exchange exchange, AsyncCallback callback) {     try {         doProcess(exchange).     } catch (Exception e) {         exchange.setException(e).     }     callback.done(true).     return true. }
false;protected;1;83;;protected void doProcess(Exchange exchange) throws Exception {     Schema schema.     if (isUseSharedSchema()) {         schema = getSchema().     } else {         schema = createSchema().     }     Validator validator = schema.newValidator().     // turn off access to external schema by default     if (!Boolean.parseBoolean(exchange.getContext().getGlobalOptions().get(ACCESS_EXTERNAL_DTD))) {         try {             log.debug("Configuring Validator to not allow access to external DTD/Schema").             validator.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, "").             validator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "").         } catch (SAXException e) {             log.warn(e.getMessage(), e).         }     }     // the underlying input stream, which we need to close to avoid locking     // files or     // other resources     Source source = null.     InputStream is = null.     try {         Result result = null.         // only convert to input stream if really needed         if (isInputStreamNeeded(exchange)) {             is = getContentToValidate(exchange, InputStream.class).             if (is != null) {                 source = getSource(exchange, is).             }         } else {             Object content = getContentToValidate(exchange).             if (content != null) {                 source = getSource(exchange, content).             }         }         if (shouldUseHeader()) {             if (source == null && isFailOnNullHeader()) {                 throw new NoXmlHeaderValidationException(exchange, headerName).             }         } else {             if (source == null && isFailOnNullBody()) {                 throw new NoXmlBodyValidationException(exchange).             }         }         // StreamSource         if (source instanceof DOMSource) {             result = new DOMResult().         } else if (source instanceof SAXSource) {             result = new SAXResult().         } else if (source instanceof StAXSource || source instanceof StreamSource) {             result = null.         }         if (source != null) {             // create a new errorHandler and set it on the validator             // must be a local instance to avoid problems with concurrency             // (to be             // thread safe)             ValidatorErrorHandler handler = errorHandler.getClass().newInstance().             validator.setErrorHandler(handler).             try {                 log.trace("Validating {}", source).                 validator.validate(source, result).                 handler.handleErrors(exchange, schema, result).             } catch (SAXParseException e) {                 // can be thrown for non well formed XML                 throw new SchemaValidationException(exchange, schema, Collections.singletonList(e), Collections.<SAXParseException>emptyList(), Collections.<SAXParseException>emptyList()).             }         }     } finally {         IOHelper.close(is).     } }
false;private;1;7;;private Object getContentToValidate(Exchange exchange) {     if (shouldUseHeader()) {         return exchange.getIn().getHeader(headerName).     } else {         return exchange.getIn().getBody().     } }
false;private;2;7;;private <T> T getContentToValidate(Exchange exchange, Class<T> clazz) {     if (shouldUseHeader()) {         return exchange.getIn().getHeader(headerName, clazz).     } else {         return exchange.getIn().getBody(clazz).     } }
false;private;0;3;;private boolean shouldUseHeader() {     return headerName != null. }
false;public;0;3;;public void loadSchema() throws Exception {     schemaReader.loadSchema(). }
false;public;0;3;;// Properties // ----------------------------------------------------------------------- public Schema getSchema() throws IOException, SAXException {     return schemaReader.getSchema(). }
false;public;1;3;;public void setSchema(Schema schema) {     schemaReader.setSchema(schema). }
false;public;0;3;;public String getSchemaLanguage() {     return schemaReader.getSchemaLanguage(). }
false;public;1;3;;public void setSchemaLanguage(String schemaLanguage) {     schemaReader.setSchemaLanguage(schemaLanguage). }
false;public;0;3;;public Source getSchemaSource() throws IOException {     return schemaReader.getSchemaSource(). }
false;public;1;3;;public void setSchemaSource(Source schemaSource) {     schemaReader.setSchemaSource(schemaSource). }
false;public;0;3;;public URL getSchemaUrl() {     return schemaReader.getSchemaUrl(). }
false;public;1;3;;public void setSchemaUrl(URL schemaUrl) {     schemaReader.setSchemaUrl(schemaUrl). }
false;public;0;3;;public File getSchemaFile() {     return schemaReader.getSchemaFile(). }
false;public;1;3;;public void setSchemaFile(File schemaFile) {     schemaReader.setSchemaFile(schemaFile). }
false;public;0;3;;public byte[] getSchemaAsByteArray() {     return schemaReader.getSchemaAsByteArray(). }
false;public;1;3;;public void setSchemaAsByteArray(byte[] schemaAsByteArray) {     schemaReader.setSchemaAsByteArray(schemaAsByteArray). }
false;public;0;3;;public SchemaFactory getSchemaFactory() {     return schemaReader.getSchemaFactory(). }
false;public;1;3;;public void setSchemaFactory(SchemaFactory schemaFactory) {     schemaReader.setSchemaFactory(schemaFactory). }
false;public;0;3;;public ValidatorErrorHandler getErrorHandler() {     return errorHandler. }
false;public;1;3;;public void setErrorHandler(ValidatorErrorHandler errorHandler) {     this.errorHandler = errorHandler. }
false;public;0;3;;public boolean isUseSharedSchema() {     return useSharedSchema. }
false;public;1;3;;public void setUseSharedSchema(boolean useSharedSchema) {     this.useSharedSchema = useSharedSchema. }
false;public;0;3;;public LSResourceResolver getResourceResolver() {     return schemaReader.getResourceResolver(). }
false;public;1;3;;public void setResourceResolver(LSResourceResolver resourceResolver) {     schemaReader.setResourceResolver(resourceResolver). }
false;public;0;3;;public boolean isFailOnNullBody() {     return failOnNullBody. }
false;public;1;3;;public void setFailOnNullBody(boolean failOnNullBody) {     this.failOnNullBody = failOnNullBody. }
false;public;0;3;;public boolean isFailOnNullHeader() {     return failOnNullHeader. }
false;public;1;3;;public void setFailOnNullHeader(boolean failOnNullHeader) {     this.failOnNullHeader = failOnNullHeader. }
false;public;0;3;;public String getHeaderName() {     return headerName. }
false;public;1;3;;public void setHeaderName(String headerName) {     this.headerName = headerName. }
false;protected;0;3;;// Implementation methods // ----------------------------------------------------------------------- protected SchemaFactory createSchemaFactory() {     return schemaReader.createSchemaFactory(). }
false;protected;0;3;;protected Source createSchemaSource() throws IOException {     return schemaReader.createSchemaSource(). }
false;protected;0;3;;protected Schema createSchema() throws SAXException, IOException {     return schemaReader.createSchema(). }
true;protected;1;23;/**  * Checks whether we need an {@link InputStream} to access the message body  * or header.  * <p/>  * Depending on the content in the message body or header, we may not need  * to convert to {@link InputStream}.  *  * @param exchange the current exchange  * @return <tt>true</tt> to convert to {@link InputStream} beforehand  *         converting to {@link Source} afterwards.  */ ;/**  * Checks whether we need an {@link InputStream} to access the message body  * or header.  * <p/>  * Depending on the content in the message body or header, we may not need  * to convert to {@link InputStream}.  *  * @param exchange the current exchange  * @return <tt>true</tt> to convert to {@link InputStream} beforehand  *         converting to {@link Source} afterwards.  */ protected boolean isInputStreamNeeded(Exchange exchange) {     Object content = getContentToValidate(exchange).     if (content == null) {         return false.     }     if (content instanceof InputStream) {         return true.     } else if (content instanceof Source) {         return false.     } else if (content instanceof String) {         return false.     } else if (content instanceof byte[]) {         return false.     } else if (content instanceof Node) {         return false.     } else if (exchange.getContext().getTypeConverterRegistry().lookup(Source.class, content.getClass()) != null) {         // there is a direct and hopefully optimized converter to Source         return false.     }     // yes an input stream is needed     return true. }
true;protected;2;41;/**  * Converts the inbound body or header to a {@link Source}, if it is  * <b>not</b> already a {@link Source}.  * <p/>  * This implementation will prefer to source in the following order:  * <ul>  * <li>DOM - DOM if explicit configured to use DOM</li>  * <li>SAX - SAX as 2nd choice</li>  * <li>Stream - Stream as 3rd choice</li>  * <li>DOM - DOM as 4th choice</li>  * </ul>  */ ;/**  * Converts the inbound body or header to a {@link Source}, if it is  * <b>not</b> already a {@link Source}.  * <p/>  * This implementation will prefer to source in the following order:  * <ul>  * <li>DOM - DOM if explicit configured to use DOM</li>  * <li>SAX - SAX as 2nd choice</li>  * <li>Stream - Stream as 3rd choice</li>  * <li>DOM - DOM as 4th choice</li>  * </ul>  */ protected Source getSource(Exchange exchange, Object content) {     // body or header may already be a source     if (content instanceof Source) {         return (Source) content.     }     Source source = null.     if (content instanceof InputStream) {         return new StreamSource((InputStream) content).     }     if (content != null) {         TypeConverter tc = exchange.getContext().getTypeConverterRegistry().lookup(Source.class, content.getClass()).         if (tc != null) {             source = tc.convertTo(Source.class, exchange, content).         }     }     if (source == null) {         // then try SAX         source = exchange.getContext().getTypeConverter().tryConvertTo(SAXSource.class, exchange, content).     }     if (source == null) {         // then try stream         source = exchange.getContext().getTypeConverter().tryConvertTo(StreamSource.class, exchange, content).     }     if (source == null) {         // and fallback to DOM         source = exchange.getContext().getTypeConverter().tryConvertTo(DOMSource.class, exchange, content).     }     if (source == null) {         if (isFailOnNullBody()) {             throw new ExpectedBodyTypeException(exchange, Source.class).         } else {             try {                 source = converter.toDOMSource(converter.createDocument()).             } catch (ParserConfigurationException | TransformerException e) {                 throw new RuntimeTransformException(e).             }         }     }     return source. }
