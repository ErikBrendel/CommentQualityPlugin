commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Processor getProcessor() {     return this. }
false;public;0;3;;public boolean isBlockWhenFull() {     return blockWhenFull. }
false;public;1;3;;public void setBlockWhenFull(boolean blockWhenFull) {     this.blockWhenFull = blockWhenFull. }
false;public;0;3;;public long getBlockTimeout() {     return blockTimeout. }
false;public;1;3;;public void setBlockTimeout(long blockTimeout) {     this.blockTimeout = blockTimeout. }
true;public;0;3;/**  * Gets the queue capacity.  */ ;/**  * Gets the queue capacity.  */ public int getQueueCapacity() {     return queueCapacity. }
true;public;0;3;/**  * Gets the current queue size (no of elements in the queue).  */ ;/**  * Gets the current queue size (no of elements in the queue).  */ public int getQueueSize() {     return queue.size(). }
false;public;0;3;;public Exchange receiveNoWait() {     return receive(0). }
false;public;0;23;;public Exchange receive() {     // must be started     if (!isRunAllowed() || !isStarted()) {         throw new RejectedExecutionException(this + " is not started, but in state: " + getStatus().name()).     }     while (isRunAllowed()) {         // synchronizing the ordering of beforePoll, poll and afterPoll as an atomic activity         synchronized (this) {             try {                 beforePoll(0).                 // take will block waiting for message                 return queue.take().             } catch (InterruptedException e) {                 handleInterruptedException(e).             } finally {                 afterPoll().             }         }     }     log.trace("Consumer is not running, so returning null").     return null. }
false;public;1;20;;public Exchange receive(long timeout) {     // must be started     if (!isRunAllowed() || !isStarted()) {         throw new RejectedExecutionException(this + " is not started, but in state: " + getStatus().name()).     }     // synchronizing the ordering of beforePoll, poll and afterPoll as an atomic activity     synchronized (this) {         try {             // use the timeout value returned from beforePoll             timeout = beforePoll(timeout).             return queue.poll(timeout, TimeUnit.MILLISECONDS).         } catch (InterruptedException e) {             handleInterruptedException(e).             return null.         } finally {             afterPoll().         }     } }
false;public;1;19;;public void process(Exchange exchange) throws Exception {     if (isBlockWhenFull()) {         try {             if (getBlockTimeout() <= 0) {                 queue.put(exchange).             } else {                 boolean added = queue.offer(exchange, getBlockTimeout(), TimeUnit.MILLISECONDS).                 if (!added) {                     throw new ExchangeTimedOutException(exchange, getBlockTimeout()).                 }             }         } catch (InterruptedException e) {             // ignore             log.debug("Put interrupted, are we stopping? {}", isStopping() || isStopped()).         }     } else {         queue.add(exchange).     } }
false;public;0;3;;public ExceptionHandler getInterruptedExceptionHandler() {     return interruptedExceptionHandler. }
false;public;1;3;;public void setInterruptedExceptionHandler(ExceptionHandler interruptedExceptionHandler) {     this.interruptedExceptionHandler = interruptedExceptionHandler. }
false;public;0;3;;public Consumer getDelegateConsumer() {     return consumer. }
false;protected;1;3;;protected void handleInterruptedException(InterruptedException e) {     getInterruptedExceptionHandler().handleException(e). }
false;protected;1;11;;protected long beforePoll(long timeout) {     if (consumer instanceof PollingConsumerPollingStrategy) {         PollingConsumerPollingStrategy strategy = (PollingConsumerPollingStrategy) consumer.         try {             timeout = strategy.beforePoll(timeout).         } catch (Exception e) {             log.debug("Error occurred before polling " + consumer + ". This exception will be ignored.", e).         }     }     return timeout. }
false;protected;0;10;;protected void afterPoll() {     if (consumer instanceof PollingConsumerPollingStrategy) {         PollingConsumerPollingStrategy strategy = (PollingConsumerPollingStrategy) consumer.         try {             strategy.afterPoll().         } catch (Exception e) {             log.debug("Error occurred after polling " + consumer + ". This exception will be ignored.", e).         }     } }
false;protected;0;3;;protected Consumer getConsumer() {     return consumer. }
false;protected;0;3;;protected Consumer createConsumer() throws Exception {     return getEndpoint().createConsumer(this). }
false;protected;0;12;;protected void doStart() throws Exception {     // lets add ourselves as a consumer     consumer = createConsumer().     // if the consumer has a polling strategy then invoke that     if (consumer instanceof PollingConsumerPollingStrategy) {         PollingConsumerPollingStrategy strategy = (PollingConsumerPollingStrategy) consumer.         strategy.onInit().     } else {         ServiceHelper.startService(consumer).     } }
false;protected;0;3;;protected void doStop() throws Exception {     ServiceHelper.stopService(consumer). }
false;protected;0;4;;protected void doShutdown() throws Exception {     ServiceHelper.stopAndShutdownService(consumer).     queue.clear(). }
false;public;0;5;;@Override public // As the consumer could take the messages at once, so we cannot release the consumer boolean isSingleton() {     return true. }
