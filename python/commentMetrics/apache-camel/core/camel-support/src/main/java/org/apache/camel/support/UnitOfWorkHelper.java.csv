commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;22;/**  * Done and stop the {@link UnitOfWork}.  *  * @param uow the unit of work  * @param exchange the exchange (will unset the UoW on the exchange)  */ ;/**  * Done and stop the {@link UnitOfWork}.  *  * @param uow the unit of work  * @param exchange the exchange (will unset the UoW on the exchange)  */ public static void doneUow(UnitOfWork uow, Exchange exchange) {     // unit of work is done     try {         if (uow != null) {             uow.done(exchange).         }     } catch (Throwable e) {         LOG.warn("Exception occurred during done UnitOfWork for Exchange: " + exchange + ". This exception will be ignored.", e).     }     try {         if (uow != null) {             uow.stop().         }     } catch (Throwable e) {         LOG.warn("Exception occurred during stopping UnitOfWork for Exchange: " + exchange + ". This exception will be ignored.", e).     }     // remove uow from exchange as its done     exchange.setUnitOfWork(null). }
false;public,static;3;29;;public static void doneSynchronizations(Exchange exchange, List<Synchronization> synchronizations, Logger log) {     boolean failed = exchange.isFailed().     if (synchronizations != null && !synchronizations.isEmpty()) {         // work on a copy of the list to avoid any modification which may cause ConcurrentModificationException         List<Synchronization> copy = new ArrayList<>(synchronizations).         // reverse so we invoke it FILO style instead of FIFO         Collections.reverse(copy).         // and honor if any was ordered by sorting it accordingly         copy.sort(OrderedComparator.get()).         // invoke synchronization callbacks         for (Synchronization synchronization : copy) {             try {                 if (failed) {                     log.trace("Invoking synchronization.onFailure: {} with {}", synchronization, exchange).                     synchronization.onFailure(exchange).                 } else {                     log.trace("Invoking synchronization.onComplete: {} with {}", synchronization, exchange).                     synchronization.onComplete(exchange).                 }             } catch (Throwable e) {                 // must catch exceptions to ensure all synchronizations have a chance to run                 log.warn("Exception occurred during onCompletion. This exception will be ignored.", e).             }         }     } }
false;public,static;4;24;;public static void beforeRouteSynchronizations(Route route, Exchange exchange, List<Synchronization> synchronizations, Logger log) {     if (synchronizations != null && !synchronizations.isEmpty()) {         // work on a copy of the list to avoid any modification which may cause ConcurrentModificationException         List<Synchronization> copy = new ArrayList<>(synchronizations).         // reverse so we invoke it FILO style instead of FIFO         Collections.reverse(copy).         // and honor if any was ordered by sorting it accordingly         copy.sort(OrderedComparator.get()).         // invoke synchronization callbacks         for (Synchronization synchronization : copy) {             if (synchronization instanceof SynchronizationRouteAware) {                 try {                     log.trace("Invoking synchronization.onBeforeRoute: {} with {}", synchronization, exchange).                     ((SynchronizationRouteAware) synchronization).onBeforeRoute(route, exchange).                 } catch (Throwable e) {                     // must catch exceptions to ensure all synchronizations have a chance to run                     log.warn("Exception occurred during onBeforeRoute. This exception will be ignored.", e).                 }             }         }     } }
false;public,static;4;24;;public static void afterRouteSynchronizations(Route route, Exchange exchange, List<Synchronization> synchronizations, Logger log) {     if (synchronizations != null && !synchronizations.isEmpty()) {         // work on a copy of the list to avoid any modification which may cause ConcurrentModificationException         List<Synchronization> copy = new ArrayList<>(synchronizations).         // reverse so we invoke it FILO style instead of FIFO         Collections.reverse(copy).         // and honor if any was ordered by sorting it accordingly         copy.sort(OrderedComparator.get()).         // invoke synchronization callbacks         for (Synchronization synchronization : copy) {             if (synchronization instanceof SynchronizationRouteAware) {                 try {                     log.trace("Invoking synchronization.onAfterRoute: {} with {}", synchronization, exchange).                     ((SynchronizationRouteAware) synchronization).onAfterRoute(route, exchange).                 } catch (Throwable e) {                     // must catch exceptions to ensure all synchronizations have a chance to run                     log.warn("Exception occurred during onAfterRoute. This exception will be ignored.", e).                 }             }         }     } }
