commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;19;/**  * Warm-up the LRUCache to startup Apache Camel faster.  */ ;/**  * Warm-up the LRUCache to startup Apache Camel faster.  */ public static void warmUp() {     // as Caffeine takes 150+ millis to initialize.     if (INIT.compareAndSet(false, true)) {         // only need to init Caffeine once in the JVM/classloader         Runnable task = () -> {             StopWatch watch = new StopWatch().             LOG.debug("Warming up LRUCache ...").             newLRUCache(16).             LOG.debug("Warming up LRUCache complete in {} millis", watch.taken()).         }.         String threadName = ThreadHelper.resolveThreadName(null, "LRUCacheFactory").         Thread thread = new Thread(task, threadName).         thread.start().     } }
true;public,static;1;7;/**  * Constructs an empty <tt>LRUCache</tt> instance with the  * specified maximumCacheSize, and will stop on eviction.  *  * @param maximumCacheSize the max capacity.  * @throws IllegalArgumentException if the initial capacity is negative  */ ;/**  * Constructs an empty <tt>LRUCache</tt> instance with the  * specified maximumCacheSize, and will stop on eviction.  *  * @param maximumCacheSize the max capacity.  * @throws IllegalArgumentException if the initial capacity is negative  */ public static <K, V> Map<K, V> newLRUCache(int maximumCacheSize) {     LOG.trace("Creating LRUCache with maximumCacheSize: {}", maximumCacheSize).     if (USE_SIMPLE_CACHE) {         return new SimpleLRUCache<>(maximumCacheSize).     }     return new LRUCache<>(maximumCacheSize). }
true;public,static;2;7;/**  * Constructs an empty <tt>LRUCache</tt> instance with the  * specified maximumCacheSize, and will stop on eviction.  *  * @param maximumCacheSize the max capacity.  * @throws IllegalArgumentException if the initial capacity is negative  */ ;/**  * Constructs an empty <tt>LRUCache</tt> instance with the  * specified maximumCacheSize, and will stop on eviction.  *  * @param maximumCacheSize the max capacity.  * @throws IllegalArgumentException if the initial capacity is negative  */ public static <K, V> Map<K, V> newLRUCache(int maximumCacheSize, Consumer<V> onEvict) {     LOG.trace("Creating LRUCache with maximumCacheSize: {}", maximumCacheSize).     if (USE_SIMPLE_CACHE) {         return new SimpleLRUCache<>(16, maximumCacheSize, onEvict).     }     return new LRUCache<>(16, maximumCacheSize, onEvict, false, false, false). }
true;public,static;2;7;/**  * Constructs an empty <tt>LRUCache</tt> instance with the  * specified initial capacity, maximumCacheSize, and will stop on eviction.  *  * @param initialCapacity  the initial capacity.  * @param maximumCacheSize the max capacity.  * @throws IllegalArgumentException if the initial capacity is negative  */ ;/**  * Constructs an empty <tt>LRUCache</tt> instance with the  * specified initial capacity, maximumCacheSize, and will stop on eviction.  *  * @param initialCapacity  the initial capacity.  * @param maximumCacheSize the max capacity.  * @throws IllegalArgumentException if the initial capacity is negative  */ public static <K, V> Map<K, V> newLRUCache(int initialCapacity, int maximumCacheSize) {     LOG.trace("Creating LRUCache with initialCapacity: {}, maximumCacheSize: {}", initialCapacity, maximumCacheSize).     if (USE_SIMPLE_CACHE) {         return new SimpleLRUCache<>(initialCapacity, maximumCacheSize).     }     return new LRUCache<>(initialCapacity, maximumCacheSize). }
true;public,static;3;7;/**  * Constructs an empty <tt>LRUCache</tt> instance with the  * specified initial capacity, maximumCacheSize,load factor and ordering mode.  *  * @param initialCapacity  the initial capacity.  * @param maximumCacheSize the max capacity.  * @param stopOnEviction   whether to stop service on eviction.  * @throws IllegalArgumentException if the initial capacity is negative  */ ;/**  * Constructs an empty <tt>LRUCache</tt> instance with the  * specified initial capacity, maximumCacheSize,load factor and ordering mode.  *  * @param initialCapacity  the initial capacity.  * @param maximumCacheSize the max capacity.  * @param stopOnEviction   whether to stop service on eviction.  * @throws IllegalArgumentException if the initial capacity is negative  */ public static <K, V> Map<K, V> newLRUCache(int initialCapacity, int maximumCacheSize, boolean stopOnEviction) {     LOG.trace("Creating LRUCache with initialCapacity: {}, maximumCacheSize: {}, stopOnEviction: {}", initialCapacity, maximumCacheSize, stopOnEviction).     if (USE_SIMPLE_CACHE) {         return new SimpleLRUCache<>(initialCapacity, maximumCacheSize, stopOnEviction).     }     return new LRUCache<>(initialCapacity, maximumCacheSize, stopOnEviction). }
true;public,static;1;7;/**  * Constructs an empty <tt>LRUSoftCache</tt> instance with the  * specified maximumCacheSize, and will stop on eviction.  *  * @param maximumCacheSize the max capacity.  * @throws IllegalArgumentException if the initial capacity is negative  */ ;/**  * Constructs an empty <tt>LRUSoftCache</tt> instance with the  * specified maximumCacheSize, and will stop on eviction.  *  * @param maximumCacheSize the max capacity.  * @throws IllegalArgumentException if the initial capacity is negative  */ public static <K, V> Map<K, V> newLRUSoftCache(int maximumCacheSize) {     LOG.trace("Creating LRUSoftCache with maximumCacheSize: {}", maximumCacheSize).     if (USE_SIMPLE_CACHE) {         return new SimpleLRUCache<>(maximumCacheSize).     }     return new LRUSoftCache<>(maximumCacheSize). }
true;public,static;1;7;/**  * Constructs an empty <tt>LRUWeakCache</tt> instance with the  * specified maximumCacheSize, and will stop on eviction.  *  * @param maximumCacheSize the max capacity.  * @throws IllegalArgumentException if the initial capacity is negative  */ ;/**  * Constructs an empty <tt>LRUWeakCache</tt> instance with the  * specified maximumCacheSize, and will stop on eviction.  *  * @param maximumCacheSize the max capacity.  * @throws IllegalArgumentException if the initial capacity is negative  */ public static <K, V> Map<K, V> newLRUWeakCache(int maximumCacheSize) {     LOG.trace("Creating LRUWeakCache with maximumCacheSize: {}", maximumCacheSize).     if (USE_SIMPLE_CACHE) {         return new SimpleLRUCache<>(maximumCacheSize).     }     return new LRUWeakCache<>(maximumCacheSize). }
false;protected;1;9;;@Override protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {     if (size() >= maximumCacheSize) {         V value = eldest.getValue().         evict.accept(value).         return true.     }     return false. }
false;static;1;2;;static <V> void doNothing(V value) { }
false;static;1;8;;static <V> void doStop(V value) {     try {         // stop service as its evicted from cache         ServiceHelper.stopService(value).     } catch (Exception e) {         LOG.warn("Error stopping service: " + value + ". This exception will be ignored.", e).     } }
