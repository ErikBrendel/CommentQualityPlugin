commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public int hashCode() {     return getEndpointUri().hashCode() * 37 + 1. }
false;public;1;11;;@Override public boolean equals(Object object) {     if (object instanceof DefaultEndpoint) {         DefaultEndpoint that = (DefaultEndpoint) object.         // must also match the same CamelContext in case we compare endpoints from different contexts         String thisContextName = this.getCamelContext() != null ? this.getCamelContext().getName() : null.         String thatContextName = that.getCamelContext() != null ? that.getCamelContext().getName() : null.         return ObjectHelper.equal(this.getEndpointUri(), that.getEndpointUri()) && ObjectHelper.equal(thisContextName, thatContextName).     }     return false. }
false;public;0;14;;@Override public String toString() {     if (endpointUriToString == null) {         String value = null.         try {             value = getEndpointUri().         } catch (RuntimeException e) {         // ignore any exception and use null for building the string value         }         // ensure to sanitize uri so we do not show sensitive information such as passwords         endpointUriToString = URISupport.sanitizeUri(value).     }     return endpointUriToString. }
true;public;0;3;/**  * Returns a unique String ID which can be used for aliasing without having  * to use the whole URI which is not unique  */ ;/**  * Returns a unique String ID which can be used for aliasing without having  * to use the whole URI which is not unique  */ public String getId() {     return id. }
false;public;0;10;;public String getEndpointUri() {     if (endpointUri == null) {         endpointUri = createEndpointUri().         if (endpointUri == null) {             throw new IllegalArgumentException("endpointUri is not specified and " + getClass().getName() + " does not implement createEndpointUri() to create a default value").         }     }     return endpointUri. }
false;public;0;14;;public String getEndpointKey() {     if (isLenientProperties()) {         // only use the endpoint uri without parameters as the properties are lenient         String uri = getEndpointUri().         if (uri.indexOf('?') != -1) {             return StringHelper.before(uri, "?").         } else {             return uri.         }     } else {         // use the full endpoint uri         return getEndpointUri().     } }
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;0;4;;@Override public AsyncProducer createAsyncProducer() throws Exception {     return AsyncProcessorConverterHelper.convert(createProducer()). }
true;public;0;3;/**  * Returns the component that created this endpoint.  *  * @return the component that created this endpoint, or <tt>null</tt> if  *         none set  */ ;/**  * Returns the component that created this endpoint.  *  * @return the component that created this endpoint, or <tt>null</tt> if  *         none set  */ public Component getComponent() {     return component. }
false;public;1;3;;public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;0;11;;public PollingConsumer createPollingConsumer() throws Exception {     // should not call configurePollingConsumer when its EventDrivenPollingConsumer     if (log.isDebugEnabled()) {         log.debug("Creating EventDrivenPollingConsumer with queueSize: {} blockWhenFull: {} blockTimeout: {}", new Object[] { getPollingConsumerQueueSize(), isPollingConsumerBlockWhenFull(), getPollingConsumerBlockTimeout() }).     }     EventDrivenPollingConsumer consumer = new EventDrivenPollingConsumer(this, getPollingConsumerQueueSize()).     consumer.setBlockWhenFull(isPollingConsumerBlockWhenFull()).     consumer.setBlockTimeout(getPollingConsumerBlockTimeout()).     return consumer. }
false;public;0;3;;public Exchange createExchange() {     return createExchange(getExchangePattern()). }
false;public;1;3;;public Exchange createExchange(ExchangePattern pattern) {     return new DefaultExchange(this, pattern). }
true;public;0;3;/**  * Returns the default exchange pattern to use when creating an exchange.  */ ;/**  * Returns the default exchange pattern to use when creating an exchange.  */ public ExchangePattern getExchangePattern() {     return exchangePattern. }
true;public;1;3;/**  * Sets the default exchange pattern when creating an exchange.  */ ;/**  * Sets the default exchange pattern when creating an exchange.  */ public void setExchangePattern(ExchangePattern exchangePattern) {     this.exchangePattern = exchangePattern. }
true;public;0;3;/**  * Returns whether synchronous processing should be strictly used.  */ ;/**  * Returns whether synchronous processing should be strictly used.  */ public boolean isSynchronous() {     return synchronous. }
true;public;1;3;/**  * Sets whether synchronous processing should be strictly used, or Camel is  * allowed to use asynchronous processing (if supported).  *  * @param synchronous <tt>true</tt> to enforce synchronous processing  */ ;/**  * Sets whether synchronous processing should be strictly used, or Camel is  * allowed to use asynchronous processing (if supported).  *  * @param synchronous <tt>true</tt> to enforce synchronous processing  */ public void setSynchronous(boolean synchronous) {     this.synchronous = synchronous. }
false;public;0;3;;public boolean isBridgeErrorHandler() {     return bridgeErrorHandler. }
true;public;1;3;/**  * Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while  * the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and  * handled by the routing Error Handler.  * <p/>  * By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions,  * that will be logged at WARN/ERROR level and ignored.  */ ;/**  * Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while  * the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and  * handled by the routing Error Handler.  * <p/>  * By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions,  * that will be logged at WARN/ERROR level and ignored.  */ public void setBridgeErrorHandler(boolean bridgeErrorHandler) {     this.bridgeErrorHandler = bridgeErrorHandler. }
false;public;0;3;;public ExceptionHandler getExceptionHandler() {     return exceptionHandler. }
true;public;1;3;/**  * To let the consumer use a custom ExceptionHandler.  *     + Notice if the option bridgeErrorHandler is enabled then this options is not in use.  *     + By default the consumer will deal with exceptions, that will be logged at WARN/ERROR level and ignored.  */ ;/**  * To let the consumer use a custom ExceptionHandler.  *     + Notice if the option bridgeErrorHandler is enabled then this options is not in use.  *     + By default the consumer will deal with exceptions, that will be logged at WARN/ERROR level and ignored.  */ public void setExceptionHandler(ExceptionHandler exceptionHandler) {     this.exceptionHandler = exceptionHandler. }
true;public;0;3;/**  * Gets the {@link org.apache.camel.PollingConsumer} queue size, when {@link EventDrivenPollingConsumer}  * is being used. Notice some Camel components may have their own implementation of {@link org.apache.camel.PollingConsumer} and  * therefore not using the default {@link EventDrivenPollingConsumer} implementation.  * <p/>  * The default value is <tt>1000</tt>  */ ;/**  * Gets the {@link org.apache.camel.PollingConsumer} queue size, when {@link EventDrivenPollingConsumer}  * is being used. Notice some Camel components may have their own implementation of {@link org.apache.camel.PollingConsumer} and  * therefore not using the default {@link EventDrivenPollingConsumer} implementation.  * <p/>  * The default value is <tt>1000</tt>  */ public int getPollingConsumerQueueSize() {     return pollingConsumerQueueSize. }
true;public;1;3;/**  * Sets the {@link org.apache.camel.PollingConsumer} queue size, when {@link EventDrivenPollingConsumer}  * is being used. Notice some Camel components may have their own implementation of {@link org.apache.camel.PollingConsumer} and  * therefore not using the default {@link EventDrivenPollingConsumer} implementation.  * <p/>  * The default value is <tt>1000</tt>  */ ;/**  * Sets the {@link org.apache.camel.PollingConsumer} queue size, when {@link EventDrivenPollingConsumer}  * is being used. Notice some Camel components may have their own implementation of {@link org.apache.camel.PollingConsumer} and  * therefore not using the default {@link EventDrivenPollingConsumer} implementation.  * <p/>  * The default value is <tt>1000</tt>  */ public void setPollingConsumerQueueSize(int pollingConsumerQueueSize) {     this.pollingConsumerQueueSize = pollingConsumerQueueSize. }
true;public;0;3;/**  * Whether to block when adding to the internal queue off when {@link EventDrivenPollingConsumer}  * is being used. Notice some Camel components may have their own implementation of {@link org.apache.camel.PollingConsumer} and  * therefore not using the default {@link EventDrivenPollingConsumer} implementation.  * <p/>  * Setting this option to <tt>false</tt>, will result in an {@link java.lang.IllegalStateException} being thrown  * when trying to add to the queue, and its full.  * <p/>  * The default value is <tt>true</tt> which will block the producer queue until the queue has space.  */ ;/**  * Whether to block when adding to the internal queue off when {@link EventDrivenPollingConsumer}  * is being used. Notice some Camel components may have their own implementation of {@link org.apache.camel.PollingConsumer} and  * therefore not using the default {@link EventDrivenPollingConsumer} implementation.  * <p/>  * Setting this option to <tt>false</tt>, will result in an {@link java.lang.IllegalStateException} being thrown  * when trying to add to the queue, and its full.  * <p/>  * The default value is <tt>true</tt> which will block the producer queue until the queue has space.  */ public boolean isPollingConsumerBlockWhenFull() {     return pollingConsumerBlockWhenFull. }
true;public;1;3;/**  * Set whether to block when adding to the internal queue off when {@link EventDrivenPollingConsumer}  * is being used. Notice some Camel components may have their own implementation of {@link org.apache.camel.PollingConsumer} and  * therefore not using the default {@link EventDrivenPollingConsumer} implementation.  * <p/>  * Setting this option to <tt>false</tt>, will result in an {@link java.lang.IllegalStateException} being thrown  * when trying to add to the queue, and its full.  * <p/>  * The default value is <tt>true</tt> which will block the producer queue until the queue has space.  */ ;/**  * Set whether to block when adding to the internal queue off when {@link EventDrivenPollingConsumer}  * is being used. Notice some Camel components may have their own implementation of {@link org.apache.camel.PollingConsumer} and  * therefore not using the default {@link EventDrivenPollingConsumer} implementation.  * <p/>  * Setting this option to <tt>false</tt>, will result in an {@link java.lang.IllegalStateException} being thrown  * when trying to add to the queue, and its full.  * <p/>  * The default value is <tt>true</tt> which will block the producer queue until the queue has space.  */ public void setPollingConsumerBlockWhenFull(boolean pollingConsumerBlockWhenFull) {     this.pollingConsumerBlockWhenFull = pollingConsumerBlockWhenFull. }
true;public;0;3;/**  * Sets the timeout in millis to use when adding to the internal queue off when {@link EventDrivenPollingConsumer}  * is being used.  *  * @see #setPollingConsumerBlockWhenFull(boolean)  */ ;/**  * Sets the timeout in millis to use when adding to the internal queue off when {@link EventDrivenPollingConsumer}  * is being used.  *  * @see #setPollingConsumerBlockWhenFull(boolean)  */ public long getPollingConsumerBlockTimeout() {     return pollingConsumerBlockTimeout. }
true;public;1;3;/**  * Sets the timeout in millis to use when adding to the internal queue off when {@link EventDrivenPollingConsumer}  * is being used.  *  * @see #setPollingConsumerBlockWhenFull(boolean)  */ ;/**  * Sets the timeout in millis to use when adding to the internal queue off when {@link EventDrivenPollingConsumer}  * is being used.  *  * @see #setPollingConsumerBlockWhenFull(boolean)  */ public void setPollingConsumerBlockTimeout(long pollingConsumerBlockTimeout) {     this.pollingConsumerBlockTimeout = pollingConsumerBlockTimeout. }
false;public;1;6;;public void configureProperties(Map<String, Object> options) {     Map<String, Object> consumerProperties = IntrospectionSupport.extractProperties(options, "consumer.").     if (consumerProperties != null && !consumerProperties.isEmpty()) {         setConsumerProperties(consumerProperties).     } }
true;protected;2;5;/**  * Sets the bean properties on the given bean.  * <p/>  * This is the same logical implementation as {@link DefaultComponent#setProperties(Object, java.util.Map)}  *  * @param bean  the bean  * @param parameters  properties to set  */ ;/**  * Sets the bean properties on the given bean.  * <p/>  * This is the same logical implementation as {@link DefaultComponent#setProperties(Object, java.util.Map)}  *  * @param bean  the bean  * @param parameters  properties to set  */ protected void setProperties(Object bean, Map<String, Object> parameters) throws Exception {     // set reference properties first as they use # syntax that fools the regular properties setter     EndpointHelper.setReferenceProperties(getCamelContext(), bean, parameters).     EndpointHelper.setProperties(getCamelContext(), bean, parameters). }
true;protected;0;3;/**  * A factory method to lazily create the endpointUri if none is specified  */ ;/**  * A factory method to lazily create the endpointUri if none is specified  */ protected String createEndpointUri() {     return null. }
true;public;1;5;/**  * Sets the endpointUri if it has not been specified yet via some kind of  * dependency injection mechanism. This allows dependency injection  * frameworks such as Spring or Guice to set the default endpoint URI in  * cases where it has not been explicitly configured using the name/context  * in which an Endpoint is created.  */ ;/**  * Sets the endpointUri if it has not been specified yet via some kind of  * dependency injection mechanism. This allows dependency injection  * frameworks such as Spring or Guice to set the default endpoint URI in  * cases where it has not been explicitly configured using the name/context  * in which an Endpoint is created.  */ public void setEndpointUriIfNotSpecified(String value) {     if (endpointUri == null) {         setEndpointUri(value).     } }
true;protected;1;3;/**  * Sets the URI that created this endpoint.  */ ;/**  * Sets the URI that created this endpoint.  */ protected void setEndpointUri(String endpointUri) {     this.endpointUri = endpointUri. }
false;public;0;4;;public boolean isLenientProperties() {     // default should be false for most components     return false. }
false;public;0;7;;public Map<String, Object> getConsumerProperties() {     if (consumerProperties == null) {         // must create empty if none exists         consumerProperties = new HashMap<>().     }     return consumerProperties. }
false;public;1;10;;public void setConsumerProperties(Map<String, Object> consumerProperties) {     // append consumer properties     if (consumerProperties != null && !consumerProperties.isEmpty()) {         if (this.consumerProperties == null) {             this.consumerProperties = new HashMap<>(consumerProperties).         } else {             this.consumerProperties.putAll(consumerProperties).         }     } }
false;protected;1;35;;protected void configureConsumer(Consumer consumer) throws Exception {     // inject CamelContext     if (consumer instanceof CamelContextAware) {         ((CamelContextAware) consumer).setCamelContext(getCamelContext()).     }     if (consumerProperties != null) {         // use a defensive copy of the consumer properties as the methods below will remove the used properties         // and in case we restart routes, we need access to the original consumer properties again         Map<String, Object> copy = new HashMap<>(consumerProperties).         // set reference properties first as they use # syntax that fools the regular properties setter         EndpointHelper.setReferenceProperties(getCamelContext(), consumer, copy).         EndpointHelper.setProperties(getCamelContext(), consumer, copy).         // special consumer.bridgeErrorHandler option         Object bridge = copy.remove("bridgeErrorHandler").         if (bridge != null && "true".equals(bridge)) {             if (consumer instanceof DefaultConsumer) {                 DefaultConsumer defaultConsumer = (DefaultConsumer) consumer.                 defaultConsumer.setExceptionHandler(new BridgeExceptionHandlerToErrorHandler(defaultConsumer)).             } else {                 throw new IllegalArgumentException("Option consumer.bridgeErrorHandler is only supported by endpoints," + " having their consumer extend DefaultConsumer. The consumer is a " + consumer.getClass().getName() + " class.").             }         }         if (!this.isLenientProperties() && copy.size() > 0) {             throw new ResolveEndpointFailedException(this.getEndpointUri(), "There are " + copy.size() + " parameters that couldn't be set on the endpoint consumer." + " Check the uri if the parameters are spelt correctly and that they are properties of the endpoint." + " Unknown consumer parameters=[" + copy + "]").         }     } }
false;protected;1;3;;protected void configurePollingConsumer(PollingConsumer consumer) throws Exception {     configureConsumer(consumer). }
false;protected;0;11;;@Override protected void doStart() throws Exception {     // so if they have been configured on the endpoint then map to the old naming style     if (bridgeErrorHandler) {         getConsumerProperties().put("bridgeErrorHandler", "true").     }     if (exceptionHandler != null) {         getConsumerProperties().put("exceptionHandler", exceptionHandler).     } }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
