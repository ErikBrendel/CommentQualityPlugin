commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Gets methods that match the given name and arguments.<p/>  * Note that the args list is a required subset of arguments for returned methods.  *  * @param name case sensitive method name or alias to lookup  * @return non-null unmodifiable list of methods that take all of the given arguments, empty if there is no match  */ ;/**  * Gets methods that match the given name and arguments.<p/>  * Note that the args list is a required subset of arguments for returned methods.  *  * @param name case sensitive method name or alias to lookup  * @return non-null unmodifiable list of methods that take all of the given arguments, empty if there is no match  */ public List<ApiMethod> getCandidateMethods(String name) {     return getCandidateMethods(name, Collections.emptyList()). }
true;public;2;27;/**  * Gets methods that match the given name and arguments.<p/>  * Note that the args list is a required subset of arguments for returned methods.  *  * @param name case sensitive method name or alias to lookup  * @param argNames unordered required argument names  * @return non-null unmodifiable list of methods that take all of the given arguments, empty if there is no match  */ ;/**  * Gets methods that match the given name and arguments.<p/>  * Note that the args list is a required subset of arguments for returned methods.  *  * @param name case sensitive method name or alias to lookup  * @param argNames unordered required argument names  * @return non-null unmodifiable list of methods that take all of the given arguments, empty if there is no match  */ public List<ApiMethod> getCandidateMethods(String name, Collection<String> argNames) {     List<T> methods = methodMap.get(name).     if (methods == null) {         if (aliasesMap.containsKey(name)) {             methods = new ArrayList<>().             for (String method : aliasesMap.get(name)) {                 methods.addAll(methodMap.get(method)).             }         }     }     if (methods == null) {         LOG.debug("No matching method for method {}", name).         return Collections.emptyList().     }     int nArgs = argNames != null ? argNames.size() : 0.     if (nArgs == 0) {         LOG.debug("Found {} methods for method {}", methods.size(), name).         return Collections.unmodifiableList(methods).     } else {         final List<ApiMethod> filteredSet = filterMethods(methods, MatchType.SUBSET, argNames).         if (LOG.isDebugEnabled()) {             LOG.debug("Found {} filtered methods for {}", filteredSet.size(), name + argNames.toString().replace('[', '(').replace(']', ')')).         }         return filteredSet.     } }
true;public;2;3;/**  * Filters a list of methods to those that take the given set of arguments.  *  * @param methods list of methods to filter  * @param matchType whether the arguments are an exact match, a subset or a super set of method args  * @return methods with arguments that satisfy the match type.<p/>  * For SUPER_SET match, if methods with exact match are found, methods that take a subset are ignored  */ ;/**  * Filters a list of methods to those that take the given set of arguments.  *  * @param methods list of methods to filter  * @param matchType whether the arguments are an exact match, a subset or a super set of method args  * @return methods with arguments that satisfy the match type.<p/>  * For SUPER_SET match, if methods with exact match are found, methods that take a subset are ignored  */ public List<ApiMethod> filterMethods(List<? extends ApiMethod> methods, MatchType matchType) {     return filterMethods(methods, matchType, Collections.emptyList()). }
true;public;3;68;/**  * Filters a list of methods to those that take the given set of arguments.  *  * @param methods list of methods to filter  * @param matchType whether the arguments are an exact match, a subset or a super set of method args  * @param argNames argument names to filter the list  * @return methods with arguments that satisfy the match type.<p/>  * For SUPER_SET match, if methods with exact match are found, methods that take a subset are ignored  */ ;/**  * Filters a list of methods to those that take the given set of arguments.  *  * @param methods list of methods to filter  * @param matchType whether the arguments are an exact match, a subset or a super set of method args  * @param argNames argument names to filter the list  * @return methods with arguments that satisfy the match type.<p/>  * For SUPER_SET match, if methods with exact match are found, methods that take a subset are ignored  */ public List<ApiMethod> filterMethods(List<? extends ApiMethod> methods, MatchType matchType, Collection<String> argNames) {     // original arguments     // supplied arguments with missing nullable arguments     final List<String> withNullableArgsList.     if (!nullableArguments.isEmpty()) {         withNullableArgsList = new ArrayList<>(argNames).         withNullableArgsList.addAll(nullableArguments).     } else {         withNullableArgsList = null.     }     // list of methods that have all args in the given names     List<ApiMethod> result = new ArrayList<>().     List<ApiMethod> extraArgs = null.     List<ApiMethod> nullArgs = null.     for (ApiMethod method : methods) {         final List<String> methodArgs = method.getArgNames().         switch(matchType) {             case EXACT:                 // method must take all args, and no more                 if (methodArgs.containsAll(argNames) && argNames.containsAll(methodArgs)) {                     result.add(method).                 }                 break.             case SUBSET:                 // all args are required, method may take more                 if (methodArgs.containsAll(argNames)) {                     result.add(method).                 }                 break.             default:             case SUPER_SET:                 // all method args must be present                 if (argNames.containsAll(methodArgs)) {                     if (methodArgs.containsAll(argNames)) {                         // prefer exact match to avoid unused args                         result.add(method).                     } else if (result.isEmpty()) {                         // if result is empty, add method to extra args list                         if (extraArgs == null) {                             extraArgs = new ArrayList<>().                         }                         // method takes a subset, unused args                         extraArgs.add(method).                     }                 } else if (result.isEmpty() && extraArgs == null) {                     // avoid looking for nullable args by checking for empty result and extraArgs                     if (withNullableArgsList != null && withNullableArgsList.containsAll(methodArgs)) {                         if (nullArgs == null) {                             nullArgs = new ArrayList<>().                         }                         nullArgs.add(method).                     }                 }                 break.         }     }     List<ApiMethod> methodList = result.isEmpty() ? extraArgs == null ? nullArgs : extraArgs : result.     // preference order is exact match, matches with extra args, matches with null args     return methodList != null ? Collections.unmodifiableList(methodList) : Collections.emptyList(). }
true;public;1;15;/**  * Gets argument types and names for all overloaded methods and aliases with the given name.  * @param name method name, either an exact name or an alias, exact matches are checked first  * @return list of arguments of the form Class type1, String name1, Class type2, String name2,...  */ ;/**  * Gets argument types and names for all overloaded methods and aliases with the given name.  * @param name method name, either an exact name or an alias, exact matches are checked first  * @return list of arguments of the form Class type1, String name1, Class type2, String name2,...  */ public List<Object> getArguments(final String name) throws IllegalArgumentException {     List<Object> arguments = argumentsMap.get(name).     if (arguments == null) {         if (aliasesMap.containsKey(name)) {             arguments = new ArrayList<>().             for (String method : aliasesMap.get(name)) {                 arguments.addAll(argumentsMap.get(method)).             }         }     }     if (arguments == null) {         throw new IllegalArgumentException(name).     }     return Collections.unmodifiableList(arguments). }
true;public;2;13;/**  * Get missing properties.  * @param methodName method name  * @param argNames available arguments  * @return Set of missing argument names  */ ;/**  * Get missing properties.  * @param methodName method name  * @param argNames available arguments  * @return Set of missing argument names  */ public Set<String> getMissingProperties(String methodName, Set<String> argNames) {     final List<Object> argsWithTypes = getArguments(methodName).     final Set<String> missingArgs = new HashSet<>().     for (int i = 1. i < argsWithTypes.size(). i += 2) {         final String name = (String) argsWithTypes.get(i).         if (!argNames.contains(name)) {             missingArgs.add(name).         }     }     return missingArgs. }
true;public;0;3;/**  * Returns alias map.  * @return alias names mapped to method names.  */ ;/**  * Returns alias map.  * @return alias names mapped to method names.  */ public Map<String, Set<String>> getAliases() {     return aliasesMap. }
true;public;0;3;/**  * Returns argument types and names used by all methods.  * @return map with argument names as keys, and types as values  */ ;/**  * Returns argument types and names used by all methods.  * @return map with argument names as keys, and types as values  */ public Map<String, Class<?>> allArguments() {     return validArguments. }
true;public;0;3;/**  * Returns argument names that can be set to null if not specified.  * @return list of argument names  */ ;/**  * Returns argument names that can be set to null if not specified.  * @return list of argument names  */ public List<String> getNullableArguments() {     return nullableArguments. }
true;public;1;7;/**  * Get the type for the given argument name.  * @param argName argument name  * @return argument type  */ ;/**  * Get the type for the given argument name.  * @param argName argument name  * @return argument type  */ public Class<?> getType(String argName) throws IllegalArgumentException {     final Class<?> type = validArguments.get(argName).     if (type == null) {         throw new IllegalArgumentException(argName).     }     return type. }
true;public,static;1;10;// the alternative of trying to convert ApiMethod and associated classes to generic classes would a bear!!! ;// this method is always called with Enum value lists, so the cast inside is safe // the alternative of trying to convert ApiMethod and associated classes to generic classes would a bear!!! @SuppressWarnings("unchecked") public static ApiMethod getHighestPriorityMethod(List<? extends ApiMethod> filteredMethods) {     Comparable<ApiMethod> highest = null.     for (ApiMethod method : filteredMethods) {         if (highest == null || highest.compareTo(method) <= 0) {             highest = (Comparable<ApiMethod>) method.         }     }     return (ApiMethod) highest. }
true;public,static;3;64;/**  * Invokes given method with argument values from given properties.  *  * @param proxy Proxy object for invoke  * @param method method to invoke  * @param properties Map of arguments  * @return result of method invocation  * @throws org.apache.camel.RuntimeCamelException on errors  */ ;/**  * Invokes given method with argument values from given properties.  *  * @param proxy Proxy object for invoke  * @param method method to invoke  * @param properties Map of arguments  * @return result of method invocation  * @throws org.apache.camel.RuntimeCamelException on errors  */ public static Object invokeMethod(Object proxy, ApiMethod method, Map<String, Object> properties) throws RuntimeCamelException {     if (LOG.isDebugEnabled()) {         LOG.debug("Invoking {} with arguments {}", method.getName(), properties).     }     final List<String> argNames = method.getArgNames().     final Object[] values = new Object[argNames.size()].     final List<Class<?>> argTypes = method.getArgTypes().     final Class<?>[] types = argTypes.toArray(new Class[argTypes.size()]).     int index = 0.     for (String name : argNames) {         Object value = properties.get(name).         // is the parameter an array type?         if (value != null && types[index].isArray()) {             Class<?> type = types[index].             if (value instanceof Collection) {                 // convert collection to array                 Collection<?> collection = (Collection<?>) value.                 Object array = Array.newInstance(type.getComponentType(), collection.size()).                 if (array instanceof Object[]) {                     collection.toArray((Object[]) array).                 } else {                     int i = 0.                     for (Object el : collection) {                         Array.set(array, i++, el).                     }                 }                 value = array.             } else if (value.getClass().isArray() && type.getComponentType().isAssignableFrom(value.getClass().getComponentType())) {                 // convert derived array to super array if needed                 if (type.getComponentType() != value.getClass().getComponentType()) {                     final int size = Array.getLength(value).                     Object array = Array.newInstance(type.getComponentType(), size).                     for (int i = 0. i < size. i++) {                         Array.set(array, i, Array.get(value, i)).                     }                     value = array.                 }             } else {                 throw new IllegalArgumentException(String.format("Cannot convert %s to %s", value.getClass(), type)).             }         }         values[index++] = value.     }     try {         return method.getMethod().invoke(proxy, values).     } catch (Throwable e) {         if (e instanceof InvocationTargetException) {             // get API exception             final Throwable cause = e.getCause().             e = (cause != null) ? cause : e.         }         throw new RuntimeCamelException(String.format("Error invoking %s with %s: %s", method.getName(), properties, e.getMessage()), e).     } }
