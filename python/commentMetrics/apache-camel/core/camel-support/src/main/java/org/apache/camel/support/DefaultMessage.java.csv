commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isFault() {     return fault. }
false;public;1;3;;public void setFault(boolean fault) {     this.fault = fault. }
false;public;1;7;;public Object getHeader(String name) {     if (hasHeaders()) {         return getHeaders().get(name).     } else {         return null.     } }
false;public;2;4;;public Object getHeader(String name, Object defaultValue) {     Object answer = getHeaders().get(name).     return answer != null ? answer : defaultValue. }
false;public;2;6;;public Object getHeader(String name, Supplier<Object> defaultValueSupplier) {     ObjectHelper.notNull(name, "name").     ObjectHelper.notNull(defaultValueSupplier, "defaultValueSupplier").     Object answer = getHeaders().get(name).     return answer != null ? answer : defaultValueSupplier.get(). }
false;public;2;24;;@SuppressWarnings("unchecked") public <T> T getHeader(String name, Class<T> type) {     Object value = getHeader(name).     if (value == null) {         // lets avoid NullPointerException when converting to boolean for null values         if (boolean.class == type) {             return (T) Boolean.FALSE.         }         return null.     }     // if already same type     if (type.isInstance(value)) {         return type.cast(value).     }     Exchange e = getExchange().     if (e != null) {         return e.getContext().getTypeConverter().convertTo(type, e, value).     } else {         return type.cast(value).     } }
false;public;3;24;;@SuppressWarnings("unchecked") public <T> T getHeader(String name, Object defaultValue, Class<T> type) {     Object value = getHeader(name, defaultValue).     if (value == null) {         // lets avoid NullPointerException when converting to boolean for null values         if (boolean.class == type) {             return (T) Boolean.FALSE.         }         return null.     }     // if already same type     if (type.isInstance(value)) {         return type.cast(value).     }     Exchange e = getExchange().     if (e != null) {         return e.getContext().getTypeConverter().convertTo(type, e, value).     } else {         return type.cast(value).     } }
false;public;3;27;;@SuppressWarnings("unchecked") public <T> T getHeader(String name, Supplier<Object> defaultValueSupplier, Class<T> type) {     ObjectHelper.notNull(name, "name").     ObjectHelper.notNull(type, "type").     ObjectHelper.notNull(defaultValueSupplier, "defaultValueSupplier").     Object value = getHeader(name, defaultValueSupplier).     if (value == null) {         // lets avoid NullPointerException when converting to boolean for null values         if (boolean.class == type) {             return (T) Boolean.FALSE.         }         return null.     }     // if already same type     if (type.isInstance(value)) {         return type.cast(value).     }     Exchange e = getExchange().     if (e != null) {         return e.getContext().getTypeConverter().convertTo(type, e, value).     } else {         return type.cast(value).     } }
false;public;2;6;;public void setHeader(String name, Object value) {     if (headers == null) {         headers = createHeaders().     }     headers.put(name, value). }
false;public;1;6;;public Object removeHeader(String name) {     if (!hasHeaders()) {         return null.     }     return headers.remove(name). }
false;public;1;3;;public boolean removeHeaders(String pattern) {     return removeHeaders(pattern, (String[]) null). }
false;public;2;25;;public boolean removeHeaders(String pattern, String... excludePatterns) {     if (!hasHeaders()) {         return false.     }     boolean matches = false.     // must use a set to store the keys to remove as we cannot walk using entrySet and remove at the same time     // due concurrent modification error     Set<String> toRemove = new HashSet<>().     for (Map.Entry<String, Object> entry : headers.entrySet()) {         String key = entry.getKey().         if (PatternHelper.matchPattern(key, pattern)) {             if (excludePatterns != null && PatternHelper.isExcludePatternMatch(key, excludePatterns)) {                 continue.             }             matches = true.             toRemove.add(entry.getKey()).         }     }     for (String key : toRemove) {         headers.remove(key).     }     return matches. }
false;public;0;6;;public Map<String, Object> getHeaders() {     if (headers == null) {         headers = createHeaders().     }     return headers. }
false;public;1;10;;public void setHeaders(Map<String, Object> headers) {     ObjectHelper.notNull(getCamelContext(), "CamelContext", this).     if (getCamelContext().getHeadersMapFactory().isInstanceOf(headers)) {         this.headers = headers.     } else {         // create a new map         this.headers = getCamelContext().getHeadersMapFactory().newMap(headers).     } }
false;public;0;7;;public boolean hasHeaders() {     if (!hasPopulatedHeaders()) {         // force creating headers         getHeaders().     }     return headers != null && !headers.isEmpty(). }
false;public;0;5;;public DefaultMessage newInstance() {     ObjectHelper.notNull(getCamelContext(), "CamelContext", this).     return new DefaultMessage(getCamelContext()). }
true;protected;0;7;/**  * A factory method to lazily create the headers to make it easy to create  * efficient Message implementations which only construct and populate the  * Map on demand  *  * @return return a newly constructed Map possibly containing headers from  *         the underlying inbound transport  */ ;/**  * A factory method to lazily create the headers to make it easy to create  * efficient Message implementations which only construct and populate the  * Map on demand  *  * @return return a newly constructed Map possibly containing headers from  *         the underlying inbound transport  */ protected Map<String, Object> createHeaders() {     ObjectHelper.notNull(getCamelContext(), "CamelContext", this).     Map<String, Object> map = getCamelContext().getHeadersMapFactory().newMap().     populateInitialHeaders(map).     return map. }
true;protected;0;5;/**  * A factory method to lazily create the attachmentObjects to make it easy to  * create efficient Message implementations which only construct and  * populate the Map on demand  *  * @return return a newly constructed Map  */ ;/**  * A factory method to lazily create the attachmentObjects to make it easy to  * create efficient Message implementations which only construct and  * populate the Map on demand  *  * @return return a newly constructed Map  */ protected Map<String, Attachment> createAttachments() {     Map<String, Attachment> map = new LinkedHashMap<>().     populateInitialAttachments(map).     return map. }
true;protected;1;3;/**  * A strategy method populate the initial set of headers on an inbound  * message from an underlying binding  *  * @param map is the empty header map to populate  */ ;/**  * A strategy method populate the initial set of headers on an inbound  * message from an underlying binding  *  * @param map is the empty header map to populate  */ protected void populateInitialHeaders(Map<String, Object> map) { // do nothing by default }
true;protected;1;3;/**  * A strategy method populate the initial set of attachmentObjects on an inbound  * message from an underlying binding  *  * @param map is the empty attachment map to populate  */ ;/**  * A strategy method populate the initial set of attachmentObjects on an inbound  * message from an underlying binding  *  * @param map is the empty attachment map to populate  */ protected void populateInitialAttachments(Map<String, Attachment> map) { // do nothing by default }
true;protected;0;4;/**  * A strategy for component specific messages to determine whether the  * message is redelivered or not.  * <p/>  * <b>Important: </b> It is not always possible to determine if the transacted is a redelivery  * or not, and therefore <tt>null</tt> is returned. Such an example would be a JDBC message.  * However JMS brokers provides details if a transacted message is redelivered.  *  * @return <tt>true</tt> if redelivered, <tt>false</tt> if not, <tt>null</tt> if not able to determine  */ ;/**  * A strategy for component specific messages to determine whether the  * message is redelivered or not.  * <p/>  * <b>Important: </b> It is not always possible to determine if the transacted is a redelivery  * or not, and therefore <tt>null</tt> is returned. Such an example would be a JDBC message.  * However JMS brokers provides details if a transacted message is redelivered.  *  * @return <tt>true</tt> if redelivered, <tt>false</tt> if not, <tt>null</tt> if not able to determine  */ protected Boolean isTransactedRedelivered() {     // return null by default     return null. }
false;public;2;3;;public void addAttachment(String id, DataHandler content) {     addAttachmentObject(id, new DefaultAttachment(content)). }
false;public;2;6;;public void addAttachmentObject(String id, Attachment content) {     if (attachmentObjects == null) {         attachmentObjects = createAttachments().     }     attachmentObjects.put(id, content). }
false;public;1;8;;public DataHandler getAttachment(String id) {     Attachment att = getAttachmentObject(id).     if (att == null) {         return null.     } else {         return att.getDataHandler().     } }
false;public;1;4;;@Override public Attachment getAttachmentObject(String id) {     return getAttachmentObjects().get(id). }
false;public;0;6;;public Set<String> getAttachmentNames() {     if (attachmentObjects == null) {         attachmentObjects = createAttachments().     }     return attachmentObjects.keySet(). }
false;public;1;5;;public void removeAttachment(String id) {     if (attachmentObjects != null && attachmentObjects.containsKey(id)) {         attachmentObjects.remove(id).     } }
false;public;0;6;;public Map<String, DataHandler> getAttachments() {     if (attachments == null) {         attachments = new AttachmentMap(getAttachmentObjects()).     }     return attachments. }
false;public;0;6;;public Map<String, Attachment> getAttachmentObjects() {     if (attachmentObjects == null) {         attachmentObjects = createAttachments().     }     return attachmentObjects. }
false;public;1;14;;public void setAttachments(Map<String, DataHandler> attachments) {     if (attachments == null) {         this.attachmentObjects = null.     } else if (attachments instanceof AttachmentMap) {         // this way setAttachments(getAttachments()) will tunnel attachment headers         this.attachmentObjects = ((AttachmentMap) attachments).getOriginalMap().     } else {         this.attachmentObjects = new LinkedHashMap<>().         for (Map.Entry<String, DataHandler> entry : attachments.entrySet()) {             this.attachmentObjects.put(entry.getKey(), new DefaultAttachment(entry.getValue())).         }     }     this.attachments = null. }
false;public;1;4;;public void setAttachmentObjects(Map<String, Attachment> attachments) {     this.attachmentObjects = attachments.     this.attachments = null. }
false;public;0;6;;public boolean hasAttachments() {     // then ensure camel-mail always creates attachments to remedy for this     return this.attachmentObjects != null && this.attachmentObjects.size() > 0. }
true;protected;0;3;/**  * Returns true if the headers have been mutated in some way  */ ;/**  * Returns true if the headers have been mutated in some way  */ protected boolean hasPopulatedHeaders() {     return headers != null. }
