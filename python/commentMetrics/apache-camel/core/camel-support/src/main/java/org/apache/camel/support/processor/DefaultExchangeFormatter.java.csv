commented;modifiers;parameterAmount;loc;comment;code
false;private;1;10;;private String style(String label) {     if (style == OutputStyle.Default) {         return String.format(", %s: ", label).     }     if (style == OutputStyle.Tab) {         return String.format("\t%s: ", label).     } else {         return String.format("\t%-20s", label).     } }
false;public;1;144;;public String format(Exchange exchange) {     Message in = exchange.getIn().     StringBuilder sb = new StringBuilder().     if (showAll || showExchangeId) {         if (multiline) {             sb.append(SEPARATOR).         }         sb.append(style("Id")).append(exchange.getExchangeId()).     }     if (showAll || showExchangePattern) {         if (multiline) {             sb.append(SEPARATOR).         }         sb.append(style("ExchangePattern")).append(exchange.getPattern()).     }     if (showAll || showProperties) {         if (multiline) {             sb.append(SEPARATOR).         }         sb.append(style("Properties")).append(sortMap(filterHeaderAndProperties(exchange.getProperties()))).     }     if (showAll || showHeaders) {         if (multiline) {             sb.append(SEPARATOR).         }         sb.append(style("Headers")).append(sortMap(filterHeaderAndProperties(in.getHeaders()))).     }     if (showAll || showBodyType) {         if (multiline) {             sb.append(SEPARATOR).         }         sb.append(style("BodyType")).append(getBodyTypeAsString(in)).     }     if (showAll || showBody) {         if (multiline) {             sb.append(SEPARATOR).         }         String body = getBodyAsString(in).         if (skipBodyLineSeparator) {             body = StringHelper.replaceAll(body, LS, "").         }         sb.append(style("Body")).append(body).     }     if (showAll || showException || showCaughtException) {         // try exception on exchange first         Exception exception = exchange.getException().         boolean caught = false.         if ((showAll || showCaughtException) && exception == null) {             // fallback to caught exception             exception = exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class).             caught = true.         }         if (exception != null) {             if (multiline) {                 sb.append(SEPARATOR).             }             if (caught) {                 sb.append(style("CaughtExceptionType")).append(exception.getClass().getCanonicalName()).                 sb.append(style("CaughtExceptionMessage")).append(exception.getMessage()).             } else {                 sb.append(style("ExceptionType")).append(exception.getClass().getCanonicalName()).                 sb.append(style("ExceptionMessage")).append(exception.getMessage()).             }             if (showAll || showStackTrace) {                 StringWriter sw = new StringWriter().                 exception.printStackTrace(new PrintWriter(sw)).                 sb.append(style("StackTrace")).append(sw.toString()).             }         }     }     if (showAll || showOut) {         if (exchange.hasOut()) {             Message out = exchange.getOut().             if (showAll || showHeaders) {                 if (multiline) {                     sb.append(SEPARATOR).                 }                 sb.append(style("OutHeaders")).append(sortMap(filterHeaderAndProperties(out.getHeaders()))).             }             if (showAll || showBodyType) {                 if (multiline) {                     sb.append(SEPARATOR).                 }                 sb.append(style("OutBodyType")).append(getBodyTypeAsString(out)).             }             if (showAll || showBody) {                 if (multiline) {                     sb.append(SEPARATOR).                 }                 String body = getBodyAsString(out).                 if (skipBodyLineSeparator) {                     body = StringHelper.replaceAll(body, LS, "").                 }                 sb.append(style("OutBody")).append(body).             }         } else {             if (multiline) {                 sb.append(SEPARATOR).             }             sb.append(style("Out: null")).         }     }     if (maxChars > 0) {         StringBuilder answer = new StringBuilder().         for (String s : sb.toString().split(SEPARATOR)) {             if (s != null) {                 if (s.length() > maxChars) {                     s = s.substring(0, maxChars).                     answer.append(s).append("...").                 } else {                     answer.append(s).                 }                 if (multiline) {                     answer.append(LS).                 }             }         }         // switch string buffer         sb = answer.     }     if (multiline) {         sb.insert(0, "Exchange[").         sb.append("]").         return sb.toString().     } else {         // get rid of the leading space comma if needed         if (sb.length() > 0 && sb.charAt(0) == ',' && sb.charAt(1) == ' ') {             sb.replace(0, 2, "").         }         sb.insert(0, "Exchange[").         sb.append("]").         return sb.toString().     } }
true;protected;1;3;/**  * Filters the headers or properties before formatting them. No default behavior, but can be overridden.  */ ;/**  * Filters the headers or properties before formatting them. No default behavior, but can be overridden.  */ protected Map<String, Object> filterHeaderAndProperties(Map<String, Object> map) {     return map. }
false;public;0;3;;public boolean isShowExchangeId() {     return showExchangeId. }
true;public;1;3;/**  * Show the unique exchange ID.  */ ;/**  * Show the unique exchange ID.  */ public void setShowExchangeId(boolean showExchangeId) {     this.showExchangeId = showExchangeId. }
false;public;0;3;;public boolean isShowProperties() {     return showProperties. }
true;public;1;3;/**  * Show the exchange properties.  */ ;/**  * Show the exchange properties.  */ public void setShowProperties(boolean showProperties) {     this.showProperties = showProperties. }
false;public;0;3;;public boolean isShowHeaders() {     return showHeaders. }
true;public;1;3;/**  * Show the message headers.  */ ;/**  * Show the message headers.  */ public void setShowHeaders(boolean showHeaders) {     this.showHeaders = showHeaders. }
false;public;0;3;;public boolean isSkipBodyLineSeparator() {     return skipBodyLineSeparator. }
true;public;1;3;/**  * Whether to skip line separators when logging the message body.  * This allows to log the message body in one line, setting this option to false will preserve any line separators  * from the body, which then will log the body as is.  */ ;/**  * Whether to skip line separators when logging the message body.  * This allows to log the message body in one line, setting this option to false will preserve any line separators  * from the body, which then will log the body as is.  */ public void setSkipBodyLineSeparator(boolean skipBodyLineSeparator) {     this.skipBodyLineSeparator = skipBodyLineSeparator. }
false;public;0;3;;public boolean isShowBodyType() {     return showBodyType. }
true;public;1;3;/**  * Show the body Java type.  */ ;/**  * Show the body Java type.  */ public void setShowBodyType(boolean showBodyType) {     this.showBodyType = showBodyType. }
false;public;0;3;;public boolean isShowBody() {     return showBody. }
true;public;1;3;/*      * Show the message body.      */ ;/*      * Show the message body.      */ public void setShowBody(boolean showBody) {     this.showBody = showBody. }
false;public;0;3;;public boolean isShowOut() {     return showOut. }
true;public;1;3;/**  * If the exchange has an out message, show the out message.  */ ;/**  * If the exchange has an out message, show the out message.  */ public void setShowOut(boolean showOut) {     this.showOut = showOut. }
false;public;0;3;;public boolean isShowAll() {     return showAll. }
true;public;1;3;/**  * Quick option for turning all options on. (multiline, maxChars has to be manually set if to be used)  */ ;/**  * Quick option for turning all options on. (multiline, maxChars has to be manually set if to be used)  */ public void setShowAll(boolean showAll) {     this.showAll = showAll. }
false;public;0;3;;public boolean isShowException() {     return showException. }
true;public;1;3;/**  * If the exchange has an exception, show the exception message (no stacktrace)  */ ;/**  * If the exchange has an exception, show the exception message (no stacktrace)  */ public void setShowException(boolean showException) {     this.showException = showException. }
false;public;0;3;;public boolean isShowStackTrace() {     return showStackTrace. }
true;public;1;3;/**  * Show the stack trace, if an exchange has an exception. Only effective if one of showAll, showException or showCaughtException are enabled.  */ ;/**  * Show the stack trace, if an exchange has an exception. Only effective if one of showAll, showException or showCaughtException are enabled.  */ public void setShowStackTrace(boolean showStackTrace) {     this.showStackTrace = showStackTrace. }
false;public;0;3;;public boolean isShowCaughtException() {     return showCaughtException. }
true;public;1;3;/**  * If the exchange has a caught exception, show the exception message (no stack trace).  * A caught exception is stored as a property on the exchange (using the key {@link org.apache.camel.Exchange#EXCEPTION_CAUGHT}  * and for instance a doCatch can catch exceptions.  */ ;/**  * If the exchange has a caught exception, show the exception message (no stack trace).  * A caught exception is stored as a property on the exchange (using the key {@link org.apache.camel.Exchange#EXCEPTION_CAUGHT}  * and for instance a doCatch can catch exceptions.  */ public void setShowCaughtException(boolean showCaughtException) {     this.showCaughtException = showCaughtException. }
false;public;0;3;;public boolean isMultiline() {     return multiline. }
false;public;0;3;;public int getMaxChars() {     return maxChars. }
true;public;1;3;/**  * Limits the number of characters logged per line.  */ ;/**  * Limits the number of characters logged per line.  */ public void setMaxChars(int maxChars) {     this.maxChars = maxChars. }
true;public;1;3;/**  * If enabled then each information is outputted on a newline.  */ ;/**  * If enabled then each information is outputted on a newline.  */ public void setMultiline(boolean multiline) {     this.multiline = multiline. }
false;public;0;3;;public boolean isShowFuture() {     return showFuture. }
true;public;1;3;/**  * If enabled Camel will on Future objects wait for it to complete to obtain the payload to be logged.  */ ;/**  * If enabled Camel will on Future objects wait for it to complete to obtain the payload to be logged.  */ public void setShowFuture(boolean showFuture) {     this.showFuture = showFuture. }
false;public;0;3;;public boolean isShowExchangePattern() {     return showExchangePattern. }
true;public;1;3;/**  * Shows the Message Exchange Pattern (or MEP for short).  */ ;/**  * Shows the Message Exchange Pattern (or MEP for short).  */ public void setShowExchangePattern(boolean showExchangePattern) {     this.showExchangePattern = showExchangePattern. }
false;public;0;3;;public boolean isShowStreams() {     return showStreams. }
true;public;1;3;/**  * Whether Camel should show stream bodies or not (eg such as java.io.InputStream).  * Beware if you enable this option then you may not be able later to access the message body  * as the stream have already been read by this logger.  * To remedy this you will have to use Stream Caching.  */ ;/**  * Whether Camel should show stream bodies or not (eg such as java.io.InputStream).  * Beware if you enable this option then you may not be able later to access the message body  * as the stream have already been read by this logger.  * To remedy this you will have to use Stream Caching.  */ public void setShowStreams(boolean showStreams) {     this.showStreams = showStreams. }
false;public;0;3;;public boolean isShowFiles() {     return showFiles. }
true;public;1;3;/**  * If enabled Camel will output files  */ ;/**  * If enabled Camel will output files  */ public void setShowFiles(boolean showFiles) {     this.showFiles = showFiles. }
false;public;0;3;;public OutputStyle getStyle() {     return style. }
true;public;1;3;/**  * Sets the outputs style to use.  */ ;/**  * Sets the outputs style to use.  */ public void setStyle(OutputStyle style) {     this.style = style. }
true;protected;1;10;// ------------------------------------------------------------------------- ;// Implementation methods // ------------------------------------------------------------------------- protected String getBodyAsString(Message message) {     if (message.getBody() instanceof Future) {         if (!isShowFuture()) {             // just use a to string of the future object             return message.getBody().toString().         }     }     return MessageHelper.extractBodyForLogging(message, "", isShowStreams(), isShowFiles(), getMaxChars(message)). }
false;private;1;10;;private int getMaxChars(Message message) {     int maxChars = getMaxChars().     if (message.getExchange() != null) {         String globalOption = message.getExchange().getContext().getGlobalOption(Exchange.LOG_DEBUG_BODY_MAX_CHARS).         if (globalOption != null) {             maxChars = message.getExchange().getContext().getTypeConverter().convertTo(Integer.class, globalOption).         }     }     return maxChars. }
false;protected;1;7;;protected String getBodyTypeAsString(Message message) {     String answer = ObjectHelper.classCanonicalName(message.getBody()).     if (answer != null && answer.startsWith("java.lang.")) {         return answer.substring(10).     }     return answer. }
false;private,static;1;5;;private static Map<String, Object> sortMap(Map<String, Object> map) {     Map<String, Object> answer = new TreeMap<>(String.CASE_INSENSITIVE_ORDER).     answer.putAll(map).     return answer. }
