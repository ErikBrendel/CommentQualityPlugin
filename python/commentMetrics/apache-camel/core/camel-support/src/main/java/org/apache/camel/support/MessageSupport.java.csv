commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override public String toString() {     // do not output information about the message as it may contain sensitive information     return String.format("Message[%s]", messageId == null ? "" : messageId). }
false;public;0;7;;@Override public Object getBody() {     if (body == null) {         body = createBody().     }     return body. }
false;public;1;4;;@Override public <T> T getBody(Class<T> type) {     return getBody(type, getBody()). }
false;public;0;8;;@Override public Object getMandatoryBody() throws InvalidPayloadException {     Object answer = getBody().     if (answer == null) {         throw new InvalidPayloadException(getExchange(), Object.class, this).     }     return answer. }
false;protected;2;29;;protected <T> T getBody(Class<T> type, Object body) {     // if already same type     if (type.isInstance(body)) {         return type.cast(body).     }     Exchange e = getExchange().     if (e != null) {         TypeConverter converter = e.getContext().getTypeConverter().         // lets first try converting the body itself first         // as for some types like InputStream v Reader its more efficient to do the transformation         // from the body itself as its got efficient implementations of them, before trying the message         T answer = converter.convertTo(type, e, body).         if (answer != null) {             return answer.         }         // fallback and try the message itself (e.g. used in camel-http)         answer = converter.tryConvertTo(type, e, this).         if (answer != null) {             return answer.         }     }     // not possible to convert     return null. }
false;public;1;19;;@Override public <T> T getMandatoryBody(Class<T> type) throws InvalidPayloadException {     // if already same type     if (type.isInstance(body)) {         return type.cast(body).     }     Exchange e = getExchange().     if (e != null) {         TypeConverter converter = e.getContext().getTypeConverter().         try {             return converter.mandatoryConvertTo(type, e, getBody()).         } catch (Exception cause) {             throw new InvalidPayloadException(e, type, this, cause).         }     }     throw new InvalidPayloadException(e, type, this). }
false;public;1;8;;@Override public void setBody(Object body) {     this.body = body.     // set data type if in use     if (body != null && camelContext != null && camelContext.isUseDataType()) {         this.dataType = new DataType(body.getClass()).     } }
false;public;2;11;;@Override public <T> void setBody(Object value, Class<T> type) {     Exchange e = getExchange().     if (e != null) {         T v = e.getContext().getTypeConverter().convertTo(type, e, value).         if (v != null) {             value = v.         }     }     setBody(value). }
false;public;2;5;;@Override public void setBody(Object body, DataType type) {     this.body = body.     this.dataType = type. }
false;public;0;4;;@Override public DataType getDataType() {     return this.dataType. }
false;public;1;4;;@Override public void setDataType(DataType type) {     this.dataType = type. }
false;public;0;4;;@Override public boolean hasDataType() {     return dataType != null. }
false;public;0;10;;@Override public Message copy() {     Message answer = newInstance().     // must copy over CamelContext     if (answer instanceof CamelContextAware) {         ((CamelContextAware) answer).setCamelContext(getCamelContext()).     }     answer.copyFrom(this).     return answer. }
false;public;1;21;;@Override public void copyFrom(Message that) {     if (that == this) {         // the same instance so do not need to copy         return.     }     // must copy over CamelContext     if (that instanceof CamelContextAware) {         setCamelContext(((CamelContextAware) that).getCamelContext()).     }     if (that instanceof DataTypeAware && ((DataTypeAware) that).hasDataType()) {         setDataType(((DataTypeAware) that).getDataType()).     }     // cover over exchange if none has been assigned     if (getExchange() == null) {         setExchange(that.getExchange()).     }     copyFromWithNewBody(that, that.getBody()). }
false;public;2;41;;@Override public void copyFromWithNewBody(Message that, Object newBody) {     if (that == this) {         // the same instance so do not need to copy         return.     }     // must copy over CamelContext     if (that instanceof CamelContextAware) {         setCamelContext(((CamelContextAware) that).getCamelContext()).     }     // cover over exchange if none has been assigned     if (getExchange() == null) {         setExchange(that.getExchange()).     }     // should likely not set DataType as the new body may be a different type than the original body     setMessageId(that.getMessageId()).     setBody(newBody).     setFault(that.isFault()).     // the headers may be the same instance if the end user has made some mistake     // and set the OUT message with the same header instance of the IN message etc     boolean sameHeadersInstance = false.     if (hasHeaders() && that.hasHeaders() && getHeaders() == that.getHeaders()) {         sameHeadersInstance = true.     }     if (!sameHeadersInstance) {         if (hasHeaders()) {             // okay its safe to clear the headers             getHeaders().clear().         }         if (that.hasHeaders()) {             getHeaders().putAll(that.getHeaders()).         }     }     copyAttachments(that). }
false;public;0;4;;@Override public Exchange getExchange() {     return exchange. }
false;public;1;3;;public void setExchange(Exchange exchange) {     this.exchange = exchange. }
false;public;0;4;;@Override public CamelContext getCamelContext() {     return camelContext. }
false;public;1;4;;@Override public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;1;19;;@Override public void copyAttachments(Message that) {     // the attachments may be the same instance if the end user has made some mistake     // and set the OUT message with the same attachment instance of the IN message etc     boolean sameAttachments = false.     if (hasAttachments() && that.hasAttachments() && getAttachmentObjects() == that.getAttachmentObjects()) {         sameAttachments = true.     }     if (!sameAttachments) {         if (hasAttachments()) {             // okay its safe to clear the attachments             getAttachmentObjects().clear().         }         if (that.hasAttachments()) {             getAttachmentObjects().putAll(that.getAttachmentObjects()).         }     } }
true;public,abstract;0;1;/**  * Returns a new instance  */ ;/**  * Returns a new instance  */ public abstract Message newInstance().
true;protected;0;3;/**  * A factory method to allow a provider to lazily create the message body  * for inbound messages from other sources  *  * @return the value of the message body or null if there is no value  *         available  */ ;/**  * A factory method to allow a provider to lazily create the message body  * for inbound messages from other sources  *  * @return the value of the message body or null if there is no value  *         available  */ protected Object createBody() {     return null. }
false;public;0;7;;@Override public String getMessageId() {     if (messageId == null) {         messageId = createMessageId().     }     return this.messageId. }
false;public;1;4;;@Override public void setMessageId(String messageId) {     this.messageId = messageId. }
true;protected;0;11;/**  * Allow implementations to auto-create a messageId  */ ;/**  * Allow implementations to auto-create a messageId  */ protected String createMessageId() {     String uuid = null.     if (exchange != null) {         uuid = exchange.getContext().getUuidGenerator().generateUuid().     }     // fall back to the simple UUID generator     if (uuid == null) {         uuid = new SimpleUuidGenerator().generateUuid().     }     return uuid. }
