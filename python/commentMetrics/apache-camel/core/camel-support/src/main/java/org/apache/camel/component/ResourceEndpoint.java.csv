commented;modifiers;parameterAmount;loc;comment;code
true;public;0;19;/**  * Gets the resource as an input stream considering the cache flag as well.  * <p/>  * If cache is enabled then the resource content is cached in an internal buffer and this content is  * returned to avoid loading the resource over and over again.  *  * @return the input stream  * @throws IOException is thrown if error loading the content of the resource to the local cache buffer  */ ;/**  * Gets the resource as an input stream considering the cache flag as well.  * <p/>  * If cache is enabled then the resource content is cached in an internal buffer and this content is  * returned to avoid loading the resource over and over again.  *  * @return the input stream  * @throws IOException is thrown if error loading the content of the resource to the local cache buffer  */ public InputStream getResourceAsInputStream() throws IOException {     // try to get the resource input stream     if (isContentCache()) {         synchronized (this) {             if (buffer == null) {                 log.debug("Reading resource: {} into the content cache", resourceUri).                 try (InputStream is = getResourceAsInputStreamWithoutCache()) {                     ByteArrayOutputStream bos = new ByteArrayOutputStream().                     IOHelper.copy(IOHelper.buffered(is), bos).                     buffer = bos.toByteArray().                 }             }         }         log.debug("Using resource: {} from the content cache", resourceUri).         return new ByteArrayInputStream(buffer).     }     return getResourceAsInputStreamWithoutCache(). }
false;protected;0;3;;protected InputStream getResourceAsInputStreamWithoutCache() throws IOException {     return loadResource(resourceUri). }
true;protected;1;3;/**  * Loads the given resource.  *  * @param uri uri of the resource.  * @return the loaded resource  * @throws IOException is thrown if resource is not found or cannot be loaded  */ ;/**  * Loads the given resource.  *  * @param uri uri of the resource.  * @return the loaded resource  * @throws IOException is thrown if resource is not found or cannot be loaded  */ protected InputStream loadResource(String uri) throws IOException {     return ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext(), uri). }
false;public;0;4;;@ManagedAttribute(description = "Whether the resource is cached") public boolean isContentCache() {     return contentCache. }
false;public;0;5;;@ManagedOperation(description = "Clears the cached resource, forcing to re-load the resource on next request") public void clearContentCache() {     log.debug("Clearing resource: {} from the content cache", resourceUri).     buffer = null. }
false;public;0;3;;public boolean isContentCacheCleared() {     return buffer == null. }
false;public;0;4;;@ManagedAttribute(description = "Camel context ID") public String getCamelId() {     return getCamelContext().getName(). }
false;public;0;4;;@ManagedAttribute(description = "Camel ManagementName") public String getCamelManagementName() {     return getCamelContext().getManagementName(). }
false;public;0;4;;@ManagedAttribute(description = "Endpoint service state") public String getState() {     return getStatus().name(). }
true;public;1;3;/**  * Sets whether to use resource content cache or not.  */ ;/**  * Sets whether to use resource content cache or not.  */ public void setContentCache(boolean contentCache) {     this.contentCache = contentCache. }
false;public;0;3;;public String getResourceUri() {     return resourceUri. }
true;public;1;3;/**  * Path to the resource.  * <p/>  * You can prefix with: classpath, file, http, ref, or bean.  * classpath, file and http loads the resource using these protocols (classpath is default).  * ref will lookup the resource in the registry.  * bean will call a method on a bean to be used as the resource.  * For bean you can specify the method name after dot, eg bean:myBean.myMethod  *  * @param resourceUri  the resource path  */ ;/**  * Path to the resource.  * <p/>  * You can prefix with: classpath, file, http, ref, or bean.  * classpath, file and http loads the resource using these protocols (classpath is default).  * ref will lookup the resource in the registry.  * bean will call a method on a bean to be used as the resource.  * For bean you can specify the method name after dot, eg bean:myBean.myMethod  *  * @param resourceUri  the resource path  */ public void setResourceUri(String resourceUri) {     this.resourceUri = resourceUri. }
