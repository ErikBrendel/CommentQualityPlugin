commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setId(String id) {     this.id = id. }
false;public;1;14;;public void process(Exchange exchange) throws Exception {     if (startTime == 0) {         startTime = System.currentTimeMillis().     }     int receivedCount = receivedCounter.incrementAndGet().     // only process if groupSize is set...otherwise we're in groupInterval mode     if (groupSize != null) {         if (receivedCount % groupSize == 0) {             lastLogMessage = createLogMessage(exchange, receivedCount).             logger.log(lastLogMessage).         }     } }
false;public;2;9;;public boolean process(Exchange exchange, AsyncCallback callback) {     try {         process(exchange).     } catch (Exception e) {         exchange.setException(e).     }     callback.done(true).     return true. }
false;public;0;3;;public Integer getGroupSize() {     return groupSize. }
false;public;1;6;;public void setGroupSize(Integer groupSize) {     if (groupSize == null || groupSize <= 0) {         throw new IllegalArgumentException("groupSize must be positive, was: " + groupSize).     }     this.groupSize = groupSize. }
false;public;0;3;;public Long getGroupInterval() {     return groupInterval. }
false;public;1;6;;public void setGroupInterval(Long groupInterval) {     if (groupInterval == null || groupInterval <= 0) {         throw new IllegalArgumentException("groupInterval must be positive, was: " + groupInterval).     }     this.groupInterval = groupInterval. }
false;public;0;3;;public long getGroupDelay() {     return groupDelay. }
false;public;1;3;;public void setGroupDelay(long groupDelay) {     this.groupDelay = groupDelay. }
false;public;0;3;;public boolean getGroupActiveOnly() {     return groupActiveOnly. }
false;private;1;3;;private void setGroupActiveOnly(boolean groupActiveOnly) {     this.groupActiveOnly = groupActiveOnly. }
false;public;0;3;;public NumberFormat getNumberFormat() {     return numberFormat. }
false;public;1;3;;public void setNumberFormat(NumberFormat numberFormat) {     this.numberFormat = numberFormat. }
false;public;0;3;;public String getAction() {     return action. }
false;public;1;3;;public void setAction(String action) {     this.action = action. }
false;public;0;9;;public void reset() {     startTime = 0.     receivedCounter.set(0).     groupStartTime = 0.     groupReceivedCount = 0.     average = 0.0d.     rate = 0.0d.     lastLogMessage = null. }
false;public;0;3;;public double getRate() {     return rate. }
false;public;0;3;;public double getAverage() {     return average. }
false;public;0;3;;public int getReceivedCounter() {     return receivedCounter.get(). }
false;public;0;3;;public String getLastLogMessage() {     return lastLogMessage. }
false;public;0;13;;@Override public void doStart() throws Exception {     // if an interval was specified, create a background thread     if (groupInterval != null) {         ObjectHelper.notNull(camelContext, "CamelContext", this).         logSchedulerService = camelContext.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "ThroughputLogger").         Runnable scheduledLogTask = new ScheduledLogTask().         log.info("Scheduling throughput logger to run every {} millis.", groupInterval).         // must use fixed rate to have it trigger at every X interval         logSchedulerService.scheduleAtFixedRate(scheduledLogTask, groupDelay, groupInterval, TimeUnit.MILLISECONDS).     } }
false;public;0;7;;@Override public void doStop() throws Exception {     if (logSchedulerService != null) {         camelContext.getExecutorServiceManager().shutdown(logSchedulerService).         logSchedulerService = null.     } }
false;protected;2;16;;protected String createLogMessage(Exchange exchange, int receivedCount) {     long time = System.currentTimeMillis().     if (groupStartTime == 0) {         groupStartTime = startTime.     }     rate = messagesPerSecond(groupSize, groupStartTime, time).     average = messagesPerSecond(receivedCount, startTime, time).     long duration = time - groupStartTime.     groupStartTime = time.     return getAction() + ": " + receivedCount + " messages so far. Last group took: " + duration + " millis which is: " + numberFormat.format(rate) + " messages per second. average: " + numberFormat.format(average). }
false;public;0;9;;public void run() {     // only run if CamelContext has been fully started     if (!camelContext.getStatus().isStarted()) {         log.trace("ThroughputLogger cannot start because CamelContext({}) has not been started yet", camelContext.getName()).         return.     }     createGroupIntervalLogMessage(). }
false;protected;0;32;;protected void createGroupIntervalLogMessage() {     // this indicates that no messages have been received yet...don't logger yet     if (startTime == 0) {         return.     }     int receivedCount = receivedCounter.get().     // if configured, hide logger messages when no new messages have been received     if (groupActiveOnly && receivedCount == groupReceivedCount) {         return.     }     long time = System.currentTimeMillis().     if (groupStartTime == 0) {         groupStartTime = startTime.     }     long duration = time - groupStartTime.     long currentCount = receivedCount - groupReceivedCount.     rate = messagesPerSecond(currentCount, groupStartTime, time).     average = messagesPerSecond(receivedCount, startTime, time).     groupStartTime = time.     groupReceivedCount = receivedCount.     lastLogMessage = getAction() + ": " + currentCount + " new messages, with total " + receivedCount + " so far. Last group took: " + duration + " millis which is: " + numberFormat.format(rate) + " messages per second. average: " + numberFormat.format(average).     logger.log(lastLogMessage). }
false;protected;3;7;;protected double messagesPerSecond(long messageCount, long startTime, long endTime) {     // timeOneMessage = elapsed / messageCount     // messagePerSend = 1000 / timeOneMessage     double rate = messageCount * 1000.0.     rate /= endTime - startTime.     return rate. }
