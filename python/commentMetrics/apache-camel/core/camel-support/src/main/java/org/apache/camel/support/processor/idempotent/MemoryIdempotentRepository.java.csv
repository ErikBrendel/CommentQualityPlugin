commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;3;/**  * Creates a new memory based repository using a {@link LRUCache}  * with a default of 1000 entries in the cache.  */ ;/**  * Creates a new memory based repository using a {@link LRUCache}  * with a default of 1000 entries in the cache.  */ public static IdempotentRepository memoryIdempotentRepository() {     return new MemoryIdempotentRepository(). }
true;public,static;1;4;/**  * Creates a new memory based repository using a {@link LRUCache}.  *  * @param cacheSize  the cache size  */ ;/**  * Creates a new memory based repository using a {@link LRUCache}.  *  * @param cacheSize  the cache size  */ @SuppressWarnings("unchecked") public static IdempotentRepository memoryIdempotentRepository(int cacheSize) {     return memoryIdempotentRepository(LRUCacheFactory.newLRUCache(cacheSize)). }
true;public,static;1;3;/**  * Creates a new memory based repository using the given {@link Map} to  * use to store the processed message ids.  * <p/>  * Care should be taken to use a suitable underlying {@link Map} to avoid this class being a  * memory leak.  *  * @param cache  the cache  */ ;/**  * Creates a new memory based repository using the given {@link Map} to  * use to store the processed message ids.  * <p/>  * Care should be taken to use a suitable underlying {@link Map} to avoid this class being a  * memory leak.  *  * @param cache  the cache  */ public static IdempotentRepository memoryIdempotentRepository(Map<String, Object> cache) {     return new MemoryIdempotentRepository(cache). }
false;public;1;11;;@ManagedOperation(description = "Adds the key to the store") public boolean add(String key) {     synchronized (cache) {         if (cache.containsKey(key)) {             return false.         } else {             cache.put(key, key).             return true.         }     } }
false;public;1;6;;@ManagedOperation(description = "Does the store contain the given key") public boolean contains(String key) {     synchronized (cache) {         return cache.containsKey(key).     } }
false;public;1;6;;@ManagedOperation(description = "Remove the key from the store") public boolean remove(String key) {     synchronized (cache) {         return cache.remove(key) != null.     } }
false;public;1;4;;public boolean confirm(String key) {     // noop     return true. }
false;public;0;6;;@ManagedOperation(description = "Clear the store") public void clear() {     synchronized (cache) {         cache.clear().     } }
false;public;0;3;;public Map<String, Object> getCache() {     return cache. }
false;public;0;4;;@ManagedAttribute(description = "The current cache size") public int getCacheSize() {     return cache.size(). }
false;public;1;3;;public void setCacheSize(int cacheSize) {     this.cacheSize = cacheSize. }
false;protected;0;7;;@Override @SuppressWarnings("unchecked") protected void doStart() throws Exception {     if (cacheSize > 0) {         cache = LRUCacheFactory.newLRUCache(cacheSize).     } }
false;protected;0;4;;@Override protected void doStop() throws Exception {     cache.clear(). }
