commented;modifiers;parameterAmount;loc;comment;code
true;public;0;37;/**  * Invoked whenever we should be polled  */ ;/**  * Invoked whenever we should be polled  */ public void run() {     // avoid this thread to throw exceptions because the thread pool wont re-schedule a new thread     try {         // log starting         if (LoggingLevel.ERROR == runLoggingLevel) {             log.error("Scheduled task started on:   {}", this.getEndpoint()).         } else if (LoggingLevel.WARN == runLoggingLevel) {             log.warn("Scheduled task started on:   {}", this.getEndpoint()).         } else if (LoggingLevel.INFO == runLoggingLevel) {             log.info("Scheduled task started on:   {}", this.getEndpoint()).         } else if (LoggingLevel.DEBUG == runLoggingLevel) {             log.debug("Scheduled task started on:   {}", this.getEndpoint()).         } else {             log.trace("Scheduled task started on:   {}", this.getEndpoint()).         }         // execute scheduled task         doRun().         // log completed         if (LoggingLevel.ERROR == runLoggingLevel) {             log.error("Scheduled task completed on: {}", this.getEndpoint()).         } else if (LoggingLevel.WARN == runLoggingLevel) {             log.warn("Scheduled task completed on: {}", this.getEndpoint()).         } else if (LoggingLevel.INFO == runLoggingLevel) {             log.info("Scheduled task completed on: {}", this.getEndpoint()).         } else if (LoggingLevel.DEBUG == runLoggingLevel) {             log.debug("Scheduled task completed on: {}", this.getEndpoint()).         } else {             log.trace("Scheduled task completed on: {}", this.getEndpoint()).         }     } catch (Error e) {         // must catch Error, to ensure the task is re-scheduled         log.error("Error occurred during running scheduled task on: " + this.getEndpoint() + ", due: " + e.getMessage(), e).     } }
false;private;0;118;;private void doRun() {     if (isSuspended()) {         log.trace("Cannot start to poll: {} as its suspended", this.getEndpoint()).         return.     }     // should we backoff if its enabled, and either the idle or error counter is > the threshold     if (backoffMultiplier > 0 && // either idle or error threshold could be not in use, so check for that and use MAX_VALUE if not in use     (idleCounter >= (backoffIdleThreshold > 0 ? backoffIdleThreshold : Integer.MAX_VALUE)) || errorCounter >= (backoffErrorThreshold > 0 ? backoffErrorThreshold : Integer.MAX_VALUE)) {         if (backoffCounter++ < backoffMultiplier) {             // yes we should backoff             if (idleCounter > 0) {                 log.debug("doRun() backoff due subsequent {} idles (backoff at {}/{})", idleCounter, backoffCounter, backoffMultiplier).             } else {                 log.debug("doRun() backoff due subsequent {} errors (backoff at {}/{})", errorCounter, backoffCounter, backoffMultiplier).             }             return.         } else {             // we are finished with backoff so reset counters             idleCounter = 0.             errorCounter = 0.             backoffCounter = 0.             log.trace("doRun() backoff finished, resetting counters.").         }     }     int retryCounter = -1.     boolean done = false.     Throwable cause = null.     int polledMessages = 0.     while (!done) {         try {             cause = null.             // eager assume we are done             done = true.             if (isPollAllowed()) {                 if (retryCounter == -1) {                     log.trace("Starting to poll: {}", this.getEndpoint()).                 } else {                     log.debug("Retrying attempt {} to poll: {}", retryCounter, this.getEndpoint()).                 }                 // mark we are polling which should also include the begin/poll/commit                 polling = true.                 try {                     boolean begin = pollStrategy.begin(this, getEndpoint()).                     if (begin) {                         retryCounter++.                         polledMessages = poll().                         log.trace("Polled {} messages", polledMessages).                         if (polledMessages == 0 && isSendEmptyMessageWhenIdle()) {                             // send an "empty" exchange                             processEmptyMessage().                         }                         pollStrategy.commit(this, getEndpoint(), polledMessages).                         if (polledMessages > 0 && isGreedy()) {                             done = false.                             retryCounter = -1.                             log.trace("Greedy polling after processing {} messages", polledMessages).                         }                     } else {                         log.debug("Cannot begin polling as pollStrategy returned false: {}", pollStrategy).                     }                 } finally {                     polling = false.                 }             }             log.trace("Finished polling: {}", this.getEndpoint()).         } catch (Exception e) {             try {                 boolean retry = pollStrategy.rollback(this, getEndpoint(), retryCounter, e).                 if (retry) {                     // do not set cause as we retry                     done = false.                 } else {                     cause = e.                     done = true.                 }             } catch (Throwable t) {                 cause = t.                 done = true.             }         } catch (Throwable t) {             cause = t.             done = true.         }         if (cause != null && isRunAllowed()) {             // but suppress this during shutdown as the logs may get flooded with exceptions during shutdown/forced shutdown             try {                 getExceptionHandler().handleException("Consumer " + this + " failed polling endpoint: " + getEndpoint() + ". Will try again at next poll", cause).             } catch (Throwable e) {                 log.warn("Error handling exception. This exception will be ignored.", e).             }         }     }     if (cause != null) {         idleCounter = 0.         errorCounter++.     } else {         idleCounter = polledMessages == 0 ? ++idleCounter : 0.         errorCounter = 0.     }     log.trace("doRun() done with idleCounter={}, errorCounter={}", idleCounter, errorCounter). // avoid this thread to throw exceptions because the thread pool wont re-schedule a new thread }
true;protected;0;5;/**  * No messages to poll so send an empty message instead.  *  * @throws Exception is thrown if error processing the empty message.  */ ;/**  * No messages to poll so send an empty message instead.  *  * @throws Exception is thrown if error processing the empty message.  */ protected void processEmptyMessage() throws Exception {     Exchange exchange = getEndpoint().createExchange().     log.debug("Sending empty message as there were no messages from polling: {}", this.getEndpoint()).     getProcessor().process(exchange). }
false;protected;0;3;;// Properties // ------------------------------------------------------------------------- protected boolean isPollAllowed() {     return isRunAllowed() && !isSuspended(). }
true;protected;0;3;/**  * Whether polling is currently in progress  */ ;/**  * Whether polling is currently in progress  */ protected boolean isPolling() {     return polling. }
false;public;0;3;;public ScheduledPollConsumerScheduler getScheduler() {     return scheduler. }
false;public;1;3;;public void setScheduler(ScheduledPollConsumerScheduler scheduler) {     this.scheduler = scheduler. }
false;public;0;3;;public Map<String, Object> getSchedulerProperties() {     return schedulerProperties. }
false;public;1;3;;public void setSchedulerProperties(Map<String, Object> schedulerProperties) {     this.schedulerProperties = schedulerProperties. }
false;public;0;3;;public long getInitialDelay() {     return initialDelay. }
false;public;1;3;;public void setInitialDelay(long initialDelay) {     this.initialDelay = initialDelay. }
false;public;0;3;;public long getDelay() {     return delay. }
false;public;1;3;;public void setDelay(long delay) {     this.delay = delay. }
false;public;0;3;;public TimeUnit getTimeUnit() {     return timeUnit. }
false;public;1;3;;public void setTimeUnit(TimeUnit timeUnit) {     this.timeUnit = timeUnit. }
false;public;0;3;;public boolean isUseFixedDelay() {     return useFixedDelay. }
false;public;1;3;;public void setUseFixedDelay(boolean useFixedDelay) {     this.useFixedDelay = useFixedDelay. }
false;public;0;3;;public LoggingLevel getRunLoggingLevel() {     return runLoggingLevel. }
false;public;1;3;;public void setRunLoggingLevel(LoggingLevel runLoggingLevel) {     this.runLoggingLevel = runLoggingLevel. }
false;public;0;3;;public PollingConsumerPollStrategy getPollStrategy() {     return pollStrategy. }
false;public;1;3;;public void setPollStrategy(PollingConsumerPollStrategy pollStrategy) {     this.pollStrategy = pollStrategy. }
false;public;0;3;;public boolean isStartScheduler() {     return startScheduler. }
false;public;1;3;;public void setStartScheduler(boolean startScheduler) {     this.startScheduler = startScheduler. }
false;public;1;3;;public void setSendEmptyMessageWhenIdle(boolean sendEmptyMessageWhenIdle) {     this.sendEmptyMessageWhenIdle = sendEmptyMessageWhenIdle. }
false;public;0;3;;public boolean isSendEmptyMessageWhenIdle() {     return sendEmptyMessageWhenIdle. }
false;public;0;3;;public boolean isGreedy() {     return greedy. }
false;public;1;3;;public void setGreedy(boolean greedy) {     this.greedy = greedy. }
false;public;0;3;;public int getBackoffCounter() {     return backoffCounter. }
false;public;0;3;;public int getBackoffMultiplier() {     return backoffMultiplier. }
false;public;1;3;;public void setBackoffMultiplier(int backoffMultiplier) {     this.backoffMultiplier = backoffMultiplier. }
false;public;0;3;;public int getBackoffIdleThreshold() {     return backoffIdleThreshold. }
false;public;1;3;;public void setBackoffIdleThreshold(int backoffIdleThreshold) {     this.backoffIdleThreshold = backoffIdleThreshold. }
false;public;0;3;;public int getBackoffErrorThreshold() {     return backoffErrorThreshold. }
false;public;1;3;;public void setBackoffErrorThreshold(int backoffErrorThreshold) {     this.backoffErrorThreshold = backoffErrorThreshold. }
false;public;0;3;;public ScheduledExecutorService getScheduledExecutorService() {     return scheduledExecutorService. }
false;public;0;3;;public boolean isSchedulerStarted() {     return scheduler.isSchedulerStarted(). }
false;public;1;3;;public void setScheduledExecutorService(ScheduledExecutorService scheduledExecutorService) {     this.scheduledExecutorService = scheduledExecutorService. }
true;protected,abstract;0;1;/**  * The polling method which is invoked periodically to poll this consumer  *  * @return number of messages polled, will be <tt>0</tt> if no message was polled at all.  * @throws Exception can be thrown if an exception occurred during polling  */ ;// Implementation methods // ------------------------------------------------------------------------- /**  * The polling method which is invoked periodically to poll this consumer  *  * @return number of messages polled, will be <tt>0</tt> if no message was polled at all.  * @throws Exception can be thrown if an exception occurred during polling  */ protected abstract int poll() throws Exception.
false;protected;0;44;;@Override protected void doStart() throws Exception {     super.doStart().     // validate that if backoff multiplier is in use, the threshold values is set correctly     if (backoffMultiplier > 0) {         if (backoffIdleThreshold <= 0 && backoffErrorThreshold <= 0) {             throw new IllegalArgumentException("backoffIdleThreshold and/or backoffErrorThreshold must be configured to a positive value when using backoffMultiplier").         }         log.debug("Using backoff[multiplier={}, idleThreshold={}, errorThreshold={}] on {}", backoffMultiplier, backoffIdleThreshold, backoffErrorThreshold, getEndpoint()).     }     if (scheduler == null) {         scheduler = new DefaultScheduledPollConsumerScheduler(scheduledExecutorService).     }     scheduler.setCamelContext(getEndpoint().getCamelContext()).     scheduler.onInit(this).     scheduler.scheduleTask(this).     // configure scheduler with options from this consumer     Map<String, Object> properties = new HashMap<>().     IntrospectionSupport.getProperties(this, properties, null).     IntrospectionSupport.setProperties(getEndpoint().getCamelContext().getTypeConverter(), scheduler, properties).     if (schedulerProperties != null && !schedulerProperties.isEmpty()) {         // need to use a copy in case the consumer is restarted so we keep the properties         Map<String, Object> copy = new HashMap<>(schedulerProperties).         IntrospectionSupport.setProperties(getEndpoint().getCamelContext().getTypeConverter(), scheduler, copy).         if (copy.size() > 0) {             throw new FailedToCreateConsumerException(getEndpoint(), "There are " + copy.size() + " scheduler parameters that couldn't be set on the endpoint." + " Check the uri if the parameters are spelt correctly and that they are properties of the endpoint." + " Unknown parameters=[" + copy + "]").         }     }     ObjectHelper.notNull(scheduler, "scheduler", this).     ObjectHelper.notNull(pollStrategy, "pollStrategy", this).     ServiceHelper.startService(scheduler).     if (isStartScheduler()) {         startScheduler().     } }
true;public;0;3;/**  * Starts the scheduler.  * <p/>  * If the scheduler is already started, then this is a noop method call.  */ ;/**  * Starts the scheduler.  * <p/>  * If the scheduler is already started, then this is a noop method call.  */ public void startScheduler() {     scheduler.startScheduler(). }
false;protected;0;14;;@Override protected void doStop() throws Exception {     if (scheduler != null) {         scheduler.unscheduleTask().         ServiceHelper.stopAndShutdownServices(scheduler).     }     // clear counters     backoffCounter = 0.     idleCounter = 0.     errorCounter = 0.     super.doStop(). }
false;protected;0;5;;@Override protected void doShutdown() throws Exception {     ServiceHelper.stopAndShutdownServices(scheduler).     super.doShutdown(). }
false;protected;0;4;;@Override protected void doSuspend() throws Exception { // dont stop/cancel the future task since we just check in the run method }
false;public;0;5;;@Override public void onInit() throws Exception {     // make sure the scheduler is starter     startScheduler = true. }
false;public;1;11;;@Override public long beforePoll(long timeout) throws Exception {     log.trace("Before poll {}", getEndpoint()).     // resume or start our self     if (!ServiceHelper.resumeService(this)) {         ServiceHelper.startService(this).     }     // ensure at least timeout is as long as one poll delay     return Math.max(timeout, getDelay()). }
false;public;0;8;;@Override public void afterPoll() throws Exception {     log.trace("After poll {}", getEndpoint()).     // suspend or stop our self     if (!ServiceHelper.suspendService(this)) {         ServiceHelper.stopService(this).     } }
