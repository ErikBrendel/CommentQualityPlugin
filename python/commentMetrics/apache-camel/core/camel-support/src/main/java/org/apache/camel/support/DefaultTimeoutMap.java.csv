commented;modifiers;parameterAmount;loc;comment;code
false;public;1;14;;public V get(K key) {     TimeoutMapEntry<K, V> entry.     lock.lock().     try {         entry = map.get(key).         if (entry == null) {             return null.         }         updateExpireTime(entry).     } finally {         lock.unlock().     }     return entry.getValue(). }
false;public;3;11;;public V put(K key, V value, long timeoutMillis) {     TimeoutMapEntry<K, V> entry = new TimeoutMapEntry<>(key, value, timeoutMillis).     lock.lock().     try {         updateExpireTime(entry).         TimeoutMapEntry<K, V> result = map.put(key, entry).         return result != null ? result.getValue() : null.     } finally {         lock.unlock().     } }
false;public;3;12;;public V putIfAbsent(K key, V value, long timeoutMillis) {     TimeoutMapEntry<K, V> entry = new TimeoutMapEntry<>(key, value, timeoutMillis).     lock.lock().     try {         updateExpireTime(entry).         // Just make sure we don't override the old entry         TimeoutMapEntry<K, V> result = map.putIfAbsent(key, entry).         return result != null ? result.getValue() : null.     } finally {         lock.unlock().     } }
false;public;1;12;;public V remove(K key) {     TimeoutMapEntry<K, V> entry.     lock.lock().     try {         entry = map.remove(key).     } finally {         lock.unlock().     }     return entry != null ? entry.getValue() : null. }
false;public;0;12;;public Object[] getKeys() {     Object[] keys.     lock.lock().     try {         Set<K> keySet = map.keySet().         keys = new Object[keySet.size()].         keySet.toArray(keys).     } finally {         lock.unlock().     }     return keys. }
false;public;0;3;;public int size() {     return map.size(). }
true;public;0;15;/**  * The timer task which purges old requests and schedules another poll  */ ;/**  * The timer task which purges old requests and schedules another poll  */ public void run() {     // only run if allowed     if (!isRunAllowed()) {         log.trace("Purge task not allowed to run").         return.     }     log.trace("Running purge task to see if any entries has been timed out").     try {         purge().     } catch (Throwable t) {         // must catch and log exception otherwise the executor will now schedule next run         log.warn("Exception occurred during purge task. This exception will be ignored.", t).     } }
false;public;2;7;;public int compare(TimeoutMapEntry<K, V> a, TimeoutMapEntry<K, V> b) {     long diff = a.getExpireTime() - b.getExpireTime().     if (diff == 0) {         return 0.     }     return diff > 0 ? 1 : -1. }
false;public;0;62;;public void purge() {     log.trace("There are {} in the timeout map", map.size()).     if (map.isEmpty()) {         return.     }     long now = currentTime().     List<TimeoutMapEntry<K, V>> expired = new ArrayList<>().     lock.lock().     try {         // need to find the expired entries and add to the expired list         for (Map.Entry<K, TimeoutMapEntry<K, V>> entry : map.entrySet()) {             if (entry.getValue().getExpireTime() < now) {                 if (isValidForEviction(entry.getValue())) {                     log.debug("Evicting inactive entry ID: {}", entry.getValue()).                     expired.add(entry.getValue()).                 }             }         }         // if we found any expired then we need to sort, onEviction and remove         if (!expired.isEmpty()) {             // sort according to the expired time so we got the first expired first             expired.sort(new Comparator<TimeoutMapEntry<K, V>>() {                  public int compare(TimeoutMapEntry<K, V> a, TimeoutMapEntry<K, V> b) {                     long diff = a.getExpireTime() - b.getExpireTime().                     if (diff == 0) {                         return 0.                     }                     return diff > 0 ? 1 : -1.                 }             }).             List<K> evicts = new ArrayList<>(expired.size()).             try {                 // now fire eviction notification                 for (TimeoutMapEntry<K, V> entry : expired) {                     boolean evict = false.                     try {                         evict = onEviction(entry.getKey(), entry.getValue()).                     } catch (Throwable t) {                         log.warn("Exception happened during eviction of entry ID {}, won't evict and will continue trying: {}", entry.getValue(), t).                     }                     if (evict) {                         // okay this entry should be evicted                         evicts.add(entry.getKey()).                     }                 }             } finally {                 // and must remove from list after we have fired the notifications                 for (K key : evicts) {                     map.remove(key).                 }             }         }     } finally {         lock.unlock().     } }
false;public;0;3;;// Properties // ------------------------------------------------------------------------- public long getPurgePollTime() {     return purgePollTime. }
false;public;0;3;;public ScheduledExecutorService getExecutor() {     return executor. }
true;protected;0;3;/**  * lets schedule each time to allow folks to change the time at runtime  */ ;// Implementation methods // ------------------------------------------------------------------------- /**  * lets schedule each time to allow folks to change the time at runtime  */ protected void schedulePoll() {     future = executor.scheduleWithFixedDelay(this, 0, purgePollTime, TimeUnit.MILLISECONDS). }
true;protected;1;3;/**  * A hook to allow derivations to avoid evicting the current entry  */ ;/**  * A hook to allow derivations to avoid evicting the current entry  */ protected boolean isValidForEviction(TimeoutMapEntry<K, V> entry) {     return true. }
false;public;2;3;;public boolean onEviction(K key, V value) {     return true. }
false;protected;1;4;;protected void updateExpireTime(TimeoutMapEntry<K, V> entry) {     long now = currentTime().     entry.setExpireTime(entry.getTimeout() + now). }
false;protected;0;3;;protected long currentTime() {     return System.currentTimeMillis(). }
false;protected;0;7;;@Override protected void doStart() throws Exception {     if (executor.isShutdown()) {         throw new IllegalStateException("The ScheduledExecutorService is shutdown").     }     schedulePoll(). }
false;protected;0;9;;@Override protected void doStop() throws Exception {     if (future != null) {         future.cancel(false).         future = null.     }     // clear map if we stop     map.clear(). }
