commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;17;;@Override protected void doStart() throws Exception {     for (final Method method : target.getClass().getDeclaredMethods()) {         InvokeOnHeaders annotation = method.getAnnotation(InvokeOnHeaders.class).         if (annotation != null) {             for (InvokeOnHeader processor : annotation.value()) {                 bind(processor, method).             }         } else {             bind(method.getAnnotation(InvokeOnHeader.class), method).         }     }     handlers = Collections.unmodifiableMap(handlers).     super.doStart(). }
false;protected;1;14;;@Override protected Processor getProcessor(Exchange exchange) throws Exception {     String header = headerSupplier.get().     String action = exchange.getIn().getHeader(header, String.class).     if (action == null) {         action = defaultHeaderValueSupplier.get().     }     if (action == null) {         throw new NoSuchHeaderException(exchange, header, String.class).     }     return handlers.get(action). }
false;protected;1;5;;protected void onMissingProcessor(Exchange exchange) throws Exception {     throw new IllegalStateException("Unsupported operation " + exchange.getIn().getHeader(headerSupplier.get())). }
false;protected,final;2;7;;protected final void bind(String key, Processor processor) {     if (handlers.containsKey(key)) {         LOGGER.warn("A processor is already set for action {}", key).     }     this.handlers.put(key, processor). }
false;private;2;16;;private void bind(InvokeOnHeader handler, final Method method) {     if (handler != null && method.getParameterCount() == 1) {         method.setAccessible(true).         final Class<?> type = method.getParameterTypes()[0].         LOGGER.debug("bind key={}, class={}, method={}, type={}", handler.value(), this.getClass(), method.getName(), type).         if (Message.class.isAssignableFrom(type)) {             bind(handler.value(), e -> method.invoke(target, e.getIn())).         } else {             bind(handler.value(), e -> method.invoke(target, e)).         }     } }
