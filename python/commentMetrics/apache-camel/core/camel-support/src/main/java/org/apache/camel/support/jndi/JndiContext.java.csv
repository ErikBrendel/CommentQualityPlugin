commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public Name parse(String name) throws NamingException {     return new CompositeName(name). }
true;public,static;1;24;/**  * A helper method to create the JNDI bindings from the input environment  * properties using $foo.class to point to a class name with $foo.* being  * properties set on the injected bean  */ ;/**  * A helper method to create the JNDI bindings from the input environment  * properties using $foo.class to point to a class name with $foo.* being  * properties set on the injected bean  */ public static Map<String, Object> createBindingsMapFromEnvironment(Hashtable<String, Object> env) throws Exception {     Map<String, Object> answer = new HashMap<>(env).     for (Map.Entry<String, Object> entry : env.entrySet()) {         String key = entry.getKey().         Object value = entry.getValue().         if (key != null && value instanceof String) {             String valueText = (String) value.             if (key.endsWith(".class")) {                 Class<?> type = org.apache.camel.util.ObjectHelper.loadClass(valueText).                 if (type != null) {                     String newEntry = key.substring(0, key.length() - ".class".length()).                     Object bean = createBean(type, answer, newEntry + ".").                     if (bean != null) {                         answer.put(newEntry, bean).                     }                 }             }         }     }     return answer. }
false;public;0;3;;public void freeze() {     frozen = true. }
false;;0;3;;boolean isFrozen() {     return frozen. }
true;protected;2;37;/**  * internalBind is intended for use only during setup or possibly by  * suitably synchronized superclasses. It binds every possible lookup into a  * map in each context. To do this, each context strips off one name segment  * and if necessary creates a new context for it. Then it asks that context  * to bind the remaining name. It returns a map containing all the bindings  * from the next context, plus the context it just created (if it in fact  * created it). (the names are suitably extended by the segment originally  * lopped off).  */ ;/**  * internalBind is intended for use only during setup or possibly by  * suitably synchronized superclasses. It binds every possible lookup into a  * map in each context. To do this, each context strips off one name segment  * and if necessary creates a new context for it. Then it asks that context  * to bind the remaining name. It returns a map containing all the bindings  * from the next context, plus the context it just created (if it in fact  * created it). (the names are suitably extended by the segment originally  * lopped off).  */ protected Map<String, Object> internalBind(String name, Object value) throws NamingException {     assert name != null && name.length() > 0.     assert !frozen.     Map<String, Object> newBindings = new HashMap<>().     int pos = name.indexOf('/').     if (pos == -1) {         if (treeBindings.put(name, value) != null) {             throw new NamingException("Something already bound at " + name).         }         bindings.put(name, value).         newBindings.put(name, value).     } else {         String segment = name.substring(0, pos).         assert segment != null.         assert !segment.equals("").         Object o = treeBindings.get(segment).         if (o == null) {             o = newContext().             treeBindings.put(segment, o).             bindings.put(segment, o).             newBindings.put(segment, o).         } else if (!(o instanceof JndiContext)) {             throw new NamingException("Something already bound where a subcontext should go").         }         JndiContext defaultContext = (JndiContext) o.         String remainder = name.substring(pos + 1).         Map<String, Object> subBindings = defaultContext.internalBind(remainder, value).         for (Entry<String, Object> entry : subBindings.entrySet()) {             String subName = segment + "/" + entry.getKey().             Object bound = entry.getValue().             treeBindings.put(subName, bound).             newBindings.put(subName, bound).         }     }     return newBindings. }
false;protected;0;7;;protected JndiContext newContext() {     try {         return new JndiContext().     } catch (Exception e) {         throw new IllegalArgumentException(e).     } }
false;public;2;3;;public Object addToEnvironment(String propName, Object propVal) throws NamingException {     return environment.put(propName, propVal). }
false;public;0;3;;public Hashtable<String, Object> getEnvironment() throws NamingException {     return CastUtils.cast((Hashtable<?, ?>) environment.clone(), String.class, Object.class). }
false;public;1;3;;public Object removeFromEnvironment(String propName) throws NamingException {     return environment.remove(propName). }
false;public;1;59;;public Object lookup(String name) throws NamingException {     if (name.length() == 0) {         return this.     }     Object result = treeBindings.get(name).     if (result == null) {         result = bindings.get(name).     }     if (result == null) {         int pos = name.indexOf(':').         if (pos > 0) {             String scheme = name.substring(0, pos).             Context ctx = NamingManager.getURLContext(scheme, environment).             if (ctx == null) {                 throw new NamingException("scheme " + scheme + " not recognized").             }             return ctx.lookup(name).         } else {             // Split out the first name of the path             // and look for it in the bindings map.             CompositeName path = new CompositeName(name).             if (path.size() == 0) {                 return this.             } else {                 String first = path.get(0).                 Object value = bindings.get(first).                 if (value == null) {                     throw new NameNotFoundException(name).                 } else if (value instanceof Context && path.size() > 1) {                     Context subContext = (Context) value.                     value = subContext.lookup(path.getSuffix(1)).                 }                 return value.             }         }     }     if (result instanceof LinkRef) {         LinkRef ref = (LinkRef) result.         result = lookup(ref.getLinkName()).     }     if (result instanceof Reference) {         try {             result = NamingManager.getObjectInstance(result, null, null, this.environment).         } catch (NamingException e) {             throw e.         } catch (Exception e) {             throw (NamingException) new NamingException("could not look up : " + name).initCause(e).         }     }     if (result instanceof JndiContext) {         String prefix = getNameInNamespace().         if (prefix.length() > 0) {             prefix = prefix + SEPARATOR.         }         result = new JndiContext((JndiContext) result, environment, prefix + name).     }     return result. }
false;public;1;3;;public Object lookup(Name name) throws NamingException {     return lookup(name.toString()). }
false;public;1;3;;public Object lookupLink(String name) throws NamingException {     return lookup(name). }
false;public;2;5;;public Name composeName(Name name, Name prefix) throws NamingException {     Name result = (Name) prefix.clone().     result.addAll(name).     return result. }
false;public;2;5;;public String composeName(String name, String prefix) throws NamingException {     CompositeName result = new CompositeName(prefix).     result.addAll(new CompositeName(name)).     return result.toString(). }
false;public;1;10;;public NamingEnumeration<NameClassPair> list(String name) throws NamingException {     Object o = lookup(name).     if (o == this) {         return CastUtils.cast(new ListEnumeration()).     } else if (o instanceof Context) {         return ((Context) o).list("").     } else {         throw new NotContextException().     } }
false;public;1;10;;public NamingEnumeration<Binding> listBindings(String name) throws NamingException {     Object o = lookup(name).     if (o == this) {         return CastUtils.cast(new ListBindingEnumeration()).     } else if (o instanceof Context) {         return ((Context) o).listBindings("").     } else {         throw new NotContextException().     } }
false;public;1;3;;public Object lookupLink(Name name) throws NamingException {     return lookupLink(name.toString()). }
false;public;1;3;;public NamingEnumeration<NameClassPair> list(Name name) throws NamingException {     return list(name.toString()). }
false;public;1;3;;public NamingEnumeration<Binding> listBindings(Name name) throws NamingException {     return listBindings(name.toString()). }
false;public;2;3;;public void bind(Name name, Object value) throws NamingException {     bind(name.toString(), value). }
false;public;2;7;;public void bind(String name, Object value) throws NamingException {     if (isFrozen()) {         throw new OperationNotSupportedException().     } else {         internalBind(name, value).     } }
false;public;0;3;;public void close() throws NamingException { // ignore }
false;public;1;3;;public Context createSubcontext(Name name) throws NamingException {     throw new OperationNotSupportedException(). }
false;public;1;3;;public Context createSubcontext(String name) throws NamingException {     throw new OperationNotSupportedException(). }
false;public;1;3;;public void destroySubcontext(Name name) throws NamingException {     throw new OperationNotSupportedException(). }
false;public;1;3;;public void destroySubcontext(String name) throws NamingException {     throw new OperationNotSupportedException(). }
false;public;0;3;;public String getNameInNamespace() throws NamingException {     return nameInNamespace. }
false;public;1;3;;public NameParser getNameParser(Name name) throws NamingException {     return NAME_PARSER. }
false;public;1;3;;public NameParser getNameParser(String name) throws NamingException {     return NAME_PARSER. }
false;public;2;3;;public void rebind(Name name, Object value) throws NamingException {     bind(name, value). }
false;public;2;3;;public void rebind(String name, Object value) throws NamingException {     bind(name, value). }
false;public;2;3;;public void rename(Name oldName, Name newName) throws NamingException {     throw new OperationNotSupportedException(). }
false;public;2;3;;public void rename(String oldName, String newName) throws NamingException {     throw new OperationNotSupportedException(). }
false;public;1;3;;public void unbind(Name name) throws NamingException {     throw new OperationNotSupportedException(). }
false;public;1;4;;public void unbind(String name) throws NamingException {     bindings.remove(name).     treeBindings.remove(name). }
false;public;0;3;;public boolean hasMore() throws NamingException {     return i.hasNext(). }
false;public;0;3;;public boolean hasMoreElements() {     return i.hasNext(). }
false;protected;0;3;;protected Map.Entry<String, Object> getNext() {     return i.next(). }
false;public;0;2;;public void close() throws NamingException { }
false;public;0;3;;public Object next() throws NamingException {     return nextElement(). }
false;public;0;4;;public Object nextElement() {     Map.Entry<String, Object> entry = getNext().     return new NameClassPair(entry.getKey(), entry.getValue().getClass().getName()). }
false;public;0;3;;public Object next() throws NamingException {     return nextElement(). }
false;public;0;4;;public Object nextElement() {     Map.Entry<String, Object> entry = getNext().     return new Binding(entry.getKey(), entry.getValue()). }
false;protected,static;3;5;;protected static Object createBean(Class<?> type, Map<String, Object> properties, String prefix) throws Exception {     Object value = ObjectHelper.newInstance(type).     IntrospectionSupport.setProperties(value, properties, prefix).     return value. }
