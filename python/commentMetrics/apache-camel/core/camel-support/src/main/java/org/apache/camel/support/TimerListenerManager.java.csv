commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;0;4;;@Override public CamelContext getCamelContext() {     return camelContext. }
true;public;0;3;/**  * Gets the interval in millis.  * <p/>  * The default interval is 1000 millis.  *  * @return interval in millis.  */ ;/**  * Gets the interval in millis.  * <p/>  * The default interval is 1000 millis.  *  * @return interval in millis.  */ public long getInterval() {     return interval. }
true;public;1;3;/**  * Sets the interval in millis.  *  * @param interval interval in millis.  */ ;/**  * Sets the interval in millis.  *  * @param interval interval in millis.  */ public void setInterval(long interval) {     this.interval = interval. }
false;public;0;19;;@Override public void run() {     LOG.trace("Running scheduled TimerListener task").     if (!isRunAllowed()) {         LOG.debug("TimerListener task cannot run as its not allowed").         return.     }     for (TimerListener listener : listeners) {         try {             LOG.trace("Invoking onTimer on {}", listener).             listener.onTimer().         } catch (Throwable e) {             // ignore             LOG.debug("Error occurred during onTimer for TimerListener: " + listener + ". This exception will be ignored.", e).         }     } }
true;public;1;4;/**  * Adds the listener.  * <p/>  * It may be important to implement {@link #equals(Object)} and {@link #hashCode()} for the listener  * to ensure that we can remove the same listener again, when invoking remove.  *  * @param listener listener  */ ;/**  * Adds the listener.  * <p/>  * It may be important to implement {@link #equals(Object)} and {@link #hashCode()} for the listener  * to ensure that we can remove the same listener again, when invoking remove.  *  * @param listener listener  */ public void addTimerListener(TimerListener listener) {     listeners.add(listener).     LOG.debug("Added TimerListener: {}", listener). }
true;public;1;4;/**  * Removes the listener.  * <p/>  * It may be important to implement {@link #equals(Object)} and {@link #hashCode()} for the listener  * to ensure that we can remove the same listener again, when invoking remove.  *  * @param listener listener.  */ ;/**  * Removes the listener.  * <p/>  * It may be important to implement {@link #equals(Object)} and {@link #hashCode()} for the listener  * to ensure that we can remove the same listener again, when invoking remove.  *  * @param listener listener.  */ public void removeTimerListener(TimerListener listener) {     listeners.remove(listener).     LOG.debug("Removed TimerListener: {}", listener). }
false;protected;0;9;;@Override protected void doStart() throws Exception {     ObjectHelper.notNull(camelContext, "camelContext", this).     // create scheduled thread pool to trigger the task to run every interval     executorService = camelContext.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "ManagementLoadTask").     task = executorService.scheduleAtFixedRate(this, interval, interval, TimeUnit.MILLISECONDS).     LOG.debug("Started scheduled TimerListener task to run with interval {} ms", interval). }
false;protected;0;8;;@Override protected void doStop() throws Exception {     // executor service will be shutdown by CamelContext     if (task != null) {         task.cancel(true).         task = null.     } }
false;protected;0;8;;@Override protected void doShutdown() throws Exception {     super.doShutdown().     // shutdown thread pool when we are shutting down     camelContext.getExecutorServiceManager().shutdownNow(executorService).     executorService = null.     listeners.clear(). }
