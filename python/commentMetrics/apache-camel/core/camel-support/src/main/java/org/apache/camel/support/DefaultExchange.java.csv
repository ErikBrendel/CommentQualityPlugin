commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override public String toString() {     // do not output information about the message as it may contain sensitive information     return String.format("Exchange[%s]", exchangeId == null ? "" : exchangeId). }
false;public;0;8;;@Override public Date getCreated() {     if (hasProperties()) {         return getProperty(Exchange.CREATED_TIMESTAMP, Date.class).     } else {         return null.     } }
false;public;0;31;;public Exchange copy() {     DefaultExchange exchange = new DefaultExchange(this).     exchange.setIn(getIn().copy()).     exchange.getIn().setBody(getIn().getBody()).     exchange.getIn().setFault(getIn().isFault()).     if (getIn().hasHeaders()) {         exchange.getIn().setHeaders(safeCopyHeaders(getIn().getHeaders())).         // just copy the attachments here         exchange.getIn().copyAttachments(getIn()).     }     if (hasOut()) {         exchange.setOut(getOut().copy()).         exchange.getOut().setBody(getOut().getBody()).         exchange.getOut().setFault(getOut().isFault()).         if (getOut().hasHeaders()) {             exchange.getOut().setHeaders(safeCopyHeaders(getOut().getHeaders())).         }         // Just copy the attachments here         exchange.getOut().copyAttachments(getOut()).     }     exchange.setException(getException()).     // copy properties after body as body may trigger lazy init     if (hasProperties()) {         exchange.setProperties(safeCopyProperties(getProperties())).     }     return exchange. }
false;private;1;7;;private Map<String, Object> safeCopyHeaders(Map<String, Object> headers) {     if (headers == null) {         return null.     }     return context.getHeadersMapFactory().newMap(headers). }
false;private;1;16;;@SuppressWarnings("unchecked") private Map<String, Object> safeCopyProperties(Map<String, Object> properties) {     if (properties == null) {         return null.     }     Map<String, Object> answer = createProperties(properties).     // safe copy message history using a defensive copy     List<MessageHistory> history = (List<MessageHistory>) answer.remove(Exchange.MESSAGE_HISTORY).     if (history != null) {         answer.put(Exchange.MESSAGE_HISTORY, new LinkedList<>(history)).     }     return answer. }
false;public;0;3;;public CamelContext getContext() {     return context. }
false;public;1;6;;public Object getProperty(String name) {     if (properties != null) {         return properties.get(name).     }     return null. }
false;public;2;4;;public Object getProperty(String name, Object defaultValue) {     Object answer = getProperty(name).     return answer != null ? answer : defaultValue. }
false;public;2;19;;@SuppressWarnings("unchecked") public <T> T getProperty(String name, Class<T> type) {     Object value = getProperty(name).     if (value == null) {         // lets avoid NullPointerException when converting to boolean for null values         if (boolean.class == type) {             return (T) Boolean.FALSE.         }         return null.     }     // if already same type     if (type.isInstance(value)) {         return (T) value.     }     return ExchangeHelper.convertToType(this, type, value). }
false;public;3;19;;@SuppressWarnings("unchecked") public <T> T getProperty(String name, Object defaultValue, Class<T> type) {     Object value = getProperty(name, defaultValue).     if (value == null) {         // lets avoid NullPointerException when converting to boolean for null values         if (boolean.class == type) {             return (T) Boolean.FALSE.         }         return null.     }     // if already same type     if (type.isInstance(value)) {         return (T) value.     }     return ExchangeHelper.convertToType(this, type, value). }
false;public;2;11;;public void setProperty(String name, Object value) {     if (value != null) {         // avoid the NullPointException         getProperties().put(name, value).     } else {         // if the value is null, we just remove the key from the map         if (name != null) {             getProperties().remove(name).         }     } }
false;public;1;6;;public Object removeProperty(String name) {     if (!hasProperties()) {         return null.     }     return getProperties().remove(name). }
false;public;1;3;;public boolean removeProperties(String pattern) {     return removeProperties(pattern, (String[]) null). }
false;public;2;29;;public boolean removeProperties(String pattern, String... excludePatterns) {     if (!hasProperties()) {         return false.     }     // store keys to be removed as we cannot loop and remove at the same time in implementations such as HashMap     Set<String> toBeRemoved = new HashSet<>().     boolean matches = false.     for (String key : properties.keySet()) {         if (PatternHelper.matchPattern(key, pattern)) {             if (excludePatterns != null && PatternHelper.isExcludePatternMatch(key, excludePatterns)) {                 continue.             }             matches = true.             toBeRemoved.add(key).         }     }     if (!toBeRemoved.isEmpty()) {         if (toBeRemoved.size() == properties.size()) {             // special optimization when all should be removed             properties.clear().         } else {             toBeRemoved.forEach(k -> properties.remove(k)).         }     }     return matches. }
false;public;0;6;;public Map<String, Object> getProperties() {     if (properties == null) {         properties = createProperties().     }     return properties. }
false;public;0;3;;public boolean hasProperties() {     return properties != null && !properties.isEmpty(). }
false;public;1;3;;public void setProperties(Map<String, Object> properties) {     this.properties = properties. }
false;public;0;7;;public Message getIn() {     if (in == null) {         in = new DefaultMessage(getContext()).         configureMessage(in).     }     return in. }
false;public;1;12;;public <T> T getIn(Class<T> type) {     Message in = getIn().     // if already same type     if (type.isInstance(in)) {         return type.cast(in).     }     // fallback to use type converter     return context.getTypeConverter().convertTo(type, this, in). }
false;public;1;4;;public void setIn(Message in) {     this.in = in.     configureMessage(in). }
false;public;0;9;;public Message getOut() {     // lazy create     if (out == null) {         out = (in instanceof MessageSupport) ? ((MessageSupport) in).newInstance() : new DefaultMessage(getContext()).         configureMessage(out).     }     return out. }
false;public;1;16;;public <T> T getOut(Class<T> type) {     if (!hasOut()) {         return null.     }     Message out = getOut().     // if already same type     if (type.isInstance(out)) {         return type.cast(out).     }     // fallback to use type converter     return context.getTypeConverter().convertTo(type, this, out). }
false;public;0;3;;public boolean hasOut() {     return out != null. }
false;public;1;4;;public void setOut(Message out) {     this.out = out.     configureMessage(out). }
false;public;0;3;;public Message getMessage() {     return hasOut() ? getOut() : getIn(). }
false;public;1;3;;public <T> T getMessage(Class<T> type) {     return hasOut() ? getOut(type) : getIn(type). }
false;public;1;7;;public void setMessage(Message message) {     if (hasOut()) {         setOut(message).     } else {         setIn(message).     } }
false;public;0;3;;public Exception getException() {     return exception. }
false;public;1;3;;public <T> T getException(Class<T> type) {     return ObjectHelper.getException(type, exception). }
false;public;1;14;;public void setException(Throwable t) {     if (t == null) {         this.exception = null.     } else if (t instanceof Exception) {         this.exception = (Exception) t.     } else {         // wrap throwable into an exception         this.exception = CamelExecutionException.wrapCamelExecutionException(this, t).     }     if (t instanceof InterruptedException) {         // mark the exchange as interrupted due to the interrupt exception         setProperty(Exchange.INTERRUPTED, Boolean.TRUE).     } }
false;public;0;3;;public ExchangePattern getPattern() {     return pattern. }
false;public;1;3;;public void setPattern(ExchangePattern pattern) {     this.pattern = pattern. }
false;public;0;3;;public Endpoint getFromEndpoint() {     return fromEndpoint. }
false;public;1;3;;public void setFromEndpoint(Endpoint fromEndpoint) {     this.fromEndpoint = fromEndpoint. }
false;public;0;3;;public String getFromRouteId() {     return fromRouteId. }
false;public;1;3;;public void setFromRouteId(String fromRouteId) {     this.fromRouteId = fromRouteId. }
false;public;0;6;;public String getExchangeId() {     if (exchangeId == null) {         exchangeId = createExchangeId().     }     return exchangeId. }
false;public;1;3;;public void setExchangeId(String id) {     this.exchangeId = id. }
false;public;0;6;;public boolean isFailed() {     if (exception != null) {         return true.     }     return hasOut() ? getOut().isFault() : getIn().isFault(). }
false;public;0;8;;public boolean isTransacted() {     UnitOfWork uow = getUnitOfWork().     if (uow != null) {         return uow.isTransacted().     } else {         return false.     } }
false;public;0;24;;public Boolean isExternalRedelivered() {     Boolean answer = null.     // as a exchange property to keep it around for the lifecycle of the exchange     if (hasProperties()) {         answer = getProperty(Exchange.EXTERNAL_REDELIVERED, null, Boolean.class).     }     if (answer == null) {         // lets avoid adding methods to the Message API, so we use the         // DefaultMessage to allow component specific messages to extend         // and implement the isExternalRedelivered method.         Message msg = getIn().         if (msg instanceof DefaultMessage) {             answer = ((DefaultMessage) msg).isTransactedRedelivered().         }     }     return answer. }
false;public;0;3;;public boolean isRollbackOnly() {     return Boolean.TRUE.equals(getProperty(Exchange.ROLLBACK_ONLY)) || Boolean.TRUE.equals(getProperty(Exchange.ROLLBACK_ONLY_LAST)). }
false;public;0;3;;public UnitOfWork getUnitOfWork() {     return unitOfWork. }
false;public;1;14;;public void setUnitOfWork(UnitOfWork unitOfWork) {     this.unitOfWork = unitOfWork.     if (unitOfWork != null && onCompletions != null) {         // we might have registered already         for (Synchronization onCompletion : onCompletions) {             unitOfWork.addSynchronization(onCompletion).         }         // cleanup the temporary on completion list as they now have been registered         // on the unit of work         onCompletions.clear().         onCompletions = null.     } }
false;public;1;12;;public void addOnCompletion(Synchronization onCompletion) {     if (unitOfWork == null) {         // until the unit of work is assigned to this exchange by the unit of work         if (onCompletions == null) {             onCompletions = new ArrayList<>().         }         onCompletions.add(onCompletion).     } else {         getUnitOfWork().addSynchronization(onCompletion).     } }
false;public;1;9;;public boolean containsOnCompletion(Synchronization onCompletion) {     if (unitOfWork != null) {         // if there is an unit of work then the completions is moved there         return unitOfWork.containsSynchronization(onCompletion).     } else {         // check temporary completions if no unit of work yet         return onCompletions != null && onCompletions.contains(onCompletion).     } }
false;public;1;13;;public void handoverCompletions(Exchange target) {     if (onCompletions != null) {         for (Synchronization onCompletion : onCompletions) {             target.addOnCompletion(onCompletion).         }         // cleanup the temporary on completion list as they have been handed over         onCompletions.clear().         onCompletions = null.     } else if (unitOfWork != null) {         // let unit of work handover         unitOfWork.handoverSynchronization(target).     } }
false;public;0;9;;public List<Synchronization> handoverCompletions() {     List<Synchronization> answer = null.     if (onCompletions != null) {         answer = new ArrayList<>(onCompletions).         onCompletions.clear().         onCompletions = null.     }     return answer. }
true;protected;1;7;/**  * Configures the message after it has been set on the exchange  */ ;/**  * Configures the message after it has been set on the exchange  */ protected void configureMessage(Message message) {     if (message instanceof MessageSupport) {         MessageSupport messageSupport = (MessageSupport) message.         messageSupport.setExchange(this).         messageSupport.setCamelContext(getContext()).     } }
false;protected;0;3;;protected String createExchangeId() {     return context.getUuidGenerator().generateUuid(). }
false;protected;0;3;;protected Map<String, Object> createProperties() {     return new ConcurrentHashMap<>(). }
false;protected;1;3;;protected Map<String, Object> createProperties(Map<String, Object> properties) {     return new ConcurrentHashMap<>(properties). }
