commented;modifiers;parameterAmount;loc;comment;code
false;public;0;22;;@Override public void run() {     try {         if (log.isDebugEnabled()) {             log.debug("Invoking operation {} with {}", method.getName(), properties.keySet()).         }         Object result = doInvokeMethod(method, properties).         // producer returns a single response, even for methods with List return types         exchange.getOut().setBody(result).         // copy headers         exchange.getOut().setHeaders(exchange.getIn().getHeaders()).         interceptResult(result, exchange).     } catch (Throwable t) {         exchange.setException(RuntimeCamelException.wrapRuntimeCamelException(t)).     } finally {         callback.done(false).     } }
false;public;2;49;;@Override public boolean process(final Exchange exchange, final AsyncCallback callback) {     // properties for method arguments     final Map<String, Object> properties = new HashMap<>().     properties.putAll(endpoint.getEndpointProperties()).     propertiesHelper.getExchangeProperties(exchange, properties).     // let the endpoint and the Producer intercept properties     endpoint.interceptProperties(properties).     interceptProperties(properties).     // decide which method to invoke     final ApiMethod method = findMethod(exchange, properties).     if (method == null) {         // synchronous failure         callback.done(true).         return true.     }     // create a runnable invocation task to be submitted on a background thread pool     // this way we avoid blocking the current thread for long running methods     Runnable invocation = new Runnable() {          @Override         public void run() {             try {                 if (log.isDebugEnabled()) {                     log.debug("Invoking operation {} with {}", method.getName(), properties.keySet()).                 }                 Object result = doInvokeMethod(method, properties).                 // producer returns a single response, even for methods with List return types                 exchange.getOut().setBody(result).                 // copy headers                 exchange.getOut().setHeaders(exchange.getIn().getHeaders()).                 interceptResult(result, exchange).             } catch (Throwable t) {                 exchange.setException(RuntimeCamelException.wrapRuntimeCamelException(t)).             } finally {                 callback.done(false).             }         }     }.     endpoint.getExecutorService().submit(invocation).     return false. }
false;public;1;4;;@Override public void interceptProperties(Map<String, Object> properties) { // do nothing by default }
true;protected;2;3;/**  * Invoke the API method. Derived classes can override, but MUST call super.doInvokeMethod().  * @param method API method to invoke.  * @param properties method arguments from endpoint properties and exchange In headers.  * @return API method invocation result.  * @throws RuntimeCamelException on error. Exceptions thrown by API method are wrapped.  */ ;/**  * Invoke the API method. Derived classes can override, but MUST call super.doInvokeMethod().  * @param method API method to invoke.  * @param properties method arguments from endpoint properties and exchange In headers.  * @return API method invocation result.  * @throws RuntimeCamelException on error. Exceptions thrown by API method are wrapped.  */ protected Object doInvokeMethod(ApiMethod method, Map<String, Object> properties) throws RuntimeCamelException {     return ApiMethodHelper.invokeMethod(endpoint.getApiProxy(method, properties), method, properties). }
false;public,final;1;5;;@Override public final Object splitResult(Object result) {     // producer never splits results     return result. }
false;public;2;4;;@Override public void interceptResult(Object methodResult, Exchange resultExchange) { // do nothing by default }
false;protected;2;30;;protected ApiMethod findMethod(Exchange exchange, Map<String, Object> properties) {     ApiMethod method = null.     final List<ApiMethod> candidates = endpoint.getCandidates().     if (processInBody(exchange, properties)) {         // filter candidates based on endpoint and exchange properties         final Set<String> argNames = properties.keySet().         final List<ApiMethod> filteredMethods = methodHelper.filterMethods(candidates, ApiMethodHelper.MatchType.SUPER_SET, argNames).         // get the method to call         if (filteredMethods.isEmpty()) {             throw new RuntimeCamelException(String.format("Missing properties for %s, need one or more from %s", endpoint.getMethodName(), methodHelper.getMissingProperties(endpoint.getMethodName(), argNames))).         } else if (filteredMethods.size() == 1) {             // found an exact match             method = filteredMethods.get(0).         } else {             method = ApiMethodHelper.getHighestPriorityMethod(filteredMethods).             log.warn("Calling highest priority operation {} from operations {}", method, filteredMethods).         }     }     return method. }
true;private;2;31;// returns false on exception, which is set in exchange ;// returns false on exception, which is set in exchange private boolean processInBody(Exchange exchange, Map<String, Object> properties) {     final String inBodyProperty = endpoint.getInBody().     if (inBodyProperty != null) {         Object value = exchange.getIn().getBody().         if (value != null) {             try {                 value = endpoint.getCamelContext().getTypeConverter().mandatoryConvertTo(endpoint.getConfiguration().getClass().getDeclaredField(inBodyProperty).getType(), exchange, value).             } catch (Exception e) {                 exchange.setException(new RuntimeCamelException(String.format("Error converting value %s to property %s: %s", value, inBodyProperty, e.getMessage()), e)).                 return false.             }         } else {             // allow null values for inBody only if its a nullable option             if (!methodHelper.getNullableArguments().contains(inBodyProperty)) {                 exchange.setException(new NullPointerException(inBodyProperty)).                 return false.             }         }         log.debug("Property [{}] has message body value {}", inBodyProperty, value).         properties.put(inBodyProperty, value).     }     return true. }
