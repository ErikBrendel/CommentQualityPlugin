commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;1;3;;public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;0;3;;public long getInitialDelay() {     return initialDelay. }
false;public;1;3;;public void setInitialDelay(long initialDelay) {     this.initialDelay = initialDelay. }
false;public;0;3;;public long getDelay() {     return delay. }
false;public;1;3;;public void setDelay(long delay) {     this.delay = delay. }
false;public;0;3;;public TimeUnit getTimeUnit() {     return timeUnit. }
false;public;1;3;;public void setTimeUnit(TimeUnit timeUnit) {     this.timeUnit = timeUnit. }
false;public;0;3;;public boolean isUseFixedDelay() {     return useFixedDelay. }
false;public;1;3;;public void setUseFixedDelay(boolean useFixedDelay) {     this.useFixedDelay = useFixedDelay. }
false;public;0;3;;public ScheduledExecutorService getScheduledExecutorService() {     return scheduledExecutorService. }
false;public;1;3;;public void setScheduledExecutorService(ScheduledExecutorService scheduledExecutorService) {     this.scheduledExecutorService = scheduledExecutorService. }
false;public;0;3;;public int getConcurrentTasks() {     return concurrentTasks. }
false;public;1;3;;public void setConcurrentTasks(int concurrentTasks) {     this.concurrentTasks = concurrentTasks. }
false;public;1;4;;@Override public void onInit(Consumer consumer) {     this.consumer = consumer. }
false;public;1;4;;@Override public void scheduleTask(Runnable task) {     this.task = task. }
false;public;0;9;;@Override public void unscheduleTask() {     if (isSchedulerStarted()) {         for (ScheduledFuture<?> future : futures) {             future.cancel(true).         }         futures.clear().     } }
false;public;0;23;;@Override public void startScheduler() {     // only schedule task if we have not already done that     if (futures.size() == 0) {         if (isUseFixedDelay()) {             if (log.isDebugEnabled()) {                 log.debug("Scheduling poll (fixed delay) with initialDelay: {}, delay: {} ({}) for: {}", new Object[] { getInitialDelay(), getDelay(), getTimeUnit().name().toLowerCase(Locale.ENGLISH), consumer.getEndpoint() }).             }             for (int i = 0. i < concurrentTasks. i++) {                 futures.add(scheduledExecutorService.scheduleWithFixedDelay(task, getInitialDelay(), getDelay(), getTimeUnit())).             }         } else {             if (log.isDebugEnabled()) {                 log.debug("Scheduling poll (fixed rate) with initialDelay: {}, delay: {} ({}) for: {}", new Object[] { getInitialDelay(), getDelay(), getTimeUnit().name().toLowerCase(Locale.ENGLISH), consumer.getEndpoint() }).             }             for (int i = 0. i < concurrentTasks. i++) {                 futures.add(scheduledExecutorService.scheduleAtFixedRate(task, getInitialDelay(), getDelay(), getTimeUnit())).             }         }     } }
false;public;0;4;;@Override public boolean isSchedulerStarted() {     return futures != null && futures.size() > 0. }
false;protected;0;15;;@Override protected void doStart() throws Exception {     ObjectHelper.notNull(consumer, "Consumer", this).     ObjectHelper.notNull(camelContext, "CamelContext", this).     ObjectHelper.notNull(task, "Task", this).     // if no existing executor provided, then create a new thread pool ourselves     if (scheduledExecutorService == null) {         // we only need one thread in the pool to schedule this task         this.scheduledExecutorService = getCamelContext().getExecutorServiceManager().newScheduledThreadPool(consumer, consumer.getEndpoint().getEndpointUri(), concurrentTasks).         // and we should shutdown the thread pool when no longer needed         this.shutdownExecutor = true.     } }
false;protected;0;16;;@Override protected void doStop() throws Exception {     if (isSchedulerStarted()) {         log.debug("This consumer is stopping, so cancelling scheduled task: {}", futures).         for (ScheduledFuture<?> future : futures) {             future.cancel(true).         }         futures.clear().     }     if (shutdownExecutor && scheduledExecutorService != null) {         getCamelContext().getExecutorServiceManager().shutdownNow(scheduledExecutorService).         scheduledExecutorService = null.         futures.clear().     } }
