commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Class<T> getProxyType() {     return proxyType. }
false;public,final;0;3;;public final List<String> getSignatures() {     return signatures. }
false;public,final;1;4;;public final void setSignatures(List<String> signatures) {     this.signatures = new ArrayList<>().     this.signatures.addAll(signatures). }
false;public,final;0;3;;public final ClassLoader getClassLoader() {     return classLoader. }
false;public,final;1;3;;public final void setClassLoader(ClassLoader classLoader) {     this.classLoader = classLoader. }
false;public;2;25;;@Override public int compare(ApiMethodModel model1, ApiMethodModel model2) {     final int nameCompare = model1.name.compareTo(model2.name).     if (nameCompare != 0) {         return nameCompare.     } else {         final int nArgs1 = model1.arguments.size().         final int nArgsCompare = nArgs1 - model2.arguments.size().         if (nArgsCompare != 0) {             return nArgsCompare.         } else {             // same number of args, compare arg names, kinda arbitrary to use alphabetized order             for (int i = 0. i < nArgs1. i++) {                 final int argCompare = model1.arguments.get(i).getName().compareTo(model2.arguments.get(i).getName()).                 if (argCompare != 0) {                     return argCompare.                 }             }             // duplicate methods???             log.warn("Duplicate methods found [{}], [{}]", model1, model2).             return 0.         }     } }
true;public,final;0;147;/**  * Parses the method signatures from {@code getSignatures()}.  * @return list of Api methods as {@link ApiMethodModel}  */ ;/**  * Parses the method signatures from {@code getSignatures()}.  * @return list of Api methods as {@link ApiMethodModel}  */ public final List<ApiMethodModel> parse() {     // parse sorted signatures and generate descriptions     List<ApiMethodModel> result = new ArrayList<>().     for (String signature : signatures) {         // skip comment or empty lines         if (signature.startsWith("##") || ObjectHelper.isEmpty(signature)) {             continue.         }         // remove all modifiers and type parameters for method         signature = signature.replaceAll(METHOD_PREFIX, "$4 $5(").         // remove all final modifiers for arguments         signature = signature.replaceAll("(\\(|,\\s*)final\\s+", "$1").         // remove all redundant spaces in generic parameters         signature = signature.replaceAll("\\s*<\\s*", "<").replaceAll("\\s*>", ">").         log.debug("Processing {}", signature).         final Matcher methodMatcher = METHOD_PATTERN.matcher(signature).         if (!methodMatcher.matches()) {             throw new IllegalArgumentException("Invalid method signature " + signature).         }         // handle generic methods with single bounded type parameters         String genericTypeParameterName = null.         String genericTypeParameterUpperBound = null.         String returnType = null.         try {             genericTypeParameterName = methodMatcher.group("genericTypeParameterName").             genericTypeParameterUpperBound = methodMatcher.group("genericTypeParameterUpperBound").             returnType = methodMatcher.group("returnType").             if (returnType != null && returnType.equals(genericTypeParameterName)) {                 returnType = genericTypeParameterUpperBound.             }         } catch (IllegalArgumentException e) {         // ignore         }         final Class<?> resultType = returnType != null ? forName(returnType) : forName(methodMatcher.group(1)).         final String name = methodMatcher.group(7).         final String argSignature = methodMatcher.group(8).         final List<ApiMethodArg> arguments = new ArrayList<>().         final List<Class<?>> argTypes = new ArrayList<>().         final Matcher argsMatcher = ARGS_PATTERN.matcher(argSignature).         while (argsMatcher.find()) {             String genericParameterName = argsMatcher.group(1).             if (genericTypeParameterName != null && genericTypeParameterName.equals(genericParameterName)) {                 genericParameterName = genericTypeParameterUpperBound.             }             final Class<?> type = forName(genericParameterName).             argTypes.add(type).             String genericParameterUpperbound = argsMatcher.group(2).             String typeArgs = genericParameterUpperbound != null ? genericParameterUpperbound.substring(1, genericParameterUpperbound.length() - 1).replaceAll(" ", "") : null.             if (typeArgs != null && typeArgs.equals(genericTypeParameterName)) {                 typeArgs = genericTypeParameterUpperBound.             }             arguments.add(new ApiMethodArg(argsMatcher.group(3), type, typeArgs)).         }         Method method.         try {             method = proxyType.getMethod(name, argTypes.toArray(new Class<?>[argTypes.size()])).         } catch (NoSuchMethodException e) {             throw new IllegalArgumentException("Method not found [" + signature + "] in type " + proxyType.getName()).         }         result.add(new ApiMethodModel(name, resultType, arguments, method)).     }     // allow derived classes to post process     result = processResults(result).     // check that argument names have the same type across methods     Map<String, Class<?>> allArguments = new HashMap<>().     for (ApiMethodModel model : result) {         for (ApiMethodArg argument : model.getArguments()) {             String name = argument.getName().             Class<?> argClass = allArguments.get(name).             Class<?> type = argument.getType().             if (argClass == null) {                 allArguments.put(name, type).             } else {                 if (argClass != type) {                     throw new IllegalArgumentException("Argument [" + name + "] is used in multiple methods with different types " + argClass.getCanonicalName() + ", " + type.getCanonicalName()).                 }             }         }     }     allArguments.clear().     result.sort(new Comparator<ApiMethodModel>() {          @Override         public int compare(ApiMethodModel model1, ApiMethodModel model2) {             final int nameCompare = model1.name.compareTo(model2.name).             if (nameCompare != 0) {                 return nameCompare.             } else {                 final int nArgs1 = model1.arguments.size().                 final int nArgsCompare = nArgs1 - model2.arguments.size().                 if (nArgsCompare != 0) {                     return nArgsCompare.                 } else {                     // same number of args, compare arg names, kinda arbitrary to use alphabetized order                     for (int i = 0. i < nArgs1. i++) {                         final int argCompare = model1.arguments.get(i).getName().compareTo(model2.arguments.get(i).getName()).                         if (argCompare != 0) {                             return argCompare.                         }                     }                     // duplicate methods???                     log.warn("Duplicate methods found [{}], [{}]", model1, model2).                     return 0.                 }             }         }     }).     // assign unique names to every method model     final Map<String, Integer> dups = new HashMap<>().     for (ApiMethodModel model : result) {         // locale independent upper case conversion         final String name = model.getName().         final char[] upperCase = new char[name.length()].         final char[] lowerCase = name.toCharArray().         for (int i = 0. i < upperCase.length. i++) {             upperCase[i] = Character.toUpperCase(lowerCase[i]).         }         String uniqueName = new String(upperCase).         Integer suffix = dups.get(uniqueName).         if (suffix == null) {             dups.put(uniqueName, 1).         } else {             dups.put(uniqueName, suffix + 1).             StringBuilder builder = new StringBuilder(uniqueName).             builder.append("_").append(suffix).             uniqueName = builder.toString().         }         model.uniqueName = uniqueName.     }     return result. }
false;protected;1;3;;protected List<ApiMethodModel> processResults(List<ApiMethodModel> result) {     return result. }
false;protected;1;7;;protected Class<?> forName(String className) {     try {         return forName(className, classLoader).     } catch (ClassNotFoundException e1) {         throw new IllegalArgumentException("Error loading class " + className).     } }
false;public,static;2;43;;public static Class<?> forName(String className, ClassLoader classLoader) throws ClassNotFoundException {     Class<?> result = null.     try {         // lookup primitive types first         result = PRIMITIVE_TYPES.get(className).         if (result == null) {             result = Class.forName(className, true, classLoader).         }     } catch (ClassNotFoundException e) {         // check if array type         if (className.endsWith("[]")) {             final int firstDim = className.indexOf('[').             final int nDimensions = (className.length() - firstDim) / 2.             result = Array.newInstance(forName(className.substring(0, firstDim), classLoader), new int[nDimensions]).getClass().         } else if (className.indexOf('.') != -1) {             // try replacing last '.' with $ to look for inner classes             String innerClass = className.             while (result == null && innerClass.indexOf('.') != -1) {                 int endIndex = innerClass.lastIndexOf('.').                 innerClass = innerClass.substring(0, endIndex) + "$" + innerClass.substring(endIndex + 1).                 try {                     result = Class.forName(innerClass, true, classLoader).                 } catch (ClassNotFoundException ignore) {                 // ignore                 }             }         }         if (result == null && !className.startsWith(JAVA_LANG)) {             // try loading from default Java package java.lang             try {                 result = forName(JAVA_LANG + className, classLoader).             } catch (ClassNotFoundException ignore) {             // ignore             }         }     }     if (result == null) {         throw new ClassNotFoundException(className).     }     return result. }
false;public;0;3;;public String getUniqueName() {     return uniqueName. }
false;public;0;3;;public String getName() {     return name. }
false;public;0;3;;public Class<?> getResultType() {     return resultType. }
false;public;0;3;;public Method getMethod() {     return method. }
false;public;0;3;;public List<ApiMethodArg> getArguments() {     return arguments. }
false;public;0;15;;@Override public String toString() {     StringBuilder builder = new StringBuilder().     builder.append(resultType.getName()).append(" ").     builder.append(name).append("(").     for (ApiMethodArg argument : arguments) {         builder.append(argument.getType().getCanonicalName()).append(" ").         builder.append(argument.getName()).append(", ").     }     if (!arguments.isEmpty()) {         builder.delete(builder.length() - 2, builder.length()).     }     builder.append(").").     return builder.toString(). }
