commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Override public void close() {     if (stream != null) {         IOHelper.close(stream).     } }
false;public;0;11;;@Override public void reset() {     // reset by closing and creating a new stream based on the file     close().     // reset by creating a new stream based on the file     stream = null.     if (!file.exists()) {         throw new RuntimeCamelException("Cannot reset stream from file " + file).     } }
false;public;1;7;;public void writeTo(OutputStream os) throws IOException {     if (stream == null && ciphers == null) {         Files.copy(file.toPath(), os).     } else {         IOHelper.copy(getInputStream(), os).     } }
false;public;1;5;;public StreamCache copy(Exchange exchange) throws IOException {     tempFileManager.addExchange(exchange).     FileInputStreamCache copy = new FileInputStreamCache(tempFileManager).     return copy. }
false;public;0;3;;public boolean inMemory() {     return false. }
false;public;0;3;;public long length() {     return length. }
false;public;0;4;;@Override public int available() throws IOException {     return getInputStream().available(). }
false;public;0;4;;@Override public int read() throws IOException {     return getInputStream().read(). }
false;protected;0;6;;protected InputStream getInputStream() throws IOException {     if (stream == null) {         stream = createInputStream(file).     }     return stream. }
false;public;0;6;;public void close() throws IOException {     if (!closed) {         super.close().         closed = true.     } }
false;private;1;15;;private InputStream createInputStream(File file) throws IOException {     InputStream in = new BufferedInputStream(Files.newInputStream(file.toPath(), StandardOpenOption.READ)).     if (ciphers != null) {         in = new CipherInputStream(in, ciphers.getDecryptor()) {              boolean closed.              public void close() throws IOException {                 if (!closed) {                     super.close().                     closed = true.                 }             }         }.     }     return in. }
true;synchronized;1;6;/**  * Adds a FileInputStreamCache instance to the closer.  * <p>  * Must be synchronized, because can be accessed by several threads.  */ ;/**  * Adds a FileInputStreamCache instance to the closer.  * <p>  * Must be synchronized, because can be accessed by several threads.  */ synchronized void add(FileInputStreamCache fileInputStreamCache) {     if (fileInputStreamCaches == null) {         fileInputStreamCaches = new ArrayList<>(3).     }     fileInputStreamCaches.add(fileInputStreamCache). }
false;public;1;20;;@Override public void onDone(Exchange exchange) {     int actualExchanges = exchangeCounter.decrementAndGet().     if (actualExchanges == 0) {         // only one exchange (one thread) left, therefore we must not synchronize the following lines of code         try {             closeFileInputStreams().             if (outputStream != null) {                 outputStream.close().             }             try {                 cleanUpTempFile().             } catch (Exception e) {                 LOG.warn("Error deleting temporary cache file: " + tempFile + ". This exception will be ignored.", e).             }         } catch (Exception e) {             LOG.warn("Error closing streams. This exception will be ignored.", e).         }     } }
false;public;0;4;;@Override public String toString() {     return "OnCompletion[CachedOutputStream]". }
false;;1;44;;void addExchange(Exchange exchange) {     if (closedOnCompletion) {         exchangeCounter.incrementAndGet().         // add on completion so we can cleanup after the exchange is done such as deleting temporary files         Synchronization onCompletion = new SynchronizationAdapter() {              @Override             public void onDone(Exchange exchange) {                 int actualExchanges = exchangeCounter.decrementAndGet().                 if (actualExchanges == 0) {                     // only one exchange (one thread) left, therefore we must not synchronize the following lines of code                     try {                         closeFileInputStreams().                         if (outputStream != null) {                             outputStream.close().                         }                         try {                             cleanUpTempFile().                         } catch (Exception e) {                             LOG.warn("Error deleting temporary cache file: " + tempFile + ". This exception will be ignored.", e).                         }                     } catch (Exception e) {                         LOG.warn("Error closing streams. This exception will be ignored.", e).                     }                 }             }              @Override             public String toString() {                 return "OnCompletion[CachedOutputStream]".             }         }.         UnitOfWork streamCacheUnitOfWork = exchange.getProperty(Exchange.STREAM_CACHE_UNIT_OF_WORK, UnitOfWork.class).         if (streamCacheUnitOfWork != null) {             // The stream cache must sometimes not be closed when the exchange is deleted. This is for example the             // case in the splitter and multi-cast case with AggregationStrategy where the result of the sub-routes             // are aggregated later in the main route. Here, the cached streams of the sub-routes must be closed with             // the Unit of Work of the main route.             streamCacheUnitOfWork.addSynchronization(onCompletion).         } else {             // add on completion so we can cleanup after the exchange is done such as deleting temporary files             exchange.addOnCompletion(onCompletion).         }     } }
false;public;0;6;;public void close() throws IOException {     if (!closed) {         super.close().         closed = true.     } }
false;;1;30;;OutputStream createOutputStream(StreamCachingStrategy strategy) throws IOException {     // should only be called once     if (tempFile != null) {         throw new IllegalStateException("The method 'createOutputStream' can only be called once!").     }     tempFile = FileUtil.createTempFile("cos", ".tmp", strategy.getSpoolDirectory()).     LOG.trace("Creating temporary stream cache file: {}", tempFile).     OutputStream out = new BufferedOutputStream(Files.newOutputStream(tempFile.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE)).     if (ObjectHelper.isNotEmpty(strategy.getSpoolChiper())) {         try {             if (ciphers == null) {                 ciphers = new CipherPair(strategy.getSpoolChiper()).             }         } catch (GeneralSecurityException e) {             throw new IOException(e.getMessage(), e).         }         out = new CipherOutputStream(out, ciphers.getEncryptor()) {              boolean closed.              public void close() throws IOException {                 if (!closed) {                     super.close().                     closed = true.                 }             }         }.     }     outputStream = out.     return out. }
false;;0;7;;FileInputStreamCache newStreamCache() throws IOException {     try {         return new FileInputStreamCache(this).     } catch (FileNotFoundException e) {         throw new IOException("Cached file " + tempFile + " not found", e).     } }
false;;0;8;;void closeFileInputStreams() {     if (fileInputStreamCaches != null) {         for (FileInputStreamCache fileInputStreamCache : fileInputStreamCaches) {             fileInputStreamCache.close().         }         fileInputStreamCaches.clear().     } }
false;;0;11;;void cleanUpTempFile() {     // cleanup temporary file     try {         if (tempFile != null) {             FileUtil.deleteFile(tempFile).             tempFile = null.         }     } catch (Exception e) {         LOG.warn("Error deleting temporary cache file: " + tempFile + ". This exception will be ignored.", e).     } }
false;;0;3;;File getTempFile() {     return tempFile. }
false;;0;3;;CipherPair getCiphers() {     return ciphers. }
