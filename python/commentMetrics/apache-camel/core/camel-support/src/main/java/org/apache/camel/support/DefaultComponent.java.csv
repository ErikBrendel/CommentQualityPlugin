commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Deprecated protected String preProcessUri(String uri) {     return UnsafeUriCharactersEncoder.encode(uri). }
false;public;1;67;;public Endpoint createEndpoint(String uri) throws Exception {     ObjectHelper.notNull(getCamelContext(), "camelContext").     // check URI string to the unsafe URI characters     String encodedUri = preProcessUri(uri).     URI u = new URI(encodedUri).     String path.     if (u.getScheme() != null) {         // if there is a scheme then there is also a path         path = URISupport.extractRemainderPath(u, useRawUri()).     } else {         // this uri has no context-path as the leading text is the component name (scheme)         path = null.     }     Map<String, Object> parameters.     if (useRawUri()) {         // when using raw uri then the query is taking from the uri as is         String query.         int idx = uri.indexOf('?').         if (idx > -1) {             query = uri.substring(idx + 1).         } else {             query = u.getRawQuery().         }         // and use method parseQuery         parameters = URISupport.parseQuery(query, true).     } else {         // however when using the encoded (default mode) uri then the query,         // is taken from the URI (ensures values is URI encoded)         // and use method parseParameters         parameters = URISupport.parseParameters(u).     }     // parameters using raw syntax: RAW(value)     // should have the token removed, so its only the value we have in parameters, as we are about to create     // an endpoint and want to have the parameter values without the RAW tokens     URISupport.resolveRawParameterValues(parameters).     // use encoded or raw uri?     uri = useRawUri() ? uri : encodedUri.     validateURI(uri, path, parameters).     if (log.isTraceEnabled()) {         // at trace level its okay to have parameters logged, that may contain passwords         log.trace("Creating endpoint uri=[{}], path=[{}], parameters=[{}]", URISupport.sanitizeUri(uri), URISupport.sanitizePath(path), parameters).     } else if (log.isDebugEnabled()) {         // but at debug level only output sanitized uris         log.debug("Creating endpoint uri=[{}], path=[{}]", URISupport.sanitizeUri(uri), URISupport.sanitizePath(path)).     }     Endpoint endpoint = createEndpoint(uri, path, parameters).     if (endpoint == null) {         return null.     }     endpoint.configureProperties(parameters).     if (useIntrospectionOnEndpoint()) {         setProperties(endpoint, parameters).     }     // fail if there are parameters that could not be set, then they are probably misspell or not supported at all     if (!endpoint.isLenientProperties()) {         validateParameters(uri, parameters, null).     }     afterConfiguration(uri, path, endpoint, parameters).     return endpoint. }
false;public;0;5;;@Override public boolean useRawUri() {     // should use encoded uri by default     return false. }
true;public;1;3;/**  * Whether the component should resolve property placeholders on itself when starting.  * Only properties which are of String type can use property placeholders.  */ ;/**  * Whether the component should resolve property placeholders on itself when starting.  * Only properties which are of String type can use property placeholders.  */ public void setResolvePropertyPlaceholders(boolean resolvePropertyPlaceholders) {     this.resolvePropertyPlaceholders = resolvePropertyPlaceholders. }
true;public;0;3;/**  * Whether the component should resolve property placeholders on itself when starting.  * Only properties which are of String type can use property placeholders.  */ ;/**  * Whether the component should resolve property placeholders on itself when starting.  * Only properties which are of String type can use property placeholders.  */ public boolean isResolvePropertyPlaceholders() {     return resolvePropertyPlaceholders. }
true;protected;4;3;/**  * Strategy to do post configuration logic.  * <p/>  * Can be used to construct an URI based on the remaining parameters. For example the parameters that configures  * the endpoint have been removed from the parameters which leaves only the additional parameters left.  *  * @param uri the uri  * @param remaining the remaining part of the URI without the query parameters or component prefix  * @param endpoint the created endpoint  * @param parameters the remaining parameters after the endpoint has been created and parsed the parameters  * @throws Exception can be thrown to indicate error creating the endpoint  */ ;/**  * Strategy to do post configuration logic.  * <p/>  * Can be used to construct an URI based on the remaining parameters. For example the parameters that configures  * the endpoint have been removed from the parameters which leaves only the additional parameters left.  *  * @param uri the uri  * @param remaining the remaining part of the URI without the query parameters or component prefix  * @param endpoint the created endpoint  * @param parameters the remaining parameters after the endpoint has been created and parsed the parameters  * @throws Exception can be thrown to indicate error creating the endpoint  */ protected void afterConfiguration(String uri, String remaining, Endpoint endpoint, Map<String, Object> parameters) throws Exception { // noop }
true;protected;3;17;/**  * Strategy for validation of parameters, that was not able to be resolved to any endpoint options.  *  * @param uri          the uri  * @param parameters   the parameters, an empty map if no parameters given  * @param optionPrefix optional prefix to filter the parameters for validation. Use <tt>null</tt> for validate all.  * @throws ResolveEndpointFailedException should be thrown if the URI validation failed  */ ;/**  * Strategy for validation of parameters, that was not able to be resolved to any endpoint options.  *  * @param uri          the uri  * @param parameters   the parameters, an empty map if no parameters given  * @param optionPrefix optional prefix to filter the parameters for validation. Use <tt>null</tt> for validate all.  * @throws ResolveEndpointFailedException should be thrown if the URI validation failed  */ protected void validateParameters(String uri, Map<String, Object> parameters, String optionPrefix) {     if (parameters == null || parameters.isEmpty()) {         return.     }     Map<String, Object> param = parameters.     if (optionPrefix != null) {         param = IntrospectionSupport.extractProperties(parameters, optionPrefix).     }     if (param.size() > 0) {         throw new ResolveEndpointFailedException(uri, "There are " + param.size() + " parameters that couldn't be set on the endpoint." + " Check the uri if the parameters are spelt correctly and that they are properties of the endpoint." + " Unknown parameters=[" + param + "]").     } }
true;protected;3;17;/**  * Strategy for validation of the uri when creating the endpoint.  *  * @param uri        the uri  * @param path       the path - part after the scheme  * @param parameters the parameters, an empty map if no parameters given  * @throws ResolveEndpointFailedException should be thrown if the URI validation failed  */ ;/**  * Strategy for validation of the uri when creating the endpoint.  *  * @param uri        the uri  * @param path       the path - part after the scheme  * @param parameters the parameters, an empty map if no parameters given  * @throws ResolveEndpointFailedException should be thrown if the URI validation failed  */ protected void validateURI(String uri, String path, Map<String, Object> parameters) {     // check for uri containing double && markers without include by RAW     if (uri.contains("&&")) {         Matcher m = RAW_PATTERN.matcher(uri).         // we should skip the RAW part         if (!m.find()) {             throw new ResolveEndpointFailedException(uri, "Invalid uri syntax: Double && marker found. " + "Check the uri and remove the duplicate & marker.").         }     }     // if we have a trailing & then that is invalid as well     if (uri.endsWith("&")) {         throw new ResolveEndpointFailedException(uri, "Invalid uri syntax: Trailing & marker found. " + "Check the uri and remove the trailing & marker.").     } }
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;1;3;;public void setCamelContext(CamelContext context) {     this.camelContext = context. }
false;protected;0;14;;protected void doStart() throws Exception {     ObjectHelper.notNull(getCamelContext(), "camelContext").     if (isResolvePropertyPlaceholders()) {         // only resolve property placeholders if its in use         Component existing = camelContext.getPropertiesComponent(false).         if (existing != null) {             log.debug("Resolving property placeholders on component: {}", this).             PropertyPlaceholdersHelper.resolvePropertyPlaceholders(camelContext, this).         } else {             log.debug("Cannot resolve property placeholders on component: {} as PropertiesComponent is not in use", this).         }     } }
false;protected;0;3;;protected void doStop() throws Exception { // noop }
true;protected,abstract;3;2;/**  * A factory method allowing derived components to create a new endpoint  * from the given URI, remaining path and optional parameters  *  * @param uri the full URI of the endpoint  * @param remaining the remaining part of the URI without the query  *                parameters or component prefix  * @param parameters the optional parameters passed in  * @return a newly created endpoint or null if the endpoint cannot be  *         created based on the inputs  * @throws Exception is thrown if error creating the endpoint  */ ;/**  * A factory method allowing derived components to create a new endpoint  * from the given URI, remaining path and optional parameters  *  * @param uri the full URI of the endpoint  * @param remaining the remaining part of the URI without the query  *                parameters or component prefix  * @param parameters the optional parameters passed in  * @return a newly created endpoint or null if the endpoint cannot be  *         created based on the inputs  * @throws Exception is thrown if error creating the endpoint  */ protected abstract Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception.
true;protected;2;3;/**  * Sets the bean properties on the given bean  *  * @param bean  the bean  * @param parameters  properties to set  */ ;/**  * Sets the bean properties on the given bean  *  * @param bean  the bean  * @param parameters  properties to set  */ protected void setProperties(Object bean, Map<String, Object> parameters) throws Exception {     setProperties(getCamelContext(), bean, parameters). }
true;protected;3;5;/**  * Sets the bean properties on the given bean using the given {@link CamelContext}  * @param camelContext  the {@link CamelContext} to use  * @param bean  the bean  * @param parameters  properties to set  */ ;/**  * Sets the bean properties on the given bean using the given {@link CamelContext}  * @param camelContext  the {@link CamelContext} to use  * @param bean  the bean  * @param parameters  properties to set  */ protected void setProperties(CamelContext camelContext, Object bean, Map<String, Object> parameters) throws Exception {     // set reference properties first as they use # syntax that fools the regular properties setter     EndpointHelper.setReferenceProperties(camelContext, bean, parameters).     EndpointHelper.setProperties(camelContext, bean, parameters). }
true;protected;0;3;/**  * Derived classes may wish to overload this to prevent the default introspection of URI parameters  * on the created Endpoint instance  */ ;/**  * Derived classes may wish to overload this to prevent the default introspection of URI parameters  * on the created Endpoint instance  */ protected boolean useIntrospectionOnEndpoint() {     return true. }
true;public;3;3;/**  * Gets the parameter and remove it from the parameter map. This method doesn't resolve  * reference parameters in the registry.  *  * @param parameters the parameters  * @param key        the key  * @param type       the requested type to convert the value from the parameter  * @return the converted value parameter, <tt>null</tt> if parameter does not exists.  * @see #resolveAndRemoveReferenceParameter(Map, String, Class)  */ ;/**  * Gets the parameter and remove it from the parameter map. This method doesn't resolve  * reference parameters in the registry.  *  * @param parameters the parameters  * @param key        the key  * @param type       the requested type to convert the value from the parameter  * @return the converted value parameter, <tt>null</tt> if parameter does not exists.  * @see #resolveAndRemoveReferenceParameter(Map, String, Class)  */ public <T> T getAndRemoveParameter(Map<String, Object> parameters, String key, Class<T> type) {     return getAndRemoveParameter(parameters, key, type, null). }
true;public;4;14;/**  * Gets the parameter and remove it from the parameter map. This method doesn't resolve  * reference parameters in the registry.  *  * @param parameters    the parameters  * @param key           the key  * @param type          the requested type to convert the value from the parameter  * @param defaultValue  use this default value if the parameter does not contain the key  * @return the converted value parameter  * @see #resolveAndRemoveReferenceParameter(Map, String, Class, Object)  */ ;/**  * Gets the parameter and remove it from the parameter map. This method doesn't resolve  * reference parameters in the registry.  *  * @param parameters    the parameters  * @param key           the key  * @param type          the requested type to convert the value from the parameter  * @param defaultValue  use this default value if the parameter does not contain the key  * @return the converted value parameter  * @see #resolveAndRemoveReferenceParameter(Map, String, Class, Object)  */ public <T> T getAndRemoveParameter(Map<String, Object> parameters, String key, Class<T> type, T defaultValue) {     Object value = parameters.remove(key).     if (value != null) {         // if we have a value then convert it         return CamelContextHelper.mandatoryConvertTo(getCamelContext(), type, value).     } else {         value = defaultValue.     }     if (value == null) {         return null.     }     return CamelContextHelper.mandatoryConvertTo(getCamelContext(), type, value). }
true;public;3;3;/**  * Gets the parameter and remove it from the parameter map. This method resolves  * reference parameters in the registry as well.  *  * @param parameters    the parameters  * @param key           the key  * @param type          the requested type to convert the value from the parameter  * @return the converted value parameter  */ ;/**  * Gets the parameter and remove it from the parameter map. This method resolves  * reference parameters in the registry as well.  *  * @param parameters    the parameters  * @param key           the key  * @param type          the requested type to convert the value from the parameter  * @return the converted value parameter  */ public <T> T getAndRemoveOrResolveReferenceParameter(Map<String, Object> parameters, String key, Class<T> type) {     return getAndRemoveOrResolveReferenceParameter(parameters, key, type, null). }
true;public;4;10;/**  * Gets the parameter and remove it from the parameter map. This method resolves  * reference parameters in the registry as well.  *  * @param parameters    the parameters  * @param key           the key  * @param type          the requested type to convert the value from the parameter  * @param defaultValue  use this default value if the parameter does not contain the key  * @return the converted value parameter  */ ;/**  * Gets the parameter and remove it from the parameter map. This method resolves  * reference parameters in the registry as well.  *  * @param parameters    the parameters  * @param key           the key  * @param type          the requested type to convert the value from the parameter  * @param defaultValue  use this default value if the parameter does not contain the key  * @return the converted value parameter  */ public <T> T getAndRemoveOrResolveReferenceParameter(Map<String, Object> parameters, String key, Class<T> type, T defaultValue) {     String value = getAndRemoveParameter(parameters, key, String.class).     if (value == null) {         return defaultValue.     } else if (EndpointHelper.isReferenceParameter(value)) {         return EndpointHelper.resolveReferenceParameter(getCamelContext(), value, type).     } else {         return getCamelContext().getTypeConverter().convertTo(type, value).     } }
true;public;3;3;/**  * Resolves a reference parameter in the registry and removes it from the map.  *  * @param <T>           type of object to lookup in the registry.  * @param parameters    parameter map.  * @param key           parameter map key.  * @param type          type of object to lookup in the registry.  * @return the referenced object or <code>null</code> if the parameter map  *         doesn't contain the key.  * @throws IllegalArgumentException if a non-null reference was not found in  *         registry.  */ ;/**  * Resolves a reference parameter in the registry and removes it from the map.  *  * @param <T>           type of object to lookup in the registry.  * @param parameters    parameter map.  * @param key           parameter map key.  * @param type          type of object to lookup in the registry.  * @return the referenced object or <code>null</code> if the parameter map  *         doesn't contain the key.  * @throws IllegalArgumentException if a non-null reference was not found in  *         registry.  */ public <T> T resolveAndRemoveReferenceParameter(Map<String, Object> parameters, String key, Class<T> type) {     return resolveAndRemoveReferenceParameter(parameters, key, type, null). }
true;public;4;8;/**  * Resolves a reference parameter in the registry and removes it from the map.  *  * @param <T>           type of object to lookup in the registry.  * @param parameters    parameter map.  * @param key           parameter map key.  * @param type          type of object to lookup in the registry.  * @param defaultValue  default value to use if the parameter map doesn't  *                      contain the key.  * @return the referenced object or the default value.  * @throws IllegalArgumentException if referenced object was not found in  *         registry.  */ ;/**  * Resolves a reference parameter in the registry and removes it from the map.  *  * @param <T>           type of object to lookup in the registry.  * @param parameters    parameter map.  * @param key           parameter map key.  * @param type          type of object to lookup in the registry.  * @param defaultValue  default value to use if the parameter map doesn't  *                      contain the key.  * @return the referenced object or the default value.  * @throws IllegalArgumentException if referenced object was not found in  *         registry.  */ public <T> T resolveAndRemoveReferenceParameter(Map<String, Object> parameters, String key, Class<T> type, T defaultValue) {     String value = getAndRemoveParameter(parameters, key, String.class).     if (value == null) {         return defaultValue.     } else {         return EndpointHelper.resolveReferenceParameter(getCamelContext(), value, type).     } }
true;public;3;3;/**  * Resolves a reference list parameter in the registry and removes it from  * the map.  *  * @param parameters parameter map.  * @param key parameter map key.  * @param elementType result list element type.  * @return the list of referenced objects or an empty list if the parameter  *         map doesn't contain the key.  * @throws IllegalArgumentException if any of the referenced objects was  *         not found in registry.  * @see EndpointHelper#resolveReferenceListParameter(CamelContext, String, Class)  */ ;/**  * Resolves a reference list parameter in the registry and removes it from  * the map.  *  * @param parameters parameter map.  * @param key parameter map key.  * @param elementType result list element type.  * @return the list of referenced objects or an empty list if the parameter  *         map doesn't contain the key.  * @throws IllegalArgumentException if any of the referenced objects was  *         not found in registry.  * @see EndpointHelper#resolveReferenceListParameter(CamelContext, String, Class)  */ public <T> List<T> resolveAndRemoveReferenceListParameter(Map<String, Object> parameters, String key, Class<T> elementType) {     return resolveAndRemoveReferenceListParameter(parameters, key, elementType, new ArrayList<>(0)). }
true;public;4;9;/**  * Resolves a reference list parameter in the registry and removes it from  * the map.  *  * @param parameters parameter map.  * @param key parameter map key.  * @param elementType result list element type.  * @param defaultValue default value to use if the parameter map doesn't  *            contain the key.  * @return the list of referenced objects or the default value.  * @throws IllegalArgumentException if any of the referenced objects was  *         not found in registry.  * @see EndpointHelper#resolveReferenceListParameter(CamelContext, String, Class)  */ ;/**  * Resolves a reference list parameter in the registry and removes it from  * the map.  *  * @param parameters parameter map.  * @param key parameter map key.  * @param elementType result list element type.  * @param defaultValue default value to use if the parameter map doesn't  *            contain the key.  * @return the list of referenced objects or the default value.  * @throws IllegalArgumentException if any of the referenced objects was  *         not found in registry.  * @see EndpointHelper#resolveReferenceListParameter(CamelContext, String, Class)  */ public <T> List<T> resolveAndRemoveReferenceListParameter(Map<String, Object> parameters, String key, Class<T> elementType, List<T> defaultValue) {     String value = getAndRemoveParameter(parameters, key, String.class).     if (value == null) {         return defaultValue.     } else {         return EndpointHelper.resolveReferenceListParameter(getCamelContext(), value, elementType).     } }
true;protected;2;9;/**  * Returns the reminder of the text if it starts with the prefix.  * <p/>  * Is useable for string parameters that contains commands.  *  * @param prefix  the prefix  * @param text  the text  * @return the reminder, or null if no reminder  */ ;/**  * Returns the reminder of the text if it starts with the prefix.  * <p/>  * Is useable for string parameters that contains commands.  *  * @param prefix  the prefix  * @param text  the text  * @return the reminder, or null if no reminder  */ protected String ifStartsWithReturnRemainder(String prefix, String text) {     if (text.startsWith(prefix)) {         String remainder = text.substring(prefix.length()).         if (remainder.length() > 0) {             return remainder.         }     }     return null. }
false;protected;1;3;;protected void registerExtension(ComponentExtension extension) {     extensions.add(() -> extension). }
false;protected;1;3;;protected void registerExtension(Supplier<ComponentExtension> supplier) {     extensions.add(Suppliers.memorize(supplier)). }
false;public;0;7;;@Override public Collection<Class<? extends ComponentExtension>> getSupportedExtensions() {     return extensions.stream().map(Supplier::get).map(ComponentExtension::getClass).collect(Collectors.toList()). }
false;public;1;10;;@Override public <T extends ComponentExtension> Optional<T> getExtension(Class<T> extensionType) {     return extensions.stream().map(Supplier::get).filter(extensionType::isInstance).findFirst().map(extensionType::cast).map(e -> Component.trySetComponent(e, this)).map(e -> CamelContextAware.trySetCamelContext(e, getCamelContext())). }
