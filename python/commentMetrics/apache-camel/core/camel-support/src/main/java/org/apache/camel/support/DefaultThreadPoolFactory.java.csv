commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {     return Executors.newCachedThreadPool(threadFactory). }
false;public;2;13;;@Override public ExecutorService newThreadPool(ThreadPoolProfile profile, ThreadFactory factory) {     // allow core thread timeout is default false if not configured     boolean allow = profile.getAllowCoreThreadTimeOut() != null ? profile.getAllowCoreThreadTimeOut() : false.     return newThreadPool(profile.getPoolSize(), profile.getMaxPoolSize(), profile.getKeepAliveTime(), profile.getTimeUnit(), profile.getMaxQueueSize(), allow, profile.getRejectedExecutionHandler(), factory). }
false;public;8;37;;public ExecutorService newThreadPool(int corePoolSize, int maxPoolSize, long keepAliveTime, TimeUnit timeUnit, int maxQueueSize, boolean allowCoreThreadTimeOut, RejectedExecutionHandler rejectedExecutionHandler, ThreadFactory threadFactory) throws IllegalArgumentException {     // the core pool size must be 0 or higher     if (corePoolSize < 0) {         throw new IllegalArgumentException("CorePoolSize must be >= 0, was " + corePoolSize).     }     // validate max >= core     if (maxPoolSize < corePoolSize) {         throw new IllegalArgumentException("MaxPoolSize must be >= corePoolSize, was " + maxPoolSize + " >= " + corePoolSize).     }     BlockingQueue<Runnable> workQueue.     if (corePoolSize == 0 && maxQueueSize <= 0) {         // use a synchronous queue for direct-handover (no tasks stored on the queue)         workQueue = new SynchronousQueue<>().         // and force 1 as pool size to be able to create the thread pool by the JDK         corePoolSize = 1.         maxPoolSize = 1.     } else if (maxQueueSize <= 0) {         // use a synchronous queue for direct-handover (no tasks stored on the queue)         workQueue = new SynchronousQueue<>().     } else {         // bounded task queue to store tasks on the queue         workQueue = new LinkedBlockingQueue<>(maxQueueSize).     }     ThreadPoolExecutor answer = new RejectableThreadPoolExecutor(corePoolSize, maxPoolSize, keepAliveTime, timeUnit, workQueue).     answer.setThreadFactory(threadFactory).     answer.allowCoreThreadTimeOut(allowCoreThreadTimeOut).     if (rejectedExecutionHandler == null) {         rejectedExecutionHandler = new ThreadPoolExecutor.CallerRunsPolicy().     }     answer.setRejectedExecutionHandler(rejectedExecutionHandler).     return answer. }
false;public;2;19;;@Override public ScheduledExecutorService newScheduledThreadPool(ThreadPoolProfile profile, ThreadFactory threadFactory) {     RejectedExecutionHandler rejectedExecutionHandler = profile.getRejectedExecutionHandler().     if (rejectedExecutionHandler == null) {         rejectedExecutionHandler = new ThreadPoolExecutor.CallerRunsPolicy().     }     ScheduledThreadPoolExecutor answer = new RejectableScheduledThreadPoolExecutor(profile.getPoolSize(), threadFactory, rejectedExecutionHandler).     answer.setRemoveOnCancelPolicy(true).     // we could potentially keep adding tasks, and run out of memory.     if (profile.getMaxPoolSize() > 0) {         return new SizedScheduledExecutorService(answer, profile.getMaxQueueSize()).     } else {         return answer.     } }
