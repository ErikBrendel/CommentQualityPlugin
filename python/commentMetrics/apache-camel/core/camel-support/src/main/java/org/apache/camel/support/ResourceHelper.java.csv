commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;7;/**  * Determines whether the URI has a scheme (e.g. file:, classpath: or http:)  *  * @param uri the URI  * @return <tt>true</tt> if the URI starts with a scheme  */ ;/**  * Determines whether the URI has a scheme (e.g. file:, classpath: or http:)  *  * @param uri the URI  * @return <tt>true</tt> if the URI starts with a scheme  */ public static boolean hasScheme(String uri) {     if (uri == null) {         return false.     }     return uri.startsWith("file:") || uri.startsWith("classpath:") || uri.startsWith("http:"). }
true;public,static;1;7;/**  * Gets the scheme from the URI (e.g. file:, classpath: or http:)  *  * @param uri  the uri  * @return the scheme, or <tt>null</tt> if no scheme  */ ;/**  * Gets the scheme from the URI (e.g. file:, classpath: or http:)  *  * @param uri  the uri  * @return the scheme, or <tt>null</tt> if no scheme  */ public static String getScheme(String uri) {     if (hasScheme(uri)) {         return uri.substring(0, uri.indexOf(":") + 1).     } else {         return null.     } }
true;public,static;2;37;/**  * Resolves the mandatory resource.  * <p/>  * The resource uri can refer to the following systems to be loaded from  * <ul>  *     <il>file:nameOfFile - to refer to the file system</il>  *     <il>classpath:nameOfFile - to refer to the classpath (default)</il>  *     <il>http:uri - to load the resource using HTTP</il>  *     <il>ref:nameOfBean - to lookup the resource in the {@link org.apache.camel.spi.Registry}</il>  *     <il>bean:nameOfBean.methodName or bean:nameOfBean::methodName - to lookup a bean in the {@link org.apache.camel.spi.Registry} and call the method</il>  *     <il><customProtocol>:uri - to lookup the resource using a custom {@link java.net.URLStreamHandler} registered for the <customProtocol>,  *     on how to register it @see java.net.URL#URL(java.lang.String, java.lang.String, int, java.lang.String)</il>  * </ul>  * If no prefix has been given, then the resource is loaded from the classpath  * <p/>  * If possible recommended to use {@link #resolveMandatoryResourceAsUrl(org.apache.camel.spi.ClassResolver, String)}  *  * @param camelContext the Camel Context  * @param uri URI of the resource  * @return the resource as an {@link InputStream}.  Remember to close this stream after usage.  * @throws java.io.IOException is thrown if the resource file could not be found or loaded as {@link InputStream}  */ ;/**  * Resolves the mandatory resource.  * <p/>  * The resource uri can refer to the following systems to be loaded from  * <ul>  *     <il>file:nameOfFile - to refer to the file system</il>  *     <il>classpath:nameOfFile - to refer to the classpath (default)</il>  *     <il>http:uri - to load the resource using HTTP</il>  *     <il>ref:nameOfBean - to lookup the resource in the {@link org.apache.camel.spi.Registry}</il>  *     <il>bean:nameOfBean.methodName or bean:nameOfBean::methodName - to lookup a bean in the {@link org.apache.camel.spi.Registry} and call the method</il>  *     <il><customProtocol>:uri - to lookup the resource using a custom {@link java.net.URLStreamHandler} registered for the <customProtocol>,  *     on how to register it @see java.net.URL#URL(java.lang.String, java.lang.String, int, java.lang.String)</il>  * </ul>  * If no prefix has been given, then the resource is loaded from the classpath  * <p/>  * If possible recommended to use {@link #resolveMandatoryResourceAsUrl(org.apache.camel.spi.ClassResolver, String)}  *  * @param camelContext the Camel Context  * @param uri URI of the resource  * @return the resource as an {@link InputStream}.  Remember to close this stream after usage.  * @throws java.io.IOException is thrown if the resource file could not be found or loaded as {@link InputStream}  */ public static InputStream resolveMandatoryResourceAsInputStream(CamelContext camelContext, String uri) throws IOException {     if (uri.startsWith("ref:")) {         String ref = uri.substring(4).         String value = CamelContextHelper.mandatoryLookup(camelContext, ref, String.class).         return new ByteArrayInputStream(value.getBytes()).     } else if (uri.startsWith("bean:")) {         String bean = uri.substring(5).         Exchange dummy = new DefaultExchange(camelContext).         Object out = camelContext.resolveLanguage("bean").createExpression(bean).evaluate(dummy, Object.class).         if (dummy.getException() != null) {             IOException io = new IOException("Cannot find resource: " + uri + " from calling the bean").             io.initCause(dummy.getException()).             throw io.         }         if (out != null) {             InputStream is = camelContext.getTypeConverter().tryConvertTo(InputStream.class, dummy, out).             if (is == null) {                 String text = camelContext.getTypeConverter().tryConvertTo(String.class, dummy, out).                 if (text != null) {                     return new ByteArrayInputStream(text.getBytes()).                 }             } else {                 return is.             }         } else {             throw new IOException("Cannot find resource: " + uri + " from calling the bean").         }     }     InputStream is = resolveResourceAsInputStream(camelContext.getClassResolver(), uri).     if (is == null) {         String resolvedName = resolveUriPath(uri).         throw new FileNotFoundException("Cannot find resource: " + resolvedName + " in classpath for URI: " + uri).     } else {         return is.     } }
true;public,static;2;36;/**  * Resolves the resource.  * <p/>  * If possible recommended to use {@link #resolveMandatoryResourceAsUrl(org.apache.camel.spi.ClassResolver, String)}  *  * @param classResolver the class resolver to load the resource from the classpath  * @param uri URI of the resource  * @return the resource as an {@link InputStream}. Remember to close this stream after usage. Or <tt>null</tt> if not found.  * @throws java.io.IOException is thrown if error loading the resource  */ ;/**  * Resolves the resource.  * <p/>  * If possible recommended to use {@link #resolveMandatoryResourceAsUrl(org.apache.camel.spi.ClassResolver, String)}  *  * @param classResolver the class resolver to load the resource from the classpath  * @param uri URI of the resource  * @return the resource as an {@link InputStream}. Remember to close this stream after usage. Or <tt>null</tt> if not found.  * @throws java.io.IOException is thrown if error loading the resource  */ public static InputStream resolveResourceAsInputStream(ClassResolver classResolver, String uri) throws IOException {     if (uri.startsWith("file:")) {         uri = StringHelper.after(uri, "file:").         uri = tryDecodeUri(uri).         LOG.trace("Loading resource: {} from file system", uri).         return new FileInputStream(uri).     } else if (uri.startsWith("http:")) {         URL url = new URL(uri).         LOG.trace("Loading resource: {} from HTTP", uri).         URLConnection con = url.openConnection().         con.setUseCaches(false).         try {             return con.getInputStream().         } catch (IOException e) {             // leaking gaps in case of an exception             if (con instanceof HttpURLConnection) {                 ((HttpURLConnection) con).disconnect().             }             throw e.         }     } else if (uri.startsWith("classpath:")) {         uri = StringHelper.after(uri, "classpath:").         uri = tryDecodeUri(uri).     } else if (uri.contains(":")) {         LOG.trace("Loading resource: {} with UrlHandler for protocol {}", uri, uri.split(":")[0]).         URL url = new URL(uri).         URLConnection con = url.openConnection().         return con.getInputStream().     }     // load from classpath by default     String resolvedName = resolveUriPath(uri).     LOG.trace("Loading resource: {} from classpath", resolvedName).     return classResolver.loadResourceAsStream(resolvedName). }
true;public,static;2;9;/**  * Resolves the mandatory resource.  *  * @param classResolver the class resolver to load the resource from the classpath  * @param uri uri of the resource  * @return the resource as an {@link java.net.URL}.  * @throws java.io.FileNotFoundException is thrown if the resource file could not be found  * @throws java.net.MalformedURLException if the URI is malformed  */ ;/**  * Resolves the mandatory resource.  *  * @param classResolver the class resolver to load the resource from the classpath  * @param uri uri of the resource  * @return the resource as an {@link java.net.URL}.  * @throws java.io.FileNotFoundException is thrown if the resource file could not be found  * @throws java.net.MalformedURLException if the URI is malformed  */ public static URL resolveMandatoryResourceAsUrl(ClassResolver classResolver, String uri) throws FileNotFoundException, MalformedURLException {     URL url = resolveResourceAsUrl(classResolver, uri).     if (url == null) {         String resolvedName = resolveUriPath(uri).         throw new FileNotFoundException("Cannot find resource: " + resolvedName + " in classpath for URI: " + uri).     } else {         return url.     } }
true;public,static;2;27;/**  * Resolves the resource.  *  * @param classResolver the class resolver to load the resource from the classpath  * @param uri uri of the resource  * @return the resource as an {@link java.net.URL}. Or <tt>null</tt> if not found.  * @throws java.net.MalformedURLException if the URI is malformed  */ ;/**  * Resolves the resource.  *  * @param classResolver the class resolver to load the resource from the classpath  * @param uri uri of the resource  * @return the resource as an {@link java.net.URL}. Or <tt>null</tt> if not found.  * @throws java.net.MalformedURLException if the URI is malformed  */ public static URL resolveResourceAsUrl(ClassResolver classResolver, String uri) throws MalformedURLException {     if (uri.startsWith("file:")) {         // check if file exists first         String name = StringHelper.after(uri, "file:").         uri = tryDecodeUri(uri).         LOG.trace("Loading resource: {} from file system", uri).         File file = new File(name).         if (!file.exists()) {             return null.         }         return new URL(uri).     } else if (uri.startsWith("http:")) {         LOG.trace("Loading resource: {} from HTTP", uri).         return new URL(uri).     } else if (uri.startsWith("classpath:")) {         uri = StringHelper.after(uri, "classpath:").         uri = tryDecodeUri(uri).     } else if (uri.contains(":")) {         LOG.trace("Loading resource: {} with UrlHandler for protocol {}", uri, uri.split(":")[0]).         return new URL(uri).     }     // load from classpath by default     String resolvedName = resolveUriPath(uri).     LOG.trace("Loading resource: {} from classpath", resolvedName).     return classResolver.loadResourceAsURL(resolvedName). }
true;public,static;1;6;/**  * Is the given uri a http uri?  *  * @param uri the uri  * @return <tt>true</tt> if the uri starts with <tt>http:</tt> or <tt>https:</tt>  */ ;/**  * Is the given uri a http uri?  *  * @param uri the uri  * @return <tt>true</tt> if the uri starts with <tt>http:</tt> or <tt>https:</tt>  */ public static boolean isHttpUri(String uri) {     if (uri == null) {         return false.     }     return uri.startsWith("http:") || uri.startsWith("https:"). }
true;public,static;2;12;/**  * Appends the parameters to the given uri  *  * @param uri the uri  * @param parameters the additional parameters (will clear the map)  * @return a new uri with the additional parameters appended  * @throws URISyntaxException is thrown if the uri is invalid  */ ;/**  * Appends the parameters to the given uri  *  * @param uri the uri  * @param parameters the additional parameters (will clear the map)  * @return a new uri with the additional parameters appended  * @throws URISyntaxException is thrown if the uri is invalid  */ public static String appendParameters(String uri, Map<String, Object> parameters) throws URISyntaxException {     // add additional parameters to the resource uri     if (!parameters.isEmpty()) {         String query = URISupport.createQueryString(parameters).         URI u = new URI(uri).         u = URISupport.createURIWithQuery(u, query).         parameters.clear().         return u.toString().     } else {         return uri.     } }
true;private,static;1;4;/**  * Helper operation used to remove relative path notation from  * resources.  Most critical for resources on the Classpath  * as resource loaders will not resolve the relative paths correctly.  *  * @param name the name of the resource to load  * @return the modified or unmodified string if there were no changes  */ ;/**  * Helper operation used to remove relative path notation from  * resources.  Most critical for resources on the Classpath  * as resource loaders will not resolve the relative paths correctly.  *  * @param name the name of the resource to load  * @return the modified or unmodified string if there were no changes  */ private static String resolveUriPath(String name) {     // compact the path and use / as separator as that's used for loading resources on the classpath     return FileUtil.compactPath(name, '/'). }
true;private,static;1;10;/**  * Tries decoding the uri.  *  * @param uri the uri  * @return the decoded uri, or the original uri  */ ;/**  * Tries decoding the uri.  *  * @param uri the uri  * @return the decoded uri, or the original uri  */ private static String tryDecodeUri(String uri) {     try {         // try to decode as the uri may contain %20 for spaces etc         uri = URLDecoder.decode(uri, "UTF-8").     } catch (Exception e) {         LOG.trace("Error URL decoding uri using UTF-8 encoding: {}. This exception is ignored.", uri).     // ignore     }     return uri. }
