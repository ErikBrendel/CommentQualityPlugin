commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getId() {     return sagaId. }
false;public;2;30;;@Override public CompletableFuture<Void> beginStep(Exchange exchange, CamelSagaStep step) {     this.steps.add(step).     if (!step.getOptions().isEmpty()) {         optionValues.putIfAbsent(step, new ConcurrentHashMap<>()).         Map<String, Object> values = optionValues.get(step).         for (String option : step.getOptions().keySet()) {             Expression expression = step.getOptions().get(option).             try {                 values.put(option, expression.evaluate(exchange, Object.class)).             } catch (Exception ex) {                 return CompletableFuture.supplyAsync(() -> {                     throw new RuntimeCamelException("Cannot evaluate saga option '" + option + "'", ex).                 }).             }         }     }     if (step.getTimeoutInMilliseconds().isPresent()) {         sagaService.getExecutorService().schedule(() -> {             boolean doAction = currentStatus.compareAndSet(Status.RUNNING, Status.COMPENSATING).             if (doAction) {                 doCompensate().             }         }, step.getTimeoutInMilliseconds().get(), TimeUnit.MILLISECONDS).     }     return CompletableFuture.completedFuture(null). }
false;public;0;17;;@Override public CompletableFuture<Void> compensate() {     boolean doAction = currentStatus.compareAndSet(Status.RUNNING, Status.COMPENSATING).     if (doAction) {         doCompensate().     } else {         Status status = currentStatus.get().         if (status != Status.COMPENSATING && status != Status.COMPENSATED) {             CompletableFuture<Void> res = new CompletableFuture<>().             res.completeExceptionally(new IllegalStateException("Cannot compensate: status is " + status)).             return res.         }     }     return CompletableFuture.completedFuture(null). }
false;public;0;17;;@Override public CompletableFuture<Void> complete() {     boolean doAction = currentStatus.compareAndSet(Status.RUNNING, Status.COMPLETING).     if (doAction) {         doComplete().     } else {         Status status = currentStatus.get().         if (status != Status.COMPLETING && status != Status.COMPLETED) {             CompletableFuture<Void> res = new CompletableFuture<>().             res.completeExceptionally(new IllegalStateException("Cannot complete: status is " + status)).             return res.         }     }     return CompletableFuture.completedFuture(null). }
false;public;0;7;;public CompletableFuture<Boolean> doCompensate() {     return doFinalize(CamelSagaStep::getCompensation, "compensation").thenApply(res -> {         currentStatus.set(Status.COMPENSATED).         return res.     }). }
false;public;0;7;;public CompletableFuture<Boolean> doComplete() {     return doFinalize(CamelSagaStep::getCompletion, "completion").thenApply(res -> {         currentStatus.set(Status.COMPLETED).         return res.     }). }
false;public;2;17;;public CompletableFuture<Boolean> doFinalize(Function<CamelSagaStep, Optional<Endpoint>> endpointExtractor, String description) {     CompletableFuture<Boolean> result = CompletableFuture.completedFuture(true).     for (CamelSagaStep step : reversed(steps)) {         Optional<Endpoint> endpoint = endpointExtractor.apply(step).         if (endpoint.isPresent()) {             result = result.thenCompose(prevResult -> doFinalize(endpoint.get(), step, 0, description).thenApply(res -> prevResult && res)).         }     }     return result.whenComplete((done, ex) -> {         if (ex != null) {             LOG.error("Cannot finalize " + description + " the saga", ex).         } else if (!done) {             LOG.warn("Unable to finalize " + description + " for all required steps of the saga " + sagaId).         }     }). }
false;private;4;35;;private CompletableFuture<Boolean> doFinalize(Endpoint endpoint, CamelSagaStep step, int doneAttempts, String description) {     Exchange exchange = createExchange(endpoint, step).     return CompletableFuture.supplyAsync(() -> {         Exchange res = camelContext.createFluentProducerTemplate().to(endpoint).withExchange(exchange).send().         Exception ex = res.getException().         if (ex != null) {             throw new RuntimeCamelException(res.getException()).         }         return true.     }, sagaService.getExecutorService()).exceptionally(ex -> {         LOG.warn("Exception thrown during " + description + " at " + endpoint.getEndpointUri() + ". Attempt " + (doneAttempts + 1) + " of " + sagaService.getMaxRetryAttempts(), ex).         return false.     }).thenCompose(executed -> {         int currentAttempt = doneAttempts + 1.         if (executed) {             return CompletableFuture.completedFuture(true).         } else if (currentAttempt >= sagaService.getMaxRetryAttempts()) {             return CompletableFuture.completedFuture(false).         } else {             CompletableFuture<Boolean> future = new CompletableFuture<>().             sagaService.getExecutorService().schedule(() -> {                 doFinalize(endpoint, step, currentAttempt, description).whenComplete((res, ex) -> {                     if (ex != null) {                         future.completeExceptionally(ex).                     } else {                         future.complete(res).                     }                 }).             }, sagaService.getRetryDelayInMilliseconds(), TimeUnit.MILLISECONDS).             return future.         }     }). }
false;private;2;12;;private Exchange createExchange(Endpoint endpoint, CamelSagaStep step) {     Exchange exchange = endpoint.createExchange().     exchange.getIn().setHeader(Exchange.SAGA_LONG_RUNNING_ACTION, getId()).     Map<String, Object> values = optionValues.get(step).     if (values != null) {         for (Map.Entry<String, Object> entry : values.entrySet()) {             exchange.getIn().setHeader(entry.getKey(), entry.getValue()).         }     }     return exchange. }
false;private;1;5;;private <T> List<T> reversed(List<T> list) {     List<T> reversed = new ArrayList<>(list).     Collections.reverse(reversed).     return reversed. }
