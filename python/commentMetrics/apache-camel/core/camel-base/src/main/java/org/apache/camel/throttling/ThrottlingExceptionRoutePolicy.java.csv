commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;0;4;;@Override public CamelContext getCamelContext() {     return camelContext. }
false;public;1;5;;@Override public void onInit(Route route) {     log.debug("Initializing ThrottlingExceptionRoutePolicy route policy...").     logState(). }
false;public;1;7;;@Override public void onStart(Route route) {     // if keepOpen then start w/ the circuit open     if (keepOpen.get()) {         openCircuit(route).     } }
false;public;2;18;;@Override public void onExchangeDone(Route route, Exchange exchange) {     if (keepOpen.get()) {         if (state.get() != STATE_OPEN) {             log.debug("opening circuit b/c keepOpen is on").             openCircuit(route).         }     } else {         if (hasFailed(exchange)) {             // record the failure             failures.incrementAndGet().             lastFailure = System.currentTimeMillis().         }         // check for state change         calculateState(route).     } }
true;private;1;29;/**  * uses similar approach as circuit breaker  * if the exchange has an exception that we are watching  * then we count that as a failure otherwise we ignore it  */ ;/**  * uses similar approach as circuit breaker  * if the exchange has an exception that we are watching  * then we count that as a failure otherwise we ignore it  */ private boolean hasFailed(Exchange exchange) {     if (exchange == null) {         return false.     }     boolean answer = false.     if (exchange.getException() != null) {         if (throttledExceptions == null || throttledExceptions.isEmpty()) {             // if no exceptions defined then always fail             // (ie) assume we throttle on all exceptions             answer = true.         } else {             for (Class<?> exception : throttledExceptions) {                 // will look in exception hierarchy                 if (exchange.getException(exception) != null) {                     answer = true.                     break.                 }             }         }     }     if (log.isDebugEnabled()) {         String exceptionName = exchange.getException() == null ? "none" : exchange.getException().getClass().getSimpleName().         log.debug("hasFailed ({}) with Throttled Exception: {} for exchangeId: {}", answer, exceptionName, exchange.getExchangeId()).     }     return answer. }
false;private;1;45;;private void calculateState(Route route) {     // have we reached the failure limit?     boolean failureLimitReached = isThresholdExceeded().     if (state.get() == STATE_CLOSED) {         if (failureLimitReached) {             log.debug("Opening circuit...").             openCircuit(route).         }     } else if (state.get() == STATE_HALF_OPEN) {         if (failureLimitReached) {             log.debug("Opening circuit...").             openCircuit(route).         } else {             log.debug("Closing circuit...").             closeCircuit(route).         }     } else if (state.get() == STATE_OPEN) {         if (!keepOpen.get()) {             long elapsedTimeSinceOpened = System.currentTimeMillis() - openedAt.             if (halfOpenAfter <= elapsedTimeSinceOpened) {                 log.debug("Checking an open circuit...").                 if (halfOpenHandler != null) {                     if (halfOpenHandler.isReadyToBeClosed()) {                         log.debug("Closing circuit...").                         closeCircuit(route).                     } else {                         log.debug("Opening circuit...").                         openCircuit(route).                     }                 } else {                     log.debug("Half opening circuit...").                     halfOpenCircuit(route).                 }             } else {                 log.debug("keeping circuit open (time not elapsed)...").             }         } else {             log.debug("keeping circuit open (keepOpen is true)...").             this.addHalfOpenTimer(route).         }     } }
false;protected;0;11;;protected boolean isThresholdExceeded() {     boolean output = false.     logState().     // AND the last of those failures occurred within window     if ((failures.get() >= failureThreshold) && (lastFailure >= System.currentTimeMillis() - failureWindow)) {         output = true.     }     return output. }
false;protected;1;14;;protected void openCircuit(Route route) {     try {         lock.lock().         suspendOrStopConsumer(route.getConsumer()).         state.set(STATE_OPEN).         openedAt = System.currentTimeMillis().         this.addHalfOpenTimer(route).         logState().     } catch (Exception e) {         handleException(e).     } finally {         lock.unlock().     } }
false;protected;1;4;;protected void addHalfOpenTimer(Route route) {     halfOpenTimer = new Timer().     halfOpenTimer.schedule(new HalfOpenTask(route), halfOpenAfter). }
false;protected;1;12;;protected void halfOpenCircuit(Route route) {     try {         lock.lock().         resumeOrStartConsumer(route.getConsumer()).         state.set(STATE_HALF_OPEN).         logState().     } catch (Exception e) {         handleException(e).     } finally {         lock.unlock().     } }
false;protected;1;15;;protected void closeCircuit(Route route) {     try {         lock.lock().         resumeOrStartConsumer(route.getConsumer()).         failures.set(0).         lastFailure = 0.         openedAt = 0.         state.set(STATE_CLOSED).         logState().     } catch (Exception e) {         handleException(e).     } finally {         lock.unlock().     } }
false;private;0;5;;private void logState() {     if (log.isDebugEnabled()) {         log.debug(dumpState()).     } }
false;public;0;9;;public String dumpState() {     int num = state.get().     String routeState = stateAsString(num).     if (failures.get() > 0) {         return String.format("State %s, failures %d, last failure %d ms ago", routeState, failures.get(), System.currentTimeMillis() - lastFailure).     } else {         return String.format("State %s, failures %d", routeState, failures.get()).     } }
false;private,static;1;9;;private static String stateAsString(int num) {     if (num == STATE_CLOSED) {         return "closed".     } else if (num == STATE_HALF_OPEN) {         return "half opened".     } else {         return "opened".     } }
false;public;0;5;;@Override public void run() {     halfOpenTimer.cancel().     calculateState(route). }
false;public;0;3;;public ThrottlingExceptionHalfOpenHandler getHalfOpenHandler() {     return halfOpenHandler. }
false;public;1;3;;public void setHalfOpenHandler(ThrottlingExceptionHalfOpenHandler halfOpenHandler) {     this.halfOpenHandler = halfOpenHandler. }
false;public;0;3;;public boolean getKeepOpen() {     return this.keepOpen.get(). }
false;public;1;4;;public void setKeepOpen(boolean keepOpen) {     log.debug("keep open: {}", keepOpen).     this.keepOpen.set(keepOpen). }
false;public;0;3;;public int getFailureThreshold() {     return failureThreshold. }
false;public;1;3;;public void setFailureThreshold(int failureThreshold) {     this.failureThreshold = failureThreshold. }
false;public;0;3;;public long getFailureWindow() {     return failureWindow. }
false;public;1;3;;public void setFailureWindow(long failureWindow) {     this.failureWindow = failureWindow. }
false;public;0;3;;public long getHalfOpenAfter() {     return halfOpenAfter. }
false;public;1;3;;public void setHalfOpenAfter(long halfOpenAfter) {     this.halfOpenAfter = halfOpenAfter. }
false;public;0;3;;public int getFailures() {     return failures.get(). }
false;public;0;3;;public long getLastFailure() {     return lastFailure. }
false;public;0;3;;public long getOpenedAt() {     return openedAt. }
