commented;modifiers;parameterAmount;loc;comment;code
true;public;0;6;/**  * Returns the default set of output properties for conversions.  */ ;/**  * Returns the default set of output properties for conversions.  */ public Properties defaultOutputProperties() {     Properties properties = new Properties().     properties.put(OutputKeys.ENCODING, defaultCharset).     properties.put(OutputKeys.OMIT_XML_DECLARATION, "yes").     return properties. }
true;public;2;3;/**  * Converts the given input Source into the required result  */ ;/**  * Converts the given input Source into the required result  */ public void toResult(Source source, Result result) throws TransformerException {     toResult(source, result, defaultOutputProperties()). }
true;public;3;17;/**  * Converts the given input Source into the required result  */ ;/**  * Converts the given input Source into the required result  */ public void toResult(Source source, Result result, Properties outputProperties) throws TransformerException {     if (source == null) {         return.     }     Transformer transformer = createTransformer().     if (transformer == null) {         throw new TransformerException("Could not create a transformer - JAXP is misconfigured!").     }     transformer.setOutputProperties(outputProperties).     if (this.transformerFactory.getClass().getName().equals(XALAN_TRANSFORMER_FACTORY) && (source instanceof StAXSource)) {         // external xalan can't handle StAXSource, so convert StAXSource to SAXSource.         source = new StAX2SAXSource(((StAXSource) source).getXMLStreamReader()).     }     transformer.transform(source, result). }
true;public;1;4;/**  * Converts the given NodeList to a boolean  */ ;/**  * Converts the given NodeList to a boolean  */ @Converter public Boolean toBoolean(NodeList list) {     return list.getLength() > 0. }
true;public;1;4;/**  * Converts the given byte[] to a Source  */ ;/**  * Converts the given byte[] to a Source  */ @Converter public BytesSource toBytesSource(byte[] data) {     return new BytesSource(data). }
true;public;1;4;/**  * Converts the given String to a Source  */ ;/**  * Converts the given String to a Source  */ @Converter public StringSource toStringSource(String data) {     return new StringSource(data). }
true;public;1;5;/**  * Converts the given Node to a Source  */ ;/**  * Converts the given Node to a Source  */ @Converter public DOMSource toDOMSource(Node node) throws ParserConfigurationException, TransformerException {     Document document = toDOMDocument(node).     return new DOMSource(document). }
true;public;1;4;/**  * Converts the given Document to a DOMSource  */ ;/**  * Converts the given Document to a DOMSource  */ @Converter public DOMSource toDOMSource(Document document) {     return new DOMSource(document). }
true;public;1;4;/**  * Converts the given String to a Source  */ ;/**  * Converts the given String to a Source  */ @Converter public Source toSource(String data) {     return new StringSource(data). }
true;public;2;23;/**  * Converts the given input Source into text  */ ;/**  * Converts the given input Source into text  */ @Converter public String toString(Source source, Exchange exchange) throws TransformerException {     if (source == null) {         return null.     } else if (source instanceof StringSource) {         return ((StringSource) source).getText().     } else if (source instanceof BytesSource) {         return new String(((BytesSource) source).getData()).     } else {         StringWriter buffer = new StringWriter().         if (exchange != null) {             // check the camelContext properties first             Properties properties = CamelContextHelper.getCamelPropertiesWithPrefix(OUTPUT_PROPERTIES_PREFIX, exchange.getContext()).             if (properties.size() > 0) {                 toResult(source, new StreamResult(buffer), properties).                 return buffer.toString().             }         }         // using the old way to deal with it         toResult(source, new StreamResult(buffer)).         return buffer.toString().     } }
true;public;2;20;/**  * Converts the given input Source into bytes  */ ;/**  * Converts the given input Source into bytes  */ @Converter public byte[] toByteArray(Source source, Exchange exchange) throws TransformerException {     if (source instanceof BytesSource) {         return ((BytesSource) source).getData().     } else {         ByteArrayOutputStream buffer = new ByteArrayOutputStream().         if (exchange != null) {             // check the camelContext properties first             Properties properties = CamelContextHelper.getCamelPropertiesWithPrefix(OUTPUT_PROPERTIES_PREFIX, exchange.getContext()).             if (properties.size() > 0) {                 toResult(source, new StreamResult(buffer), properties).                 return buffer.toByteArray().             }         }         // using the old way to deal with it         toResult(source, new StreamResult(buffer)).         return buffer.toByteArray().     } }
true;public;2;4;/**  * Converts the given input Node into text  */ ;/**  * Converts the given input Node into text  */ @Converter public String toString(Node node, Exchange exchange) throws TransformerException {     return toString(new DOMSource(node), exchange). }
true;public;2;10;/**  * Converts the given Document to into text  * @param document The document to convert  * @param outputOptions The {@link OutputKeys} properties to control various aspects of the XML output  * @return The string representation of the document  * @throws TransformerException  */ ;/**  * Converts the given Document to into text  * @param document The document to convert  * @param outputOptions The {@link OutputKeys} properties to control various aspects of the XML output  * @return The string representation of the document  * @throws TransformerException  */ public String toStringFromDocument(Document document, Properties outputOptions) throws TransformerException {     if (document == null) {         return null.     }     DOMSource source = new DOMSource(document).     StringWriter buffer = new StringWriter().     toResult(source, new StreamResult(buffer), outputOptions).     return buffer.toString(). }
true;public;2;14;/**  * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  */ ;/**  * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  */ @Converter public DOMSource toDOMSource(Source source, Exchange exchange) throws ParserConfigurationException, IOException, SAXException, TransformerException {     if (source instanceof DOMSource) {         return (DOMSource) source.     } else if (source instanceof SAXSource) {         return toDOMSourceFromSAX((SAXSource) source).     } else if (source instanceof StreamSource) {         return toDOMSourceFromStream((StreamSource) source, exchange).     } else if (source instanceof StAXSource) {         return toDOMSourceFromStAX((StAXSource) source).     } else {         return null.     } }
true;public;1;5;/**  * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  */ ;/**  * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  */ @Converter public DOMSource toDOMSource(String text) throws ParserConfigurationException, IOException, SAXException, TransformerException {     Source source = toSource(text).     return toDOMSourceFromStream((StreamSource) source, null). }
true;public;1;9;/**  * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  */ ;/**  * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  */ @Converter public DOMSource toDOMSource(byte[] bytes) throws IOException, SAXException, ParserConfigurationException {     InputStream is = new ByteArrayInputStream(bytes).     try {         return toDOMSource(is, null).     } finally {         IOHelper.close(is).     } }
true;public;2;4;/**  * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  */ ;/**  * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  */ @Converter public SAXSource toSAXSource(String source, Exchange exchange) throws IOException, SAXException, TransformerException {     return toSAXSource(toSource(source), exchange). }
true;public;2;5;/**  * Converts the source instance to a {@link StAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  * @throws XMLStreamException  */ ;/**  * Converts the source instance to a {@link StAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  * @throws XMLStreamException  */ @Converter public StAXSource toStAXSource(String source, Exchange exchange) throws XMLStreamException {     XMLStreamReader r = new StaxConverter().createXMLStreamReader(new StringReader(source)).     return new StAXSource(r). }
true;public;2;5;/**  * Converts the source instance to a {@link StAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  * @throws XMLStreamException  */ ;/**  * Converts the source instance to a {@link StAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  * @throws XMLStreamException  */ @Converter public StAXSource toStAXSource(byte[] in, Exchange exchange) throws XMLStreamException {     XMLStreamReader r = new StaxConverter().createXMLStreamReader(new ByteArrayInputStream(in), exchange).     return new StAXSource(r). }
true;public;2;4;/**  * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  */ ;/**  * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  */ @Converter public SAXSource toSAXSource(InputStream source, Exchange exchange) throws IOException, SAXException, TransformerException {     return toSAXSource(toStreamSource(source), exchange). }
true;public;2;4;/**  * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  */ ;/**  * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  */ @Converter public SAXSource toSAXSource(byte[] in, Exchange exchange) throws IOException, SAXException, TransformerException {     return toSAXSource(toStreamSource(in, exchange), exchange). }
true;public;2;5;/**  * Converts the source instance to a {@link StAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  * @throws XMLStreamException  */ ;/**  * Converts the source instance to a {@link StAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  * @throws XMLStreamException  */ @Converter public StAXSource toStAXSource(InputStream source, Exchange exchange) throws XMLStreamException {     XMLStreamReader r = new StaxConverter().createXMLStreamReader(source, exchange).     return new StAXSource(r). }
true;public;2;5;/**  * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  */ ;/**  * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  */ @Converter public SAXSource toSAXSource(File file, Exchange exchange) throws IOException, SAXException, TransformerException {     InputStream is = IOHelper.buffered(new FileInputStream(file)).     return toSAXSource(is, exchange). }
true;public;2;6;/**  * Converts the source instance to a {@link StAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  * @throws FileNotFoundException  * @throws XMLStreamException  */ ;/**  * Converts the source instance to a {@link StAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  * @throws FileNotFoundException  * @throws XMLStreamException  */ @Converter public StAXSource toStAXSource(File file, Exchange exchange) throws FileNotFoundException, XMLStreamException {     InputStream is = IOHelper.buffered(new FileInputStream(file)).     XMLStreamReader r = new StaxConverter().createXMLStreamReader(is, exchange).     return new StAXSource(r). }
true;public;2;14;/**  * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  */ ;/**  * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not  * supported (making it easy to derive from this class to add new kinds of conversion).  */ @Converter public SAXSource toSAXSource(Source source, Exchange exchange) throws IOException, SAXException, TransformerException {     if (source instanceof SAXSource) {         return (SAXSource) source.     } else if (source instanceof DOMSource) {         return toSAXSourceFromDOM((DOMSource) source, exchange).     } else if (source instanceof StreamSource) {         return toSAXSourceFromStream((StreamSource) source, exchange).     } else if (source instanceof StAXSource) {         return toSAXSourceFromStAX((StAXSource) source, exchange).     } else {         return null.     } }
false;public;2;14;;@Converter public StreamSource toStreamSource(Source source, Exchange exchange) throws TransformerException {     if (source instanceof StreamSource) {         return (StreamSource) source.     } else if (source instanceof DOMSource) {         return toStreamSourceFromDOM((DOMSource) source, exchange).     } else if (source instanceof SAXSource) {         return toStreamSourceFromSAX((SAXSource) source, exchange).     } else if (source instanceof StAXSource) {         return toStreamSourceFromStAX((StAXSource) source, exchange).     } else {         return null.     } }
false;public;1;4;;@Converter public StreamSource toStreamSource(InputStream in) throws TransformerException {     return new StreamSource(in). }
false;public;1;4;;@Converter public StreamSource toStreamSource(Reader in) throws TransformerException {     return new StreamSource(in). }
false;public;1;4;;@Converter public StreamSource toStreamSource(File in) throws TransformerException {     return new StreamSource(in). }
false;public;2;5;;@Converter public StreamSource toStreamSource(byte[] in, Exchange exchange) throws TransformerException {     InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, in).     return new StreamSource(is). }
false;public;2;5;;@Converter public StreamSource toStreamSource(ByteBuffer in, Exchange exchange) throws TransformerException {     InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, in).     return new StreamSource(is). }
false;public;2;14;;@Converter public StreamSource toStreamSourceFromSAX(SAXSource source, Exchange exchange) throws TransformerException {     InputSource inputSource = source.getInputSource().     if (inputSource != null) {         if (inputSource.getCharacterStream() != null) {             return new StreamSource(inputSource.getCharacterStream()).         }         if (inputSource.getByteStream() != null) {             return new StreamSource(inputSource.getByteStream()).         }     }     String result = toString(source, exchange).     return new StringSource(result). }
false;public;2;5;;@Converter public StreamSource toStreamSourceFromDOM(DOMSource source, Exchange exchange) throws TransformerException {     String result = toString(source, exchange).     return new StringSource(result). }
false;public;2;5;;@Converter public StreamSource toStreamSourceFromStAX(StAXSource source, Exchange exchange) throws TransformerException {     String result = toString(source, exchange).     return new StringSource(result). }
false;public;2;34;;@Converter public SAXSource toSAXSourceFromStream(StreamSource source, Exchange exchange) throws SAXException {     InputSource inputSource.     if (source.getReader() != null) {         inputSource = new InputSource(source.getReader()).     } else {         inputSource = new InputSource(source.getInputStream()).     }     inputSource.setSystemId(source.getSystemId()).     inputSource.setPublicId(source.getPublicId()).     XMLReader xmlReader = null.     try {         // use the SAXPaserFactory which is set from exchange         if (exchange != null) {             SAXParserFactory sfactory = exchange.getProperty(Exchange.SAXPARSER_FACTORY, SAXParserFactory.class).             if (sfactory != null) {                 if (!sfactory.isNamespaceAware()) {                     sfactory.setNamespaceAware(true).                 }                 xmlReader = sfactory.newSAXParser().getXMLReader().             }         }         if (xmlReader == null) {             if (xmlReaderPool == null) {                 xmlReaderPool = new XMLReaderPool(createSAXParserFactory()).             }             xmlReader = xmlReaderPool.createXMLReader().         }     } catch (Exception ex) {         LOG.warn("Cannot create the SAXParser XMLReader, due to {}", ex).     }     return new SAXSource(xmlReader, inputSource). }
false;public;2;9;;@Converter public Reader toReaderFromSource(Source src, Exchange exchange) throws TransformerException {     StreamSource stSrc = toStreamSource(src, exchange).     Reader r = stSrc.getReader().     if (r == null) {         r = new InputStreamReader(stSrc.getInputStream()).     }     return r. }
false;public;2;8;;@Converter public DOMSource toDOMSource(InputStream is, Exchange exchange) throws ParserConfigurationException, IOException, SAXException {     InputSource source = new InputSource(is).     String systemId = source.getSystemId().     DocumentBuilder builder = createDocumentBuilder(getDocumentBuilderFactory(exchange)).     Document document = builder.parse(source).     return new DOMSource(document, systemId). }
false;public;2;5;;@Converter public DOMSource toDOMSource(File file, Exchange exchange) throws ParserConfigurationException, IOException, SAXException {     InputStream is = IOHelper.buffered(new FileInputStream(file)).     return toDOMSource(is, exchange). }
false;public;2;21;;@Converter public DOMSource toDOMSourceFromStream(StreamSource source, Exchange exchange) throws ParserConfigurationException, IOException, SAXException {     Document document.     String systemId = source.getSystemId().     DocumentBuilder builder = createDocumentBuilder(getDocumentBuilderFactory(exchange)).     Reader reader = source.getReader().     if (reader != null) {         document = builder.parse(new InputSource(reader)).     } else {         InputStream inputStream = source.getInputStream().         if (inputStream != null) {             InputSource inputsource = new InputSource(inputStream).             inputsource.setSystemId(systemId).             document = builder.parse(inputsource).         } else {             throw new IOException("No input stream or reader available on StreamSource: " + source).         }     }     return new DOMSource(document, systemId). }
false;public;2;6;;@Converter public SAXSource toSAXSourceFromDOM(DOMSource source, Exchange exchange) throws TransformerException {     String str = toString(source, exchange).     StringReader reader = new StringReader(str).     return new SAXSource(new InputSource(reader)). }
false;public;2;6;;@Converter public SAXSource toSAXSourceFromStAX(StAXSource source, Exchange exchange) throws TransformerException {     String str = toString(source, exchange).     StringReader reader = new StringReader(str).     return new SAXSource(new InputSource(reader)). }
false;public;1;4;;@Converter public DOMSource toDOMSourceFromSAX(SAXSource source) throws IOException, SAXException, ParserConfigurationException, TransformerException {     return new DOMSource(toDOMNodeFromSAX(source)). }
false;public;1;4;;@Converter public DOMSource toDOMSourceFromStAX(StAXSource source) throws IOException, SAXException, ParserConfigurationException, TransformerException {     return new DOMSource(toDOMNodeFromStAX(source)). }
false;public;1;6;;@Converter public Node toDOMNodeFromSAX(SAXSource source) throws ParserConfigurationException, IOException, SAXException, TransformerException {     DOMResult result = new DOMResult().     toResult(source, result).     return result.getNode(). }
false;public;1;6;;@Converter public Node toDOMNodeFromStAX(StAXSource source) throws ParserConfigurationException, IOException, SAXException, TransformerException {     DOMResult result = new DOMResult().     toResult(source, result).     return result.getNode(). }
true;public;1;4;/**  * Convert a NodeList consisting of just 1 node to a DOM Node.  * @param nl the NodeList  * @return the DOM Node  */ ;/**  * Convert a NodeList consisting of just 1 node to a DOM Node.  * @param nl the NodeList  * @return the DOM Node  */ @Converter(allowNull = true) public Node toDOMNodeFromSingleNodeList(NodeList nl) {     return nl.getLength() == 1 ? nl.item(0) : null. }
true;public;1;12;/**  * Convert a NodeList consisting of just 1 node to a DOM Document.  * Cannot convert NodeList with length > 1 because they require a root node.  * @param nl the NodeList  * @return the DOM Document  */ ;/**  * Convert a NodeList consisting of just 1 node to a DOM Document.  * Cannot convert NodeList with length > 1 because they require a root node.  * @param nl the NodeList  * @return the DOM Document  */ @Converter(allowNull = true) public Document toDOMDocumentFromSingleNodeList(NodeList nl) throws ParserConfigurationException, TransformerException {     if (nl.getLength() == 1) {         return toDOMDocument(nl.item(0)).     } else if (nl instanceof Node) {         // may lookup either a type converter from NodeList or Node. So let's fallback and try with Node         return toDOMDocument((Node) nl).     } else {         return null.     } }
true;public;1;5;/**  * Converts the given TRaX Source into a W3C DOM node  */ ;/**  * Converts the given TRaX Source into a W3C DOM node  */ @Converter(allowNull = true) public Node toDOMNode(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {     DOMSource domSrc = toDOMSource(source, null).     return domSrc != null ? domSrc.getNode() : null. }
true;public;1;5;/**  * Create a DOM element from the given source.  */ ;/**  * Create a DOM element from the given source.  */ @Converter public Element toDOMElement(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {     Node node = toDOMNode(source).     return toDOMElement(node). }
true;public;1;13;/**  * Create a DOM element from the DOM node.  * Simply cast if the node is an Element, or  * return the root element if it is a Document.  */ ;/**  * Create a DOM element from the DOM node.  * Simply cast if the node is an Element, or  * return the root element if it is a Document.  */ @Converter public Element toDOMElement(Node node) throws TransformerException {     // If the node is an document, return the root element     if (node instanceof Document) {         return ((Document) node).getDocumentElement().     // If the node is an element, just cast it     } else if (node instanceof Element) {         return (Element) node.     // Other node types are not handled     } else {         throw new TransformerException("Unable to convert DOM node to an Element").     } }
true;public;2;5;/**  * Converts the given data to a DOM document  *  * @param data is the data to be parsed  * @param exchange is the exchange to be used when calling the converter  * @return the parsed document  */ ;/**  * Converts the given data to a DOM document  *  * @param data is the data to be parsed  * @param exchange is the exchange to be used when calling the converter  * @return the parsed document  */ @Converter public Document toDOMDocument(byte[] data, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {     DocumentBuilder documentBuilder = createDocumentBuilder(getDocumentBuilderFactory(exchange)).     return documentBuilder.parse(new ByteArrayInputStream(data)). }
true;public;2;12;/**  * Converts the given {@link InputStream} to a DOM document  *  * @param in is the data to be parsed  * @param exchange is the exchange to be used when calling the converter  * @return the parsed document  */ ;/**  * Converts the given {@link InputStream} to a DOM document  *  * @param in is the data to be parsed  * @param exchange is the exchange to be used when calling the converter  * @return the parsed document  */ @Converter public Document toDOMDocument(InputStream in, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {     DocumentBuilder documentBuilder = createDocumentBuilder(getDocumentBuilderFactory(exchange)).     if (in instanceof IOHelper.EncodingInputStream) {         // DocumentBuilder detects encoding from XML declaration, so we need to         // revert the converted encoding for the input stream         IOHelper.EncodingInputStream encIn = (IOHelper.EncodingInputStream) in.         return documentBuilder.parse(encIn.toOriginalInputStream()).     } else {         return documentBuilder.parse(in).     } }
true;public;2;4;/**  * Converts the given {@link Reader} to a DOM document  *  * @param in is the data to be parsed  * @param exchange is the exchange to be used when calling the converter  * @return the parsed document  */ ;/**  * Converts the given {@link Reader} to a DOM document  *  * @param in is the data to be parsed  * @param exchange is the exchange to be used when calling the converter  * @return the parsed document  */ @Converter public Document toDOMDocument(Reader in, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {     return toDOMDocument(new InputSource(in), exchange). }
true;public;2;5;/**  * Converts the given {@link InputSource} to a DOM document  *  * @param in is the data to be parsed  * @param exchange is the exchange to be used when calling the converter  * @return the parsed document  */ ;/**  * Converts the given {@link InputSource} to a DOM document  *  * @param in is the data to be parsed  * @param exchange is the exchange to be used when calling the converter  * @return the parsed document  */ @Converter public Document toDOMDocument(InputSource in, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {     DocumentBuilder documentBuilder = createDocumentBuilder(getDocumentBuilderFactory(exchange)).     return documentBuilder.parse(in). }
true;public;2;4;/**  * Converts the given {@link String} to a DOM document  *  * @param text is the data to be parsed  * @param exchange is the exchange to be used when calling the converter  * @return the parsed document  */ ;/**  * Converts the given {@link String} to a DOM document  *  * @param text is the data to be parsed  * @param exchange is the exchange to be used when calling the converter  * @return the parsed document  */ @Converter public Document toDOMDocument(String text, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {     return toDOMDocument(new StringReader(text), exchange). }
true;public;2;5;/**  * Converts the given {@link File} to a DOM document  *  * @param file is the data to be parsed  * @param exchange is the exchange to be used when calling the converter  * @return the parsed document  */ ;/**  * Converts the given {@link File} to a DOM document  *  * @param file is the data to be parsed  * @param exchange is the exchange to be used when calling the converter  * @return the parsed document  */ @Converter public Document toDOMDocument(File file, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {     DocumentBuilder documentBuilder = createDocumentBuilder(getDocumentBuilderFactory(exchange)).     return documentBuilder.parse(file). }
true;public;1;5;/**  * Create a DOM document from the given source.  */ ;/**  * Create a DOM document from the given source.  */ @Converter public Document toDOMDocument(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {     Node node = toDOMNode(source).     return toDOMDocument(node). }
true;public;1;28;/**  * Create a DOM document from the given Node.  *  * If the node is an document, just cast it, if the node is an root element, retrieve its  * owner element or create a new document and import the node.  */ ;/**  * Create a DOM document from the given Node.  *  * If the node is an document, just cast it, if the node is an root element, retrieve its  * owner element or create a new document and import the node.  */ @Converter public Document toDOMDocument(final Node node) throws ParserConfigurationException, TransformerException {     ObjectHelper.notNull(node, "node").     // If the node is the document, just cast it     if (node instanceof Document) {         return (Document) node.     // If the node is an element     } else if (node instanceof Element) {         Element elem = (Element) node.         // If this is the root element, return its owner document         if (elem.getOwnerDocument().getDocumentElement() == elem) {             return elem.getOwnerDocument().         // else, create a new doc and copy the element inside it         } else {             Document doc = createDocument().             // so we need to synchronize on it             synchronized (node.getOwnerDocument()) {                 doc.appendChild(doc.importNode(node, true)).             }             return doc.         }     // other element types are not handled     } else {         throw new TransformerException("Unable to convert DOM node to a Document: " + node).     } }
false;public;2;4;;@Converter public InputStream toInputStream(DOMSource source, Exchange exchange) throws TransformerException, IOException {     return new ByteArrayInputStream(toByteArray(source, exchange)). }
false;public;2;4;;@Converter public InputStream toInputStream(Document dom, Exchange exchange) throws TransformerException, IOException {     return toInputStream(new DOMSource(dom), exchange). }
false;public;2;4;;@Converter public InputSource toInputSource(InputStream is, Exchange exchange) {     return new InputSource(is). }
false;public;2;5;;@Converter public InputSource toInputSource(File file, Exchange exchange) throws FileNotFoundException {     InputStream is = IOHelper.buffered(new FileInputStream(file)).     return new InputSource(is). }
false;public;0;6;;// Properties // ------------------------------------------------------------------------- public DocumentBuilderFactory getDocumentBuilderFactory() {     if (documentBuilderFactory == null) {         documentBuilderFactory = createDocumentBuilderFactory().     }     return documentBuilderFactory. }
false;public;1;3;;public void setDocumentBuilderFactory(DocumentBuilderFactory documentBuilderFactory) {     this.documentBuilderFactory = documentBuilderFactory. }
false;public;0;6;;public TransformerFactory getTransformerFactory() {     if (transformerFactory == null) {         transformerFactory = createTransformerFactory().     }     return transformerFactory. }
false;public;1;6;;public void setTransformerFactory(TransformerFactory transformerFactory) {     if (transformerFactory != null) {         configureSaxonTransformerFactory(transformerFactory).     }     this.transformerFactory = transformerFactory. }
false;protected;1;29;;// Helper methods // ------------------------------------------------------------------------- protected void setupFeatures(DocumentBuilderFactory factory) {     Properties properties = System.getProperties().     List<String> features = new ArrayList<>().     for (Map.Entry<Object, Object> prop : properties.entrySet()) {         String key = (String) prop.getKey().         if (key.startsWith(XmlConverter.DOCUMENT_BUILDER_FACTORY_FEATURE)) {             String uri = StringHelper.after(key, ":").             Boolean value = Boolean.valueOf((String) prop.getValue()).             try {                 factory.setFeature(uri, value).                 features.add("feature " + uri + " value " + value).             } catch (ParserConfigurationException e) {                 LOG.warn("DocumentBuilderFactory doesn't support the feature {} with value {}, due to {}.", uri, value, e).             }         }     }     if (features.size() > 0) {         StringBuilder featureString = new StringBuilder().         // just log the configured feature         for (String feature : features) {             if (featureString.length() != 0) {                 featureString.append(", ").             }             featureString.append(feature).         }         LOG.info("DocumentBuilderFactory has been set with features {{}}.", featureString).     } }
false;public;1;11;;public DocumentBuilderFactory getDocumentBuilderFactory(Exchange exchange) {     DocumentBuilderFactory answer = getDocumentBuilderFactory().     // Get the DocumentBuilderFactory from the exchange header first     if (exchange != null) {         DocumentBuilderFactory factory = exchange.getProperty(Exchange.DOCUMENT_BUILDER_FACTORY, DocumentBuilderFactory.class).         if (factory != null) {             answer = factory.         }     }     return answer. }
false;public;0;35;;public DocumentBuilderFactory createDocumentBuilderFactory() {     DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance().     factory.setNamespaceAware(true).     factory.setIgnoringElementContentWhitespace(true).     factory.setIgnoringComments(true).     try {         // Set secure processing         factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE).     } catch (ParserConfigurationException e) {         LOG.warn("DocumentBuilderFactory doesn't support the feature {} with value {}, due to {}.", new Object[] { XMLConstants.FEATURE_SECURE_PROCESSING, true, e }).     }     try {         // Disable the external-general-entities by default         factory.setFeature("http://xml.org/sax/features/external-general-entities", false).     } catch (ParserConfigurationException e) {         LOG.warn("DocumentBuilderFactory doesn't support the feature {} with value {}, due to {}.", new Object[] { "http://xml.org/sax/features/external-general-entities", false, e }).     }     // setup the SecurityManager by default if it's apache xerces     try {         Class<?> smClass = ObjectHelper.loadClass("org.apache.xerces.util.SecurityManager").         if (smClass != null) {             Object sm = smClass.newInstance().             // Here we just use the default setting of the SeurityManager             factory.setAttribute("http://apache.org/xml/properties/security-manager", sm).         }     } catch (Exception e) {         LOG.warn("DocumentBuilderFactory doesn't support the attribute {}, due to {}.", new Object[] { "http://apache.org/xml/properties/security-manager", e }).     }     // setup the feature from the system property     setupFeatures(factory).     return factory. }
false;public;0;3;;public DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {     return createDocumentBuilder(getDocumentBuilderFactory()). }
false;public;1;5;;public DocumentBuilder createDocumentBuilder(DocumentBuilderFactory factory) throws ParserConfigurationException {     DocumentBuilder builder = factory.newDocumentBuilder().     builder.setErrorHandler(DOCUMENT_BUILDER_LOGGING_ERROR_HANDLER).     return builder. }
false;public;0;4;;public Document createDocument() throws ParserConfigurationException {     DocumentBuilder builder = createDocumentBuilder().     return builder.newDocument(). }
false;public;0;4;;public Transformer createTransformer() throws TransformerConfigurationException {     TransformerFactory factory = getTransformerFactory().     return factory.newTransformer(). }
false;public;0;28;;public TransformerFactory createTransformerFactory() {     TransformerFactory factory.     TransformerFactoryConfigurationError cause.     try {         factory = TransformerFactory.newInstance().     } catch (TransformerFactoryConfigurationError e) {         cause = e.         // try fallback from the JDK         try {             LOG.debug("Cannot create/load TransformerFactory due: {}. Will attempt to use JDK fallback TransformerFactory: {}", e.getMessage(), JDK_FALLBACK_TRANSFORMER_FACTORY).             factory = TransformerFactory.newInstance(JDK_FALLBACK_TRANSFORMER_FACTORY, null).         } catch (Throwable t) {             // okay we cannot load fallback then throw original exception             throw cause.         }     }     LOG.debug("Created TransformerFactory: {}", factory).     // Enable the Security feature by default     try {         factory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true).     } catch (TransformerConfigurationException e) {         LOG.warn("TransformerFactory doesn't support the feature {} with value {}, due to {}.", javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, "true", e).     }     factory.setErrorListener(new XmlErrorListener()).     configureSaxonTransformerFactory(factory).     return factory. }
true;public;1;32;/**  * Make a Saxon TransformerFactory more JAXP compliant by configuring it to  * send &lt.xsl:message&gt. output to the ErrorListener.  *  * @param factory  *            the TransformerFactory  */ ;/**  * Make a Saxon TransformerFactory more JAXP compliant by configuring it to  * send &lt.xsl:message&gt. output to the ErrorListener.  *  * @param factory  *            the TransformerFactory  */ public void configureSaxonTransformerFactory(TransformerFactory factory) {     // check whether we have a Saxon TransformerFactory ("net.sf.saxon" for open source editions (HE / B)     // and "com.saxonica" for commercial editions (PE / EE / SA))     Class<?> factoryClass = factory.getClass().     if (factoryClass.getName().startsWith("net.sf.saxon") || factoryClass.getName().startsWith("com.saxonica")) {         // just in case there are multiple class loaders with different Saxon versions, use the         // TransformerFactory's class loader to find Saxon support classes         ClassLoader loader = factoryClass.getClassLoader().         // try to find Saxon's MessageWarner class that redirects <xsl:message> to the ErrorListener         Class<?> messageWarner = null.         try {             // Saxon >= 9.3             messageWarner = loader.loadClass("net.sf.saxon.serialize.MessageWarner").         } catch (ClassNotFoundException cnfe) {             try {                 // Saxon < 9.3 (including Saxon-B / -SA)                 messageWarner = loader.loadClass("net.sf.saxon.event.MessageWarner").             } catch (ClassNotFoundException cnfe2) {                 LOG.warn("Error loading Saxon's net.sf.saxon.serialize.MessageWarner class from the classpath!" + " <xsl:message> output will not be redirected to the ErrorListener!").             }         }         if (messageWarner != null) {             // set net.sf.saxon.FeatureKeys.MESSAGE_EMITTER_CLASS             factory.setAttribute("http://saxon.sf.net/feature/messageEmitterClass", messageWarner.getName()).         }     } }
false;public;0;17;;public SAXParserFactory createSAXParserFactory() {     SAXParserFactory sfactory = SAXParserFactory.newInstance().     // Need to setup XMLReader security feature by default     try {         sfactory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true).     } catch (Exception e) {         LOG.warn("SAXParser doesn't support the feature {} with value {}, due to {}.", javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, "true", e).     }     try {         sfactory.setFeature("http://xml.org/sax/features/external-general-entities", false).     } catch (Exception e) {         LOG.warn("SAXParser doesn't support the feature {} with value {}, due to {}.", new Object[] { "http://xml.org/sax/features/external-general-entities", false, e }).     }     sfactory.setNamespaceAware(true).     return sfactory. }
false;public;1;4;;@Override public void warning(SAXParseException exception) throws SAXException {     LOG.warn(exception.getMessage(), exception). }
false;public;1;4;;@Override public void error(SAXParseException exception) throws SAXException {     LOG.error(exception.getMessage(), exception). }
false;public;1;4;;@Override public void fatalError(SAXParseException exception) throws SAXException {     LOG.error(exception.getMessage(), exception). }
