commented;modifiers;parameterAmount;loc;comment;code
false;public;3;4;;@Override public <T> T convertTo(Class<T> type, Exchange exchange, Object value) throws TypeConversionException {     return (T) MISS_VALUE. }
false;public;0;4;;@Override public CamelContext getCamelContext() {     return camelContext. }
false;public;1;4;;@Override public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;0;3;;public List<TypeConverterLoader> getTypeConverterLoaders() {     return typeConverterLoaders. }
false;public;2;4;;@Override public <T> T convertTo(Class<T> type, Object value) {     return convertTo(type, null, value). }
false;public;3;5;;@SuppressWarnings("unchecked") @Override public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {     return (T) doConvertTo(type, exchange, value, false, false). }
false;public;2;4;;@Override public <T> T mandatoryConvertTo(Class<T> type, Object value) throws NoTypeConversionAvailableException {     return mandatoryConvertTo(type, null, value). }
false;public;3;10;;@SuppressWarnings("unchecked") @Override public <T> T mandatoryConvertTo(Class<T> type, Exchange exchange, Object value) throws NoTypeConversionAvailableException {     Object answer = doConvertTo(type, exchange, value, true, false).     if (answer == null) {         // Could not find suitable conversion         throw new NoTypeConversionAvailableException(value, type).     }     return (T) answer. }
false;public;2;4;;@Override public <T> T tryConvertTo(Class<T> type, Object value) {     return tryConvertTo(type, null, value). }
false;public;3;5;;@SuppressWarnings("unchecked") @Override public <T> T tryConvertTo(Class<T> type, Exchange exchange, Object value) {     return (T) doConvertTo(type, exchange, value, false, true). }
false;protected;5;35;;protected Object doConvertTo(final Class<?> type, final Exchange exchange, final Object value, final boolean mandatory, final boolean tryConvert) {     Object answer.     try {         answer = doConvertTo(type, exchange, value, tryConvert).     } catch (Exception e) {         if (statistics.isStatisticsEnabled()) {             failedCounter.increment().         }         if (tryConvert) {             return null.         }         // if its a ExecutionException then we have rethrow it as its not due to failed conversion         // this is special for FutureTypeConverter         boolean execution = ObjectHelper.getException(ExecutionException.class, e) != null || ObjectHelper.getException(CamelExecutionException.class, e) != null.         if (execution) {             throw CamelExecutionException.wrapCamelExecutionException(exchange, e).         }         // error occurred during type conversion         throw createTypeConversionException(exchange, type, value, e).     }     if (answer == MISS_VALUE) {         // Could not find suitable conversion         if (statistics.isStatisticsEnabled()) {             missCounter.increment().         }         return null.     } else {         if (statistics.isStatisticsEnabled()) {             hitCounter.increment().         }         return answer.     } }
false;protected;4;151;;protected Object doConvertTo(final Class<?> type, final Exchange exchange, final Object value, final boolean tryConvert) throws Exception {     boolean trace = log.isTraceEnabled().     boolean statisticsEnabled = statistics.isStatisticsEnabled().     if (trace) {         log.trace("Finding type converter to convert {} -> {} with value: {}", value == null ? "null" : value.getClass().getCanonicalName(), type.getCanonicalName(), value).     }     if (value == null) {         // no type conversion was needed         if (statisticsEnabled) {             noopCounter.increment().         }         // lets avoid NullPointerException when converting to primitives for null values         if (type.isPrimitive()) {             if (boolean.class == type) {                 return Boolean.FALSE.             }             if (int.class == type) {                 return 0.             }             if (long.class == type) {                 return 0L.             }             if (byte.class == type) {                 return (byte) 0.             }             if (short.class == type) {                 return (short) 0.             }             if (double.class == type) {                 return 0.0.             }             if (float.class == type) {                 return 0.0f.             }             if (char.class == type) {                 return '\0'.             }         }         return null.     }     // same instance type     if (type.isInstance(value)) {         // no type conversion was needed         if (statisticsEnabled) {             noopCounter.increment().         }         return value.     }     // okay we need to attempt to convert     if (statisticsEnabled) {         attemptCounter.increment().     }     // try to find a suitable type converter     TypeConverter converter = getOrFindTypeConverter(type, value.getClass()).     if (converter != null) {         if (trace) {             log.trace("Using converter: {} to convert [{}=>{}]", converter, value.getClass(), type).         }         Object rc.         if (tryConvert) {             rc = converter.tryConvertTo(type, exchange, value).         } else {             rc = converter.convertTo(type, exchange, value).         }         if (rc != null) {             return rc.         } else if (converter.allowNull()) {             return null.         }     }     // not found with that type then if it was a primitive type then try again with the wrapper type     if (type.isPrimitive()) {         Class<?> primitiveType = ObjectHelper.convertPrimitiveTypeToWrapperType(type).         if (primitiveType != type) {             Class<?> fromType = value.getClass().             TypeConverter tc = getOrFindTypeConverter(primitiveType, fromType).             if (tc != null) {                 // add the type as a known type converter as we can convert from primitive to object converter                 addTypeConverter(type, fromType, tc).                 Object rc.                 if (tryConvert) {                     rc = tc.tryConvertTo(primitiveType, exchange, value).                 } else {                     rc = tc.convertTo(primitiveType, exchange, value).                 }                 if (rc == null && tc.allowNull()) {                     return null.                 } else if (rc != null) {                     return rc.                 }             }         }     }     // fallback converters     for (FallbackTypeConverter fallback : fallbackConverters) {         TypeConverter tc = fallback.getFallbackTypeConverter().         Object rc.         if (tryConvert) {             rc = tc.tryConvertTo(type, exchange, value).         } else {             rc = tc.convertTo(type, exchange, value).         }         if (rc == null && tc.allowNull()) {             return null.         }         if (rc == MISS_VALUE) {             // it cannot be converted so give up             return MISS_VALUE.         }         if (rc != null) {             // if fallback can promote then let it be promoted to a first class type converter             if (fallback.isCanPromote()) {                 // add it as a known type converter since we found a fallback that could do it                 if (log.isDebugEnabled()) {                     log.debug("Promoting fallback type converter as a known type converter to convert from: {} to: {} for the fallback converter: {}", type.getCanonicalName(), value.getClass().getCanonicalName(), fallback.getFallbackTypeConverter()).                 }                 addTypeConverter(type, value.getClass(), fallback.getFallbackTypeConverter()).             }             if (log.isTraceEnabled()) {                 log.trace("Fallback type converter {} converted type from: {} to: {}", fallback.getFallbackTypeConverter(), type.getCanonicalName(), value.getClass().getCanonicalName()).             }             // return converted value             return rc.         }     }     if (!tryConvert) {         // Could not find suitable conversion, so remember it         // do not register misses for try conversions         typeMappings.put(type, value.getClass(), MISS_CONVERTER).     }     // Could not find suitable conversion, so return Void to indicate not found     return MISS_VALUE. }
false;public;3;32;;@Override public void addTypeConverter(Class<?> toType, Class<?> fromType, TypeConverter typeConverter) {     log.trace("Adding type converter: {}", typeConverter).     TypeConverter converter = typeMappings.get(toType, fromType).     if (typeConverter != converter) {         // add the converter unless we should ignore         boolean add = true.         // if converter is not null then a duplicate exists         if (converter != null) {             if (typeConverterExists == TypeConverterExists.Override) {                 CamelLogger logger = new CamelLogger(log, typeConverterExistsLoggingLevel).                 logger.log("Overriding type converter from: " + converter + " to: " + typeConverter).             } else if (typeConverterExists == TypeConverterExists.Ignore) {                 CamelLogger logger = new CamelLogger(log, typeConverterExistsLoggingLevel).                 logger.log("Ignoring duplicate type converter from: " + converter + " to: " + typeConverter).                 add = false.             } else {                 // we should fail                 throw new TypeConverterExistsException(toType, fromType).             }         }         if (add) {             typeMappings.put(toType, fromType, typeConverter).         }     } }
false;public;1;11;;@Override public void addTypeConverters(TypeConverters typeConverters) {     log.trace("Adding type converters: {}", typeConverters).     try {         // scan the class for @Converter and load them into this registry         TypeConvertersLoader loader = new TypeConvertersLoader(typeConverters).         loader.load(this).     } catch (TypeConverterLoaderException e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;public;2;5;;@Override public boolean removeTypeConverter(Class<?> toType, Class<?> fromType) {     log.trace("Removing type converter from: {} to: {}", fromType, toType).     return typeMappings.remove(toType, fromType). }
false;public;2;18;;@Override public void addFallbackTypeConverter(TypeConverter typeConverter, boolean canPromote) {     log.trace("Adding fallback type converter: {} which can promote: {}", typeConverter, canPromote).     // add in top of fallback as the toString() fallback will nearly always be able to convert     // the last one which is add to the FallbackTypeConverter will be called at the first place     fallbackConverters.add(0, new FallbackTypeConverter(typeConverter, canPromote)).     if (typeConverter instanceof TypeConverterAware) {         TypeConverterAware typeConverterAware = (TypeConverterAware) typeConverter.         typeConverterAware.setTypeConverter(this).     }     if (typeConverter instanceof CamelContextAware) {         CamelContextAware camelContextAware = (CamelContextAware) typeConverter.         if (camelContext != null) {             camelContextAware.setCamelContext(camelContext).         }     } }
false;private;3;17;;private void addCoreFallbackTypeConverterToList(TypeConverter typeConverter, boolean canPromote, List<FallbackTypeConverter> converters) {     log.trace("Adding core fallback type converter: {} which can promote: {}", typeConverter, canPromote).     // add in top of fallback as the toString() fallback will nearly always be able to convert     // the last one which is add to the FallbackTypeConverter will be called at the first place     converters.add(0, new FallbackTypeConverter(typeConverter, canPromote)).     if (typeConverter instanceof TypeConverterAware) {         TypeConverterAware typeConverterAware = (TypeConverterAware) typeConverter.         typeConverterAware.setTypeConverter(this).     }     if (typeConverter instanceof CamelContextAware) {         CamelContextAware camelContextAware = (CamelContextAware) typeConverter.         if (camelContext != null) {             camelContextAware.setCamelContext(camelContext).         }     } }
false;public;2;3;;public TypeConverter getTypeConverter(Class<?> toType, Class<?> fromType) {     return typeMappings.get(toType, fromType). }
false;public;0;4;;@Override public Injector getInjector() {     return injector. }
false;public;1;4;;@Override public void setInjector(Injector injector) {     this.injector = injector. }
false;protected;2;11;;protected <T> TypeConverter getOrFindTypeConverter(Class<?> toType, Class<?> fromType) {     TypeConverter converter = typeMappings.get(toType, fromType).     if (converter == null) {         // converter not found, try to lookup then         converter = lookup(toType, fromType).         if (converter != null) {             typeMappings.put(toType, fromType, converter).         }     }     return converter. }
false;public;2;4;;@Override public TypeConverter lookup(Class<?> toType, Class<?> fromType) {     return doLookup(toType, fromType, false). }
false;protected;3;51;;protected TypeConverter doLookup(Class<?> toType, Class<?> fromType, boolean isSuper) {     if (fromType != null) {         // lets try if there is a direct match         TypeConverter converter = getTypeConverter(toType, fromType).         if (converter != null) {             return converter.         }         // try the interfaces         for (Class<?> type : fromType.getInterfaces()) {             converter = getTypeConverter(toType, type).             if (converter != null) {                 return converter.             }         }         // try super then         Class<?> fromSuperClass = fromType.getSuperclass().         if (fromSuperClass != null && !fromSuperClass.equals(Object.class)) {             converter = doLookup(toType, fromSuperClass, true).             if (converter != null) {                 return converter.             }         }     }     // only do these tests as fallback and only on the target type (eg not on its super)     if (!isSuper) {         if (fromType != null && !fromType.equals(Object.class)) {             // lets try classes derived from this toType             TypeConverter converter = typeMappings.getFirst(toType::isAssignableFrom, // skip Object based we do them last             from -> !from.equals(Object.class) && from.isAssignableFrom(fromType)).             if (converter != null) {                 return converter.             }             // lets test for Object based converters as last resort             converter = getTypeConverter(toType, Object.class).             if (converter != null) {                 return converter.             }         }     }     // none found     return null. }
false;public;0;5;;public List<Class<?>[]> listAllTypeConvertersFromTo() {     List<Class<?>[]> answer = new ArrayList<>().     typeMappings.forEach((k1, k2, v) -> answer.add(new Class<?>[] { k2, k1 })).     return answer. }
true;public;0;4;/**  * Loads the core type converters which is mandatory to use Camel  */ ;/**  * Loads the core type converters which is mandatory to use Camel  */ public void loadCoreTypeConverters() throws Exception {     // load all the type converters from camel-core     CoreStaticTypeConverterLoader.INSTANCE.load(this). }
true;protected;0;12;/**  * Checks if the registry is loaded and if not lazily load it  */ ;/**  * Checks if the registry is loaded and if not lazily load it  */ protected void loadTypeConverters() throws Exception {     for (TypeConverterLoader typeConverterLoader : getTypeConverterLoaders()) {         typeConverterLoader.load(this).     }     // lets try load any other fallback converters     try {         loadFallbackTypeConverters().     } catch (NoFactoryAvailableException e) {     // ignore its fine to have none     } }
false;protected;0;6;;protected void loadFallbackTypeConverters() throws IOException, ClassNotFoundException {     List<TypeConverter> converters = factoryFinder.newInstances("FallbackTypeConverter", getInjector(), TypeConverter.class).     for (TypeConverter converter : converters) {         addFallbackTypeConverter(converter, false).     } }
false;protected;4;16;;protected TypeConversionException createTypeConversionException(Exchange exchange, Class<?> type, Object value, Throwable cause) {     if (cause instanceof TypeConversionException) {         if (((TypeConversionException) cause).getToType() == type) {             return (TypeConversionException) cause.         }     }     Object body.     // and also can be used to turn off logging sensitive message data     if (exchange != null) {         body = MessageHelper.extractValueForLogging(value, exchange.getIn()).     } else {         body = value.     }     return new TypeConversionException(body, type, cause). }
false;public;0;4;;@Override public Statistics getStatistics() {     return statistics. }
false;public;0;4;;@Override public int size() {     return typeMappings.size(). }
false;public;0;3;;public LoggingLevel getTypeConverterExistsLoggingLevel() {     return typeConverterExistsLoggingLevel. }
false;public;1;3;;public void setTypeConverterExistsLoggingLevel(LoggingLevel typeConverterExistsLoggingLevel) {     this.typeConverterExistsLoggingLevel = typeConverterExistsLoggingLevel. }
false;public;0;3;;public TypeConverterExists getTypeConverterExists() {     return typeConverterExists. }
false;public;1;3;;public void setTypeConverterExists(TypeConverterExists typeConverterExists) {     this.typeConverterExists = typeConverterExists. }
false;protected;0;4;;@Override protected void doStart() throws Exception { // noop }
false;protected;0;18;;@Override protected void doStop() throws Exception {     // log utilization statistics when stopping, including mappings     if (statistics.isStatisticsEnabled()) {         String info = statistics.toString().         AtomicInteger misses = new AtomicInteger().         typeMappings.forEach((k1, k2, v) -> {             if (v == MISS_CONVERTER) {                 misses.incrementAndGet().             }         }).         info += String.format(" mappings[total=%s, misses=%s]", typeMappings.size(), misses).         log.info(info).     }     typeMappings.clear().     statistics.reset(). }
false;public;0;4;;@Override public long getNoopCounter() {     return noopCounter.longValue(). }
false;public;0;4;;@Override public long getAttemptCounter() {     return attemptCounter.longValue(). }
false;public;0;4;;@Override public long getHitCounter() {     return hitCounter.longValue(). }
false;public;0;4;;@Override public long getMissCounter() {     return missCounter.longValue(). }
false;public;0;4;;@Override public long getFailedCounter() {     return failedCounter.longValue(). }
false;public;0;8;;@Override public void reset() {     noopCounter.reset().     attemptCounter.reset().     hitCounter.reset().     missCounter.reset().     failedCounter.reset(). }
false;public;0;4;;@Override public boolean isStatisticsEnabled() {     return statisticsEnabled. }
false;public;1;4;;@Override public void setStatisticsEnabled(boolean statisticsEnabled) {     this.statisticsEnabled = statisticsEnabled. }
false;public;0;5;;@Override public String toString() {     return String.format("TypeConverterRegistry utilization[noop=%s, attempts=%s, hits=%s, misses=%s, failures=%s]", getNoopCounter(), getAttemptCounter(), getHitCounter(), getMissCounter(), getFailedCounter()). }
false;public;0;3;;public boolean isCanPromote() {     return canPromote. }
false;public;0;3;;public TypeConverter getFallbackTypeConverter() {     return fallbackTypeConverter. }
