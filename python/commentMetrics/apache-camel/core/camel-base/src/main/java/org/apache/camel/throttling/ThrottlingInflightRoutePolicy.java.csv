commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "ThrottlingInflightRoutePolicy[" + maxInflightExchanges + " / " + resumePercentOfMax + "% using scope " + scope + "]". }
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;1;3;;public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;1;5;;@Override public void onInit(Route route) {     // we need to remember the routes we apply for     routes.add(route). }
false;public;2;8;;@Override public void onExchangeDone(Route route, Exchange exchange) {     // as context scoped is handled using an EventNotifier instead     if (scope == ThrottlingScope.Route) {         throttle(route, exchange).     } }
true;protected;2;38;/**  * Throttles the route when {@link Exchange}s is done.  *  * @param route  the route  * @param exchange the exchange  */ ;/**  * Throttles the route when {@link Exchange}s is done.  *  * @param route  the route  * @param exchange the exchange  */ protected void throttle(Route route, Exchange exchange) {     // this works the best when this logic is executed when the exchange is done     Consumer consumer = route.getConsumer().     int size = getSize(route, exchange).     boolean stop = maxInflightExchanges > 0 && size > maxInflightExchanges.     if (log.isTraceEnabled()) {         log.trace("{} > 0 && {} > {} evaluated as {}", maxInflightExchanges, size, maxInflightExchanges, stop).     }     if (stop) {         try {             lock.lock().             stopConsumer(size, consumer).         } catch (Exception e) {             handleException(e).         } finally {             lock.unlock().         }     }     // reload size in case a race condition with too many at once being invoked     // so we need to ensure that we read the most current size and start the consumer if we are already to low     size = getSize(route, exchange).     boolean start = size <= resumeInflightExchanges.     if (log.isTraceEnabled()) {         log.trace("{} <= {} evaluated as {}", size, resumeInflightExchanges, start).     }     if (start) {         try {             lock.lock().             startConsumer(size, consumer).         } catch (Exception e) {             handleException(e).         } finally {             lock.unlock().         }     } }
false;public;0;3;;public int getMaxInflightExchanges() {     return maxInflightExchanges. }
true;public;1;5;/**  * Sets the upper limit of number of concurrent inflight exchanges at which point reached  * the throttler should suspend the route.  * <p/>  * Is default 1000.  *  * @param maxInflightExchanges the upper limit of concurrent inflight exchanges  */ ;/**  * Sets the upper limit of number of concurrent inflight exchanges at which point reached  * the throttler should suspend the route.  * <p/>  * Is default 1000.  *  * @param maxInflightExchanges the upper limit of concurrent inflight exchanges  */ public void setMaxInflightExchanges(int maxInflightExchanges) {     this.maxInflightExchanges = maxInflightExchanges.     // recalculate, must be at least at 1     this.resumeInflightExchanges = Math.max(resumePercentOfMax * maxInflightExchanges / 100, 1). }
false;public;0;3;;public int getResumePercentOfMax() {     return resumePercentOfMax. }
true;public;1;9;/**  * Sets at which percentage of the max the throttler should start resuming the route.  * <p/>  * Will by default use 70%.  *  * @param resumePercentOfMax the percentage must be between 0 and 100  */ ;/**  * Sets at which percentage of the max the throttler should start resuming the route.  * <p/>  * Will by default use 70%.  *  * @param resumePercentOfMax the percentage must be between 0 and 100  */ public void setResumePercentOfMax(int resumePercentOfMax) {     if (resumePercentOfMax < 0 || resumePercentOfMax > 100) {         throw new IllegalArgumentException("Must be a percentage between 0 and 100, was: " + resumePercentOfMax).     }     this.resumePercentOfMax = resumePercentOfMax.     // recalculate, must be at least at 1     this.resumeInflightExchanges = Math.max(resumePercentOfMax * maxInflightExchanges / 100, 1). }
false;public;0;3;;public ThrottlingScope getScope() {     return scope. }
true;public;1;3;/**  * Sets which scope the throttling should be based upon, either route or total scoped.  *  * @param scope the scope  */ ;/**  * Sets which scope the throttling should be based upon, either route or total scoped.  *  * @param scope the scope  */ public void setScope(ThrottlingScope scope) {     this.scope = scope. }
false;public;0;3;;public LoggingLevel getLoggingLevel() {     return loggingLevel. }
false;public;0;6;;public CamelLogger getLogger() {     if (logger == null) {         logger = createLogger().     }     return logger. }
true;public;1;3;/**  * Sets the logger to use for logging throttling activity.  *  * @param logger the logger  */ ;/**  * Sets the logger to use for logging throttling activity.  *  * @param logger the logger  */ public void setLogger(CamelLogger logger) {     this.logger = logger. }
true;public;1;3;/**  * Sets the logging level to report the throttling activity.  * <p/>  * Is default <tt>INFO</tt> level.  *  * @param loggingLevel the logging level  */ ;/**  * Sets the logging level to report the throttling activity.  * <p/>  * Is default <tt>INFO</tt> level.  *  * @param loggingLevel the logging level  */ public void setLoggingLevel(LoggingLevel loggingLevel) {     this.loggingLevel = loggingLevel. }
false;protected;0;3;;protected CamelLogger createLogger() {     return new CamelLogger(log, getLoggingLevel()). }
false;private;2;7;;private int getSize(Route route, Exchange exchange) {     if (scope == ThrottlingScope.Context) {         return exchange.getContext().getInflightRepository().size().     } else {         return exchange.getContext().getInflightRepository().size(route.getId()).     } }
false;private;2;6;;private void startConsumer(int size, Consumer consumer) throws Exception {     boolean started = resumeOrStartConsumer(consumer).     if (started) {         getLogger().log("Throttling consumer: " + size + " <= " + resumeInflightExchanges + " inflight exchange by resuming consumer: " + consumer).     } }
false;private;2;6;;private void stopConsumer(int size, Consumer consumer) throws Exception {     boolean stopped = suspendOrStopConsumer(consumer).     if (stopped) {         getLogger().log("Throttling consumer: " + size + " > " + maxInflightExchanges + " inflight exchange by suspending consumer: " + consumer).     } }
false;protected;0;13;;@Override protected void doStart() throws Exception {     ObjectHelper.notNull(camelContext, "CamelContext", this).     if (scope == ThrottlingScope.Context) {         eventNotifier = new ContextScopedEventNotifier().         // must start the notifier before it can be used         ServiceHelper.startService(eventNotifier).         // we are in context scope, so we need to use an event notifier to keep track         // when any exchanges is done on the camel context.         // This ensures we can trigger accordingly to context scope         camelContext.getManagementStrategy().addEventNotifier(eventNotifier).     } }
false;protected;0;7;;@Override protected void doStop() throws Exception {     ObjectHelper.notNull(camelContext, "CamelContext", this).     if (scope == ThrottlingScope.Context) {         camelContext.getManagementStrategy().removeEventNotifier(eventNotifier).     } }
false;public;1;7;;@Override public void notify(CamelEvent event) throws Exception {     ExchangeCompletedEvent completedEvent = (ExchangeCompletedEvent) event.     for (Route route : routes) {         throttle(route, completedEvent.getExchange()).     } }
false;public;1;4;;@Override public boolean isEnabled(CamelEvent event) {     return event instanceof ExchangeCompletedEvent. }
false;public;0;4;;@Override public String toString() {     return "ContextScopedEventNotifier". }
