commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;// ************************************ // Properties // ************************************ @Override public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;0;4;;@Override public CamelContext getCamelContext() {     return camelContext. }
false;public;0;3;;public HealthCheckRegistry getHealthCheckRegistry() {     return registry. }
false;public;1;3;;public void setHealthCheckRegistry(HealthCheckRegistry registry) {     this.registry = registry. }
false;public;0;3;;public long getCheckInterval() {     return checkInterval. }
false;public;1;3;;public void setCheckInterval(long checkInterval) {     this.checkInterval = checkInterval. }
false;public;2;4;;public void setCheckInterval(long interval, TimeUnit intervalUnit) {     setCheckInterval(interval).     setCheckIntervalUnit(intervalUnit). }
false;public;0;3;;public TimeUnit getCheckIntervalUnit() {     return checkIntervalUnit. }
false;public;1;3;;public void setCheckIntervalUnit(TimeUnit checkIntervalUnit) {     this.checkIntervalUnit = checkIntervalUnit. }
false;public;1;7;;@Override public void addStateChangeListener(BiConsumer<HealthCheck.State, HealthCheck> consumer) {     LockHelper.doWithWriteLock(lock, () -> listeners.add(consumer)). }
false;public;1;7;;@Override public void removeStateChangeListener(BiConsumer<HealthCheck.State, HealthCheck> consumer) {     LockHelper.doWithWriteLock(lock, () -> listeners.removeIf(listener -> listener.equals(consumer))). }
false;public;2;4;;@Override public void setHealthCheckOptions(String id, Map<String, Object> options) {     options.put(id, options). }
false;public;1;4;;@Override public Optional<HealthCheck.Result> call(String id) {     return call(id, options.getOrDefault(id, Collections.emptyMap())). }
false;public;2;4;;@Override public Optional<HealthCheck.Result> call(String id, Map<String, Object> options) {     return registry.getCheck(id).map(check -> invoke(check, options)). }
false;public;2;7;;@Override public void notify(HealthCheck check, HealthCheck.Result result) {     LockHelper.doWithWriteLock(lock, () -> processResult(check, result)). }
false;public;0;4;;@Override public Collection<HealthCheck.Result> getResults() {     return new ArrayList<>(this.checks.values()). }
false;protected;0;41;;// ************************************ // Lifecycle // ************************************ @Override protected void doStart() throws Exception {     ObjectHelper.notNull(camelContext, "CamelContext").     if (executorService == null) {         executorService = camelContext.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "DefaultHealthCheckService").     }     if (future != null) {         future.cancel(true).     }     if (registry == null) {         registry = HealthCheckRegistry.get(camelContext).     }     if (ObjectHelper.isNotEmpty(registry) && ObjectHelper.isEmpty(future)) {         // Start the health check task only if the health check registry         // has been registered.         LOGGER.debug("Schedule health-checks to be executed every %d (%s)", checkInterval, checkIntervalUnit.name()).         future = executorService.scheduleAtFixedRate(() -> {             if (!isRunAllowed()) {                 // properly started.                 return.             }             LOGGER.debug("Invoke health-checks (scheduled)").             registry.stream().collect(Collectors.groupingBy(HealthCheckHelper::getGroup)).entrySet().stream().map(Map.Entry::getValue).flatMap(Collection::stream).sorted(Comparator.comparingInt(HealthCheck::getOrder)).forEach(this::invoke).         }, checkInterval, checkInterval, checkIntervalUnit).     } }
false;protected;0;15;;@Override protected void doStop() throws Exception {     if (future != null) {         future.cancel(true).         future = null.     }     if (executorService != null) {         if (camelContext != null) {             camelContext.getExecutorServiceManager().shutdownNow(executorService).         } else {             executorService.shutdownNow().         }         executorService = null.     } }
false;private;2;17;;// ************************************ // Helpers // ************************************ private HealthCheck.Result processResult(HealthCheck check, HealthCheck.Result result) {     final HealthCheck.Result cachedResult = checks.get(check).     if (!isSameResult(result, cachedResult)) {         // Maybe make the listener aware of the reason, i.e.         // the service is still un-healthy but the message         // or error has changed.         listeners.forEach(listener -> listener.accept(result.getState(), check)).     }     // replace the old result with the new one even if the     // state has not changed but the reason/error may be     // changed.     checks.put(check, result).     return result. }
false;private;1;3;;private HealthCheck.Result invoke(HealthCheck check) {     return invoke(check, options.getOrDefault(check.getId(), Collections.emptyMap())). }
false;private;2;9;;private HealthCheck.Result invoke(HealthCheck check, Map<String, Object> options) {     return LockHelper.supplyWithWriteLock(lock, () -> {         LOGGER.debug("Invoke health-check {}", check.getId()).         return processResult(check, check.call(options)).     }). }
true;private;2;11;/**  * Check if two results are equals by checking only the state, this method  * does not check if the result comes from the same health check, this should  * be done by the caller.  * <p>  * A future implementation should check all the parameter of the result.  */ ;/**  * Check if two results are equals by checking only the state, this method  * does not check if the result comes from the same health check, this should  * be done by the caller.  * <p>  * A future implementation should check all the parameter of the result.  */ private boolean isSameResult(HealthCheck.Result r1, HealthCheck.Result r2) {     if (Objects.equals(r1, r2)) {         return true.     }     if (r1 != null && r2 != null) {         return r1.getState() == r2.getState().     }     return false. }
