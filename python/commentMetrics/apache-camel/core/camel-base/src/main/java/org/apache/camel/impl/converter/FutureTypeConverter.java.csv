commented;modifiers;parameterAmount;loc;comment;code
false;public;3;8;;@Override public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {     try {         return doConvertTo(type, exchange, value).     } catch (Exception e) {         throw new TypeConversionException(value, type, e).     } }
false;private;3;41;;@SuppressWarnings("unchecked") private <T> T doConvertTo(Class<T> type, Exchange exchange, Object value) throws Exception {     // do not convert to stream cache     if (StreamCache.class.isAssignableFrom(value.getClass())) {         return null.     }     if (Future.class.isAssignableFrom(value.getClass())) {         Future<?> future = (Future<?>) value.         if (future.isCancelled()) {             // return void to indicate its not possible to convert at this time             return (T) MISS_VALUE.         }         // do some trace logging as the get is blocking until the response is ready         LOG.trace("Getting future response").         Object body = future.get().         LOG.trace("Got future response").         if (body == null) {             // return void to indicate its not possible to convert at this time             return (T) MISS_VALUE.         }         // maybe from is already the type we want         if (type.isAssignableFrom(body.getClass())) {             return type.cast(body).         } else if (body instanceof Exchange) {             Exchange result = (Exchange) body.             body = ExchangeHelper.extractResultBody(result, result.getPattern()).         }         // no then convert to the type         return converter.convertTo(type, exchange, body).     }     return null. }
