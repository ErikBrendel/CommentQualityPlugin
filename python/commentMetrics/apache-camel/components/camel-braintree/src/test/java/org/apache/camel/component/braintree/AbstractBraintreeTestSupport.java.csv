commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;12;;@Override protected CamelContext createCamelContext() throws Exception {     final CamelContext context = super.createCamelContext().     // add BraintreeComponent to Camel context     final BraintreeComponent component = new BraintreeComponent(context).     component.setConfiguration(buildBraintreeConfiguration()).     context.addComponent("braintree", component).     return context. }
false;protected;3;8;;protected void addOptionIfMissing(Map<String, Object> options, String name, String envName) {     if (!options.containsKey(name)) {         String value = System.getenv(envName).         if (ObjectHelper.isNotEmpty(value)) {             options.put(name, value).         }     } }
false;protected;0;43;;protected BraintreeConfiguration buildBraintreeConfiguration() throws Exception {     final Properties properties = new Properties().     try {         properties.load(getClass().getResourceAsStream(TEST_OPTIONS_PROPERTIES)).     } catch (Exception e) {         throw new IOException(String.format("%s could not be loaded: %s", TEST_OPTIONS_PROPERTIES, e.getMessage()), e).     }     Map<String, Object> options = new HashMap<>().     for (Map.Entry<Object, Object> entry : properties.entrySet()) {         options.put(entry.getKey().toString(), entry.getValue()).     }     AuthenticationType configurationType = getAuthenticationType().     LOG.info(String.format("Test using %s configuration profile", configurationType)).     switch(configurationType) {         case PUBLIC_PRIVATE_KEYS:             addOptionIfMissing(options, "environment", "CAMEL_BRAINTREE_ENVIRONMENT").             addOptionIfMissing(options, "merchantId", "CAMEL_BRAINTREE_MERCHANT_ID").             addOptionIfMissing(options, "publicKey", "CAMEL_BRAINTREE_PUBLIC_KEY").             addOptionIfMissing(options, "privateKey", "CAMEL_BRAINTREE_PRIVATE_KEY").             options.remove("accessToken").             options.remove("clientId").             break.         case ACCESS_TOKEN:             addOptionIfMissing(options, "accessToken", "CAMEL_BRAINTREE_ACCESS_TOKEN").             options.remove("environment").             options.remove("merchantId").             options.remove("publicKey").             options.remove("privateKey").             break.         default:             throw new IllegalArgumentException("Unsupported configuration type").     }     final BraintreeConfiguration configuration = new BraintreeConfiguration().     configuration.setHttpLogLevel(BraintreeLogHandler.DEFAULT_LOGGER_VERSION).     configuration.setHttpLogName(BraintreeLogHandler.DEFAULT_LOGGER_NAME).     IntrospectionSupport.setProperties(configuration, options).     return configuration. }
false;protected;0;6;;protected AuthenticationType getAuthenticationType() {     if (authenticationType == null) {         authenticationType = parseAuthenticationType().     }     return authenticationType. }
false;protected;1;3;;protected boolean checkAuthenticationType(AuthenticationType authenticationType) {     return getAuthenticationType().equals(authenticationType). }
false;private;0;10;;private AuthenticationType parseAuthenticationType() {     String authenticationTypeString = System.getProperty("braintreeAuthenticationType").     if (authenticationTypeString != null) {         AuthenticationType authenticationType = AuthenticationType.valueOf(authenticationTypeString).         if (authenticationType != null) {             return authenticationType.         }     }     return AuthenticationType.PUBLIC_PRIVATE_KEYS. }
false;public;0;6;;@Override public boolean isCreateCamelContextPerClass() {     // only create the context once for this class     return false. }
false;protected;3;4;;@SuppressWarnings("unchecked") protected <T> T requestBodyAndHeaders(String endpointUri, Object body, Map<String, Object> headers) throws CamelExecutionException {     return (T) template().requestBodyAndHeaders(endpointUri, body, headers). }
false;protected;4;3;;protected <T> T requestBodyAndHeaders(String endpointUri, Object body, Map<String, Object> headers, Class<T> type) throws CamelExecutionException {     return template().requestBodyAndHeaders(endpointUri, body, headers, type). }
false;protected;2;4;;@SuppressWarnings("unchecked") protected <T> T requestBody(String endpoint, Object body) throws CamelExecutionException {     return (T) template().requestBody(endpoint, body). }
false;protected;3;3;;protected <T> T requestBody(String endpoint, Object body, Class<T> type) throws CamelExecutionException {     return template().requestBody(endpoint, body, type). }
false;protected,static;1;3;;protected static BraintreeApiName getApiName(Class<? extends ApiMethod> apiMethod) {     return BraintreeApiCollection.getCollection().getApiName(apiMethod). }
false;protected,static;1;3;;protected static String getApiNameAsString(Class<? extends ApiMethod> apiMethod) {     return getApiName(apiMethod).getName(). }
false;protected,final;0;3;;protected final BraintreeComponent getBraintreeComponent() {     return (BraintreeComponent) context().getComponent("braintree"). }
false;protected,final,synchronized;0;7;;protected final synchronized BraintreeGateway getGateway() {     if (gateway == null) {         gateway = getBraintreeComponent().getConfiguration().newBraintreeGateway().     }     return gateway. }
false;public;2;9;;public BraintreeHeaderBuilder add(String key, Object value) {     if (key.startsWith(BraintreeConstants.PROPERTY_PREFIX)) {         headers.put(key, value).     } else {         headers.put(BraintreeConstants.PROPERTY_PREFIX + key, value).     }     return this. }
false;public;0;3;;public Map<String, Object> build() {     return Collections.unmodifiableMap(headers). }
