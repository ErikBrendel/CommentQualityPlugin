commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Set the ZooKeeper host information which the solrCloud could use, such as "zkhost=localhost:8123".  */ ;/**  * Set the ZooKeeper host information which the solrCloud could use, such as "zkhost=localhost:8123".  */ public void setZkHost(String zkHost) throws UnsupportedEncodingException {     String decoded = URLDecoder.decode(zkHost, "UTF-8").     this.zkHost = decoded. }
false;public;0;3;;public String getZkHost() {     return this.zkHost. }
true;public;1;3;/**  * Set the collection name which the solrCloud server could use  */ ;/**  * Set the collection name which the solrCloud server could use  */ public void setCollection(String collection) {     this.collection = collection. }
false;public;0;3;;public String getCollection() {     return this.collection. }
false;public;0;4;;@Override public SolrComponent getComponent() {     return (SolrComponent) super.getComponent(). }
false;private;0;8;;private CloudSolrClient getCloudServer() {     CloudSolrClient rVal = null.     if (this.getZkHost() != null && this.getCollection() != null) {         rVal = new CloudSolrClient.Builder().withZkHost(zkHost).build().         rVal.setDefaultCollection(this.getCollection()).     }     return rVal. }
false;public;0;33;;@Override public Producer createProducer() throws Exception {     // do we have servers?     SolrComponent.SolrServerReference ref = getComponent().getSolrServers(this).     if (ref == null) {         // no then create new servers         ref = new SolrComponent.SolrServerReference().         CloudSolrClient cloudServer = getCloudServer().         if (cloudServer == null) {             HttpSolrClient solrServer = new HttpSolrClient.Builder(url).build().             ConcurrentUpdateSolrClient solrStreamingServer = new ConcurrentUpdateSolrClient.Builder(url).withQueueSize(streamingQueueSize).withThreadCount(streamingThreadCount).build().             // set the properties on the solr server             if (soTimeout != null) {                 solrServer.setSoTimeout(soTimeout).             }             if (connectionTimeout != null) {                 solrServer.setConnectionTimeout(connectionTimeout).             }             if (followRedirects != null) {                 solrServer.setFollowRedirects(followRedirects).             }             ref.setSolrServer(solrServer).             ref.setUpdateSolrServer(solrStreamingServer).         }         ref.setCloudSolrServer(cloudServer).         getComponent().addSolrServers(this, ref).     }     ref.addReference().     return new SolrProducer(this, ref.getSolrServer(), ref.getUpdateSolrServer(), ref.getCloudSolrServer()). }
false;protected;1;9;;protected void onProducerShutdown(SolrProducer producer) {     SolrComponent.SolrServerReference ref = getComponent().getSolrServers(this).     if (ref != null) {         int counter = ref.decReference().         if (counter <= 0) {             getComponent().shutdownServers(ref, true).         }     } }
false;public;1;4;;@Override public Consumer createConsumer(Processor processor) throws Exception {     throw new UnsupportedOperationException("Consumer not supported for Solr endpoint."). }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
true;public;1;3;/**  * Set the request handler to be used  */ ;/**  * Set the request handler to be used  */ public void setRequestHandler(String requestHandler) {     this.requestHandler = requestHandler. }
false;public;0;3;;public String getRequestHandler() {     return requestHandler. }
false;public;0;3;;public int getStreamingThreadCount() {     return streamingThreadCount. }
true;public;1;3;/**  * Set the number of threads for the StreamingUpdateSolrServer  */ ;/**  * Set the number of threads for the StreamingUpdateSolrServer  */ public void setStreamingThreadCount(int streamingThreadCount) {     this.streamingThreadCount = streamingThreadCount. }
false;public;0;3;;public int getStreamingQueueSize() {     return streamingQueueSize. }
true;public;1;3;/**  * Set the queue size for the StreamingUpdateSolrServer  */ ;/**  * Set the queue size for the StreamingUpdateSolrServer  */ public void setStreamingQueueSize(int streamingQueueSize) {     this.streamingQueueSize = streamingQueueSize. }
false;public;0;3;;public Integer getMaxRetries() {     return maxRetries. }
true;public;1;3;/**  * Maximum number of retries to attempt in the event of transient errors  */ ;/**  * Maximum number of retries to attempt in the event of transient errors  */ public void setMaxRetries(Integer maxRetries) {     this.maxRetries = maxRetries. }
false;public;0;3;;public Integer getSoTimeout() {     return soTimeout. }
true;public;1;3;/**  * Read timeout on the underlying HttpConnectionManager. This is desirable for queries, but probably not for indexing  */ ;/**  * Read timeout on the underlying HttpConnectionManager. This is desirable for queries, but probably not for indexing  */ public void setSoTimeout(Integer soTimeout) {     this.soTimeout = soTimeout. }
false;public;0;3;;public Integer getConnectionTimeout() {     return connectionTimeout. }
true;public;1;3;/**  * connectionTimeout on the underlying HttpConnectionManager  */ ;/**  * connectionTimeout on the underlying HttpConnectionManager  */ public void setConnectionTimeout(Integer connectionTimeout) {     this.connectionTimeout = connectionTimeout. }
false;public;0;3;;public Integer getDefaultMaxConnectionsPerHost() {     return defaultMaxConnectionsPerHost. }
true;public;1;3;/**  * maxConnectionsPerHost on the underlying HttpConnectionManager  */ ;/**  * maxConnectionsPerHost on the underlying HttpConnectionManager  */ public void setDefaultMaxConnectionsPerHost(Integer defaultMaxConnectionsPerHost) {     this.defaultMaxConnectionsPerHost = defaultMaxConnectionsPerHost. }
false;public;0;3;;public Integer getMaxTotalConnections() {     return maxTotalConnections. }
true;public;1;3;/**  * maxTotalConnection on the underlying HttpConnectionManager  */ ;/**  * maxTotalConnection on the underlying HttpConnectionManager  */ public void setMaxTotalConnections(Integer maxTotalConnections) {     this.maxTotalConnections = maxTotalConnections. }
false;public;0;3;;public Boolean getFollowRedirects() {     return followRedirects. }
true;public;1;3;/**  * indicates whether redirects are used to get to the Solr server  */ ;/**  * indicates whether redirects are used to get to the Solr server  */ public void setFollowRedirects(Boolean followRedirects) {     this.followRedirects = followRedirects. }
false;public;0;3;;public Boolean getAllowCompression() {     return allowCompression. }
true;public;1;3;/**  * Server side must support gzip or deflate for this to have any effect  */ ;/**  * Server side must support gzip or deflate for this to have any effect  */ public void setAllowCompression(Boolean allowCompression) {     this.allowCompression = allowCompression. }
