commented;modifiers;parameterAmount;loc;comment;code
false;private;1;9;;private SolrClient getBestSolrServer(String operation) {     if (this.cloudSolrServer != null) {         return this.cloudSolrServer.     } else if (SolrConstants.OPERATION_INSERT_STREAMING.equals(operation)) {         return this.concSolrServer.     } else {         return this.httpServer.     } }
false;public;1;34;;@Override public void process(Exchange exchange) throws Exception {     String operation = (String) exchange.getIn().getHeader(SolrConstants.OPERATION).     if (operation == null) {         throw new IllegalArgumentException(SolrConstants.OPERATION + " header is missing").     }     SolrClient serverToUse = getBestSolrServer(operation).     if (operation.equalsIgnoreCase(SolrConstants.OPERATION_INSERT)) {         insert(exchange, serverToUse).     } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_INSERT_STREAMING)) {         insert(exchange, serverToUse).     } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_DELETE_BY_ID)) {         serverToUse.deleteById(exchange.getIn().getBody(String.class)).     } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_DELETE_BY_QUERY)) {         serverToUse.deleteByQuery(exchange.getIn().getBody(String.class)).     } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_ADD_BEAN)) {         serverToUse.addBean(exchange.getIn().getBody()).     } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_ADD_BEANS)) {         serverToUse.addBeans(exchange.getIn().getBody(Collection.class)).     } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_COMMIT)) {         serverToUse.commit().     } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_ROLLBACK)) {         serverToUse.rollback().     } else if (operation.equalsIgnoreCase(SolrConstants.OPERATION_OPTIMIZE)) {         serverToUse.optimize().     } else {         throw new IllegalArgumentException(SolrConstants.OPERATION + " header value '" + operation + "' is not supported").     } }
false;private;2;116;;private void insert(Exchange exchange, SolrClient solrServer) throws Exception {     Object body = exchange.getIn().getBody().     boolean invalid = false.     if (body instanceof WrappedFile) {         body = ((WrappedFile<?>) body).getFile().     }     if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(Exchange.CONTENT_TYPE, String.class))) {         String mimeType = exchange.getIn().getHeader(Exchange.CONTENT_TYPE, String.class).         ContentStreamUpdateRequest updateRequest = new ContentStreamUpdateRequest(getRequestHandler()).         updateRequest.addFile((File) body, mimeType).         for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {             if (entry.getKey().startsWith(SolrConstants.PARAM)) {                 String paramName = entry.getKey().substring(SolrConstants.PARAM.length()).                 updateRequest.setParam(paramName, entry.getValue().toString()).             }         }         updateRequest.process(solrServer).     } else {         if (body instanceof File) {             MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap().             String mimeType = mimeTypesMap.getContentType((File) body).             ContentStreamUpdateRequest updateRequest = new ContentStreamUpdateRequest(getRequestHandler()).             updateRequest.addFile((File) body, mimeType).             for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {                 if (entry.getKey().startsWith(SolrConstants.PARAM)) {                     String paramName = entry.getKey().substring(SolrConstants.PARAM.length()).                     updateRequest.setParam(paramName, entry.getValue().toString()).                 }             }             updateRequest.process(solrServer).         } else if (body instanceof SolrInputDocument) {             UpdateRequest updateRequest = new UpdateRequest(getRequestHandler()).             updateRequest.add((SolrInputDocument) body).             for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {                 if (entry.getKey().startsWith(SolrConstants.PARAM)) {                     String paramName = entry.getKey().substring(SolrConstants.PARAM.length()).                     updateRequest.setParam(paramName, entry.getValue().toString()).                 }             }             updateRequest.process(solrServer).         } else if (body instanceof List<?>) {             List<?> list = (List<?>) body.             if (list.size() > 0 && list.get(0) instanceof SolrInputDocument) {                 UpdateRequest updateRequest = new UpdateRequest(getRequestHandler()).                 updateRequest.add((List<SolrInputDocument>) list).                 for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {                     if (entry.getKey().startsWith(SolrConstants.PARAM)) {                         String paramName = entry.getKey().substring(SolrConstants.PARAM.length()).                         updateRequest.setParam(paramName, entry.getValue().toString()).                     }                 }                 updateRequest.process(solrServer).             } else {                 invalid = true.             }         } else {             boolean hasSolrHeaders = false.             for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {                 if (entry.getKey().startsWith(SolrConstants.FIELD)) {                     hasSolrHeaders = true.                     break.                 }             }             if (hasSolrHeaders) {                 UpdateRequest updateRequest = new UpdateRequest(getRequestHandler()).                 SolrInputDocument doc = new SolrInputDocument().                 for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {                     if (entry.getKey().startsWith(SolrConstants.FIELD)) {                         String fieldName = entry.getKey().substring(SolrConstants.FIELD.length()).                         doc.setField(fieldName, entry.getValue()).                     }                 }                 updateRequest.add(doc).                 updateRequest.process(solrServer).             } else if (body instanceof String) {                 String bodyAsString = (String) body.                 if (!bodyAsString.startsWith("<add")) {                     bodyAsString = "<add>" + bodyAsString + "</add>".                 }                 DirectXmlRequest xmlRequest = new DirectXmlRequest(getRequestHandler(), bodyAsString).                 solrServer.request(xmlRequest).             } else {                 invalid = true.             }         }     }     if (invalid) {         throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "unable to find data in Exchange to update Solr").     } }
false;private;0;4;;private String getRequestHandler() {     String requestHandler = getEndpoint().getRequestHandler().     return (requestHandler == null) ? "/update" : requestHandler. }
false;public;0;4;;@Override public SolrEndpoint getEndpoint() {     return (SolrEndpoint) super.getEndpoint(). }
false;protected;0;4;;@Override protected void doShutdown() throws Exception {     getEndpoint().onProducerShutdown(this). }
