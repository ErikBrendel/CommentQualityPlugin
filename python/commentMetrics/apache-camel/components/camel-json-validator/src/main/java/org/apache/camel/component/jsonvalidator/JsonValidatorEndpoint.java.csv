commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override public void clearContentCache() {     this.schema = null.     super.clearContentCache(). }
false;public;0;4;;@Override public ExchangePattern getExchangePattern() {     return ExchangePattern.InOut. }
false;protected;1;66;;@Override protected void onExchange(Exchange exchange) throws Exception {     StreamCache cache = null.     // if the content is an input stream then its likely not re-readable so we need to make it stream cached     Object content = getContentToValidate(exchange).     if (!(content instanceof StreamCache) && content instanceof InputStream) {         cache = exchange.getContext().getTypeConverter().convertTo(StreamCache.class, exchange, content).         if (cache != null) {             if (shouldUseHeader()) {                 exchange.getIn().setHeader(headerName, cache).             } else {                 exchange.getIn().setBody(cache).             }         }     }     // Get a local copy of the current schema to improve concurrency.     JsonSchema localSchema = this.schema.     if (localSchema == null) {         localSchema = getOrCreateSchema().     }     try {         if (shouldUseHeader()) {             if (content == null && isFailOnNullHeader()) {                 throw new NoJsonHeaderValidationException(exchange, headerName).             }         } else {             if (content == null && isFailOnNullBody()) {                 throw new NoJsonBodyValidationException(exchange).             }         }         if (content != null) {             // favour using stream caching             if (cache == null) {                 cache = exchange.getContext().getTypeConverter().convertTo(StreamCache.class, exchange, content).             }             ObjectMapper mapper = new ObjectMapper().             InputStream is = exchange.getContext().getTypeConverter().mandatoryConvertTo(InputStream.class, exchange, cache != null ? cache : content).             JsonNode node = mapper.readTree(is).             if (node == null) {                 throw new NoJsonBodyValidationException(exchange).             }             Set<ValidationMessage> errors = localSchema.validate(node).             if (errors.size() > 0) {                 this.log.debug("Validated JSon has {} errors", errors.size()).                 this.errorHandler.handleErrors(exchange, schema, errors).             } else {                 this.log.debug("Validated JSon success").             }         }     } catch (Exception e) {         if (e instanceof ValidationException) {             // already as validation error             throw e.         } else {             // general error             this.errorHandler.handleErrors(exchange, schema, e).         }     } finally {         if (cache != null) {             cache.reset().         }     } }
false;private;1;7;;private Object getContentToValidate(Exchange exchange) {     if (shouldUseHeader()) {         return exchange.getIn().getHeader(headerName).     } else {         return exchange.getIn().getBody().     } }
false;private;0;3;;private boolean shouldUseHeader() {     return headerName != null. }
true;private;0;8;/**  * Synchronized method to create a schema if is does not already exist.  *  * @return The currently loaded schema  */ ;/**  * Synchronized method to create a schema if is does not already exist.  *  * @return The currently loaded schema  */ private JsonSchema getOrCreateSchema() throws Exception {     synchronized (this) {         if (this.schema == null) {             this.schema = this.schemaLoader.createSchema(getCamelContext(), this.getResourceAsInputStream()).         }     }     return this.schema. }
false;protected;0;4;;@Override protected String createEndpointUri() {     return "json-validator:" + getResourceUri(). }
false;public;0;3;;public JsonValidatorErrorHandler getErrorHandler() {     return errorHandler. }
true;public;1;3;/**  * To use a custom ValidatorErrorHandler.  * <p/>  * The default error handler captures the errors and throws an exception.  */ ;/**  * To use a custom ValidatorErrorHandler.  * <p/>  * The default error handler captures the errors and throws an exception.  */ public void setErrorHandler(JsonValidatorErrorHandler errorHandler) {     this.errorHandler = errorHandler. }
false;public;0;3;;public JsonSchemaLoader getSchemaLoader() {     return schemaLoader. }
true;public;1;3;/**  * To use a custom schema loader allowing for adding custom format validation. The default implementation will create a schema loader with draft v4 support.  */ ;/**  * To use a custom schema loader allowing for adding custom format validation. The default implementation will create a schema loader with draft v4 support.  */ public void setSchemaLoader(JsonSchemaLoader schemaLoader) {     this.schemaLoader = schemaLoader. }
false;public;0;3;;public boolean isFailOnNullBody() {     return failOnNullBody. }
true;public;1;3;/**  * Whether to fail if no body exists.  */ ;/**  * Whether to fail if no body exists.  */ public void setFailOnNullBody(boolean failOnNullBody) {     this.failOnNullBody = failOnNullBody. }
false;public;0;3;;public boolean isFailOnNullHeader() {     return failOnNullHeader. }
true;public;1;3;/**  * Whether to fail if no header exists when validating against a header.  */ ;/**  * Whether to fail if no header exists when validating against a header.  */ public void setFailOnNullHeader(boolean failOnNullHeader) {     this.failOnNullHeader = failOnNullHeader. }
false;public;0;3;;public String getHeaderName() {     return headerName. }
true;public;1;3;/**  * To validate against a header instead of the message body.  */ ;/**  * To validate against a header instead of the message body.  */ public void setHeaderName(String headerName) {     this.headerName = headerName. }
