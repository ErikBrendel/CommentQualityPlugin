commented;modifiers;parameterAmount;loc;comment;code
false;public;3;5;;public void initialize(URI uri, Map<String, Object> parameters, SipComponent component) {     this.setParameters(parameters).     this.setComponent(component).     this.setUri(uri). }
false;public;0;100;;public void parseURI() throws Exception {     protocol = uri.getScheme().     if ((!protocol.equalsIgnoreCase("sip")) && (!protocol.equalsIgnoreCase("sips"))) {         throw new IllegalArgumentException("Unrecognized SIP protocol: " + protocol + " for uri: " + uri).     }     Map<String, Object> settings = URISupport.parseParameters(uri).     if (settings.containsKey("stackName")) {         setStackName((String) settings.get("stackName")).     }     if (settings.containsKey("transport")) {         setTransport((String) settings.get("transport")).     }     if (settings.containsKey("maxMessageSize")) {         setMaxMessageSize(Integer.parseInt((String) settings.get("maxMessageSize"))).     }     if (settings.containsKey("cacheConnections")) {         setCacheConnections(Boolean.valueOf((String) settings.get("cacheConnections"))).     }     if (settings.containsKey("contentType")) {         setContentType((String) settings.get("contentType")).     }     if (settings.containsKey("contentSubType")) {         setContentSubType((String) settings.get("contentSubType")).     }     if (settings.containsKey("maxForwards")) {         setMaxForwards(Integer.parseInt((String) settings.get("maxForwards"))).     }     if (settings.containsKey("receiveTimeoutMillis")) {         setReceiveTimeoutMillis(Long.parseLong((String) settings.get("receiveTimeoutMillis"))).     }     if (settings.containsKey("eventHeaderName")) {         setEventHeaderName((String) settings.get("eventHeaderName")).     }     if (settings.containsKey("eventId")) {         setEventId((String) settings.get("eventId")).     }     if (settings.containsKey("useRouterForAllUris")) {         setUseRouterForAllUris(Boolean.valueOf((String) settings.get("useRouterForAllUris"))).     }     if (settings.containsKey("msgExpiration")) {         setMsgExpiration(Integer.parseInt((String) settings.get("msgExpiration"))).     }     if (settings.containsKey("presenceAgent")) {         setPresenceAgent(Boolean.valueOf((String) settings.get("presenceAgent"))).     }     if (!consumer) {         if (settings.containsKey("fromUser")) {             setFromUser((String) settings.get("fromUser")).         }         if (settings.containsKey("fromHost")) {             setFromHost((String) settings.get("fromHost")).         }         if (settings.containsKey("fromPort")) {             setFromPort(Integer.parseInt((String) settings.get("fromPort"))).         }         setToUser(uri.getUserInfo()).         setToHost(uri.getHost()).         setToPort(uri.getPort()).     } else {         setFromUser(uri.getUserInfo()).         setFromHost(uri.getHost()).         setFromPort(uri.getPort()).         if (!presenceAgent) {             if (settings.containsKey("toUser")) {                 setToUser((String) settings.get("toUser")).             }             if (settings.containsKey("toHost")) {                 setToHost((String) settings.get("toHost")).             }             if (settings.containsKey("toPort")) {                 setToPort(Integer.parseInt((String) settings.get("toPort"))).             }         }     }     implementationDebugLogFile = component.getAndRemoveParameter(parameters, "implementationDebugLogFile", String.class, null).     implementationServerLogFile = component.getAndRemoveParameter(parameters, "implementationServerLogFile", String.class, null).     implementationTraceLevel = component.getAndRemoveParameter(parameters, "implementationTraceLevel", String.class, "0").     LOG.trace("Consumer:" + consumer + " StackName:" + stackName).     LOG.trace("From User: " + getFromUser() + " From host: " + getFromHost() + " From Port: " + getFromPort()).     createFactoriesAndHeaders(parameters, component).     sipUri = component.resolveAndRemoveReferenceParameter(parameters, "sipUri", SipURI.class, null).     if (sipUri == null) {         sipUri = addressFactory.createSipURI(getToUser(), getToHost() + ":" + getToPort()).     }     ObjectHelper.notNull(fromUser, "From User").     ObjectHelper.notNull(fromHost, "From Host").     ObjectHelper.notNull(fromPort, "From Port").     ObjectHelper.notNull(eventHeader, "Event Header").     ObjectHelper.notNull(eventHeaderName, "Event Header Name").     ObjectHelper.notNull(eventId, "Event Id"). }
false;private;2;47;;@SuppressWarnings("unchecked") private void createFactoriesAndHeaders(Map<String, Object> parameters, SipComponent component) throws Exception {     headerFactory = sipFactory.createHeaderFactory().     addressFactory = sipFactory.createAddressFactory().     setMessageFactory(sipFactory.createMessageFactory()).     fromHeader = component.resolveAndRemoveReferenceParameter(parameters, "fromHeader", FromHeader.class, null).     if (fromHeader == null) {         createFromHeader().     }     if (!presenceAgent) {         toHeader = component.resolveAndRemoveReferenceParameter(parameters, "toHeader", ToHeader.class, null).         if (toHeader == null) {             createToHeader().         }     }     viaHeaders = component.resolveAndRemoveReferenceParameter(parameters, "viaHeaders", List.class, null).     if (viaHeaders == null) {         createViaHeaders().     }     contentTypeHeader = component.resolveAndRemoveReferenceParameter(parameters, "contentTypeHeader", ContentTypeHeader.class, null).     if (contentTypeHeader == null) {         createContentTypeHeader().     }     callIdHeader = component.resolveAndRemoveReferenceParameter(parameters, "callIdHeader", CallIdHeader.class, null).     maxForwardsHeader = component.resolveAndRemoveReferenceParameter(parameters, "maxForwardsHeader", MaxForwardsHeader.class, null).     if (maxForwardsHeader == null) {         createMaxForwardsHeader().     }     // Optional Headers     eventHeader = component.resolveAndRemoveReferenceParameter(parameters, "eventHeader", EventHeader.class, null).     if (eventHeader == null) {         createEventHeader().     }     contactHeader = component.resolveAndRemoveReferenceParameter(parameters, "contactHeader", ContactHeader.class, null).     if (contactHeader == null) {         createContactHeader().     }     expiresHeader = component.resolveAndRemoveReferenceParameter(parameters, "expiresHeader", ExpiresHeader.class, null).     if (expiresHeader == null) {         createExpiresHeader().     }     extensionHeader = component.resolveAndRemoveReferenceParameter(parameters, "extensionHeader", ExtensionHeader.class, null). }
false;public;3;31;;public Request createSipRequest(long sequenceNumber, String requestMethod, Object body) throws ParseException, InvalidArgumentException {     // SipConfiguration configuration = sipPublisher.getConfiguration().     CSeqHeader cSeqHeader = getHeaderFactory().createCSeqHeader(sequenceNumber, requestMethod).     // Create the request.     Request request = getMessageFactory().createRequest(getSipUri(), requestMethod, getCallIdHeader(), cSeqHeader, getFromHeader(), getToHeader(), getViaHeaders(), getMaxForwardsHeader()).     if (getEventHeader() != null) {         request.addHeader(getEventHeader()).     }     if (getExpiresHeader() != null) {         request.addHeader(getExpiresHeader()).     }     if (getContactHeader() != null) {         request.addHeader(getContactHeader()).     }     if (getExtensionHeader() != null) {         request.addHeader(getExtensionHeader()).     }     request.setContent(body, getContentTypeHeader()).     return request. }
false;private;0;8;;private void createFromHeader() throws ParseException {     SipURI fromAddress = getAddressFactory().createSipURI(getFromUser(), getFromHost()).     fromAddress.setPort(Integer.valueOf(getFromPort()).intValue()).     Address fromNameAddress = addressFactory.createAddress(fromAddress).     fromNameAddress.setDisplayName(getFromUser()).     setFromHeader(headerFactory.createFromHeader(fromNameAddress, getFromUser() + "_Header")). }
false;private;0;8;;private void createToHeader() throws ParseException {     SipURI toAddress = getAddressFactory().createSipURI(getToUser(), getToHost()).     toAddress.setPort(getToPort()).     Address toNameAddress = addressFactory.createAddress(toAddress).     toNameAddress.setDisplayName(getToUser()).     setToHeader(headerFactory.createToHeader(toNameAddress, getToUser() + "_Header")). }
false;private;0;7;;private void createViaHeaders() throws ParseException, InvalidArgumentException {     viaHeaders = new ArrayList<>().     ViaHeader viaHeader = headerFactory.createViaHeader(getFromHost(), getFromPort(), getTransport(), null).     viaHeaders.add(viaHeader). }
false;private;0;3;;private void createContentTypeHeader() throws ParseException {     setContentTypeHeader(headerFactory.createContentTypeHeader(getContentType(), getContentSubType())). }
false;private;0;3;;private void createMaxForwardsHeader() throws ParseException, InvalidArgumentException {     setMaxForwardsHeader(headerFactory.createMaxForwardsHeader(getMaxForwards())). }
false;private;0;4;;private void createEventHeader() throws ParseException {     eventHeader = getHeaderFactory().createEventHeader(getEventHeaderName()).     eventHeader.setEventId(getEventId()). }
false;private;0;11;;private void createContactHeader() throws ParseException {     SipURI contactURI = addressFactory.createSipURI(getFromUser(), getFromHost()).     contactURI.setTransportParam(getTransport()).     contactURI.setPort(Integer.valueOf(getFromPort()).intValue()).     Address contactAddress = addressFactory.createAddress(contactURI).     // Add the contact address.     contactAddress.setDisplayName(getFromUser()).     contactHeader = headerFactory.createContactHeader(contactAddress). }
false;private;0;3;;private void createExpiresHeader() throws ParseException, InvalidArgumentException {     expiresHeader = getHeaderFactory().createExpiresHeader(getMsgExpiration()). }
false;;0;14;;Properties createInitialProperties() {     Properties properties = new Properties().     properties.setProperty("javax.sip.STACK_NAME", getStackName()).     properties.setProperty("gov.nist.javax.sip.MAX_MESSAGE_SIZE", "" + getMaxMessageSize()).     properties.setProperty("gov.nist.javax.sip.CACHE_CLIENT_CONNECTIONS", "" + isCacheConnections()).     properties.setProperty("javax.sip.USE_ROUTER_FOR_ALL_URIS", "" + isUseRouterForAllUris()).     if ((implementationDebugLogFile != null) && (implementationServerLogFile != null)) {         properties.setProperty("gov.nist.javax.sip.DEBUG_LOG", implementationDebugLogFile).         properties.setProperty("gov.nist.javax.sip.SERVER_LOG", implementationServerLogFile).         properties.setProperty("gov.nist.javax.sip.TRACE_LEVEL", implementationTraceLevel).     }     return properties. }
false;public;0;3;;public AddressFactory getAddressFactory() {     return addressFactory. }
true;public;1;3;/**  * To use a custom AddressFactory  */ ;/**  * To use a custom AddressFactory  */ public void setAddressFactory(AddressFactory addressFactory) {     this.addressFactory = addressFactory. }
false;public;0;3;;public MessageFactory getMessageFactory() {     return messageFactory. }
true;public;1;3;/**  * To use a custom MessageFactory  */ ;/**  * To use a custom MessageFactory  */ public void setMessageFactory(MessageFactory messageFactory) {     this.messageFactory = messageFactory. }
false;public;0;3;;public HeaderFactory getHeaderFactory() {     return headerFactory. }
true;public;1;3;/**  * To use a custom HeaderFactory  */ ;/**  * To use a custom HeaderFactory  */ public void setHeaderFactory(HeaderFactory headerFactory) {     this.headerFactory = headerFactory. }
false;public;0;3;;public SipStack getSipStack() {     return sipStack. }
true;public;1;3;/**  * To use a custom SipStack  */ ;/**  * To use a custom SipStack  */ public void setSipStack(SipStack sipStack) {     this.sipStack = sipStack. }
false;public;0;3;;public SipURI getSipUri() {     return sipUri. }
true;public;1;3;/**  * To use a custom SipURI. If none configured, then the SipUri fallback to use the options toUser toHost:toPort  */ ;/**  * To use a custom SipURI. If none configured, then the SipUri fallback to use the options toUser toHost:toPort  */ public void setSipUri(SipURI sipUri) {     this.sipUri = sipUri. }
false;public;0;3;;public String getStackName() {     return stackName. }
true;public;1;3;/**  * Name of the SIP Stack instance associated with an SIP Endpoint.  */ ;/**  * Name of the SIP Stack instance associated with an SIP Endpoint.  */ public void setStackName(String stackName) {     this.stackName = stackName. }
false;public;0;3;;public String getTransport() {     return transport. }
true;public;1;3;/**  * Setting for choice of transport protocol. Valid choices are "tcp" or "udp".  */ ;/**  * Setting for choice of transport protocol. Valid choices are "tcp" or "udp".  */ public void setTransport(String transport) {     this.transport = transport. }
false;public;0;3;;public int getMaxMessageSize() {     return maxMessageSize. }
true;public;1;3;/**  * Setting for maximum allowed Message size in bytes.  */ ;/**  * Setting for maximum allowed Message size in bytes.  */ public void setMaxMessageSize(int maxMessageSize) {     this.maxMessageSize = maxMessageSize. }
false;public;0;3;;public boolean isCacheConnections() {     return cacheConnections. }
true;public;1;3;/**  * Should connections be cached by the SipStack to reduce cost of connection creation. This is useful if the connection is used for long running conversations.  */ ;/**  * Should connections be cached by the SipStack to reduce cost of connection creation. This is useful if the connection is used for long running conversations.  */ public void setCacheConnections(boolean cacheConnections) {     this.cacheConnections = cacheConnections. }
false;public;0;3;;public ListeningPoint getListeningPoint() {     return listeningPoint. }
true;public;1;3;/**  * To use a custom ListeningPoint implementation  */ ;/**  * To use a custom ListeningPoint implementation  */ public void setListeningPoint(ListeningPoint listeningPoint) {     this.listeningPoint = listeningPoint. }
true;public;1;3;/**  * Setting for contentType can be set to any valid MimeType.  */ ;/**  * Setting for contentType can be set to any valid MimeType.  */ public void setContentType(String contentType) {     this.contentType = contentType. }
false;public;0;3;;public String getContentType() {     return contentType. }
true;public;1;3;/**  * Setting for contentSubType can be set to any valid MimeSubType.  */ ;/**  * Setting for contentSubType can be set to any valid MimeSubType.  */ public void setContentSubType(String contentSubType) {     this.contentSubType = contentSubType. }
false;public;0;3;;public String getContentSubType() {     return contentSubType. }
true;public;1;3;/**  * Number of maximum proxy forwards  */ ;/**  * Number of maximum proxy forwards  */ public void setMaxForwards(int maxForwards) {     this.maxForwards = maxForwards. }
false;public;0;3;;public int getMaxForwards() {     return maxForwards. }
true;public;1;3;/**  * Setting for specifying amount of time to wait for a Response and/or Acknowledgement can be received from another SIP stack  */ ;/**  * Setting for specifying amount of time to wait for a Response and/or Acknowledgement can be received from another SIP stack  */ public void setReceiveTimeoutMillis(long receiveTimeoutMillis) {     this.receiveTimeoutMillis = receiveTimeoutMillis. }
false;public;0;3;;public long getReceiveTimeoutMillis() {     return receiveTimeoutMillis. }
false;public;1;3;;public void setParameters(Map<String, Object> parameters) {     this.parameters = parameters. }
false;public;0;3;;public Map<String, Object> getParameters() {     return parameters. }
false;public;1;3;;public void setComponent(SipComponent component) {     this.component = component. }
false;public;0;3;;public SipComponent getComponent() {     return component. }
false;public;0;3;;public String getImplementationServerLogFile() {     return implementationServerLogFile. }
true;public;1;3;/**  * Name of server log file to use for logging  */ ;/**  * Name of server log file to use for logging  */ public void setImplementationServerLogFile(String implementationServerLogFile) {     this.implementationServerLogFile = implementationServerLogFile. }
false;public;0;3;;public String getImplementationDebugLogFile() {     return implementationDebugLogFile. }
true;public;1;3;/**  * Name of client debug log file to use for logging  */ ;/**  * Name of client debug log file to use for logging  */ public void setImplementationDebugLogFile(String implementationDebugLogFile) {     this.implementationDebugLogFile = implementationDebugLogFile. }
false;public;0;3;;public String getImplementationTraceLevel() {     return implementationTraceLevel. }
true;public;1;3;/**  * Logging level for tracing  */ ;/**  * Logging level for tracing  */ public void setImplementationTraceLevel(String implementationTraceLevel) {     this.implementationTraceLevel = implementationTraceLevel. }
false;public;0;3;;public SipFactory getSipFactory() {     return sipFactory. }
true;public;1;3;/**  * To use a custom SipFactory to create the SipStack to be used  */ ;/**  * To use a custom SipFactory to create the SipStack to be used  */ public void setSipFactory(SipFactory sipFactory) {     this.sipFactory = sipFactory. }
false;public;0;3;;public String getFromUser() {     return fromUser. }
true;public;1;3;/**  * Username of the message originator. Mandatory setting unless a registry based custom FromHeader is specified.  */ ;/**  * Username of the message originator. Mandatory setting unless a registry based custom FromHeader is specified.  */ public void setFromUser(String fromUser) {     this.fromUser = fromUser. }
false;public;0;3;;public String getFromHost() {     return fromHost. }
true;public;1;3;/**  * Hostname of the message originator. Mandatory setting unless a registry based FromHeader is specified  */ ;/**  * Hostname of the message originator. Mandatory setting unless a registry based FromHeader is specified  */ public void setFromHost(String fromHost) {     this.fromHost = fromHost. }
false;public;0;3;;public int getFromPort() {     return fromPort. }
true;public;1;3;/**  * Port of the message originator. Mandatory setting unless a registry based FromHeader is specified  */ ;/**  * Port of the message originator. Mandatory setting unless a registry based FromHeader is specified  */ public void setFromPort(int fromPort) {     this.fromPort = fromPort. }
false;public;0;3;;public String getToUser() {     return toUser. }
true;public;1;3;/**  * Username of the message receiver. Mandatory setting unless a registry based custom ToHeader is specified.  */ ;/**  * Username of the message receiver. Mandatory setting unless a registry based custom ToHeader is specified.  */ public void setToUser(String toUser) {     this.toUser = toUser. }
false;public;0;3;;public String getToHost() {     return toHost. }
true;public;1;3;/**  * Hostname of the message receiver. Mandatory setting unless a registry based ToHeader is specified  */ ;/**  * Hostname of the message receiver. Mandatory setting unless a registry based ToHeader is specified  */ public void setToHost(String toHost) {     this.toHost = toHost. }
false;public;0;3;;public int getToPort() {     return toPort. }
true;public;1;3;/**  * Portname of the message receiver. Mandatory setting unless a registry based ToHeader is specified  */ ;/**  * Portname of the message receiver. Mandatory setting unless a registry based ToHeader is specified  */ public void setToPort(int toPort) {     this.toPort = toPort. }
false;public;0;3;;public FromHeader getFromHeader() {     return fromHeader. }
true;public;1;3;/**  * A custom Header object containing message originator settings. Must implement the type javax.sip.header.FromHeader  */ ;/**  * A custom Header object containing message originator settings. Must implement the type javax.sip.header.FromHeader  */ public void setFromHeader(FromHeader fromHeader) {     this.fromHeader = fromHeader. }
false;public;0;3;;public ToHeader getToHeader() {     return toHeader. }
true;public;1;3;/**  * A custom Header object containing message receiver settings. Must implement the type javax.sip.header.ToHeader  */ ;/**  * A custom Header object containing message receiver settings. Must implement the type javax.sip.header.ToHeader  */ public void setToHeader(ToHeader toHeader) {     this.toHeader = toHeader. }
false;public;0;3;;public List<ViaHeader> getViaHeaders() {     return viaHeaders. }
true;public;1;3;/**  * List of custom Header objects of the type javax.sip.header.ViaHeader.  * Each ViaHeader containing a proxy address for request forwarding. (Note this header is automatically updated by each proxy when the request arrives at its listener)  */ ;/**  * List of custom Header objects of the type javax.sip.header.ViaHeader.  * Each ViaHeader containing a proxy address for request forwarding. (Note this header is automatically updated by each proxy when the request arrives at its listener)  */ public void setViaHeaders(List<ViaHeader> viaHeaders) {     this.viaHeaders = viaHeaders. }
false;public;0;3;;public ContentTypeHeader getContentTypeHeader() {     return contentTypeHeader. }
true;public;1;3;/**  * A custom Header object containing message content details. Must implement the type javax.sip.header.ContentTypeHeader  */ ;/**  * A custom Header object containing message content details. Must implement the type javax.sip.header.ContentTypeHeader  */ public void setContentTypeHeader(ContentTypeHeader contentTypeHeader) {     this.contentTypeHeader = contentTypeHeader. }
false;public;0;3;;public CallIdHeader getCallIdHeader() {     return callIdHeader. }
true;public;1;3;/**  * A custom Header object containing call details. Must implement the type javax.sip.header.CallIdHeader  */ ;/**  * A custom Header object containing call details. Must implement the type javax.sip.header.CallIdHeader  */ public void setCallIdHeader(CallIdHeader callIdHeader) {     this.callIdHeader = callIdHeader. }
false;public;0;3;;public MaxForwardsHeader getMaxForwardsHeader() {     return maxForwardsHeader. }
true;public;1;3;/**  * A custom Header object containing details on maximum proxy forwards.  * This header places a limit on the viaHeaders possible. Must implement the type javax.sip.header.MaxForwardsHeader  */ ;/**  * A custom Header object containing details on maximum proxy forwards.  * This header places a limit on the viaHeaders possible. Must implement the type javax.sip.header.MaxForwardsHeader  */ public void setMaxForwardsHeader(MaxForwardsHeader maxForwardsHeader) {     this.maxForwardsHeader = maxForwardsHeader. }
false;public;0;3;;public ContactHeader getContactHeader() {     return contactHeader. }
true;public;1;3;/**  * An optional custom Header object containing verbose contact details (email, phone number etc). Must implement the type javax.sip.header.ContactHeader  */ ;/**  * An optional custom Header object containing verbose contact details (email, phone number etc). Must implement the type javax.sip.header.ContactHeader  */ public void setContactHeader(ContactHeader contactHeader) {     this.contactHeader = contactHeader. }
false;public;0;3;;public ExtensionHeader getExtensionHeader() {     return extensionHeader. }
true;public;1;3;/**  * A custom Header object containing user/application specific details. Must implement the type javax.sip.header.ExtensionHeader  */ ;/**  * A custom Header object containing user/application specific details. Must implement the type javax.sip.header.ExtensionHeader  */ public void setExtensionHeader(ExtensionHeader extensionHeader) {     this.extensionHeader = extensionHeader. }
true;public;1;3;/**  * URI of the SIP server to connect to (the username and password can be included such as: john:secret@myserver:9999)  */ ;/**  * URI of the SIP server to connect to (the username and password can be included such as: john:secret@myserver:9999)  */ public void setUri(URI uri) {     this.uri = uri. }
false;public;0;3;;public URI getUri() {     return uri. }
true;public;1;3;/**  * This setting is used to determine whether the kind of header (FromHeader,ToHeader etc) that needs to be created for this endpoint  */ ;/**  * This setting is used to determine whether the kind of header (FromHeader,ToHeader etc) that needs to be created for this endpoint  */ public void setConsumer(boolean consumer) {     this.consumer = consumer. }
false;public;0;3;;public boolean isConsumer() {     return consumer. }
true;public;1;3;/**  * A custom Header object containing event details. Must implement the type javax.sip.header.EventHeader  */ ;/**  * A custom Header object containing event details. Must implement the type javax.sip.header.EventHeader  */ public void setEventHeader(EventHeader eventHeader) {     this.eventHeader = eventHeader. }
false;public;0;3;;public EventHeader getEventHeader() {     return eventHeader. }
true;public;1;3;/**  * Setting for a String based event type.  */ ;/**  * Setting for a String based event type.  */ public void setEventHeaderName(String eventHeaderName) {     this.eventHeaderName = eventHeaderName. }
false;public;0;3;;public String getEventHeaderName() {     return eventHeaderName. }
true;public;1;3;/**  * Setting for a String based event Id. Mandatory setting unless a registry based FromHeader is specified  */ ;/**  * Setting for a String based event Id. Mandatory setting unless a registry based FromHeader is specified  */ public void setEventId(String eventId) {     this.eventId = eventId. }
false;public;0;3;;public String getEventId() {     return eventId. }
true;public;1;3;/**  * This setting is used when requests are sent to the Presence Agent via a proxy.  */ ;/**  * This setting is used when requests are sent to the Presence Agent via a proxy.  */ public void setUseRouterForAllUris(boolean useRouterForAllUris) {     this.useRouterForAllUris = useRouterForAllUris. }
false;public;0;3;;public boolean isUseRouterForAllUris() {     return useRouterForAllUris. }
false;public;0;3;;public int getMsgExpiration() {     return msgExpiration. }
true;public;1;3;/**  * The amount of time a message received at an endpoint is considered valid  */ ;/**  * The amount of time a message received at an endpoint is considered valid  */ public void setMsgExpiration(int msgExpiration) {     this.msgExpiration = msgExpiration. }
false;public;0;3;;public ExpiresHeader getExpiresHeader() {     return expiresHeader. }
true;public;1;3;/**  * A custom Header object containing message expiration details. Must implement the type javax.sip.header.ExpiresHeader  */ ;/**  * A custom Header object containing message expiration details. Must implement the type javax.sip.header.ExpiresHeader  */ public void setExpiresHeader(ExpiresHeader expiresHeader) {     this.expiresHeader = expiresHeader. }
false;public;0;3;;public boolean isPresenceAgent() {     return presenceAgent. }
true;public;1;3;/**  * This setting is used to distinguish between a Presence Agent & a consumer.  * This is due to the fact that the SIP Camel component ships with a basic Presence Agent (for testing purposes only). Consumers have to set this flag to true.  */ ;/**  * This setting is used to distinguish between a Presence Agent & a consumer.  * This is due to the fact that the SIP Camel component ships with a basic Presence Agent (for testing purposes only). Consumers have to set this flag to true.  */ public void setPresenceAgent(boolean presenceAgent) {     this.presenceAgent = presenceAgent. }
