commented;modifiers;parameterAmount;loc;comment;code
false;public;1;15;;public void processRequest(RequestEvent requestEvent) {     Request request = requestEvent.getRequest().     ServerTransaction serverTransactionId = requestEvent.getServerTransaction().     LOG.debug("Request: {}", request.getMethod()).     LOG.debug("Server Transaction Id: {}", serverTransactionId).     if (request.getMethod().equals(Request.SUBSCRIBE)) {         processSubscribe(requestEvent, serverTransactionId).     } else if (request.getMethod().equals(Request.PUBLISH)) {         processPublish(requestEvent, serverTransactionId).     } else {         LOG.debug("Received expected request with method: {}. No further processing done", request.getMethod()).     } }
false;private;3;42;;private void sendNotification(EventHeader eventHeader, boolean isInitial, Object body) throws SipException, ParseException {     /*          * NOTIFY requests MUST contain a "Subscription-State" header with a          * value of "active", "pending", or "terminated". The "active" value          * indicates that the subscription has been accepted and has been          * authorized (in most cases. see section 5.2.). The "pending" value          * indicates that the subscription has been received, but that          * policy information is insufficient to accept or deny the          * subscription at this time. The "terminated" value indicates that          * the subscription is not active.          */     Request notifyRequest = dialog.createRequest("NOTIFY").     // Mark the contact header, to check that the remote contact is updated     ((SipURI) sipPresenceAgent.getConfiguration().getContactHeader().getAddress().getURI()).setParameter(sipPresenceAgent.getConfiguration().getFromUser(), sipPresenceAgent.getConfiguration().getFromHost()).     SubscriptionStateHeader sstate.     if (isInitial) {         // Initial state is pending, second time we assume terminated (Expires==0)         sstate = sipPresenceAgent.getConfiguration().getHeaderFactory().createSubscriptionStateHeader(isInitial ? SubscriptionStateHeader.PENDING : SubscriptionStateHeader.TERMINATED).         // Need a reason for terminated         if (sstate.getState().equalsIgnoreCase("terminated")) {             sstate.setReasonCode("deactivated").         }     } else {         sstate = sipPresenceAgent.getConfiguration().getHeaderFactory().createSubscriptionStateHeader(SubscriptionStateHeader.ACTIVE).     }     notifyRequest.addHeader(sstate).     notifyRequest.setHeader(eventHeader).     notifyRequest.setHeader(sipPresenceAgent.getConfiguration().getContactHeader()).     notifyRequest.setContent(body, sipPresenceAgent.getConfiguration().getContentTypeHeader()).     LOG.debug("Sending the following NOTIFY request to Subscriber: {}", notifyRequest).     ClientTransaction clientTransactionId = sipPresenceAgent.getProvider().getNewClientTransaction(notifyRequest).     dialog.sendRequest(clientTransactionId). }
false;private;2;17;;private void processPublish(RequestEvent requestEvent, ServerTransaction serverTransactionId) {     try {         Request request = requestEvent.getRequest().         LOG.debug("SipPresenceAgentListener: Received a Publish request, sending OK").         LOG.debug("SipPresenceAgentListener request: {}", request).         EventHeader eventHeader = (EventHeader) requestEvent.getRequest().getHeader(EventHeader.NAME).         Response response = sipPresenceAgent.getConfiguration().getMessageFactory().createResponse(202, request).         sipPresenceAgent.getProvider().sendResponse(response).         // Send notification to subscriber         sendNotification(eventHeader, false, request.getContent()).     } catch (Exception e) {         LOG.error("Exception thrown during publish/notify processing in the Sip Presence Agent Listener", e).     } }
false;public;2;50;;public void processSubscribe(RequestEvent requestEvent, ServerTransaction serverTransaction) {     SipProvider sipProvider = (SipProvider) requestEvent.getSource().     Request request = requestEvent.getRequest().     try {         LOG.debug("SipPresenceAgentListener: Received a Subscribe request, sending OK").         LOG.debug("SipPresenceAgentListener request: {}", request).         EventHeader eventHeader = (EventHeader) request.getHeader(EventHeader.NAME).         if (eventHeader == null) {             LOG.debug("Cannot find event header.... dropping request.").             return.         }         // Always create a ServerTransaction, best as early as possible in the code         Response response = null.         ServerTransaction st = requestEvent.getServerTransaction().         if (st == null) {             st = sipProvider.getNewServerTransaction(request).         }         // Check if it is an initial SUBSCRIBE or a refresh / unsubscribe         boolean isInitial = requestEvent.getDialog() == null.         if (isInitial) {             String toTag = UUID.randomUUID().toString().             response = sipPresenceAgent.getConfiguration().getMessageFactory().createResponse(202, request).             ToHeader toHeader = (ToHeader) response.getHeader(ToHeader.NAME).             // Application is supposed to set.             toHeader.setTag(toTag).             this.dialog = st.getDialog().             // subscribe dialogs do not terminate on bye.             this.dialog.terminateOnBye(false).         } else {             response = sipPresenceAgent.getConfiguration().getMessageFactory().createResponse(200, request).         }         // Both 2xx response to SUBSCRIBE and NOTIFY need a Contact         response.addHeader(sipPresenceAgent.getConfiguration().getContactHeader()).         // Expires header is mandatory in 2xx responses to SUBSCRIBE         response.addHeader(sipPresenceAgent.getConfiguration().getExpiresHeader()).         st.sendResponse(response).         LOG.debug("SipPresenceAgentListener: Sent OK Message").         LOG.debug("SipPresenceAgentListener response: {}", response).         sendNotification(eventHeader, isInitial, request.getContent()).     } catch (Throwable e) {         LOG.error("Exception thrown during Notify processing in the SipPresenceAgentListener.", e).     } }
false;public,synchronized;1;7;;public synchronized void processResponse(ResponseEvent responseReceivedEvent) {     Response response = responseReceivedEvent.getResponse().     Integer statusCode = response.getStatusCode().     if (SIP_MESSAGE_CODES.containsKey(statusCode)) {         LOG.debug(SIP_MESSAGE_CODES.get(statusCode) + " received from Subscriber").     } }
false;public;1;5;;public void processTimeout(javax.sip.TimeoutEvent timeoutEvent) {     if (LOG.isWarnEnabled()) {         LOG.warn("TimeoutEvent received at Sip Presence Agent Listener").     } }
false;public;1;5;;public void processIOException(IOExceptionEvent exceptionEvent) {     if (LOG.isWarnEnabled()) {         LOG.warn("IOExceptionEvent received at SipPresenceAgentListener").     } }
false;public;1;6;;public void processTransactionTerminated(TransactionTerminatedEvent transactionTerminatedEvent) {     if (LOG.isWarnEnabled()) {         LOG.warn("TransactionTerminatedEvent received at SipPresenceAgentListener").     } }
false;public;1;6;;public void processDialogTerminated(DialogTerminatedEvent dialogTerminatedEvent) {     if (LOG.isWarnEnabled()) {         LOG.warn("DialogTerminatedEvent received at SipPresenceAgentListener").     } }
