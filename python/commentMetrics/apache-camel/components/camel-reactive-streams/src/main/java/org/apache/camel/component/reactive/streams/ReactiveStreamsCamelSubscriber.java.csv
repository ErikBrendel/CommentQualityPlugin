commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;public void attachConsumer(ReactiveStreamsConsumer consumer) {     synchronized (this) {         if (this.consumer != null) {             throw new IllegalStateException("A consumer is already attached to the stream '" + name + "'").         }         this.consumer = consumer.     }     refill(). }
false;public,synchronized;0;3;;public synchronized ReactiveStreamsConsumer getConsumer() {     return consumer. }
false;public;0;5;;public void detachConsumer() {     synchronized (this) {         this.consumer = null.     } }
false;public;1;22;;@Override public void onSubscribe(Subscription subscription) {     if (subscription == null) {         throw new NullPointerException("subscription is null for stream '" + name + "'").     }     boolean allowed = true.     synchronized (this) {         if (this.subscription != null) {             allowed = false.         } else {             this.subscription = subscription.         }     }     if (!allowed) {         LOG.warn("There is another active subscription: cancelled").         subscription.cancel().     } else {         refill().     } }
false;public;1;31;;@Override public void onNext(Exchange exchange) {     if (exchange == null) {         throw new NullPointerException("exchange is null").     }     ReactiveStreamsConsumer target.     synchronized (this) {         if (requested < UNBOUNDED_REQUESTS) {             // When there are UNBOUNDED_REQUESTS, they remain constant             requested--.         }         target = this.consumer.         if (target != null) {             inflightCount++.         }     }     if (target != null) {         target.process(exchange, doneSync -> {             synchronized (this) {                 inflightCount--.             }             refill().         }).     } else {         // This may happen when the consumer is stopped         LOG.warn("Message received in stream '{}', but no consumers were attached. Discarding {}.", name, exchange).     } }
false;protected;0;24;;protected void refill() {     Long toBeRequested = null.     Subscription subs = null.     synchronized (this) {         if (consumer != null && this.subscription != null) {             Integer consMax = consumer.getEndpoint().getMaxInflightExchanges().             long max = (consMax != null && consMax > 0) ? consMax.longValue() : UNBOUNDED_REQUESTS.             if (requested < UNBOUNDED_REQUESTS) {                 long lowWatermark = Math.max(0, Math.round(consumer.getEndpoint().getExchangesRefillLowWatermark() * max)).                 long minRequests = Math.min(max, max - lowWatermark).                 long newRequest = max - requested - inflightCount.                 if (newRequest > 0 && newRequest >= minRequests) {                     toBeRequested = newRequest.                     requested += toBeRequested.                     subs = this.subscription.                 }             }         }     }     if (toBeRequested != null) {         subs.request(toBeRequested).     } }
false;public;1;19;;@Override public void onError(Throwable throwable) {     if (throwable == null) {         throw new NullPointerException("throwable is null").     }     LOG.error("Error in reactive stream '" + name + "'", throwable).     ReactiveStreamsConsumer consumer.     synchronized (this) {         consumer = this.consumer.         this.subscription = null.     }     if (consumer != null) {         consumer.onError(throwable).     } }
false;public;0;14;;@Override public void onComplete() {     LOG.info("Reactive stream '{}' completed", name).     ReactiveStreamsConsumer consumer.     synchronized (this) {         consumer = this.consumer.         this.subscription = null.     }     if (consumer != null) {         consumer.onComplete().     } }
false;public;0;11;;@Override public void close() throws IOException {     Subscription subscription.     synchronized (this) {         subscription = this.subscription.     }     if (subscription != null) {         subscription.cancel().     } }
false;public;0;3;;public long getRequested() {     return requested. }
false;public;0;3;;public long getInflightCount() {     return inflightCount. }
