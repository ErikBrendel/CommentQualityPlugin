commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;public;0;4;;@Override public Producer createProducer() throws Exception {     return new ReactiveStreamsProducer(this, stream, getReactiveStreamsService()). }
false;public;1;4;;@Override public Consumer createConsumer(Processor processor) throws Exception {     return new ReactiveStreamsConsumer(this, processor, getReactiveStreamsService()). }
false;public;0;4;;@ManagedAttribute(description = "Name of the stream channel used by the endpoint to exchange messages") public String getStream() {     return stream. }
true;public;1;3;/**  * Name of the stream channel used by the endpoint to exchange messages.  */ ;/**  * Name of the stream channel used by the endpoint to exchange messages.  */ public void setStream(String stream) {     this.stream = stream. }
false;public;0;4;;@ManagedAttribute(description = "Maximum number of exchanges concurrently being processed by Camel") public Integer getMaxInflightExchanges() {     return maxInflightExchanges. }
true;public;1;3;/**  * Maximum number of exchanges concurrently being processed by Camel.  * This parameter controls backpressure on the stream.  * Setting a non-positive value will disable backpressure.  */ ;/**  * Maximum number of exchanges concurrently being processed by Camel.  * This parameter controls backpressure on the stream.  * Setting a non-positive value will disable backpressure.  */ public void setMaxInflightExchanges(Integer maxInflightExchanges) {     this.maxInflightExchanges = maxInflightExchanges. }
false;public;0;3;;public int getConcurrentConsumers() {     return concurrentConsumers. }
true;public;1;4;/**  * Number of threads used to process exchanges in the Camel route.  */ ;/**  * Number of threads used to process exchanges in the Camel route.  */ @ManagedAttribute(description = "Number of threads used to process exchanges in the Camel route") public void setConcurrentConsumers(int concurrentConsumers) {     this.concurrentConsumers = concurrentConsumers. }
false;public;0;3;;public ReactiveStreamsBackpressureStrategy getBackpressureStrategy() {     return backpressureStrategy. }
true;public;1;3;/**  * The backpressure strategy to use when pushing events to a slow subscriber.  */ ;/**  * The backpressure strategy to use when pushing events to a slow subscriber.  */ public void setBackpressureStrategy(ReactiveStreamsBackpressureStrategy backpressureStrategy) {     this.backpressureStrategy = backpressureStrategy. }
false;public;0;4;;@ManagedAttribute(description = "Determines if onComplete events should be pushed to the Camel route") public boolean isForwardOnComplete() {     return forwardOnComplete. }
true;public;1;3;/**  * Determines if onComplete events should be pushed to the Camel route.  */ ;/**  * Determines if onComplete events should be pushed to the Camel route.  */ public void setForwardOnComplete(boolean forwardOnComplete) {     this.forwardOnComplete = forwardOnComplete. }
false;public;0;4;;@ManagedAttribute(description = "Determines if onError events should be pushed to the Camel route") public boolean isForwardOnError() {     return forwardOnError. }
true;public;1;3;/**  * Determines if onError events should be pushed to the Camel route.  * Exceptions will be set as message body.  */ ;/**  * Determines if onError events should be pushed to the Camel route.  * Exceptions will be set as message body.  */ public void setForwardOnError(boolean forwardOnError) {     this.forwardOnError = forwardOnError. }
false;public;0;4;;@ManagedAttribute(description = "The percentage of maxInflightExchanges below which new items can be requested to the source subscription") public double getExchangesRefillLowWatermark() {     return exchangesRefillLowWatermark. }
true;public;1;3;/**  * Set the low watermark of requested exchanges to the active subscription as percentage of the maxInflightExchanges.  * When the number of pending items from the upstream source is lower than the watermark, new items can be requested to the subscription.  * If set to 0, the subscriber will request items in batches of maxInflightExchanges, only after all items of the previous batch have been processed.  * If set to 1, the subscriber can request a new item each time an exchange is processed (chatty).  * Any intermediate value can be used.  */ ;/**  * Set the low watermark of requested exchanges to the active subscription as percentage of the maxInflightExchanges.  * When the number of pending items from the upstream source is lower than the watermark, new items can be requested to the subscription.  * If set to 0, the subscriber will request items in batches of maxInflightExchanges, only after all items of the previous batch have been processed.  * If set to 1, the subscriber can request a new item each time an exchange is processed (chatty).  * Any intermediate value can be used.  */ public void setExchangesRefillLowWatermark(double exchangesRefillLowWatermark) {     this.exchangesRefillLowWatermark = exchangesRefillLowWatermark. }
false;;0;3;;CamelReactiveStreamsService getReactiveStreamsService() {     return ((ReactiveStreamsComponent) getComponent()).getReactiveStreamsService(). }
