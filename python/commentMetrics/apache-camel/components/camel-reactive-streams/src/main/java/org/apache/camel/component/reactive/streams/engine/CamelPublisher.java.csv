commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public void subscribe(Subscriber<? super Exchange> subscriber) {     Objects.requireNonNull(subscriber, "subscriber must not be null").     CamelSubscription sub = new CamelSubscription(UUID.randomUUID().toString(), workerPool, this, name, this.backpressureStrategy, subscriber).     this.subscriptions.add(sub).     subscriber.onSubscribe(sub). }
false;public;1;3;;public void unsubscribe(CamelSubscription subscription) {     subscriptions.remove(subscription). }
false;public;1;35;;public void publish(Exchange data) {     // freeze the subscriptions     List<CamelSubscription> subs = new LinkedList<>(subscriptions).     DispatchCallback<Exchange> originalCallback = ReactiveStreamsHelper.getCallback(data).     DispatchCallback<Exchange> callback = originalCallback.     if (originalCallback != null && subs.size() > 0) {         // When multiple subscribers have an active subscription,         // we acknowledge the exchange once it has been delivered to every         // subscriber (or their subscription is cancelled)         AtomicInteger counter = new AtomicInteger(subs.size()).         // Use just the first exception in the callback when multiple exceptions are thrown         AtomicReference<Throwable> thrown = new AtomicReference<>(null).         callback = ReactiveStreamsHelper.attachCallback(data, (exchange, error) -> {             thrown.compareAndSet(null, error).             if (counter.decrementAndGet() == 0) {                 originalCallback.processed(exchange, thrown.get()).             }         }).     }     if (subs.size() > 0) {         if (LOG.isDebugEnabled()) {             LOG.debug("Exchange published to {} subscriptions for the stream {}: {}", subs.size(), name, data).         }         // at least one subscriber         for (CamelSubscription sub : subs) {             sub.publish(data).         }     } else if (callback != null) {         callback.processed(data, new IllegalStateException("The stream has no active subscriptions")).     } }
false;public;1;16;;public void attachProducer(ReactiveStreamsProducer producer) {     Objects.requireNonNull(producer, "producer cannot be null, use the detach method").     if (this.producer != null) {         throw new IllegalStateException("A producer is already attached to the stream '" + name + "'").     }     this.producer = producer.     // Apply endpoint options if available     ReactiveStreamsEndpoint endpoint = producer.getEndpoint().     if (endpoint.getBackpressureStrategy() != null) {         this.backpressureStrategy = endpoint.getBackpressureStrategy().         for (CamelSubscription sub : this.subscriptions) {             sub.setBackpressureStrategy(endpoint.getBackpressureStrategy()).         }     } }
false;public;0;3;;public void detachProducer() {     this.producer = null. }
false;public;0;7;;@Override public void close() throws Exception {     for (CamelSubscription sub : subscriptions) {         sub.signalCompletion().     }     subscriptions.clear(). }
false;public;0;3;;public List<CamelSubscription> getSubscriptions() {     return subscriptions. }
