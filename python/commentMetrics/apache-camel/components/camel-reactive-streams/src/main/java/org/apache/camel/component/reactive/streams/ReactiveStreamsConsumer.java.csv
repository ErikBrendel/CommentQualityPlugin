commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;11;;@Override protected void doStart() throws Exception {     super.doStart().     int poolSize = endpoint.getConcurrentConsumers().     if (executor == null) {         executor = getEndpoint().getCamelContext().getExecutorServiceManager().newFixedThreadPool(this, getEndpoint().getEndpointUri(), poolSize).     }     this.service.attachCamelConsumer(endpoint.getStream(), this). }
false;protected;0;10;;@Override protected void doStop() throws Exception {     super.doStop().     this.service.detachCamelConsumer(endpoint.getStream()).     if (executor != null) {         endpoint.getCamelContext().getExecutorServiceManager().shutdownNow(executor).         executor = null.     } }
false;public;2;4;;public boolean process(Exchange exchange, AsyncCallback callback) {     exchange.getIn().setHeader(ReactiveStreamsConstants.REACTIVE_STREAMS_EVENT_TYPE, "onNext").     return doSend(exchange, callback). }
false;public;0;9;;public void onComplete() {     if (endpoint.isForwardOnComplete()) {         Exchange exchange = endpoint.createExchange().         exchange.getIn().setHeader(ReactiveStreamsConstants.REACTIVE_STREAMS_EVENT_TYPE, "onComplete").         doSend(exchange, done -> {         }).     } }
false;public;1;10;;public void onError(Throwable error) {     if (endpoint.isForwardOnError()) {         Exchange exchange = endpoint.createExchange().         exchange.getIn().setHeader(ReactiveStreamsConstants.REACTIVE_STREAMS_EVENT_TYPE, "onError").         exchange.getIn().setBody(error).         doSend(exchange, done -> {         }).     } }
false;private;2;19;;private boolean doSend(Exchange exchange, AsyncCallback callback) {     ExecutorService executorService = this.executor.     if (executorService != null && this.isRunAllowed()) {         executorService.execute(() -> this.getAsyncProcessor().process(exchange, doneSync -> {             if (exchange.getException() != null) {                 getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException()).             }             callback.done(doneSync).         })).         return false.     } else {         log.warn("Consumer not ready to process exchanges. The exchange {} will be discarded", exchange).         callback.done(true).         return true.     } }
false;public;0;4;;@Override public ReactiveStreamsEndpoint getEndpoint() {     return endpoint. }
