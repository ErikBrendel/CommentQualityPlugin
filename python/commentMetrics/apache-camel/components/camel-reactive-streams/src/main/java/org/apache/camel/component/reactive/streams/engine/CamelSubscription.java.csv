commented;modifiers;parameterAmount;loc;comment;code
false;public;1;19;;@Override public void request(long l) {     LOG.debug("Requested {} events from subscriber", l).     if (l <= 0) {         // wrong argument         mutex.lock().         terminated = true.         mutex.unlock().         publisher.unsubscribe(this).         subscriber.onError(new IllegalArgumentException("3.9")).     } else {         mutex.lock().         requested += l.         mutex.unlock().         checkAndFlush().     } }
false;protected;0;35;;protected void checkAndFlush() {     mutex.lock().     boolean shouldFlush = !terminated && !sending && requested > 0 && buffer.size() > 0.     if (shouldFlush) {         sending = true.     }     mutex.unlock().     if (shouldFlush) {         workerPool.execute(() -> {             this.flush().             mutex.lock().             sending = false.             mutex.unlock().             // try again to flush             checkAndFlush().         }).     } else {         mutex.lock().         boolean shouldComplete = terminating && !terminated.         if (shouldComplete) {             terminated = true.         }         mutex.unlock().         if (shouldComplete) {             this.publisher.unsubscribe(this).             this.subscriber.onComplete().             discardBuffer(this.buffer).         }     } }
false;protected;0;39;;protected void flush() {     LinkedList<Exchange> sendingQueue = null.     try {         mutex.lock().         if (this.terminated) {             return.         }         int amount = (int) Math.min(requested, buffer.size()).         if (amount > 0) {             this.requested -= amount.             sendingQueue = new LinkedList<>().             while (amount > 0) {                 sendingQueue.add(buffer.removeFirst()).                 amount--.             }         }     } finally {         mutex.unlock().     }     if (sendingQueue != null) {         LOG.debug("Sending {} events to the subscriber", sendingQueue.size()).         for (Exchange data : sendingQueue) {             // TODO what if the subscriber throws an exception?             this.subscriber.onNext(data).             mutex.lock().             boolean shouldStop = this.terminated.             mutex.unlock().             if (shouldStop) {                 break.             }         }     } }
false;public;0;7;;public void signalCompletion() throws Exception {     mutex.lock().     terminating = true.     mutex.unlock().     checkAndFlush(). }
false;public;0;12;;@Override public void cancel() {     publisher.unsubscribe(this).     mutex.lock().     this.terminated = true.     List<Exchange> bufferCopy = new LinkedList<>(buffer).     this.buffer.clear().     mutex.unlock().     discardBuffer(bufferCopy). }
false;protected;1;8;;protected void discardBuffer(List<Exchange> remaining) {     for (Exchange data : remaining) {         ReactiveStreamsHelper.invokeDispatchCallback(data, new IllegalStateException("Cannot process the exchange " + data + ": subscription cancelled")).     } }
false;public;1;32;;public void publish(Exchange message) {     Map<Exchange, String> discardedMessages = null.     try {         mutex.lock().         if (!this.terminating && !this.terminated) {             Collection<Exchange> discarded = this.backpressureStrategy.update(buffer, message).             if (!discarded.isEmpty()) {                 discardedMessages = new HashMap<>().                 for (Exchange ex : discarded) {                     discardedMessages.put(ex, "Exchange " + ex + " discarded by backpressure strategy " + this.backpressureStrategy).                 }             }         } else {             // acknowledge             discardedMessages = Collections.singletonMap(message, "Exchange " + message + " discarded: subscription closed").         }     } finally {         mutex.unlock().     }     // discarding outside of mutex scope     if (discardedMessages != null) {         for (Exchange exchange : discardedMessages.keySet()) {             ReactiveStreamsHelper.invokeDispatchCallback(exchange, new ReactiveStreamsDiscardedException("Discarded by backpressure strategy", exchange, streamName)).         }     }     checkAndFlush(). }
false;public;1;5;;public void setBackpressureStrategy(ReactiveStreamsBackpressureStrategy backpressureStrategy) {     mutex.lock().     this.backpressureStrategy = backpressureStrategy.     mutex.unlock(). }
false;public;0;3;;public long getBufferSize() {     return buffer.size(). }
false;public;0;3;;public ReactiveStreamsBackpressureStrategy getBackpressureStrategy() {     return backpressureStrategy. }
false;public;0;3;;public String getId() {     return id. }
