commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public GrpcConfiguration getConfiguration() {     return configuration. }
false;protected;0;10;;@Override protected void doStart() throws Exception {     super.doStart().     if (server == null) {         log.info("Starting the gRPC server").         initializeServer().         server.start().         log.info("gRPC server started and listening on port: {}", server.getPort()).     } }
false;protected;0;9;;@Override protected void doStop() throws Exception {     if (server != null) {         log.debug("Terminating gRPC server").         server.shutdown().shutdownNow().         server = null.     }     super.doStop(). }
false;protected;0;53;;protected void initializeServer() throws Exception {     NettyServerBuilder serverBuilder = null.     BindableService bindableService = null.     ProxyFactory serviceProxy = new ProxyFactory().     ServerInterceptor headerInterceptor = new GrpcHeaderInterceptor().     MethodHandler methodHandler = new GrpcMethodHandler(endpoint, this).     serviceProxy.setSuperclass(GrpcUtils.constructGrpcImplBaseClass(endpoint.getServicePackage(), endpoint.getServiceName(), endpoint.getCamelContext())).     try {         bindableService = (BindableService) serviceProxy.create(new Class<?>[0], new Object[0], methodHandler).     } catch (NoSuchMethodException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException e) {         throw new IllegalArgumentException("Unable to create bindable proxy service for " + configuration.getService()).     }     if (!ObjectHelper.isEmpty(configuration.getHost()) && !ObjectHelper.isEmpty(configuration.getPort())) {         log.debug("Building gRPC server on {}:{}", configuration.getHost(), configuration.getPort()).         serverBuilder = NettyServerBuilder.forAddress(new InetSocketAddress(configuration.getHost(), configuration.getPort())).     } else {         throw new IllegalArgumentException("No server start properties (host, port) specified").     }     if (configuration.getNegotiationType() == NegotiationType.TLS) {         ObjectHelper.notNull(configuration.getKeyCertChainResource(), "keyCertChainResource").         ObjectHelper.notNull(configuration.getKeyResource(), "keyResource").         ClassResolver classResolver = endpoint.getCamelContext().getClassResolver().         SslContextBuilder sslContextBuilder = SslContextBuilder.forServer(ResourceHelper.resolveResourceAsInputStream(classResolver, configuration.getKeyCertChainResource()), ResourceHelper.resolveResourceAsInputStream(classResolver, configuration.getKeyResource()), configuration.getKeyPassword()).clientAuth(ClientAuth.REQUIRE).sslProvider(SslProvider.OPENSSL).         if (ObjectHelper.isNotEmpty(configuration.getTrustCertCollectionResource())) {             sslContextBuilder = sslContextBuilder.trustManager(ResourceHelper.resolveResourceAsInputStream(classResolver, configuration.getTrustCertCollectionResource())).         }         serverBuilder = serverBuilder.sslContext(GrpcSslContexts.configure(sslContextBuilder).build()).     }     if (configuration.getAuthenticationType() == GrpcAuthType.JWT) {         ObjectHelper.notNull(configuration.getJwtSecret(), "jwtSecret").         serverBuilder = serverBuilder.intercept(new JwtServerInterceptor(configuration.getJwtAlgorithm(), configuration.getJwtSecret(), configuration.getJwtIssuer(), configuration.getJwtSubject())).     }     server = serverBuilder.addService(ServerInterceptors.intercept(bindableService, headerInterceptor)).maxMessageSize(configuration.getMaxMessageSize()).flowControlWindow(configuration.getFlowControlWindow()).maxConcurrentCallsPerConnection(configuration.getMaxConcurrentCallsPerConnection()).build(). }
false;public;2;4;;public boolean process(Exchange exchange, AsyncCallback callback) {     exchange.getIn().setHeader(GrpcConstants.GRPC_EVENT_TYPE_HEADER, GrpcConstants.GRPC_EVENT_TYPE_ON_NEXT).     return doSend(exchange, callback). }
false;public;1;7;;public void onCompleted(Exchange exchange) {     if (configuration.isForwardOnCompleted()) {         exchange.getIn().setHeader(GrpcConstants.GRPC_EVENT_TYPE_HEADER, GrpcConstants.GRPC_EVENT_TYPE_ON_COMPLETED).         doSend(exchange, done -> {         }).     } }
false;public;2;9;;public void onError(Exchange exchange, Throwable error) {     if (configuration.isForwardOnError()) {         exchange.getIn().setHeader(GrpcConstants.GRPC_EVENT_TYPE_HEADER, GrpcConstants.GRPC_EVENT_TYPE_ON_ERROR).         exchange.getIn().setBody(error).         doSend(exchange, done -> {         }).     } }
false;private;2;15;;private boolean doSend(Exchange exchange, AsyncCallback callback) {     if (this.isRunAllowed()) {         this.getAsyncProcessor().process(exchange, doneSync -> {             if (exchange.getException() != null) {                 getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException()).             }             callback.done(doneSync).         }).         return false.     } else {         log.warn("Consumer not ready to process exchanges. The exchange {} will be discarded", exchange).         callback.done(true).         return true.     } }
