commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;3;;public static String extractServiceName(String service) {     return service.contains(".") ? service.substring(service.lastIndexOf(".") + 1) : service. }
false;public,static;1;3;;public static String extractServicePackage(String service) {     return service.contains(".") ? service.substring(0, service.lastIndexOf(".")) : "". }
false;public,static;5;3;;public static Object constructGrpcAsyncStub(String packageName, String serviceName, Channel channel, final CallCredentials creds, final CamelContext context) {     return constructGrpcStubClass(packageName, serviceName, GrpcConstants.GRPC_SERVICE_ASYNC_STUB_METHOD, channel, creds, context). }
false;public,static;5;3;;public static Object constructGrpcBlockingStub(String packageName, String serviceName, Channel channel, final CallCredentials creds, final CamelContext context) {     return constructGrpcStubClass(packageName, serviceName, GrpcConstants.GRPC_SERVICE_SYNC_STUB_METHOD, channel, creds, context). }
true;private,static;6;23;/**  * Get gRPC stub class instance depends on the invocation style  * newBlockingStub - for sync style  * newStub - for async style  * newFutureStub - for ListenableFuture-style (not implemented yet)  */ ;/**  * Get gRPC stub class instance depends on the invocation style  * newBlockingStub - for sync style  * newStub - for async style  * newFutureStub - for ListenableFuture-style (not implemented yet)  */ @SuppressWarnings({ "rawtypes" }) private static Object constructGrpcStubClass(String packageName, String serviceName, String stubMethod, Channel channel, final CallCredentials creds, final CamelContext context) {     Class[] paramChannel = { Channel.class }.     Object grpcStub = null.     String serviceClassName = constructFullClassName(packageName, serviceName + GrpcConstants.GRPC_SERVICE_CLASS_POSTFIX).     try {         Class grpcServiceClass = context.getClassResolver().resolveMandatoryClass(serviceClassName).         Method grpcMethod = ReflectionHelper.findMethod(grpcServiceClass, stubMethod, paramChannel).         if (grpcMethod == null) {             throw new IllegalArgumentException("gRPC service method not found: " + serviceClassName + "." + stubMethod).         }         grpcStub = ObjectHelper.invokeMethod(grpcMethod, grpcServiceClass, channel).         if (creds != null) {             return addClientCallCredentials(grpcStub, creds).         }     } catch (ClassNotFoundException e) {         throw new IllegalArgumentException("gRPC service class not found: " + serviceClassName).     }     return grpcStub. }
false;public,static;2;10;;@SuppressWarnings("rawtypes") public static Object addClientCallCredentials(Object grpcStub, final CallCredentials creds) {     Class[] paramCallCreds = { CallCredentials.class }.     Object grpcStubWithCreds = null.     Method callCredsMethod = ReflectionHelper.findMethod(grpcStub.getClass(), GrpcConstants.GRPC_SERVICE_STUB_CALL_CREDS_METHOD, paramCallCreds).     grpcStubWithCreds = ObjectHelper.invokeMethod(callCredsMethod, grpcStub, creds).     return grpcStubWithCreds. }
false;public,static;3;13;;@SuppressWarnings("rawtypes") public static Class constructGrpcImplBaseClass(String packageName, String serviceName, final CamelContext context) {     Class grpcServerImpl.     String serverBaseImpl = constructFullClassName(packageName, serviceName + GrpcConstants.GRPC_SERVICE_CLASS_POSTFIX + "$" + serviceName + GrpcConstants.GRPC_SERVER_IMPL_POSTFIX).     try {         grpcServerImpl = context.getClassResolver().resolveMandatoryClass(serverBaseImpl).     } catch (ClassNotFoundException e) {         throw new IllegalArgumentException("gRPC server base class not found: " + serverBaseImpl).     }     return grpcServerImpl. }
false;public,static;4;23;;@SuppressWarnings({ "rawtypes", "unchecked" }) public static void invokeAsyncMethod(Object asyncStubClass, String invokeMethod, Object request, StreamObserver responseObserver) {     Class[] paramMethod = null.     Method method = ReflectionHelper.findMethod(asyncStubClass.getClass(), invokeMethod, paramMethod).     if (method == null) {         throw new IllegalArgumentException("gRPC service method not found: " + asyncStubClass.getClass().getName() + "." + invokeMethod).     }     if (method.getReturnType().equals(StreamObserver.class)) {         StreamObserver<Object> requestObserver = (StreamObserver<Object>) ObjectHelper.invokeMethod(method, asyncStubClass, responseObserver).         if (request instanceof List) {             List<Object> requestList = (List<Object>) request.             requestList.forEach((requestItem) -> {                 requestObserver.onNext(requestItem).             }).         } else {             requestObserver.onNext(request).         }         requestObserver.onCompleted().     } else {         ObjectHelper.invokeMethod(method, asyncStubClass, request, responseObserver).     } }
false;public,static;3;14;;@SuppressWarnings({ "rawtypes", "unchecked" }) public static StreamObserver<Object> invokeAsyncMethodStreaming(Object asyncStubClass, String invokeMethod, StreamObserver<?> responseObserver) {     Class[] paramMethod = null.     Method method = ReflectionHelper.findMethod(asyncStubClass.getClass(), invokeMethod, paramMethod).     if (method == null) {         throw new IllegalArgumentException("gRPC service method not found: " + asyncStubClass.getClass().getName() + "." + invokeMethod).     }     if (!StreamObserver.class.isAssignableFrom(method.getReturnType())) {         throw new IllegalArgumentException("gRPC service method does not declare an input of type stream (cannot be used in streaming mode): " + asyncStubClass.getClass().getName() + "." + invokeMethod).     }     return (StreamObserver<Object>) ObjectHelper.invokeMethod(method, asyncStubClass, responseObserver). }
false;public,static;3;19;;@SuppressWarnings({ "rawtypes", "unchecked" }) public static Object invokeSyncMethod(Object blockingStubClass, String invokeMethod, Object request) {     Class[] paramMethod = null.     Method method = ReflectionHelper.findMethod(blockingStubClass.getClass(), invokeMethod, paramMethod).     if (method == null) {         throw new IllegalArgumentException("gRPC service method not found: " + blockingStubClass.getClass().getName() + "." + invokeMethod).     }     if (method.getReturnType().equals(Iterator.class)) {         Iterator<Object> responseObjects = (Iterator<Object>) ObjectHelper.invokeMethod(method, blockingStubClass, request).         List<Object> objectList = new ArrayList<>().         while (responseObjects.hasNext()) {             objectList.add(responseObjects.next()).         }         return objectList.     } else {         return ObjectHelper.invokeMethod(method, blockingStubClass, request).     } }
true;public,static;1;14;/**  * Migrated MixedLower function from the gRPC converting plugin source code  * (https://github.com/grpc/grpc-java/blob/master/compiler/src/java_plugin/cpp/java_generator.cpp)  *  * - decapitalize the first letter  * - remove embedded underscores & capitalize the following letter  */ ;/**  * Migrated MixedLower function from the gRPC converting plugin source code  * (https://github.com/grpc/grpc-java/blob/master/compiler/src/java_plugin/cpp/java_generator.cpp)  *  * - decapitalize the first letter  * - remove embedded underscores & capitalize the following letter  */ public static String convertMethod2CamelCase(final String method) {     StringBuilder sb = new StringBuilder(method.length()).     sb.append(method.substring(0, 1).toLowerCase()).     Boolean afterUnderscore = false.     for (int i = 1. i < method.length(). i++) {         if (method.charAt(i) == '_') {             afterUnderscore = true.         } else {             sb.append(afterUnderscore ? Character.toUpperCase(method.charAt(i)) : method.charAt(i)).             afterUnderscore = false.         }     }     return sb.toString(). }
false;private,static;2;7;;private static String constructFullClassName(String packageName, String className) {     if (org.apache.camel.util.ObjectHelper.isEmpty(packageName)) {         return className.     } else {         return packageName + "." + className.     } }
