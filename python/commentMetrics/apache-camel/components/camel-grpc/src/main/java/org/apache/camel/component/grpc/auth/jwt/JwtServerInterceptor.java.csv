commented;modifiers;parameterAmount;loc;comment;code
false;public;3;23;;@Override @SuppressWarnings("unchecked") public <ReqT, RespT> Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call, Metadata metadata, ServerCallHandler<ReqT, RespT> serverCallHandler) {     String jwtToken = metadata.get(GrpcConstants.GRPC_JWT_METADATA_KEY).     if (jwtToken == null) {         call.close(Status.UNAUTHENTICATED.withDescription("JWT Token is missing from metadata"), metadata).         return NOOP_LISTENER.     }     Context ctx.     try {         DecodedJWT verified = verifier.verify(jwtToken).         ctx = Context.current().withValue(GrpcConstants.GRPC_JWT_USER_ID_CTX_KEY, verified.getSubject() == null ? "anonymous" : verified.getSubject()).withValue(GrpcConstants.GRPC_JWT_CTX_KEY, jwtToken).     } catch (Exception e) {         LOG.debug("JWT token verification failed - Unauthenticated").         call.close(Status.UNAUTHENTICATED.withDescription(e.getMessage()).withCause(e), metadata).         return NOOP_LISTENER.     }     return Contexts.interceptCall(ctx, call, metadata, serverCallHandler). }
false;public,static;4;10;;public static JWTVerifier prepareJwtVerifier(JwtAlgorithm algorithmName, String secret, String issuer, String subject) {     try {         Algorithm algorithm = JwtHelper.selectAlgorithm(algorithmName, secret).         return JWT.require(algorithm).withIssuer(issuer).withSubject(subject).build().     } catch (JWTCreationException e) {         throw new IllegalArgumentException("Unable to create JWT verifier", e).     } catch (UnsupportedEncodingException e) {         throw new IllegalArgumentException("UTF-8 encoding not supported during JWT verifier creation", e).     } }
