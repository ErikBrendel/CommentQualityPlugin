commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Producer createProducer() throws Exception {     return new GuavaEventBusProducer(this, eventBus). }
false;public;1;6;;@Override public Consumer createConsumer(Processor processor) throws Exception {     GuavaEventBusConsumer answer = new GuavaEventBusConsumer(this, processor, eventBus, eventClass, listenerInterface).     configureConsumer(answer).     return answer. }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;public;0;4;;@Override public boolean isMultipleConsumersSupported() {     return true. }
false;public;1;5;;public Exchange createExchange(Object event) {     Exchange exchange = createExchange().     exchange.getIn().setBody(event).     return exchange. }
false;public;0;3;;public String getEventBusRef() {     return eventBusRef. }
true;public;1;3;/**  * To lookup the Guava EventBus from the registry with the given name  */ ;/**  * To lookup the Guava EventBus from the registry with the given name  */ public void setEventBusRef(String eventBusRef) {     this.eventBusRef = eventBusRef. }
false;public;0;3;;public EventBus getEventBus() {     return eventBus. }
true;public;1;3;/**  * To use the given Guava EventBus instance  */ ;/**  * To use the given Guava EventBus instance  */ public void setEventBus(EventBus eventBus) {     this.eventBus = eventBus. }
false;public;0;3;;public Class<?> getEventClass() {     return eventClass. }
true;public;1;3;/**  * If used on the consumer side of the route, will filter events received from the EventBus to the instances of  * the class and superclasses of eventClass. Null value of this option is equal to setting it to the java.lang.Object  * i.e. the consumer will capture all messages incoming to the event bus. This option cannot be used together  * with listenerInterface option.  */ ;/**  * If used on the consumer side of the route, will filter events received from the EventBus to the instances of  * the class and superclasses of eventClass. Null value of this option is equal to setting it to the java.lang.Object  * i.e. the consumer will capture all messages incoming to the event bus. This option cannot be used together  * with listenerInterface option.  */ public void setEventClass(Class<?> eventClass) {     this.eventClass = eventClass. }
false;public;0;3;;public Class<?> getListenerInterface() {     return listenerInterface. }
true;public;1;3;/**  * The interface with method(s) marked with the @Subscribe annotation.  * Dynamic proxy will be created over the interface so it could be registered as the EventBus listener.  * Particularly useful when creating multi-event listeners and for handling DeadEvent properly. This option cannot be used together with eventClass option.  */ ;/**  * The interface with method(s) marked with the @Subscribe annotation.  * Dynamic proxy will be created over the interface so it could be registered as the EventBus listener.  * Particularly useful when creating multi-event listeners and for handling DeadEvent properly. This option cannot be used together with eventClass option.  */ public void setListenerInterface(Class<?> listenerInterface) {     this.listenerInterface = listenerInterface. }
false;protected;0;8;;@Override protected void doStart() throws Exception {     super.doStart().     if (eventBusRef != null && eventBus == null) {         eventBus = CamelContextHelper.mandatoryLookup(getCamelContext(), eventBusRef, EventBus.class).     } }
