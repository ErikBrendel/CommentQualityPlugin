# id;timestamp;commentText;codeText;commentWords;codeWords
BindyCsvFactory -> private void initAnnotedFields() throws Exception;1233214146;Find fields annoted in each class of the model__@throws Exception;private void initAnnotedFields() throws Exception {__        for (Class<?> cl : models) {__            for (Field field : cl.getDeclaredFields()) {__                DataField dataField = field.getAnnotation(DataField.class)__                if (dataField != null) {_                    mapDataField.put(dataField.pos(), dataField)__                    mapAnnotedField.put(dataField.pos(), field)__                }__                Link linkField = field.getAnnotation(Link.class)___                if (linkField != null) {_                    mapAnnotedLinkField.put(cl.getName(), field)__                }__            }__        }__    };find,fields,annoted,in,each,class,of,the,model,throws,exception;private,void,init,annoted,fields,throws,exception,for,class,cl,models,for,field,field,cl,get,declared,fields,data,field,data,field,field,get,annotation,data,field,class,if,data,field,null,map,data,field,put,data,field,pos,data,field,map,annoted,field,put,data,field,pos,field,link,link,field,field,get,annotation,link,class,if,link,field,null,map,annoted,link,field,put,cl,get,name,field
BindyCsvFactory -> private void initAnnotedFields() throws Exception;1233250656;Find fields annoted in each class of the model;private void initAnnotedFields() throws Exception {__        for (Class<?> cl : models) {__            for (Field field : cl.getDeclaredFields()) {_                DataField dataField = field.getAnnotation(DataField.class)__                if (dataField != null) {_                    mapDataField.put(dataField.pos(), dataField)__                    mapAnnotedField.put(dataField.pos(), field)__                }__                Link linkField = field.getAnnotation(Link.class)___                if (linkField != null) {_                    mapAnnotedLinkField.put(cl.getName(), field)__                }_            }__        }_    };find,fields,annoted,in,each,class,of,the,model;private,void,init,annoted,fields,throws,exception,for,class,cl,models,for,field,field,cl,get,declared,fields,data,field,data,field,field,get,annotation,data,field,class,if,data,field,null,map,data,field,put,data,field,pos,data,field,map,annoted,field,put,data,field,pos,field,link,link,field,field,get,annotation,link,class,if,link,field,null,map,annoted,link,field,put,cl,get,name,field
BindyCsvFactory -> public boolean getSkipFirstLine();1233250656;Get the parameter skipFirstLine;public boolean getSkipFirstLine() {_        return skipFirstLine__    };get,the,parameter,skip,first,line;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1235652242;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1236098343;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1236835446;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1236912265;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1245936806;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_		return skipFirstLine__	};find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1246045355;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1246454824;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1246526096;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1246589739;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1247659740;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1247731460;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1247738177;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1249980324;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1250061962;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1250156684;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1252503390;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1252575745;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1252663206;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1252844150;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1254476721;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1255352752;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1255482326;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1255612798;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1258732346;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1258736086;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1260808207;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1271143787;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1276128415;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1276357650;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1276858355;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1290574380;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1293121457;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1296495624;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1297377495;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1304355123;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1307685726;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1311784042;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1311838731;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1313481945;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1319272780;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1321110017;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1325779288;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1326392736;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1329896980;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1330973608;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1335090271;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1335788887;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1338733510;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1355719205;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1355739468;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1357140814;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1364939806;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1365150732;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1376549254;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1382001237;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1392400400;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1405374721;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1436627349;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1436627987;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1438938304;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1438938346;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1458660774;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1463827036;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1467414446;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1489149464;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1489149465;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1489495870;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1492674464;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1506410459;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1513330638;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1517474119;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1517474119;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1518764028;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1521797596;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1523384632;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1523968787;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1536517284;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1536687142;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1537943284;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1537943284;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean getSkipFirstLine();1540108163;Find the separator used to delimit the CSV fields;public boolean getSkipFirstLine() {_        return skipFirstLine__    };find,the,separator,used,to,delimit,the,csv,fields;public,boolean,get,skip,first,line,return,skip,first,line
BindyCsvFactory -> public boolean isMessageOrdered();1245936806;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_		return messageOrdered__	};flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1246045355;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1246454824;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1246526096;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1246589739;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1247659740;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1247731460;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1247738177;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1249980324;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1250061962;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1250156684;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1252503390;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1252575745;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1252663206;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1252844150;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1254476721;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1255352752;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1255482326;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1255612798;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1258732346;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1258736086;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1260808207;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1271143787;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1276128415;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1276357650;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1276858355;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1290574380;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1293121457;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1296495624;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1297377495;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1304355123;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1307685726;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1311784042;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1311838731;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1313481945;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1319272780;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1321110017;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1325779288;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1326392736;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1329896980;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1330973608;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1335090271;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1335788887;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1338733510;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1355719205;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1355739468;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1357140814;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1364939806;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1365150732;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1376549254;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1382001237;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1392400400;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1405374721;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1436627349;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1436627987;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1438938304;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1438938346;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1458660774;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1463827036;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1467414446;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1489149464;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1489149465;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1489495870;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1492674464;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1506410459;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1513330638;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1517474119;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1517474119;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1518764028;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1521797596;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1523384632;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1523968787;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1536517284;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1536687142;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1537943284;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1537943284;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean isMessageOrdered();1540108163;Flag indicating if the message must be ordered__@return boolean;public boolean isMessageOrdered() {_        return messageOrdered__    };flag,indicating,if,the,message,must,be,ordered,return,boolean;public,boolean,is,message,ordered,return,message,ordered
BindyCsvFactory -> public boolean getAutospanLine();1382001237;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1392400400;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1405374721;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1436627349;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1436627987;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1438938304;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1438938346;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1458660774;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1463827036;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1467414446;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1489149464;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1489149465;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1489495870;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1492674464;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1506410459;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1513330638;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1517474119;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1517474119;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1518764028;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1521797596;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1523384632;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1523968787;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1536517284;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1536687142;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1537943284;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1537943284;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> public boolean getAutospanLine();1540108163;If last record is to span the rest of the line;public boolean getAutospanLine() {_        return autospanLine__    };if,last,record,is,to,span,the,rest,of,the,line;public,boolean,get,autospan,line,return,autospan,line
BindyCsvFactory -> private void generateCsvPositionMap(Class clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1319272780;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                ArrayList list = (ArrayList)field.get(obj)__                if (list != null) {__                    Iterator it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,array,list,list,array,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1321110017;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                ArrayList list = (ArrayList)field.get(obj)__                if (list != null) {__                    Iterator it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,array,list,list,array,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1325779288;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                ArrayList list = (ArrayList)field.get(obj)__                if (list != null) {__                    Iterator it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,array,list,list,array,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1329896980;Set the default values for the non defined fields._@param The model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                String pattern = dataField.pattern()__                Format<?> format = FormatFactory.getFormat(field.getType(), pattern, getLocale(),_                                                                 dataField.precision())__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,string,pattern,data,field,pattern,format,format,format,factory,get,format,field,get,type,pattern,get,locale,data,field,precision,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1330973608;Set the default values for the non defined fields._@param The model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                String pattern = dataField.pattern()__                Format<?> format = FormatFactory.getFormat(field.getType(), pattern, getLocale(),_                                                                 dataField.precision())__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,string,pattern,data,field,pattern,format,format,format,factory,get,format,field,get,type,pattern,get,locale,data,field,precision,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1335090271;Set the default values for the non defined fields._@param The model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                String pattern = dataField.pattern()__                Format<?> format = FormatFactory.getFormat(field.getType(), pattern, getLocale(),_                                                                 dataField.precision())__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,string,pattern,data,field,pattern,format,format,format,factory,get,format,field,get,type,pattern,get,locale,data,field,precision,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1335788887;Set the default values for the non defined fields._@param The model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                String pattern = dataField.pattern()__                Format<?> format = FormatFactory.getFormat(field.getType(), pattern, getLocale(),_                                                                 dataField.precision())__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,string,pattern,data,field,pattern,format,format,format,factory,get,format,field,get,type,pattern,get,locale,data,field,precision,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1338733510;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                String pattern = dataField.pattern()__                Format<?> format = FormatFactory.getFormat(field.getType(), pattern, getLocale(),_                                                                 dataField.precision())__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,string,pattern,data,field,pattern,format,format,format,factory,get,format,field,get,type,pattern,get,locale,data,field,precision,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1355719205;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                String pattern = dataField.pattern()__                Format<?> format = FormatFactory.getFormat(field.getType(), pattern, getLocale(),_                                                                 dataField.precision())__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,string,pattern,data,field,pattern,format,format,format,factory,get,format,field,get,type,pattern,get,locale,data,field,precision,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1355739468;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                String pattern = dataField.pattern()__                Format<?> format = FormatFactory.getFormat(field.getType(), getLocale(), dataField)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,string,pattern,data,field,pattern,format,format,format,factory,get,format,field,get,type,get,locale,data,field,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1357140814;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                Format<?> format = FormatFactory.getFormat(field.getType(), getLocale(), dataField)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,format,format,format,factory,get,format,field,get,type,get,locale,data,field,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1364939806;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                Format<?> format = FormatFactory.getFormat(field.getType(), getLocale(), dataField)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,format,format,format,factory,get,format,field,get,type,get,locale,data,field,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1365150732;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                Format<?> format = FormatFactory.getFormat(field.getType(), getLocale(), dataField)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,format,format,format,factory,get,format,field,get,type,get,locale,data,field,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1376549254;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                Format<?> format = FormatFactory.getFormat(field.getType(), getLocale(), dataField)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,format,format,format,factory,get,format,field,get,type,get,locale,data,field,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1382001237;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                Format<?> format = FormatFactory.getFormat(field.getType(), getLocale(), dataField)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,format,format,format,factory,get,format,field,get,type,get,locale,data,field,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1392400400;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                Format<?> format = FormatFactory.getFormat(field.getType(), getLocale(), dataField)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,format,format,format,factory,get,format,field,get,type,get,locale,data,field,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1405374721;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                Format<?> format = FormatFactory.getFormat(field.getType(), getLocale(), dataField)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,format,format,format,factory,get,format,field,get,type,get,locale,data,field,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1436627349;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                Format<?> format = FormatFactory.getFormat(field.getType(), getLocale(), dataField)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,format,format,format,factory,get,format,field,get,type,get,locale,data,field,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1436627987;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                Format<?> format = FormatFactory.getFormat(field.getType(), getLocale(), dataField)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,format,format,format,factory,get,format,field,get,type,get,locale,data,field,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1438938304;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                Format<?> format = FormatFactory.getFormat(field.getType(), getLocale(), dataField)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,format,format,format,factory,get,format,field,get,type,get,locale,data,field,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1438938346;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                Format<?> format = FormatFactory.getFormat(field.getType(), getLocale(), dataField)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,format,format,format,factory,get,format,field,get,type,get,locale,data,field,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1458660774;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                Format<?> format = FormatFactory.getFormat(field.getType(), getLocale(), dataField, field.getAnnotation(BindyConverter.class))__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,format,format,format,factory,get,format,field,get,type,get,locale,data,field,field,get,annotation,bindy,converter,class,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1463827036;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1467414446;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1489149464;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1489149465;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1489495870;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1492674464;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1506410459;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1513330638;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1517474119;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1517474119;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1518764028;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1521797596;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1523384632;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1523968787;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1536517284;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1536687142;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1537943284;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1537943284;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,         Exception;1540108163;Set the default values for the non defined fields._@param model the model which has its default fields set._@throws IllegalAccessException if the underlying fields are inaccessible_@throws Exception In case the field cannot be parsed;private void setDefaultValuesForFields(final Map<String, Object> model) throws IllegalAccessException,_        Exception {_        _        for (int i = 1_ i <= dataFields.size()_ i++) {_            Field field = annotatedFields.get(i)__            field.setAccessible(true)__            DataField dataField = dataFields.get(i)__            Object modelField = model.get(field.getDeclaringClass().getName())__            if (field.get(modelField) == null && !dataField.defaultValue().isEmpty()) {_                FormattingOptions formattingOptions = ConverterUtils.convert(dataField,_                        field.getType(),_                        field.getAnnotation(BindyConverter.class),_                        getLocale())__                Format<?> format = formatFactory.getFormat(formattingOptions)__                Object value = format.parse(dataField.defaultValue())__                field.set(modelField, value)__            }_        }_    };set,the,default,values,for,the,non,defined,fields,param,model,the,model,which,has,its,default,fields,set,throws,illegal,access,exception,if,the,underlying,fields,are,inaccessible,throws,exception,in,case,the,field,cannot,be,parsed;private,void,set,default,values,for,fields,final,map,string,object,model,throws,illegal,access,exception,exception,for,int,i,1,i,data,fields,size,i,field,field,annotated,fields,get,i,field,set,accessible,true,data,field,data,field,data,fields,get,i,object,model,field,model,get,field,get,declaring,class,get,name,if,field,get,model,field,null,data,field,default,value,is,empty,formatting,options,formatting,options,converter,utils,convert,data,field,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,format,parse,data,field,default,value,field,set,model,field,value
BindyCsvFactory -> public String generateHeader();1276858355;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annoted,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1290574380;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annoted,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1293121457;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annoted,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1296495624;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annoted,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1297377495;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annoted,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1304355123;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annoted,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1307685726;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annoted,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1311784042;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annoted,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1311838731;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1313481945;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1319272780;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1321110017;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1325779288;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1326392736;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1329896980;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1330973608;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1335090271;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1335788887;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1338733510;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1355719205;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1355739468;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1357140814;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1364939806;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1365150732;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1376549254;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1382001237;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1392400400;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1405374721;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1436627349;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1436627987;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1438938304;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1438938346;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1458660774;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1463827036;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(separator)__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1467414446;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1489149464;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1489149465;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1489495870;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1492674464;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1506410459;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1513330638;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1517474119;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1517474119;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1518764028;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            if (!dataField.columnName().equals("")) {_                builderHeader.append(dataField.columnName())__            } else {_                builderHeader.append(field.getName())__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,if,data,field,column,name,equals,builder,header,append,data,field,column,name,else,builder,header,append,field,get,name,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1521797596;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            final String res__            if (!dataField.columnName().equals("")) {_                res = dataField.columnName()__            } else {_                res = field.getName()__            }__            if (quoting && quote != null) {_                builderHeader.append(quote)__            }_            if (quoting && quote != null && (res.contains("\\" + quote) || res.contains(quote))  && quotingEscaped) {_                builderHeader.append(res.replaceAll("\\" + quote, "\\\\" + quote))__            } else {_                builderHeader.append(res)__            }_            if (quoting && quote != null) {_                builderHeader.append(quote)__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,final,string,res,if,data,field,column,name,equals,res,data,field,column,name,else,res,field,get,name,if,quoting,quote,null,builder,header,append,quote,if,quoting,quote,null,res,contains,quote,res,contains,quote,quoting,escaped,builder,header,append,res,replace,all,quote,quote,else,builder,header,append,res,if,quoting,quote,null,builder,header,append,quote,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1523384632;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            final String res__            if (!dataField.columnName().equals("")) {_                res = dataField.columnName()__            } else {_                res = field.getName()__            }__            if (quoting && quote != null) {_                builderHeader.append(quote)__            }_            if (quoting && quote != null && (res.contains("\\" + quote) || res.contains(quote))  && quotingEscaped) {_                builderHeader.append(res.replaceAll("\\" + quote, "\\\\" + quote))__            } else {_                builderHeader.append(res)__            }_            if (quoting && quote != null) {_                builderHeader.append(quote)__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,integer,data,field,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,final,string,res,if,data,field,column,name,equals,res,data,field,column,name,else,res,field,get,name,if,quoting,quote,null,builder,header,append,quote,if,quoting,quote,null,res,contains,quote,res,contains,quote,quoting,escaped,builder,header,append,res,replace,all,quote,quote,else,builder,header,append,res,if,quoting,quote,null,builder,header,append,quote,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1523968787;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            final String res__            if (!dataField.columnName().equals("")) {_                res = dataField.columnName()__            } else {_                res = field.getName()__            }__            if (quoting && quote != null) {_                builderHeader.append(quote)__            }_            if (quoting && quote != null && (res.contains("\\" + quote) || res.contains(quote))  && quotingEscaped) {_                builderHeader.append(res.replaceAll("\\" + quote, "\\\\" + quote))__            } else {_                builderHeader.append(res)__            }_            if (quoting && quote != null) {_                builderHeader.append(quote)__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,final,string,res,if,data,field,column,name,equals,res,data,field,column,name,else,res,field,get,name,if,quoting,quote,null,builder,header,append,quote,if,quoting,quote,null,res,contains,quote,res,contains,quote,quoting,escaped,builder,header,append,res,replace,all,quote,quote,else,builder,header,append,res,if,quoting,quote,null,builder,header,append,quote,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1536517284;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            final String res__            if (!dataField.columnName().equals("")) {_                res = dataField.columnName()__            } else {_                res = field.getName()__            }__            if (quoting && quote != null) {_                builderHeader.append(quote)__            }_            if (quoting && quote != null && (res.contains("\\" + quote) || res.contains(quote))  && quotingEscaped) {_                builderHeader.append(res.replaceAll("\\" + quote, "\\\\" + quote))__            } else {_                builderHeader.append(res)__            }_            if (quoting && quote != null) {_                builderHeader.append(quote)__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,final,string,res,if,data,field,column,name,equals,res,data,field,column,name,else,res,field,get,name,if,quoting,quote,null,builder,header,append,quote,if,quoting,quote,null,res,contains,quote,res,contains,quote,quoting,escaped,builder,header,append,res,replace,all,quote,quote,else,builder,header,append,res,if,quoting,quote,null,builder,header,append,quote,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1536687142;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            final String res__            if (!dataField.columnName().equals("")) {_                res = dataField.columnName()__            } else {_                res = field.getName()__            }__            if (quoting && quote != null) {_                builderHeader.append(quote)__            }_            if (quoting && quote != null && (res.contains("\\" + quote) || res.contains(quote))  && quotingEscaped) {_                builderHeader.append(res.replaceAll("\\" + quote, "\\\\" + quote))__            } else {_                builderHeader.append(res)__            }_            if (quoting && quote != null) {_                builderHeader.append(quote)__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,final,string,res,if,data,field,column,name,equals,res,data,field,column,name,else,res,field,get,name,if,quoting,quote,null,builder,header,append,quote,if,quoting,quote,null,res,contains,quote,res,contains,quote,quoting,escaped,builder,header,append,res,replace,all,quote,quote,else,builder,header,append,res,if,quoting,quote,null,builder,header,append,quote,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1537943284;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            final String res__            if (!dataField.columnName().equals("")) {_                res = dataField.columnName()__            } else {_                res = field.getName()__            }__            if (quoting && quote != null) {_                builderHeader.append(quote)__            }_            if (quoting && quote != null && (res.contains("\\" + quote) || res.contains(quote))  && quotingEscaped) {_                builderHeader.append(res.replaceAll("\\" + quote, "\\\\" + quote))__            } else {_                builderHeader.append(res)__            }_            if (quoting && quote != null) {_                builderHeader.append(quote)__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,final,string,res,if,data,field,column,name,equals,res,data,field,column,name,else,res,field,get,name,if,quoting,quote,null,builder,header,append,quote,if,quoting,quote,null,res,contains,quote,res,contains,quote,quoting,escaped,builder,header,append,res,replace,all,quote,quote,else,builder,header,append,res,if,quoting,quote,null,builder,header,append,quote,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1537943284;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            final String res__            if (!dataField.columnName().equals("")) {_                res = dataField.columnName()__            } else {_                res = field.getName()__            }__            if (quoting && quote != null) {_                builderHeader.append(quote)__            }_            if (quoting && quote != null && (res.contains("\\" + quote) || res.contains(quote))  && quotingEscaped) {_                builderHeader.append(res.replaceAll("\\" + quote, "\\\\" + quote))__            } else {_                builderHeader.append(res)__            }_            if (quoting && quote != null) {_                builderHeader.append(quote)__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,final,string,res,if,data,field,column,name,equals,res,data,field,column,name,else,res,field,get,name,if,quoting,quote,null,builder,header,append,quote,if,quoting,quote,null,res,contains,quote,res,contains,quote,quoting,escaped,builder,header,append,res,replace,all,quote,quote,else,builder,header,append,res,if,quoting,quote,null,builder,header,append,quote,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String generateHeader();1540108163;Generate for the first line the headers of the columns__@return the headers columns;public String generateHeader() {__        Map<Integer, DataField> dataFieldsSorted = new TreeMap<>(dataFields)__        Iterator<Integer> it = dataFieldsSorted.keySet().iterator()___        StringBuilder builderHeader = new StringBuilder()___        while (it.hasNext()) {__            DataField dataField = dataFieldsSorted.get(it.next())___            _            Field field = annotatedFields.get(dataField.pos())__            _            field.setAccessible(true)___            _            final String res__            if (!dataField.columnName().equals("")) {_                res = dataField.columnName()__            } else {_                res = field.getName()__            }__            if (quoting && quote != null) {_                builderHeader.append(quote)__            }_            if (quoting && quote != null && (res.contains("\\" + quote) || res.contains(quote))  && quotingEscaped) {_                builderHeader.append(res.replaceAll("\\" + quote, "\\\\" + quote))__            } else {_                builderHeader.append(res)__            }_            if (quoting && quote != null) {_                builderHeader.append(quote)__            }__            if (it.hasNext()) {_                builderHeader.append(ConverterUtils.getCharDelimiter(separator))__            }__        }__        return builderHeader.toString()__    };generate,for,the,first,line,the,headers,of,the,columns,return,the,headers,columns;public,string,generate,header,map,integer,data,field,data,fields,sorted,new,tree,map,data,fields,iterator,integer,it,data,fields,sorted,key,set,iterator,string,builder,builder,header,new,string,builder,while,it,has,next,data,field,data,field,data,fields,sorted,get,it,next,field,field,annotated,fields,get,data,field,pos,field,set,accessible,true,final,string,res,if,data,field,column,name,equals,res,data,field,column,name,else,res,field,get,name,if,quoting,quote,null,builder,header,append,quote,if,quoting,quote,null,res,contains,quote,res,contains,quote,quoting,escaped,builder,header,append,res,replace,all,quote,quote,else,builder,header,append,res,if,quoting,quote,null,builder,header,append,quote,if,it,has,next,builder,header,append,converter,utils,get,char,delimiter,separator,return,builder,header,to,string
BindyCsvFactory -> public String getSeparator();1233250656;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1235652242;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1236098343;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1236835446;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1236912265;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1245936806;Find the separator used to delimit the CSV fields;public String getSeparator() {_		return separator__	};find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1246045355;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1246454824;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1246526096;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1246589739;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1247659740;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1247731460;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1247738177;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1249980324;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1250061962;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1250156684;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1252503390;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1252575745;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1252663206;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1252844150;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1254476721;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1255352752;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1255482326;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1255612798;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1258732346;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1258736086;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1260808207;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1271143787;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1276128415;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1276357650;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1276858355;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1290574380;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1293121457;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1296495624;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1297377495;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1304355123;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1307685726;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1311784042;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1311838731;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1313481945;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1319272780;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1321110017;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1325779288;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1326392736;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1329896980;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1330973608;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1335090271;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1335788887;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1338733510;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1355719205;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1355739468;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1357140814;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1364939806;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1365150732;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1376549254;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1382001237;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1392400400;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1405374721;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1436627349;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1436627987;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1438938304;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1438938346;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1458660774;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1463827036;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1467414446;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1489149464;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1489149465;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1489495870;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1492674464;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1506410459;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1513330638;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1517474119;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1517474119;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1518764028;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1521797596;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1523384632;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1523968787;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1536517284;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1536687142;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1537943284;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1537943284;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> public String getSeparator();1540108163;Find the separator used to delimit the CSV fields;public String getSeparator() {_        return separator__    };find,the,separator,used,to,delimit,the,csv,fields;public,string,get,separator,return,separator
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1326392736;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class<?> type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format<?> format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                ArrayList<?> list = (ArrayList<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,array,list,list,array,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1329896980;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class<?> type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format<?> format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                ArrayList<?> list = (ArrayList<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,array,list,list,array,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1330973608;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class<?> type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format<?> format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1335090271;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class<?> type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format<?> format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1335788887;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class<?> type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format<?> format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1338733510;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class<?> type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format<?> format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1355719205;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class<?> type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format<?> format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1355739468;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class<?> type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format<?> format = FormatFactory.getFormat(type, getLocale(), datafield)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,get,locale,datafield,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1357140814;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    Format<?> format = FormatFactory.getFormat(type, getLocale(), datafield)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,format,format,format,factory,get,format,type,get,locale,datafield,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1364939806;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    Format<?> format = FormatFactory.getFormat(type, getLocale(), datafield)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,format,format,format,factory,get,format,type,get,locale,datafield,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1365150732;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    Format<?> format = FormatFactory.getFormat(type, getLocale(), datafield)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,format,format,format,factory,get,format,type,get,locale,datafield,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1376549254;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    Format<?> format = FormatFactory.getFormat(type, getLocale(), datafield)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,format,format,format,factory,get,format,type,get,locale,datafield,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1382001237;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    Format<?> format = FormatFactory.getFormat(type, getLocale(), datafield)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,format,format,format,factory,get,format,type,get,locale,datafield,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1392400400;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    Format<?> format = FormatFactory.getFormat(type, getLocale(), datafield)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,format,format,format,factory,get,format,type,get,locale,datafield,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1405374721;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    Format<?> format = FormatFactory.getFormat(type, getLocale(), datafield)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,format,format,format,factory,get,format,type,get,locale,datafield,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1436627349;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    Format<?> format = FormatFactory.getFormat(type, getLocale(), datafield)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.outPos() > 0 ? datafield.outPos() : datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,format,format,format,factory,get,format,type,get,locale,datafield,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,out,pos,0,datafield,out,pos,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1436627987;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    Format<?> format = FormatFactory.getFormat(type, getLocale(), datafield)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,format,format,format,factory,get,format,type,get,locale,datafield,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1438938304;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    Format<?> format = FormatFactory.getFormat(type, getLocale(), datafield)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,format,format,format,factory,get,format,type,get,locale,datafield,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1438938346;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    Format<?> format = FormatFactory.getFormat(type, getLocale(), datafield)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,format,format,format,factory,get,format,type,get,locale,datafield,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1458660774;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    Format<?> format = FormatFactory.getFormat(type, getLocale(), datafield, field.getAnnotation(BindyConverter.class))___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,format,format,format,factory,get,format,type,get,locale,datafield,field,get,annotation,bindy,converter,class,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1463827036;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1467414446;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1489149464;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1489149465;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1489495870;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    _                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {_                        value = datafield.defaultValue()__                    }__                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,if,object,helper,is,not,empty,datafield,default,value,object,helper,is,empty,value,value,datafield,default,value,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1492674464;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    _                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {_                        value = datafield.defaultValue()__                    }__                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,if,object,helper,is,not,empty,datafield,default,value,object,helper,is,empty,value,value,datafield,default,value,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1506410459;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    _                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {_                        value = datafield.defaultValue()__                    }__                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,if,object,helper,is,not,empty,datafield,default,value,object,helper,is,empty,value,value,datafield,default,value,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1513330638;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    _                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {_                        value = datafield.defaultValue()__                    }__                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,if,object,helper,is,not,empty,datafield,default,value,object,helper,is,empty,value,value,datafield,default,value,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1517474119;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    _                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {_                        value = datafield.defaultValue()__                    }__                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,if,object,helper,is,not,empty,datafield,default,value,object,helper,is,empty,value,value,datafield,default,value,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1517474119;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    _                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {_                        value = datafield.defaultValue()__                    }__                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,if,object,helper,is,not,empty,datafield,default,value,object,helper,is,empty,value,value,datafield,default,value,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1518764028;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    _                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {_                        value = datafield.defaultValue()__                    }__                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,if,object,helper,is,not,empty,datafield,default,value,object,helper,is,empty,value,value,datafield,default,value,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1521797596;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    _                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {_                        value = datafield.defaultValue()__                    }__                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,if,object,helper,is,not,empty,datafield,default,value,object,helper,is,empty,value,value,datafield,default,value,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1523384632;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    Class<?> type = field.getType()___                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    _                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {_                        value = datafield.defaultValue()__                    }__                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,if,object,helper,is,not,empty,datafield,default,value,object,helper,is,empty,value,value,datafield,default,value,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1523968787;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    _                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {_                        value = datafield.defaultValue()__                    }__                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,if,object,helper,is,not,empty,datafield,default,value,object,helper,is,empty,value,value,datafield,default,value,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1536517284;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    _                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {_                        value = datafield.defaultValue()__                    }__                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", value, datafield.pos(), result)__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,if,object,helper,is,not,empty,datafield,default,value,object,helper,is,empty,value,value,datafield,default,value,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1536687142;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    _                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {_                        value = datafield.defaultValue()__                    }__                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", value, datafield.pos(), result)__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,if,object,helper,is,not,empty,datafield,default,value,object,helper,is,empty,value,value,datafield,default,value,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1537943284;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    _                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {_                        value = datafield.defaultValue()__                    }__                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", value, datafield.pos(), result)__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,if,object,helper,is,not,empty,datafield,default,value,object,helper,is,empty,value,value,datafield,default,value,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1537943284;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    _                    if (ObjectHelper.isNotEmpty(datafield.defaultValue()) && ObjectHelper.isEmpty(value)) {_                        value = datafield.defaultValue()__                    }__                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", value, datafield.pos(), result)__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,if,object,helper,is,not,empty,datafield,default,value,object,helper,is,empty,value,value,datafield,default,value,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception;1540108163;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class<?> clazz, Object obj, Map<Integer, List<String>> results) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    FormattingOptions formattingOptions = ConverterUtils.convert(datafield,_                            field.getType(),_                            field.getAnnotation(BindyConverter.class),_                            getLocale())__                    Format<?> format = formatFactory.getFormat(formattingOptions)___                    _                    Object value = field.get(obj)___                    _                    if (org.apache.camel.util.ObjectHelper.isNotEmpty(datafield.defaultValue()) && org.apache.camel.util.ObjectHelper.isEmpty(value)) {_                        value = datafield.defaultValue()__                    }__                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", value, datafield.pos(), result)__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                List<?> list = (List<?>)field.get(obj)__                if (list != null) {__                    Iterator<?> it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target, results)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null, results)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,map,integer,list,string,results,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,formatting,options,formatting,options,converter,utils,convert,datafield,field,get,type,field,get,annotation,bindy,converter,class,get,locale,format,format,format,factory,get,format,formatting,options,object,value,field,get,obj,if,org,apache,camel,util,object,helper,is,not,empty,datafield,default,value,org,apache,camel,util,object,helper,is,empty,value,value,datafield,default,value,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,list,list,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,results,else,generate,csv,position,map,field,get,class,null,results
BindyCsvFactory -> public Map<String, Object> factory() throws Exception;1233214146;Factory method generating new instances of the model and adding them to a_HashMap__@return Map is a collection of the objects used to bind data from csv_records_@throws Exception;public Map<String, Object> factory() throws Exception {__        Map<String, Object> mapModel = new HashMap<String, Object>()___        for (Class<?> cl : models) {__            Object obj = ObjectHelper.newInstance(cl)___            _            mapModel.put(obj.getClass().getName(), obj)___        }__        return mapModel__    };factory,method,generating,new,instances,of,the,model,and,adding,them,to,a,hash,map,return,map,is,a,collection,of,the,objects,used,to,bind,data,from,csv,records,throws,exception;public,map,string,object,factory,throws,exception,map,string,object,map,model,new,hash,map,string,object,for,class,cl,models,object,obj,object,helper,new,instance,cl,map,model,put,obj,get,class,get,name,obj,return,map,model
BindyCsvFactory -> public Map<String, Object> factory() throws Exception;1233250656;Factory method generating new instances of the model and adding them to a_HashMap__@return Map is a collection of the objects used to bind data from csv_records_@throws Exception can be thrown;public Map<String, Object> factory() throws Exception {__        Map<String, Object> mapModel = new HashMap<String, Object>()___        for (Class<?> cl : models) {__            Object obj = ObjectHelper.newInstance(cl)___            _            mapModel.put(obj.getClass().getName(), obj)___        }__        return mapModel__    };factory,method,generating,new,instances,of,the,model,and,adding,them,to,a,hash,map,return,map,is,a,collection,of,the,objects,used,to,bind,data,from,csv,records,throws,exception,can,be,thrown;public,map,string,object,factory,throws,exception,map,string,object,map,model,new,hash,map,string,object,for,class,cl,models,object,obj,object,helper,new,instance,cl,map,model,put,obj,get,class,get,name,obj,return,map,model
BindyCsvFactory -> private void generateCsvPositionMap(Class clazz, Object obj) throws Exception;1276858355;Generate a table containing the data formated and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursivelu through this function_The result is placed in the Map<Integer, List> results__@param clazz_@param obj_@throws Exception;private void generateCsvPositionMap(Class clazz, Object obj) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format format = FormatFactory.getFormat(type, pattern, precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted : " + value + ", position : " + datafield.pos() + ", and its formated value : " + result)__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered()) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated : " + String.valueOf(keyGenerated) + ", for section : " + key1)__                    }__                    key = keyGenerated___                } else {__                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {__                    List list = new LinkedList()__                    list.add(result)__                    results.put(key, list)___                } else {__                    List list = (LinkedList)results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                ArrayList list = (ArrayList)field.get(obj)___                if (list != null) {__                    Iterator it = list.iterator()___                    while (it.hasNext()) {__                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target)___                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null)__                }__            }_        }__    };generate,a,table,containing,the,data,formated,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursivelu,through,this,function,the,result,is,placed,in,the,map,integer,list,results,param,clazz,param,obj,throws,exception;private,void,generate,csv,position,map,class,clazz,object,obj,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,precision,object,value,field,get,obj,result,format,string,format,value,if,log,is,debug,enabled,log,debug,value,to,be,formatted,value,position,datafield,pos,and,its,formated,value,result,else,result,integer,key,if,is,message,ordered,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,string,value,of,key,generated,for,section,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,list,new,linked,list,list,add,result,results,put,key,list,else,list,list,linked,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,array,list,list,array,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,else,generate,csv,position,map,field,get,class,null
BindyCsvFactory -> private void generateCsvPositionMap(Class clazz, Object obj) throws Exception;1290574380;Generate a table containing the data formated and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursivelu through this function_The result is placed in the Map<Integer, List> results__@param clazz_@param obj_@throws Exception;private void generateCsvPositionMap(Class clazz, Object obj) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted : " + value + ", position : " + datafield.pos() + ", and its formated value : " + result)__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered()) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated : " + String.valueOf(keyGenerated) + ", for section : " + key1)__                    }__                    key = keyGenerated___                } else {__                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {__                    List list = new LinkedList()__                    list.add(result)__                    results.put(key, list)___                } else {__                    List list = (LinkedList)results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                ArrayList list = (ArrayList)field.get(obj)___                if (list != null) {__                    Iterator it = list.iterator()___                    while (it.hasNext()) {__                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target)___                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null)__                }__            }_        }__    };generate,a,table,containing,the,data,formated,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursivelu,through,this,function,the,result,is,placed,in,the,map,integer,list,results,param,clazz,param,obj,throws,exception;private,void,generate,csv,position,map,class,clazz,object,obj,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,log,is,debug,enabled,log,debug,value,to,be,formatted,value,position,datafield,pos,and,its,formated,value,result,else,result,integer,key,if,is,message,ordered,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,string,value,of,key,generated,for,section,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,list,new,linked,list,list,add,result,results,put,key,list,else,list,list,linked,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,array,list,list,array,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,else,generate,csv,position,map,field,get,class,null
BindyCsvFactory -> private void generateCsvPositionMap(Class clazz, Object obj) throws Exception;1293121457;Generate a table containing the data formated and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursivelu through this function_The result is placed in the Map<Integer, List> results__@param clazz_@param obj_@throws Exception;private void generateCsvPositionMap(Class clazz, Object obj) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted : " + value + ", position : " + datafield.pos() + ", and its formated value : " + result)__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered()) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated : " + String.valueOf(keyGenerated) + ", for section : " + key1)__                    }__                    key = keyGenerated___                } else {__                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {__                    List list = new LinkedList()__                    list.add(result)__                    results.put(key, list)___                } else {__                    List list = (LinkedList)results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                ArrayList list = (ArrayList)field.get(obj)___                if (list != null) {__                    Iterator it = list.iterator()___                    while (it.hasNext()) {__                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target)___                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null)__                }__            }_        }__    };generate,a,table,containing,the,data,formated,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursivelu,through,this,function,the,result,is,placed,in,the,map,integer,list,results,param,clazz,param,obj,throws,exception;private,void,generate,csv,position,map,class,clazz,object,obj,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,log,is,debug,enabled,log,debug,value,to,be,formatted,value,position,datafield,pos,and,its,formated,value,result,else,result,integer,key,if,is,message,ordered,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,string,value,of,key,generated,for,section,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,list,new,linked,list,list,add,result,results,put,key,list,else,list,list,linked,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,array,list,list,array,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,else,generate,csv,position,map,field,get,class,null
BindyCsvFactory -> private void generateCsvPositionMap(Class clazz, Object obj) throws Exception;1296495624;Generate a table containing the data formated and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursivelu through this function_The result is placed in the Map<Integer, List> results__@param clazz_@param obj_@throws Exception;private void generateCsvPositionMap(Class clazz, Object obj) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted : " + value + ", position : " + datafield.pos() + ", and its formated value : " + result)__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered()) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated : " + String.valueOf(keyGenerated) + ", for section : " + key1)__                    }__                    key = keyGenerated___                } else {__                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {__                    List list = new LinkedList()__                    list.add(result)__                    results.put(key, list)___                } else {__                    List list = (LinkedList)results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                ArrayList list = (ArrayList)field.get(obj)___                if (list != null) {__                    Iterator it = list.iterator()___                    while (it.hasNext()) {__                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target)___                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null)__                }__            }_        }__    };generate,a,table,containing,the,data,formated,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursivelu,through,this,function,the,result,is,placed,in,the,map,integer,list,results,param,clazz,param,obj,throws,exception;private,void,generate,csv,position,map,class,clazz,object,obj,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,log,is,debug,enabled,log,debug,value,to,be,formatted,value,position,datafield,pos,and,its,formated,value,result,else,result,integer,key,if,is,message,ordered,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,string,value,of,key,generated,for,section,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,list,new,linked,list,list,add,result,results,put,key,list,else,list,list,linked,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,array,list,list,array,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,else,generate,csv,position,map,field,get,class,null
BindyCsvFactory -> private void generateCsvPositionMap(Class clazz, Object obj) throws Exception;1297377495;Generate a table containing the data formated and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursivelu through this function_The result is placed in the Map<Integer, List> results__@param clazz_@param obj_@throws Exception;private void generateCsvPositionMap(Class clazz, Object obj) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted : " + value + ", position : " + datafield.pos() + ", and its formated value : " + result)__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered()) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated : " + String.valueOf(keyGenerated) + ", for section : " + key1)__                    }__                    key = keyGenerated___                } else {__                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {__                    List list = new LinkedList()__                    list.add(result)__                    results.put(key, list)___                } else {__                    List list = (LinkedList)results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                ArrayList list = (ArrayList)field.get(obj)___                if (list != null) {__                    Iterator it = list.iterator()___                    while (it.hasNext()) {__                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target)___                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null)__                }__            }_        }__    };generate,a,table,containing,the,data,formated,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursivelu,through,this,function,the,result,is,placed,in,the,map,integer,list,results,param,clazz,param,obj,throws,exception;private,void,generate,csv,position,map,class,clazz,object,obj,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,log,is,debug,enabled,log,debug,value,to,be,formatted,value,position,datafield,pos,and,its,formated,value,result,else,result,integer,key,if,is,message,ordered,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,string,value,of,key,generated,for,section,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,list,new,linked,list,list,add,result,results,put,key,list,else,list,list,linked,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,array,list,list,array,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,else,generate,csv,position,map,field,get,class,null
BindyCsvFactory -> private void generateCsvPositionMap(Class clazz, Object obj) throws Exception;1304355123;Generate a table containing the data formated and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursivelu through this function_The result is placed in the Map<Integer, List> results__@param clazz_@param obj_@throws Exception;private void generateCsvPositionMap(Class clazz, Object obj) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted : " + value + ", position : " + datafield.pos() + ", and its formated value : " + result)__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered()) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated : " + String.valueOf(keyGenerated) + ", for section : " + key1)__                    }__                    key = keyGenerated___                } else {__                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {__                    List list = new LinkedList()__                    list.add(result)__                    results.put(key, list)___                } else {__                    List list = (LinkedList)results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                ArrayList list = (ArrayList)field.get(obj)___                if (list != null) {__                    Iterator it = list.iterator()___                    while (it.hasNext()) {__                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target)___                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null)__                }__            }_        }__    };generate,a,table,containing,the,data,formated,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursivelu,through,this,function,the,result,is,placed,in,the,map,integer,list,results,param,clazz,param,obj,throws,exception;private,void,generate,csv,position,map,class,clazz,object,obj,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,log,is,debug,enabled,log,debug,value,to,be,formatted,value,position,datafield,pos,and,its,formated,value,result,else,result,integer,key,if,is,message,ordered,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,string,value,of,key,generated,for,section,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,list,new,linked,list,list,add,result,results,put,key,list,else,list,list,linked,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,array,list,list,array,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,else,generate,csv,position,map,field,get,class,null
BindyCsvFactory -> private void generateCsvPositionMap(Class clazz, Object obj) throws Exception;1307685726;Generate a table containing the data formated and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursivelu through this function_The result is placed in the Map<Integer, List> results__@param clazz_@param obj_@throws Exception;private void generateCsvPositionMap(Class clazz, Object obj) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted : {}, position : {}, and its formated value : {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered()) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated : {}, for section : {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {__                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {__                    List list = new LinkedList()__                    list.add(result)__                    results.put(key, list)___                } else {__                    List list = (LinkedList)results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                ArrayList list = (ArrayList)field.get(obj)___                if (list != null) {__                    Iterator it = list.iterator()___                    while (it.hasNext()) {__                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target)___                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null)__                }__            }_        }__    };generate,a,table,containing,the,data,formated,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursivelu,through,this,function,the,result,is,placed,in,the,map,integer,list,results,param,clazz,param,obj,throws,exception;private,void,generate,csv,position,map,class,clazz,object,obj,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formated,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,list,new,linked,list,list,add,result,results,put,key,list,else,list,list,linked,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,array,list,list,array,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,else,generate,csv,position,map,field,get,class,null
BindyCsvFactory -> private void generateCsvPositionMap(Class clazz, Object obj) throws Exception;1311784042;Generate a table containing the data formated and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursivelu through this function_The result is placed in the Map<Integer, List> results__@param clazz_@param obj_@throws Exception;private void generateCsvPositionMap(Class clazz, Object obj) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted : {}, position : {}, and its formated value : {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered()) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated : {}, for section : {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {__                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {__                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)___                } else {__                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                ArrayList list = (ArrayList)field.get(obj)___                if (list != null) {__                    Iterator it = list.iterator()___                    while (it.hasNext()) {__                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target)___                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null)__                }__            }_        }__    };generate,a,table,containing,the,data,formated,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursivelu,through,this,function,the,result,is,placed,in,the,map,integer,list,results,param,clazz,param,obj,throws,exception;private,void,generate,csv,position,map,class,clazz,object,obj,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formated,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,array,list,list,array,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,else,generate,csv,position,map,field,get,class,null
BindyCsvFactory -> private void generateCsvPositionMap(Class clazz, Object obj) throws Exception;1311838731;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class clazz, Object obj) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                ArrayList list = (ArrayList)field.get(obj)__                if (list != null) {__                    Iterator it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,array,list,list,array,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,else,generate,csv,position,map,field,get,class,null
BindyCsvFactory -> private void generateCsvPositionMap(Class clazz, Object obj) throws Exception;1313481945;Generate a table containing the data formatted and sorted with their position/offset_If the model is Ordered than a key is created combining the annotation @Section and Position of the field_If a relation @OneToMany is defined, than we iterate recursively through this function_The result is placed in the Map<Integer, List> results;private void generateCsvPositionMap(Class clazz, Object obj) throws Exception {__        String result = ""___        for (Field field : clazz.getDeclaredFields()) {__            field.setAccessible(true)___            DataField datafield = field.getAnnotation(DataField.class)___            if (datafield != null) {__                if (obj != null) {__                    _                    _                    Class type = field.getType()__                    String pattern = datafield.pattern()__                    int precision = datafield.precision()___                    _                    Format format = FormatFactory.getFormat(type, pattern, getLocale(), precision)___                    _                    Object value = field.get(obj)___                    result = formatString(format, value)___                    if (datafield.trim()) {_                        result = result.trim()__                    }__                    if (datafield.clip() && result.length() > datafield.length()) {_                        result = result.substring(0, datafield.length())__                    }__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Value to be formatted: {}, position: {}, and its formatted value: {}", new Object[]{value, datafield.pos(), result})__                    }__                } else {_                    result = ""__                }__                Integer key___                if (isMessageOrdered() && obj != null) {__                    _                    _                    Integer key1 = sections.get(obj.getClass().getName())__                    Integer key2 = datafield.position()__                    Integer keyGenerated = generateKey(key1, key2)___                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Key generated: {}, for section: {}", String.valueOf(keyGenerated), key1)__                    }__                    key = keyGenerated___                } else {_                    key = datafield.pos()__                }__                if (!results.containsKey(key)) {_                    List<String> list = new LinkedList<String>()__                    list.add(result)__                    results.put(key, list)__                } else {_                    List<String> list = results.get(key)__                    list.add(result)__                }__            }__            OneToMany oneToMany = field.getAnnotation(OneToMany.class)__            if (oneToMany != null) {__                _                _                isOneToMany = true___                ArrayList list = (ArrayList)field.get(obj)__                if (list != null) {__                    Iterator it = list.iterator()__                    while (it.hasNext()) {_                        Object target = it.next()__                        generateCsvPositionMap(target.getClass(), target)__                    }__                } else {__                    _                    _                    generateCsvPositionMap(field.getClass(), null)__                }__            }_        }__    };generate,a,table,containing,the,data,formatted,and,sorted,with,their,position,offset,if,the,model,is,ordered,than,a,key,is,created,combining,the,annotation,section,and,position,of,the,field,if,a,relation,one,to,many,is,defined,than,we,iterate,recursively,through,this,function,the,result,is,placed,in,the,map,integer,list,results;private,void,generate,csv,position,map,class,clazz,object,obj,throws,exception,string,result,for,field,field,clazz,get,declared,fields,field,set,accessible,true,data,field,datafield,field,get,annotation,data,field,class,if,datafield,null,if,obj,null,class,type,field,get,type,string,pattern,datafield,pattern,int,precision,datafield,precision,format,format,format,factory,get,format,type,pattern,get,locale,precision,object,value,field,get,obj,result,format,string,format,value,if,datafield,trim,result,result,trim,if,datafield,clip,result,length,datafield,length,result,result,substring,0,datafield,length,if,log,is,debug,enabled,log,debug,value,to,be,formatted,position,and,its,formatted,value,new,object,value,datafield,pos,result,else,result,integer,key,if,is,message,ordered,obj,null,integer,key1,sections,get,obj,get,class,get,name,integer,key2,datafield,position,integer,key,generated,generate,key,key1,key2,if,log,is,debug,enabled,log,debug,key,generated,for,section,string,value,of,key,generated,key1,key,key,generated,else,key,datafield,pos,if,results,contains,key,key,list,string,list,new,linked,list,string,list,add,result,results,put,key,list,else,list,string,list,results,get,key,list,add,result,one,to,many,one,to,many,field,get,annotation,one,to,many,class,if,one,to,many,null,is,one,to,many,true,array,list,list,array,list,field,get,obj,if,list,null,iterator,it,list,iterator,while,it,has,next,object,target,it,next,generate,csv,position,map,target,get,class,target,else,generate,csv,position,map,field,get,class,null
BindyCsvFactory -> private void initModelClasses(String packageName) throws Exception;1233214146;Find all the classes defined as model__@param packageName_@throws Exception;private void initModelClasses(String packageName) throws Exception {_        models = ClassHelper.getClasses(packageName)__    };find,all,the,classes,defined,as,model,param,package,name,throws,exception;private,void,init,model,classes,string,package,name,throws,exception,models,class,helper,get,classes,package,name
BindyCsvFactory -> private void initModelClasses(String packageName) throws Exception;1233250656;Find all the classes defined as model;private void initModelClasses(String packageName) throws Exception {_        models = modelsLoader.loadModels(packageName)__    };find,all,the,classes,defined,as,model;private,void,init,model,classes,string,package,name,throws,exception,models,models,loader,load,models,package,name
BindyCsvFactory -> public boolean isSkipField();1517474119;Indicate if DataField can be ignored__@return boolean;public boolean isSkipField() {_        return this.isSkipField__    };indicate,if,data,field,can,be,ignored,return,boolean;public,boolean,is,skip,field,return,this,is,skip,field
BindyCsvFactory -> public boolean isSkipField();1517474119;Indicate if can skip fields__@return boolean;public boolean isSkipField() {_        return this.skipField__    };indicate,if,can,skip,fields,return,boolean;public,boolean,is,skip,field,return,this,skip,field
BindyCsvFactory -> public boolean isSkipField();1518764028;Indicate if can skip fields__@return boolean;public boolean isSkipField() {_        return this.skipField__    };indicate,if,can,skip,fields,return,boolean;public,boolean,is,skip,field,return,this,skip,field
BindyCsvFactory -> public boolean isSkipField();1521797596;Indicate if can skip fields__@return boolean;public boolean isSkipField() {_        return this.skipField__    };indicate,if,can,skip,fields,return,boolean;public,boolean,is,skip,field,return,this,skip,field
BindyCsvFactory -> public boolean isSkipField();1523384632;Indicate if can skip fields__@return boolean;public boolean isSkipField() {_        return this.skipField__    };indicate,if,can,skip,fields,return,boolean;public,boolean,is,skip,field,return,this,skip,field
BindyCsvFactory -> public boolean isSkipField();1523968787;Indicate if can skip fields__@return boolean;public boolean isSkipField() {_        return this.skipField__    };indicate,if,can,skip,fields,return,boolean;public,boolean,is,skip,field,return,this,skip,field
BindyCsvFactory -> public boolean isSkipField();1536517284;Indicate if can skip fields__@return boolean;public boolean isSkipField() {_        return this.skipField__    };indicate,if,can,skip,fields,return,boolean;public,boolean,is,skip,field,return,this,skip,field
BindyCsvFactory -> public boolean isSkipField();1536687142;Indicate if can skip fields__@return boolean;public boolean isSkipField() {_        return this.skipField__    };indicate,if,can,skip,fields,return,boolean;public,boolean,is,skip,field,return,this,skip,field
BindyCsvFactory -> public boolean isSkipField();1537943284;Indicate if can skip fields__@return boolean;public boolean isSkipField() {_        return this.skipField__    };indicate,if,can,skip,fields,return,boolean;public,boolean,is,skip,field,return,this,skip,field
BindyCsvFactory -> public boolean isSkipField();1537943284;Indicate if can skip fields__@return boolean;public boolean isSkipField() {_        return this.skipField__    };indicate,if,can,skip,fields,return,boolean;public,boolean,is,skip,field,return,this,skip,field
BindyCsvFactory -> public boolean isSkipField();1540108163;Indicate if can skip fields__@return boolean;public boolean isSkipField() {_        return this.skipField__    };indicate,if,can,skip,fields,return,boolean;public,boolean,is,skip,field,return,this,skip,field
BindyCsvFactory -> public void link(Map<String, Object> model) throws Exception;1233214146;Link objects together (Only 1to1 relation is allowed)__@param model_@throws Exception;public void link(Map<String, Object> model) throws Exception {__        Iterator<?> it = mapAnnotedLinkField.keySet().iterator()___        while (it.hasNext()) {__            Field field = mapAnnotedLinkField.get(it.next())__            field.setAccessible(true)___            _            String toClassName = field.getType().getName()__            Object to = model.get(toClassName)___            ObjectHelper.notNull(to, "No @link annotation has been defined for the oject to link")__            field.set(model.get(field.getDeclaringClass().getName()), to)___        }_    };link,objects,together,only,1to1,relation,is,allowed,param,model,throws,exception;public,void,link,map,string,object,model,throws,exception,iterator,it,map,annoted,link,field,key,set,iterator,while,it,has,next,field,field,map,annoted,link,field,get,it,next,field,set,accessible,true,string,to,class,name,field,get,type,get,name,object,to,model,get,to,class,name,object,helper,not,null,to,no,link,annotation,has,been,defined,for,the,oject,to,link,field,set,model,get,field,get,declaring,class,get,name,to
BindyCsvFactory -> public void link(Map<String, Object> model) throws Exception;1233250656;Link objects together (Only 1to1 relation is allowed);public void link(Map<String, Object> model) throws Exception {__        for (String link : mapAnnotedLinkField.keySet()) {__            Field field = mapAnnotedLinkField.get(link)__            field.setAccessible(true)___            _            String toClassName = field.getType().getName()__            Object to = model.get(toClassName)___            ObjectHelper.notNull(to, "No @link annotation has been defined for the oject to link")__            field.set(model.get(field.getDeclaringClass().getName()), to)___        }_    };link,objects,together,only,1to1,relation,is,allowed;public,void,link,map,string,object,model,throws,exception,for,string,link,map,annoted,link,field,key,set,field,field,map,annoted,link,field,get,link,field,set,accessible,true,string,to,class,name,field,get,type,get,name,object,to,model,get,to,class,name,object,helper,not,null,to,no,link,annotation,has,been,defined,for,the,oject,to,link,field,set,model,get,field,get,declaring,class,get,name,to
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1255352752;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1255482326;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1255612798;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1258732346;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1258736086;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1260808207;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1271143787;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1276128415;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1276357650;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1276858355;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1290574380;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1293121457;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1296495624;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1297377495;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1304355123;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1307685726;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1311784042;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1311838731;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1313481945;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1319272780;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1321110017;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1325779288;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1326392736;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1329896980;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1330973608;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1335090271;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1335788887;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1338733510;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1355719205;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1355739468;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1357140814;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1364939806;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1365150732;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1376549254;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1382001237;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1392400400;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1405374721;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1436627349;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1436627987;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1438938304;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1438938346;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1458660774;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1463827036;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1467414446;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1489149464;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1489149465;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1489495870;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1492674464;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1506410459;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1513330638;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1517474119;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1517474119;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1518764028;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1521797596;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1523384632;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1523968787;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1536517284;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1536687142;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1537943284;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1537943284;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public boolean getGenerateHeaderColumnNames();1540108163;Flag indicating if the first line of the CSV must be skipped;public boolean getGenerateHeaderColumnNames() {_        return generateHeaderColumnNames__    };flag,indicating,if,the,first,line,of,the,csv,must,be,skipped;public,boolean,get,generate,header,column,names,return,generate,header,column,names
BindyCsvFactory -> public void initCsvModel() throws Exception;1235652242;method uses to initialize the model representing the classes who will_bind the data This process will scan for classes according to the package_name provided, check the classes and fields annoted and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {_        _        _        initAnnotedFields()__        _        _        _        initCsvRecordParameters()___    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,classes,and,fields,annoted,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1236098343;method uses to initialize the model representing the classes who will_bind the data This process will scan for classes according to the package_name provided, check the classes and fields annoted and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {_        _        _        initAnnotedFields()__        _        _        _        initCsvRecordParameters()___    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,classes,and,fields,annoted,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1236835446;method uses to initialize the model representing the classes who will_bind the data This process will scan for classes according to the package_name provided, check the classes and fields annoted and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {_        _        _        initAnnotedFields()__        _        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,classes,and,fields,annoted,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1236912265;method uses to initialize the model representing the classes who will_bind the data This process will scan for classes according to the package_name provided, check the classes and fields annoted and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {_        _        _        initAnnotedFields()__        _        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,classes,and,fields,annoted,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1245936806;method uses to initialize the model representing the classes who will_bind the data This process will scan for classes according to the package_name provided, check the classes and fields annoted and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__		_		initAnnotedFields()___		_		_		initCsvRecordParameters()__	};method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,classes,and,fields,annoted,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1246045355;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1246454824;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1246526096;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1246589739;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1247659740;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1247731460;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1247738177;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1249980324;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1250061962;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1250156684;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1252503390;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1252575745;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1252663206;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1252844150;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1254476721;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1255352752;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1255482326;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1255612798;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1258732346;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the package_name provided, check the annotated classes and fields and retrieve the_separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1258736086;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1260808207;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1271143787;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1276128415;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1276357650;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1276858355;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1290574380;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1293121457;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1296495624;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1297377495;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1304355123;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1307685726;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1311784042;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1311838731;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1313481945;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1319272780;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1321110017;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1325779288;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1326392736;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1329896980;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1330973608;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1335090271;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1335788887;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1338733510;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1355719205;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1355739468;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1357140814;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1364939806;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1365150732;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1376549254;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1382001237;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1392400400;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1405374721;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1436627349;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1436627987;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1438938304;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1438938346;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1458660774;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1463827036;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1467414446;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1489149464;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1489149465;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1489495870;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1492674464;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1506410459;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1513330638;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1517474119;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1517474119;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1518764028;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1521797596;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1523384632;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1523968787;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1536517284;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1536687142;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1537943284;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1537943284;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initCsvModel() throws Exception;1540108163;method uses to initialize the model representing the classes who will_bind the data. This process will scan for classes according to the_package name provided, check the annotated classes and fields and_retrieve the separator of the CSV record__@throws Exception;public void initCsvModel() throws Exception {__        _        initAnnotatedFields()___        _        _        initCsvRecordParameters()__    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,annotated,classes,and,fields,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,csv,model,throws,exception,init,annotated,fields,init,csv,record,parameters
BindyCsvFactory -> public void initModel() throws Exception;1233214146;method uses to initialize the model representing the classes who will_bind the data This process will scan for classes according to the package_name provided, check the classes and fields annoted and retrieve the_separator of the CSV record__@throws Exception;public void initModel() throws Exception {__        _        initModelClasses(this.packageName)___        _        initAnnotedFields()___        _        _        initCsvRecordParameters()___    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,classes,and,fields,annoted,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,model,throws,exception,init,model,classes,this,package,name,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> public void initModel() throws Exception;1233250656;method uses to initialize the model representing the classes who will_bind the data This process will scan for classes according to the package_name provided, check the classes and fields annoted and retrieve the_separator of the CSV record__@throws Exception;public void initModel() throws Exception {__        _        initModelClasses(packageName)___        _        initAnnotedFields()___        _        _        initCsvRecordParameters()___    };method,uses,to,initialize,the,model,representing,the,classes,who,will,bind,the,data,this,process,will,scan,for,classes,according,to,the,package,name,provided,check,the,classes,and,fields,annoted,and,retrieve,the,separator,of,the,csv,record,throws,exception;public,void,init,model,throws,exception,init,model,classes,package,name,init,annoted,fields,init,csv,record,parameters
BindyCsvFactory -> private void initCsvRecordParameters();1233214146;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {__        if (separator == null) {__            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                if (record != null) {__                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV : " + separator)___                }__            }__        }__    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,if,record,null,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator
BindyCsvFactory -> private void initCsvRecordParameters();1233250656;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {__        if (separator == null) {__            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                if (record != null) {__                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV : " + separator)___                }__            }__        }__    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,if,record,null,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator
BindyCsvFactory -> private void initCsvRecordParameters();1235652242;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {__        if (separator == null) {__            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                if (record != null) {__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                                         "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                }__            }__        }__    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,if,record,null,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator
BindyCsvFactory -> private void initCsvRecordParameters();1236098343;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {__        if (separator == null) {__            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                if (record != null) {__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                                         "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                }__            }__        }__    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,if,record,null,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator
BindyCsvFactory -> private void initCsvRecordParameters();1236835446;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                if (record != null) {__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                        "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }_                    _                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,if,record,null,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf
BindyCsvFactory -> private void initCsvRecordParameters();1236912265;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                if (record != null) {__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                        "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }_                    _                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,if,record,null,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf
BindyCsvFactory -> private void initCsvRecordParameters();1245936806;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_		if (separator == null) {_			for (Class<?> cl : models) {__				_				CsvRecord record = cl.getAnnotation(CsvRecord.class)___				_				Section section = cl.getAnnotation(Section.class)___				if (record != null) {__					if (LOG.isDebugEnabled()) {_						LOG.debug("Csv record : " + record.toString())__					}__					_					skipFirstLine = record.skipFirstLine()__					if (LOG.isDebugEnabled()) {_						LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__					}__					_					ObjectHelper.notNull(record.separator(),_							"No separator has been defined in the @Record annotation !")__					separator = record.separator()__					if (LOG.isDebugEnabled()) {_						LOG.debug("Separator defined for the CSV : " + separator)__					}__					_					crlf = record.crlf()__					if (LOG.isDebugEnabled()) {_						LOG.debug("Carriage return defined for the CSV : " + crlf)__					}_				}__				if (section != null) {__					_					ObjectHelper.notNull(section.nber(), "No number has been defined for the section !")___					_					sections.put(cl.getName(), section.nber())___				}_			}_		}_	};get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,nber,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,nber
BindyCsvFactory -> private void initCsvRecordParameters();1246045355;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1246454824;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1246526096;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1246589739;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1247659740;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1247731460;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1247738177;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1249980324;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1250061962;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1250156684;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1252503390;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1252575745;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1252663206;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1252844150;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1254476721;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1255352752;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_            	_                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }_                    _                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Generate header column names parameter of the CSV : " + generateHeaderColumnNames)__                    }_                    _                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,if,log,is,debug,enabled,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1255482326;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_            _                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }_                    _                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Generate header column names parameter of the CSV : " + generateHeaderColumnNames)__                    }_                    _                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,if,log,is,debug,enabled,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1255612798;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_            _                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }_                    _                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Generate header column names parameter of the CSV : " + generateHeaderColumnNames)__                    }_                    _                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,if,log,is,debug,enabled,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1258732346;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {_            _                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }_                    _                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Generate header column names parameter of the CSV : " + generateHeaderColumnNames)__                    }_                    _                    _                    ObjectHelper.notNull(record.separator(),_                            "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }_                    _                    _                    messageOrdered = record.isOrdered()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Must CSV record be ordered ? " + messageOrdered)__                    }_                    _                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,if,log,is,debug,enabled,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,if,log,is,debug,enabled,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1258736086;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Generate header column names parameter of the CSV : " + generateHeaderColumnNames)__                    }__                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }__                    _                    messageOrdered = record.isOrdered()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Must CSV record be ordered ? " + messageOrdered)__                    }__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,if,log,is,debug,enabled,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,if,log,is,debug,enabled,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1260808207;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Generate header column names parameter of the CSV : " + generateHeaderColumnNames)__                    }__                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }__                    _                    messageOrdered = record.isOrdered()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Must CSV record be ordered ? " + messageOrdered)__                    }__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,if,log,is,debug,enabled,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,if,log,is,debug,enabled,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1271143787;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Generate header column names parameter of the CSV : " + generateHeaderColumnNames)__                    }__                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }__                    _                    messageOrdered = record.isOrdered()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Must CSV record be ordered ? " + messageOrdered)__                    }__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,if,log,is,debug,enabled,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,if,log,is,debug,enabled,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1276128415;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Generate header column names parameter of the CSV : " + generateHeaderColumnNames)__                    }__                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }__                    _                    messageOrdered = record.isOrdered()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Must CSV record be ordered ? " + messageOrdered)__                    }__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,if,log,is,debug,enabled,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,if,log,is,debug,enabled,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1276357650;Get paramaters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Generate header column names parameter of the CSV : " + generateHeaderColumnNames)__                    }__                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }__                    _                    messageOrdered = record.isOrdered()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Must CSV record be ordered ? " + messageOrdered)__                    }__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,paramaters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,if,log,is,debug,enabled,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,if,log,is,debug,enabled,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1276858355;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Generate header column names parameter of the CSV : " + generateHeaderColumnNames)__                    }__                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }__                    _                    messageOrdered = record.isOrdered()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Must CSV record be ordered ? " + messageOrdered)__                    }__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,if,log,is,debug,enabled,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,if,log,is,debug,enabled,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1290574380;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Generate header column names parameter of the CSV : " + generateHeaderColumnNames)__                    }__                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }__                    _                    messageOrdered = record.isOrdered()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Must CSV record be ordered ? " + messageOrdered)__                    }__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,if,log,is,debug,enabled,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,if,log,is,debug,enabled,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1293121457;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Generate header column names parameter of the CSV : " + generateHeaderColumnNames)__                    }__                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }__                    _                    messageOrdered = record.isOrdered()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Must CSV record be ordered ? " + messageOrdered)__                    }__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,if,log,is,debug,enabled,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,if,log,is,debug,enabled,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1296495624;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Generate header column names parameter of the CSV : " + generateHeaderColumnNames)__                    }__                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }__                    _                    messageOrdered = record.isOrdered()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Must CSV record be ordered ? " + messageOrdered)__                    }__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,if,log,is,debug,enabled,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,if,log,is,debug,enabled,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1297377495;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Generate header column names parameter of the CSV : " + generateHeaderColumnNames)__                    }__                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }__                    _                    messageOrdered = record.isOrdered()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Must CSV record be ordered ? " + messageOrdered)__                    }__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,if,log,is,debug,enabled,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,if,log,is,debug,enabled,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1304355123;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Csv record : " + record.toString())__                    }__                    _                    skipFirstLine = record.skipFirstLine()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Skip First Line parameter of the CSV : " + skipFirstLine)__                    }__                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Generate header column names parameter of the CSV : " + generateHeaderColumnNames)__                    }__                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Separator defined for the CSV : " + separator)__                    }__                    _                    crlf = record.crlf()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Carriage return defined for the CSV : " + crlf)__                    }__                    _                    messageOrdered = record.isOrdered()__                    if (LOG.isDebugEnabled()) {_                        LOG.debug("Must CSV record be ordered ? " + messageOrdered)__                    }__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,if,log,is,debug,enabled,log,debug,csv,record,record,to,string,skip,first,line,record,skip,first,line,if,log,is,debug,enabled,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,if,log,is,debug,enabled,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,if,log,is,debug,enabled,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,if,log,is,debug,enabled,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,if,log,is,debug,enabled,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1307685726;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record : {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV : {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV : {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV : {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV : {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered ? {}", messageOrdered)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1311784042;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record : {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV : {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV : {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation !")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV : {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV : {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered ? {}", messageOrdered)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section !")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1311838731;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1313481945;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1319272780;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1321110017;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1325779288;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1326392736;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1329896980;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1330973608;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1335090271;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1335788887;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1338733510;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }_                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1355719205;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", messageOrdered)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1355739468;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", messageOrdered)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1357140814;Get parameters defined in @Csvrecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", messageOrdered)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csvrecord,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1364939806;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", messageOrdered)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1365150732;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", messageOrdered)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1376549254;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", messageOrdered)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,message,ordered,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1382001237;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", messageOrdered)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,message,ordered,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1392400400;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", messageOrdered)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,message,ordered,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1405374721;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1436627349;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1436627987;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1438938304;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            Class<?> cl = type()___            _            CsvRecord record = cl.getAnnotation(CsvRecord.class)___            _            Section section = cl.getAnnotation(Section.class)___            if (record != null) {_                LOG.debug("Csv record: {}", record)___                _                skipFirstLine = record.skipFirstLine()__                LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                _                generateHeaderColumnNames = record.generateHeaderColumns()__                LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                _                ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                separator = record.separator()__                LOG.debug("Separator defined for the CSV: {}", separator)___                _                crlf = record.crlf()__                LOG.debug("Carriage return defined for the CSV: {}", crlf)___                _                messageOrdered = record.isOrdered()__                LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                if (ObjectHelper.isNotEmpty(record.quote())) {_                    quote = record.quote()__                    LOG.debug("Quoting columns with: {}", quote)__                }__                quoting = record.quoting()__                LOG.debug("CSV will be quoted: {}", quoting)___                autospanLine = record.autospanLine()__                LOG.debug("Autospan line in last record: {}", autospanLine)__            }__            if (section != null) {_                _                ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                _                sections.put(cl.getName(), section.number())__            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,class,cl,type,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1438938346;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1458660774;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1463827036;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1467414446;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1489149464;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allo empty stream parameter of the CSV: {}" + allowEmptyStream)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allo,empty,stream,parameter,of,the,csv,allow,empty,stream,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1489149465;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allo empty stream parameter of the CSV: {}" + allowEmptyStream)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allo,empty,stream,parameter,of,the,csv,allow,empty,stream,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1489495870;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allo empty stream parameter of the CSV: {}" + allowEmptyStream)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allo,empty,stream,parameter,of,the,csv,allow,empty,stream,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1492674464;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allow empty stream parameter of the CSV: {}" + allowEmptyStream)__                    _                    _                    quotingEscaped = record.quotingEscaped()__                    LOG.debug("Escape quote character flag of the CSV: {}" + quotingEscaped)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allow,empty,stream,parameter,of,the,csv,allow,empty,stream,quoting,escaped,record,quoting,escaped,log,debug,escape,quote,character,flag,of,the,csv,quoting,escaped,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1506410459;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allow empty stream parameter of the CSV: {}" + allowEmptyStream)__                    _                    _                    quotingEscaped = record.quotingEscaped()__                    LOG.debug("Escape quote character flag of the CSV: {}" + quotingEscaped)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allow,empty,stream,parameter,of,the,csv,allow,empty,stream,quoting,escaped,record,quoting,escaped,log,debug,escape,quote,character,flag,of,the,csv,quoting,escaped,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1513330638;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allow empty stream parameter of the CSV: {}" + allowEmptyStream)__                    _                    _                    quotingEscaped = record.quotingEscaped()__                    LOG.debug("Escape quote character flag of the CSV: {}" + quotingEscaped)__                    _                    _                    endWithLineBreak = record.endWithLineBreak()__                    LOG.debug("End with line break: {}" + endWithLineBreak)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allow,empty,stream,parameter,of,the,csv,allow,empty,stream,quoting,escaped,record,quoting,escaped,log,debug,escape,quote,character,flag,of,the,csv,quoting,escaped,end,with,line,break,record,end,with,line,break,log,debug,end,with,line,break,end,with,line,break,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1517474119;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allow empty stream parameter of the CSV: {}" + allowEmptyStream)__                    _                    _                    quotingEscaped = record.quotingEscaped()__                    LOG.debug("Escape quote character flag of the CSV: {}" + quotingEscaped)__                    _                    _                    endWithLineBreak = record.endWithLineBreak()__                    LOG.debug("End with line break: {}" + endWithLineBreak)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allow,empty,stream,parameter,of,the,csv,allow,empty,stream,quoting,escaped,record,quoting,escaped,log,debug,escape,quote,character,flag,of,the,csv,quoting,escaped,end,with,line,break,record,end,with,line,break,log,debug,end,with,line,break,end,with,line,break,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1517474119;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    skipField = record.skipField()__                    LOG.debug("Skip Field parameter of the CSV: {}" + skipField)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allow empty stream parameter of the CSV: {}" + allowEmptyStream)__                    _                    _                    quotingEscaped = record.quotingEscaped()__                    LOG.debug("Escape quote character flag of the CSV: {}" + quotingEscaped)__                    _                    _                    endWithLineBreak = record.endWithLineBreak()__                    LOG.debug("End with line break: {}" + endWithLineBreak)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,skip,field,record,skip,field,log,debug,skip,field,parameter,of,the,csv,skip,field,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allow,empty,stream,parameter,of,the,csv,allow,empty,stream,quoting,escaped,record,quoting,escaped,log,debug,escape,quote,character,flag,of,the,csv,quoting,escaped,end,with,line,break,record,end,with,line,break,log,debug,end,with,line,break,end,with,line,break,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1518764028;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    skipField = record.skipField()__                    LOG.debug("Skip Field parameter of the CSV: {}" + skipField)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allow empty stream parameter of the CSV: {}" + allowEmptyStream)__                    _                    _                    quotingEscaped = record.quotingEscaped()__                    LOG.debug("Escape quote character flag of the CSV: {}" + quotingEscaped)__                    _                    _                    endWithLineBreak = record.endWithLineBreak()__                    LOG.debug("End with line break: {}" + endWithLineBreak)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,skip,field,record,skip,field,log,debug,skip,field,parameter,of,the,csv,skip,field,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allow,empty,stream,parameter,of,the,csv,allow,empty,stream,quoting,escaped,record,quoting,escaped,log,debug,escape,quote,character,flag,of,the,csv,quoting,escaped,end,with,line,break,record,end,with,line,break,log,debug,end,with,line,break,end,with,line,break,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1521797596;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    skipField = record.skipField()__                    LOG.debug("Skip Field parameter of the CSV: {}" + skipField)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allow empty stream parameter of the CSV: {}" + allowEmptyStream)__                    _                    _                    quotingEscaped = record.quotingEscaped()__                    LOG.debug("Escape quote character flag of the CSV: {}" + quotingEscaped)__                    _                    _                    endWithLineBreak = record.endWithLineBreak()__                    LOG.debug("End with line break: {}" + endWithLineBreak)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,skip,field,record,skip,field,log,debug,skip,field,parameter,of,the,csv,skip,field,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allow,empty,stream,parameter,of,the,csv,allow,empty,stream,quoting,escaped,record,quoting,escaped,log,debug,escape,quote,character,flag,of,the,csv,quoting,escaped,end,with,line,break,record,end,with,line,break,log,debug,end,with,line,break,end,with,line,break,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1523384632;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    skipField = record.skipField()__                    LOG.debug("Skip Field parameter of the CSV: {}" + skipField)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allow empty stream parameter of the CSV: {}" + allowEmptyStream)__                    _                    _                    quotingEscaped = record.quotingEscaped()__                    LOG.debug("Escape quote character flag of the CSV: {}" + quotingEscaped)__                    _                    _                    endWithLineBreak = record.endWithLineBreak()__                    LOG.debug("End with line break: {}" + endWithLineBreak)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,skip,field,record,skip,field,log,debug,skip,field,parameter,of,the,csv,skip,field,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allow,empty,stream,parameter,of,the,csv,allow,empty,stream,quoting,escaped,record,quoting,escaped,log,debug,escape,quote,character,flag,of,the,csv,quoting,escaped,end,with,line,break,record,end,with,line,break,log,debug,end,with,line,break,end,with,line,break,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1523968787;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    skipField = record.skipField()__                    LOG.debug("Skip Field parameter of the CSV: {}" + skipField)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allow empty stream parameter of the CSV: {}" + allowEmptyStream)__                    _                    _                    quotingEscaped = record.quotingEscaped()__                    LOG.debug("Escape quote character flag of the CSV: {}" + quotingEscaped)__                    _                    _                    endWithLineBreak = record.endWithLineBreak()__                    LOG.debug("End with line break: {}" + endWithLineBreak)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,skip,field,record,skip,field,log,debug,skip,field,parameter,of,the,csv,skip,field,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allow,empty,stream,parameter,of,the,csv,allow,empty,stream,quoting,escaped,record,quoting,escaped,log,debug,escape,quote,character,flag,of,the,csv,quoting,escaped,end,with,line,break,record,end,with,line,break,log,debug,end,with,line,break,end,with,line,break,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1536517284;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}" + skipFirstLine)___                    _                    skipField = record.skipField()__                    LOG.debug("Skip Field parameter of the CSV: {}" + skipField)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allow empty stream parameter of the CSV: {}" + allowEmptyStream)__                    _                    _                    quotingEscaped = record.quotingEscaped()__                    LOG.debug("Escape quote character flag of the CSV: {}" + quotingEscaped)__                    _                    _                    endWithLineBreak = record.endWithLineBreak()__                    LOG.debug("End with line break: {}" + endWithLineBreak)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,skip,field,record,skip,field,log,debug,skip,field,parameter,of,the,csv,skip,field,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allow,empty,stream,parameter,of,the,csv,allow,empty,stream,quoting,escaped,record,quoting,escaped,log,debug,escape,quote,character,flag,of,the,csv,quoting,escaped,end,with,line,break,record,end,with,line,break,log,debug,end,with,line,break,end,with,line,break,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1536687142;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}", skipFirstLine)___                    _                    skipField = record.skipField()__                    LOG.debug("Skip Field parameter of the CSV: {}", skipField)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allow empty stream parameter of the CSV: {}", allowEmptyStream)__                    _                    _                    quotingEscaped = record.quotingEscaped()__                    LOG.debug("Escape quote character flag of the CSV: {}", quotingEscaped)__                    _                    _                    endWithLineBreak = record.endWithLineBreak()__                    LOG.debug("End with line break: {}", endWithLineBreak)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,skip,field,record,skip,field,log,debug,skip,field,parameter,of,the,csv,skip,field,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allow,empty,stream,parameter,of,the,csv,allow,empty,stream,quoting,escaped,record,quoting,escaped,log,debug,escape,quote,character,flag,of,the,csv,quoting,escaped,end,with,line,break,record,end,with,line,break,log,debug,end,with,line,break,end,with,line,break,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1537943284;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}", skipFirstLine)___                    _                    skipField = record.skipField()__                    LOG.debug("Skip Field parameter of the CSV: {}", skipField)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allow empty stream parameter of the CSV: {}", allowEmptyStream)__                    _                    _                    quotingEscaped = record.quotingEscaped()__                    LOG.debug("Escape quote character flag of the CSV: {}", quotingEscaped)__                    _                    _                    endWithLineBreak = record.endWithLineBreak()__                    LOG.debug("End with line break: {}", endWithLineBreak)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,skip,field,record,skip,field,log,debug,skip,field,parameter,of,the,csv,skip,field,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allow,empty,stream,parameter,of,the,csv,allow,empty,stream,quoting,escaped,record,quoting,escaped,log,debug,escape,quote,character,flag,of,the,csv,quoting,escaped,end,with,line,break,record,end,with,line,break,log,debug,end,with,line,break,end,with,line,break,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1537943284;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}", skipFirstLine)___                    _                    skipField = record.skipField()__                    LOG.debug("Skip Field parameter of the CSV: {}", skipField)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allow empty stream parameter of the CSV: {}", allowEmptyStream)__                    _                    _                    quotingEscaped = record.quotingEscaped()__                    LOG.debug("Escape quote character flag of the CSV: {}", quotingEscaped)__                    _                    _                    endWithLineBreak = record.endWithLineBreak()__                    LOG.debug("End with line break: {}", endWithLineBreak)___                    removeQuotes = record.removeQuotes()__                    LOG.debug("Remove quotes: {}", removeQuotes)__                }__                if (section != null) {_                    _                    ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,skip,field,record,skip,field,log,debug,skip,field,parameter,of,the,csv,skip,field,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allow,empty,stream,parameter,of,the,csv,allow,empty,stream,quoting,escaped,record,quoting,escaped,log,debug,escape,quote,character,flag,of,the,csv,quoting,escaped,end,with,line,break,record,end,with,line,break,log,debug,end,with,line,break,end,with,line,break,remove,quotes,record,remove,quotes,log,debug,remove,quotes,remove,quotes,if,section,null,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
BindyCsvFactory -> private void initCsvRecordParameters();1540108163;Get parameters defined in @CsvRecord annotation;private void initCsvRecordParameters() {_        if (separator == null) {_            for (Class<?> cl : models) {__                _                CsvRecord record = cl.getAnnotation(CsvRecord.class)___                _                Section section = cl.getAnnotation(Section.class)___                if (record != null) {_                    LOG.debug("Csv record: {}", record)___                    _                    skipFirstLine = record.skipFirstLine()__                    LOG.debug("Skip First Line parameter of the CSV: {}", skipFirstLine)___                    _                    skipField = record.skipField()__                    LOG.debug("Skip Field parameter of the CSV: {}", skipField)___                    _                    generateHeaderColumnNames = record.generateHeaderColumns()__                    LOG.debug("Generate header column names parameter of the CSV: {}", generateHeaderColumnNames)___                    _                    org.apache.camel.util.ObjectHelper.notNull(record.separator(), "No separator has been defined in the @Record annotation")__                    separator = record.separator()__                    LOG.debug("Separator defined for the CSV: {}", separator)___                    _                    crlf = record.crlf()__                    LOG.debug("Carriage return defined for the CSV: {}", crlf)___                    _                    messageOrdered = record.isOrdered()__                    LOG.debug("Must CSV record be ordered: {}", messageOrdered)___                    if (org.apache.camel.util.ObjectHelper.isNotEmpty(record.quote())) {_                        quote = record.quote()__                        LOG.debug("Quoting columns with: {}", quote)__                    }__                    quoting = record.quoting()__                    LOG.debug("CSV will be quoted: {}", quoting)___                    autospanLine = record.autospanLine()__                    LOG.debug("Autospan line in last record: {}", autospanLine)__                    _                    _                    allowEmptyStream = record.allowEmptyStream()__                    LOG.debug("Allow empty stream parameter of the CSV: {}", allowEmptyStream)__                    _                    _                    quotingEscaped = record.quotingEscaped()__                    LOG.debug("Escape quote character flag of the CSV: {}", quotingEscaped)__                    _                    _                    endWithLineBreak = record.endWithLineBreak()__                    LOG.debug("End with line break: {}", endWithLineBreak)___                    removeQuotes = record.removeQuotes()__                    LOG.debug("Remove quotes: {}", removeQuotes)__                }__                if (section != null) {_                    _                    org.apache.camel.util.ObjectHelper.notNull(section.number(), "No number has been defined for the section")___                    _                    sections.put(cl.getName(), section.number())__                }_            }_        }_    };get,parameters,defined,in,csv,record,annotation;private,void,init,csv,record,parameters,if,separator,null,for,class,cl,models,csv,record,record,cl,get,annotation,csv,record,class,section,section,cl,get,annotation,section,class,if,record,null,log,debug,csv,record,record,skip,first,line,record,skip,first,line,log,debug,skip,first,line,parameter,of,the,csv,skip,first,line,skip,field,record,skip,field,log,debug,skip,field,parameter,of,the,csv,skip,field,generate,header,column,names,record,generate,header,columns,log,debug,generate,header,column,names,parameter,of,the,csv,generate,header,column,names,org,apache,camel,util,object,helper,not,null,record,separator,no,separator,has,been,defined,in,the,record,annotation,separator,record,separator,log,debug,separator,defined,for,the,csv,separator,crlf,record,crlf,log,debug,carriage,return,defined,for,the,csv,crlf,message,ordered,record,is,ordered,log,debug,must,csv,record,be,ordered,message,ordered,if,org,apache,camel,util,object,helper,is,not,empty,record,quote,quote,record,quote,log,debug,quoting,columns,with,quote,quoting,record,quoting,log,debug,csv,will,be,quoted,quoting,autospan,line,record,autospan,line,log,debug,autospan,line,in,last,record,autospan,line,allow,empty,stream,record,allow,empty,stream,log,debug,allow,empty,stream,parameter,of,the,csv,allow,empty,stream,quoting,escaped,record,quoting,escaped,log,debug,escape,quote,character,flag,of,the,csv,quoting,escaped,end,with,line,break,record,end,with,line,break,log,debug,end,with,line,break,end,with,line,break,remove,quotes,record,remove,quotes,log,debug,remove,quotes,remove,quotes,if,section,null,org,apache,camel,util,object,helper,not,null,section,number,no,number,has,been,defined,for,the,section,sections,put,cl,get,name,section,number
