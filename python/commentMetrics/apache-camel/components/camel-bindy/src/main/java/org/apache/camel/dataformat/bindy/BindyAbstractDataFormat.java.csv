commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Class<?> getClassType() {     return classType. }
false;public;1;3;;public void setClassType(Class<?> classType) {     this.classType = classType. }
false;public;0;3;;public String getLocale() {     return locale. }
false;public;1;3;;public void setLocale(String locale) {     this.locale = locale. }
false;public;0;3;;public boolean isUnwrapSingleInstance() {     return unwrapSingleInstance. }
false;public;1;3;;public void setUnwrapSingleInstance(boolean unwrapSingleInstance) {     this.unwrapSingleInstance = unwrapSingleInstance. }
false;public;0;9;;public BindyAbstractFactory getFactory() throws Exception {     if (modelFactory == null) {         FormatFactory formatFactory = createFormatFactory().         registerAdditionalConverter(formatFactory).         modelFactory = createModelFactory(formatFactory).         modelFactory.setLocale(locale).     }     return modelFactory. }
false;private;1;12;;private void registerAdditionalConverter(FormatFactory formatFactory) throws IllegalAccessException, InstantiationException {     Function<Class<?>, FormatFactories> g = aClass -> aClass.getAnnotation(FormatFactories.class).     Function<FormatFactories, List<Class<? extends FormatFactoryInterface>>> h = formatFactories -> Arrays.asList(formatFactories.value()).     List<Class<? extends FormatFactoryInterface>> array = Optional.ofNullable(classType).map(g).map(h).orElse(Collections.emptyList()).     for (Class<? extends FormatFactoryInterface> l : array) {         formatFactory.getFactoryRegistry().register(l.newInstance()).     } }
false;private;0;6;;private FormatFactory createFormatFactory() {     FormatFactory formatFactory = new FormatFactory().     FactoryRegistry factoryRegistry = createFactoryRegistry().     formatFactory.setFactoryRegistry(factoryRegistry).     return formatFactory. }
false;private;0;3;;private FactoryRegistry createFactoryRegistry() {     return tryToGetFactoryRegistry(). }
false;private;0;22;;private FactoryRegistry tryToGetFactoryRegistry() {     Function<CamelContext, Registry> f = CamelContext::getRegistry.     Function<Registry, Set<FactoryRegistry>> g = r -> r.findByType(FactoryRegistry.class).     Function<Set<FactoryRegistry>, FactoryRegistry> h = factoryRegistries -> {         if (factoryRegistries.size() > 1) {             LOGGER.warn("Number of registered {}: {}", FactoryRegistry.class.getCanonicalName(), factoryRegistries.size()).         }         if (factoryRegistries.iterator().hasNext()) {             return factoryRegistries.iterator().next().         } else {             return new DefaultFactoryRegistry().         }     }.     return Optional.ofNullable(camelContext).map(f).map(g).map(h).orElse(new DefaultFactoryRegistry()). }
false;public;1;3;;public void setModelFactory(BindyAbstractFactory modelFactory) {     this.modelFactory = modelFactory. }
false;protected;1;5;;protected Map<String, Object> createLinkedFieldsModel(Object model) throws IllegalAccessException {     Map<String, Object> row = new HashMap<>().     createLinkedFieldsModel(model, row).     return row. }
false;protected;2;13;;protected void createLinkedFieldsModel(Object model, Map<String, Object> row) throws IllegalAccessException {     for (Field field : model.getClass().getDeclaredFields()) {         Link linkField = field.getAnnotation(Link.class).         if (linkField != null) {             boolean accessible = field.isAccessible().             field.setAccessible(true).             if (!row.containsKey(field.getType().getName())) {                 row.put(field.getType().getName(), field.get(model)).             }             field.setAccessible(accessible).         }     } }
false;protected,abstract;1;1;;protected abstract BindyAbstractFactory createModelFactory(FormatFactory formatFactory) throws Exception.
false;protected;1;20;;protected Object extractUnmarshalResult(List<Map<String, Object>> models) {     if (getClassType() != null) {         // we expect to findForFormattingOptions this type in the models, and grab only that type         List<Object> answer = new ArrayList<>().         for (Map<String, Object> entry : models) {             Object data = entry.get(getClassType().getName()).             if (data != null) {                 answer.add(data).             }         }         // if there is only 1 then dont return a list         if (isUnwrapSingleInstance() && answer.size() == 1) {             return answer.get(0).         } else {             return answer.         }     } else {         return models.     } }
false;protected;0;4;;@Override protected void doStart() throws Exception { // noop }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
false;public;0;4;;@Override public CamelContext getCamelContext() {     return camelContext. }
false;public;1;4;;@Override public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
