commented;modifiers;parameterAmount;loc;comment;code
true;public;0;6;/**  * method uses to initialize the model representing the classes who will  * bind the data. This process will scan for classes according to the  * package name provided, check the annotated classes and fields.  *  * @throws Exception  */ ;/**  * method uses to initialize the model representing the classes who will  * bind the data. This process will scan for classes according to the  * package name provided, check the annotated classes and fields.  *  * @throws Exception  */ public void initModel() throws Exception {     models = new HashSet<>().     modelClassNames = new HashSet<>().     loadModels(type). }
true;private;1;38;/**  * Recursively load model.  *  * @param root  */ ;/**  * Recursively load model.  *  * @param root  */ @SuppressWarnings("rawtypes") private void loadModels(Class<?> root) {     models.add(root).     modelClassNames.add(root.getName()).     for (Field field : root.getDeclaredFields()) {         Link linkField = field.getAnnotation(Link.class).         if (linkField != null) {             if (LOG.isDebugEnabled()) {                 LOG.debug("Class linked: {}, Field: {}", field.getType(), field).             }             models.add(field.getType()).             modelClassNames.add(field.getType().getName()).             loadModels(field.getType()).         }         OneToMany oneToManyField = field.getAnnotation(OneToMany.class).         if (oneToManyField != null) {             if (LOG.isDebugEnabled()) {                 LOG.debug("Class (OneToMany) linked: {}, Field: {}", field.getType(), field).             }             Type listType = field.getGenericType().             Type type = ((ParameterizedType) listType).getActualTypeArguments()[0].             Class clazz = (Class<?>) type.             models.add(clazz).             modelClassNames.add(clazz.getName()).             loadModels(clazz).         }     } }
true;public,abstract;0;1;/**  * Find fields annotated in each class of the model  */ ;/**  * Find fields annotated in each class of the model  */ public abstract void initAnnotatedFields() throws Exception.
false;public,abstract;4;1;;public abstract void bind(CamelContext camelContext, List<String> data, Map<String, Object> model, int line) throws Exception.
false;public,abstract;2;1;;public abstract String unbind(CamelContext camelContext, Map<String, Object> model) throws Exception.
true;public;1;21;/**  * Link objects together  */ ;/**  * Link objects together  */ public void link(Map<String, Object> model) throws Exception {     // Iterate class by class     for (String link : annotatedLinkFields.keySet()) {         List<Field> linkFields = annotatedLinkFields.get(link).         // Iterate through Link fields list         for (Field field : linkFields) {             // Change protection for private field             field.setAccessible(true).             // Retrieve linked object             String toClassName = field.getType().getName().             Object to = model.get(toClassName).             org.apache.camel.util.ObjectHelper.notNull(to, "No @link annotation has been defined for the object to link").             field.set(model.get(field.getDeclaringClass().getName()), to).         }     } }
true;public;0;12;/**  * Factory method generating new instances of the model and adding them to a  * HashMap  *  * @return Map is a collection of the objects used to bind data from  *         records, messages  * @throws Exception can be thrown  */ ;/**  * Factory method generating new instances of the model and adding them to a  * HashMap  *  * @return Map is a collection of the objects used to bind data from  *         records, messages  * @throws Exception can be thrown  */ public Map<String, Object> factory() throws Exception {     Map<String, Object> mapModel = new HashMap<>().     for (Class<?> cl : models) {         Object obj = ObjectHelper.newInstance(cl).         // Add instance of the class to the Map Model         mapModel.put(obj.getClass().getName(), obj).     }     return mapModel. }
true;public;1;3;/**  * Indicates whether this factory can support a row comprised of the identified classes  * @param classes  the names of the classes in the row  * @return true if the model supports the identified classes  */ ;/**  * Indicates whether this factory can support a row comprised of the identified classes  * @param classes  the names of the classes in the row  * @return true if the model supports the identified classes  */ public boolean supportsModel(Set<String> classes) {     return modelClassNames.containsAll(classes). }
true;protected,static;2;14;/**  * Generate a unique key  *  * @param key1 The key of the section number  * @param key2 The key of the position of the field  * @return the key generated  */ ;/**  * Generate a unique key  *  * @param key1 The key of the section number  * @param key2 The key of the position of the field  * @return the key generated  */ protected static Integer generateKey(Integer key1, Integer key2) {     String key2Formatted.     String keyGenerated.     // BigIntegerFormatFactory added for ticket - camel-2773     if ((key1 != null) && (key2 != null)) {         key2Formatted = getNumberFormat().format((long) key2).         keyGenerated = String.valueOf(key1) + key2Formatted.     } else {         throw new IllegalArgumentException("@Section and/or @KeyValuePairDataField have not been defined").     }     return Integer.valueOf(keyGenerated). }
false;private,static;0;10;;private static NumberFormat getNumberFormat() {     // Get instance of NumberFormat     NumberFormat nf = NumberFormat.getInstance().     // set max number of digits to 3 (thousands)     nf.setMaximumIntegerDigits(3).     nf.setMinimumIntegerDigits(3).     return nf. }
false;public,static;1;24;;public static Object getDefaultValueForPrimitive(Class<?> clazz) throws Exception {     if (clazz == byte.class) {         return Byte.MIN_VALUE.     } else if (clazz == short.class) {         return Short.MIN_VALUE.     } else if (clazz == int.class) {         return Integer.MIN_VALUE.     } else if (clazz == long.class) {         return Long.MIN_VALUE.     } else if (clazz == float.class) {         return Float.MIN_VALUE.     } else if (clazz == double.class) {         return Double.MIN_VALUE.     } else if (clazz == char.class) {         return Character.MIN_VALUE.     } else if (clazz == boolean.class) {         return false.     } else if (clazz == String.class) {         return "".     } else {         return null.     } }
true;public;0;3;/**  * Find the carriage return set  */ ;/**  * Find the carriage return set  */ public String getCarriageReturn() {     return crlf. }
true;public;0;3;/**  * Find the carriage return set  */ ;/**  * Find the carriage return set  */ public String getEndOfLine() {     return eol. }
true;public;2;14;/**  * Format the object into a string according to the format rule defined  */ ;/**  * Format the object into a string according to the format rule defined  */ @SuppressWarnings("unchecked") public String formatString(Format<?> format, Object value) throws Exception {     String strValue = "".     if (value != null) {         try {             strValue = ((Format<Object>) format).format(value).         } catch (Exception e) {             throw new IllegalArgumentException("Formatting error detected for the value: " + value, e).         }     }     return strValue. }
false;public;0;3;;public String getLocale() {     return locale. }
false;public;1;3;;public void setLocale(String locale) {     this.locale = locale. }
false;public;1;3;;public void setFormatFactory(FormatFactory formatFactory) {     this.formatFactory = formatFactory. }
