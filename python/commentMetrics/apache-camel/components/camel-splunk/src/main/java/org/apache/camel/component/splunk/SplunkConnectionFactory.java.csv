commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getApp() {     return app. }
false;public;1;3;;public void setApp(String app) {     this.app = app. }
false;public;0;3;;public int getConnectionTimeout() {     return connectionTimeout. }
false;public;1;3;;public void setConnectionTimeout(int connectionTimeout) {     this.connectionTimeout = connectionTimeout. }
false;public;0;3;;public String getScheme() {     return scheme. }
false;public;1;3;;public void setScheme(String scheme) {     this.scheme = scheme. }
false;public;0;3;;public boolean isUseSunHttpsHandler() {     return useSunHttpsHandler. }
false;public;1;3;;public void setUseSunHttpsHandler(boolean useSunHttpsHandler) {     this.useSunHttpsHandler = useSunHttpsHandler. }
false;public;0;3;;public SSLSecurityProtocol getSslProtocol() {     return sslProtocol. }
false;public;1;3;;public void setSslProtocol(SSLSecurityProtocol sslProtocol) {     this.sslProtocol = sslProtocol. }
false;public;0;7;;public Service call() throws Exception {     if (Service.DEFAULT_SCHEME.equals(getScheme())) {         LOG.debug("Https in use. Setting SSL protocol to {}", getSslProtocol()).         HttpService.setSslSecurityProtocol(getSslProtocol()).     }     return Service.connect(args). }
false;public,synchronized;1;62;;public synchronized Service createService(CamelContext camelContext) {     final ServiceArgs args = new ServiceArgs().     if (host != null) {         args.setHost(host).     }     if (port > 0) {         args.setPort(port).     }     if (scheme != null) {         args.setScheme(scheme).     }     if (app != null) {         args.setApp(app).     }     if (owner != null) {         args.setOwner(owner).     }     args.setUsername(username).     args.setPassword(password).     // (wls i'm looking at you)     if (isUseSunHttpsHandler()) {         String sunHandlerClassName = "sun.net.www.protocol.https.Handler".         Class<URLStreamHandler> clazz = camelContext.getClassResolver().resolveClass(sunHandlerClassName, URLStreamHandler.class).         if (clazz != null) {             URLStreamHandler handler = camelContext.getInjector().newInstance(clazz).             args.setHTTPSHandler(handler).             LOG.debug("using the URLStreamHandler {} for {}", handler, args).         } else {             LOG.warn("could not resolve and use the URLStreamHandler class '{}'", sunHandlerClassName).         }     }     ExecutorService executor = camelContext.getExecutorServiceManager().newSingleThreadExecutor(this, "DefaultSplunkConnectionFactory").     Future<Service> future = executor.submit(new Callable<Service>() {          public Service call() throws Exception {             if (Service.DEFAULT_SCHEME.equals(getScheme())) {                 LOG.debug("Https in use. Setting SSL protocol to {}", getSslProtocol()).                 HttpService.setSslSecurityProtocol(getSslProtocol()).             }             return Service.connect(args).         }     }).     try {         Service service = null.         if (connectionTimeout > 0) {             service = future.get(connectionTimeout, TimeUnit.MILLISECONDS).         } else {             service = future.get().         }         LOG.info("Successfully connected to Splunk").         return service.     } catch (Exception e) {         throw new RuntimeException(String.format("could not connect to Splunk Server @ %s:%d - %s", host, port, e.getMessage())).     } finally {         if (executor != null) {             camelContext.getExecutorServiceManager().shutdownNow(executor).         }     } }
