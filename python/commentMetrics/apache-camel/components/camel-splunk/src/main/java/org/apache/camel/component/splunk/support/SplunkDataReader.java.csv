commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public int getCount() {     return endpoint.getConfiguration().getCount(). }
false;public;0;3;;public String getSearch() {     return endpoint.getConfiguration().getSearch(). }
false;public;0;3;;public String getEarliestTime() {     return endpoint.getConfiguration().getEarliestTime(). }
false;public;0;3;;public String getLatestTime() {     return endpoint.getConfiguration().getLatestTime(). }
false;public;0;3;;public String getInitEarliestTime() {     return endpoint.getConfiguration().getInitEarliestTime(). }
false;private;0;3;;private String getSavedSearch() {     return endpoint.getConfiguration().getSavedSearch(). }
false;public;0;4;;public List<SplunkEvent> read() throws Exception {     // Read without callback     return read(null). }
false;public;1;16;;public List<SplunkEvent> read(SplunkResultProcessor callback) throws Exception {     switch(consumerType) {         case NORMAL:             {                 return nonBlockingSearch(callback).             }         case REALTIME:             {                 return realtimeSearch(callback).             }         case SAVEDSEARCH:             {                 return savedSearch(callback).             }         default:             {                 throw new RuntimeException("Unknown search mode " + consumerType).             }     } }
true;private;2;10;/**  * Get the earliestTime of range search.  *  * @param startTime the time where search start  * @param realtime if this is realtime search  * @return The time of last successful read if not realtime. Time difference  *         between last successful read and start time.  */ ;/**  * Get the earliestTime of range search.  *  * @param startTime the time where search start  * @param realtime if this is realtime search  * @return The time of last successful read if not realtime. Time difference  *         between last successful read and start time.  */ private String calculateEarliestTime(Calendar startTime, boolean realtime) {     String result.     if (realtime) {         result = calculateEarliestTimeForRealTime(startTime).     } else {         DateFormat df = new SimpleDateFormat(DATE_FORMAT).         result = df.format(lastSuccessfulReadTime.getTime()).     }     return result. }
true;private;1;6;/**  * Gets earliest time for realtime search  */ ;/**  * Gets earliest time for realtime search  */ private String calculateEarliestTimeForRealTime(Calendar startTime) {     String result.     long diff = startTime.getTimeInMillis() - lastSuccessfulReadTime.getTimeInMillis().     result = "-" + diff / 1000 + "s".     return result. }
false;private;3;14;;private void populateArgs(JobArgs queryArgs, Calendar startTime, boolean realtime) {     String earliestTime = getEarliestTime(startTime, realtime).     if (ObjectHelper.isNotEmpty(earliestTime)) {         queryArgs.setEarliestTime(earliestTime).     }     String latestTime = getLatestTime(startTime, realtime).     if (ObjectHelper.isNotEmpty(latestTime)) {         queryArgs.setLatestTime(latestTime).     }     queryArgs.setTimeFormat(SPLUNK_TIME_FORMAT). }
false;private;2;14;;private String getLatestTime(Calendar startTime, boolean realtime) {     String lTime.     if (ObjectHelper.isNotEmpty(getLatestTime())) {         lTime = getLatestTime().     } else {         if (realtime) {             lTime = "rt".         } else {             DateFormat df = new SimpleDateFormat(DATE_FORMAT).             lTime = df.format(startTime.getTime()).         }     }     return lTime. }
false;private;2;21;;private String getEarliestTime(Calendar startTime, boolean realtime) {     String eTime = null.     if (lastSuccessfulReadTime == null) {         eTime = getInitEarliestTime().     } else {         if (ObjectHelper.isNotEmpty(getEarliestTime())) {             eTime = getEarliestTime().         } else {             String calculatedEarliestTime = calculateEarliestTime(startTime, realtime).             if (calculatedEarliestTime != null) {                 if (realtime) {                     eTime = "rt" + calculatedEarliestTime.                 } else {                     eTime = calculatedEarliestTime.                 }             }         }     }     return eTime. }
false;private;1;44;;private List<SplunkEvent> savedSearch(SplunkResultProcessor callback) throws Exception {     LOG.trace("saved search start").     ServiceArgs queryArgs = new ServiceArgs().     queryArgs.setApp("search").     if (ObjectHelper.isNotEmpty(endpoint.getConfiguration().getOwner())) {         queryArgs.setOwner(endpoint.getConfiguration().getOwner()).     }     if (ObjectHelper.isNotEmpty(endpoint.getConfiguration().getApp())) {         queryArgs.setApp(endpoint.getConfiguration().getApp()).     }     Calendar startTime = Calendar.getInstance().     SavedSearch search = null.     Job job = null.     String latestTime = getLatestTime(startTime, false).     String earliestTime = getEarliestTime(startTime, false).     Service service = endpoint.getService().     SavedSearchCollection savedSearches = service.getSavedSearches(queryArgs).     for (SavedSearch s : savedSearches.values()) {         if (s.getName().equals(getSavedSearch())) {             search = s.             break.         }     }     if (search != null) {         SavedSearchDispatchArgs args = new SavedSearchDispatchArgs().         args.setForceDispatch(true).         args.setDispatchEarliestTime(earliestTime).         args.setDispatchLatestTime(latestTime).         job = search.dispatch(args).     } else {         throw new RuntimeException("Unable to find saved search '" + getSavedSearch() + "'.").     }     while (!job.isDone()) {         Thread.sleep(2000).     }     List<SplunkEvent> data = extractData(job, false, callback).     this.lastSuccessfulReadTime = startTime.     return data. }
false;private;1;12;;private List<SplunkEvent> nonBlockingSearch(SplunkResultProcessor callback) throws Exception {     LOG.debug("non block search start").     JobArgs queryArgs = new JobArgs().     queryArgs.setExecutionMode(ExecutionMode.NORMAL).     Calendar startTime = Calendar.getInstance().     populateArgs(queryArgs, startTime, false).     List<SplunkEvent> data = runQuery(queryArgs, false, callback).     lastSuccessfulReadTime = startTime.     return data. }
false;private;1;13;;private List<SplunkEvent> realtimeSearch(SplunkResultProcessor callback) throws Exception {     LOG.debug("realtime search start").     JobArgs queryArgs = new JobArgs().     queryArgs.setExecutionMode(ExecutionMode.NORMAL).     queryArgs.setSearchMode(SearchMode.REALTIME).     Calendar startTime = Calendar.getInstance().     populateArgs(queryArgs, startTime, true).     List<SplunkEvent> data = runQuery(queryArgs, true, callback).     lastSuccessfulReadTime = startTime.     return data. }
false;private;3;20;;private List<SplunkEvent> runQuery(JobArgs queryArgs, boolean realtime, SplunkResultProcessor callback) throws Exception {     Service service = endpoint.getService().     Job job = service.getJobs().create(getSearch(), queryArgs).     LOG.debug("Running search : {} with queryArgs : {}", getSearch(), queryArgs).     if (realtime) {         while (!job.isReady()) {             Thread.sleep(500).         }         // Besides job.isReady there must be some delay before real time job         // is ready         // TODO seems that the realtime stream is not quite isReady to be         // read         Thread.sleep(4000).     } else {         while (!job.isDone()) {             Thread.sleep(500).         }     }     return extractData(job, realtime, callback). }
false;private;3;66;;private List<SplunkEvent> extractData(Job job, boolean realtime, SplunkResultProcessor callback) throws Exception {     List<SplunkEvent> result = new ArrayList<>().     HashMap<String, String> data.     SplunkEvent splunkData.     ResultsReader resultsReader = null.     int total = 0.     if (realtime) {         total = job.getResultPreviewCount().     } else {         total = job.getResultCount().     }     if (getCount() == 0 || total < getCount()) {         InputStream stream = null.         JobResultsArgs outputArgs = new JobResultsArgs().         outputArgs.setOutputMode(OutputMode.JSON).         if (realtime) {             if (getCount() > 0) {                 outputArgs.setCount(getCount()).             }             stream = job.getResultsPreview(outputArgs).         } else {             stream = job.getResults(outputArgs).         }         resultsReader = new ResultsReaderJson(stream).         while ((data = resultsReader.getNextEvent()) != null) {             splunkData = new SplunkEvent(data).             if (callback != null) {                 callback.process(splunkData).             } else {                 result.add(splunkData).             }         }         IOHelper.close(stream).     } else {         int offset = 0.         while (offset < total) {             InputStream stream.             JobResultsArgs outputArgs = new JobResultsArgs().             outputArgs.setOutputMode(OutputMode.JSON).             outputArgs.setCount(getCount()).             outputArgs.setOffset(offset).             if (realtime) {                 stream = job.getResultsPreview(outputArgs).             } else {                 stream = job.getResults(outputArgs).             }             resultsReader = new ResultsReaderJson(stream).             while ((data = resultsReader.getNextEvent()) != null) {                 splunkData = new SplunkEvent(data).                 if (callback != null) {                     callback.process(splunkData).                 } else {                     result.add(splunkData).                 }             }             offset += getCount().             IOHelper.close(stream).         }     }     if (resultsReader != null) {         resultsReader.close().     }     job.cancel().     return result. }
