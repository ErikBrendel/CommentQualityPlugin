commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public SchedulerComponent getComponent() {     return (SchedulerComponent) super.getComponent(). }
false;public;0;4;;@Override public Producer createProducer() throws Exception {     throw new UnsupportedOperationException("Scheduler cannot be used as a producer"). }
false;public;1;6;;@Override public Consumer createConsumer(Processor processor) throws Exception {     SchedulerConsumer consumer = new SchedulerConsumer(this, processor).     configureConsumer(consumer).     return consumer. }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;public;0;3;;public String getName() {     return name. }
true;public;1;3;/**  * The name of the scheduler  */ ;/**  * The name of the scheduler  */ public void setName(String name) {     this.name = name. }
false;public;0;3;;public int getConcurrentTasks() {     return concurrentTasks. }
true;public;1;3;/**  * Number of threads used by the scheduling thread pool.  * <p/>  * Is by default using a single thread  */ ;/**  * Number of threads used by the scheduling thread pool.  * <p/>  * Is by default using a single thread  */ public void setConcurrentTasks(int concurrentTasks) {     this.concurrentTasks = concurrentTasks. }
false;public;1;7;;public void onConsumerStart(SchedulerConsumer consumer) {     // if using default scheduler then obtain thread pool from component which manages their lifecycle     if (consumer.getScheduler() == null && consumer.getScheduledExecutorService() == null) {         ScheduledExecutorService scheduler = getComponent().addConsumer(consumer).         consumer.setScheduledExecutorService(scheduler).     } }
false;public;1;3;;public void onConsumerStop(SchedulerConsumer consumer) {     getComponent().removeConsumer(consumer). }
