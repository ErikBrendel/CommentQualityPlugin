commented;modifiers;parameterAmount;loc;comment;code
false;public;2;11;;@Override public void onCamelContextStarted(CamelContext context, boolean alreadyStarted) throws Exception {     // not running on     if (!alreadyStarted) {         LOG.info("Starting CamelMainRunController to ensure the main thread keeps running").         controller.start().     } }
false;public;1;11;;@Override public void notify(CamelEvent eventObject) throws Exception {     for (CamelContextConfiguration camelContextConfiguration : camelContextConfigurations) {         log.debug("CamelContextConfiguration found. Invoking afterApplicationStart: {}", camelContextConfiguration).         try {             camelContextConfiguration.afterApplicationStart(camelContext).         } catch (Exception e) {             log.warn("Error during calling afterApplicationStart due " + e.getMessage() + ". This exception is ignored", e).         }     } }
false;public;1;4;;@Override public boolean isEnabled(CamelEvent eventObject) {     return eventObject.getType() == Type.CamelContextStarted. }
false;public;1;193;;// Overridden @Override public void onApplicationEvent(ContextRefreshedEvent event) {     CamelContext camelContext = applicationContext.getBean(CamelContext.class).     // only add and start Camel if its stopped (initial state)     if (event.getApplicationContext() == this.applicationContext && camelContext.getStatus().isStopped()) {         LOG.debug("Post-processing CamelContext bean: {}", camelContext.getName()).         final AntPathMatcher matcher = new AntPathMatcher().         for (RoutesBuilder routesBuilder : applicationContext.getBeansOfType(RoutesBuilder.class, configurationProperties.isIncludeNonSingletons(), true).values()) {             // filter out abstract classes             boolean abs = Modifier.isAbstract(routesBuilder.getClass().getModifiers()).             if (!abs) {                 String name = routesBuilder.getClass().getName().                 // make name as path so we can use ant path matcher                 name = name.replace('.', '/').                 String exclude = configurationProperties.getJavaRoutesExcludePattern().                 String include = configurationProperties.getJavaRoutesIncludePattern().                 boolean match = !"false".equals(include).                 // exclude take precedence over include                 if (match && ObjectHelper.isNotEmpty(exclude)) {                     // there may be multiple separated by comma                     String[] parts = exclude.split(",").                     for (String part : parts) {                         // must negate when excluding, and hence !                         match = !matcher.match(part, name).                         LOG.trace("Java RoutesBuilder: {} exclude filter: {} -> {}", name, part, match).                         if (!match) {                             break.                         }                     }                 }                 // special support for testing with @ExcludeRoutes annotation with camel-test-spring                 exclude = System.getProperty("CamelTestSpringExcludeRoutes").                 // exclude take precedence over include                 if (match && ObjectHelper.isNotEmpty(exclude)) {                     // this property is a comma separated list of FQN class names, so we need to make                     // name as path so we can use ant patch matcher                     exclude = exclude.replace('.', '/').                     // there may be multiple separated by comma                     String[] parts = exclude.split(",").                     for (String part : parts) {                         // must negate when excluding, and hence !                         match = !matcher.match(part, name).                         LOG.trace("Java RoutesBuilder: {} exclude filter: {} -> {}", name, part, match).                         if (!match) {                             break.                         }                     }                 }                 if (match && ObjectHelper.isNotEmpty(include)) {                     // there may be multiple separated by comma                     String[] parts = include.split(",").                     for (String part : parts) {                         match = matcher.match(part, name).                         LOG.trace("Java RoutesBuilder: {} include filter: {} -> {}", name, part, match).                         if (match) {                             break.                         }                     }                 }                 LOG.debug("Java RoutesBuilder: {} accepted by include/exclude filter: {}", name, match).                 if (match) {                     try {                         LOG.debug("Injecting following route into the CamelContext: {}", routesBuilder).                         camelContext.addRoutes(routesBuilder).                     } catch (Exception e) {                         throw new CamelSpringBootInitializationException(e).                     }                 }             }         }         try {             boolean scan = !configurationProperties.getXmlRoutes().equals("false").             if (scan) {                 loadXmlRoutes(applicationContext, camelContext, configurationProperties.getXmlRoutes()).             }             boolean scanRests = !configurationProperties.getXmlRests().equals("false").             if (scanRests) {                 loadXmlRests(applicationContext, camelContext, configurationProperties.getXmlRests()).             }             for (CamelContextConfiguration camelContextConfiguration : camelContextConfigurations) {                 LOG.debug("CamelContextConfiguration found. Invoking beforeApplicationStart: {}", camelContextConfiguration).                 camelContextConfiguration.beforeApplicationStart(camelContext).             }             if (configurationProperties.isMainRunController()) {                 CamelMainRunController controller = new CamelMainRunController(applicationContext, camelContext).                 if (configurationProperties.getDurationMaxMessages() > 0 || configurationProperties.getDurationMaxIdleSeconds() > 0) {                     if (configurationProperties.getDurationMaxMessages() > 0) {                         LOG.info("CamelSpringBoot will terminate after processing {} messages", configurationProperties.getDurationMaxMessages()).                     }                     if (configurationProperties.getDurationMaxIdleSeconds() > 0) {                         LOG.info("CamelSpringBoot will terminate after being idle for more {} seconds", configurationProperties.getDurationMaxIdleSeconds()).                     }                     // register lifecycle so we can trigger to shutdown the JVM when maximum number of messages has been processed                     EventNotifier notifier = new MainDurationEventNotifier(camelContext, configurationProperties.getDurationMaxMessages(), configurationProperties.getDurationMaxIdleSeconds(), controller.getCompleted(), controller.getLatch(), true).                     // register our event notifier                     ServiceHelper.startService(notifier).                     camelContext.getManagementStrategy().addEventNotifier(notifier).                 }                 if (configurationProperties.getDurationMaxSeconds() > 0) {                     LOG.info("CamelSpringBoot will terminate after {} seconds", configurationProperties.getDurationMaxSeconds()).                     terminateMainControllerAfter(camelContext, configurationProperties.getDurationMaxSeconds(), controller.getCompleted(), controller.getLatch()).                 }                 camelContext.addStartupListener(new StartupListener() {                      @Override                     public void onCamelContextStarted(CamelContext context, boolean alreadyStarted) throws Exception {                         // not running on                         if (!alreadyStarted) {                             LOG.info("Starting CamelMainRunController to ensure the main thread keeps running").                             controller.start().                         }                     }                 }).             } else {                 if (applicationContext instanceof ConfigurableApplicationContext) {                     ConfigurableApplicationContext cac = (ConfigurableApplicationContext) applicationContext.                     if (configurationProperties.getDurationMaxSeconds() > 0) {                         LOG.info("CamelSpringBoot will terminate after {} seconds", configurationProperties.getDurationMaxSeconds()).                         terminateApplicationContext(cac, camelContext, configurationProperties.getDurationMaxSeconds()).                     }                     if (configurationProperties.getDurationMaxMessages() > 0 || configurationProperties.getDurationMaxIdleSeconds() > 0) {                         if (configurationProperties.getDurationMaxMessages() > 0) {                             LOG.info("CamelSpringBoot will terminate after processing {} messages", configurationProperties.getDurationMaxMessages()).                         }                         if (configurationProperties.getDurationMaxIdleSeconds() > 0) {                             LOG.info("CamelSpringBoot will terminate after being idle for more {} seconds", configurationProperties.getDurationMaxIdleSeconds()).                         }                         // needed by MainDurationEventNotifier to signal when we have processed the max messages                         final AtomicBoolean completed = new AtomicBoolean().                         final CountDownLatch latch = new CountDownLatch(1).                         // register lifecycle so we can trigger to shutdown the JVM when maximum number of messages has been processed                         EventNotifier notifier = new MainDurationEventNotifier(camelContext, configurationProperties.getDurationMaxMessages(), configurationProperties.getDurationMaxIdleSeconds(), completed, latch, false).                         // register our event notifier                         ServiceHelper.startService(notifier).                         camelContext.getManagementStrategy().addEventNotifier(notifier).                         terminateApplicationContext(cac, camelContext, latch).                     }                 }             }             if (!camelContextConfigurations.isEmpty()) {                 // we want to call these notifications just after CamelContext has been fully started                 // so use an event notifier to trigger when this happens                 camelContext.getManagementStrategy().addEventNotifier(new EventNotifierSupport() {                      @Override                     public void notify(CamelEvent eventObject) throws Exception {                         for (CamelContextConfiguration camelContextConfiguration : camelContextConfigurations) {                             log.debug("CamelContextConfiguration found. Invoking afterApplicationStart: {}", camelContextConfiguration).                             try {                                 camelContextConfiguration.afterApplicationStart(camelContext).                             } catch (Exception e) {                                 log.warn("Error during calling afterApplicationStart due " + e.getMessage() + ". This exception is ignored", e).                             }                         }                     }                      @Override                     public boolean isEnabled(CamelEvent eventObject) {                         return eventObject.getType() == Type.CamelContextStarted.                     }                 }).             }         } catch (Exception e) {             throw new CamelSpringBootInitializationException(e).         }     } else {         LOG.debug("Camel already started, not adding routes.").     } }
false;public;0;15;;@Override public int getOrder() {     // 3. SpringCamelContext (LOWEST_PRECEDENCE)     return LOWEST_PRECEDENCE - 2. }
false;private;3;16;;// Helpers private void loadXmlRoutes(ApplicationContext applicationContext, CamelContext camelContext, String directory) throws Exception {     String[] parts = directory.split(",").     for (String part : parts) {         LOG.info("Loading additional Camel XML routes from: {}", part).         try {             Resource[] xmlRoutes = applicationContext.getResources(part).             for (Resource xmlRoute : xmlRoutes) {                 LOG.debug("Found XML route: {}", xmlRoute).                 RoutesDefinition xmlDefinition = camelContext.adapt(ModelCamelContext.class).loadRoutesDefinition(xmlRoute.getInputStream()).                 camelContext.adapt(ModelCamelContext.class).addRouteDefinitions(xmlDefinition.getRoutes()).             }         } catch (FileNotFoundException e) {             LOG.debug("No XML routes found in {}. Skipping XML routes detection.", part).         }     } }
false;private;3;19;;private void loadXmlRests(ApplicationContext applicationContext, CamelContext camelContext, String directory) throws Exception {     String[] parts = directory.split(",").     for (String part : parts) {         LOG.info("Loading additional Camel XML rests from: {}", part).         try {             final Resource[] xmlRests = applicationContext.getResources(part).             for (final Resource xmlRest : xmlRests) {                 final RestsDefinition xmlDefinitions = camelContext.adapt(ModelCamelContext.class).loadRestsDefinition(xmlRest.getInputStream()).                 camelContext.adapt(ModelCamelContext.class).addRestDefinitions(xmlDefinitions.getRests()).                 for (final RestDefinition xmlDefinition : xmlDefinitions.getRests()) {                     final List<RouteDefinition> routeDefinitions = xmlDefinition.asRouteDefinition(camelContext).                     camelContext.adapt(ModelCamelContext.class).addRouteDefinitions(routeDefinitions).                 }             }         } catch (FileNotFoundException e) {             LOG.debug("No XML rests found in {}. Skipping XML rests detection.", part).         }     } }
false;private;4;15;;private void terminateMainControllerAfter(final CamelContext camelContext, int seconds, final AtomicBoolean completed, final CountDownLatch latch) {     ScheduledExecutorService executorService = camelContext.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "CamelSpringBootTerminateTask").     Runnable task = () -> {         LOG.info("CamelSpringBoot triggering shutdown of the JVM.").         try {             camelContext.stop().         } catch (Throwable e) {             LOG.warn("Error during stopping CamelContext", e).         } finally {             completed.set(true).             latch.countDown().         }     }.     executorService.schedule(task, seconds, TimeUnit.SECONDS). }
false;private;3;9;;private void terminateApplicationContext(final ConfigurableApplicationContext applicationContext, final CamelContext camelContext, int seconds) {     ScheduledExecutorService executorService = camelContext.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "CamelSpringBootTerminateTask").     Runnable task = () -> {         LOG.info("CamelSpringBoot triggering shutdown of the JVM.").         // we need to run a daemon thread to stop ourselves so this thread pool can be stopped nice also         new Thread(applicationContext::close).start().     }.     executorService.schedule(task, seconds, TimeUnit.SECONDS). }
false;private;3;14;;private void terminateApplicationContext(final ConfigurableApplicationContext applicationContext, final CamelContext camelContext, final CountDownLatch latch) {     ExecutorService executorService = camelContext.getExecutorServiceManager().newSingleThreadExecutor(this, "CamelSpringBootTerminateTask").     Runnable task = () -> {         try {             latch.await().             LOG.info("CamelSpringBoot triggering shutdown of the JVM.").             // we need to run a daemon thread to stop ourselves so this thread pool can be stopped nice also             new Thread(applicationContext::close).start().         } catch (Throwable e) {         // ignore         }     }.     executorService.submit(task). }
