commented;modifiers;parameterAmount;loc;comment;code
true;protected;2;4;/**  * Loads all the class entries from the main JAR and all nested jars.  *  * @param stream  the inputstream of the jar file to be examined for classes  * @param urlPath the url of the jar file to be examined for classes  * @return all the .class entries from the main JAR and all nested jars  */ ;/**  * Loads all the class entries from the main JAR and all nested jars.  *  * @param stream  the inputstream of the jar file to be examined for classes  * @param urlPath the url of the jar file to be examined for classes  * @return all the .class entries from the main JAR and all nested jars  */ @Override protected List<String> doLoadJarClassEntries(InputStream stream, String urlPath) {     return doLoadJarClassEntries(stream, urlPath, true, true). }
false;protected;4;35;;protected List<String> doLoadJarClassEntries(InputStream stream, String urlPath, boolean inspectNestedJars, boolean closeStream) {     List<String> entries = new ArrayList<>().     JarInputStream jarStream = null.     try {         jarStream = new JarInputStream(stream).         JarEntry entry.         while ((entry = jarStream.getNextJarEntry()) != null) {             String name = entry.getName().             if (name != null) {                 name = name.trim().                 if (!entry.isDirectory() && name.endsWith(".class")) {                     entries.add(cleanupSpringbootClassName(name)).                 } else if (inspectNestedJars && !entry.isDirectory() && isSpringBootNestedJar(name)) {                     String nestedUrl = urlPath + "!/" + name.                     log.trace("Inspecting nested jar: {}", nestedUrl).                     List<String> nestedEntries = doLoadJarClassEntries(jarStream, nestedUrl, false, false).                     entries.addAll(nestedEntries).                 }             }         }     } catch (IOException ioe) {         log.warn("Cannot search jar file '" + urlPath + " due to an IOException: " + ioe.getMessage() + ". This exception is ignored.", ioe).     } finally {         if (closeStream) {             // stream is left open when scanning nested jars, otherwise the fat jar stream gets closed             IOHelper.close(jarStream, urlPath, log).         }     }     return entries. }
false;private;1;4;;private boolean isSpringBootNestedJar(String name) {     // Supporting both versions of the packaging model     return name.endsWith(".jar") && (name.startsWith(SPRING_BOOT_CLASSIC_LIB_ROOT) || name.startsWith(SPRING_BOOT_BOOT_INF_LIB_ROOT)). }
false;private;1;7;;private String cleanupSpringbootClassName(String name) {     // Classes inside BOOT-INF/classes will be loaded by the new classloader as if they were in the root     if (name.startsWith(SPRING_BOOT_BOOT_INF_CLASSES_ROOT)) {         name = name.substring(SPRING_BOOT_BOOT_INF_CLASSES_ROOT.length()).     }     return name. }
