commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public DirectVmComponent getComponent() {     return (DirectVmComponent) super.getComponent(). }
false;public;0;8;;@Override public Producer createProducer() throws Exception {     if (block) {         return new DirectVmBlockingProducer(this).     } else {         return new DirectVmProducer(this).     } }
false;public;1;6;;@Override public Consumer createConsumer(Processor processor) throws Exception {     Consumer answer = new DirectVmConsumer(this, new DirectVmProcessor(processor, this)).     configureConsumer(answer).     return answer. }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;public;0;3;;public DirectVmConsumer getConsumer() {     return getComponent().getConsumer(this). }
false;public;0;3;;public boolean isBlock() {     return block. }
true;public;1;3;/**  * If sending a message to a direct endpoint which has no active consumer,  * then we can tell the producer to block and wait for the consumer to become active.  */ ;/**  * If sending a message to a direct endpoint which has no active consumer,  * then we can tell the producer to block and wait for the consumer to become active.  */ public void setBlock(boolean block) {     this.block = block. }
false;public;0;3;;public long getTimeout() {     return timeout. }
true;public;1;3;/**  * The timeout value to use if block is enabled.  */ ;/**  * The timeout value to use if block is enabled.  */ public void setTimeout(long timeout) {     this.timeout = timeout. }
false;public;0;3;;public boolean isFailIfNoConsumers() {     return failIfNoConsumers. }
true;public;1;3;/**  * Whether the producer should fail by throwing an exception, when sending to a Direct-VM endpoint with no active consumers.  */ ;/**  * Whether the producer should fail by throwing an exception, when sending to a Direct-VM endpoint with no active consumers.  */ public void setFailIfNoConsumers(boolean failIfNoConsumers) {     this.failIfNoConsumers = failIfNoConsumers. }
false;public;0;3;;public HeaderFilterStrategy getHeaderFilterStrategy() {     return headerFilterStrategy == null ? getComponent().getHeaderFilterStrategy() : headerFilterStrategy. }
true;public;1;3;/**  * Sets a {@link HeaderFilterStrategy} that will only be applied on producer endpoints (on both directions: request and response).  * <p>Default value: none.</p>  */ ;/**  * Sets a {@link HeaderFilterStrategy} that will only be applied on producer endpoints (on both directions: request and response).  * <p>Default value: none.</p>  */ public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {     this.headerFilterStrategy = headerFilterStrategy. }
false;public;0;3;;public boolean isPropagateProperties() {     return propagateProperties. }
true;public;1;3;/**  * Whether to propagate or not properties from the producer side to the consumer side, and vice versa.  * <p>Default value: true.</p>  */ ;/**  * Whether to propagate or not properties from the producer side to the consumer side, and vice versa.  * <p>Default value: true.</p>  */ public void setPropagateProperties(boolean propagateProperties) {     this.propagateProperties = propagateProperties. }
