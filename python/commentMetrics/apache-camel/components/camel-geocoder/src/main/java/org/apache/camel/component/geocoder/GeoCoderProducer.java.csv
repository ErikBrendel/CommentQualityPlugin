commented;modifiers;parameterAmount;loc;comment;code
false;public;1;55;;public void process(Exchange exchange) throws Exception {     try {         // headers take precedence         String address = exchange.getIn().getHeader(GeoCoderConstants.ADDRESS, String.class).         if (address == null) {             address = endpoint.getAddress().         }         String latlng = exchange.getIn().getHeader(GeoCoderConstants.LATLNG, String.class).         if (latlng == null) {             latlng = endpoint.getLatlng().         }         if (latlng != null) {             String lat = StringHelper.before(latlng, ",").             String lng = StringHelper.after(latlng, ",").             LatLng latLng = new LatLng(Double.parseDouble(lat), Double.parseDouble(lng)).             LOG.debug("Geocode for lat/lng {}", latlng).             GeocodingResult[] results = GeocodingApi.reverseGeocode(context, latLng).await().             LOG.debug("Geocode response {}", results).             if (results != null) {                 extractGeoResult(results, exchange).             }         } else if (address != null) {             // is it current address             if ("current".equals(address)) {                 processCurrentLocation(exchange).             } else {                 LOG.debug("Geocode for address {}", address).                 GeocodingResult[] results = GeocodingApi.geocode(context, address).await().                 LOG.debug("Geocode response {}", results).                 if (results != null) {                     extractGeoResult(results, exchange).                 }             }         }     } catch (RequestDeniedException e) {         exchange.getIn().setHeader(GeoCoderConstants.STATUS, GeocoderStatus.REQUEST_DENIED).     } catch (OverQueryLimitException e) {         exchange.getIn().setHeader(GeoCoderConstants.STATUS, GeocoderStatus.OVER_QUERY_LIMIT).     } catch (OverDailyLimitException e) {         exchange.getIn().setHeader(GeoCoderConstants.STATUS, GeocoderStatus.OVER_DAILY_LIMIT).     } catch (InvalidRequestException e) {         exchange.getIn().setHeader(GeoCoderConstants.STATUS, GeocoderStatus.INVALID_REQUEST).     } catch (UnknownErrorException e) {         exchange.getIn().setHeader(GeoCoderConstants.STATUS, GeocoderStatus.UNKNOWN_ERROR).     } }
true;protected;1;24;/**  * Perform geolocation to retrieve LatLng and then perform a geocoding  */ ;/**  * Perform geolocation to retrieve LatLng and then perform a geocoding  */ protected void processCurrentLocation(Exchange exchange) throws Exception {     LOG.debug("Geolocation for current location").     GeolocationPayload payload = new GeolocationPayload().     payload.considerIp = true.     GeolocationResult result = GeolocationApi.geolocate(context, payload).await().     LOG.debug("Geolocation response {}", result).     // status     exchange.getIn().setHeader(GeoCoderConstants.STATUS, GeocoderStatus.OK).     // latlng     String resLatlng = result.location.toString().     exchange.getIn().setHeader(GeoCoderConstants.LATLNG, resLatlng).     // address - reverse geocode     LOG.debug("Geocode - reverse geocode for location {}", resLatlng).     GeocodingResult[] results = GeocodingApi.reverseGeocode(context, result.location).await().     LOG.debug("Geocode response {}", results).     if (results != null) {         extractGeoResult(results, exchange).     } }
false;private;2;8;;private void setLatLngToExchangeHeader(LatLng location, Exchange exchange) {     double resLat = location.lat.     double resLng = location.lng.     exchange.getIn().setHeader(GeoCoderConstants.LAT, formatLatOrLon(resLat)).     exchange.getIn().setHeader(GeoCoderConstants.LNG, formatLatOrLon(resLng)).     String resLatlng = location.toString().     exchange.getIn().setHeader(GeoCoderConstants.LATLNG, resLatlng). }
false;protected;2;41;;protected void extractGeoResult(GeocodingResult[] res, Exchange exchange) {     // should we include body     if (!endpoint.isHeadersOnly()) {         exchange.getIn().setBody(res).     }     // no results     if (res.length == 0) {         exchange.getIn().setHeader(GeoCoderConstants.STATUS, GeocoderStatus.ZERO_RESULTS).         return.     }     exchange.getIn().setHeader(GeoCoderConstants.STATUS, GeocoderStatus.OK).     GeocodingResult first = res[0].     exchange.getIn().setHeader(GeoCoderConstants.ADDRESS, first.formattedAddress).     // just grab the first element and its lat and lon     setLatLngToExchangeHeader(first.geometry.location, exchange).     // additional details     AddressComponent country = getCountry(res).     if (country != null) {         exchange.getIn().setHeader(GeoCoderConstants.COUNTRY_SHORT, country.shortName).         exchange.getIn().setHeader(GeoCoderConstants.COUNTRY_LONG, country.longName).     }     AddressComponent city = getCity(res).     if (city != null) {         exchange.getIn().setHeader(GeoCoderConstants.CITY, city.longName).     }     AddressComponent postalCode = getPostalCode(res).     if (postalCode != null) {         exchange.getIn().setHeader(GeoCoderConstants.POSTAL_CODE, postalCode.shortName).     }     AddressComponent region = getRegion(res).     if (region != null) {         exchange.getIn().setHeader(GeoCoderConstants.REGION_CODE, region.shortName).         exchange.getIn().setHeader(GeoCoderConstants.REGION_NAME, region.longName).     } }
false;private;1;3;;private String formatLatOrLon(double value) {     return String.format(Locale.ENGLISH, "%.8f", value). }
false;private,static;2;10;;private static AddressComponent getComponent(GeocodingResult[] results, AddressType addressType) {     for (GeocodingResult result : results) {         for (AddressType type : result.types) {             if (type == addressType && result.addressComponents.length > 0) {                 return result.addressComponents[0].             }         }     }     return null. }
false;private,static;1;3;;private static AddressComponent getCountry(GeocodingResult[] res) {     return getComponent(res, AddressType.COUNTRY). }
false;private,static;1;3;;private static AddressComponent getCity(GeocodingResult[] res) {     return getComponent(res, AddressType.LOCALITY). }
false;private,static;1;3;;private static AddressComponent getPostalCode(GeocodingResult[] res) {     return getComponent(res, AddressType.POSTAL_CODE). }
false;private,static;1;3;;private static AddressComponent getRegion(GeocodingResult[] res) {     return getComponent(res, AddressType.ADMINISTRATIVE_AREA_LEVEL_1). }
false;protected;0;4;;@Override protected void doStart() {     context = endpoint.createGeoApiContext(). }
