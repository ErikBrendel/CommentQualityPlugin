commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public NettyHttpComponent getComponent() {     return (NettyHttpComponent) super.getComponent(). }
false;public;1;17;;@Override public Consumer createConsumer(Processor processor) throws Exception {     NettyHttpConsumer answer = new NettyHttpConsumer(this, processor, getConfiguration()).     configureConsumer(answer).     if (nettySharedHttpServer != null) {         answer.setNettyServerBootstrapFactory(nettySharedHttpServer.getServerBootstrapFactory()).         log.info("NettyHttpConsumer: {} is using NettySharedHttpServer on port: {}", answer, nettySharedHttpServer.getPort()).     } else {         // reuse pipeline factory for the same address         HttpServerBootstrapFactory factory = getComponent().getOrCreateHttpNettyServerBootstrapFactory(answer).         // force using our server bootstrap factory         answer.setNettyServerBootstrapFactory(factory).         log.debug("Created NettyHttpConsumer: {} using HttpServerBootstrapFactory: {}", answer, factory).     }     return answer. }
false;public;0;9;;@Override public Producer createProducer() throws Exception {     Producer answer = new NettyHttpProducer(this, getConfiguration()).     if (isSynchronous()) {         return new SynchronousDelegateProducer(answer).     } else {         return answer.     } }
false;public;0;4;;@Override public PollingConsumer createPollingConsumer() throws Exception {     throw new UnsupportedOperationException("This component does not support polling consumer"). }
false;public;2;21;;@Override public Exchange createExchange(ChannelHandlerContext ctx, Object message) throws Exception {     Exchange exchange = createExchange().     FullHttpRequest request = (FullHttpRequest) message.     Message in = getNettyHttpBinding().toCamelMessage(request, exchange, getConfiguration()).     exchange.setIn(in).     // setup the common message headers     updateMessageHeader(in, ctx).     // honor the character encoding     String contentType = in.getHeader(Exchange.CONTENT_TYPE, String.class).     String charset = NettyHttpHelper.getCharsetFromContentType(contentType).     if (charset != null) {         exchange.setProperty(Exchange.CHARSET_NAME, charset).         in.setHeader(Exchange.HTTP_CHARACTER_ENCODING, charset).     }     return exchange. }
false;public;0;5;;@Override public boolean isLenientProperties() {     // true to allow dynamic URI options to be configured and passed to external system for eg. the HttpProducer     return true. }
false;public;1;5;;@Override public void setConfiguration(NettyConfiguration configuration) {     super.setConfiguration(configuration).     this.configuration = (NettyHttpConfiguration) configuration. }
false;public;0;4;;@Override public NettyHttpConfiguration getConfiguration() {     return (NettyHttpConfiguration) super.getConfiguration(). }
false;public;0;3;;public NettyHttpBinding getNettyHttpBinding() {     return nettyHttpBinding. }
true;public;1;3;/**  * To use a custom org.apache.camel.component.netty4.http.NettyHttpBinding for binding to/from Netty and Camel Message API.  */ ;/**  * To use a custom org.apache.camel.component.netty4.http.NettyHttpBinding for binding to/from Netty and Camel Message API.  */ public void setNettyHttpBinding(NettyHttpBinding nettyHttpBinding) {     this.nettyHttpBinding = nettyHttpBinding. }
false;public;0;3;;public HeaderFilterStrategy getHeaderFilterStrategy() {     return headerFilterStrategy. }
true;public;1;4;/**  * To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter headers.  */ ;/**  * To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter headers.  */ public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {     this.headerFilterStrategy = headerFilterStrategy.     getNettyHttpBinding().setHeaderFilterStrategy(headerFilterStrategy). }
false;public;0;3;;public boolean isTraceEnabled() {     return traceEnabled. }
true;public;1;3;/**  * Specifies whether to enable HTTP TRACE for this Netty HTTP consumer. By default TRACE is turned off.  */ ;/**  * Specifies whether to enable HTTP TRACE for this Netty HTTP consumer. By default TRACE is turned off.  */ public void setTraceEnabled(boolean traceEnabled) {     this.traceEnabled = traceEnabled. }
false;public;0;3;;public String getHttpMethodRestrict() {     return httpMethodRestrict. }
true;public;1;3;/**  * To disable HTTP methods on the Netty HTTP consumer. You can specify multiple separated by comma.  */ ;/**  * To disable HTTP methods on the Netty HTTP consumer. You can specify multiple separated by comma.  */ public void setHttpMethodRestrict(String httpMethodRestrict) {     this.httpMethodRestrict = httpMethodRestrict. }
false;public;0;3;;public NettySharedHttpServer getNettySharedHttpServer() {     return nettySharedHttpServer. }
true;public;1;3;/**  * To use a shared Netty HTTP server. See Netty HTTP Server Example for more details.  */ ;/**  * To use a shared Netty HTTP server. See Netty HTTP Server Example for more details.  */ public void setNettySharedHttpServer(NettySharedHttpServer nettySharedHttpServer) {     this.nettySharedHttpServer = nettySharedHttpServer. }
false;public;0;3;;public NettyHttpSecurityConfiguration getSecurityConfiguration() {     return securityConfiguration. }
true;public;1;3;/**  * Refers to a org.apache.camel.component.netty4.http.NettyHttpSecurityConfiguration for configuring secure web resources.  */ ;/**  * Refers to a org.apache.camel.component.netty4.http.NettyHttpSecurityConfiguration for configuring secure web resources.  */ public void setSecurityConfiguration(NettyHttpSecurityConfiguration securityConfiguration) {     this.securityConfiguration = securityConfiguration. }
false;public;0;3;;public Map<String, Object> getSecurityOptions() {     return securityOptions. }
true;public;1;3;/**  * To configure NettyHttpSecurityConfiguration using key/value pairs from the map  */ ;/**  * To configure NettyHttpSecurityConfiguration using key/value pairs from the map  */ public void setSecurityOptions(Map<String, Object> securityOptions) {     this.securityOptions = securityOptions. }
false;public;0;3;;public CookieHandler getCookieHandler() {     return cookieHandler. }
true;public;1;3;/**  * Configure a cookie handler to maintain a HTTP session  */ ;/**  * Configure a cookie handler to maintain a HTTP session  */ public void setCookieHandler(CookieHandler cookieHandler) {     this.cookieHandler = cookieHandler. }
false;protected;0;20;;@Override protected void doStart() throws Exception {     super.doStart().     ObjectHelper.notNull(nettyHttpBinding, "nettyHttpBinding", this).     ObjectHelper.notNull(headerFilterStrategy, "headerFilterStrategy", this).     if (securityConfiguration != null) {         StringHelper.notEmpty(securityConfiguration.getRealm(), "realm", securityConfiguration).         StringHelper.notEmpty(securityConfiguration.getConstraint(), "restricted", securityConfiguration).         if (securityConfiguration.getSecurityAuthenticator() == null) {             // setup default JAAS authenticator if none was configured             JAASSecurityAuthenticator jaas = new JAASSecurityAuthenticator().             jaas.setName(securityConfiguration.getRealm()).             log.info("No SecurityAuthenticator configured, using JAASSecurityAuthenticator as authenticator: {}", jaas).             securityConfiguration.setSecurityAuthenticator(jaas).         }     } }
