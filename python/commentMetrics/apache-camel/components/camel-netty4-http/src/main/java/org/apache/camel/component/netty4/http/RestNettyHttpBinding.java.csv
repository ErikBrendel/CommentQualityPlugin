commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;public RestNettyHttpBinding copy() {     try {         return (RestNettyHttpBinding) this.clone().     } catch (CloneNotSupportedException e) {         throw new RuntimeCamelException(e).     } }
false;public;4;39;;@Override public void populateCamelHeaders(FullHttpRequest request, Map<String, Object> headers, Exchange exchange, NettyHttpConfiguration configuration) throws Exception {     super.populateCamelHeaders(request, headers, exchange, configuration).     String path = request.uri().     if (path == null) {         return.     }     // skip the scheme/host/port etc, as we only want the context-path     URI uri = new URI(path).     path = uri.getPath().     // in the endpoint the user may have defined rest {} placeholders     // so we need to map those placeholders with data from the incoming request context path     String consumerPath = configuration.getPath().     if (useRestMatching(consumerPath)) {         // split using single char / is optimized in the jdk         String[] paths = path.split("/").         String[] consumerPaths = consumerPath.split("/").         for (int i = 0. i < consumerPaths.length. i++) {             if (paths.length < i) {                 break.             }             String p1 = consumerPaths[i].             if (p1.startsWith("{") && p1.endsWith("}")) {                 String key = p1.substring(1, p1.length() - 1).                 String value = paths[i].                 if (value != null) {                     NettyHttpHelper.appendHeader(headers, key, value).                 }             }         }     } }
false;private;1;4;;private boolean useRestMatching(String path) {     // only need to do rest matching if using { } placeholders     return path.indexOf('{') > -1. }
