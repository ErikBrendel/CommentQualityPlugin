commented;modifiers;parameterAmount;loc;comment;code
true;public;1;45;/**  * Producer is a exchange processor. This process is built in several steps. 1. Validate message receive from client 2. Send validated message to CM endpoints. 3. Process response from CM  * endpoints.  */ ;/**  * Producer is a exchange processor. This process is built in several steps. 1. Validate message receive from client 2. Send validated message to CM endpoints. 3. Process response from CM  * endpoints.  */ @Override public void process(final Exchange exchange) throws Exception {     // Immutable message receive from clients. Throws camel ' s     // InvalidPayloadException     final SMSMessage smsMessage = exchange.getIn().getMandatoryBody(SMSMessage.class).     // Validates Payload - SMSMessage     log.trace("Validating SMSMessage instance provided: {}", smsMessage).     final Set<ConstraintViolation<SMSMessage>> constraintViolations = getValidator().validate(smsMessage).     if (constraintViolations.size() > 0) {         final StringBuffer msg = new StringBuffer().         for (final ConstraintViolation<SMSMessage> cv : constraintViolations) {             msg.append(String.format("- Invalid value for %s: %s", cv.getPropertyPath().toString(), cv.getMessage())).         }         log.debug(msg.toString()).         throw new InvalidPayloadRuntimeException(exchange, SMSMessage.class).     }     log.trace("SMSMessage instance is valid: {}", smsMessage).     // We have a valid (immutable) SMSMessage instance, lets extend to     // CMMessage     // This is the instance we will use to build the XML document to be     // sent to CM SMS GW.     final CMMessage cmMessage = new CMMessage(smsMessage.getPhoneNumber(), smsMessage.getMessage()).     log.debug("CMMessage instance build from valid SMSMessage instance").     if (smsMessage.getFrom() == null || smsMessage.getFrom().isEmpty()) {         String df = getConfiguration().getDefaultFrom().         cmMessage.setSender(df).         log.debug("Dynamic sender is set to default dynamic sender: {}", df).     }     // Remember, this can be null.     cmMessage.setIdAsString(smsMessage.getId()).     // Unicode and multipart     cmMessage.setUnicodeAndMultipart(getConfiguration().getDefaultMaxNumberOfParts()).     // 2. Send a validated sms message to CM endpoints     // for abnormal situations.     sender.send(cmMessage).     log.debug("Request accepted by CM Host: {}", cmMessage). }
false;protected;0;25;;@Override protected void doStart() throws Exception {     // log at debug level for singletons, for prototype scoped log at trace     // level to not spam logs     log.debug("Starting CMProducer").     final CMConfiguration configuration = getConfiguration().     if (configuration.isTestConnectionOnStartup()) {         try {             log.debug("Checking connection - {}", getEndpoint().getCMUrl()).             HttpClientBuilder.create().build().execute(new HttpHead(getEndpoint().getCMUrl())).             log.debug("Connection to {}: OK", getEndpoint().getCMUrl()).         } catch (final Exception e) {             throw new HostUnavailableException(String.format("Connection to %s: NOT AVAILABLE", getEndpoint().getCMUrl()), e).         }     }     // keep starting     super.doStart().     log.debug("CMProducer started"). }
false;public;0;4;;@Override public CMEndpoint getEndpoint() {     return (CMEndpoint) super.getEndpoint(). }
false;public;0;3;;public CMConfiguration getConfiguration() {     return getEndpoint().getConfiguration(). }
false;public;0;6;;public Validator getValidator() {     if (validator == null) {         validator = getEndpoint().getComponent().getValidator().     }     return validator. }
false;public;0;3;;public CMSender getSender() {     return sender. }
false;public;1;3;;public void setSender(CMSender sender) {     this.sender = sender. }
