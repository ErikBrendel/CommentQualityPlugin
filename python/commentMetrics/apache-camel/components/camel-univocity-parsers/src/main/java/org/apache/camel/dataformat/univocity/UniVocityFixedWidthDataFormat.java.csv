commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Gets the field lengths.  * It's used to construct uniVocity {@link com.univocity.parsers.fixed.FixedWidthFields} instance.  *  * @return the field lengths  */ ;/**  * Gets the field lengths.  * It's used to construct uniVocity {@link com.univocity.parsers.fixed.FixedWidthFields} instance.  *  * @return the field lengths  */ public int[] getFieldLengths() {     return fieldLengths. }
true;public;1;4;/**  * Sets the field lengths  * It's used to construct uniVocity {@link com.univocity.parsers.fixed.FixedWidthFields} instance.  *  * @param fieldLengths the field length  * @return current data format instance, fluent API  */ ;/**  * Sets the field lengths  * It's used to construct uniVocity {@link com.univocity.parsers.fixed.FixedWidthFields} instance.  *  * @param fieldLengths the field length  * @return current data format instance, fluent API  */ public UniVocityFixedWidthDataFormat setFieldLengths(int[] fieldLengths) {     this.fieldLengths = fieldLengths.     return this. }
true;public;0;3;/**  * Gets whether or not trailing characters until new line must be ignored.  *  * @return whether or not trailing characters until new line must be ignored  * @see com.univocity.parsers.fixed.FixedWidthParserSettings#getSkipTrailingCharsUntilNewline()  */ ;/**  * Gets whether or not trailing characters until new line must be ignored.  *  * @return whether or not trailing characters until new line must be ignored  * @see com.univocity.parsers.fixed.FixedWidthParserSettings#getSkipTrailingCharsUntilNewline()  */ public Boolean getSkipTrailingCharsUntilNewline() {     return skipTrailingCharsUntilNewline. }
true;public;1;4;/**  * Sets whether or not trailing characters until new line must be ignored.  *  * @param skipTrailingCharsUntilNewline whether or not trailing characters until new line must be ignored  * @return current data format instance, fluent API  * @see com.univocity.parsers.fixed.FixedWidthParserSettings#setSkipTrailingCharsUntilNewline(boolean)  */ ;/**  * Sets whether or not trailing characters until new line must be ignored.  *  * @param skipTrailingCharsUntilNewline whether or not trailing characters until new line must be ignored  * @return current data format instance, fluent API  * @see com.univocity.parsers.fixed.FixedWidthParserSettings#setSkipTrailingCharsUntilNewline(boolean)  */ public UniVocityFixedWidthDataFormat setSkipTrailingCharsUntilNewline(Boolean skipTrailingCharsUntilNewline) {     this.skipTrailingCharsUntilNewline = skipTrailingCharsUntilNewline.     return this. }
true;public;0;3;/**  * Gets whether or not the record ends on new line.  *  * @return whether or not the record ends on new line  * @see com.univocity.parsers.fixed.FixedWidthParserSettings#getRecordEndsOnNewline()  */ ;/**  * Gets whether or not the record ends on new line.  *  * @return whether or not the record ends on new line  * @see com.univocity.parsers.fixed.FixedWidthParserSettings#getRecordEndsOnNewline()  */ public Boolean getRecordEndsOnNewline() {     return recordEndsOnNewline. }
true;public;1;4;/**  * Sets whether or not the record ends on new line  *  * @param recordEndsOnNewline whether or not the record ends on new line  * @return current data format instance, fluent API  * @see com.univocity.parsers.fixed.FixedWidthParserSettings#setRecordEndsOnNewline(boolean)  */ ;/**  * Sets whether or not the record ends on new line  *  * @param recordEndsOnNewline whether or not the record ends on new line  * @return current data format instance, fluent API  * @see com.univocity.parsers.fixed.FixedWidthParserSettings#setRecordEndsOnNewline(boolean)  */ public UniVocityFixedWidthDataFormat setRecordEndsOnNewline(Boolean recordEndsOnNewline) {     this.recordEndsOnNewline = recordEndsOnNewline.     return this. }
true;public;0;3;/**  * Gets the padding symbol.  * If {@code null} then the default format value is used.  *  * @return the padding symbol  * @see com.univocity.parsers.fixed.FixedWidthFormat#getPadding()  */ ;/**  * Gets the padding symbol.  * If {@code null} then the default format value is used.  *  * @return the padding symbol  * @see com.univocity.parsers.fixed.FixedWidthFormat#getPadding()  */ public Character getPadding() {     return padding. }
true;public;1;4;/**  * Sets the padding symbol.  * If {@code null} then the default format value is used.  *  * @param padding the padding symbol  * @return current data format instance, fluent API  * @see com.univocity.parsers.fixed.FixedWidthFormat#setPadding(char)  */ ;/**  * Sets the padding symbol.  * If {@code null} then the default format value is used.  *  * @param padding the padding symbol  * @return current data format instance, fluent API  * @see com.univocity.parsers.fixed.FixedWidthFormat#setPadding(char)  */ public UniVocityFixedWidthDataFormat setPadding(Character padding) {     this.padding = padding.     return this. }
true;protected;0;4;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override protected FixedWidthWriterSettings createWriterSettings() {     return new FixedWidthWriterSettings(createFixedWidthFields()). }
true;protected;2;4;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override protected FixedWidthWriter createWriter(Writer writer, FixedWidthWriterSettings settings) {     return new FixedWidthWriter(writer, settings). }
true;protected;0;4;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override protected FixedWidthParserSettings createParserSettings() {     return new FixedWidthParserSettings(createFixedWidthFields()). }
false;protected;1;11;;@Override protected void configureParserSettings(FixedWidthParserSettings settings) {     super.configureParserSettings(settings).     if (skipTrailingCharsUntilNewline != null) {         settings.setSkipTrailingCharsUntilNewline(skipTrailingCharsUntilNewline).     }     if (recordEndsOnNewline != null) {         settings.setRecordEndsOnNewline(true).     } }
true;protected;1;4;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override protected FixedWidthParser createParser(FixedWidthParserSettings settings) {     return new FixedWidthParser(settings). }
true;protected;1;8;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override protected void configureFormat(FixedWidthFormat format) {     super.configureFormat(format).     if (padding != null) {         format.setPadding(padding).     } }
true;private;0;24;/**  * Creates the {@link com.univocity.parsers.fixed.FixedWidthFields} instance based on the headers and field  * lengths.  *  * @return new {@code FixedWidthFields} based on the header and field lengths.  */ ;/**  * Creates the {@link com.univocity.parsers.fixed.FixedWidthFields} instance based on the headers and field  * lengths.  *  * @return new {@code FixedWidthFields} based on the header and field lengths.  */ private FixedWidthFields createFixedWidthFields() {     // Ensure that the field lengths have been defined.     if (fieldLengths == null) {         throw new IllegalArgumentException("The fieldLengths must have been defined in order to use the fixed-width format.").     }     // If there's no header then we only use their length     if (headers == null) {         return new FixedWidthFields(fieldLengths).     }     // Use both headers and field lengths (same size and no duplicate headers)     if (fieldLengths.length != headers.length) {         throw new IllegalArgumentException("The headers and fieldLengths must have the same number of element in order to use the fixed-width format.").     }     LinkedHashMap<String, Integer> fields = new LinkedHashMap<>().     for (int i = 0. i < headers.length. i++) {         fields.put(headers[i], fieldLengths[i]).     }     if (fields.size() != headers.length) {         throw new IllegalArgumentException("The headers cannot have duplicates in order to use the fixed-width format.").     }     return new FixedWidthFields(fields). }
false;public;0;4;;@Override public String getDataFormatName() {     return "univocity-fixed". }
