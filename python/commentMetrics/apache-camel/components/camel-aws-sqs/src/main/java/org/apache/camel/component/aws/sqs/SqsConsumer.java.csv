commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;36;;@Override protected int poll() throws Exception {     // must reset for each poll     shutdownRunningTask = null.     pendingExchanges = 0.     ReceiveMessageRequest request = new ReceiveMessageRequest(getQueueUrl()).     request.setMaxNumberOfMessages(getMaxMessagesPerPoll() > 0 ? getMaxMessagesPerPoll() : null).     request.setVisibilityTimeout(getConfiguration().getVisibilityTimeout() != null ? getConfiguration().getVisibilityTimeout() : null).     request.setWaitTimeSeconds(getConfiguration().getWaitTimeSeconds() != null ? getConfiguration().getWaitTimeSeconds() : null).     if (attributeNames != null) {         request.setAttributeNames(attributeNames).     }     if (messageAttributeNames != null) {         request.setMessageAttributeNames(messageAttributeNames).     }     log.trace("Receiving messages with request [{}]...", request).     ReceiveMessageResult messageResult = null.     try {         messageResult = getClient().receiveMessage(request).     } catch (QueueDoesNotExistException e) {         log.info("Queue does not exist....recreating now...").         reConnectToQueue().         messageResult = getClient().receiveMessage(request).     }     if (log.isTraceEnabled()) {         log.trace("Received {} messages", messageResult.getMessages().size()).     }     Queue<Exchange> exchanges = createExchanges(messageResult.getMessages()).     return processBatch(CastUtils.cast(exchanges)). }
false;public;0;15;;public void reConnectToQueue() {     try {         getEndpoint().createQueue(getClient()).     } catch (QueueDeletedRecentlyException qdr) {         log.debug("Queue recently deleted, will retry in 30 seconds.").         try {             Thread.sleep(30000).             getEndpoint().createQueue(getClient()).         } catch (Exception e) {             log.warn("failed to retry queue connection.", e).         }     } catch (Exception e) {         log.warn("Could not connect to queue in amazon.", e).     } }
false;protected;1;13;;protected Queue<Exchange> createExchanges(List<Message> messages) {     if (log.isTraceEnabled()) {         log.trace("Received {} messages in this poll", messages.size()).     }     Queue<Exchange> answer = new LinkedList<>().     for (Message message : messages) {         Exchange exchange = getEndpoint().createExchange(message).         answer.add(exchange).     }     return answer. }
false;public;1;4;;@Override public void onComplete(Exchange exchange) {     cancelExtender(exchange). }
false;public;1;4;;@Override public void onFailure(Exchange exchange) {     cancelExtender(exchange). }
false;private;1;5;;private void cancelExtender(Exchange exchange) {     // cancel task as we are done     log.trace("Processing done so cancelling TimeoutExtender task for exchangeId: {}", exchange.getExchangeId()).     scheduledFuture.cancel(true). }
false;public;1;3;;public void onComplete(Exchange exchange) {     processCommit(exchange). }
false;public;1;3;;public void onFailure(Exchange exchange) {     processRollback(exchange). }
false;public;0;4;;@Override public String toString() {     return "SqsConsumerOnCompletion". }
false;public;1;4;;@Override public void done(boolean doneSync) {     log.trace("Processing exchange [{}] done.", exchange). }
false;public;1;72;;public int processBatch(Queue<Object> exchanges) throws Exception {     int total = exchanges.size().     for (int index = 0. index < total && isBatchAllowed(). index++) {         // only loop if we are started (allowed to run)         final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll()).         // add current index and total as properties         exchange.setProperty(Exchange.BATCH_INDEX, index).         exchange.setProperty(Exchange.BATCH_SIZE, total).         exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1).         // update pending number of exchanges         pendingExchanges = total - index - 1.         // schedule task to extend visibility if enabled         Integer visibilityTimeout = getConfiguration().getVisibilityTimeout().         if (this.scheduledExecutor != null && visibilityTimeout != null && (visibilityTimeout.intValue() / 2) > 0) {             int delay = visibilityTimeout.intValue() / 2.             int period = visibilityTimeout.intValue().             int repeatSeconds = Double.valueOf(visibilityTimeout.doubleValue() * 1.5).intValue().             if (log.isDebugEnabled()) {                 log.debug("Scheduled TimeoutExtender task to start after {} delay, and run with {}/{} period/repeat (seconds), to extend exchangeId: {}", new Object[] { delay, period, repeatSeconds, exchange.getExchangeId() }).             }             final ScheduledFuture<?> scheduledFuture = this.scheduledExecutor.scheduleAtFixedRate(new TimeoutExtender(exchange, repeatSeconds), delay, period, TimeUnit.SECONDS).             exchange.addOnCompletion(new Synchronization() {                  @Override                 public void onComplete(Exchange exchange) {                     cancelExtender(exchange).                 }                  @Override                 public void onFailure(Exchange exchange) {                     cancelExtender(exchange).                 }                  private void cancelExtender(Exchange exchange) {                     // cancel task as we are done                     log.trace("Processing done so cancelling TimeoutExtender task for exchangeId: {}", exchange.getExchangeId()).                     scheduledFuture.cancel(true).                 }             }).         }         // add on completion to handle after work when the exchange is done         exchange.addOnCompletion(new Synchronization() {              public void onComplete(Exchange exchange) {                 processCommit(exchange).             }              public void onFailure(Exchange exchange) {                 processRollback(exchange).             }              @Override             public String toString() {                 return "SqsConsumerOnCompletion".             }         }).         log.trace("Processing exchange [{}]...", exchange).         getAsyncProcessor().process(exchange, new AsyncCallback() {              @Override             public void done(boolean doneSync) {                 log.trace("Processing exchange [{}] done.", exchange).             }         }).     }     return total. }
true;protected;1;17;/**  * Strategy to delete the message after being processed.  *  * @param exchange the exchange  */ ;/**  * Strategy to delete the message after being processed.  *  * @param exchange the exchange  */ protected void processCommit(Exchange exchange) {     try {         if (shouldDelete(exchange)) {             String receiptHandle = exchange.getIn().getHeader(SqsConstants.RECEIPT_HANDLE, String.class).             DeleteMessageRequest deleteRequest = new DeleteMessageRequest(getQueueUrl(), receiptHandle).             log.trace("Deleting message with receipt handle {}...", receiptHandle).             getClient().deleteMessage(deleteRequest).             log.trace("Deleted message with receipt handle {}...", receiptHandle).         }     } catch (AmazonClientException e) {         getExceptionHandler().handleException("Error occurred during deleting message. This exception is ignored.", exchange, e).     } }
false;private;1;8;;private boolean shouldDelete(Exchange exchange) {     boolean shouldDeleteByFilter = exchange.getProperty(Exchange.FILTER_MATCHED) != null && getConfiguration().isDeleteIfFiltered() && passedThroughFilter(exchange).     return getConfiguration().isDeleteAfterRead() || shouldDeleteByFilter. }
false;private;1;3;;private boolean passedThroughFilter(Exchange exchange) {     return exchange.getProperty(Exchange.FILTER_MATCHED, false, Boolean.class). }
true;protected;1;6;/**  * Strategy when processing the exchange failed.  *  * @param exchange the exchange  */ ;/**  * Strategy when processing the exchange failed.  *  * @param exchange the exchange  */ protected void processRollback(Exchange exchange) {     Exception cause = exchange.getException().     if (cause != null) {         getExceptionHandler().handleException("Error during processing exchange. Will attempt to process the message on next poll.", exchange, cause).     } }
false;protected;0;3;;protected SqsConfiguration getConfiguration() {     return getEndpoint().getConfiguration(). }
false;protected;0;3;;protected AmazonSQS getClient() {     return getEndpoint().getClient(). }
false;protected;0;3;;protected String getQueueUrl() {     return getEndpoint().getQueueUrl(). }
false;public;0;4;;@Override public SqsEndpoint getEndpoint() {     return (SqsEndpoint) super.getEndpoint(). }
false;public;0;7;;@Override public String toString() {     if (sqsConsumerToString == null) {         sqsConsumerToString = "SqsConsumer[" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + "]".     }     return sqsConsumerToString. }
false;protected;0;9;;@Override protected void doStart() throws Exception {     // start scheduler first     if (getConfiguration().isExtendMessageVisibility() && scheduledExecutor == null) {         this.scheduledExecutor = getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "SqsTimeoutExtender").     }     super.doStart(). }
false;protected;0;9;;@Override protected void doShutdown() throws Exception {     if (scheduledExecutor != null) {         getEndpoint().getCamelContext().getExecutorServiceManager().shutdownNow(scheduledExecutor).         scheduledExecutor = null.     }     super.doShutdown(). }
false;public;0;18;;@Override public void run() {     ChangeMessageVisibilityRequest request = new ChangeMessageVisibilityRequest(getQueueUrl(), exchange.getIn().getHeader(SqsConstants.RECEIPT_HANDLE, String.class), repeatSeconds).     try {         log.trace("Extending visibility window by {} seconds for exchange {}", this.repeatSeconds, this.exchange).         getEndpoint().getClient().changeMessageVisibility(request).         log.debug("Extended visibility window by {} seconds for exchange {}", this.repeatSeconds, this.exchange).     } catch (ReceiptHandleIsInvalidException e) {     // Ignore.     } catch (MessageNotInflightException e) {     // Ignore.     } catch (Exception e) {         log.warn("Extending visibility window failed for exchange " + exchange + ". Will not attempt to extend visibility further. This exception will be ignored.", e).     } }
