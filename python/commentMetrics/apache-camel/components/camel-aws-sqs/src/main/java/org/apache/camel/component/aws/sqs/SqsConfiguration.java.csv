commented;modifiers;parameterAmount;loc;comment;code
true;;0;8;/**  *  Whether or not the queue is a FIFO queue  */ ;/**  *  Whether or not the queue is a FIFO queue  */ boolean isFifoQueue() {     // FIFO queue names must end with .fifo, and standard queues cannot     if (queueName.endsWith(".fifo")) {         return true.     }     return false. }
false;public;0;3;;public String getAmazonAWSHost() {     return amazonAWSHost. }
true;public;1;3;/**  * The hostname of the Amazon AWS cloud.  */ ;/**  * The hostname of the Amazon AWS cloud.  */ public void setAmazonAWSHost(String amazonAWSHost) {     this.amazonAWSHost = amazonAWSHost. }
false;public;0;3;;public String getQueueName() {     return queueName. }
true;public;1;3;/**  * Name of queue. The queue will be created if they don't already exists.  */ ;/**  * Name of queue. The queue will be created if they don't already exists.  */ public void setQueueName(String queueName) {     this.queueName = queueName. }
false;public;0;3;;public String getAccessKey() {     return accessKey. }
true;public;1;3;/**  * Amazon AWS Access Key  */ ;/**  * Amazon AWS Access Key  */ public void setAccessKey(String accessKey) {     this.accessKey = accessKey. }
false;public;0;3;;public String getSecretKey() {     return secretKey. }
true;public;1;3;/**  * Amazon AWS Secret Key  */ ;/**  * Amazon AWS Secret Key  */ public void setSecretKey(String secretKey) {     this.secretKey = secretKey. }
false;public;0;3;;public boolean isDeleteAfterRead() {     return deleteAfterRead. }
true;public;1;3;/**  * Delete message from SQS after it has been read  */ ;/**  * Delete message from SQS after it has been read  */ public void setDeleteAfterRead(boolean deleteAfterRead) {     this.deleteAfterRead = deleteAfterRead. }
false;public;0;3;;public AmazonSQS getAmazonSQSClient() {     return amazonSQSClient. }
true;public;1;3;/**  * To use the AmazonSQS as client  */ ;/**  * To use the AmazonSQS as client  */ public void setAmazonSQSClient(AmazonSQS amazonSQSClient) {     this.amazonSQSClient = amazonSQSClient. }
false;public;0;3;;public Integer getVisibilityTimeout() {     return visibilityTimeout. }
true;public;1;3;/**  * The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved  * by a ReceiveMessage request to set in the com.amazonaws.services.sqs.model.SetQueueAttributesRequest.  * This only make sense if its different from defaultVisibilityTimeout.  * It changes the queue visibility timeout attribute permanently.  */ ;/**  * The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved  * by a ReceiveMessage request to set in the com.amazonaws.services.sqs.model.SetQueueAttributesRequest.  * This only make sense if its different from defaultVisibilityTimeout.  * It changes the queue visibility timeout attribute permanently.  */ public void setVisibilityTimeout(Integer visibilityTimeout) {     this.visibilityTimeout = visibilityTimeout. }
false;public;0;3;;public String getAttributeNames() {     return attributeNames. }
true;public;1;3;/**  * A list of attribute names to receive when consuming.  Multiple names can be separated by comma.  */ ;/**  * A list of attribute names to receive when consuming.  Multiple names can be separated by comma.  */ public void setAttributeNames(String attributeNames) {     this.attributeNames = attributeNames. }
false;public;0;3;;public String getMessageAttributeNames() {     return messageAttributeNames. }
true;public;1;3;/**  * A list of message attribute names to receive when consuming. Multiple names can be separated by comma.  */ ;/**  * A list of message attribute names to receive when consuming. Multiple names can be separated by comma.  */ public void setMessageAttributeNames(String messageAttributeNames) {     this.messageAttributeNames = messageAttributeNames. }
false;public;0;3;;public Integer getDefaultVisibilityTimeout() {     return defaultVisibilityTimeout. }
true;public;1;3;/**  * The default visibility timeout (in seconds)  */ ;/**  * The default visibility timeout (in seconds)  */ public void setDefaultVisibilityTimeout(Integer defaultVisibilityTimeout) {     this.defaultVisibilityTimeout = defaultVisibilityTimeout. }
false;public;0;3;;public Integer getDelaySeconds() {     return delaySeconds. }
true;public;1;3;/**  * Delay sending messages for a number of seconds.  */ ;/**  * Delay sending messages for a number of seconds.  */ public void setDelaySeconds(Integer delaySeconds) {     this.delaySeconds = delaySeconds. }
false;public;0;3;;public boolean isDelayQueue() {     return delayQueue. }
true;public;1;3;/**  * Define if you want to apply delaySeconds option to the queue or on single messages  */ ;/**  * Define if you want to apply delaySeconds option to the queue or on single messages  */ public void setDelayQueue(boolean delayQueue) {     this.delayQueue = delayQueue. }
false;public;0;3;;public Integer getMaximumMessageSize() {     return maximumMessageSize. }
true;public;1;3;/**  * The maximumMessageSize (in bytes) an SQS message can contain for this queue.  */ ;/**  * The maximumMessageSize (in bytes) an SQS message can contain for this queue.  */ public void setMaximumMessageSize(Integer maximumMessageSize) {     this.maximumMessageSize = maximumMessageSize. }
false;public;0;3;;public Integer getMessageRetentionPeriod() {     return messageRetentionPeriod. }
true;public;1;3;/**  * The messageRetentionPeriod (in seconds) a message will be retained by SQS for this queue.  */ ;/**  * The messageRetentionPeriod (in seconds) a message will be retained by SQS for this queue.  */ public void setMessageRetentionPeriod(Integer messageRetentionPeriod) {     this.messageRetentionPeriod = messageRetentionPeriod. }
false;public;0;3;;public String getPolicy() {     return policy. }
true;public;1;3;/**  * The policy for this queue  */ ;/**  * The policy for this queue  */ public void setPolicy(String policy) {     this.policy = policy. }
false;public;0;3;;public String getRedrivePolicy() {     return redrivePolicy. }
true;public;1;3;/**  * Specify the policy that send message to DeadLetter queue. See detail at Amazon docs.  */ ;/**  * Specify the policy that send message to DeadLetter queue. See detail at Amazon docs.  */ public void setRedrivePolicy(String redrivePolicy) {     this.redrivePolicy = redrivePolicy. }
false;public;0;3;;public boolean isExtendMessageVisibility() {     return this.extendMessageVisibility. }
true;public;1;3;/**  * If enabled then a scheduled background task will keep extending the message visibility on SQS.  * This is needed if it takes a long time to process the message. If set to true defaultVisibilityTimeout must be set.  * See details at Amazon docs.  */ ;/**  * If enabled then a scheduled background task will keep extending the message visibility on SQS.  * This is needed if it takes a long time to process the message. If set to true defaultVisibilityTimeout must be set.  * See details at Amazon docs.  */ public void setExtendMessageVisibility(boolean extendMessageVisibility) {     this.extendMessageVisibility = extendMessageVisibility. }
false;public;0;3;;public Integer getReceiveMessageWaitTimeSeconds() {     return receiveMessageWaitTimeSeconds. }
true;public;1;3;/**  * If you do not specify WaitTimeSeconds in the request, the queue attribute ReceiveMessageWaitTimeSeconds is used to determine how long to wait.  */ ;/**  * If you do not specify WaitTimeSeconds in the request, the queue attribute ReceiveMessageWaitTimeSeconds is used to determine how long to wait.  */ public void setReceiveMessageWaitTimeSeconds(Integer receiveMessageWaitTimeSeconds) {     this.receiveMessageWaitTimeSeconds = receiveMessageWaitTimeSeconds. }
false;public;0;3;;public Integer getWaitTimeSeconds() {     return waitTimeSeconds. }
true;public;1;3;/**  * Duration in seconds (0 to 20) that the ReceiveMessage action call will wait until a message is in the queue to include in the response.  */ ;/**  * Duration in seconds (0 to 20) that the ReceiveMessage action call will wait until a message is in the queue to include in the response.  */ public void setWaitTimeSeconds(Integer waitTimeSeconds) {     this.waitTimeSeconds = waitTimeSeconds. }
false;public;0;3;;public String getQueueOwnerAWSAccountId() {     return queueOwnerAWSAccountId. }
true;public;1;3;/**  * Specify the queue owner aws account id when you need to connect the queue with different account owner.  */ ;/**  * Specify the queue owner aws account id when you need to connect the queue with different account owner.  */ public void setQueueOwnerAWSAccountId(String queueOwnerAWSAccountId) {     this.queueOwnerAWSAccountId = queueOwnerAWSAccountId. }
false;public;0;3;;public boolean isDeleteIfFiltered() {     return deleteIfFiltered. }
true;public;1;3;/**  * Whether or not to send the DeleteMessage to the SQS queue if an exchange fails to get through a filter.  * If 'false' and exchange does not make it through a Camel filter upstream in the route, then don't send DeleteMessage.  */ ;/**  * Whether or not to send the DeleteMessage to the SQS queue if an exchange fails to get through a filter.  * If 'false' and exchange does not make it through a Camel filter upstream in the route, then don't send DeleteMessage.  */ public void setDeleteIfFiltered(boolean deleteIfFiltered) {     this.deleteIfFiltered = deleteIfFiltered. }
false;public;0;3;;public String getRegion() {     return region. }
true;public;1;3;/**  * Specify the queue region which could be used with queueOwnerAWSAccountId to build the service URL.  */ ;/**  * Specify the queue region which could be used with queueOwnerAWSAccountId to build the service URL.  */ public void setRegion(String region) {     this.region = region. }
false;public;0;3;;public int getConcurrentConsumers() {     return concurrentConsumers. }
true;public;1;3;/**  * Allows you to use multiple threads to poll the sqs queue to increase throughput  */ ;/**  * Allows you to use multiple threads to poll the sqs queue to increase throughput  */ public void setConcurrentConsumers(int concurrentConsumers) {     this.concurrentConsumers = concurrentConsumers. }
false;public;0;3;;public String getQueueUrl() {     return queueUrl. }
true;public;1;3;/**  * To define the queueUrl explicitly. All other parameters, which would influence the queueUrl, are ignored.  * This parameter is intended to be used, to connect to a mock implementation of SQS, for testing purposes.  */ ;/**  * To define the queueUrl explicitly. All other parameters, which would influence the queueUrl, are ignored.  * This parameter is intended to be used, to connect to a mock implementation of SQS, for testing purposes.  */ public void setQueueUrl(String queueUrl) {     this.queueUrl = queueUrl. }
false;public;0;3;;public String getProxyHost() {     return proxyHost. }
true;public;1;3;/**  * To define a proxy host when instantiating the SQS client  */ ;/**  * To define a proxy host when instantiating the SQS client  */ public void setProxyHost(String proxyHost) {     this.proxyHost = proxyHost. }
false;public;0;3;;public Integer getProxyPort() {     return proxyPort. }
true;public;1;3;/**  * To define a proxy port when instantiating the SQS client  */ ;/**  * To define a proxy port when instantiating the SQS client  */ public void setProxyPort(Integer proxyPort) {     this.proxyPort = proxyPort. }
false;public;0;3;;public String getKmsMasterKeyId() {     return kmsMasterKeyId. }
true;public;1;3;/**  * The ID of an AWS-managed customer master key (CMK) for Amazon SQS or a custom CMK.  */ ;/**  * The ID of an AWS-managed customer master key (CMK) for Amazon SQS or a custom CMK.  */ public void setKmsMasterKeyId(String kmsMasterKeyId) {     this.kmsMasterKeyId = kmsMasterKeyId. }
false;public;0;3;;public Integer getKmsDataKeyReusePeriodSeconds() {     return kmsDataKeyReusePeriodSeconds. }
true;public;1;3;/**  * The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt  * messages before calling AWS KMS again. An integer representing seconds, between 60 seconds (1 minute)  * and 86,400 seconds (24 hours). Default: 300 (5 minutes).  */ ;/**  * The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt  * messages before calling AWS KMS again. An integer representing seconds, between 60 seconds (1 minute)  * and 86,400 seconds (24 hours). Default: 300 (5 minutes).  */ public void setKmsDataKeyReusePeriodSeconds(Integer kmsDataKeyReusePeriodSeconds) {     this.kmsDataKeyReusePeriodSeconds = kmsDataKeyReusePeriodSeconds. }
false;public;0;3;;public boolean isServerSideEncryptionEnabled() {     return serverSideEncryptionEnabled. }
true;public;1;3;/**  * Define if Server Side Encryption is enabled or not on the queue  */ ;/**  * Define if Server Side Encryption is enabled or not on the queue  */ public void setServerSideEncryptionEnabled(boolean serverSideEncryptionEnabled) {     this.serverSideEncryptionEnabled = serverSideEncryptionEnabled. }
true;public;1;11;/**  * Only for FIFO queues. Strategy for setting the messageGroupId on the message.  * Can be one of the following options: *useConstant*, *useExchangeId*, *usePropertyValue*.  * For the *usePropertyValue* option, the value of property "CamelAwsMessageGroupId" will be used.  */ ;/**  * Only for FIFO queues. Strategy for setting the messageGroupId on the message.  * Can be one of the following options: *useConstant*, *useExchangeId*, *usePropertyValue*.  * For the *usePropertyValue* option, the value of property "CamelAwsMessageGroupId" will be used.  */ public void setMessageGroupIdStrategy(String strategy) {     if ("useConstant".equalsIgnoreCase(strategy)) {         messageGroupIdStrategy = new ConstantMessageGroupIdStrategy().     } else if ("useExchangeId".equalsIgnoreCase(strategy)) {         messageGroupIdStrategy = new ExchangeIdMessageGroupIdStrategy().     } else if ("usePropertyValue".equalsIgnoreCase(strategy)) {         messageGroupIdStrategy = new PropertyValueMessageGroupIdStrategy().     } else {         throw new IllegalArgumentException("Unrecognised MessageGroupIdStrategy: " + strategy).     } }
false;public;0;3;;public MessageGroupIdStrategy getMessageGroupIdStrategy() {     return messageGroupIdStrategy. }
false;public;0;3;;public MessageDeduplicationIdStrategy getMessageDeduplicationIdStrategy() {     return messageDeduplicationIdStrategy. }
true;public;1;9;/**  * Only for FIFO queues. Strategy for setting the messageDeduplicationId on the message.  * Can be one of the following options: *useExchangeId*, *useContentBasedDeduplication*.  * For the *useContentBasedDeduplication* option, no messageDeduplicationId will be set on the message.  */ ;/**  * Only for FIFO queues. Strategy for setting the messageDeduplicationId on the message.  * Can be one of the following options: *useExchangeId*, *useContentBasedDeduplication*.  * For the *useContentBasedDeduplication* option, no messageDeduplicationId will be set on the message.  */ public void setMessageDeduplicationIdStrategy(String strategy) {     if ("useExchangeId".equalsIgnoreCase(strategy)) {         messageDeduplicationIdStrategy = new ExchangeIdMessageDeduplicationIdStrategy().     } else if ("useContentBasedDeduplication".equalsIgnoreCase(strategy)) {         messageDeduplicationIdStrategy = new NullMessageDeduplicationIdStrategy().     } else {         throw new IllegalArgumentException("Unrecognised MessageDeduplicationIdStrategy: " + strategy).     } }
false;public;0;7;;// ************************************************* //  // ************************************************* public SqsConfiguration copy() {     try {         return (SqsConfiguration) super.clone().     } catch (CloneNotSupportedException e) {         throw new RuntimeCamelException(e).     } }
