commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;public void setBeanFactory(BeanFactory beanFactory) {     this.beanFactory = beanFactory.     if (beanFactory instanceof AutowireCapableBeanFactory) {         autowireCapableBeanFactory = (AutowireCapableBeanFactory) beanFactory.     } }
false;protected;0;3;;protected BeanFactory getBeanFactory() {     return this.beanFactory. }
false;public;1;3;;public void setApplicationContext(ApplicationContext ac) {     this.applicationContext = ac. }
false;protected;0;3;;protected ApplicationContext getApplicationContext() {     return this.applicationContext. }
false;public;1;3;;public Object getBean(String beanName) {     return beanFactory.getBean(beanName). }
false;public;1;3;;public <T> T getBean(Class<T> type) {     return beanFactory.getBean(type). }
false;public;2;3;;public <T> T getBean(String beanName, Class<T> type) {     return beanFactory.getBean(beanName, type). }
true;protected;1;30;/**  * Invoke callbacks on the object, as though it were configured in the factory. If appropriate,  * the object may be wrapped before being returned. For this reason, it is recommended to always  * respect the return value when using this method.  *  * @param   object  object to configure  *  * @return  either the original object or a wrapped one after callbacks called on it.  */ ;/**  * Invoke callbacks on the object, as though it were configured in the factory. If appropriate,  * the object may be wrapped before being returned. For this reason, it is recommended to always  * respect the return value when using this method.  *  * @param   object  object to configure  *  * @return  either the original object or a wrapped one after callbacks called on it.  */ protected <T> T getConfigured(T object) {     if (this.autowireCapableBeanFactory == null) {         throw new UnsupportedOperationException("Cannot configure object - not running in an AutowireCapableBeanFactory").     }     // See SPR-4955     @SuppressWarnings("unchecked")     T configuredObject = (T) autowireCapableBeanFactory.initializeBean(object, null).     // this block copied from ApplicationContextAwareProcessor.  See SJC-149.     if (this.applicationContext != null) {         if (configuredObject instanceof ResourceLoaderAware) {             ((ResourceLoaderAware) configuredObject).setResourceLoader(this.applicationContext).         }         if (configuredObject instanceof ApplicationEventPublisherAware) {             ((ApplicationEventPublisherAware) configuredObject).setApplicationEventPublisher(this.applicationContext).         }         if (configuredObject instanceof MessageSourceAware) {             ((MessageSourceAware) configuredObject).setMessageSource(this.applicationContext).         }         if (configuredObject instanceof ApplicationContextAware) {             ((ApplicationContextAware) configuredObject).setApplicationContext(this.applicationContext).         }     }     return configuredObject. }
true;public;1;5;/**  * Get's the {@link ProducerTemplate} to be used.  */ ;/**  * Get's the {@link ProducerTemplate} to be used.  */ @Bean(initMethod = "", destroyMethod = "") public // Camel handles the lifecycle of this bean ProducerTemplate producerTemplate(CamelContext camelContext) throws Exception {     return camelContext.createProducerTemplate(). }
true;public;1;5;/**  * Get's the {@link ConsumerTemplate} to be used.  */ ;/**  * Get's the {@link ConsumerTemplate} to be used.  */ @Bean(initMethod = "", destroyMethod = "") public // Camel handles the lifecycle of this bean ConsumerTemplate consumerTemplate(CamelContext camelContext) throws Exception {     return camelContext.createConsumerTemplate(). }
true;public;0;7;/**  * Camel post processor - required to support Camel annotations.  */ ;/**  * Camel post processor - required to support Camel annotations.  */ @Bean public CamelBeanPostProcessor camelBeanPostProcessor() throws Exception {     CamelBeanPostProcessor answer = new CamelBeanPostProcessor().     answer.setApplicationContext(getApplicationContext()).     // do not set CamelContext as we will lazy evaluate that later     return answer. }
true;public;0;7;/**  * Get's the {@link CamelContext} to be used.  */ ;/**  * Get's the {@link CamelContext} to be used.  */ @Bean public CamelContext camelContext() throws Exception {     CamelContext camelContext = createCamelContext().     setupCamelContext(camelContext).     camelContext.init().     return camelContext. }
false;;1;4;;@Bean RoutesCollector routesCollector(ApplicationContext applicationContext) {     return new RoutesCollector(applicationContext, this). }
true;protected;1;3;/**  * Callback to setup {@link CamelContext} before its started  */ ;/**  * Callback to setup {@link CamelContext} before its started  */ protected void setupCamelContext(CamelContext camelContext) throws Exception { // noop }
true;protected;0;3;/**  * Factory method returning {@link CamelContext} used by this configuration.  *  * @return {@link CamelContext} used by this configuration. By default {@link SpringCamelContext} instance is  * created, to fully integrate Spring application context and Camel registry.  */ ;/**  * Factory method returning {@link CamelContext} used by this configuration.  *  * @return {@link CamelContext} used by this configuration. By default {@link SpringCamelContext} instance is  * created, to fully integrate Spring application context and Camel registry.  */ protected CamelContext createCamelContext() throws Exception {     return new SpringCamelContext(getApplicationContext()). }
true;public;0;12;/**  * Returns the list of routes to use in this configuration. By default autowires all  * {@link org.apache.camel.builder.RouteBuilder} instances available in the  * {@link org.springframework.context.ApplicationContext}.  */ ;/**  * Returns the list of routes to use in this configuration. By default autowires all  * {@link org.apache.camel.builder.RouteBuilder} instances available in the  * {@link org.springframework.context.ApplicationContext}.  */ public List<RouteBuilder> routes() {     if (this.applicationContext != null) {         Map<String, RouteBuilder> routeBuildersMap = applicationContext.getBeansOfType(RouteBuilder.class).         List<RouteBuilder> routeBuilders = new ArrayList<>(routeBuildersMap.size()).         for (RouteBuilder routeBuilder : routeBuildersMap.values()) {             routeBuilders.add(routeBuilder).         }         return routeBuilders.     } else {         return emptyList().     } }
