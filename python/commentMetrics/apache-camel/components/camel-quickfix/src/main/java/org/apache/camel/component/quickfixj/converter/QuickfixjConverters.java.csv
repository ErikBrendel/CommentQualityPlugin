commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;4;;@Converter public static SessionID toSessionID(String sessionID) {     return new SessionID(sessionID). }
false;public,static;2;5;;@Converter public static Message toMessage(String value, Exchange exchange) throws InvalidMessage, ConfigError {     DataDictionary dataDictionary = getDataDictionary(exchange).     return new Message(value, dataDictionary). }
false;public,static;2;21;;@Converter public static Message toMessage(byte[] value, Exchange exchange) throws InvalidMessage, ConfigError, UnsupportedEncodingException {     DataDictionary dataDictionary = getDataDictionary(exchange).     String charsetName = ExchangeHelper.getCharsetName(exchange).     String message.     if (charsetName != null) {         message = new String(value, charsetName).     } else {         message = new String(value).     }     // if message ends with any sort of newline trim it so QuickfixJ's doesn't fail while parsing the string     if (message.endsWith("\r\n")) {         message = message.substring(0, message.length() - 2).     } else if (message.endsWith("\r") || message.endsWith("\n")) {         message = message.substring(0, message.length() - 1).     }     return new Message(message, dataDictionary, false). }
false;public,static;2;12;;@Converter public static InputStream toInputStream(Message value, Exchange exchange) throws InvalidMessage, ConfigError, UnsupportedEncodingException {     if (exchange != null) {         String charsetName = ExchangeHelper.getCharsetName(exchange).         if (charsetName != null) {             return new ByteArrayInputStream(value.toString().getBytes(charsetName)).         } else {             return new ByteArrayInputStream(value.toString().getBytes()).         }     }     return null. }
false;private,static;1;18;;private static DataDictionary getDataDictionary(Exchange exchange) throws ConfigError {     Object dictionaryValue = exchange.getProperties().get(QuickfixjEndpoint.DATA_DICTIONARY_KEY).     DataDictionary dataDictionary = null.     if (dictionaryValue instanceof DataDictionary) {         dataDictionary = (DataDictionary) dictionaryValue.     } else if (dictionaryValue instanceof String) {         dataDictionary = new DataDictionary((String) dictionaryValue).     } else {         SessionID sessionID = exchange.getIn().getHeader(QuickfixjEndpoint.SESSION_ID_KEY, SessionID.class).         if (sessionID != null) {             Session session = Session.lookupSession(sessionID).             dataDictionary = session != null ? session.getDataDictionary() : null.         }     }     return dataDictionary. }
false;public,static;4;3;;public static Exchange toExchange(Endpoint endpoint, SessionID sessionID, Message message, QuickfixjEventCategory eventCategory) {     return toExchange(endpoint, sessionID, message, eventCategory, ExchangePattern.InOnly). }
false;public,static;5;18;;public static Exchange toExchange(Endpoint endpoint, SessionID sessionID, Message message, QuickfixjEventCategory eventCategory, ExchangePattern exchangePattern) {     Exchange exchange = endpoint.createExchange(exchangePattern).     org.apache.camel.Message camelMessage = exchange.getIn().     camelMessage.setHeader(EVENT_CATEGORY_KEY, eventCategory).     camelMessage.setHeader(SESSION_ID_KEY, sessionID).     if (message != null) {         try {             camelMessage.setHeader(MESSAGE_TYPE_KEY, message.getHeader().getString(MsgType.FIELD)).         } catch (FieldNotFound e) {             LOG.warn("Message type field not found in QFJ message: {}, continuing...", message).         }     }     camelMessage.setBody(message).     return exchange. }
