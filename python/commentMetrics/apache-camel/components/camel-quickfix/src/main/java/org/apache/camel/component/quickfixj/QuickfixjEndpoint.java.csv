commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public SessionID getSessionID() {     return sessionID. }
true;public;1;3;/**  * The optional sessionID identifies a specific FIX session. The format of the sessionID is:  * (BeginString):(SenderCompID)[/(SenderSubID)[/(SenderLocationID)]]->(TargetCompID)[/(TargetSubID)[/(TargetLocationID)]]  */ ;/**  * The optional sessionID identifies a specific FIX session. The format of the sessionID is:  * (BeginString):(SenderCompID)[/(SenderSubID)[/(SenderLocationID)]]->(TargetCompID)[/(TargetSubID)[/(TargetLocationID)]]  */ public void setSessionID(SessionID sessionID) {     this.sessionID = sessionID. }
false;public;0;3;;public String getConfigurationName() {     return configurationName. }
true;public;1;3;/**  * The configFile is the name of the QuickFIX/J configuration to use for the FIX engine (located as a resource found in your classpath).  */ ;/**  * The configFile is the name of the QuickFIX/J configuration to use for the FIX engine (located as a resource found in your classpath).  */ public void setConfigurationName(String configurationName) {     this.configurationName = configurationName. }
false;public;0;3;;public boolean isLazyCreateEngine() {     return lazyCreateEngine. }
true;public;1;3;/**  * This option allows to create QuickFIX/J engine on demand.  * Value true means the engine is started when first message is send or there's consumer configured in route definition.  * When false value is used, the engine is started at the endpoint creation.  * When this parameter is missing, the value of component's property lazyCreateEngines is being used.  */ ;/**  * This option allows to create QuickFIX/J engine on demand.  * Value true means the engine is started when first message is send or there's consumer configured in route definition.  * When false value is used, the engine is started at the endpoint creation.  * When this parameter is missing, the value of component's property lazyCreateEngines is being used.  */ public void setLazyCreateEngine(boolean lazyCreateEngine) {     this.lazyCreateEngine = lazyCreateEngine. }
false;public;1;8;;@Override public Consumer createConsumer(Processor processor) throws Exception {     log.info("Creating QuickFIX/J consumer: {}, ExchangePattern={}", sessionID != null ? sessionID : "No Session", getExchangePattern()).     QuickfixjConsumer consumer = new QuickfixjConsumer(this, processor).     configureConsumer(consumer).     consumers.add(consumer).     return consumer. }
false;public;0;8;;@Override public Producer createProducer() throws Exception {     log.info("Creating QuickFIX/J producer: {}", sessionID != null ? sessionID : "No Session").     if (isWildcarded()) {         throw new ResolveEndpointFailedException("Cannot create consumer on wildcarded session identifier: " + sessionID).     }     return new QuickfixjProducer(this). }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;public;3;12;;@Override public void onEvent(QuickfixjEventCategory eventCategory, SessionID sessionID, Message message) throws Exception {     if (this.sessionID == null || isMatching(sessionID)) {         for (QuickfixjConsumer consumer : consumers) {             Exchange exchange = QuickfixjConverters.toExchange(this, sessionID, message, eventCategory, getExchangePattern()).             consumer.onExchange(exchange).             if (exchange.getException() != null) {                 throw exchange.getException().             }         }     } }
false;private;1;12;;private boolean isMatching(SessionID sessionID) {     if (this.sessionID.equals(sessionID)) {         return true.     }     return isMatching(this.sessionID.getBeginString(), sessionID.getBeginString()) && isMatching(this.sessionID.getSenderCompID(), sessionID.getSenderCompID()) && isMatching(this.sessionID.getSenderSubID(), sessionID.getSenderSubID()) && isMatching(this.sessionID.getSenderLocationID(), sessionID.getSenderLocationID()) && isMatching(this.sessionID.getTargetCompID(), sessionID.getTargetCompID()) && isMatching(this.sessionID.getTargetSubID(), sessionID.getTargetSubID()) && isMatching(this.sessionID.getTargetLocationID(), sessionID.getTargetLocationID()). }
false;private;2;3;;private boolean isMatching(String s1, String s2) {     return s1.equals("") || s1.equals("*") || s1.equals(s2). }
false;private;0;12;;private boolean isWildcarded() {     if (sessionID == null) {         return false.     }     return sessionID.getBeginString().equals("*") || sessionID.getSenderCompID().equals("*") || sessionID.getSenderSubID().equals("*") || sessionID.getSenderLocationID().equals("*") || sessionID.getTargetCompID().equals("*") || sessionID.getTargetSubID().equals("*") || sessionID.getTargetLocationID().equals("*"). }
false;public;0;4;;@Override public boolean isMultipleConsumersSupported() {     return true. }
true;public;0;10;/**  * Initializing and starts the engine if it wasn't initialized so far.  */ ;/**  * Initializing and starts the engine if it wasn't initialized so far.  */ public void ensureInitialized() throws Exception {     if (!engine.isInitialized()) {         synchronized (engine) {             if (!engine.isInitialized()) {                 engine.initializeEngine().                 engine.start().             }         }     } }
false;public;0;3;;public QuickfixjEngine getEngine() {     return engine. }
false;protected;0;5;;@Override protected void doStop() throws Exception {     // clear list of consumers     consumers.clear(). }
