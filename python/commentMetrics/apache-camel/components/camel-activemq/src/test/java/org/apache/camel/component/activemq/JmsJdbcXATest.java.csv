commented;modifiers;parameterAmount;loc;comment;code
false;public;0;19;;public java.sql.Connection initDb() throws Exception {     String createStatement = "CREATE TABLE SCP_INPUT_MESSAGES (" + "id int NOT NULL GENERATED ALWAYS AS IDENTITY, " + "messageId varchar(96) NOT NULL, " + "messageCorrelationId varchar(96) NOT NULL, " + "messageContent varchar(2048) NOT NULL, " + "PRIMARY KEY (id) )".     java.sql.Connection conn = getJDBCConnection().     try {         conn.createStatement().execute(createStatement).     } catch (SQLException alreadyExists) {         log.info("ex on create tables", alreadyExists).     }     try {         conn.createStatement().execute("DELETE FROM SCP_INPUT_MESSAGES").     } catch (SQLException ex) {         log.info("ex on create delete all", ex).     }     return conn. }
false;private;0;4;;private java.sql.Connection getJDBCConnection() throws Exception {     DataSource dataSource = getMandatoryBean(DataSource.class, "managedDataSourceWithRecovery").     return dataSource.getConnection(). }
false;private;1;9;;private int dumpDb(java.sql.Connection jdbcConn) throws Exception {     int count = 0.     ResultSet resultSet = jdbcConn.createStatement().executeQuery("SELECT * FROM SCP_INPUT_MESSAGES").     while (resultSet.next()) {         count++.         log.info("message - seq:" + resultSet.getInt(1) + ", id: " + resultSet.getString(2) + ", corr: " + resultSet.getString(3) + ", content: " + resultSet.getString(4)).     }     return count. }
false;public;0;4;;@Override public boolean isSatisified() throws Exception {     return broker.getBroker().getPreparedTransactions(null).length == 0. }
false;public;0;4;;@Override public boolean isSatisified() throws Exception {     return 1 == dumpDb(freshConnection). }
false;public;0;4;;@Override public boolean isSatisified() throws Exception {     return 2 == dumpDb(freshConnection). }
false;public;0;48;;@Test public void testRecoveryCommit() throws Exception {     java.sql.Connection jdbcConn = initDb().     sendJMSMessageToKickOffRoute().     LOG.info("waiting for route to kick in, it will kill the broker on first 2pc commit").     // will be stopped by the plugin on first 2pc commit     broker.waitUntilStopped().     assertEquals("message in db, commit to db worked", 1, dumpDb(jdbcConn)).     LOG.info("Broker stopped, restarting...").     broker = createBroker(false).     broker.start().     broker.waitUntilStarted().     assertEquals("pending transactions", 1, broker.getBroker().getPreparedTransactions(null).length).     // TM stays actively committing first message ack which won't get     // redelivered - xa once only delivery     LOG.info("waiting for recovery to complete").     assertTrue("recovery complete in time", Wait.waitFor(new Wait.Condition() {          @Override         public boolean isSatisified() throws Exception {             return broker.getBroker().getPreparedTransactions(null).length == 0.         }     })).     // verify recovery complete     assertEquals("recovery complete", 0, broker.getBroker().getPreparedTransactions(null).length).     final java.sql.Connection freshConnection = getJDBCConnection().     assertTrue("did not get replay", Wait.waitFor(new Wait.Condition() {          @Override         public boolean isSatisified() throws Exception {             return 1 == dumpDb(freshConnection).         }     })).     assertEquals("still one message in db", 1, dumpDb(freshConnection)).     // let once complete ok     sendJMSMessageToKickOffRoute().     assertTrue("got second message", Wait.waitFor(new Wait.Condition() {          @Override         public boolean isSatisified() throws Exception {             return 2 == dumpDb(freshConnection).         }     })).     assertEquals("two messages in db", 2, dumpDb(freshConnection)). }
false;private;0;12;;private void sendJMSMessageToKickOffRoute() throws Exception {     ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("vm://testXA").     factory.setWatchTopicAdvisories(false).     Connection connection = factory.createConnection().     connection.start().     Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE).     MessageProducer producer = session.createProducer(new ActiveMQQueue("scp_transacted")).     TextMessage message = session.createTextMessage("Some Text, messageCount:" + messageCount++).     message.setJMSCorrelationID("pleaseCorrelate").     producer.send(message).     connection.close(). }
false;private;1;10;;private BrokerService createBroker(boolean deleteAllMessages) throws Exception {     BrokerService brokerService = new BrokerService().     brokerService.setDeleteAllMessagesOnStartup(deleteAllMessages).     brokerService.setBrokerName("testXA").     brokerService.setAdvisorySupport(false).     brokerService.setUseJmx(false).     brokerService.setDataDirectory("target/data").     brokerService.addConnector("tcp://0.0.0.0:61616").     return brokerService. }
false;public;0;9;;@Override public void run() {     LOG.info("Stopping broker post commit...").     try {         broker.stop().     } catch (Exception e) {         e.printStackTrace().     } }
false;public;3;21;;@Override public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {     if (onePhase) {         super.commitTransaction(context, xid, onePhase).     } else {         // die before doing the commit         // so commit will hang as if reply is lost         context.setDontSendReponse(true).         Executors.newSingleThreadExecutor().execute(new Runnable() {              @Override             public void run() {                 LOG.info("Stopping broker post commit...").                 try {                     broker.stop().                 } catch (Exception e) {                     e.printStackTrace().                 }             }         }).     } }
false;protected;0;39;;@SuppressWarnings("unchecked") @Override protected AbstractXmlApplicationContext createApplicationContext() {     deleteDirectory("target/data/howl").     // make broker available to recovery processing on app context start     try {         broker = createBroker(true).         broker.setPlugins(new BrokerPlugin[] { new BrokerPluginSupport() {              @Override             public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {                 if (onePhase) {                     super.commitTransaction(context, xid, onePhase).                 } else {                     // die before doing the commit                     // so commit will hang as if reply is lost                     context.setDontSendReponse(true).                     Executors.newSingleThreadExecutor().execute(new Runnable() {                          @Override                         public void run() {                             LOG.info("Stopping broker post commit...").                             try {                                 broker.stop().                             } catch (Exception e) {                                 e.printStackTrace().                             }                         }                     }).                 }             }         } }).         broker.start().     } catch (Exception e) {         throw new RuntimeException("Failed to start broker", e).     }     return new ClassPathXmlApplicationContext("org/apache/camel/component/activemq/jmsXajdbc.xml"). }
