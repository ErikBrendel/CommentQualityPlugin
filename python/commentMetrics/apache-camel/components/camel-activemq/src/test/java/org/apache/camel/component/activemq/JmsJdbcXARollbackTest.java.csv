commented;modifiers;parameterAmount;loc;comment;code
false;public;0;19;;public java.sql.Connection initDb() throws Exception {     String createStatement = "CREATE TABLE SCP_INPUT_MESSAGES (" + "id int NOT NULL GENERATED ALWAYS AS IDENTITY, " + "messageId varchar(96) NOT NULL, " + "messageCorrelationId varchar(96) NOT NULL, " + "messageContent varchar(2048) NOT NULL, " + "PRIMARY KEY (id) )".     java.sql.Connection conn = getJDBCConnection().     try {         conn.createStatement().execute(createStatement).     } catch (SQLException alreadyExists) {         log.info("ex on create tables", alreadyExists).     }     try {         conn.createStatement().execute("DELETE FROM SCP_INPUT_MESSAGES").     } catch (SQLException ex) {         log.info("ex on create delete all", ex).     }     return conn. }
false;private;0;4;;private java.sql.Connection getJDBCConnection() throws Exception {     DataSource dataSource = getMandatoryBean(DataSource.class, "managedDataSourceWithRecovery").     return dataSource.getConnection(). }
false;private;1;9;;private int dumpDb(java.sql.Connection jdbcConn) throws Exception {     int count = 0.     ResultSet resultSet = jdbcConn.createStatement().executeQuery("SELECT * FROM SCP_INPUT_MESSAGES").     while (resultSet.next()) {         count++.         log.info("message - seq:" + resultSet.getInt(1) + ", id: " + resultSet.getString(2) + ", corr: " + resultSet.getString(3) + ", content: " + resultSet.getString(4)).     }     return count. }
false;public;0;4;;@Override public boolean isSatisified() throws Exception {     return consumedFrom(SharedDeadLetterStrategy.DEFAULT_DEAD_LETTER_QUEUE_NAME). }
false;public;0;18;;@Test public void testConsumeRollback() throws Exception {     java.sql.Connection jdbcConn = initDb().     initTMRef().     sendJMSMessageToKickOffRoute().     // should go to dlq eventually     Wait.waitFor(new Wait.Condition() {          @Override         public boolean isSatisified() throws Exception {             return consumedFrom(SharedDeadLetterStrategy.DEFAULT_DEAD_LETTER_QUEUE_NAME).         }     }).     assertEquals("message in db, commit to db worked", 0, dumpDb(jdbcConn)).     assertFalse("Nothing to to out q", consumedFrom("scp_transacted_out")). }
false;private;1;12;;private boolean consumedFrom(String qName) throws Exception {     ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("vm://testXA").     factory.setWatchTopicAdvisories(false).     Connection connection = factory.createConnection().     connection.start().     Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE).     MessageConsumer consumer = session.createConsumer(new ActiveMQQueue(qName)).     Message message = consumer.receive(500).     LOG.info("Got from queue:{} {}", qName, message).     connection.close().     return message != null. }
false;private;0;4;;private void initTMRef() {     transactionManager[0] = getMandatoryBean(JtaTransactionManager.class, "jtaTransactionManager").getTransactionManager(). }
false;private;0;12;;private void sendJMSMessageToKickOffRoute() throws Exception {     ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("vm://testXA").     factory.setWatchTopicAdvisories(false).     Connection connection = factory.createConnection().     connection.start().     Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE).     MessageProducer producer = session.createProducer(new ActiveMQQueue("scp_transacted")).     TextMessage message = session.createTextMessage("Some Text, messageCount:" + messageCount++).     message.setJMSCorrelationID("pleaseCorrelate").     producer.send(message).     connection.close(). }
false;private;1;10;;private BrokerService createBroker(boolean deleteAllMessages) throws Exception {     BrokerService brokerService = new BrokerService().     brokerService.setDeleteAllMessagesOnStartup(deleteAllMessages).     brokerService.setBrokerName("testXA").     brokerService.setAdvisorySupport(false).     brokerService.setUseJmx(false).     brokerService.setDataDirectory("target/data").     brokerService.addConnector("tcp://0.0.0.0:61616").     return brokerService. }
false;protected;0;16;;@SuppressWarnings("unchecked") @Override protected AbstractXmlApplicationContext createApplicationContext() {     deleteDirectory("target/data/howl").     // make broker available to recovery processing on app context start     try {         broker = createBroker(true).         broker.start().     } catch (Exception e) {         throw new RuntimeException("Failed to start broker", e).     }     return new ClassPathXmlApplicationContext("org/apache/camel/component/activemq/jmsXajdbcRollback.xml"). }
false;public;1;9;;public String enrich(Exchange exchange) throws Exception {     LOG.info("Got exchange: " + exchange).     LOG.info("Got message: " + ((JmsMessage) exchange.getIn()).getJmsMessage()).     LOG.info("Current tx: " + transactionManager[0].getTransaction()).     LOG.info("Marking rollback only...").     transactionManager[0].getTransaction().setRollbackOnly().     return "Some Text". }
