commented;modifiers;parameterAmount;loc;comment;code
false;private;0;5;;private void createBroker() throws Exception {     brokerService = new BrokerService().     brokerService.addConnector(BROKER_URL).     brokerService.start(). }
false;public;1;3;;public void consume(@Body String message) {     LOG.info("consume message = " + message). }
false;public;0;4;;@Override public void configure() throws Exception {     from(queueEndpointName).bean(Consumer.class, "consume"). }
false;private;0;15;;private void createCamelContext() throws Exception {     LOG.info("creating context and sending message").     camelContext = new DefaultCamelContext().     camelContext.addComponent("activemq", ActiveMQComponent.activeMQComponent(BROKER_URL)).     final String queueEndpointName = "activemq:queue" + QUEUE_NAME.     camelContext.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             from(queueEndpointName).bean(Consumer.class, "consume").         }     }).     camelContext.start().     final ProducerTemplate producerTemplate = camelContext.createProducerTemplate().     producerTemplate.sendBody(queueEndpointName, "message"). }
false;private;0;5;;private void destroyCamelContext() throws Exception {     LOG.info("destroying context").     camelContext.stop().     camelContext = null. }
false;public;0;15;;public void testConnections() {     try {         createBroker().         int i = 0.         while (i++ < 5) {             createCamelContext().             Thread.sleep(1000).             destroyCamelContext().             Thread.sleep(1000).             assertEquals(0, brokerService.getConnectorByName(BROKER_URL).getConnections().size()).         }     } catch (Exception e) {         LOG.warn("run", e).     } }
