commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getBrokerURL() {     return brokerURL. }
true;public;1;3;/**  * Sets the broker URL to use to connect to ActiveMQ using the  * <a href="http://activemq.apache.org/configuring-transports.html">ActiveMQ  * URI format</a>  *  * @param brokerURL the URL of the broker.  */ ;/**  * Sets the broker URL to use to connect to ActiveMQ using the  * <a href="http://activemq.apache.org/configuring-transports.html">ActiveMQ  * URI format</a>  *  * @param brokerURL the URL of the broker.  */ public void setBrokerURL(String brokerURL) {     this.brokerURL = brokerURL. }
false;public;0;3;;public boolean isUseSingleConnection() {     return useSingleConnection. }
true;public;0;4;/**  * @deprecated - use JmsConfiguration#getUsername()  * @see JmsConfiguration#getUsername()  */ ;/**  * @deprecated - use JmsConfiguration#getUsername()  * @see JmsConfiguration#getUsername()  */ @Deprecated public String getUserName() {     return getUsername(). }
true;public;1;4;/**  * @deprecated - use JmsConfiguration#setUsername(String)  * @see JmsConfiguration#setUsername(String)  */ ;/**  * @deprecated - use JmsConfiguration#setUsername(String)  * @see JmsConfiguration#setUsername(String)  */ @Deprecated public void setUserName(String userName) {     setUsername(userName). }
true;public;1;3;/**  * Enables or disables whether a Spring {@link SingleConnectionFactory} will  * be used so that when messages are sent to ActiveMQ from outside of a  * message consuming thread, pooling will be used rather than the default  * with the Spring {@link JmsTemplate} which will create a new connection,  * session, producer for each message then close them all down again.  * <p/>  * The default value is false and a pooled connection is used by default.  */ ;/**  * Enables or disables whether a Spring {@link SingleConnectionFactory} will  * be used so that when messages are sent to ActiveMQ from outside of a  * message consuming thread, pooling will be used rather than the default  * with the Spring {@link JmsTemplate} which will create a new connection,  * session, producer for each message then close them all down again.  * <p/>  * The default value is false and a pooled connection is used by default.  */ public void setUseSingleConnection(boolean useSingleConnection) {     this.useSingleConnection = useSingleConnection. }
false;public;0;3;;public boolean isUsePooledConnection() {     return usePooledConnection. }
true;public;1;3;/**  * Enables or disables whether a PooledConnectionFactory will be used so  * that when messages are sent to ActiveMQ from outside of a message  * consuming thread, pooling will be used rather than the default with the  * Spring {@link JmsTemplate} which will create a new connection, session,  * producer for each message then close them all down again.  * <p/>  * The default value is true. Note that this requires an extra dependency on  * commons-pool2.  */ ;/**  * Enables or disables whether a PooledConnectionFactory will be used so  * that when messages are sent to ActiveMQ from outside of a message  * consuming thread, pooling will be used rather than the default with the  * Spring {@link JmsTemplate} which will create a new connection, session,  * producer for each message then close them all down again.  * <p/>  * The default value is true. Note that this requires an extra dependency on  * commons-pool2.  */ public void setUsePooledConnection(boolean usePooledConnection) {     this.usePooledConnection = usePooledConnection. }
false;public;0;3;;public boolean isTrustAllPackages() {     return trustAllPackages. }
true;public;1;3;/**  * ObjectMessage objects depend on Java serialization of marshal/unmarshal  * object payload. This process is generally considered unsafe as malicious  * payload can exploit the host system. That's why starting with versions  * 5.12.2 and 5.13.0, ActiveMQ enforces users to explicitly whitelist  * packages that can be exchanged using ObjectMessages. <br/>  * This option can be set to <tt>true</tt> to trust all packages (eg  * whitelist is *).  * <p/>  * See more details at: http://activemq.apache.org/objectmessage.html  */ ;/**  * ObjectMessage objects depend on Java serialization of marshal/unmarshal  * object payload. This process is generally considered unsafe as malicious  * payload can exploit the host system. That's why starting with versions  * 5.12.2 and 5.13.0, ActiveMQ enforces users to explicitly whitelist  * packages that can be exchanged using ObjectMessages. <br/>  * This option can be set to <tt>true</tt> to trust all packages (eg  * whitelist is *).  * <p/>  * See more details at: http://activemq.apache.org/objectmessage.html  */ public void setTrustAllPackages(boolean trustAllPackages) {     this.trustAllPackages = trustAllPackages. }
true;protected;0;6;/**  * Factory method to create a default transaction manager if one is not  * specified  */ ;/**  * Factory method to create a default transaction manager if one is not  * specified  */ @Override protected PlatformTransactionManager createTransactionManager() {     JmsTransactionManager answer = new JmsTransactionManager(getConnectionFactory()).     answer.afterPropertiesSet().     return answer. }
false;protected;1;3;;protected void setActiveMQComponent(ActiveMQComponent activeMQComponent) {     this.activeMQComponent = activeMQComponent. }
false;protected;0;30;;@Override protected ConnectionFactory createConnectionFactory() {     ActiveMQConnectionFactory answer = new ActiveMQConnectionFactory().     answer.setTrustAllPackages(trustAllPackages).     if (getUsername() != null) {         answer.setUserName(getUsername()).     }     if (getPassword() != null) {         answer.setPassword(getPassword()).     }     if (answer.getBeanName() == null) {         answer.setBeanName("Camel").     }     answer.setBrokerURL(getBrokerURL()).     if (isUseSingleConnection()) {         SingleConnectionFactory scf = new SingleConnectionFactory(answer).         if (activeMQComponent != null) {             activeMQComponent.addSingleConnectionFactory(scf).         }         return scf.     } else if (isUsePooledConnection()) {         ConnectionFactory pcf = createPooledConnectionFactory(answer).         if (activeMQComponent != null) {             activeMQComponent.addPooledConnectionFactoryService((Service) pcf).         }         return pcf.     } else {         return answer.     } }
false;protected;1;12;;protected ConnectionFactory createPooledConnectionFactory(ActiveMQConnectionFactory connectionFactory) {     // for folks not using this option     try {         Class type = loadClass("org.apache.activemq.pool.PooledConnectionFactory", getClass().getClassLoader()).         Constructor constructor = type.getConstructor(org.apache.activemq.ActiveMQConnectionFactory.class).         return (ConnectionFactory) constructor.newInstance(connectionFactory).     } catch (Exception e) {         throw new RuntimeException("Failed to instantiate PooledConnectionFactory: " + e, e).     } }
false;public,static;2;16;;public static Class<?> loadClass(String name, ClassLoader loader) throws ClassNotFoundException {     ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader().     if (contextClassLoader != null) {         try {             return contextClassLoader.loadClass(name).         } catch (ClassNotFoundException e) {             try {                 return loader.loadClass(name).             } catch (ClassNotFoundException e1) {                 throw e1.             }         }     } else {         return loader.loadClass(name).     } }
