commented;modifiers;parameterAmount;loc;comment;code
false;;1;1;;void onChange(File file).
false;public;0;4;;@Override public CamelContext getCamelContext() {     return camelContext. }
false;public;1;4;;@Override public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;0;3;;public long getPollTimeout() {     return pollTimeout. }
true;public;1;3;/**  * Sets the poll timeout in millis. The default value is 1000.  */ ;/**  * Sets the poll timeout in millis. The default value is 1000.  */ public void setPollTimeout(long pollTimeout) {     this.pollTimeout = pollTimeout. }
false;protected;0;48;;@Override protected void doStart() throws Exception {     if (directory == null) {         // no folder configured         return.     }     File dir = new File(directory).     if (dir.exists() && dir.isDirectory()) {         LOG.info("Starting ReloadStrategy to watch directory: {}", dir).         WatchEvent.Modifier modifier = null.         // if its mac OSX then attempt to apply workaround or warn its slower         String os = ObjectHelper.getSystemProperty("os.name", "").         if (os.toLowerCase(Locale.US).startsWith("mac")) {             // this modifier can speedup the scanner on mac osx (as java on mac has no native file notification integration)             Class<WatchEvent.Modifier> clazz = getCamelContext().getClassResolver().resolveClass("com.sun.nio.file.SensitivityWatchEventModifier", WatchEvent.Modifier.class).             if (clazz != null) {                 WatchEvent.Modifier[] modifiers = clazz.getEnumConstants().                 for (WatchEvent.Modifier mod : modifiers) {                     if ("HIGH".equals(mod.name())) {                         modifier = mod.                         break.                     }                 }             }             if (modifier != null) {                 LOG.info("On Mac OS X the JDK WatchService is slow by default so enabling SensitivityWatchEventModifier.HIGH as workaround").             } else {                 LOG.warn("On Mac OS X the JDK WatchService is slow and it may take up till 10 seconds to notice file changes").             }         }         try {             Path path = dir.toPath().             watcher = path.getFileSystem().newWatchService().             registerPathToWatcher(modifier, path, watcher).             task = new WatchFileChangesTask(watcher, path, onChangeEvent).             executorService = getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, "FileWatcherStrategy").             executorService.submit(task).         } catch (IOException e) {             throw RuntimeCamelException.wrapRuntimeCamelException(e).         }     } }
false;private;3;9;;private WatchKey registerPathToWatcher(WatchEvent.Modifier modifier, Path path, WatchService watcher) throws IOException {     WatchKey key.     if (modifier != null) {         key = path.register(watcher, new WatchEvent.Kind<?>[] { ENTRY_CREATE, ENTRY_MODIFY }, modifier).     } else {         key = path.register(watcher, ENTRY_CREATE, ENTRY_MODIFY).     }     return key. }
false;protected;0;10;;@Override protected void doStop() throws Exception {     if (executorService != null) {         getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService).         executorService = null.     }     if (watcher != null) {         IOHelper.close(watcher).     } }
false;public;0;3;;public boolean isRunning() {     return running. }
false;public;0;39;;public void run() {     LOG.debug("FileWatcherStrategy is starting watching folder: {}", folder).     // allow to run while starting Camel     while (isStarting() || isRunAllowed()) {         running = true.         WatchKey key.         try {             LOG.trace("FileWatcherStrategy is polling for file changes in directory: {}", folder).             // wait for a key to be available             key = watcher.poll(pollTimeout, TimeUnit.MILLISECONDS).         } catch (InterruptedException ex) {             break.         }         if (key != null) {             Path pathToReload = folder.             for (WatchEvent<?> event : key.pollEvents()) {                 WatchEvent<Path> we = (WatchEvent<Path>) event.                 Path path = we.context().                 File file = pathToReload.resolve(path).toFile().                 LOG.trace("Modified/Created/Deleted file: {}", file).                 changeEvent.onChange(file).             }             // the key must be reset after processed             boolean valid = key.reset().             if (!valid) {                 break.             }         }     }     running = false.     LOG.info("FileWatcherStrategy is stopping watching folder: {}", folder). }
