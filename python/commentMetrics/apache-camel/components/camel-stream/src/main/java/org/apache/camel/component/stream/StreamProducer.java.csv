commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected void doStart() throws Exception {     super.doStart(). }
false;protected;0;5;;@Override protected void doStop() throws Exception {     super.doStop().     closeStream(null, true). }
false;public;1;12;;public void process(Exchange exchange) throws Exception {     delay(endpoint.getDelay()).     synchronized (this) {         try {             openStream(exchange).             writeToStream(outputStream, exchange).         } finally {             closeStream(exchange, false).         }     } }
false;private;0;19;;private OutputStream resolveStreamFromUrl() throws IOException {     String u = endpoint.getUrl().     StringHelper.notEmpty(u, "url").     log.debug("About to write to url: {}", u).     URL url = new URL(u).     URLConnection c = url.openConnection().     c.setDoOutput(true).     if (endpoint.getConnectTimeout() > 0) {         c.setConnectTimeout(endpoint.getConnectTimeout()).     }     if (endpoint.getReadTimeout() > 0) {         c.setReadTimeout(endpoint.getReadTimeout()).     }     if (endpoint.getHttpHeaders() != null) {         endpoint.getHttpHeaders().forEach((k, v) -> c.addRequestProperty(k, v.toString())).     }     return c.getOutputStream(). }
false;private;0;10;;private OutputStream resolveStreamFromFile() throws IOException {     String fileName = endpoint.getFileName().     StringHelper.notEmpty(fileName, "fileName").     log.debug("About to write to file: {}", fileName).     File f = new File(fileName).     // will create a new file if missing or append to existing     f.getParentFile().mkdirs().     f.createNewFile().     return new FileOutputStream(f, true). }
false;private;2;3;;private OutputStream resolveStreamFromHeader(Object o, Exchange exchange) throws CamelExchangeException {     return exchange.getContext().getTypeConverter().convertTo(OutputStream.class, o). }
false;private;1;7;;private void delay(long ms) throws InterruptedException {     if (ms == 0) {         return.     }     log.trace("Delaying {} millis", ms).     Thread.sleep(ms). }
false;private;2;30;;private void writeToStream(OutputStream outputStream, Exchange exchange) throws IOException, CamelExchangeException {     Object body = exchange.getIn().getBody().     if (body == null) {         log.debug("Body is null, cannot write it to the stream.").         return.     }     // if not a string then try as byte array first     if (!(body instanceof String)) {         byte[] bytes = exchange.getIn().getBody(byte[].class).         if (bytes != null) {             log.debug("Writing as byte[]: {} to {}", bytes, outputStream).             outputStream.write(bytes).             return.         }     }     // okay now fallback to mandatory converterable to string     String s = exchange.getIn().getMandatoryBody(String.class).     Charset charset = endpoint.getCharset().     Writer writer = new OutputStreamWriter(outputStream, charset).     BufferedWriter bw = IOHelper.buffered(writer).     if (log.isDebugEnabled()) {         log.debug("Writing as text: {} to {} using encoding: {}", body, outputStream, charset).     }     bw.write(s).     bw.write(System.lineSeparator()).     bw.flush(). }
false;private;0;17;;private void openStream() throws Exception {     if (outputStream != null) {         return.     }     if ("out".equals(uri)) {         outputStream = System.out.     } else if ("err".equals(uri)) {         outputStream = System.err.     } else if ("file".equals(uri)) {         outputStream = resolveStreamFromFile().     } else if ("url".equals(uri)) {         outputStream = resolveStreamFromUrl().     }     count.set(outputStream == null ? 0 : endpoint.getAutoCloseCount()).     log.debug("Opened stream '{}'", endpoint.getEndpointKey()). }
false;private;1;11;;private void openStream(final Exchange exchange) throws Exception {     if (outputStream != null) {         return.     }     if ("header".equals(uri)) {         outputStream = resolveStreamFromHeader(exchange.getIn().getHeader("stream"), exchange).         log.debug("Opened stream '{}'", endpoint.getEndpointKey()).     } else {         openStream().     } }
false;private;1;3;;private Boolean isDone(Exchange exchange) {     return exchange != null && exchange.getProperty(Exchange.SPLIT_COMPLETE, Boolean.FALSE, Boolean.class). }
false;private;2;20;;private void closeStream(Exchange exchange, boolean force) throws Exception {     if (outputStream == null) {         return.     }     // never close a standard stream (system.out or system.err)     // always close a 'header' stream (unless it's a system stream)     boolean systemStream = outputStream == System.out || outputStream == System.err.     boolean headerStream = "header".equals(uri).     boolean reachedLimit = endpoint.getAutoCloseCount() > 0 && count.decrementAndGet() <= 0.     boolean isDone = endpoint.isCloseOnDone() && isDone(exchange).     // evaluation order is important!     boolean expiredStream = force || headerStream || isDone || reachedLimit.     // never ever close a system stream     if (!systemStream && expiredStream) {         outputStream.close().         outputStream = null.         log.debug("Closed stream '{}'", endpoint.getEndpointKey()).     } }
false;private;1;19;;private void validateUri(String uri) throws Exception {     String[] s = uri.split(":").     if (s.length < 2) {         throw new IllegalArgumentException(INVALID_URI).     }     String[] t = s[1].split("\\?").     if (t.length < 1) {         throw new IllegalArgumentException(INVALID_URI).     }     this.uri = t[0].trim().     if (this.uri.startsWith("//")) {         this.uri = this.uri.substring(2).     }     if (!TYPES_LIST.contains(this.uri)) {         throw new IllegalArgumentException(INVALID_URI).     } }
