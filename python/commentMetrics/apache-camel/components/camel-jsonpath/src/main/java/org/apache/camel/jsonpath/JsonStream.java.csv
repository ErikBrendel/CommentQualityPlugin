commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Charset getEncoding() {     return encoding. }
false;private;1;13;;private boolean loadAtLeast(int minimum) throws IOException {     int received = inputEnd - inputIndex.     while (received < minimum) {         int count = in.read(fourByteBuffer, inputEnd, fourByteBuffer.length - inputEnd).         if (count < 1) {             return false.         }         inputEnd += count.         received += count.     }     return true. }
false;private;0;33;;private Charset getEncodingFromBOM() throws IOException {     // 32-bit encoding BOMs     if (Arrays.equals(fourByteBuffer, BOM_UTF_32BE)) {         inputIndex = 4.         return Charset.forName("UTF-32BE").     } else if (Arrays.equals(fourByteBuffer, BOM_UTF_32LE)) {         inputIndex = 4.         return Charset.forName("UTF-32LE").     } else if (Arrays.equals(fourByteBuffer, BOM_UTF_32_2143)) {         throw getExceptionUnsupportedUCS4("2143").     } else if (Arrays.equals(fourByteBuffer, BOM_UTF_32_3412)) {         throw getExceptionUnsupportedUCS4("3412").     }     byte[] firstTwoBytes = Arrays.copyOf(fourByteBuffer, 2).     // 16-bit encoding BOMs     if (Arrays.equals(firstTwoBytes, BOM_UTF_16BE)) {         inputIndex = 2.         return Charset.forName("UTF-16BE").     }     if (Arrays.equals(firstTwoBytes, BOM_UTF_16LE)) {         inputIndex = 2.         return Charset.forName("UTF-16LE").     }     byte[] firstThreeBytes = Arrays.copyOf(fourByteBuffer, 3).     // UTF-8 BOM?     if (Arrays.equals(firstThreeBytes, BOM_UTF_8)) {         inputIndex = 3.         return Charset.forName("UTF-8").     }     return null. }
false;private;0;19;;private Charset getUTF32EncodingFromNullPattern() throws IOException {     // content without BOM     if (fourByteBuffer[0] == 0 && fourByteBuffer[1] == 0 && fourByteBuffer[2] == 0) {         // 00 00 00 xx         return Charset.forName("UTF-32BE").     } else if (fourByteBuffer[1] == 0 && fourByteBuffer[2] == 0 && fourByteBuffer[3] == 0) {         // xx 00 00 00         return Charset.forName("UTF-32LE").     } else if (fourByteBuffer[0] == 0 && fourByteBuffer[2] == 0 && fourByteBuffer[3] == 0) {         // 00 xx 00 00         throw getExceptionUnsupportedUCS4("3412").     } else if (fourByteBuffer[0] == 0 && fourByteBuffer[1] == 0 && fourByteBuffer[3] == 0) {         // 00 00 xx 00         throw getExceptionUnsupportedUCS4("2143").     } else {         // Cannot be valid UTF-32 encoded JSON...         return null.     } }
false;private;0;9;;private Charset getUTF16EncodingFromNullPattern() {     if (fourByteBuffer[0] == 0) {         return Charset.forName("UTF-16BE").     } else if (fourByteBuffer[1] == 0) {         return Charset.forName("UTF-16LE").     } else {         // not  UTF-16         return null.     } }
false;private;1;3;;private CharConversionException getExceptionUnsupportedUCS4(String type) throws IOException {     return new CharConversionException("Unsupported UCS-4 endianness (" + type + ") detected"). }
false;public;0;13;;@Override public int read() throws IOException {     if (inputIndex < inputEnd) {         int result = fourByteBuffer[inputIndex].         inputIndex++.         return result.     }     try {         return in.read().     } catch (java.io.EOFException ex) {         return -1.     } }
false;public;1;27;;@Override public int read(byte[] b) throws IOException {     if (inputIndex < inputEnd) {         int minimum = Math.min(b.length, inputEnd - inputIndex).         for (int i = 0. i < minimum. i++) {             b[i] = fourByteBuffer[inputIndex].             inputIndex++.         }         int rest = b.length - minimum.         if (rest == 0) {             return minimum.         }         try {             int additionalRead = in.read(b, minimum, rest).             if (additionalRead < 0) {                 return minimum.             } else {                 return minimum + additionalRead.             }         } catch (java.io.EOFException ex) {             return minimum.         }     } else {         return read(b, 0, b.length).     } }
false;public;3;31;;@Override public int read(byte[] b, int off, int len) throws IOException {     if (inputIndex < inputEnd) {         int minimum = Math.min(b.length, inputEnd - inputIndex).         for (int i = 0. i < minimum. i++) {             b[off + i] = fourByteBuffer[inputIndex].             inputIndex++.         }         int rest = b.length - minimum.         if (rest == 0) {             return minimum.         }         try {             int additionalRead = in.read(b, minimum + off, rest).             if (additionalRead < 0) {                 return minimum.             } else {                 return minimum + additionalRead.             }         } catch (java.io.EOFException ex) {             return minimum.         }     } else {         try {             return in.read(b, off, len).         } catch (java.io.EOFException ex) {             return -1.         }     } }
false;public;1;17;;@Override public long skip(long n) throws IOException {     if (inputIndex < inputEnd) {         long minimum = Math.min(n, inputEnd - inputIndex).         for (int i = 0. i < minimum. i++) {             inputIndex++.         }         long rest = n - minimum.         if (rest == 0) {             return minimum.         }         long additionalSkipped = in.skip(rest).         return additionalSkipped + minimum.     } else {         return in.skip(n).     } }
false;public,synchronized;0;4;;@Override public synchronized void reset() throws IOException {     throw new IOException("reset not supported"). }
false;public;0;4;;@Override public boolean markSupported() {     return false. }
