commented;modifiers;parameterAmount;loc;comment;code
true;public;1;52;/**  * Parses the predicate  *  * @param predicate the predicate  * @return the parsed predicate or the original predicate if easy parser did not kick-in  */ ;/**  * Parses the predicate  *  * @param predicate the predicate  * @return the parsed predicate or the original predicate if easy parser did not kick-in  */ public String parse(String predicate) {     if (predicate.startsWith("$")) {         // regular json path so skip         return predicate.     }     // must have an operator     if (!hasOperator(predicate)) {         return predicate.     }     StringBuilder sb = new StringBuilder().     // grab before operator     String[] parts = tokens(predicate).     // only support one operator currently     if (parts.length == 3) {         String prev = parts[0].         String op = parts[1].         String next = parts[2].         if (isOperator(op)) {             String before.             String after.             int pos = prev.lastIndexOf(".").             if (pos == -1) {                 before = "..*".                 after = prev.             } else {                 before = prev.substring(0, pos).                 after = prev.substring(pos + 1).             }             sb.append("$").             if (!before.startsWith(".")) {                 sb.append(".").             }             sb.append(before).             sb.append("[?(@.").             sb.append(after).             sb.append(" ").             sb.append(op).             sb.append(" ").             sb.append(next).             sb.append(")]").         }         return sb.toString().     }     // not able to parse so return as-is     return predicate. }
true;private,static;1;30;/**  * Splits the predicate into: left OP right  *  * @param predicate the predicate  * @return the splitted parts  */ ;/**  * Splits the predicate into: left OP right  *  * @param predicate the predicate  * @return the splitted parts  */ private static String[] tokens(String predicate) {     List<String> list = new ArrayList<>().     StringBuilder part = new StringBuilder().     for (int i = 0. i < predicate.length(). i++) {         // is there a new operator         String s = predicate.substring(i).         String op = EasyPredicateOperators.getOperatorAtStart(s).         if (op != null) {             if (part.length() > 0) {                 list.add(part.toString()).                 part.setLength(0).             }             list.add(op.trim()).             // move i ahead             i = i + op.length() + 1.         } else {             char ch = predicate.charAt(i).             part.append(ch).         }     }     // ant leftovers     if (part.length() > 0) {         list.add(part.toString()).     }     return list.toArray(new String[list.size()]). }
