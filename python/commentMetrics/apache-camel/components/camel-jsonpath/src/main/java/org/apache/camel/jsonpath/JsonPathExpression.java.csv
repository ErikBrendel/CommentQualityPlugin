commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isPredicate() {     return predicate. }
true;public;1;3;/**  * Whether to be evaluated as a predicate  */ ;/**  * Whether to be evaluated as a predicate  */ public void setPredicate(boolean predicate) {     this.predicate = predicate. }
false;public;0;3;;public Class<?> getResultType() {     return resultType. }
true;public;1;3;/**  * To configure the result type to use  */ ;/**  * To configure the result type to use  */ public void setResultType(Class<?> resultType) {     this.resultType = resultType. }
false;public;0;3;;public boolean isSuppressExceptions() {     return suppressExceptions. }
true;public;1;3;/**  * Whether to suppress exceptions such as PathNotFoundException  */ ;/**  * Whether to suppress exceptions such as PathNotFoundException  */ public void setSuppressExceptions(boolean suppressExceptions) {     this.suppressExceptions = suppressExceptions. }
false;public;0;3;;public boolean isAllowSimple() {     return allowSimple. }
true;public;1;3;/**  * Whether to allow in inlined simple exceptions in the json path expression  */ ;/**  * Whether to allow in inlined simple exceptions in the json path expression  */ public void setAllowSimple(boolean allowSimple) {     this.allowSimple = allowSimple. }
false;public;0;3;;public boolean isAllowEasyPredicate() {     return allowEasyPredicate. }
true;public;1;3;/**  * Whether to allow using the easy predicate parser to pre-parse predicates.  * See {@link EasyPredicateParser} for more details.  */ ;/**  * Whether to allow using the easy predicate parser to pre-parse predicates.  * See {@link EasyPredicateParser} for more details.  */ public void setAllowEasyPredicate(boolean allowEasyPredicate) {     this.allowEasyPredicate = allowEasyPredicate. }
false;public;0;3;;public boolean isWriteAsString() {     return writeAsString. }
true;public;1;3;/**  * Whether to write the output of each row/element as a JSon String value instead of a Map/POJO value.  */ ;/**  * Whether to write the output of each row/element as a JSon String value instead of a Map/POJO value.  */ public void setWriteAsString(boolean writeAsString) {     this.writeAsString = writeAsString. }
false;public;0;3;;public String getHeaderName() {     return headerName. }
true;public;1;3;/**  * Name of header to use as input, instead of the message body  */ ;/**  * Name of header to use as input, instead of the message body  */ public void setHeaderName(String headerName) {     this.headerName = headerName. }
false;public;0;3;;public Option[] getOptions() {     return options. }
true;public;1;3;/**  * To configure the json path options to use  */ ;/**  * To configure the json path options to use  */ public void setOptions(Option[] options) {     this.options = options. }
false;public;1;21;;@Override public Object evaluate(Exchange exchange) {     try {         Object result = evaluateJsonPath(exchange, engine).         if (resultType != null) {             // in some cases we get a single element that is wrapped in a List, so unwrap that             // if we for example want to grab the single entity and convert that to a int/boolean/String etc             boolean resultIsCollection = Collection.class.isAssignableFrom(resultType).             boolean singleElement = result instanceof List && ((List) result).size() == 1.             if (singleElement && !resultIsCollection) {                 result = ((List) result).get(0).                 LOG.trace("Unwrapping result: {} from single element List before converting to: {}", result, resultType).             }             return exchange.getContext().getTypeConverter().convertTo(resultType, exchange, result).         } else {             return result.         }     } catch (Exception e) {         throw new ExpressionEvaluationException(this, exchange, e).     } }
false;public;1;4;;@Override public void afterPropertiesConfigured(CamelContext camelContext) {     init(). }
false;public;0;19;;public void init() {     String exp = expression.     if (predicate && isAllowEasyPredicate()) {         EasyPredicateParser parser = new EasyPredicateParser().         exp = parser.parse(expression).         if (!exp.equals(expression)) {             LOG.debug("EasyPredicateParser parsed {} -> {}", expression, exp).         }     }     LOG.debug("Initializing {} using: {}", predicate ? "predicate" : "expression", exp).     try {         engine = new JsonPathEngine(exp, writeAsString, suppressExceptions, allowSimple, headerName, options).     } catch (Exception e) {         throw new ExpressionIllegalSyntaxException(exp, e).     } }
false;public;0;4;;@Override public String toString() {     return "jsonpath[" + expression + "]". }
false;private;2;3;;private Object evaluateJsonPath(Exchange exchange, JsonPathEngine engine) throws Exception {     return engine.read(exchange). }
