commented;modifiers;parameterAmount;loc;comment;code
true;private;0;19;/**  * Fills the internal char buffer from the reader.  *  * @throws IOException  *             If an I/O error occurs  */ ;/**  * Fills the internal char buffer from the reader.  *  * @throws IOException  *             If an I/O error occurs  */ private void fillBuffer() throws IOException {     if (!endOfInput && (lastCoderResult == null || lastCoderResult.isUnderflow())) {         encoderIn.compact().         int position = encoderIn.position().         // We don't use Reader#read(CharBuffer) here because it is more efficient         // to write directly to the underlying char array (the default implementation         // copies data to a temporary char array).         int c = reader.read(encoderIn.array(), position, encoderIn.remaining()).         if (c == -1) {             endOfInput = true.         } else {             encoderIn.position(position + c).         }         encoderIn.flip().     }     encoderOut.compact().     lastCoderResult = encoder.encode(encoderIn, encoderOut, endOfInput).     encoderOut.flip(). }
true;public;3;29;/**  * Read the specified number of bytes into an array.  *  * @param b the byte array to read into  * @param off the offset to start reading bytes into  * @param len the number of bytes to read  * @return the number of bytes read or <code>-1</code>  *         if the end of the stream has been reached  * @throws IOException if an I/O error occurs  */ ;/**  * Read the specified number of bytes into an array.  *  * @param b the byte array to read into  * @param off the offset to start reading bytes into  * @param len the number of bytes to read  * @return the number of bytes read or <code>-1</code>  *         if the end of the stream has been reached  * @throws IOException if an I/O error occurs  */ @Override public int read(byte[] b, int off, int len) throws IOException {     if (b == null) {         throw new NullPointerException("Byte array must not be null").     }     if (len < 0 || off < 0 || (off + len) > b.length) {         throw new IndexOutOfBoundsException("Array Size=" + b.length + ", offset=" + off + ", length=" + len).     }     int read = 0.     if (len == 0) {         // Always return 0 if len == 0         return 0.     }     while (len > 0) {         if (encoderOut.hasRemaining()) {             int c = Math.min(encoderOut.remaining(), len).             encoderOut.get(b, off, c).             off += c.             len -= c.             read += c.         } else {             fillBuffer().             if (endOfInput && !encoderOut.hasRemaining()) {                 break.             }         }     }     return read == 0 && endOfInput ? -1 : read. }
true;public;1;4;/**  * Read the specified number of bytes into an array.  *  * @param b the byte array to read into  * @return the number of bytes read or <code>-1</code>  *         if the end of the stream has been reached  * @throws IOException if an I/O error occurs  */ ;/**  * Read the specified number of bytes into an array.  *  * @param b the byte array to read into  * @return the number of bytes read or <code>-1</code>  *         if the end of the stream has been reached  * @throws IOException if an I/O error occurs  */ @Override public int read(byte[] b) throws IOException {     return read(b, 0, b.length). }
true;public;0;13;/**  * Read a single byte.  *  * @return either the byte read or <code>-1</code> if the end of the stream  *         has been reached  * @throws IOException if an I/O error occurs  */ ;/**  * Read a single byte.  *  * @return either the byte read or <code>-1</code> if the end of the stream  *         has been reached  * @throws IOException if an I/O error occurs  */ @Override public int read() throws IOException {     for (. . ) {         if (encoderOut.hasRemaining()) {             return encoderOut.get() & 0xFF.         } else {             fillBuffer().             if (endOfInput && !encoderOut.hasRemaining()) {                 return -1.             }         }     } }
true;public;0;4;/**  * Close the stream. This method will cause the underlying {@link Reader}  * to be closed.  * @throws IOException if an I/O error occurs  */ ;/**  * Close the stream. This method will cause the underlying {@link Reader}  * to be closed.  * @throws IOException if an I/O error occurs  */ @Override public void close() throws IOException {     reader.close(). }
