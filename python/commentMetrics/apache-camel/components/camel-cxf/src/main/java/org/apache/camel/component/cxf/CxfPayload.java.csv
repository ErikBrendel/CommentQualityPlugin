commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public boolean add(Element e) {     return body.add(new DOMSource(e)). }
false;public;2;8;;public Element set(int index, Element element) {     Source s = body.set(index, new DOMSource(element)).     try {         return StaxUtils.read(s).getDocumentElement().     } catch (XMLStreamException e) {         throw new RuntimeCamelException("Problem converting content to Element", e).     } }
false;public;2;3;;public void add(int index, Element element) {     body.add(index, new DOMSource(element)). }
false;public;1;8;;public Element remove(int index) {     Source s = body.remove(index).     try {         return StaxUtils.read(s).getDocumentElement().     } catch (XMLStreamException e) {         throw new RuntimeCamelException("Problem converting content to Element", e).     } }
false;public;1;11;;public Element get(int index) {     Source s = body.get(index).     try {         Element el = StaxUtils.read(s).getDocumentElement().         addNamespace(el, nsMap).         body.set(index, new DOMSource(el)).         return el.     } catch (Exception ex) {         throw new RuntimeCamelException("Problem converting content to Element", ex).     } }
false;public;0;3;;public int size() {     return body.size(). }
true;public;0;45;/**  * Get the body as a List of DOM elements.  * This will cause the Body to be fully read and parsed.  * @return  */ ;/**  * Get the body as a List of DOM elements.  * This will cause the Body to be fully read and parsed.  * @return  */ public List<Element> getBody() {     return new AbstractList<Element>() {          public boolean add(Element e) {             return body.add(new DOMSource(e)).         }          public Element set(int index, Element element) {             Source s = body.set(index, new DOMSource(element)).             try {                 return StaxUtils.read(s).getDocumentElement().             } catch (XMLStreamException e) {                 throw new RuntimeCamelException("Problem converting content to Element", e).             }         }          public void add(int index, Element element) {             body.add(index, new DOMSource(element)).         }          public Element remove(int index) {             Source s = body.remove(index).             try {                 return StaxUtils.read(s).getDocumentElement().             } catch (XMLStreamException e) {                 throw new RuntimeCamelException("Problem converting content to Element", e).             }         }          public Element get(int index) {             Source s = body.get(index).             try {                 Element el = StaxUtils.read(s).getDocumentElement().                 addNamespace(el, nsMap).                 body.set(index, new DOMSource(el)).                 return el.             } catch (Exception ex) {                 throw new RuntimeCamelException("Problem converting content to Element", ex).             }         }          public int size() {             return body.size().         }     }. }
false;protected,static;2;16;;protected static void addNamespace(Element element, Map<String, String> nsMap) {     if (nsMap != null) {         for (String ns : nsMap.keySet()) {             // We should not override the namespace setting of the element             if (XMLConstants.XMLNS_ATTRIBUTE.equals(ns)) {                 if (ObjectHelper.isEmpty(element.getAttribute(XMLConstants.XMLNS_ATTRIBUTE))) {                     element.setAttribute(ns, nsMap.get(ns)).                 }             } else {                 if (ObjectHelper.isEmpty(element.getAttribute(XMLConstants.XMLNS_ATTRIBUTE + ":" + ns))) {                     element.setAttribute(XMLConstants.XMLNS_ATTRIBUTE + ":" + ns, nsMap.get(ns)).                 }             }         }     } }
true;public;0;3;/**  * Gets the body as a List of source objects.   If possible, the Source objects  * will likely be StaxSource or similar that allows streaming.   If you plan to  * modify or use the Source, be careful that the result is still usable by  * the Camel runtime.  * @return  */ ;/**  * Gets the body as a List of source objects.   If possible, the Source objects  * will likely be StaxSource or similar that allows streaming.   If you plan to  * modify or use the Source, be careful that the result is still usable by  * the Camel runtime.  * @return  */ public List<Source> getBodySources() {     return body. }
false;public;0;3;;public List<T> getHeaders() {     return headers. }
false;public;0;3;;public Map<String, String> getNsMap() {     return nsMap. }
false;public;0;4;;public String toString() {     // do not load or print the payload body etc as we do not want to load that into memory etc     return super.toString(). }
