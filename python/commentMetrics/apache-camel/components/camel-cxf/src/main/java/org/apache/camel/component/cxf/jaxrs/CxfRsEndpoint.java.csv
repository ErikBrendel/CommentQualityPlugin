commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isLenientProperties() {     return true. }
true;protected;1;3;// This method is for CxfRsComponent setting the EndpointUri ;// This method is for CxfRsComponent setting the EndpointUri protected void updateEndpointUri(String endpointUri) {     super.setEndpointUri(endpointUri). }
false;public;1;3;;public void setParameters(Map<String, String> param) {     parameters = param. }
false;public;0;3;;public Map<String, String> getParameters() {     return parameters. }
true;public;1;3;/**  * If it is true, the CxfRsProducer will use the HttpClientAPI to invoke the service.  * If it is false, the CxfRsProducer will use the ProxyClientAPI to invoke the service  */ ;/**  * If it is true, the CxfRsProducer will use the HttpClientAPI to invoke the service.  * If it is false, the CxfRsProducer will use the ProxyClientAPI to invoke the service  */ public void setHttpClientAPI(boolean clientAPI) {     httpClientAPI = clientAPI. }
false;public;0;3;;public boolean isHttpClientAPI() {     return httpClientAPI. }
false;public;0;3;;public HeaderFilterStrategy getHeaderFilterStrategy() {     return headerFilterStrategy. }
true;public;1;3;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ ;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ public void setHeaderFilterStrategy(HeaderFilterStrategy strategy) {     headerFilterStrategy = strategy. }
false;public;1;5;;public Consumer createConsumer(Processor processor) throws Exception {     CxfRsConsumer answer = new CxfRsConsumer(this, processor).     configureConsumer(answer).     return answer. }
false;public;0;11;;public Producer createProducer() throws Exception {     if (bindingStyle == BindingStyle.SimpleConsumer) {         throw new IllegalArgumentException("The SimpleConsumer Binding Style cannot be used in a camel-cxfrs producer").     }     final CxfRsProducer cxfRsProducer = new CxfRsProducer(this).     if (isSynchronous()) {         return new SynchronousDelegateProducer(cxfRsProducer).     } else {         return cxfRsProducer.     } }
false;public;0;3;;public boolean isSingleton() {     return true. }
true;public;1;3;/**  * To use a custom CxfBinding to control the binding between Camel Message and CXF Message.  */ ;/**  * To use a custom CxfBinding to control the binding between Camel Message and CXF Message.  */ public void setBinding(CxfRsBinding binding) {     this.binding = binding. }
false;public;0;3;;public CxfRsBinding getBinding() {     return binding. }
false;public;0;3;;public boolean isSkipFaultLogging() {     return skipFaultLogging. }
false;public;0;6;;public CxfRsEndpointConfigurer getChainedCxfRsEndpointConfigurer() {     return ChainedCxfRsEndpointConfigurer.create(getNullSafeCxfRsEndpointConfigurer(), SslCxfRsEndpointConfigurer.create(sslContextParameters, getCamelContext())).addChild(HostnameVerifierCxfRsEndpointConfigurer.create(hostnameVerifier)). }
true;public;1;3;/**  * This option controls whether the PhaseInterceptorChain skips logging the Fault that it catches.  */ ;/**  * This option controls whether the PhaseInterceptorChain skips logging the Fault that it catches.  */ public void setSkipFaultLogging(boolean skipFaultLogging) {     this.skipFaultLogging = skipFaultLogging. }
false;protected;2;5;;protected void checkBeanType(Object object, Class<?> clazz) {     if (!clazz.isAssignableFrom(object.getClass())) {         throw new IllegalArgumentException("The configure bean is not the instance of " + clazz.getName()).     } }
false;protected;1;25;;protected void setupJAXRSServerFactoryBean(JAXRSServerFactoryBean sfb) {     // address     if (getAddress() != null) {         sfb.setAddress(getAddress()).     }     processResourceModel(sfb).     if (getResourceClasses() != null) {         sfb.setResourceClasses(getResourceClasses()).     }     if (serviceBeans != null && !serviceBeans.isEmpty()) {         sfb.setServiceBeans(serviceBeans).     }     // setup the resource providers for interfaces     List<ClassResourceInfo> cris = sfb.getServiceFactory().getClassResourceInfo().     for (ClassResourceInfo cri : cris) {         final Class<?> serviceClass = cri.getServiceClass().         if (serviceClass.isInterface()) {             cri.setResourceProvider(new CamelResourceProvider(serviceClass)).         }     }     setupCommonFactoryProperties(sfb).     sfb.setStart(false).     getNullSafeCxfRsEndpointConfigurer().configure(sfb). }
false;protected;0;6;;protected CxfRsEndpointConfigurer getNullSafeCxfRsEndpointConfigurer() {     if (cxfRsEndpointConfigurer == null) {         return new ChainedCxfRsEndpointConfigurer.NullCxfRsEndpointConfigurer().     }     return cxfRsEndpointConfigurer. }
false;private;1;10;;private void processResourceModel(JAXRSServerFactoryBean sfb) {     // of the model. Other sources will be supported going forward     if (modelRef != null) {         List<UserResource> resources = ResourceUtils.getUserResources(modelRef, sfb.getBus()).         processUserResources(sfb, resources).     } }
true;private;2;13;/*      * Prepare model beans and set them on the factory.      * The model beans can be created from a variety of sources such as      * CXF Model extensions but also other documents (to be supported in the future).      */ ;/*      * Prepare model beans and set them on the factory.      * The model beans can be created from a variety of sources such as      * CXF Model extensions but also other documents (to be supported in the future).      */ private void processUserResources(JAXRSServerFactoryBean sfb, List<UserResource> resources) {     for (UserResource resource : resources) {         if (StringUtils.isEmpty(resource.getName())) {             resource.setName(DefaultModelResource.class.getName()).         }     }     // The CXF to Camel exchange binding may need to be customized     // for the operation name, request, response types be derived from     // the model info (when a given model does provide this info) as opposed     // to a matched method which is of no real use with a default handler.     sfb.setModelBeans(resources). }
false;protected;2;16;;protected void setupJAXRSClientFactoryBean(JAXRSClientFactoryBean cfb, String address) {     if (modelRef != null) {         cfb.setModelRef(modelRef).     }     if (getResourceClasses() != null && !getResourceClasses().isEmpty()) {         cfb.setResourceClass(getResourceClasses().get(0)).         cfb.getServiceFactory().setResourceClasses(getResourceClasses()).     }     setupCommonFactoryProperties(cfb).     cfb.setThreadSafe(true).     getNullSafeCxfRsEndpointConfigurer().configure(cfb).     // Add the address could be override by message header     if (address != null) {         cfb.setAddress(address).     } }
false;protected;1;52;;protected void setupCommonFactoryProperties(AbstractJAXRSFactoryBean factory) {     // let customer to override the default setting of provider     if (!getProviders().isEmpty()) {         factory.setProviders(getProviders()).     }     // setup the features     if (!getFeatures().isEmpty()) {         factory.getFeatures().addAll(getFeatures()).     }     if (publishedEndpointUrl != null) {         factory.setPublishedEndpointUrl(publishedEndpointUrl).     }     // we need to avoid flushing the setting from spring or blueprint     if (!interceptorHolder.getInInterceptors().isEmpty()) {         factory.setInInterceptors(interceptorHolder.getInInterceptors()).     }     if (!interceptorHolder.getOutInterceptors().isEmpty()) {         factory.setOutInterceptors(interceptorHolder.getOutInterceptors()).     }     if (!interceptorHolder.getOutFaultInterceptors().isEmpty()) {         factory.setOutFaultInterceptors(interceptorHolder.getOutFaultInterceptors()).     }     if (!interceptorHolder.getInFaultInterceptors().isEmpty()) {         factory.setInFaultInterceptors(interceptorHolder.getInFaultInterceptors()).     }     if (getProperties() != null) {         if (factory.getProperties() != null) {             // add to existing properties             factory.getProperties().putAll(getProperties()).         } else {             factory.setProperties(getProperties()).         }         LOG.debug("JAXRS FactoryBean: {} added properties: {}", factory, getProperties()).     }     if (isLoggingFeatureEnabled()) {         LoggingFeature loggingFeature = new LoggingFeature().         if (getLoggingSizeLimit() > 0) {             loggingFeature.setLimit(getLoggingSizeLimit()).         }         factory.getFeatures().add(loggingFeature).     }     if (this.isSkipFaultLogging()) {         if (factory.getProperties() == null) {             factory.setProperties(new HashMap<String, Object>()).         }         factory.getProperties().put(FaultListener.class.getName(), new NullFaultListener()).     } }
false;protected;1;6;;protected boolean isValidClassResourceInfo(ClassResourceInfo cri) {     // is requested.     return !performInvocation || !cri.getServiceClass().isInterface(). }
false;protected;0;10;;protected JAXRSServerFactoryBean newJAXRSServerFactoryBean() {     return new JAXRSServerFactoryBean() {          protected boolean isValidClassResourceInfo(ClassResourceInfo cri) {             // is requested.             return !performInvocation || !cri.getServiceClass().isInterface().         }     }. }
false;protected;0;3;;protected JAXRSClientFactoryBean newJAXRSClientFactoryBean() {     return new JAXRSClientFactoryBean(). }
false;protected;1;11;;protected String resolvePropertyPlaceholders(String str) {     try {         if (getCamelContext() != null) {             return getCamelContext().resolvePropertyPlaceholders(str).         } else {             return str.         }     } catch (Exception ex) {         throw RuntimeCamelException.wrapRuntimeCamelException(ex).     } }
false;public;0;5;;public JAXRSServerFactoryBean createJAXRSServerFactoryBean() {     JAXRSServerFactoryBean answer = newJAXRSServerFactoryBean().     setupJAXRSServerFactoryBean(answer).     return answer. }
false;public;0;3;;public JAXRSClientFactoryBean createJAXRSClientFactoryBean() {     return createJAXRSClientFactoryBean(getAddress()). }
false;public;1;5;;public JAXRSClientFactoryBean createJAXRSClientFactoryBean(String address) {     JAXRSClientFactoryBean answer = newJAXRSClientFactoryBean().     setupJAXRSClientFactoryBean(answer, address).     return answer. }
false;public;0;3;;public List<Class<?>> getResourceClasses() {     return resourceClasses. }
false;public;1;6;;public void addResourceClass(Class<?> resourceClass) {     if (resourceClasses == null) {         resourceClasses = new ArrayList<>().     }     resourceClasses.add(resourceClass). }
true;public;1;3;/**  * The resource classes which you want to export as REST service. Multiple classes can be separated by comma.  */ ;/**  * The resource classes which you want to export as REST service. Multiple classes can be separated by comma.  */ public void setResourceClasses(List<Class<?>> resourceClasses) {     this.resourceClasses = resourceClasses. }
false;public;1;3;;public void setResourceClasses(Class<?>... classes) {     setResourceClasses(Arrays.asList(classes)). }
false;public;0;3;;public List<?> getServiceBeans() {     return serviceBeans. }
false;public;1;6;;public void addServiceBean(Object bean) {     if (serviceBeans == null) {         serviceBeans = new ArrayList<>().     }     serviceBeans.add(bean). }
true;public;1;3;/**  * The service beans which you want to export as REST service. Multiple beans can be separated by comma.  */ ;/**  * The service beans which you want to export as REST service. Multiple beans can be separated by comma.  */ public void setServiceBeans(List<?> beans) {     this.serviceBeans = new ArrayList<Object>(beans). }
false;public;1;3;;public void setServiceBeans(Object... beans) {     setServiceBeans(Arrays.asList(beans)). }
false;public;1;3;;public void setServiceBeans(String beans) {     setServiceBeans(EndpointHelper.resolveReferenceListParameter(getCamelContext(), beans, Object.class)). }
true;public;1;3;/**  * The service publish address.  */ ;/**  * The service publish address.  */ public void setAddress(String address) {     this.address = address. }
true;public;1;3;/**  * This option is used to specify the model file which is useful for the resource class without annotation.  * When using this option, then the service class can be omitted, to emulate document-only endpoints  */ ;/**  * This option is used to specify the model file which is useful for the resource class without annotation.  * When using this option, then the service class can be omitted, to emulate document-only endpoints  */ public void setModelRef(String ref) {     this.modelRef = ref. }
false;public;0;3;;public String getAddress() {     return resolvePropertyPlaceholders(address). }
false;public;0;3;;public String getPublishedEndpointUrl() {     return publishedEndpointUrl. }
true;public;1;3;/**  * This option can override the endpointUrl that published from the WADL which can be accessed with resource address url plus ?_wadl  */ ;/**  * This option can override the endpointUrl that published from the WADL which can be accessed with resource address url plus ?_wadl  */ public void setPublishedEndpointUrl(String publishedEndpointUrl) {     this.publishedEndpointUrl = publishedEndpointUrl. }
true;public;0;3;/**  * This option enables CXF Logging Feature which writes inbound and outbound REST messages to log.  */ ;/**  * This option enables CXF Logging Feature which writes inbound and outbound REST messages to log.  */ public boolean isLoggingFeatureEnabled() {     return loggingFeatureEnabled. }
false;public;1;3;;public void setLoggingFeatureEnabled(boolean loggingFeatureEnabled) {     this.loggingFeatureEnabled = loggingFeatureEnabled. }
false;public;0;3;;public int getLoggingSizeLimit() {     return loggingSizeLimit. }
true;public;1;3;/**  * To limit the total size of number of bytes the logger will output when logging feature has been enabled.  */ ;/**  * To limit the total size of number of bytes the logger will output when logging feature has been enabled.  */ public void setLoggingSizeLimit(int loggingSizeLimit) {     this.loggingSizeLimit = loggingSizeLimit. }
false;public;0;3;;public boolean isThrowExceptionOnFailure() {     return throwExceptionOnFailure. }
true;public;1;3;/**  * This option tells the CxfRsProducer to inspect return codes and will generate an Exception if the return code is larger than 207.  */ ;/**  * This option tells the CxfRsProducer to inspect return codes and will generate an Exception if the return code is larger than 207.  */ public void setThrowExceptionOnFailure(boolean throwExceptionOnFailure) {     this.throwExceptionOnFailure = throwExceptionOnFailure. }
true;public;1;3;/**  * This option allows you to configure the maximum size of the cache.  * The implementation caches CXF clients or ClientFactoryBean in CxfProvider and CxfRsProvider.  */ ;/**  * This option allows you to configure the maximum size of the cache.  * The implementation caches CXF clients or ClientFactoryBean in CxfProvider and CxfRsProvider.  */ public void setMaxClientCacheSize(int maxClientCacheSize) {     this.maxClientCacheSize = maxClientCacheSize. }
false;public;0;3;;public int getMaxClientCacheSize() {     return maxClientCacheSize. }
true;public;1;7;/**  * To use a custom configured CXF Bus.  */ ;/**  * To use a custom configured CXF Bus.  */ public void setBus(Bus bus) {     this.bus = bus.     if (defaultBus) {         BusFactory.setDefaultBus(bus).         LOG.debug("Set bus {} as thread default bus", bus).     } }
false;public;0;3;;public Bus getBus() {     return bus. }
true;public;1;3;/**  * Will set the default bus when CXF endpoint create a bus by itself  */ ;/**  * Will set the default bus when CXF endpoint create a bus by itself  */ public void setDefaultBus(boolean isSetDefaultBus) {     this.defaultBus = isSetDefaultBus. }
false;public;0;3;;public boolean isDefaultBus() {     return defaultBus. }
false;public;0;3;;public boolean isIgnoreDeleteMethodMessageBody() {     return ignoreDeleteMethodMessageBody. }
true;public;1;3;/**  * This option is used to tell CxfRsProducer to ignore the message body of the DELETE method when using HTTP API.  */ ;/**  * This option is used to tell CxfRsProducer to ignore the message body of the DELETE method when using HTTP API.  */ public void setIgnoreDeleteMethodMessageBody(boolean ignoreDeleteMethodMessageBody) {     this.ignoreDeleteMethodMessageBody = ignoreDeleteMethodMessageBody. }
false;public;0;3;;public BindingStyle getBindingStyle() {     return bindingStyle. }
false;public;0;3;;public List<?> getProviders() {     return providers. }
true;public;1;3;/**  * Set custom JAX-RS provider(s) list to the CxfRs endpoint.  * You can specify a string with a list of providers to lookup in the registy separated by comma.  */ ;/**  * Set custom JAX-RS provider(s) list to the CxfRs endpoint.  * You can specify a string with a list of providers to lookup in the registy separated by comma.  */ public void setProviders(List<?> providers) {     this.providers.addAll(providers). }
true;public;1;3;/**  * Set custom JAX-RS provider(s) list which is looked up in the registry. Multiple entries can be separated by comma.  */ ;/**  * Set custom JAX-RS provider(s) list which is looked up in the registry. Multiple entries can be separated by comma.  */ public void setProviders(String providers) {     this.providersRef = providers. }
true;public;1;3;/**  * Set custom JAX-RS provider to the CxfRs endpoint.  */ ;/**  * Set custom JAX-RS provider to the CxfRs endpoint.  */ public void setProvider(Object provider) {     providers.add(provider). }
true;public;1;3;/**  * Sets the locations of the schema(s) which can be used to validate the incoming XML or JAXB-driven JSON.  */ ;/**  * Sets the locations of the schema(s) which can be used to validate the incoming XML or JAXB-driven JSON.  */ public void setSchemaLocation(String schema) {     setSchemaLocations(Collections.singletonList(schema)). }
true;public;1;3;/**  * Sets the locations of the schema(s) which can be used to validate the incoming XML or JAXB-driven JSON.  */ ;/**  * Sets the locations of the schema(s) which can be used to validate the incoming XML or JAXB-driven JSON.  */ public void setSchemaLocations(List<String> schemas) {     this.schemaLocations = schemas. }
false;public;0;3;;public List<String> getSchemaLocations() {     return schemaLocations. }
false;public;0;3;;public List<Interceptor<? extends Message>> getOutFaultInterceptors() {     return interceptorHolder.getOutFaultInterceptors(). }
false;public;0;3;;public List<Interceptor<? extends Message>> getInFaultInterceptors() {     return interceptorHolder.getInFaultInterceptors(). }
false;public;0;3;;public List<Interceptor<? extends Message>> getInInterceptors() {     return interceptorHolder.getInInterceptors(). }
false;public;0;3;;public List<Interceptor<? extends Message>> getOutInterceptors() {     return interceptorHolder.getOutInterceptors(). }
true;public;1;3;/**  * Set the inInterceptors to the CxfRs endpoint.  */ ;/**  * Set the inInterceptors to the CxfRs endpoint.  */ public void setInInterceptors(List<Interceptor<? extends Message>> interceptors) {     interceptorHolder.setInInterceptors(interceptors). }
true;public;1;3;/**  * Set the inFaultInterceptors to the CxfRs endpoint.  */ ;/**  * Set the inFaultInterceptors to the CxfRs endpoint.  */ public void setInFaultInterceptors(List<Interceptor<? extends Message>> interceptors) {     interceptorHolder.setInFaultInterceptors(interceptors). }
true;public;1;3;/**  * Set the outInterceptor to the CxfRs endpoint.  */ ;/**  * Set the outInterceptor to the CxfRs endpoint.  */ public void setOutInterceptors(List<Interceptor<? extends Message>> interceptors) {     interceptorHolder.setOutInterceptors(interceptors). }
true;public;1;3;/**  * Set the outFaultInterceptors to the CxfRs endpoint.  */ ;/**  * Set the outFaultInterceptors to the CxfRs endpoint.  */ public void setOutFaultInterceptors(List<Interceptor<? extends Message>> interceptors) {     interceptorHolder.setOutFaultInterceptors(interceptors). }
false;public;0;3;;public List<Feature> getFeatures() {     return features. }
true;public;1;3;/**  * Set the feature list to the CxfRs endpoint.  */ ;/**  * Set the feature list to the CxfRs endpoint.  */ public void setFeatures(List<Feature> features) {     this.features = features. }
false;public;0;3;;public Map<String, Object> getProperties() {     return properties. }
false;public;1;7;;public void setProperties(Map<String, Object> properties) {     if (this.properties == null) {         this.properties = properties.     } else {         this.properties.putAll(properties).     } }
true;public;1;3;/**  *  Sets how requests and responses will be mapped to/from Camel. Two values are possible:  *  <ul>  *      <li>SimpleConsumer: This binding style processes request parameters, multiparts, etc. and maps them to IN headers, IN attachments and to the message body.  *                          It aims to eliminate low-level processing of {@link org.apache.cxf.message.MessageContentsList}.  *                          It also also adds more flexibility and simplicity to the response mapping.  *                          Only available for consumers.  *      </li>  *      <li>Default: The default style. For consumers this passes on a MessageContentsList to the route, requiring low-level processing in the route.  *                   This is the traditional binding style, which simply dumps the {@link org.apache.cxf.message.MessageContentsList} coming in from the CXF stack  *                   onto the IN message body. The user is then responsible for processing it according to the contract defined by the JAX-RS method signature.  *      </li>  *      <li>Custom: allows you to specify a custom binding through the binding option.</li>  *  </ul>  */ ;/**  *  Sets how requests and responses will be mapped to/from Camel. Two values are possible:  *  <ul>  *      <li>SimpleConsumer: This binding style processes request parameters, multiparts, etc. and maps them to IN headers, IN attachments and to the message body.  *                          It aims to eliminate low-level processing of {@link org.apache.cxf.message.MessageContentsList}.  *                          It also also adds more flexibility and simplicity to the response mapping.  *                          Only available for consumers.  *      </li>  *      <li>Default: The default style. For consumers this passes on a MessageContentsList to the route, requiring low-level processing in the route.  *                   This is the traditional binding style, which simply dumps the {@link org.apache.cxf.message.MessageContentsList} coming in from the CXF stack  *                   onto the IN message body. The user is then responsible for processing it according to the contract defined by the JAX-RS method signature.  *      </li>  *      <li>Custom: allows you to specify a custom binding through the binding option.</li>  *  </ul>  */ public void setBindingStyle(BindingStyle bindingStyle) {     this.bindingStyle = bindingStyle. }
false;public;0;3;;public String getBeanId() {     return beanId. }
false;public;1;3;;public void setBeanId(String beanId) {     this.beanId = beanId. }
false;protected;0;37;;@Override protected void doStart() throws Exception {     if (headerFilterStrategy == null) {         headerFilterStrategy = new CxfRsHeaderFilterStrategy().     }     // if the user explicitly selected the Custom binding style, he must provide a binding     if (bindingStyle == BindingStyle.Custom && binding == null) {         throw new IllegalArgumentException("Custom binding style selected, but no binding was supplied").     }     // if the user has set a binding, do nothing, just make sure that BindingStyle = Custom for coherency purposes     if (binding != null) {         bindingStyle = BindingStyle.Custom.     }     // set the right binding based on the binding style     if (bindingStyle == BindingStyle.SimpleConsumer) {         binding = new SimpleCxfRsBinding().     } else if (bindingStyle == BindingStyle.Custom) {     // do nothing     } else {         binding = new DefaultCxfRsBinding().     }     if (binding instanceof HeaderFilterStrategyAware) {         ((HeaderFilterStrategyAware) binding).setHeaderFilterStrategy(getHeaderFilterStrategy()).     }     if (providersRef != null) {         String[] names = providersRef.split(",").         for (String name : names) {             Object provider = EndpointHelper.resolveReferenceParameter(getCamelContext(), name, Object.class, true).             setProvider(provider).         }     } }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
false;public;0;3;;public long getContinuationTimeout() {     return continuationTimeout. }
true;public;1;3;/**  * This option is used to set the CXF continuation timeout which could be used in CxfConsumer by default when the CXF server is using Jetty or Servlet transport.  */ ;/**  * This option is used to set the CXF continuation timeout which could be used in CxfConsumer by default when the CXF server is using Jetty or Servlet transport.  */ public void setContinuationTimeout(long continuationTimeout) {     this.continuationTimeout = continuationTimeout. }
false;public;0;3;;public boolean isPerformInvocation() {     return performInvocation. }
true;public;1;3;/**  * When the option is true, Camel will perform the invocation of the resource class instance and put the response object into the exchange for further processing.  */ ;/**  * When the option is true, Camel will perform the invocation of the resource class instance and put the response object into the exchange for further processing.  */ public void setPerformInvocation(boolean performInvocation) {     this.performInvocation = performInvocation. }
false;public;0;3;;public boolean isPropagateContexts() {     return propagateContexts. }
true;public;1;3;/**  * When the option is true, JAXRS UriInfo, HttpHeaders, Request and SecurityContext contexts will be available to  * custom CXFRS processors as typed Camel exchange properties.  * These contexts can be used to analyze the current requests using JAX-RS API.  */ ;/**  * When the option is true, JAXRS UriInfo, HttpHeaders, Request and SecurityContext contexts will be available to  * custom CXFRS processors as typed Camel exchange properties.  * These contexts can be used to analyze the current requests using JAX-RS API.  */ public void setPropagateContexts(boolean propagateContexts) {     this.propagateContexts = propagateContexts. }
false;public;0;3;;public SSLContextParameters getSslContextParameters() {     return sslContextParameters. }
true;public;1;3;/**  * The Camel SSL setting reference. Use the # notation to reference the SSL Context.  */ ;/**  * The Camel SSL setting reference. Use the # notation to reference the SSL Context.  */ public void setSslContextParameters(SSLContextParameters sslContextParameters) {     this.sslContextParameters = sslContextParameters. }
false;public;0;3;;public HostnameVerifier getHostnameVerifier() {     return hostnameVerifier. }
true;public;1;3;/**  * The hostname verifier to be used. Use the # notation to reference a HostnameVerifier  * from the registry.  */ ;/**  * The hostname verifier to be used. Use the # notation to reference a HostnameVerifier  * from the registry.  */ public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {     this.hostnameVerifier = hostnameVerifier. }
false;public;0;3;;public CxfRsEndpointConfigurer getCxfRsEndpointConfigurer() {     return cxfRsEndpointConfigurer. }
true;public;1;3;/**  * This option could apply the implementation of org.apache.camel.component.cxf.jaxrs.CxfRsEndpointConfigurer which supports to configure the CXF endpoint  * in  programmatic way. User can configure the CXF server and client by implementing configure{Server/Client} method of CxfEndpointConfigurer.  */ ;/**  * This option could apply the implementation of org.apache.camel.component.cxf.jaxrs.CxfRsEndpointConfigurer which supports to configure the CXF endpoint  * in  programmatic way. User can configure the CXF server and client by implementing configure{Server/Client} method of CxfEndpointConfigurer.  */ public void setCxfRsEndpointConfigurer(CxfRsEndpointConfigurer configurer) {     this.cxfRsEndpointConfigurer = configurer. }
false;public;0;3;;public CookieHandler getCookieHandler() {     return cookieHandler. }
true;public;1;3;/**  * Configure a cookie handler to maintain a HTTP session  */ ;/**  * Configure a cookie handler to maintain a HTTP session  */ public void setCookieHandler(CookieHandler cookieHandler) {     this.cookieHandler = cookieHandler. }
