commented;modifiers;parameterAmount;loc;comment;code
false;public;4;17;;@Override public void populateExchangeFromCxfRsRequest(Exchange cxfExchange, org.apache.camel.Exchange camelExchange, Method method, Object[] paramArray) {     super.populateExchangeFromCxfRsRequest(cxfExchange, camelExchange, method, paramArray).     Message in = camelExchange.getIn().     bindHeadersFromSubresourceLocators(cxfExchange, camelExchange).     MethodSpec spec = methodSpecCache.get(method).     if (spec == null) {         spec = MethodSpec.fromMethod(method).         methodSpecCache.put(method, spec).     }     bindParameters(in, paramArray, spec.paramNames, spec.numberParameters).     bindBody(in, paramArray, spec.entityIndex).     if (spec.multipart) {         transferMultipartParameters(paramArray, spec.multipartNames, spec.multipartTypes, in).     } }
false;public;2;5;;@Override public Object populateCxfRsResponseFromExchange(org.apache.camel.Exchange camelExchange, Exchange cxfExchange) throws Exception {     Object base = super.populateCxfRsResponseFromExchange(camelExchange, cxfExchange).     return buildResponse(camelExchange, base). }
true;protected;2;24;/**  * Builds the response for the client.  * <p />  * Always returns a JAX-RS {@link Response} object, which gives the user a better control on the response behaviour.  * If the message body is already an instance of {@link Response}, we reuse it and just inject the relevant HTTP headers.  * @param camelExchange  * @param base  * @return  */ ;/**  * Builds the response for the client.  * <p />  * Always returns a JAX-RS {@link Response} object, which gives the user a better control on the response behaviour.  * If the message body is already an instance of {@link Response}, we reuse it and just inject the relevant HTTP headers.  * @param camelExchange  * @param base  * @return  */ protected Object buildResponse(org.apache.camel.Exchange camelExchange, Object base) {     Message m = camelExchange.hasOut() ? camelExchange.getOut() : camelExchange.getIn().     ResponseBuilder response.     // if the body is different to Response, it's an entity. therefore, check     if (base instanceof Response) {         response = Response.fromResponse((Response) base).     } else {         int status = m.getHeader(org.apache.camel.Exchange.HTTP_RESPONSE_CODE, Status.OK.getStatusCode(), Integer.class).         response = Response.status(status).         // avoid using the request MessageContentsList as the entity. it simply doesn't make sense         if (base != null && !(base instanceof MessageContentsList)) {             response.entity(base).         }     }     // Compute which headers to transfer by applying the HeaderFilterStrategy, and transfer them to the JAX-RS Response     Map<String, String> headersToPropagate = filterCamelHeadersForResponseHeaders(m.getHeaders(), camelExchange).     for (Entry<String, String> entry : headersToPropagate.entrySet()) {         response.header(entry.getKey(), entry.getValue()).     }     return response.build(). }
true;protected;2;16;/**  * Filters the response headers that will be sent back to the client.  * <p />  * The {@link DefaultCxfRsBinding} doesn't filter the response headers according to the {@link HeaderFilterStrategy},  * so we handle this task in this binding.  */ ;/**  * Filters the response headers that will be sent back to the client.  * <p />  * The {@link DefaultCxfRsBinding} doesn't filter the response headers according to the {@link HeaderFilterStrategy},  * so we handle this task in this binding.  */ protected Map<String, String> filterCamelHeadersForResponseHeaders(Map<String, Object> headers, org.apache.camel.Exchange camelExchange) {     Map<String, String> answer = new HashMap<>().     for (Map.Entry<String, Object> entry : headers.entrySet()) {         if (getHeaderFilterStrategy().applyFilterToCamelHeaders(entry.getKey(), entry.getValue(), camelExchange)) {             continue.         }         // on the entity set as the Response         if ("content-length".equalsIgnoreCase(entry.getKey())) {             continue.         }         answer.put(entry.getKey(), entry.getValue().toString()).     }     return answer. }
true;protected;2;19;/**  * Transfers path parameters from the full path (including ancestor subresource locators) into Camel IN Message Headers.  */ ;/**  * Transfers path parameters from the full path (including ancestor subresource locators) into Camel IN Message Headers.  */ @SuppressWarnings("unchecked") protected void bindHeadersFromSubresourceLocators(Exchange cxfExchange, org.apache.camel.Exchange camelExchange) {     MultivaluedMap<String, String> pathParams = (MultivaluedMap<String, String>) cxfExchange.getInMessage().get(URITemplate.TEMPLATE_PARAMETERS).     // return immediately if we have no path parameters     if (pathParams == null || (pathParams.size() == 1 && pathParams.containsKey(URITemplate.FINAL_MATCH_GROUP))) {         return.     }     Message m = camelExchange.getIn().     for (Entry<String, List<String>> entry : pathParams.entrySet()) {         // skip over the FINAL_MATCH_GROUP which stores the entire path         if (URITemplate.FINAL_MATCH_GROUP.equals(entry.getKey())) {             continue.         }         m.setHeader(entry.getKey(), entry.getValue().get(0)).     } }
true;protected;4;10;/**  * Binds JAX-RS parameter types (@HeaderParam, @QueryParam, @MatrixParam, etc.) to the exchange.  *  * @param in  * @param paramArray  * @param paramNames  * @param numberParameters  */ ;/**  * Binds JAX-RS parameter types (@HeaderParam, @QueryParam, @MatrixParam, etc.) to the exchange.  *  * @param in  * @param paramArray  * @param paramNames  * @param numberParameters  */ protected void bindParameters(Message in, Object[] paramArray, String[] paramNames, int numberParameters) {     if (numberParameters == 0) {         return.     }     for (int i = 0. i < paramNames.length. i++) {         if (paramNames[i] != null) {             in.setHeader(paramNames[i], paramArray[i]).         }     } }
true;protected;3;6;/**  * Binds the message body.  *  * @param in  * @param paramArray  * @param singleBodyIndex  */ ;/**  * Binds the message body.  *  * @param in  * @param paramArray  * @param singleBodyIndex  */ protected void bindBody(Message in, Object[] paramArray, int singleBodyIndex) {     if (singleBodyIndex == -1) {         return.     }     in.setBody(paramArray[singleBodyIndex]). }
false;private;4;12;;private void transferMultipartParameters(Object[] paramArray, String[] multipartNames, String[] multipartTypes, Message in) {     for (int i = 0. i < multipartNames.length. i++) {         if (multipartNames[i] == null || paramArray[i] == null) {             continue.         }         if (BINARY_ATTACHMENT_TYPES.contains(paramArray[i].getClass())) {             transferBinaryMultipartParameter(paramArray[i], multipartNames[i], multipartTypes[i], in).         } else {             in.setHeader(multipartNames[i], paramArray[i]).         }     } }
false;private;4;15;;private void transferBinaryMultipartParameter(Object toMap, String parameterName, String multipartType, Message in) {     org.apache.camel.Attachment dh = null.     if (toMap instanceof Attachment) {         dh = createCamelAttachment((Attachment) toMap).     } else if (toMap instanceof DataSource) {         dh = new DefaultAttachment((DataSource) toMap).     } else if (toMap instanceof DataHandler) {         dh = new DefaultAttachment((DataHandler) toMap).     } else if (toMap instanceof InputStream) {         dh = new DefaultAttachment(new InputStreamDataSource((InputStream) toMap, multipartType == null ? "application/octet-stream" : multipartType)).     }     if (dh != null) {         in.addAttachmentObject(parameterName, dh).     } }
false;private;1;9;;private DefaultAttachment createCamelAttachment(Attachment attachment) {     DefaultAttachment camelAttachment = new DefaultAttachment(attachment.getDataHandler()).     for (String name : attachment.getHeaders().keySet()) {         for (String value : attachment.getHeaderAsList(name)) {             camelAttachment.addHeader(name, value).         }     }     return camelAttachment. }
true;public,static;1;44;/**  * Processes this method definition and extracts metadata relevant for the binding process.  * @param method The Method to process.  * @return A MethodSpec instance representing the method metadata relevant to the Camel binding process.  */ ;/**  * Processes this method definition and extracts metadata relevant for the binding process.  * @param method The Method to process.  * @return A MethodSpec instance representing the method metadata relevant to the Camel binding process.  */ public static MethodSpec fromMethod(Method method) {     method = AnnotationUtils.getAnnotatedMethod(method.getDeclaringClass(), method).     MethodSpec answer = new MethodSpec().     Annotation[][] annotations = method.getParameterAnnotations().     int paramCount = method.getParameterTypes().length.     answer.paramNames = new String[paramCount].     answer.multipartNames = new String[paramCount].     answer.multipartTypes = new String[paramCount].     // remember the names of parameters to be bound to headers and/or attachments     for (int i = 0. i < paramCount. i++) {         // if the parameter has no annotations, let its array element remain = null         for (Annotation a : annotations[i]) {             // am I a header?             if (HEADER_ANNOTATIONS.contains(a.annotationType())) {                 try {                     answer.paramNames[i] = (String) a.annotationType().getMethod("value", NO_PARAMETER_TYPES).invoke(a, NO_PARAMETERS).                     answer.numberParameters++.                 } catch (Exception e) {                 }             }             // am I multipart?             if (Multipart.class.equals(a.annotationType())) {                 Multipart multipart = (Multipart) a.                 answer.multipart = true.                 answer.multipartNames[i] = multipart.value().                 answer.multipartTypes[i] = multipart.type().             }         }     }     // there's one parameter that will serve as message body     if (!answer.multipart && answer.numberParameters < method.getParameterTypes().length) {         for (int i = 0. i < answer.paramNames.length. i++) {             if (answer.paramNames[i] == null) {                 answer.entityIndex = i.                 break.             }         }     }     return answer. }
