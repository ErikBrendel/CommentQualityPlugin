commented;modifiers;parameterAmount;loc;comment;code
false;public;2;24;;@Override public void initialize(Client client, Bus bus) {     client.getEndpoint().put("org.apache.cxf.binding.soap.addNamespaceContext", "true").     removeFaultInInterceptorFromClient(client).     // Need to remove some interceptors that are incompatible     // We don't support JAX-WS Holders for PAYLOAD (not needed anyway)     // and thus we need to remove those interceptors to prevent Holder     // object from being created and stuck into the contents list     // instead of Source objects     removeInterceptor(client.getEndpoint().getInInterceptors(), HolderInInterceptor.class).     removeInterceptor(client.getEndpoint().getOutInterceptors(), HolderOutInterceptor.class).     // The SoapHeaderInterceptor maps various headers onto method parameters.     // At this point, we expect all the headers to remain as headers, not     // part of the body, so we remove that one.     removeInterceptor(client.getEndpoint().getBinding().getInInterceptors(), SoapHeaderInterceptor.class).     client.getEndpoint().getBinding().getInInterceptors().add(new ConfigureDocLitWrapperInterceptor(true)).     resetPartTypes(client.getEndpoint().getBinding()).     LOG.info("Initialized CXF Client: {} in Payload mode with allow streaming: {}", client, allowStreaming). }
false;public;2;19;;@Override public void initialize(Server server, Bus bus) {     server.getEndpoint().put("org.apache.cxf.binding.soap.addNamespaceContext", "true").     server.getEndpoint().getBinding().getInInterceptors().add(new ConfigureDocLitWrapperInterceptor(true)).     if (server.getEndpoint().getBinding() instanceof SoapBinding) {         server.getEndpoint().getBinding().getOutInterceptors().add(new SetSoapVersionInterceptor()).     }     // Need to remove some interceptors that are incompatible     // See above.     removeInterceptor(server.getEndpoint().getInInterceptors(), HolderInInterceptor.class).     removeInterceptor(server.getEndpoint().getOutInterceptors(), HolderOutInterceptor.class).     removeInterceptor(server.getEndpoint().getBinding().getInInterceptors(), SoapHeaderInterceptor.class).     resetPartTypes(server.getEndpoint().getBinding()).     LOG.info("Initialized CXF Server: {} in Payload mode with allow streaming: {}", server, allowStreaming). }
false;protected;0;4;;@Override protected Logger getLogger() {     return LOG. }
false;private;1;9;;private void resetPartTypes(Binding bop2) {     // (for non-streaming, defaults to DOMSource.     for (BindingOperationInfo bop : bop2.getBindingInfo().getOperations()) {         resetPartTypes(bop).     } }
false;private;1;16;;private void resetPartTypes(BindingOperationInfo bop) {     if (bop.isUnwrapped()) {         bop = bop.getWrappedOperation().     }     if (bop.isUnwrappedCapable()) {         resetPartTypeClass(bop.getWrappedOperation().getOperationInfo().getInput()).         resetPartTypeClass(bop.getWrappedOperation().getOperationInfo().getOutput()).         resetPartTypeClass(bop.getWrappedOperation().getInput()).         resetPartTypeClass(bop.getWrappedOperation().getOutput()).     } else {         resetPartTypeClass(bop.getOperationInfo().getInput()).         resetPartTypeClass(bop.getOperationInfo().getOutput()).         resetPartTypeClass(bop.getInput()).         resetPartTypeClass(bop.getOutput()).     } }
false;protected;1;13;;protected void resetPartTypeClass(BindingMessageInfo bmi) {     if (bmi != null) {         int size = bmi.getMessageParts().size().         for (int x = 0. x < size. x++) {             // last part can be streamed, others need DOM parsing             if (x < (size - 1)) {                 bmi.getMessageParts().get(x).setTypeClass(allowStreaming ? DOMSource.class : null).             } else {                 bmi.getMessageParts().get(x).setTypeClass(allowStreaming ? Source.class : null).             }         }     } }
false;protected;1;13;;protected void resetPartTypeClass(MessageInfo msgInfo) {     if (msgInfo != null) {         int size = msgInfo.getMessageParts().size().         for (int x = 0. x < size. x++) {             // last part can be streamed, others need DOM parsing             if (x < (size - 1)) {                 msgInfo.getMessageParts().get(x).setTypeClass(allowStreaming ? DOMSource.class : null).             } else {                 msgInfo.getMessageParts().get(x).setTypeClass(allowStreaming ? Source.class : null).             }         }     } }
