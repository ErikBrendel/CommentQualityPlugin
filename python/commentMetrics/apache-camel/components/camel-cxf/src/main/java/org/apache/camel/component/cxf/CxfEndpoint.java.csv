commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;public CxfEndpoint copy() {     try {         return (CxfEndpoint) this.clone().     } catch (CloneNotSupportedException e) {         throw new RuntimeCamelException(e).     } }
true;protected;1;3;// This method is for CxfComponent setting the EndpointUri ;// This method is for CxfComponent setting the EndpointUri protected void updateEndpointUri(String endpointUri) {     super.setEndpointUri(UnsafeUriCharactersEncoder.encodeHttpURI(endpointUri)). }
false;public;0;8;;public Producer createProducer() throws Exception {     Producer answer = new CxfProducer(this).     if (isSynchronous()) {         return new SynchronousDelegateProducer(answer).     } else {         return answer.     } }
false;public;1;5;;public Consumer createConsumer(Processor processor) throws Exception {     CxfConsumer answer = new CxfConsumer(this, processor).     configureConsumer(answer).     return answer. }
false;public;0;3;;public boolean isSingleton() {     return true. }
true;protected;2;119;/**  * Populate server factory bean  */ ;/**  * Populate server factory bean  */ protected void setupServerFactoryBean(ServerFactoryBean sfb, Class<?> cls) {     // address     sfb.setAddress(getAddress()).     sfb.setServiceClass(cls).     sfb.setInInterceptors(in).     sfb.setOutInterceptors(out).     sfb.setOutFaultInterceptors(outFault).     sfb.setInFaultInterceptors(inFault).     sfb.setFeatures(features).     if (schemaLocations != null) {         sfb.setSchemaLocations(schemaLocations).     }     if (bindingConfig != null) {         sfb.setBindingConfig(bindingConfig).     }     if (dataBinding != null) {         sfb.setDataBinding(dataBinding).     }     if (serviceFactoryBean != null) {         setServiceFactory(sfb, serviceFactoryBean).     }     if (sfb instanceof JaxWsServerFactoryBean && handlers != null) {         ((JaxWsServerFactoryBean) sfb).setHandlers(handlers).     }     if (getTransportId() != null) {         sfb.setTransportId(getTransportId()).     }     if (getBindingId() != null) {         sfb.setBindingId(getBindingId()).     }     // wsdl url     if (getWsdlURL() != null) {         sfb.setWsdlURL(getWsdlURL()).     }     // service  name qname     if (getServiceName() != null) {         sfb.setServiceName(getServiceName()).     }     // port qname     if (getPortName() != null) {         sfb.setEndpointName(getPortName()).     }     // apply feature here     if (!CxfEndpointUtils.hasAnnotation(cls, WebServiceProvider.class)) {         if (getDataFormat() == DataFormat.PAYLOAD) {             sfb.getFeatures().add(new PayLoadDataFormatFeature(allowStreaming)).         } else if (getDataFormat().dealias() == DataFormat.CXF_MESSAGE) {             sfb.getFeatures().add(new CXFMessageDataFormatFeature()).             sfb.setDataBinding(new SourceDataBinding()).         } else if (getDataFormat().dealias() == DataFormat.RAW) {             RAWDataFormatFeature feature = new RAWDataFormatFeature().             if (this.getExchangePattern().equals(ExchangePattern.InOnly)) {                 // if DataFormat is RAW|MESSAGE, can't read message so can't                 // determine it's oneway so need get the MEP from URI explicitly                 feature.setOneway(true).             }             feature.addInIntercepters(getInInterceptors()).             feature.addOutInterceptors(getOutInterceptors()).             sfb.getFeatures().add(feature).         }     } else {         log.debug("Ignore DataFormat mode {} since SEI class is annotated with WebServiceProvider", getDataFormat()).     }     if (isLoggingFeatureEnabled()) {         LoggingFeature loggingFeature = new LoggingFeature().         if (getLoggingSizeLimit() > 0) {             loggingFeature.setLimit(getLoggingSizeLimit()).         }         sfb.getFeatures().add(loggingFeature).     }     if (getDataFormat() == DataFormat.PAYLOAD) {         sfb.setDataBinding(new HybridSourceDataBinding()).     }     // set the document-literal wrapped style     if (getWrappedStyle() != null && getDataFormat().dealias() != DataFormat.CXF_MESSAGE) {         setWrapped(sfb, getWrappedStyle()).     }     // any optional properties     if (getProperties() != null) {         if (sfb.getProperties() != null) {             // add to existing properties             sfb.getProperties().putAll(getProperties()).         } else {             sfb.setProperties(getProperties()).         }         log.debug("ServerFactoryBean: {} added properties: {}", sfb, getProperties()).     }     if (this.isSkipPayloadMessagePartCheck()) {         if (sfb.getProperties() == null) {             sfb.setProperties(new HashMap<String, Object>()).         }         sfb.getProperties().put("soap.no.validate.parts", Boolean.TRUE).     }     if (this.isSkipFaultLogging()) {         if (sfb.getProperties() == null) {             sfb.setProperties(new HashMap<String, Object>()).         }         sfb.getProperties().put(FaultListener.class.getName(), new NullFaultListener()).     }     sfb.setBus(getBus()).     sfb.setStart(false).     getNullSafeCxfEndpointConfigurer().configure(sfb). }
false;protected;1;4;;@Override protected Client createClient(Endpoint ep) {     return new CamelCxfClientImpl(getBus(), ep). }
false;protected;1;4;;@Override protected Client createClient(Endpoint ep) {     return new CamelCxfClientImpl(getBus(), ep). }
true;protected;1;17;/**  * Create a client factory bean object.  Notice that the serviceClass <b>must</b> be  * an interface.  */ ;/**  * Create a client factory bean object.  Notice that the serviceClass <b>must</b> be  * an interface.  */ protected ClientFactoryBean createClientFactoryBean(Class<?> cls) throws CamelException {     if (CxfEndpointUtils.hasWebServiceAnnotation(cls)) {         return new JaxWsClientFactoryBean() {              @Override             protected Client createClient(Endpoint ep) {                 return new CamelCxfClientImpl(getBus(), ep).             }         }.     } else {         return new ClientFactoryBean() {              @Override             protected Client createClient(Endpoint ep) {                 return new CamelCxfClientImpl(getBus(), ep).             }         }.     } }
false;protected;1;4;;@Override protected Client createClient(Endpoint ep) {     return new CamelCxfClientImpl(getBus(), ep). }
false;protected;2;4;;@Override protected void initializeAnnotationInterceptors(Endpoint ep, Class<?> cls) { // Do nothing here }
true;protected;0;24;/**  * Create a client factory bean object without serviceClass interface.  */ ;/**  * Create a client factory bean object without serviceClass interface.  */ protected ClientFactoryBean createClientFactoryBean() {     ClientFactoryBean cf = new ClientFactoryBean() {          @Override         protected Client createClient(Endpoint ep) {             return new CamelCxfClientImpl(getBus(), ep).         }          @Override         protected void initializeAnnotationInterceptors(Endpoint ep, Class<?> cls) {         // Do nothing here         }     }.     for (Method m : cf.getClass().getMethods()) {         if ("setServiceFactory".equals(m.getName())) {             try {                 // Set Object class as the service class of WSDLServiceFactoryBean                 ReflectionUtil.setAccessible(m).invoke(cf, new WSDLServiceFactoryBean(Object.class)).             } catch (Exception e) {                 throw new RuntimeException(e).             }         }     }     return cf. }
false;protected;2;36;;protected void setupHandlers(ClientFactoryBean factoryBean, Client client) throws Exception {     if (handlers != null) {         AnnotationHandlerChainBuilder builder = new AnnotationHandlerChainBuilder().         Method m = factoryBean.getClass().getMethod("getServiceFactory").         JaxWsServiceFactoryBean sf = (JaxWsServiceFactoryBean) m.invoke(factoryBean).         @SuppressWarnings("rawtypes")         List<Handler> chain = new ArrayList<>(handlers).         chain.addAll(builder.buildHandlerChainFromClass(sf.getServiceClass(), sf.getEndpointInfo().getName(), sf.getServiceQName(), factoryBean.getBindingId())).         if (!chain.isEmpty()) {             ResourceManager resourceManager = getBus().getExtension(ResourceManager.class).             List<ResourceResolver> resolvers = resourceManager.getResourceResolvers().             resourceManager = new DefaultResourceManager(resolvers).             resourceManager.addResourceResolver(new WebServiceContextResourceResolver()).             ResourceInjector injector = new ResourceInjector(resourceManager).             for (Handler<?> h : chain) {                 if (Proxy.isProxyClass(h.getClass()) && getServiceClass() != null) {                     injector.inject(h, getServiceClass()).                     injector.construct(h, getServiceClass()).                 } else {                     injector.inject(h).                     injector.construct(h).                 }             }         }         ((JaxWsEndpointImpl) client.getEndpoint()).getJaxwsBinding().setHandlerChain(chain).     } }
false;protected;2;110;;protected void setupClientFactoryBean(ClientFactoryBean factoryBean, Class<?> cls) {     if (cls != null) {         factoryBean.setServiceClass(cls).     }     factoryBean.setInInterceptors(in).     factoryBean.setOutInterceptors(out).     factoryBean.setOutFaultInterceptors(outFault).     factoryBean.setInFaultInterceptors(inFault).     factoryBean.setFeatures(features).     factoryBean.setTransportId(transportId).     factoryBean.setBindingId(bindingId).     if (bindingConfig != null) {         factoryBean.setBindingConfig(bindingConfig).     }     if (dataBinding != null) {         factoryBean.setDataBinding(dataBinding).     }     if (serviceFactoryBean != null) {         setServiceFactory(factoryBean, serviceFactoryBean).     }     // address     factoryBean.setAddress(getAddress()).     // wsdl url     if (getWsdlURL() != null) {         factoryBean.setWsdlURL(getWsdlURL()).     }     // service name qname     if (getServiceName() != null) {         factoryBean.setServiceName(getServiceName()).     }     // port name qname     if (getPortName() != null) {         factoryBean.setEndpointName(getPortName()).     }     // apply feature here     if (getDataFormat().dealias() == DataFormat.RAW) {         RAWDataFormatFeature feature = new RAWDataFormatFeature().         feature.addInIntercepters(getInInterceptors()).         feature.addOutInterceptors(getOutInterceptors()).         factoryBean.getFeatures().add(feature).     } else if (getDataFormat().dealias() == DataFormat.CXF_MESSAGE) {         factoryBean.getFeatures().add(new CXFMessageDataFormatFeature()).         factoryBean.setDataBinding(new SourceDataBinding()).     } else if (getDataFormat() == DataFormat.PAYLOAD) {         factoryBean.getFeatures().add(new PayLoadDataFormatFeature(allowStreaming)).         factoryBean.setDataBinding(new HybridSourceDataBinding()).     }     if (isLoggingFeatureEnabled()) {         LoggingFeature loggingFeature = new LoggingFeature().         if (getLoggingSizeLimit() > 0) {             loggingFeature.setLimit(getLoggingSizeLimit()).         }         factoryBean.getFeatures().add(loggingFeature).     }     // set the document-literal wrapped style     if (getWrappedStyle() != null) {         setWrapped(factoryBean, getWrappedStyle()).     }     // any optional properties     if (getProperties() != null) {         if (factoryBean.getProperties() != null) {             // add to existing properties             factoryBean.getProperties().putAll(getProperties()).         } else {             factoryBean.setProperties(getProperties()).         }         log.debug("ClientFactoryBean: {} added properties: {}", factoryBean, getProperties()).     }     // setup the basic authentication property     if (ObjectHelper.isNotEmpty(username)) {         AuthorizationPolicy authPolicy = new AuthorizationPolicy().         authPolicy.setUserName(username).         authPolicy.setPassword(password).         if (factoryBean.getProperties() == null) {             factoryBean.setProperties(new HashMap<String, Object>()).         }         factoryBean.getProperties().put(AuthorizationPolicy.class.getName(), authPolicy).     }     if (this.isSkipPayloadMessagePartCheck()) {         if (factoryBean.getProperties() == null) {             factoryBean.setProperties(new HashMap<String, Object>()).         }         factoryBean.getProperties().put("soap.no.validate.parts", Boolean.TRUE).     }     if (this.isSkipFaultLogging()) {         if (factoryBean.getProperties() == null) {             factoryBean.setProperties(new HashMap<String, Object>()).         }         factoryBean.getProperties().put(FaultListener.class.getName(), new NullFaultListener()).     }     factoryBean.setBus(getBus()).     getNullSafeCxfEndpointConfigurer().configure(factoryBean). }
false;private;2;8;;// Package private methods // ------------------------------------------------------------------------- private void setWrapped(Object factoryBean, boolean wrapped) {     try {         Object sf = factoryBean.getClass().getMethod("getServiceFactory").invoke(factoryBean).         sf.getClass().getMethod("setWrapped", Boolean.TYPE).invoke(sf, wrapped).     } catch (Throwable t) {         throw new RuntimeException(t).     } }
false;private;2;12;;private void setServiceFactory(Object factoryBean, Object serviceFactoryBean2) {     for (Method m : factoryBean.getClass().getMethods()) {         if ("setServiceFactory".equals(m.getName()) && m.getParameterTypes()[0].isInstance(serviceFactoryBean2)) {             try {                 ReflectionUtil.setAccessible(m).invoke(factoryBean, serviceFactoryBean2).             } catch (Exception e) {                 throw new RuntimeException(e).             }         }     } }
true;;0;40;/**  * Create a CXF client object  */ ;/**  * Create a CXF client object  */ Client createClient() throws Exception {     // get service class     if (getDataFormat().equals(DataFormat.POJO)) {         ObjectHelper.notNull(getServiceClass(), CxfConstants.SERVICE_CLASS).     }     if (getWsdlURL() == null && getServiceClass() == null) {         // no WSDL and serviceClass specified, set our default serviceClass         setServiceClass(org.apache.camel.component.cxf.DefaultSEI.class.getName()).         setDefaultOperationNamespace(CxfConstants.DISPATCH_NAMESPACE).         setDefaultOperationName(CxfConstants.DISPATCH_DEFAULT_OPERATION_NAMESPACE).         if (getDataFormat().equals(DataFormat.PAYLOAD)) {             setSkipPayloadMessagePartCheck(true).         }     }     Class<?> cls = getServiceClass().     ClientFactoryBean factoryBean.     if (cls != null) {         // create client factory bean         factoryBean = createClientFactoryBean(cls).     } else {         factoryBean = createClientFactoryBean().     }     // setup client factory bean     setupClientFactoryBean(factoryBean, cls).     if (cls == null) {         checkName(factoryBean.getEndpointName(), "endpoint/port name").         checkName(factoryBean.getServiceName(), "service name").     }     Client client = factoryBean.create().     // setup the handlers     setupHandlers(factoryBean, client).     return client. }
false;;2;5;;void checkName(Object value, String name) {     if (ObjectHelper.isEmpty(value)) {         log.warn("The " + name + " of " + this.getEndpointUri() + " is empty, cxf will try to load the first one in wsdl for you.").     } }
true;;0;38;/**  * Create a CXF server factory bean  */ ;/**  * Create a CXF server factory bean  */ ServerFactoryBean createServerFactoryBean() throws Exception {     Class<?> cls = null.     if (getDataFormat() == DataFormat.POJO) {         ObjectHelper.notNull(getServiceClass(), CxfConstants.SERVICE_CLASS).     }     if (getWsdlURL() == null && getServiceClass() == null) {         // no WSDL and serviceClass specified, set our default serviceClass         if (getDataFormat().equals(DataFormat.PAYLOAD)) {             setServiceClass(org.apache.camel.component.cxf.DefaultPayloadProviderSEI.class.getName()).         }     }     if (getServiceClass() != null) {         cls = getServiceClass().     }     // create server factory bean     // Shouldn't use CxfEndpointUtils.getServerFactoryBean(cls) as it is for     // CxfSoapComponent     ServerFactoryBean answer = null.     if (cls == null) {         checkName(portName, " endpoint/port name").         checkName(serviceName, " service name").         answer = new JaxWsServerFactoryBean(new WSDLServiceFactoryBean()).         cls = Provider.class.     } else if (CxfEndpointUtils.hasWebServiceAnnotation(cls)) {         answer = new JaxWsServerFactoryBean().     } else {         answer = new ServerFactoryBean().     }     // setup server factory bean     setupServerFactoryBean(answer, cls).     return answer. }
false;protected;1;11;;protected String resolvePropertyPlaceholders(String str) {     try {         if (getCamelContext() != null) {             return getCamelContext().resolvePropertyPlaceholders(str).         } else {             return str.         }     } catch (Exception ex) {         throw RuntimeCamelException.wrapRuntimeCamelException(ex).     } }
false;public;0;3;;// Properties // ------------------------------------------------------------------------- public String getBeanId() {     return beanId. }
false;public;1;3;;public void setBeanId(String beanId) {     this.beanId = beanId. }
false;public;0;3;;public DataFormat getDataFormat() {     return dataFormat. }
true;public;1;3;/**  * The data type messages supported by the CXF endpoint.  */ ;/**  * The data type messages supported by the CXF endpoint.  */ public void setDataFormat(DataFormat format) {     dataFormat = format. }
false;public;0;3;;public String getPublishedEndpointUrl() {     return resolvePropertyPlaceholders(publishedEndpointUrl). }
true;public;1;3;/**  * This option can override the endpointUrl that published from the WSDL which can be accessed with service address url plus ?wsd  */ ;/**  * This option can override the endpointUrl that published from the WSDL which can be accessed with service address url plus ?wsd  */ public void setPublishedEndpointUrl(String url) {     publishedEndpointUrl = url. }
false;public;0;3;;public String getWsdlURL() {     return resolvePropertyPlaceholders(wsdlURL). }
true;public;1;3;/**  * The location of the WSDL. Can be on the classpath, file system, or be hosted remotely.  */ ;/**  * The location of the WSDL. Can be on the classpath, file system, or be hosted remotely.  */ public void setWsdlURL(String url) {     wsdlURL = url. }
false;public;0;3;;public Class<?> getServiceClass() {     return serviceClass. }
true;public;1;3;/**  * The class name of the SEI (Service Endpoint Interface) class which could have JSR181 annotation or not.  */ ;/**  * The class name of the SEI (Service Endpoint Interface) class which could have JSR181 annotation or not.  */ public void setServiceClass(Class<?> cls) {     serviceClass = cls. }
true;public;1;3;/**  * The class name of the SEI (Service Endpoint Interface) class which could have JSR181 annotation or not.  */ ;/**  * The class name of the SEI (Service Endpoint Interface) class which could have JSR181 annotation or not.  */ public void setServiceClass(Object instance) {     serviceClass = ClassHelper.getRealClass(instance). }
true;public;1;6;/**  * The class name of the SEI (Service Endpoint Interface) class which could have JSR181 annotation or not.  */ ;/**  * The class name of the SEI (Service Endpoint Interface) class which could have JSR181 annotation or not.  */ public void setServiceClass(String type) throws ClassNotFoundException {     if (ObjectHelper.isEmpty(type)) {         throw new IllegalArgumentException("The serviceClass option can neither be null nor an empty String.").     }     serviceClass = ClassLoaderUtils.loadClass(resolvePropertyPlaceholders(type), getClass()). }
true;public;1;3;/**  * The service name this service is implementing, it maps to the wsdl:service@name.  */ ;/**  * The service name this service is implementing, it maps to the wsdl:service@name.  */ public void setServiceNameString(String service) {     serviceNameString = service. }
true;public;1;3;/**  * The service name this service is implementing, it maps to the wsdl:service@name.  */ ;/**  * The service name this service is implementing, it maps to the wsdl:service@name.  */ public void setServiceName(QName service) {     serviceName = service. }
true;public;1;3;/**  * The service name this service is implementing, it maps to the wsdl:service@name.  */ ;/**  * The service name this service is implementing, it maps to the wsdl:service@name.  */ public void setService(String service) {     serviceNameString = service. }
false;public;0;24;;public QName getServiceName() {     if (serviceName == null && serviceNameString != null) {         serviceName = QName.valueOf(resolvePropertyPlaceholders(serviceNameString)).     }     // from wsdl to avoid ambiguity     if (serviceName == null && getWsdlURL() != null) {         // definition         try {             Definition definition = getBus().getExtension(WSDLManager.class).getDefinition(getWsdlURL()).             if (definition.getServices().size() == 1) {                 serviceName = (QName) definition.getServices().keySet().iterator().next().             }         } catch (WSDLException e) {             throw new RuntimeException(e).         }     }     return serviceName. }
false;public;0;6;;public QName getPortName() {     if (portName == null && portNameString != null) {         portName = QName.valueOf(resolvePropertyPlaceholders(portNameString)).     }     return portName. }
true;public;1;3;/**  * The endpoint name this service is implementing, it maps to the wsdl:port@name. In the format of ns:PORT_NAME where ns is a namespace prefix valid at this scope.  */ ;/**  * The endpoint name this service is implementing, it maps to the wsdl:port@name. In the format of ns:PORT_NAME where ns is a namespace prefix valid at this scope.  */ public void setPortName(QName port) {     portName = port. }
true;public;1;3;/**  * The endpoint name this service is implementing, it maps to the wsdl:port@name. In the format of ns:PORT_NAME where ns is a namespace prefix valid at this scope.  */ ;/**  * The endpoint name this service is implementing, it maps to the wsdl:port@name. In the format of ns:PORT_NAME where ns is a namespace prefix valid at this scope.  */ public void setPortNameString(String portNameString) {     this.portNameString = portNameString. }
false;public;1;3;;public void setPortName(String portName) {     portNameString = portName. }
true;public;1;3;/**  * The port name this service is implementing, it maps to the wsdl:port@name.  */ ;/**  * The port name this service is implementing, it maps to the wsdl:port@name.  */ public void setEndpointNameString(String port) {     portNameString = port. }
true;public;1;3;/**  * The port name this service is implementing, it maps to the wsdl:port@name.  */ ;/**  * The port name this service is implementing, it maps to the wsdl:port@name.  */ public void setEndpointName(QName port) {     portName = port. }
false;public;0;3;;public String getDefaultOperationName() {     return resolvePropertyPlaceholders(defaultOperationName). }
true;public;1;3;/**  * This option will set the default operationName that will be used by the CxfProducer which invokes the remote service.  */ ;/**  * This option will set the default operationName that will be used by the CxfProducer which invokes the remote service.  */ public void setDefaultOperationName(String name) {     defaultOperationName = name. }
false;public;0;3;;public String getDefaultOperationNamespace() {     return resolvePropertyPlaceholders(defaultOperationNamespace). }
true;public;1;3;/**  * This option will set the default operationNamespace that will be used by the CxfProducer which invokes the remote service.  */ ;/**  * This option will set the default operationNamespace that will be used by the CxfProducer which invokes the remote service.  */ public void setDefaultOperationNamespace(String namespace) {     defaultOperationNamespace = namespace. }
false;public;0;3;;public boolean isWrapped() {     return wrapped. }
true;public;1;3;/**  * Which kind of operation that CXF endpoint producer will invoke  */ ;/**  * Which kind of operation that CXF endpoint producer will invoke  */ public void setWrapped(boolean wrapped) {     this.wrapped = wrapped. }
false;public;0;3;;public Boolean getWrappedStyle() {     return wrappedStyle. }
true;public;1;3;/**  * The WSDL style that describes how parameters are represented in the SOAP body.  * If the value is false, CXF will chose the document-literal unwrapped style,  * If the value is true, CXF will chose the document-literal wrapped style  */ ;/**  * The WSDL style that describes how parameters are represented in the SOAP body.  * If the value is false, CXF will chose the document-literal unwrapped style,  * If the value is true, CXF will chose the document-literal wrapped style  */ public void setWrappedStyle(Boolean wrapped) {     wrappedStyle = wrapped. }
true;public;1;3;/**  * This option controls whether the CXF component, when running in PAYLOAD mode, will DOM parse the incoming messages  * into DOM Elements or keep the payload as a javax.xml.transform.Source object that would allow streaming in some cases.  */ ;/**  * This option controls whether the CXF component, when running in PAYLOAD mode, will DOM parse the incoming messages  * into DOM Elements or keep the payload as a javax.xml.transform.Source object that would allow streaming in some cases.  */ public void setAllowStreaming(Boolean allowStreaming) {     this.allowStreaming = allowStreaming. }
false;public;0;3;;public Boolean getAllowStreaming() {     return allowStreaming. }
true;public;1;3;/**  * To use a custom CxfBinding to control the binding between Camel Message and CXF Message.  */ ;/**  * To use a custom CxfBinding to control the binding between Camel Message and CXF Message.  */ public void setCxfBinding(CxfBinding cxfBinding) {     this.cxfBinding = cxfBinding. }
false;public;0;3;;public CxfBinding getCxfBinding() {     return cxfBinding. }
true;public;1;6;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ ;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {     this.headerFilterStrategy = headerFilterStrategy.     if (cxfBinding instanceof HeaderFilterStrategyAware) {         ((HeaderFilterStrategyAware) cxfBinding).setHeaderFilterStrategy(headerFilterStrategy).     } }
false;public;0;3;;public HeaderFilterStrategy getHeaderFilterStrategy() {     return headerFilterStrategy. }
true;public;1;4;/**  * To use a custom configured CXF Bus.  */ ;/**  * To use a custom configured CXF Bus.  */ public void setBus(Bus bus) {     this.bus = bus.     this.createBus = false. }
false;public;0;13;;public Bus getBus() {     if (bus == null) {         bus = CxfEndpointUtils.createBus(getCamelContext()).         this.createBus = true.         log.debug("Using DefaultBus {}", bus).     }     if (!getBusHasBeenCalled.getAndSet(true) && defaultBus) {         BusFactory.setDefaultBus(bus).         log.debug("Set bus {} as thread default bus", bus).     }     return bus. }
true;public;1;3;/**  * Will set the default bus when CXF endpoint create a bus by itself  */ ;/**  * Will set the default bus when CXF endpoint create a bus by itself  */ public void setDefaultBus(boolean defaultBus) {     this.defaultBus = defaultBus. }
false;public;0;3;;public boolean isDefaultBus() {     return defaultBus. }
true;public;1;3;/**  * This option enables CXF Logging Feature which writes inbound and outbound SOAP messages to log.  */ ;/**  * This option enables CXF Logging Feature which writes inbound and outbound SOAP messages to log.  */ public void setLoggingFeatureEnabled(boolean loggingFeatureEnabled) {     this.loggingFeatureEnabled = loggingFeatureEnabled. }
false;public;0;3;;public boolean isLoggingFeatureEnabled() {     return loggingFeatureEnabled. }
false;public;0;3;;public int getLoggingSizeLimit() {     return loggingSizeLimit. }
true;public;1;6;/**  * To limit the total size of number of bytes the logger will output when logging feature has been enabled and -1 for no limit.  */ ;/**  * To limit the total size of number of bytes the logger will output when logging feature has been enabled and -1 for no limit.  */ public void setLoggingSizeLimit(int loggingSizeLimit) {     if (loggingSizeLimit < -1) {         throw new IllegalArgumentException("LoggingSizeLimit must be greater or equal to -1.").     }     this.loggingSizeLimit = loggingSizeLimit. }
false;public;0;3;;public boolean isSkipPayloadMessagePartCheck() {     return skipPayloadMessagePartCheck. }
true;public;1;3;/**  * Sets whether SOAP message validation should be disabled.  */ ;/**  * Sets whether SOAP message validation should be disabled.  */ public void setSkipPayloadMessagePartCheck(boolean skipPayloadMessagePartCheck) {     this.skipPayloadMessagePartCheck = skipPayloadMessagePartCheck. }
false;public;0;3;;public Map<String, Object> getProperties() {     return properties. }
false;public;1;16;;public void setCamelContext(CamelContext c) {     super.setCamelContext(c).     if (this.properties != null) {         try {             EndpointHelper.setReferenceProperties(getCamelContext(), this, this.properties).             EndpointHelper.setProperties(getCamelContext(), this, this.properties).         } catch (Throwable e) {             // TODO: Why dont't we rethrown this exception             log.warn("Error setting CamelContext. This exception will be ignored.", e).         }     } }
true;public;1;20;/**  * To set additional CXF options using the key/value pairs from the Map.  * For example to turn on stacktraces in SOAP faults, <tt>properties.faultStackTraceEnabled=true</tt>  */ ;/**  * To set additional CXF options using the key/value pairs from the Map.  * For example to turn on stacktraces in SOAP faults, <tt>properties.faultStackTraceEnabled=true</tt>  */ public void setProperties(Map<String, Object> properties) {     if (this.properties == null) {         this.properties = properties.     } else {         this.properties.putAll(properties).     }     if (getCamelContext() != null && this.properties != null) {         try {             EndpointHelper.setReferenceProperties(getCamelContext(), this, this.properties).             EndpointHelper.setProperties(getCamelContext(), this, this.properties).         } catch (Throwable e) {             // TODO: Why dont't we rethrown this exception             log.warn("Error setting properties. This exception will be ignored.", e).         }     } }
false;public;0;3;;public CookieHandler getCookieHandler() {     return cookieHandler. }
true;public;1;3;/**  * Configure a cookie handler to maintain a HTTP session  */ ;/**  * Configure a cookie handler to maintain a HTTP session  */ public void setCookieHandler(CookieHandler cookieHandler) {     this.cookieHandler = cookieHandler. }
false;protected;0;12;;@Override protected void doStart() throws Exception {     if (headerFilterStrategy == null) {         headerFilterStrategy = new CxfHeaderFilterStrategy().     }     if (cxfBinding == null) {         cxfBinding = new DefaultCxfBinding().     }     if (cxfBinding instanceof HeaderFilterStrategyAware) {         ((HeaderFilterStrategyAware) cxfBinding).setHeaderFilterStrategy(getHeaderFilterStrategy()).     } }
false;protected;0;10;;@Override protected void doStop() throws Exception {     // we should consider to shutdown the bus if the bus is created by cxfEndpoint     if (createBus && bus != null) {         log.info("shutdown the bus ... {}", bus).         getBus().shutdown(false).         // clean up the bus to create a new one if the endpoint is started again         bus = null.     } }
true;public;1;4;/**  * The service publish address.  */ ;/**  * The service publish address.  */ public void setAddress(String address) {     super.setEndpointUri(UnsafeUriCharactersEncoder.encodeHttpURI(address)).     this.address = address. }
false;public;0;3;;public String getAddress() {     return resolvePropertyPlaceholders(address). }
true;public;1;3;/**  * To enable MTOM (attachments). This requires to use POJO or PAYLOAD data format mode.  */ ;/**  * To enable MTOM (attachments). This requires to use POJO or PAYLOAD data format mode.  */ public void setMtomEnabled(boolean mtomEnabled) {     this.mtomEnabled = mtomEnabled. }
false;public;0;3;;public boolean isMtomEnabled() {     return mtomEnabled. }
false;public;0;3;;public String getPassword() {     return password. }
true;public;1;3;/**  * This option is used to set the basic authentication information of password for the CXF client.  */ ;/**  * This option is used to set the basic authentication information of password for the CXF client.  */ public void setPassword(String password) {     this.password = password. }
false;public;0;3;;public String getUsername() {     return username. }
true;public;1;3;/**  * This option is used to set the basic authentication information of username for the CXF client.  */ ;/**  * This option is used to set the basic authentication information of username for the CXF client.  */ public void setUsername(String username) {     this.username = username. }
false;public;0;6;;public CxfEndpointConfigurer getChainedCxfEndpointConfigurer() {     return ChainedCxfEndpointConfigurer.create(getNullSafeCxfEndpointConfigurer(), SslCxfEndpointConfigurer.create(sslContextParameters, getCamelContext())).addChild(HostnameVerifierCxfEndpointConfigurer.create(hostnameVerifier)). }
false;private;0;7;;private CxfEndpointConfigurer getNullSafeCxfEndpointConfigurer() {     if (cxfEndpointConfigurer == null) {         return new ChainedCxfEndpointConfigurer.NullCxfEndpointConfigurer().     } else {         return cxfEndpointConfigurer.     } }
false;protected;4;12;;@Override protected Object[] processResult(Message message, org.apache.cxf.message.Exchange exchange, BindingOperationInfo oi, Map<String, Object> resContext) throws Exception {     try {         return super.processResult(message, exchange, oi, resContext).     } catch (IllegalEmptyResponseException ex) {         // Thus, we'll capture the exception raised and return a null         return null.     } }
false;protected;2;58;;@SuppressWarnings("unchecked") @Override protected void setParameters(Object[] params, Message message) {     Object attachments = message.get(CxfConstants.CAMEL_CXF_ATTACHMENTS).     if (attachments != null) {         message.setAttachments((Collection<Attachment>) attachments).         message.remove(CxfConstants.CAMEL_CXF_ATTACHMENTS).     }     // as the setParameter will be called more than once when using the fail over feature     if (DataFormat.PAYLOAD == message.get(DataFormat.class) && params[0] instanceof CxfPayload) {         CxfPayload<?> payload = (CxfPayload<?>) params[0].         List<Source> elements = payload.getBodySources().         BindingOperationInfo boi = message.get(BindingOperationInfo.class).         MessageContentsList content = new MessageContentsList().         int i = 0.         for (MessagePartInfo partInfo : boi.getInput().getMessageParts()) {             if (elements.size() > i) {                 if (isSkipPayloadMessagePartCheck()) {                     content.put(partInfo, elements.get(i++)).                 } else {                     String name = findName(elements, i).                     if (partInfo.getConcreteName().getLocalPart().equals(name)) {                         content.put(partInfo, elements.get(i++)).                     }                 }             }         }         if (elements != null && content.size() < elements.size()) {             throw new IllegalArgumentException("The PayLoad elements cannot fit with the message parts of the BindingOperation. Please check the BindingOperation and PayLoadMessage.").         }         message.setContent(List.class, content).         // merge header list from request context with header list from CXF payload         List<Object> headerListOfRequestContxt = (List<Object>) message.get(Header.HEADER_LIST).         List<Object> headerListOfPayload = CastUtils.cast(payload.getHeaders()).         if (headerListOfRequestContxt == headerListOfPayload) {         // == is correct, we want to compare the object instances         // nothing to do, this can happen when the CXF payload is already created in the from-cxf-endpoint and then forwarded to a to-cxf-endpoint         } else {             if (headerListOfRequestContxt == null) {                 message.put(Header.HEADER_LIST, payload.getHeaders()).             } else {                 headerListOfRequestContxt.addAll(headerListOfPayload).             }         }     } else {         super.setParameters(params, message).     }     message.remove(DataFormat.class.getName()). }
false;private;2;38;;private String findName(List<Source> sources, int i) {     Source source = sources.get(i).     XMLStreamReader r = null.     if (source instanceof DOMSource) {         Node nd = ((DOMSource) source).getNode().         if (nd instanceof Document) {             nd = ((Document) nd).getDocumentElement().         }         return nd.getLocalName().     } else if (source instanceof StaxSource) {         StaxSource s = (StaxSource) source.         r = s.getXMLStreamReader().     } else if (source instanceof StAXSource) {         StAXSource s = (StAXSource) source.         r = s.getXMLStreamReader().     } else if (source instanceof StreamSource || source instanceof SAXSource) {         // flip to stax so we can get the name         r = StaxUtils.createXMLStreamReader(source).         StaxSource src2 = new StaxSource(r).         sources.set(i, src2).     }     if (r != null) {         try {             if (r.getEventType() == XMLStreamConstants.START_DOCUMENT) {                 r.next().             }             if (r.getEventType() != XMLStreamConstants.START_ELEMENT) {                 r.nextTag().             }         } catch (XMLStreamException e) {             // ignore             log.warn("Error finding the start element.", e).             return null.         }         return r.getLocalName().     }     return null. }
false;public;0;3;;public List<Interceptor<? extends Message>> getOutFaultInterceptors() {     return outFault. }
false;public;0;3;;public List<Interceptor<? extends Message>> getInFaultInterceptors() {     return inFault. }
false;public;0;3;;public List<Interceptor<? extends Message>> getInInterceptors() {     return in. }
false;public;0;3;;public List<Interceptor<? extends Message>> getOutInterceptors() {     return out. }
false;public;1;3;;public void setInInterceptors(List<Interceptor<? extends Message>> interceptors) {     in = interceptors. }
false;public;1;3;;public void setInFaultInterceptors(List<Interceptor<? extends Message>> interceptors) {     inFault = interceptors. }
false;public;1;3;;public void setOutInterceptors(List<Interceptor<? extends Message>> interceptors) {     out = interceptors. }
false;public;1;3;;public void setOutFaultInterceptors(List<Interceptor<? extends Message>> interceptors) {     outFault = interceptors. }
false;public;1;3;;public void setFeatures(List<Feature> f) {     features = f. }
false;public;0;3;;public List<Feature> getFeatures() {     return features. }
false;public;1;4;;@SuppressWarnings("rawtypes") public void setHandlers(List<Handler> h) {     handlers = h. }
false;public;0;4;;@SuppressWarnings("rawtypes") public List<Handler> getHandlers() {     return handlers. }
false;public;1;3;;public void setSchemaLocations(List<String> sc) {     schemaLocations = sc. }
false;public;0;3;;public List<String> getSchemaLocations() {     return schemaLocations. }
false;public;0;3;;public String getTransportId() {     return resolvePropertyPlaceholders(transportId). }
false;public;1;3;;public void setTransportId(String transportId) {     this.transportId = transportId. }
false;public;0;3;;public String getBindingId() {     return resolvePropertyPlaceholders(bindingId). }
true;public;1;3;/**  * The bindingId for the service model to use.  */ ;/**  * The bindingId for the service model to use.  */ public void setBindingId(String bindingId) {     this.bindingId = bindingId. }
false;public;0;3;;public BindingConfiguration getBindingConfig() {     return bindingConfig. }
false;public;0;3;;public boolean isSkipFaultLogging() {     return skipFaultLogging. }
true;public;1;3;/**  * This option controls whether the PhaseInterceptorChain skips logging the Fault that it catches.  */ ;/**  * This option controls whether the PhaseInterceptorChain skips logging the Fault that it catches.  */ public void setSkipFaultLogging(boolean skipFaultLogging) {     this.skipFaultLogging = skipFaultLogging. }
false;public;0;3;;public Boolean getMergeProtocolHeaders() {     return mergeProtocolHeaders. }
true;public;1;3;/**  * Whether to merge protocol headers. If enabled then propagating headers between Camel and CXF becomes more consistent and similar. For more details see CAMEL-6393.  */ ;/**  * Whether to merge protocol headers. If enabled then propagating headers between Camel and CXF becomes more consistent and similar. For more details see CAMEL-6393.  */ public void setMergeProtocolHeaders(boolean mergeProtocolHeaders) {     this.mergeProtocolHeaders = mergeProtocolHeaders. }
false;public;1;3;;public void setBindingConfig(BindingConfiguration bindingConfig) {     this.bindingConfig = bindingConfig. }
false;public;0;3;;public DataBinding getDataBinding() {     return dataBinding. }
false;public;1;3;;public void setDataBinding(DataBinding dataBinding) {     this.dataBinding = dataBinding. }
false;public;0;3;;public Object getServiceFactoryBean() {     return serviceFactoryBean. }
false;public;1;3;;public void setServiceFactoryBean(Object serviceFactoryBean) {     this.serviceFactoryBean = serviceFactoryBean. }
false;public;1;4;;public void setServiceFactory(Object serviceFactoryBean) {     // needed a setter with this name as the cxf namespace parser expects this name     this.serviceFactoryBean = serviceFactoryBean. }
false;public;0;3;;public CxfEndpointConfigurer getCxfEndpointConfigurer() {     return cxfEndpointConfigurer. }
true;public;1;3;/**  * This option could apply the implementation of org.apache.camel.component.cxf.CxfEndpointConfigurer which supports to configure the CXF endpoint  * in  programmatic way. User can configure the CXF server and client by implementing configure{Server|Client} method of CxfEndpointConfigurer.  */ ;/**  * This option could apply the implementation of org.apache.camel.component.cxf.CxfEndpointConfigurer which supports to configure the CXF endpoint  * in  programmatic way. User can configure the CXF server and client by implementing configure{Server|Client} method of CxfEndpointConfigurer.  */ public void setCxfEndpointConfigurer(CxfEndpointConfigurer configurer) {     this.cxfEndpointConfigurer = configurer. }
false;public;0;3;;public long getContinuationTimeout() {     return continuationTimeout. }
true;public;1;3;/**  * This option is used to set the CXF continuation timeout which could be used in CxfConsumer by default when the CXF server is using Jetty or Servlet transport.  */ ;/**  * This option is used to set the CXF continuation timeout which could be used in CxfConsumer by default when the CXF server is using Jetty or Servlet transport.  */ public void setContinuationTimeout(long continuationTimeout) {     this.continuationTimeout = continuationTimeout. }
false;public;0;3;;public SSLContextParameters getSslContextParameters() {     return sslContextParameters. }
true;public;1;3;/**  * The Camel SSL setting reference. Use the # notation to reference the SSL Context.  */ ;/**  * The Camel SSL setting reference. Use the # notation to reference the SSL Context.  */ public void setSslContextParameters(SSLContextParameters sslContextParameters) {     this.sslContextParameters = sslContextParameters. }
false;public;0;3;;public HostnameVerifier getHostnameVerifier() {     return hostnameVerifier. }
true;public;1;3;/**  * The hostname verifier to be used. Use the # notation to reference a HostnameVerifier  * from the registry.  */ ;/**  * The hostname verifier to be used. Use the # notation to reference a HostnameVerifier  * from the registry.  */ public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {     this.hostnameVerifier = hostnameVerifier. }
true;;1;12;/**  * get the request uri for a given exchange.  */ ;/**  * get the request uri for a given exchange.  */ URI getRequestUri(Exchange camelExchange) {     String uriString = camelExchange.getIn().getHeader(Exchange.DESTINATION_OVERRIDE_URL, String.class).     if (uriString == null) {         uriString = getAddress().     }     try {         return new URI(uriString).     } catch (URISyntaxException e) {         log.error("cannot determine request URI", e).         return null.     } }
