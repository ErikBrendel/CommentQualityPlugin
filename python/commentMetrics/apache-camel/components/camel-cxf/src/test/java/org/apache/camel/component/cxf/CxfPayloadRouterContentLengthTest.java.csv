commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected CamelContext createCamelContext() throws Exception {     return SpringCamelContext.springCamelContext(applicationContext, true). }
false;public;4;12;;@Override public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {     response.setContentType("text/xml").     // the Content-Length is correct for this response message     response.setContentLength(RESPONSE_MESSAGE.length()).     response.setStatus(HttpServletResponse.SC_OK).     baseRequest.setHandled(true).     PrintWriter pw = response.getWriter().     pw.write(RESPONSE_MESSAGE).     pw.close(). }
false;public;0;37;;@Before public void setUp() throws Exception {     /*          * We start a Jetty for the service in order to have better control over          * the response The response must contain only a Content-Type and a          * Content-Length but no other header          */     log.info("Starting jetty server at port {}", JETTY_PORT).     server = new Server().     // Do not send a Server header     HttpConfiguration httpconf = new HttpConfiguration().     httpconf.setSendServerVersion(false).     ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpconf)).     http.setPort(JETTY_PORT).     server.addConnector(http).     server.setHandler(new AbstractHandler() {          @Override         public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {             response.setContentType("text/xml").             // the Content-Length is correct for this response message             response.setContentLength(RESPONSE_MESSAGE.length()).             response.setStatus(HttpServletResponse.SC_OK).             baseRequest.setHandled(true).             PrintWriter pw = response.getWriter().             pw.write(RESPONSE_MESSAGE).             pw.close().         }     }).     server.start().     // Load the CXF endpoints for the route     log.info("Start Routing Scenario at port {}", CXFTestSupport.getPort1()).     applicationContext = new ClassPathXmlApplicationContext("org/apache/camel/component/cxf/CxfPayloadRouterContentLengthBeans.xml").     super.setUp().     assertNotNull("Should have created a valid spring context", applicationContext). }
false;public;0;11;;@After public void tearDown() throws Exception {     // close the spring context     IOHelper.close(applicationContext).     // stop the jetty server     if (server != null && server.isRunning()) {         server.stop().         server.join().     }     super.tearDown(). }
false;public;0;6;;public void configure() {     //      from("cxf:bean:proxyEndpoint?dataFormat=PAYLOAD").removeHeaders(".*").to("cxf:bean:serviceEndpoint?dataFormat=PAYLOAD"). }
false;protected;0;11;;@Override protected RouteBuilder createRouteBuilder() {     return new RouteBuilder() {          public void configure() {             //              from("cxf:bean:proxyEndpoint?dataFormat=PAYLOAD").removeHeaders(".*").to("cxf:bean:serviceEndpoint?dataFormat=PAYLOAD").         }     }. }
false;public;0;34;;@Test public void testInvokeRouter() throws IOException {     CloseableHttpClient httpclient = HttpClients.createDefault().     long contentLength = 0.     boolean isChunked = false.     String receivedContent = null.     try {         HttpPost httppost = new HttpPost("http://localhost:" + CXFTestSupport.getPort1() + "/TEST/PROXY").         StringEntity reqEntity = new StringEntity(REQUEST_MESSAGE, ContentType.TEXT_XML).         reqEntity.setChunked(false).         httppost.setEntity(reqEntity).         CloseableHttpResponse response = httpclient.execute(httppost).         try {             HttpEntity respEntity = response.getEntity().             contentLength = respEntity.getContentLength().             isChunked = respEntity.isChunked().             receivedContent = EntityUtils.toString(respEntity).             EntityUtils.consume(response.getEntity()).         } finally {             response.close().         }     } finally {         httpclient.close().     }     assertNotNull(receivedContent).     // chunked encoding is fine, we don't need to check the content length     if (!isChunked) {         assertEquals(receivedContent.length(), contentLength).     }     assertTrue("[" + receivedContent + "] does not contain [" + RESPONSE_STRING + "]", receivedContent.contains(RESPONSE_STRING)).     // check whether the response was cut off by the client because the     // Content-Length was wrong     assertTrue("[" + receivedContent + "] does not contain the closing Envelope tag.", receivedContent.matches(".*\\</.*:Envelope\\>")). }
