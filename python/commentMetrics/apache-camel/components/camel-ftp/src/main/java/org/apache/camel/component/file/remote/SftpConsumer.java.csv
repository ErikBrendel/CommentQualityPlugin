commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;25;;@Override protected void doStart() throws Exception {     // turn off scheduler first, so autoCreate is handled before scheduler starts     boolean startScheduler = isStartScheduler().     setStartScheduler(false).     try {         super.doStart().         if (endpoint.isAutoCreate()) {             log.debug("Auto creating directory: {}", endpoint.getConfiguration().getDirectory()).             try {                 connectIfNecessary().                 operations.buildDirectory(endpoint.getConfiguration().getDirectory(), true).             } catch (GenericFileOperationFailedException e) {                 // log a WARN as we want to start the consumer.                 log.warn("Error auto creating directory: " + endpoint.getConfiguration().getDirectory() + " due " + e.getMessage() + ". This exception is ignored.", e).             }         }     } finally {         if (startScheduler) {             setStartScheduler(true).             startScheduler().         }     } }
false;protected;3;18;;@Override protected boolean pollDirectory(String fileName, List<GenericFile<SftpRemoteFile>> fileList, int depth) {     String currentDir = null.     if (isStepwise()) {         // must remember current dir so we stay in that directory after the poll         currentDir = operations.getCurrentDirectory().     }     // strip trailing slash     fileName = FileUtil.stripTrailingSeparator(fileName).     boolean answer = doPollDirectory(fileName, null, fileList, depth).     if (currentDir != null) {         operations.changeCurrentDirectory(currentDir).     }     return answer. }
false;protected;4;8;;protected boolean pollSubDirectory(String absolutePath, String dirName, List<GenericFile<SftpRemoteFile>> fileList, int depth) {     boolean answer = doSafePollSubDirectory(absolutePath, dirName, fileList, depth).     // change back to parent directory when finished polling sub directory     if (isStepwise()) {         operations.changeToParentDirectory().     }     return answer. }
false;protected;4;92;;protected boolean doPollDirectory(String absolutePath, String dirName, List<GenericFile<SftpRemoteFile>> fileList, int depth) {     log.trace("doPollDirectory from absolutePath: {}, dirName: {}", absolutePath, dirName).     depth++.     // remove trailing /     dirName = FileUtil.stripTrailingSeparator(dirName).     // compute dir depending on stepwise is enabled or not     String dir = null.     List<SftpRemoteFile> files = null.     try {         if (isStepwise()) {             dir = ObjectHelper.isNotEmpty(dirName) ? dirName : absolutePath.             operations.changeCurrentDirectory(dir).         } else {             dir = absolutePath.         }         log.trace("Polling directory: {}", dir).         if (isUseList()) {             if (isStepwise()) {                 files = operations.listFiles().             } else {                 files = operations.listFiles(dir).             }         } else {             // we cannot use the LIST command(s) so we can only poll a named file             // so created a pseudo file with that name             fileExpressionResult = evaluateFileExpression().             if (fileExpressionResult != null) {                 SftpRemoteFile file = new SftpRemoteFileSingle(fileExpressionResult).                 files = new ArrayList<>(1).                 files.add(file).             }         }     } catch (GenericFileOperationFailedException e) {         if (ignoreCannotRetrieveFile(null, null, e)) {             log.debug("Cannot list files in directory {} due directory does not exists or file permission error.", dir).         } else {             throw e.         }     }     if (files == null || files.isEmpty()) {         // no files in this directory to poll         log.trace("No files found in directory: {}", dir).         return true.     } else {         // we found some files         log.trace("Found {} in directory: {}", files.size(), dir).     }     if (getEndpoint().isPreSort()) {         Collections.sort(files, (a, b) -> a.getFilename().compareTo(b.getFilename())).     }     for (SftpRemoteFile file : files) {         if (log.isTraceEnabled()) {             log.trace("SftpFile[fileName={}, longName={}, dir={}]", file.getFilename(), file.getLongname(), file.isDirectory()).         }         // check if we can continue polling in files         if (!canPollMoreFiles(fileList)) {             return false.         }         if (file.isDirectory()) {             RemoteFile<SftpRemoteFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset()).             if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(remote, true, files)) {                 // recursive scan and add the sub files and folders                 String subDirectory = file.getFilename().                 String path = absolutePath + "/" + subDirectory.                 boolean canPollMore = pollSubDirectory(path, subDirectory, fileList, depth).                 if (!canPollMore) {                     return false.                 }             }         // we cannot use file.getAttrs().isLink on Windows, so we dont invoke the method         // just assuming its a file we should poll         } else {             RemoteFile<SftpRemoteFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset()).             if (depth >= endpoint.getMinDepth() && isValidFile(remote, false, files)) {                 // matched file so add                 fileList.add(remote).             }         }     }     return true. }
false;protected;3;13;;@Override protected boolean isMatched(GenericFile<SftpRemoteFile> file, String doneFileName, List<SftpRemoteFile> files) {     String onlyName = FileUtil.stripPath(doneFileName).     for (SftpRemoteFile f : files) {         if (f.getFilename().equals(onlyName)) {             return true.         }     }     log.trace("Done file: {} does not exist", doneFileName).     return false. }
false;protected;3;10;;@Override protected boolean ignoreCannotRetrieveFile(String name, Exchange exchange, Exception cause) {     if (getEndpoint().getConfiguration().isIgnoreFileNotFoundOrPermissionError()) {         SftpException sftp = ObjectHelper.getException(SftpException.class, cause).         if (sftp != null) {             return sftp.id == ChannelSftp.SSH_FX_NO_SUCH_FILE || sftp.id == ChannelSftp.SSH_FX_PERMISSION_DENIED.         }     }     return super.ignoreCannotRetrieveFile(name, exchange, cause). }
false;private;3;36;;private RemoteFile<SftpRemoteFile> asRemoteFile(String absolutePath, SftpRemoteFile file, String charset) {     RemoteFile<SftpRemoteFile> answer = new RemoteFile<>().     answer.setCharset(charset).     answer.setEndpointPath(endpointPath).     answer.setFile(file).     answer.setFileNameOnly(file.getFilename()).     answer.setFileLength(file.getFileLength()).     answer.setLastModified(file.getLastModified()).     answer.setHostname(((RemoteFileConfiguration) endpoint.getConfiguration()).getHost()).     answer.setDirectory(file.isDirectory()).     // absolute or relative path     boolean absolute = FileUtil.hasLeadingSeparator(absolutePath).     answer.setAbsolute(absolute).     // create a pseudo absolute name     String dir = FileUtil.stripTrailingSeparator(absolutePath).     String absoluteFileName = FileUtil.stripLeadingSeparator(dir + "/" + file.getFilename()).     // if absolute start with a leading separator otherwise let it be relative     if (absolute) {         absoluteFileName = "/" + absoluteFileName.     }     answer.setAbsoluteFilePath(absoluteFileName).     // the relative filename, skip the leading endpoint configured path     String relativePath = StringHelper.after(absoluteFileName, endpointPath).     // skip trailing /     relativePath = FileUtil.stripLeadingSeparator(relativePath).     answer.setRelativeFilePath(relativePath).     // the file name should be the relative path     answer.setFileName(answer.getRelativeFilePath()).     return answer. }
false;protected;2;17;;@Override protected void updateFileHeaders(GenericFile<SftpRemoteFile> file, Message message) {     Object rf = file.getFile().getRemoteFile().     if (rf != null) {         ChannelSftp.LsEntry e = (ChannelSftp.LsEntry) rf.         long length = e.getAttrs().getSize().         long modified = e.getAttrs().getMTime() * 1000L.         file.setFileLength(length).         file.setLastModified(modified).         if (length >= 0) {             message.setHeader(Exchange.FILE_LENGTH, length).         }         if (modified >= 0) {             message.setHeader(Exchange.FILE_LAST_MODIFIED, modified).         }     } }
false;private;0;4;;private boolean isStepwise() {     RemoteFileConfiguration config = (RemoteFileConfiguration) endpoint.getConfiguration().     return config.isStepwise(). }
false;private;0;4;;private boolean isUseList() {     RemoteFileConfiguration config = (RemoteFileConfiguration) endpoint.getConfiguration().     return config.isUseList(). }
false;public;0;7;;@Override public String toString() {     if (sftpConsumerToString == null) {         sftpConsumerToString = "SftpConsumer[" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + "]".     }     return sftpConsumerToString. }
