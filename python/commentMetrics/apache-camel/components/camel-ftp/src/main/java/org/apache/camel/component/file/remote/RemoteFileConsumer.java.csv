commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override @SuppressWarnings("unchecked") public RemoteFileEndpoint<T> getEndpoint() {     return (RemoteFileEndpoint<T>) super.getEndpoint(). }
false;protected;0;3;;protected RemoteFileOperations<T> getOperations() {     return (RemoteFileOperations<T>) operations. }
false;protected;0;29;;protected boolean prePollCheck() throws Exception {     if (log.isTraceEnabled()) {         log.trace("prePollCheck on {}", getEndpoint().getConfiguration().remoteServerInformation()).     }     try {         connectIfNecessary().     } catch (Exception e) {         loggedIn = false.         // login failed should we thrown exception         if (getEndpoint().getConfiguration().isThrowExceptionOnConnectFailed()) {             throw e.         }     }     if (!loggedIn) {         String message = "Cannot connect/login to: " + remoteServer() + ". Will skip this poll.".         if (!loggedInWarning) {             log.warn(message).             loggedInWarning = true.         }         return false.     } else {         // need to log the failed log again         loggedInWarning = false.     }     return true. }
false;protected;1;15;;@Override protected void postPollCheck(int polledMessages) {     if (log.isTraceEnabled()) {         log.trace("postPollCheck on {}", getEndpoint().getConfiguration().remoteServerInformation()).     }     // as there is no exchanges to be routed that otherwise will disconnect from the last UoW     if (polledMessages == 0) {         if (getEndpoint().isDisconnect()) {             log.trace("postPollCheck disconnect from: {}", getEndpoint()).             disconnect().         }     } }
false;public;1;5;;@Override public void onDone(Exchange exchange) {     log.trace("processExchange disconnect from: {}", getEndpoint()).     disconnect(). }
false;public;0;5;;@Override public boolean allowHandover() {     // do not allow handover as we must execute the callbacks in the same thread as this consumer     return false. }
false;public;0;5;;@Override public int getOrder() {     // we want to disconnect last     return Ordered.LOWEST. }
false;public;0;3;;public String toString() {     return "Disconnect". }
false;protected;1;36;;@Override protected boolean processExchange(Exchange exchange) {     // mark the exchange to be processed synchronously as the ftp client is not thread safe     // and we must execute the callbacks in the same thread as this consumer     exchange.setProperty(Exchange.UNIT_OF_WORK_PROCESS_SYNC, Boolean.TRUE).     // defer disconnect til the UoW is complete - but only the last exchange from the batch should do that     boolean isLast = exchange.getProperty(Exchange.BATCH_COMPLETE, true, Boolean.class).     if (isLast && getEndpoint().isDisconnect()) {         exchange.addOnCompletion(new SynchronizationAdapter() {              @Override             public void onDone(Exchange exchange) {                 log.trace("processExchange disconnect from: {}", getEndpoint()).                 disconnect().             }              @Override             public boolean allowHandover() {                 // do not allow handover as we must execute the callbacks in the same thread as this consumer                 return false.             }              @Override             public int getOrder() {                 // we want to disconnect last                 return Ordered.LOWEST.             }              public String toString() {                 return "Disconnect".             }         }).     }     return super.processExchange(exchange). }
false;protected;0;4;;@Override protected boolean isRetrieveFile() {     return getEndpoint().isDownload(). }
false;protected;0;5;;@Override protected void doStop() throws Exception {     super.doStop().     disconnect(). }
false;protected;0;17;;protected void disconnect() {     // eager indicate we are no longer logged in     loggedIn = false.     // disconnect     try {         if (getOperations().isConnected()) {             if (log.isDebugEnabled()) {                 log.debug("Disconnecting from: {}", remoteServer()).             }             getOperations().disconnect().         }     } catch (GenericFileOperationFailedException e) {         // ignore just log a warning         log.warn("Error occurred while disconnecting from " + remoteServer() + " due: " + e.getMessage() + ". This exception will be ignored.").     } }
false;protected;0;15;;protected void forceDisconnect() {     // eager indicate we are no longer logged in     loggedIn = false.     // disconnect     try {         if (log.isDebugEnabled()) {             log.debug("Force disconnecting from: {}", remoteServer()).         }         getOperations().forceDisconnect().     } catch (GenericFileOperationFailedException e) {         // ignore just log a warning         log.warn("Error occurred while disconnecting from " + remoteServer() + " due: " + e.getMessage() + ". This exception will be ignored.").     } }
false;protected;0;22;;protected void connectIfNecessary() throws IOException {     // We need to send a noop first to check if the connection is still open     boolean isConnected = false.     try {         isConnected = getOperations().sendNoop().     } catch (Exception ex) {         // here we just ignore the exception and try to reconnect         if (log.isDebugEnabled()) {             log.debug("Exception checking connection status: {}", ex.getMessage()).         }     }     if (!loggedIn || !isConnected) {         if (log.isDebugEnabled()) {             log.debug("Not connected/logged in, connecting to: {}", remoteServer()).         }         loggedIn = getOperations().connect((RemoteFileConfiguration) endpoint.getConfiguration()).         if (loggedIn) {             log.debug("Connected and logged in to: {}", remoteServer()).         }     } }
true;protected;0;3;/**  * Returns human readable server information for logging purpose  */ ;/**  * Returns human readable server information for logging purpose  */ protected String remoteServer() {     return ((RemoteFileEndpoint<?>) endpoint).remoteServerInformation(). }
true;protected;4;21;/**  * Executes doPollDirectory and on exception checks if it can be ignored by calling ignoreCannotRetrieveFile.  *  * @param absolutePath  the path of the directory to poll  * @param dirName       the name of the directory to poll  * @param fileList      current list of files gathered  * @param depth         the current depth of the directory  * @return whether or not to continue polling, <tt>false</tt> means the maxMessagesPerPoll limit has been hit  * @throws GenericFileOperationFailedException if the exception during doPollDirectory can not be ignored  */ ;/**  * Executes doPollDirectory and on exception checks if it can be ignored by calling ignoreCannotRetrieveFile.  *  * @param absolutePath  the path of the directory to poll  * @param dirName       the name of the directory to poll  * @param fileList      current list of files gathered  * @param depth         the current depth of the directory  * @return whether or not to continue polling, <tt>false</tt> means the maxMessagesPerPoll limit has been hit  * @throws GenericFileOperationFailedException if the exception during doPollDirectory can not be ignored  */ protected boolean doSafePollSubDirectory(String absolutePath, String dirName, List<GenericFile<T>> fileList, int depth) {     try {         log.trace("Polling sub directory: {} from: {}", absolutePath, endpoint).         // Try to poll the directory         return doPollDirectory(absolutePath, dirName, fileList, depth).     } catch (Exception e) {         log.debug("Caught exception {}", e.getMessage()).         if (ignoreCannotRetrieveFile(absolutePath, null, e)) {             log.trace("Ignoring file error {} for {}", e.getMessage(), absolutePath).             // indicate no files in this directory to poll, continue with fileList             return true.         } else {             log.trace("Not ignoring file error {} for {}", e.getMessage(), absolutePath).             if (e instanceof GenericFileOperationFailedException) {                 throw (GenericFileOperationFailedException) e.             } else {                 throw new GenericFileOperationFailedException("Cannot poll sub-directory: " + absolutePath + " from: " + endpoint, e).             }         }     } }
true;protected,abstract;4;1;/**  * Poll directory given by dirName or absolutePath  *  * @param absolutePath The path of the directory to poll  * @param dirName The name of the directory to poll  * @param fileList current list of files gathered  * @param depth the current depth of the directory  * @return whether or not to continue polling, <tt>false</tt> means the maxMessagesPerPoll limit has been hit  */ ;/**  * Poll directory given by dirName or absolutePath  *  * @param absolutePath The path of the directory to poll  * @param dirName The name of the directory to poll  * @param fileList current list of files gathered  * @param depth the current depth of the directory  * @return whether or not to continue polling, <tt>false</tt> means the maxMessagesPerPoll limit has been hit  */ protected abstract boolean doPollDirectory(String absolutePath, String dirName, List<GenericFile<T>> fileList, int depth).
