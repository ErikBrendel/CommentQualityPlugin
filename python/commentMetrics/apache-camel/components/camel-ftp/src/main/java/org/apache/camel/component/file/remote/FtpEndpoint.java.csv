commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getScheme() {     return "ftp". }
false;public;1;10;;@Override public RemoteFileConsumer<FTPFile> createConsumer(Processor processor) throws Exception {     if (isResumeDownload() && ObjectHelper.isEmpty(getLocalWorkDirectory())) {         throw new IllegalArgumentException("The option localWorkDirectory must be configured when resumeDownload=true").     }     if (isResumeDownload() && !getConfiguration().isBinary()) {         throw new IllegalArgumentException("The option binary must be enabled when resumeDownload=true").     }     return super.createConsumer(processor). }
false;protected;1;8;;@Override protected RemoteFileConsumer<FTPFile> buildConsumer(Processor processor) {     try {         return new FtpConsumer(this, processor, createRemoteFileOperations(), processStrategy != null ? processStrategy : createGenericFileStrategy()).     } catch (Exception e) {         throw new FailedToCreateConsumerException(this, e).     } }
false;protected;0;10;;protected GenericFileProducer<FTPFile> buildProducer() {     try {         if (this.getMoveExistingFileStrategy() == null) {             this.setMoveExistingFileStrategy(createDefaultFtpMoveExistingFileStrategy()).         }         return new RemoteFileProducer<>(this, createRemoteFileOperations()).     } catch (Exception e) {         throw new FailedToCreateProducerException(this, e).     } }
true;private;0;3;/**  * Default Existing File Move Strategy  * @return the default implementation for ftp components  */ ;/**  * Default Existing File Move Strategy  * @return the default implementation for ftp components  */ private FileMoveExistingStrategy createDefaultFtpMoveExistingFileStrategy() {     return new FtpDefaultMoveExistingFileStrategy(). }
false;public;0;74;;public RemoteFileOperations<FTPFile> createRemoteFileOperations() throws Exception {     // configure ftp client     FTPClient client = ftpClient.     if (client == null) {         // must use a new client if not explicit configured to use a custom client         client = createFtpClient().     }     // use configured buffer size which is larger and therefore faster (as the default is no buffer)     if (getConfiguration().getReceiveBufferSize() > 0) {         client.setBufferSize(getConfiguration().getReceiveBufferSize()).     }     // set any endpoint configured timeouts     if (getConfiguration().getConnectTimeout() > -1) {         client.setConnectTimeout(getConfiguration().getConnectTimeout()).     }     if (getConfiguration().getSoTimeout() > -1) {         soTimeout = getConfiguration().getSoTimeout().     }     dataTimeout = getConfiguration().getTimeout().     if (getConfiguration().getActivePortRange() != null) {         // parse it as min-max         String[] parts = getConfiguration().getActivePortRange().split("-").         if (parts.length != 2) {             throw new IllegalArgumentException("The option activePortRange should have syntax: min-max").         }         int min = getCamelContext().getTypeConverter().mandatoryConvertTo(int.class, parts[0]).         int max = getCamelContext().getTypeConverter().mandatoryConvertTo(int.class, parts[1]).         log.debug("Using active port range: {}-{}", min, max).         client.setActivePortRange(min, max).     }     // then lookup ftp client parameters and set those     if (ftpClientParameters != null) {         Map<String, Object> localParameters = new HashMap<>(ftpClientParameters).         // setting soTimeout has to be done later on FTPClient (after it has connected)         Object timeout = localParameters.remove("soTimeout").         if (timeout != null) {             soTimeout = getCamelContext().getTypeConverter().convertTo(int.class, timeout).         }         // and we want to keep data timeout so we can log it later         timeout = localParameters.remove("dataTimeout").         if (timeout != null) {             dataTimeout = getCamelContext().getTypeConverter().convertTo(int.class, timeout).         }         setProperties(client, localParameters).     }     if (ftpClientConfigParameters != null) {         // client config is optional so create a new one if we have parameter for it         if (ftpClientConfig == null) {             ftpClientConfig = new FTPClientConfig().         }         Map<String, Object> localConfigParameters = new HashMap<>(ftpClientConfigParameters).         setProperties(ftpClientConfig, localConfigParameters).     }     if (dataTimeout > 0) {         client.setDataTimeout(dataTimeout).     }     if (log.isDebugEnabled()) {         log.debug("Created FTPClient [connectTimeout: {}, soTimeout: {}, dataTimeout: {}, bufferSize: {}" + ", receiveDataSocketBufferSize: {}, sendDataSocketBufferSize: {}]: {}", new Object[] { client.getConnectTimeout(), getSoTimeout(), dataTimeout, client.getBufferSize(), client.getReceiveDataSocketBufferSize(), client.getSendDataSocketBufferSize(), client }).     }     FtpOperations operations = new FtpOperations(client, getFtpClientConfig()).     operations.setEndpoint(this).     return operations. }
false;protected;0;12;;protected FTPClient createFtpClient() throws Exception {     FTPClient client = new FTPClient().     // default ParserFactory     if (isOsgi()) {         ClassResolver cr = getCamelContext().getClassResolver().         OsgiParserFactory opf = new OsgiParserFactory(cr).         client.setParserFactory(opf).     }     return client. }
false;private;0;3;;private boolean isOsgi() {     return PlatformHelper.isOsgiContext(getCamelContext()). }
false;public;0;7;;@Override public FtpConfiguration getConfiguration() {     if (configuration == null) {         configuration = new FtpConfiguration().     }     return configuration. }
false;public;1;9;;@Override public void setConfiguration(GenericFileConfiguration configuration) {     if (configuration == null) {         throw new IllegalArgumentException("FtpConfiguration expected").     }     // need to set on both     this.configuration = (FtpConfiguration) configuration.     super.setConfiguration(configuration). }
false;public;0;3;;public FTPClient getFtpClient() {     return ftpClient. }
true;public;1;3;/**  * To use a custom instance of FTPClient  */ ;/**  * To use a custom instance of FTPClient  */ public void setFtpClient(FTPClient ftpClient) {     this.ftpClient = ftpClient. }
false;public;0;3;;public FTPClientConfig getFtpClientConfig() {     return ftpClientConfig. }
true;public;1;3;/**  * To use a custom instance of FTPClientConfig to configure the FTP client the endpoint should use.  */ ;/**  * To use a custom instance of FTPClientConfig to configure the FTP client the endpoint should use.  */ public void setFtpClientConfig(FTPClientConfig ftpClientConfig) {     this.ftpClientConfig = ftpClientConfig. }
true;;1;3;/**  * Used by FtpComponent to provide additional parameters for the FTPClient  */ ;/**  * Used by FtpComponent to provide additional parameters for the FTPClient  */ void setFtpClientParameters(Map<String, Object> ftpClientParameters) {     this.ftpClientParameters = ftpClientParameters. }
true;;1;3;/**  * Used by FtpComponent to provide additional parameters for the FTPClientConfig  */ ;/**  * Used by FtpComponent to provide additional parameters for the FTPClientConfig  */ void setFtpClientConfigParameters(Map<String, Object> ftpClientConfigParameters) {     this.ftpClientConfigParameters = new HashMap<>(ftpClientConfigParameters). }
false;public;0;3;;public int getSoTimeout() {     return soTimeout. }
true;public;1;3;/**  * Sets the soTimeout on the FTP client.  */ ;/**  * Sets the soTimeout on the FTP client.  */ public void setSoTimeout(int soTimeout) {     this.soTimeout = soTimeout. }
false;public;0;3;;public int getDataTimeout() {     return dataTimeout. }
true;public;1;3;/**  * Sets the data timeout on the FTP client.  */ ;/**  * Sets the data timeout on the FTP client.  */ public void setDataTimeout(int dataTimeout) {     this.dataTimeout = dataTimeout. }
false;public;0;3;;public LoggingLevel getTransferLoggingLevel() {     return transferLoggingLevel. }
true;public;1;3;/**  * Configure the logging level to use when logging the progress of upload and download operations.  */ ;/**  * Configure the logging level to use when logging the progress of upload and download operations.  */ public void setTransferLoggingLevel(LoggingLevel transferLoggingLevel) {     this.transferLoggingLevel = transferLoggingLevel. }
false;public;1;4;;@ManagedAttribute(description = "Logging level to use when logging the progress of upload and download operations") public void setTransferLoggingLevelName(String transferLoggingLevel) {     this.transferLoggingLevel = getCamelContext().getTypeConverter().convertTo(LoggingLevel.class, transferLoggingLevel). }
false;public;0;4;;@ManagedAttribute public String getTransferLoggingLevelName() {     return transferLoggingLevel.name(). }
false;public;0;4;;@ManagedAttribute public int getTransferLoggingIntervalSeconds() {     return transferLoggingIntervalSeconds. }
true;public;1;4;/**  * Configures the interval in seconds to use when logging the progress of upload and download operations that are in-flight.  * This is used for logging progress when operations takes longer time.  */ ;/**  * Configures the interval in seconds to use when logging the progress of upload and download operations that are in-flight.  * This is used for logging progress when operations takes longer time.  */ @ManagedAttribute(description = "Interval in seconds to use when logging the progress of upload and download operations that are in-flight") public void setTransferLoggingIntervalSeconds(int transferLoggingIntervalSeconds) {     this.transferLoggingIntervalSeconds = transferLoggingIntervalSeconds. }
false;public;0;4;;@ManagedAttribute public boolean isTransferLoggingVerbose() {     return transferLoggingVerbose. }
true;public;1;4;/**  * Configures whether the perform verbose (fine grained) logging of the progress of upload and download operations.  */ ;/**  * Configures whether the perform verbose (fine grained) logging of the progress of upload and download operations.  */ @ManagedAttribute(description = "Whether the perform verbose (fine grained) logging of the progress of upload and download operations") public void setTransferLoggingVerbose(boolean transferLoggingVerbose) {     this.transferLoggingVerbose = transferLoggingVerbose. }
false;public;0;3;;public boolean isResumeDownload() {     return resumeDownload. }
true;public;1;3;/**  * Configures whether resume download is enabled. This must be supported by the FTP server (almost all FTP servers support it).  * In addition the options <tt>localWorkDirectory</tt> must be configured so downloaded files are stored in a local directory,  * and the option <tt>binary</tt> must be enabled, which is required to support resuming of downloads.  */ ;/**  * Configures whether resume download is enabled. This must be supported by the FTP server (almost all FTP servers support it).  * In addition the options <tt>localWorkDirectory</tt> must be configured so downloaded files are stored in a local directory,  * and the option <tt>binary</tt> must be enabled, which is required to support resuming of downloads.  */ public void setResumeDownload(boolean resumeDownload) {     this.resumeDownload = resumeDownload. }
false;public;0;15;;@Override public char getFileSeparator() {     // the regular ftp component should use the configured separator     // as FTP servers may require you to use windows or unix style     // and therefore you need to be able to control that     PathSeparator pathSeparator = getConfiguration().getSeparator().     switch(pathSeparator) {         case Windows:             return '\\'.         case UNIX:             return '/'.         default:             return super.getFileSeparator().     } }
