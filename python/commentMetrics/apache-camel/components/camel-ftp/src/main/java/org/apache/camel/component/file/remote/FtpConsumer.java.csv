commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected FtpOperations getOperations() {     return (FtpOperations) super.getOperations(). }
false;protected;0;25;;@Override protected void doStart() throws Exception {     // turn off scheduler first, so autoCreate is handled before scheduler starts     boolean startScheduler = isStartScheduler().     setStartScheduler(false).     try {         super.doStart().         if (endpoint.isAutoCreate()) {             log.debug("Auto creating directory: {}", endpoint.getConfiguration().getDirectory()).             try {                 connectIfNecessary().                 operations.buildDirectory(endpoint.getConfiguration().getDirectory(), true).             } catch (GenericFileOperationFailedException e) {                 // log a WARN as we want to start the consumer.                 log.warn("Error auto creating directory: " + endpoint.getConfiguration().getDirectory() + " due " + e.getMessage() + ". This exception is ignored.", e).             }         }     } finally {         if (startScheduler) {             setStartScheduler(true).             startScheduler().         }     } }
false;protected;3;18;;@Override protected boolean pollDirectory(String fileName, List<GenericFile<FTPFile>> fileList, int depth) {     String currentDir = null.     if (isStepwise()) {         // must remember current dir so we stay in that directory after the poll         currentDir = operations.getCurrentDirectory().     }     // strip trailing slash     fileName = FileUtil.stripTrailingSeparator(fileName).     boolean answer = doPollDirectory(fileName, null, fileList, depth).     if (currentDir != null) {         operations.changeCurrentDirectory(currentDir).     }     return answer. }
false;protected;4;8;;protected boolean pollSubDirectory(String absolutePath, String dirName, List<GenericFile<FTPFile>> fileList, int depth) {     boolean answer = doSafePollSubDirectory(absolutePath, dirName, fileList, depth).     // change back to parent directory when finished polling sub directory     if (isStepwise()) {         operations.changeToParentDirectory().     }     return answer. }
false;protected;4;94;;protected boolean doPollDirectory(String absolutePath, String dirName, List<GenericFile<FTPFile>> fileList, int depth) {     log.trace("doPollDirectory from absolutePath: {}, dirName: {}", absolutePath, dirName).     depth++.     // remove trailing /     dirName = FileUtil.stripTrailingSeparator(dirName).     // compute dir depending on stepwise is enabled or not     String dir = null.     List<FTPFile> files = null.     try {         if (isStepwise()) {             dir = ObjectHelper.isNotEmpty(dirName) ? dirName : absolutePath.             operations.changeCurrentDirectory(dir).         } else {             dir = absolutePath.         }         log.trace("Polling directory: {}", dir).         if (isUseList()) {             if (isStepwise()) {                 files = operations.listFiles().             } else {                 files = operations.listFiles(dir).             }         } else {             // we cannot use the LIST command(s) so we can only poll a named file             // so created a pseudo file with that name             FTPFile file = new FTPFile().             file.setType(FTPFile.FILE_TYPE).             fileExpressionResult = evaluateFileExpression().             if (fileExpressionResult != null) {                 file.setName(fileExpressionResult).                 files = new ArrayList<>(1).                 files.add(file).             }         }     } catch (GenericFileOperationFailedException e) {         if (ignoreCannotRetrieveFile(null, null, e)) {             log.debug("Cannot list files in directory {} due directory does not exists or file permission error.", dir).         } else {             throw e.         }     }     if (files == null || files.isEmpty()) {         // no files in this directory to poll         log.trace("No files found in directory: {}", dir).         return true.     } else {         // we found some files         log.trace("Found {} in directory: {}", files.size(), dir).     }     if (getEndpoint().isPreSort()) {         Collections.sort(files, (a, b) -> a.getName().compareTo(b.getName())).     }     for (FTPFile file : files) {         if (log.isTraceEnabled()) {             log.trace("FtpFile[name={}, dir={}, file={}]", file.getName(), file.isDirectory(), file.isFile()).         }         // check if we can continue polling in files         if (!canPollMoreFiles(fileList)) {             return false.         }         if (file.isDirectory()) {             RemoteFile<FTPFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset()).             if (endpoint.isRecursive() && depth < endpoint.getMaxDepth() && isValidFile(remote, true, files)) {                 // recursive scan and add the sub files and folders                 String subDirectory = file.getName().                 String path = absolutePath + "/" + subDirectory.                 boolean canPollMore = pollSubDirectory(path, subDirectory, fileList, depth).                 if (!canPollMore) {                     return false.                 }             }         } else if (file.isFile()) {             RemoteFile<FTPFile> remote = asRemoteFile(absolutePath, file, getEndpoint().getCharset()).             if (depth >= endpoint.getMinDepth() && isValidFile(remote, false, files)) {                 // matched file so add                 fileList.add(remote).             }         } else {             log.debug("Ignoring unsupported remote file type: {}", file).         }     }     return true. }
false;protected;3;13;;@Override protected boolean isMatched(GenericFile<FTPFile> file, String doneFileName, List<FTPFile> files) {     String onlyName = FileUtil.stripPath(doneFileName).     for (FTPFile f : files) {         if (f.getName().equals(onlyName)) {             return true.         }     }     log.trace("Done file: {} does not exist", doneFileName).     return false. }
false;protected;3;20;;@Override protected boolean ignoreCannotRetrieveFile(String name, Exchange exchange, Exception cause) {     if (getEndpoint().getConfiguration().isIgnoreFileNotFoundOrPermissionError()) {         if (exchange != null) {             // error code 550 is file not found             int code = exchange.getIn().getHeader(FtpConstants.FTP_REPLY_CODE, 0, int.class).             if (code == 550) {                 return true.             }         }         if (cause instanceof GenericFileOperationFailedException) {             GenericFileOperationFailedException generic = ObjectHelper.getException(GenericFileOperationFailedException.class, cause).             // exchange is null and cause has the reason for failure to read directories             if (generic.getCode() == 550) {                 return true.             }         }     }     return super.ignoreCannotRetrieveFile(name, exchange, cause). }
false;private;3;42;;private RemoteFile<FTPFile> asRemoteFile(String absolutePath, FTPFile file, String charset) {     RemoteFile<FTPFile> answer = new RemoteFile<>().     answer.setCharset(charset).     answer.setEndpointPath(endpointPath).     answer.setFile(file).     answer.setFileNameOnly(file.getName()).     answer.setFileLength(file.getSize()).     answer.setDirectory(file.isDirectory()).     if (file.getTimestamp() != null) {         answer.setLastModified(file.getTimestamp().getTimeInMillis()).     }     answer.setHostname(((RemoteFileConfiguration) endpoint.getConfiguration()).getHost()).     // absolute or relative path     boolean absolute = FileUtil.hasLeadingSeparator(absolutePath).     answer.setAbsolute(absolute).     // create a pseudo absolute name     String dir = FileUtil.stripTrailingSeparator(absolutePath).     String fileName = file.getName().     if (((FtpConfiguration) endpoint.getConfiguration()).isHandleDirectoryParserAbsoluteResult()) {         fileName = FtpUtils.extractDirNameFromAbsolutePath(file.getName()).     }     String absoluteFileName = FileUtil.stripLeadingSeparator(dir + "/" + fileName).     // if absolute start with a leading separator otherwise let it be relative     if (absolute) {         absoluteFileName = "/" + absoluteFileName.     }     answer.setAbsoluteFilePath(absoluteFileName).     // the relative filename, skip the leading endpoint configured path     String relativePath = StringHelper.after(absoluteFileName, endpointPath).     // skip leading /     relativePath = FileUtil.stripLeadingSeparator(relativePath).     answer.setRelativeFilePath(relativePath).     // the file name should be the relative path     answer.setFileName(answer.getRelativeFilePath()).     return answer. }
false;protected;2;13;;@Override protected void updateFileHeaders(GenericFile<FTPFile> file, Message message) {     long length = file.getFile().getSize().     long modified = file.getFile().getTimestamp() != null ? file.getFile().getTimestamp().getTimeInMillis() : -1.     file.setFileLength(length).     file.setLastModified(modified).     if (length >= 0) {         message.setHeader(Exchange.FILE_LENGTH, length).     }     if (modified >= 0) {         message.setHeader(Exchange.FILE_LAST_MODIFIED, modified).     } }
false;private;0;4;;private boolean isStepwise() {     RemoteFileConfiguration config = (RemoteFileConfiguration) endpoint.getConfiguration().     return config.isStepwise(). }
false;private;0;4;;private boolean isUseList() {     RemoteFileConfiguration config = (RemoteFileConfiguration) endpoint.getConfiguration().     return config.isUseList(). }
false;public;0;20;;@ManagedAttribute(description = "Summary of last FTP activity (download only)") public String getLastFtpActivity() {     FTPClient client = getOperations().getFtpClient().     FtpClientActivityListener listener = (FtpClientActivityListener) client.getCopyStreamListener().     if (listener != null) {         String log = listener.getLastLogActivity().         if (log != null) {             long since = listener.getLastLogActivityTimestamp().             if (since > 0) {                 StopWatch watch = new StopWatch(new Date(since)).                 long delta = watch.taken().                 String human = TimeUtils.printDuration(delta).                 return log + " " + human + " ago".             } else {                 return log.             }         }     }     return null. }
false;public;0;20;;@ManagedAttribute(description = "Summary of last FTP activity (all)") public String getLastFtpActivityVerbose() {     FTPClient client = getOperations().getFtpClient().     FtpClientActivityListener listener = (FtpClientActivityListener) client.getCopyStreamListener().     if (listener != null) {         String log = listener.getLastVerboseLogActivity().         if (log != null) {             long since = listener.getLastVerboseLogActivityTimestamp().             if (since > 0) {                 StopWatch watch = new StopWatch(new Date(since)).                 long delta = watch.taken().                 String human = TimeUtils.printDuration(delta).                 return log + " " + human + " ago".             } else {                 return log.             }         }     }     return null. }
false;public;0;7;;@Override public String toString() {     if (ftpConsumerToString == null) {         ftpConsumerToString = "FtpConsumer[" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + "]".     }     return ftpConsumerToString. }
