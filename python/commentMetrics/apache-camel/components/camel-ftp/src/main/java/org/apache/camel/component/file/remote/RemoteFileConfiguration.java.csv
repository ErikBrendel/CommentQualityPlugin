commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean needToNormalize() {     return false. }
false;public;1;27;;@Override public void configure(URI uri) {     super.configure(uri).     // after configure the directory has been resolved, so we can use it for directoryName     // (directoryName is the name we use in the other file components, to use consistent name)     setDirectoryName(getDirectory()).     setProtocol(uri.getScheme()).     setDefaultPort().     // UserInfo can contain both username and password as: user:pwd@ftpserver     // see: http://en.wikipedia.org/wiki/URI_scheme     String username = uri.getUserInfo().     String pw = null.     if (username != null && username.contains(":")) {         pw = StringHelper.after(username, ":").         username = StringHelper.before(username, ":").     }     if (username != null) {         setUsername(username).     }     if (pw != null) {         setPassword(pw).     }     setHost(uri.getHost()).     setPort(uri.getPort()). }
true;public;0;3;/**  * Returns human readable server information for logging purpose  */ ;/**  * Returns human readable server information for logging purpose  */ public String remoteServerInformation() {     return protocol + "://" + (username != null ? username : "anonymous") + "@" + host + ":" + getPort(). }
false;protected,abstract;0;1;;protected abstract void setDefaultPort().
false;public;0;3;;public String getHost() {     return host. }
true;public;1;3;/**  * Hostname of the FTP server  */ ;/**  * Hostname of the FTP server  */ public void setHost(String host) {     this.host = host. }
false;public;0;3;;public int getPort() {     return port. }
true;public;1;6;/**  * Port of the FTP server  */ ;/**  * Port of the FTP server  */ public void setPort(int port) {     // only set port if provided with a positive number     if (port > 0) {         this.port = port.     } }
false;public;0;3;;public String getPassword() {     return password. }
true;public;1;3;/**  * Password to use for login  */ ;/**  * Password to use for login  */ public void setPassword(String password) {     this.password = password. }
false;public;0;3;;public String getProtocol() {     return protocol. }
true;public;1;3;/**  * The ftp protocol to use  */ ;/**  * The ftp protocol to use  */ public void setProtocol(String protocol) {     this.protocol = protocol. }
false;public;0;3;;public String getUsername() {     return username. }
true;public;1;3;/**  * Username to use for login  */ ;/**  * Username to use for login  */ public void setUsername(String username) {     this.username = username. }
false;public;0;3;;public String getDirectoryName() {     return directoryName. }
true;public;1;3;/**  * The starting directory  */ ;/**  * The starting directory  */ public void setDirectoryName(String directoryName) {     this.directoryName = directoryName. }
false;public;0;3;;public boolean isBinary() {     return binary. }
true;public;1;3;/**  * Specifies the file transfer mode, BINARY or ASCII. Default is ASCII (false).  */ ;/**  * Specifies the file transfer mode, BINARY or ASCII. Default is ASCII (false).  */ public void setBinary(boolean binary) {     this.binary = binary. }
false;public;0;3;;public boolean isPassiveMode() {     return passiveMode. }
true;public;1;3;/**  * Sets passive mode connections.  * <br/>  * Default is active mode connections.  */ ;/**  * Sets passive mode connections.  * <br/>  * Default is active mode connections.  */ public void setPassiveMode(boolean passiveMode) {     this.passiveMode = passiveMode. }
false;public;0;3;;public int getConnectTimeout() {     return connectTimeout. }
true;public;1;3;/**  * Sets the connect timeout for waiting for a connection to be established  * <p/>  * Used by both FTPClient and JSCH  */ ;/**  * Sets the connect timeout for waiting for a connection to be established  * <p/>  * Used by both FTPClient and JSCH  */ public void setConnectTimeout(int connectTimeout) {     this.connectTimeout = connectTimeout. }
false;public;0;3;;public int getTimeout() {     return timeout. }
true;public;1;3;/**  * Sets the data timeout for waiting for reply  * <p/>  * Used only by FTPClient  */ ;/**  * Sets the data timeout for waiting for reply  * <p/>  * Used only by FTPClient  */ public void setTimeout(int timeout) {     this.timeout = timeout. }
false;public;0;3;;public int getSoTimeout() {     return soTimeout. }
true;public;1;3;/**  * Sets the so timeout  * <p/>  * FTP and FTPS Only for Camel 2.4. SFTP for Camel 2.14.3/2.15.3/2.16 onwards.  * Is the SocketOptions.SO_TIMEOUT value in millis.  * Recommended option is to set this to 300000 so as not have a hanged connection.  * On SFTP this option is set as timeout on the JSCH Session instance.  */ ;/**  * Sets the so timeout  * <p/>  * FTP and FTPS Only for Camel 2.4. SFTP for Camel 2.14.3/2.15.3/2.16 onwards.  * Is the SocketOptions.SO_TIMEOUT value in millis.  * Recommended option is to set this to 300000 so as not have a hanged connection.  * On SFTP this option is set as timeout on the JSCH Session instance.  */ public void setSoTimeout(int soTimeout) {     this.soTimeout = soTimeout. }
false;public;0;3;;public int getReceiveBufferSize() {     return receiveBufferSize. }
true;public;1;3;/**  * The receive (download) buffer size  * <p/>  * Used only by FTPClient  */ ;/**  * The receive (download) buffer size  * <p/>  * Used only by FTPClient  */ public void setReceiveBufferSize(int receiveBufferSize) {     this.receiveBufferSize = receiveBufferSize. }
false;public;0;3;;public boolean isThrowExceptionOnConnectFailed() {     return throwExceptionOnConnectFailed. }
true;public;1;3;/**  * Should an exception be thrown if connection failed (exhausted)  * <p/>  * By default exception is not thrown and a <tt>WARN</tt> is logged.  * You can use this to enable exception being thrown and handle the thrown exception  * from the {@link org.apache.camel.spi.PollingConsumerPollStrategy} rollback method.  */ ;/**  * Should an exception be thrown if connection failed (exhausted)  * <p/>  * By default exception is not thrown and a <tt>WARN</tt> is logged.  * You can use this to enable exception being thrown and handle the thrown exception  * from the {@link org.apache.camel.spi.PollingConsumerPollStrategy} rollback method.  */ public void setThrowExceptionOnConnectFailed(boolean throwExceptionOnConnectFailed) {     this.throwExceptionOnConnectFailed = throwExceptionOnConnectFailed. }
false;public;0;3;;public String getSiteCommand() {     return siteCommand. }
true;public;1;3;/**  * Sets optional site command(s) to be executed after successful login.  * <p/>  * Multiple site commands can be separated using a new line character.  */ ;/**  * Sets optional site command(s) to be executed after successful login.  * <p/>  * Multiple site commands can be separated using a new line character.  */ public void setSiteCommand(String siteCommand) {     this.siteCommand = siteCommand. }
false;public;0;3;;public boolean isStepwise() {     return stepwise. }
true;public;1;3;/**  * Sets whether we should stepwise change directories while traversing file structures  * when downloading files, or as well when uploading a file to a directory.  * <p/>  * You can disable this if you for example are in a situation where you cannot change directory  * on the FTP server due security reasons.  *  * @param stepwise whether to use change directory or not  */ ;/**  * Sets whether we should stepwise change directories while traversing file structures  * when downloading files, or as well when uploading a file to a directory.  * <p/>  * You can disable this if you for example are in a situation where you cannot change directory  * on the FTP server due security reasons.  *  * @param stepwise whether to use change directory or not  */ public void setStepwise(boolean stepwise) {     this.stepwise = stepwise. }
false;public;0;3;;public PathSeparator getSeparator() {     return separator. }
true;public;1;3;/**  * Sets the path separator to be used.  * <p/>  * UNIX = Uses unix style path separator  * Windows = Uses windows style path separator  * Auto = (is default) Use existing path separator in file name  */ ;/**  * Sets the path separator to be used.  * <p/>  * UNIX = Uses unix style path separator  * Windows = Uses windows style path separator  * Auto = (is default) Use existing path separator in file name  */ public void setSeparator(PathSeparator separator) {     this.separator = separator. }
false;public;0;3;;public boolean isStreamDownload() {     return streamDownload. }
true;public;1;3;/**  * Sets the download method to use when not using a local working directory.  If set to true,  * the remote files are streamed to the route as they are read.  When set to false, the remote files  * are loaded into memory before being sent into the route.  */ ;/**  * Sets the download method to use when not using a local working directory.  If set to true,  * the remote files are streamed to the route as they are read.  When set to false, the remote files  * are loaded into memory before being sent into the route.  */ public void setStreamDownload(boolean streamDownload) {     this.streamDownload = streamDownload. }
false;public;0;3;;public boolean isUseList() {     return useList. }
true;public;1;3;/**  * Whether to allow using LIST command when downloading a file.  * <p/>  * Default is <tt>true</tt>. In some use cases you may want to download  * a specific file and are not allowed to use the LIST command, and therefore  * you can set this option to <tt>false</tt>.  * Notice when using this option, then the specific file to download does <b>not</b>  * include meta-data information such as file size, timestamp, permissions etc, because  * those information is only possible to retrieve when LIST command is in use.  */ ;/**  * Whether to allow using LIST command when downloading a file.  * <p/>  * Default is <tt>true</tt>. In some use cases you may want to download  * a specific file and are not allowed to use the LIST command, and therefore  * you can set this option to <tt>false</tt>.  * Notice when using this option, then the specific file to download does <b>not</b>  * include meta-data information such as file size, timestamp, permissions etc, because  * those information is only possible to retrieve when LIST command is in use.  */ public void setUseList(boolean useList) {     this.useList = useList. }
false;public;0;3;;public boolean isIgnoreFileNotFoundOrPermissionError() {     return ignoreFileNotFoundOrPermissionError. }
true;public;1;3;/**  * Whether to ignore when (trying to list files in directories or when downloading a file), which does not exist or due to permission error.  * <p/>  * By default when a directory or file does not exists or insufficient permission, then an exception is thrown.  * Setting this option to <tt>true</tt> allows to ignore that instead.  */ ;/**  * Whether to ignore when (trying to list files in directories or when downloading a file), which does not exist or due to permission error.  * <p/>  * By default when a directory or file does not exists or insufficient permission, then an exception is thrown.  * Setting this option to <tt>true</tt> allows to ignore that instead.  */ public void setIgnoreFileNotFoundOrPermissionError(boolean ignoreFileNotFoundOrPermissionError) {     this.ignoreFileNotFoundOrPermissionError = ignoreFileNotFoundOrPermissionError. }
false;public;0;3;;public boolean isSendNoop() {     return sendNoop. }
true;public;1;3;/**  * Whether to send a noop command as a pre-write check before uploading files to the FTP server.  * <p/>  * This is enabled by default as a validation of the connection is still valid, which allows to silently  * re-connect to be able to upload the file. However if this causes problems, you can turn this option off.  */ ;/**  * Whether to send a noop command as a pre-write check before uploading files to the FTP server.  * <p/>  * This is enabled by default as a validation of the connection is still valid, which allows to silently  * re-connect to be able to upload the file. However if this causes problems, you can turn this option off.  */ public void setSendNoop(boolean sendNoop) {     this.sendNoop = sendNoop. }
true;public;1;13;/**  * Normalizes the given path according to the configured path separator.  *  * @param path  the given path  * @return the normalized path  */ ;/**  * Normalizes the given path according to the configured path separator.  *  * @param path  the given path  * @return the normalized path  */ public String normalizePath(String path) {     if (ObjectHelper.isEmpty(path) || separator == PathSeparator.Auto) {         return path.     }     if (separator == PathSeparator.UNIX) {         // unix style         return path.replace('\\', '/').     } else {         // windows style         return path.replace('/', '\\').     } }
