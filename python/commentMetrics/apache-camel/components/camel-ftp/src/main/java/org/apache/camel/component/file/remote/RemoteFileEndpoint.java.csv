commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public RemoteFileConfiguration getConfiguration() {     return (RemoteFileConfiguration) this.configuration. }
false;public;1;8;;@Override public Exchange createExchange(GenericFile<T> file) {     Exchange answer = super.createExchange().     if (file != null) {         file.bindToExchange(answer).     }     return answer. }
false;public;0;13;;@Override public GenericFileProducer<T> createProducer() throws Exception {     afterPropertiesSet().     // ensure fileExist and moveExisting is configured correctly if in use     if (getFileExist() == GenericFileExist.Move && getMoveExisting() == null) {         throw new IllegalArgumentException("You must configure moveExisting option when fileExist=Move").     } else if (getMoveExisting() != null && getFileExist() != GenericFileExist.Move) {         throw new IllegalArgumentException("You must configure fileExist=Move when moveExisting has been set").     }     return buildProducer(). }
false;public;1;32;;@Override public RemoteFileConsumer<T> createConsumer(Processor processor) throws Exception {     afterPropertiesSet().     RemoteFileConsumer<T> consumer = buildConsumer(processor).     if (isDelete() && getMove() != null) {         throw new IllegalArgumentException("You cannot both set delete=true and move options").     }     // if noop=true then idempotent should also be configured     if (isNoop() && !isIdempotentSet()) {         log.info("Endpoint is configured with noop=true so forcing endpoint to be idempotent as well").         setIdempotent(true).     }     // if idempotent and no repository set then create a default one     if (isIdempotentSet() && isIdempotent() && idempotentRepository == null) {         log.info("Using default memory based idempotent repository with cache max size: {}", DEFAULT_IDEMPOTENT_CACHE_SIZE).         idempotentRepository = MemoryIdempotentRepository.memoryIdempotentRepository(DEFAULT_IDEMPOTENT_CACHE_SIZE).     }     if (!getConfiguration().isUseList() && getFileName() == null) {         throw new IllegalArgumentException("Endpoint is configured with useList=false, then fileName must be configured also").     }     // set max messages per poll     consumer.setMaxMessagesPerPoll(getMaxMessagesPerPoll()).     consumer.setEagerLimitMaxMessagesPerPoll(isEagerMaxMessagesPerPoll()).     configureConsumer(consumer).     return consumer. }
false;public;0;13;;@Override public PollingConsumer createPollingConsumer() throws Exception {     if (log.isDebugEnabled()) {         log.debug("Creating GenericFilePollingConsumer with queueSize: {} blockWhenFull: {} blockTimeout: {}", getPollingConsumerQueueSize(), isPollingConsumerBlockWhenFull(), getPollingConsumerBlockTimeout()).     }     GenericFilePollingConsumer result = new GenericFilePollingConsumer(this).     // should not call configurePollingConsumer when its GenericFilePollingConsumer     result.setBlockWhenFull(isPollingConsumerBlockWhenFull()).     result.setBlockTimeout(getPollingConsumerBlockTimeout()).     return result. }
true;protected;0;5;/**  * Validates this endpoint if its configured properly.  *  * @throws Exception is thrown if endpoint is invalid configured for its mandatory options  */ ;/**  * Validates this endpoint if its configured properly.  *  * @throws Exception is thrown if endpoint is invalid configured for its mandatory options  */ protected void afterPropertiesSet() throws Exception {     RemoteFileConfiguration config = getConfiguration().     StringHelper.notEmpty(config.getHost(), "host").     StringHelper.notEmpty(config.getProtocol(), "protocol"). }
false;protected;0;6;;@Override protected Map<String, Object> getParamsAsMap() {     Map<String, Object> map = super.getParamsAsMap().     map.put("fastExistsCheck", fastExistsCheck).     return map. }
true;protected,abstract;1;1;/**  * Remote File Endpoints, impl this method to create a custom consumer specific to their "protocol" etc.  *  * @param processor  the processor  * @return the created consumer  */ ;/**  * Remote File Endpoints, impl this method to create a custom consumer specific to their "protocol" etc.  *  * @param processor  the processor  * @return the created consumer  */ protected abstract RemoteFileConsumer<T> buildConsumer(Processor processor).
true;protected,abstract;0;1;/**  * Remote File Endpoints, impl this method to create a custom producer specific to their "protocol" etc.  *  * @return the created producer  */ ;/**  * Remote File Endpoints, impl this method to create a custom producer specific to their "protocol" etc.  *  * @return the created producer  */ protected abstract GenericFileProducer<T> buildProducer().
true;public,abstract;0;1;/**  * Creates the operations to be used by the consumer or producer.  *  * @return a new created operations  * @throws Exception is thrown if error creating operations.  */ ;/**  * Creates the operations to be used by the consumer or producer.  *  * @return a new created operations  * @throws Exception is thrown if error creating operations.  */ public abstract RemoteFileOperations<T> createRemoteFileOperations() throws Exception.
true;public;0;3;/**  * Returns human readable server information for logging purpose  */ ;/**  * Returns human readable server information for logging purpose  */ public String remoteServerInformation() {     return ((RemoteFileConfiguration) configuration).remoteServerInformation(). }
false;public;0;4;;@Override public char getFileSeparator() {     return '/'. }
false;public;1;4;;@Override public boolean isAbsolute(String name) {     return name.startsWith("/"). }
false;public;0;3;;public int getMaximumReconnectAttempts() {     return maximumReconnectAttempts. }
true;public;1;3;/**  * Specifies the maximum reconnect attempts Camel performs when it tries to connect to the remote FTP server. Use 0 to disable this behavior.  */ ;/**  * Specifies the maximum reconnect attempts Camel performs when it tries to connect to the remote FTP server. Use 0 to disable this behavior.  */ public void setMaximumReconnectAttempts(int maximumReconnectAttempts) {     this.maximumReconnectAttempts = maximumReconnectAttempts. }
false;public;0;3;;public long getReconnectDelay() {     return reconnectDelay. }
true;public;1;3;/**  * Delay in millis Camel will wait before performing a reconnect attempt.  */ ;/**  * Delay in millis Camel will wait before performing a reconnect attempt.  */ public void setReconnectDelay(long reconnectDelay) {     this.reconnectDelay = reconnectDelay. }
false;public;0;3;;public boolean isDisconnect() {     return disconnect. }
true;public;1;3;/**  * Whether or not to disconnect from remote FTP server right after use.  * Disconnect will only disconnect the current connection to the FTP server.  * If you have a consumer which you want to stop, then you need to stop the consumer/route instead.  */ ;/**  * Whether or not to disconnect from remote FTP server right after use.  * Disconnect will only disconnect the current connection to the FTP server.  * If you have a consumer which you want to stop, then you need to stop the consumer/route instead.  */ public void setDisconnect(boolean disconnect) {     this.disconnect = disconnect. }
false;public;0;3;;public boolean isDisconnectOnBatchComplete() {     return disconnectOnBatchComplete. }
true;public;1;3;/**  * Whether or not to disconnect from remote FTP server right after a Batch upload is complete.  * disconnectOnBatchComplete will only disconnect the current connection to the FTP server.  */ ;/**  * Whether or not to disconnect from remote FTP server right after a Batch upload is complete.  * disconnectOnBatchComplete will only disconnect the current connection to the FTP server.  */ public void setDisconnectOnBatchComplete(boolean disconnectOnBatchComplete) {     this.disconnectOnBatchComplete = disconnectOnBatchComplete. }
false;public;0;3;;public boolean isFastExistsCheck() {     return fastExistsCheck. }
true;public;1;3;/**  * If set this option to be true, camel-ftp will use the list file directly to check if the file exists.  * Since some FTP server may not support to list the file directly, if the option is false,  * camel-ftp will use the old way to list the directory and check if the file exists.  * This option also influences readLock=changed to control whether it performs a fast check to update file information or not.  * This can be used to speed up the process if the FTP server has a lot of files.  */ ;/**  * If set this option to be true, camel-ftp will use the list file directly to check if the file exists.  * Since some FTP server may not support to list the file directly, if the option is false,  * camel-ftp will use the old way to list the directory and check if the file exists.  * This option also influences readLock=changed to control whether it performs a fast check to update file information or not.  * This can be used to speed up the process if the FTP server has a lot of files.  */ public void setFastExistsCheck(boolean fastExistsCheck) {     this.fastExistsCheck = fastExistsCheck. }
false;public;0;3;;public boolean isDownload() {     return this.download. }
true;public;1;3;/**  * Whether the FTP consumer should download the file.  * If this option is set to false, then the message body will be null, but the consumer will still trigger a Camel  * Exchange that has details about the file such as file name, file size, etc. It's just that the file will not be downloaded.  */ ;/**  * Whether the FTP consumer should download the file.  * If this option is set to false, then the message body will be null, but the consumer will still trigger a Camel  * Exchange that has details about the file such as file name, file size, etc. It's just that the file will not be downloaded.  */ public void setDownload(boolean download) {     this.download = download. }
