commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getFileSeparator() {     return "/". }
false;public;1;4;;@Override public String normalizePath(String name) {     return name. }
false;public;1;17;;@Override public void process(Exchange exchange) throws Exception {     // store any existing file header which we want to keep and propagate     final String existing = exchange.getIn().getHeader(Exchange.FILE_NAME, String.class).     // create the target file name     String target = createFileName(exchange).     try {         processExchange(exchange, target).     } finally {         // remove the write file name header as we only want to use it once (by design)         exchange.getIn().removeHeader(Exchange.OVERRULE_FILE_NAME).         // and restore existing file name         exchange.getIn().setHeader(Exchange.FILE_NAME, existing).     } }
false;protected;0;3;;protected RemoteFileOperations<T> getOperations() {     return (RemoteFileOperations<T>) operations. }
false;public;0;5;;@Override @SuppressWarnings("unchecked") public RemoteFileEndpoint<T> getEndpoint() {     return (RemoteFileEndpoint<T>) super.getEndpoint(). }
true;public;2;17;/**  * The file could not be written. We need to disconnect from the remote server.  */ ;/**  * The file could not be written. We need to disconnect from the remote server.  */ public void handleFailedWrite(Exchange exchange, Exception exception) throws Exception {     loggedIn = false.     if (isStopping() || isStopped()) {         // if we are stopping then ignore any exception during a poll         log.debug("Exception occurred during stopping: {}", exception.getMessage()).     } else {         log.warn("Writing file failed with: {}", exception.getMessage()).         try {             disconnect().         } catch (Exception e) {             // ignore exception             log.debug("Ignored exception during disconnect: {}", e.getMessage()).         }         // rethrow the original exception*/         throw exception.     } }
false;public;0;7;;public void disconnect() throws GenericFileOperationFailedException {     loggedIn = false.     if (getOperations().isConnected()) {         log.debug("Disconnecting from: {}", getEndpoint()).         getOperations().disconnect().     } }
false;public;0;34;;@Override public void preWriteCheck() throws Exception {     // before writing send a noop to see if the connection is alive and works     boolean noop = false.     if (loggedIn) {         if (getEndpoint().getConfiguration().isSendNoop()) {             try {                 noop = getOperations().sendNoop().             } catch (Exception e) {                 // ignore as we will try to recover connection                 noop = false.                 // mark as not logged in, since the noop failed                 loggedIn = false.             }             log.trace("preWriteCheck send noop success: {}", noop).         } else {             // okay send noop is disabled then we would regard the op as success             noop = true.             log.trace("preWriteCheck send noop disabled").         }     }     // if not alive then reconnect     if (!noop) {         try {             connectIfNecessary().         } catch (Exception e) {             loggedIn = false.             // must be logged in to be able to upload the file             throw e.         }     } }
false;public;1;17;;@Override public void postWriteCheck(Exchange exchange) {     try {         boolean isLast = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class).         if (isLast && getEndpoint().isDisconnectOnBatchComplete()) {             log.trace("postWriteCheck disconnect on batch complete from: {}", getEndpoint()).             disconnect().         }         if (getEndpoint().isDisconnect()) {             log.trace("postWriteCheck disconnect from: {}", getEndpoint()).             disconnect().         }     } catch (GenericFileOperationFailedException e) {         // ignore just log a warning         log.warn("Exception occurred during disconnecting from: " + getEndpoint() + " " + e.getMessage()).     } }
false;protected;0;7;;@Override protected void doStart() throws Exception {     log.debug("Starting").     // do not connect when component starts, just wait until we process as we will     // connect at that time if needed     super.doStart(). }
false;protected;0;9;;@Override protected void doStop() throws Exception {     try {         disconnect().     } catch (Exception e) {         log.debug("Exception occurred during disconnecting from: " + getEndpoint() + " " + e.getMessage()).     }     super.doStop(). }
false;protected;0;11;;protected void connectIfNecessary() throws GenericFileOperationFailedException {     if (!loggedIn || !getOperations().isConnected()) {         log.debug("Not already connected/logged in. Connecting to: {}", getEndpoint()).         RemoteFileConfiguration config = getEndpoint().getConfiguration().         loggedIn = getOperations().connect(config).         if (!loggedIn) {             return.         }         log.debug("Connected and logged in to: {}", getEndpoint()).     } }
false;public;0;4;;public boolean isSingleton() {     // this producer is stateful because the remote file operations is not thread safe     return false. }
false;public;0;7;;@Override public String toString() {     if (remoteFileProducerToString == null) {         remoteFileProducerToString = "RemoteFileProducer[" + URISupport.sanitizeUri(getEndpoint().getEndpointUri()) + "]".     }     return remoteFileProducerToString. }
