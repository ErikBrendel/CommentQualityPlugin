commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public void prepareOnStartup(GenericFileOperations<ChannelSftp.LsEntry> tGenericFileOperations, GenericFileEndpoint<ChannelSftp.LsEntry> tGenericFileEndpoint) throws Exception { // noop }
false;public;3;87;;public boolean acquireExclusiveReadLock(GenericFileOperations<ChannelSftp.LsEntry> operations, GenericFile<ChannelSftp.LsEntry> file, Exchange exchange) throws Exception {     boolean exclusive = false.     LOG.trace("Waiting for exclusive read lock to file: {}", file).     long lastModified = Long.MIN_VALUE.     long length = Long.MIN_VALUE.     StopWatch watch = new StopWatch().     long startTime = new Date().getTime().     while (!exclusive) {         // timeout check         if (timeout > 0) {             long delta = watch.taken().             if (delta > timeout) {                 CamelLogger.log(LOG, readLockLoggingLevel, "Cannot acquire read lock within " + timeout + " millis. Will skip the file: " + file).                 // we could not get the lock within the timeout period, so return false                 return false.             }         }         long newLastModified = 0.         long newLength = 0.         // operations.listFiles returns List<SftpRemoteFile> so do not use generic in the List files         List files.         if (fastExistsCheck) {             // use the absolute file path to only pickup the file we want to check, this avoids expensive             // list operations if we have a lot of files in the directory             String path = file.getAbsoluteFilePath().             if (path.equals("/") || path.equals("\\")) {                 // special for root (= home) directory                 LOG.trace("Using fast exists to update file information in home directory").                 files = operations.listFiles().             } else {                 LOG.trace("Using fast exists to update file information for {}", path).                 files = operations.listFiles(path).             }         } else {             String path = file.getParent().             if (path.equals("/") || path.equals("\\")) {                 // special for root (= home) directory                 LOG.trace("Using full directory listing in home directory to update file information. Consider enabling fastExistsCheck option.").                 files = operations.listFiles().             } else {                 LOG.trace("Using full directory listing to update file information for {}. Consider enabling fastExistsCheck option.", path).                 files = operations.listFiles(path).             }         }         LOG.trace("List files {} found {} files", file.getAbsoluteFilePath(), files.size()).         for (Object f : files) {             SftpRemoteFile rf = (SftpRemoteFile) f.             boolean match.             if (fastExistsCheck) {                 // uses the absolute file path as well                 match = rf.getFilename().equals(file.getAbsoluteFilePath()) || rf.getFilename().equals(file.getFileNameOnly()).             } else {                 match = rf.getFilename().equals(file.getFileNameOnly()).             }             if (match) {                 newLastModified = rf.getLastModified().                 newLength = rf.getFileLength().             }         }         LOG.trace("Previous last modified: " + lastModified + ", new last modified: " + newLastModified).         LOG.trace("Previous length: " + length + ", new length: " + newLength).         long newOlderThan = startTime + watch.taken() - minAge.         LOG.trace("New older than threshold: {}", newOlderThan).         if (newLength >= minLength && ((minAge == 0 && newLastModified == lastModified && newLength == length) || (minAge != 0 && newLastModified < newOlderThan))) {             LOG.trace("Read lock acquired.").             exclusive = true.         } else {             // set new base file change information             lastModified = newLastModified.             length = newLength.             boolean interrupted = sleep().             if (interrupted) {                 // we were interrupted while sleeping, we are likely being shutdown so return false                 return false.             }         }     }     return exclusive. }
false;private;0;10;;private boolean sleep() {     LOG.trace("Exclusive read lock not granted. Sleeping for {} millis.", checkInterval).     try {         Thread.sleep(checkInterval).         return false.     } catch (InterruptedException e) {         LOG.debug("Sleep interrupted while waiting for exclusive read lock, so breaking out").         return true.     } }
false;public;3;4;;@Override public void releaseExclusiveReadLockOnAbort(GenericFileOperations<ChannelSftp.LsEntry> operations, GenericFile<ChannelSftp.LsEntry> file, Exchange exchange) throws Exception { // noop }
false;public;3;4;;@Override public void releaseExclusiveReadLockOnRollback(GenericFileOperations<ChannelSftp.LsEntry> operations, GenericFile<ChannelSftp.LsEntry> file, Exchange exchange) throws Exception { // noop }
false;public;3;4;;@Override public void releaseExclusiveReadLockOnCommit(GenericFileOperations<ChannelSftp.LsEntry> operations, GenericFile<ChannelSftp.LsEntry> file, Exchange exchange) throws Exception { // noop }
false;public;0;3;;public long getTimeout() {     return timeout. }
false;public;1;4;;@Override public void setTimeout(long timeout) {     this.timeout = timeout. }
false;public;0;3;;public long getCheckInterval() {     return checkInterval. }
false;public;1;4;;@Override public void setCheckInterval(long checkInterval) {     this.checkInterval = checkInterval. }
false;public;1;4;;@Override public void setReadLockLoggingLevel(LoggingLevel readLockLoggingLevel) {     this.readLockLoggingLevel = readLockLoggingLevel. }
false;public;0;3;;public long getMinLength() {     return minLength. }
false;public;1;3;;public void setMinLength(long minLength) {     this.minLength = minLength. }
false;public;0;3;;public long getMinAge() {     return minAge. }
false;public;1;3;;public void setMinAge(long minAge) {     this.minAge = minAge. }
false;public;0;3;;public boolean isFastExistsCheck() {     return fastExistsCheck. }
false;public;1;3;;public void setFastExistsCheck(boolean fastExistsCheck) {     this.fastExistsCheck = fastExistsCheck. }
false;public;1;4;;@Override public void setMarkerFiler(boolean markerFiler) { // noop - not supported by ftp }
false;public;1;4;;@Override public void setDeleteOrphanLockFiles(boolean deleteOrphanLockFiles) { // noop - not supported by ftp }
