commented;modifiers;parameterAmount;loc;comment;code
false;private;0;4;;private String getFtpUrl() {     return "ftp://dummy@localhost:" + getPort() + "/badlogin?password=cantremeber&maximumReconnectAttempts=3" + "&throwExceptionOnConnectFailed=false&ftpClient.socketFactory=#sf". }
false;public;0;5;;@Override public boolean sendNoOp() throws IOException {     // return true as long as connection is established     return this.isConnected(). }
false;public;0;14;;@Override @Before public void setUp() throws Exception {     super.setUp().     FtpEndpoint<?> endpoint = context.getEndpoint(getFtpUrl(), FtpEndpoint.class).     endpoint.setFtpClient(new FTPClient() {          @Override         public boolean sendNoOp() throws IOException {             // return true as long as connection is established             return this.isConnected().         }     }). }
false;protected;0;8;;@Override protected JndiRegistry createRegistry() throws Exception {     JndiRegistry jndi = super.createRegistry().     SocketFactory sf = new AuditingSocketFactory().     jndi.bind("sf", sf).     return jndi. }
false;public;0;17;;@Test public void testConnectionLeak() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMessageCount(0).     // let's have several login attempts     Thread.sleep(3000L).     stopCamelContext().     for (Map.Entry<Integer, boolean[]> socketStats : socketAudits.entrySet()) {         assertTrue("Socket should be connected", socketStats.getValue()[0]).         assertEquals("Socket should be closed", socketStats.getValue()[0], socketStats.getValue()[1]).     }     mock.assertIsSatisfied(). }
false;public;0;3;;public void configure() throws Exception {     from(getFtpUrl()).to("mock:result"). }
false;protected;0;8;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          public void configure() throws Exception {             from(getFtpUrl()).to("mock:result").         }     }. }
false;public;2;4;;@Override public Socket createSocket(String s, int i) throws IOException {     return null. }
false;public;4;4;;@Override public Socket createSocket(String s, int i, InetAddress inetAddress, int i1) throws IOException {     return null. }
false;public;2;4;;@Override public Socket createSocket(InetAddress inetAddress, int i) throws IOException {     return null. }
false;public;0;6;;@Override public Socket createSocket() throws IOException {     AuditingSocket socket = new AuditingSocket().     socketAudits.put(System.identityHashCode(socket), new boolean[] { false, false }).     return socket. }
false;public;4;4;;@Override public Socket createSocket(InetAddress inetAddress, int i, InetAddress inetAddress1, int i1) throws IOException {     return null. }
false;public;2;7;;@Override public void connect(SocketAddress endpoint, int timeout) throws IOException {     log.info("Connecting socket {}", System.identityHashCode(this)).     super.connect(endpoint, timeout).     boolean[] value = socketAudits.get(System.identityHashCode(this)).     value[0] = true. }
false;public,synchronized;0;7;;@Override public synchronized void close() throws IOException {     log.info("Disconnecting socket {}", System.identityHashCode(this)).     super.close().     boolean[] value = socketAudits.get(System.identityHashCode(this)).     value[1] = true. }
