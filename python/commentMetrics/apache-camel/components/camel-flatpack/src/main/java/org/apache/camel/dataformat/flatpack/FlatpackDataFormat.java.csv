commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getDataFormatName() {     return "flatback". }
false;public;3;32;;@SuppressWarnings("unchecked") public void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception {     ObjectHelper.notNull(graph, "The object to marshal must be provided").     List<Map<String, Object>> data = (List<Map<String, Object>>) graph.     if (data.isEmpty()) {         LOG.warn("No data to marshal as the list is empty").         return.     }     Map<String, Object> firstRow = data.get(0).     Writer writer = createWriter(exchange, firstRow, stream).     try {         boolean first = true.         writer.printHeader().         for (Map<String, Object> row : data) {             if (ignoreFirstRecord && first) {                 // skip first row                 first = false.                 continue.             }             for (Entry<String, Object> entry : row.entrySet()) {                 writer.addRecordEntry(entry.getKey(), entry.getValue()).             }             writer.nextRecord().         }         writer.printFooter().     } finally {         writer.flush().         writer.close().     } }
false;public;2;10;;public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {     InputStreamReader reader = new InputStreamReader(stream, ExchangeHelper.getCharsetName(exchange)).     try {         Parser parser = createParser(exchange, reader).         DataSet dataSet = parser.parse().         return new DataSetList(dataSet).     } finally {         reader.close().     } }
false;protected;0;4;;@Override protected void doStart() throws Exception { // noop }
false;protected;0;5;;@Override protected void doStop() throws Exception { // noop }
false;public;0;3;;// Properties // ------------------------------------------------------------------------- public String getDefinition() {     return definition. }
false;public;1;3;;public void setDefinition(String definition) {     this.definition = definition. }
false;public;0;3;;public boolean isFixed() {     return fixed. }
false;public;1;3;;public void setFixed(boolean fixed) {     this.fixed = fixed. }
false;public;0;3;;public char getDelimiter() {     return delimiter. }
false;public;1;3;;public void setDelimiter(char delimiter) {     this.delimiter = delimiter. }
false;public;0;3;;public boolean isIgnoreFirstRecord() {     return ignoreFirstRecord. }
false;public;1;3;;public void setIgnoreFirstRecord(boolean ignoreFirstRecord) {     this.ignoreFirstRecord = ignoreFirstRecord. }
false;public;0;3;;public char getTextQualifier() {     return textQualifier. }
false;public;1;3;;public void setTextQualifier(char textQualifier) {     this.textQualifier = textQualifier. }
false;public;0;3;;public ParserFactory getParserFactory() {     return parserFactory. }
false;public;1;3;;public void setParserFactory(ParserFactory parserFactory) {     this.parserFactory = parserFactory. }
false;public;0;3;;public boolean isAllowShortLines() {     return this.allowShortLines. }
true;public;1;3;/**  * Allows for lines to be shorter than expected and ignores the extra characters  */ ;/**  * Allows for lines to be shorter than expected and ignores the extra characters  */ public void setAllowShortLines(boolean allowShortLines) {     this.allowShortLines = allowShortLines. }
true;public;1;3;/**  * Allows for lines to be longer than expected and ignores the extra characters  */ ;/**  * Allows for lines to be longer than expected and ignores the extra characters  */ public void setIgnoreExtraColumns(boolean ignoreExtraColumns) {     this.ignoreExtraColumns = ignoreExtraColumns. }
false;public;0;3;;public boolean isIgnoreExtraColumns() {     return ignoreExtraColumns. }
false;protected;2;33;;// Implementation methods // ------------------------------------------------------------------------- protected Parser createParser(Exchange exchange, Reader bodyReader) throws IOException {     if (isFixed()) {         InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(exchange.getContext(), getDefinition()).         InputStreamReader reader = new InputStreamReader(is, ExchangeHelper.getCharsetName(exchange)).         Parser parser = getParserFactory().newFixedLengthParser(reader, bodyReader).         if (allowShortLines) {             parser.setHandlingShortLines(true).             parser.setIgnoreParseWarnings(true).         }         if (ignoreExtraColumns) {             parser.setIgnoreExtraColumns(true).             parser.setIgnoreParseWarnings(true).         }         return parser.     } else {         if (ObjectHelper.isEmpty(getDefinition())) {             return getParserFactory().newDelimitedParser(bodyReader, delimiter, textQualifier).         } else {             InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(exchange.getContext(), getDefinition()).             InputStreamReader reader = new InputStreamReader(is, ExchangeHelper.getCharsetName(exchange)).             Parser parser = getParserFactory().newDelimitedParser(reader, bodyReader, delimiter, textQualifier, ignoreFirstRecord).             if (allowShortLines) {                 parser.setHandlingShortLines(true).                 parser.setIgnoreParseWarnings(true).             }             if (ignoreExtraColumns) {                 parser.setIgnoreExtraColumns(true).                 parser.setIgnoreParseWarnings(true).             }             return parser.         }     } }
false;private;3;22;;private Writer createWriter(Exchange exchange, Map<String, Object> firstRow, OutputStream stream) throws JDOMException, IOException {     if (isFixed()) {         InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(exchange.getContext(), getDefinition()).         InputStreamReader reader = new InputStreamReader(is, ExchangeHelper.getCharsetName(exchange)).         FixedWriterFactory factory = new FixedWriterFactory(reader).         return factory.createWriter(new OutputStreamWriter(stream, ExchangeHelper.getCharsetName(exchange))).     } else {         if (getDefinition() == null) {             DelimiterWriterFactory factory = new DelimiterWriterFactory(delimiter, textQualifier).             // add columns from the keys in the data map as the columns must be known             for (String key : firstRow.keySet()) {                 factory.addColumnTitle(key).             }             return factory.createWriter(new OutputStreamWriter(stream, ExchangeHelper.getCharsetName(exchange))).         } else {             InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(exchange.getContext(), getDefinition()).             InputStreamReader reader = new InputStreamReader(is, ExchangeHelper.getCharsetName(exchange)).             DelimiterWriterFactory factory = new DelimiterWriterFactory(reader, delimiter, textQualifier).             return factory.createWriter(new OutputStreamWriter(stream, ExchangeHelper.getCharsetName(exchange))).         }     } }
