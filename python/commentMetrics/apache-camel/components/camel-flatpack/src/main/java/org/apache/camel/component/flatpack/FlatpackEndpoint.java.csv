commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isSingleton() {     return true. }
false;public;0;3;;public Producer createProducer() throws Exception {     return new FlatpackProducer(this). }
false;public;1;3;;public Consumer createConsumer(Processor processor) throws Exception {     return new FlatpackConsumer(this, processor, loadBalancer). }
false;public;3;7;;public void processDataSet(Exchange originalExchange, DataSet dataSet, int counter) throws Exception {     Exchange exchange = ExchangeHelper.createCorrelatedCopy(originalExchange, false).     Message in = exchange.getIn().     in.setBody(dataSet).     in.setHeader("CamelFlatpackCounter", counter).     loadBalancer.process(exchange). }
false;public;1;14;;public Parser createParser(Exchange exchange) throws Exception {     Reader bodyReader = exchange.getIn().getMandatoryBody(Reader.class).     try {         if (FlatpackType.fixed == type) {             return createFixedParser(resourceUri, bodyReader).         } else {             return createDelimitedParser(exchange).         }     } catch (Exception e) {         // must close reader in case of some exception         IOHelper.close(bodyReader).         throw e.     } }
false;protected;2;14;;protected Parser createFixedParser(String resourceUri, Reader bodyReader) throws IOException {     InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext(), resourceUri).     InputStreamReader reader = new InputStreamReader(is).     Parser parser = getParserFactory().newFixedLengthParser(reader, bodyReader).     if (isAllowShortLines()) {         parser.setHandlingShortLines(true).         parser.setIgnoreParseWarnings(true).     }     if (isIgnoreExtraColumns()) {         parser.setIgnoreExtraColumns(true).         parser.setIgnoreParseWarnings(true).     }     return parser. }
false;public;1;23;;public Parser createDelimitedParser(Exchange exchange) throws InvalidPayloadException, IOException {     Reader bodyReader = exchange.getIn().getMandatoryBody(Reader.class).     Parser parser.     if (ObjectHelper.isEmpty(getResourceUri())) {         parser = getParserFactory().newDelimitedParser(bodyReader, delimiter, textQualifier).     } else {         InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext(), resourceUri).         InputStreamReader reader = new InputStreamReader(is, ExchangeHelper.getCharsetName(exchange)).         parser = getParserFactory().newDelimitedParser(reader, bodyReader, delimiter, textQualifier, ignoreFirstRecord).     }     if (isAllowShortLines()) {         parser.setHandlingShortLines(true).         parser.setIgnoreParseWarnings(true).     }     if (isIgnoreExtraColumns()) {         parser.setIgnoreExtraColumns(true).         parser.setIgnoreParseWarnings(true).     }     return parser. }
false;public;0;3;;// Properties // ------------------------------------------------------------------------- public String getResourceUri() {     return resourceUri. }
false;public;0;3;;public ParserFactory getParserFactory() {     return parserFactory. }
false;public;1;3;;public void setParserFactory(ParserFactory parserFactory) {     this.parserFactory = parserFactory. }
false;public;0;3;;public LoadBalancer getLoadBalancer() {     return loadBalancer. }
false;public;1;3;;public void setLoadBalancer(LoadBalancer loadBalancer) {     this.loadBalancer = loadBalancer. }
false;public;0;3;;public boolean isSplitRows() {     return splitRows. }
true;public;1;3;/**  * Sets the Component to send each row as a separate exchange once parsed  */ ;/**  * Sets the Component to send each row as a separate exchange once parsed  */ public void setSplitRows(boolean splitRows) {     this.splitRows = splitRows. }
false;public;0;3;;public boolean isAllowShortLines() {     return this.allowShortLines. }
true;public;1;3;/**  * Allows for lines to be shorter than expected and ignores the extra characters  */ ;/**  * Allows for lines to be shorter than expected and ignores the extra characters  */ public void setAllowShortLines(boolean allowShortLines) {     this.allowShortLines = allowShortLines. }
true;public;1;3;/**  * Allows for lines to be longer than expected and ignores the extra characters  */ ;/**  * Allows for lines to be longer than expected and ignores the extra characters  */ public void setIgnoreExtraColumns(boolean ignoreExtraColumns) {     this.ignoreExtraColumns = ignoreExtraColumns. }
false;public;0;3;;public boolean isIgnoreExtraColumns() {     return ignoreExtraColumns. }
false;public;0;3;;public FlatpackType getType() {     return type. }
true;public;1;3;/**  * Whether to use fixed or delimiter  */ ;/**  * Whether to use fixed or delimiter  */ public void setType(FlatpackType type) {     this.type = type. }
true;public;1;3;/**  * URL for loading the flatpack mapping file from classpath or file system  */ ;/**  * URL for loading the flatpack mapping file from classpath or file system  */ public void setResourceUri(String resourceUri) {     this.resourceUri = resourceUri. }
false;public;0;3;;public char getDelimiter() {     return delimiter. }
true;public;1;3;/**  * The default character delimiter for delimited files.  */ ;/**  * The default character delimiter for delimited files.  */ public void setDelimiter(char delimiter) {     this.delimiter = delimiter. }
false;public;0;3;;public char getTextQualifier() {     return textQualifier. }
true;public;1;3;/**  * The text qualifier for delimited files.  */ ;/**  * The text qualifier for delimited files.  */ public void setTextQualifier(char textQualifier) {     this.textQualifier = textQualifier. }
false;public;0;3;;public boolean isIgnoreFirstRecord() {     return ignoreFirstRecord. }
true;public;1;3;/**  * Whether the first line is ignored for delimited files (for the column headers).  */ ;/**  * Whether the first line is ignored for delimited files (for the column headers).  */ public void setIgnoreFirstRecord(boolean ignoreFirstRecord) {     this.ignoreFirstRecord = ignoreFirstRecord. }
