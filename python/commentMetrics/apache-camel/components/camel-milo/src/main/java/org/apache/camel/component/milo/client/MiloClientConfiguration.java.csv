commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * The OPC UA server endpoint  */ ;/**  * The OPC UA server endpoint  */ public void setEndpointUri(final String endpointUri) {     this.endpointUri = endpointUri. }
false;public;0;3;;public String getEndpointUri() {     return this.endpointUri. }
true;public;1;3;/**  * An alternative discovery URI  */ ;/**  * An alternative discovery URI  */ public void setDiscoveryEndpointUri(final String endpointDiscoveryUri) {     this.discoveryEndpointUri = endpointDiscoveryUri. }
false;public;0;3;;public String getDiscoveryEndpointUri() {     return this.discoveryEndpointUri. }
true;public;1;3;/**  * A suffix for endpoint URI when discovering  */ ;/**  * A suffix for endpoint URI when discovering  */ public void setDiscoveryEndpointSuffix(final String endpointDiscoverySuffix) {     this.discoveryEndpointSuffix = endpointDiscoverySuffix. }
false;public;0;3;;public String getDiscoveryEndpointSuffix() {     return this.discoveryEndpointSuffix. }
true;public;1;3;/**  * A virtual client id to force the creation of a new connection instance  */ ;/**  * A virtual client id to force the creation of a new connection instance  */ public void setClientId(final String clientId) {     this.clientId = clientId. }
false;public;0;3;;public String getClientId() {     return this.clientId. }
true;public;1;3;/**  * The application name  */ ;/**  * The application name  */ public void setApplicationName(final String applicationName) {     this.applicationName = applicationName. }
false;public;0;3;;public String getApplicationName() {     return this.applicationName. }
true;public;1;3;/**  * The application URI  */ ;/**  * The application URI  */ public void setApplicationUri(final String applicationUri) {     this.applicationUri = applicationUri. }
false;public;0;3;;public String getApplicationUri() {     return this.applicationUri. }
true;public;1;3;/**  * The product URI  */ ;/**  * The product URI  */ public void setProductUri(final String productUri) {     this.productUri = productUri. }
false;public;0;3;;public String getProductUri() {     return this.productUri. }
true;public;1;3;/**  * Request timeout in milliseconds  */ ;/**  * Request timeout in milliseconds  */ public void setRequestTimeout(final Long reconnectTimeout) {     this.requestTimeout = reconnectTimeout. }
false;public;0;3;;public Long getRequestTimeout() {     return this.requestTimeout. }
true;public;1;3;/**  * Channel lifetime in milliseconds  */ ;/**  * Channel lifetime in milliseconds  */ public void setChannelLifetime(final Long channelLifetime) {     this.channelLifetime = channelLifetime. }
false;public;0;3;;public Long getChannelLifetime() {     return this.channelLifetime. }
true;public;1;3;/**  * Session name  */ ;/**  * Session name  */ public void setSessionName(final String sessionName) {     this.sessionName = sessionName. }
false;public;0;3;;public String getSessionName() {     return this.sessionName. }
true;public;1;3;/**  * Session timeout in milliseconds  */ ;/**  * Session timeout in milliseconds  */ public void setSessionTimeout(final Long sessionTimeout) {     this.sessionTimeout = sessionTimeout. }
false;public;0;3;;public Long getSessionTimeout() {     return this.sessionTimeout. }
true;public;1;3;/**  * The maximum number of pending publish requests  */ ;/**  * The maximum number of pending publish requests  */ public void setMaxPendingPublishRequests(final Long maxPendingPublishRequests) {     this.maxPendingPublishRequests = maxPendingPublishRequests. }
false;public;0;3;;public Long getMaxPendingPublishRequests() {     return this.maxPendingPublishRequests. }
true;public;1;3;/**  * The maximum number of bytes a response message may have  */ ;/**  * The maximum number of bytes a response message may have  */ public void setMaxResponseMessageSize(final Long maxResponseMessageSize) {     this.maxResponseMessageSize = maxResponseMessageSize. }
false;public;0;3;;public Long getMaxResponseMessageSize() {     return this.maxResponseMessageSize. }
true;public;1;3;/**  * The URL where the key should be loaded from  */ ;/**  * The URL where the key should be loaded from  */ public void setKeyStoreUrl(final String keyStoreUrl) throws MalformedURLException {     this.keyStoreUrl = keyStoreUrl != null ? new URL(keyStoreUrl) : null. }
false;public;0;3;;public URL getKeyStoreUrl() {     return this.keyStoreUrl. }
true;public;1;3;/**  * The key store type  */ ;/**  * The key store type  */ public void setKeyStoreType(final String keyStoreType) {     this.keyStoreType = keyStoreType. }
false;public;0;3;;public String getKeyStoreType() {     return this.keyStoreType. }
true;public;1;3;/**  * The name of the key in the keystore file  */ ;/**  * The name of the key in the keystore file  */ public void setKeyAlias(final String keyAlias) {     this.keyAlias = keyAlias. }
false;public;0;3;;public String getKeyAlias() {     return this.keyAlias. }
true;public;1;3;/**  * The keystore password  */ ;/**  * The keystore password  */ public void setKeyStorePassword(final String keyStorePassword) {     this.keyStorePassword = keyStorePassword. }
false;public;0;3;;public String getKeyStorePassword() {     return this.keyStorePassword. }
true;public;1;3;/**  * The key password  */ ;/**  * The key password  */ public void setKeyPassword(final String keyPassword) {     this.keyPassword = keyPassword. }
false;public;0;3;;public String getKeyPassword() {     return this.keyPassword. }
true;public;1;3;/**  * A set of allowed security policy URIs. Default is to accept all and use  * the highest.  */ ;/**  * A set of allowed security policy URIs. Default is to accept all and use  * the highest.  */ public void setAllowedSecurityPolicies(final Set<String> allowedSecurityPolicies) {     this.allowedSecurityPolicies = allowedSecurityPolicies. }
false;public;1;36;;public void setAllowedSecurityPolicies(final String allowedSecurityPolicies) {     if (allowedSecurityPolicies == null) {         // resetting to null         this.allowedSecurityPolicies = null.         return.     }     // split and convert     this.allowedSecurityPolicies = new HashSet<>().     final String[] policies = allowedSecurityPolicies.split(",").     for (final String policy : policies) {         String adding = null.         try {             adding = SecurityPolicy.fromUri(policy).getSecurityPolicyUri().         } catch (Exception e) {         }         if (adding == null) {             try {                 adding = SecurityPolicy.valueOf(policy).getSecurityPolicyUri().             } catch (Exception e) {             }         }         if (adding == null) {             throw new RuntimeException("Unknown security policy: " + policy).         }         this.allowedSecurityPolicies.add(adding).     } }
false;public;0;3;;public Set<String> getAllowedSecurityPolicies() {     return this.allowedSecurityPolicies. }
true;public;1;3;/**  * Override the server reported endpoint host with the host from the  * endpoint URI.  */ ;/**  * Override the server reported endpoint host with the host from the  * endpoint URI.  */ public void setOverrideHost(boolean overrideHost) {     this.overrideHost = overrideHost. }
false;public;0;3;;public boolean isOverrideHost() {     return overrideHost. }
false;public;0;4;;@Override public MiloClientConfiguration clone() {     return new MiloClientConfiguration(this). }
false;public;0;7;;public String toCacheId() {     if (this.clientId != null && !this.clientId.isEmpty()) {         return this.endpointUri + "|" + this.clientId.     } else {         return this.endpointUri.     } }
false;public;0;3;;public OpcUaClientConfigBuilder newBuilder() {     return mapToClientConfiguration(this). }
false;private,static;1;33;;private static OpcUaClientConfigBuilder mapToClientConfiguration(final MiloClientConfiguration configuration) {     final OpcUaClientConfigBuilder builder = new OpcUaClientConfigBuilder().     whenHasText(configuration::getApplicationName, value -> builder.setApplicationName(LocalizedText.english(value))).     whenHasText(configuration::getApplicationUri, builder::setApplicationUri).     whenHasText(configuration::getProductUri, builder::setProductUri).     if (configuration.getRequestTimeout() != null) {         builder.setRequestTimeout(Unsigned.uint(configuration.getRequestTimeout())).     }     if (configuration.getChannelLifetime() != null) {         builder.setChannelLifetime(Unsigned.uint(configuration.getChannelLifetime())).     }     whenHasText(configuration::getSessionName, value -> builder.setSessionName(() -> value)).     if (configuration.getSessionTimeout() != null) {         builder.setSessionTimeout(UInteger.valueOf(configuration.getSessionTimeout())).     }     if (configuration.getMaxPendingPublishRequests() != null) {         builder.setMaxPendingPublishRequests(UInteger.valueOf(configuration.getMaxPendingPublishRequests())).     }     if (configuration.getMaxResponseMessageSize() != null) {         builder.setMaxResponseMessageSize(UInteger.valueOf(configuration.getMaxPendingPublishRequests())).     }     if (configuration.getKeyStoreUrl() != null) {         setKey(configuration, builder).     }     return builder. }
false;private,static;2;26;;private static void setKey(final MiloClientConfiguration configuration, final OpcUaClientConfigBuilder builder) {     final KeyStoreLoader loader = new KeyStoreLoader().     final Result result.     try {         // key store properties         loader.setType(configuration.getKeyStoreType()).         loader.setUrl(configuration.getKeyStoreUrl()).         loader.setKeyStorePassword(configuration.getKeyStorePassword()).         // key properties         loader.setKeyAlias(configuration.getKeyAlias()).         loader.setKeyPassword(configuration.getKeyPassword()).         result = loader.load().     } catch (GeneralSecurityException | IOException e) {         throw new IllegalStateException("Failed to load key", e).     }     if (result == null) {         throw new IllegalStateException("Key not found in keystore").     }     builder.setCertificate(result.getCertificate()).     builder.setKeyPair(result.getKeyPair()). }
false;private,static;2;6;;private static void whenHasText(final Supplier<String> valueSupplier, final Consumer<String> valueConsumer) {     final String value = valueSupplier.get().     if (value != null && !value.isEmpty()) {         valueConsumer.accept(value).     } }
