commented;modifiers;parameterAmount;loc;comment;code
false;public;2;7;;@Override public void onSubscriptionTransferFailed(final UaSubscription subscription, final StatusCode statusCode) {     LOG.info("Transfer failed {} : {}", subscription.getSubscriptionId(), statusCode).     // we simply tear it down and build it up again     handleConnectionFailue(new RuntimeException("Subscription failed to reconnect")). }
false;public;2;4;;@Override public void onStatusChanged(final UaSubscription subscription, final StatusCode status) {     LOG.info("Subscription status changed {} : {}", subscription.getSubscriptionId(), status). }
false;public;1;3;;@Override public void onPublishFailure(final UaException exception) { }
false;public;1;3;;@Override public void onNotificationDataLost(final UaSubscription subscription) { }
false;public;2;3;;@Override public void onKeepAlive(final UaSubscription subscription, final DateTime publishTime) { }
false;;1;1;;void work(T on) throws Exception.
false;public;0;3;;public ExpandedNodeId getNodeId() {     return nodeId. }
false;public;0;3;;public Double getSamplingInterval() {     return this.samplingInterval. }
false;public;0;3;;public Consumer<DataValue> getValueConsumer() {     return this.valueConsumer. }
false;public;1;53;;public void putSubscriptions(final Map<UInteger, Subscription> subscriptions) throws Exception {     if (subscriptions.isEmpty()) {         return.     }     // convert to requests     final List<MonitoredItemCreateRequest> items = new ArrayList<>(subscriptions.size()).     for (final Map.Entry<UInteger, Subscription> entry : subscriptions.entrySet()) {         final Subscription s = entry.getValue().         final NodeId node = lookupNamespace(s.getNodeId()).get().         if (node == null) {             handleSubscriptionError(new StatusCode(StatusCodes.Bad_InvalidArgument), entry.getKey(), s).         } else {             final ReadValueId itemId = new ReadValueId(node, AttributeId.Value.uid(), null, QualifiedName.NULL_VALUE).             Double samplingInterval = s.getSamplingInterval().             if (samplingInterval == null) {                 // work around a bug (NPE) in Eclipse Milo 0.1.3                 samplingInterval = 0.0.             }             final MonitoringParameters parameters = new MonitoringParameters(entry.getKey(), samplingInterval, null, null, null).             items.add(new MonitoredItemCreateRequest(itemId, MonitoringMode.Reporting, parameters)).         }     }     if (!items.isEmpty()) {         // create monitors         this.manager.createMonitoredItems(TimestampsToReturn.Both, items, (item, idx) -> {             // set value listener             final Subscription s = subscriptions.get(item.getClientHandle()).             if (item.getStatusCode().isBad()) {                 handleSubscriptionError(item.getStatusCode(), item.getClientHandle(), s).             } else {                 this.goodSubscriptions.put(item.getClientHandle(), item).                 item.setValueConsumer(s.getValueConsumer()).             }         }).get().     }     if (!this.badSubscriptions.isEmpty()) {         SubscriptionManager.this.executor.schedule(this::resubscribe, SubscriptionManager.this.reconnectTimeout, TimeUnit.MILLISECONDS).     } }
false;private;3;4;;private void handleSubscriptionError(final StatusCode statusCode, final UInteger clientHandle, final Subscription s) {     this.badSubscriptions.put(clientHandle, s).     s.getValueConsumer().accept(new DataValue(statusCode)). }
false;private;0;9;;private void resubscribe() {     final Map<UInteger, Subscription> subscriptions = new HashMap<>(this.badSubscriptions).     this.badSubscriptions.clear().     try {         putSubscriptions(subscriptions).     } catch (final Exception e) {         handleConnectionFailue(e).     } }
false;public;2;3;;public void activate(final UInteger clientHandle, final Subscription subscription) throws Exception {     putSubscriptions(Collections.singletonMap(clientHandle, subscription)). }
false;public;1;8;;public void deactivate(final UInteger clientHandle) throws Exception {     final UaMonitoredItem item = this.goodSubscriptions.remove(clientHandle).     if (item != null) {         this.manager.deleteMonitoredItems(Collections.singletonList(item)).get().     } else {         this.badSubscriptions.remove(clientHandle).     } }
false;private;1;39;;private CompletableFuture<UShort> lookupNamespaceIndex(final String namespaceUri) {     LOG.trace("Looking up namespace: {}", namespaceUri).     // check cache     {         final UShort result = this.namespaceCache.get(namespaceUri).         if (result != null) {             LOG.trace("Found namespace in cache: {} -> {}", namespaceUri, result).             return CompletableFuture.completedFuture(result).         }     }     /*              * We always read the server side table since the cache did not help              * us and the namespace might have been added to the server at a              * later time.              */     LOG.debug("Looking up namespace on server: {}", namespaceUri).     final CompletableFuture<DataValue> future = this.client.readValue(0, TimestampsToReturn.Neither, Identifiers.Server_NamespaceArray).     return future.thenApply(value -> {         final Object rawValue = value.getValue().getValue().         if (rawValue instanceof String[]) {             final String[] namespaces = (String[]) rawValue.             for (int i = 0. i < namespaces.length. i++) {                 if (namespaces[i].equals(namespaceUri)) {                     final UShort result = Unsigned.ushort(i).                     this.namespaceCache.putIfAbsent(namespaceUri, result).                     return result.                 }             }         }         return null.     }). }
false;public;0;6;;public void dispose() {     if (this.client != null) {         this.client.disconnect().         this.client = null.     } }
false;private;1;15;;private CompletableFuture<NodeId> lookupNamespace(final ExpandedNodeId nodeId) {     LOG.trace("Expanded Node Id: {}", nodeId).     final String uri = nodeId.getNamespaceUri().     if (uri != null) {         LOG.trace("Looking up namespace: {}", uri).         return lookupNamespaceIndex(uri).thenApply(index -> toNodeId(index, nodeId)).     } else {         final UShort index = nodeId.getNamespaceIndex().         LOG.trace("Using provided index: {}", index).         return completedFuture(toNodeId(index, nodeId)).     } }
false;public;2;16;;public CompletableFuture<StatusCode> write(final ExpandedNodeId nodeId, final DataValue value) {     return lookupNamespace(nodeId).thenCompose(node -> {         LOG.debug("Node - expanded: {}, full: {}", nodeId, node).         return this.client.writeValue(node, value).whenComplete((status, error) -> {             if (status != null) {                 LOG.debug("Write to node={} = {} -> {}", node, value, status).             } else {                 LOG.debug("Failed to write", error).             }         }).     }). }
false;public;3;24;;public CompletableFuture<CallMethodResult> call(final ExpandedNodeId nodeId, final ExpandedNodeId methodId, final Variant[] inputArguments) {     return lookupNamespace(nodeId).thenCompose(node -> {         LOG.debug("Node   - expanded: {}, full: {}", nodeId, node).         return lookupNamespace(methodId).thenCompose(method -> {             LOG.debug("Method - expanded: {}, full: {}", methodId, method).             final CallMethodRequest cmr = new CallMethodRequest(node, method, inputArguments).             return this.client.call(cmr).whenComplete((status, error) -> {                 if (status != null) {                     LOG.debug("Call to node={}, method={} = {}-> {}", nodeId, methodId, inputArguments, status).                 } else {                     LOG.debug("Failed to call", error).                 }             }).         }).     }). }
false;private,synchronized;1;14;;private synchronized void handleConnectionFailue(final Throwable e) {     if (this.connected != null) {         this.connected.dispose().         this.connected = null.     }     // log     LOG.info("Connection failed", e).     // always trigger re-connect     triggerReconnect(true). }
false;private;0;14;;private void connect() {     LOG.info("Starting connect").     synchronized (this) {         this.reconnectJob = null.         if (this.disposed) {             // we woke up disposed             return.         }     }     performAndEvalConnect(). }
false;private;0;34;;private void performAndEvalConnect() {     try {         final Connected connected = performConnect().         LOG.debug("Connect call done").         synchronized (this) {             if (this.disposed) {                 // we got disposed during connect                 return.             }             try {                 LOG.debug("Setting subscriptions: {}", this.subscriptions.size()).                 connected.putSubscriptions(this.subscriptions).                 LOG.debug("Update state : {} -> {}", this.connected, connected).                 final Connected oldConnected = this.connected.                 this.connected = connected.                 if (oldConnected != null) {                     LOG.debug("Dispose old state").                     oldConnected.dispose().                 }             } catch (final Exception e) {                 LOG.info("Failed to set subscriptions", e).                 connected.dispose().                 throw e.             }         }     } catch (final Exception e) {         LOG.info("Failed to connect", e).         triggerReconnect(false).     } }
false;private;0;63;;private Connected performConnect() throws Exception {     // eval enpoint     final String discoveryUri = getEndpointDiscoveryUri().     LOG.debug("Discovering endpoints from: {}", discoveryUri).     final EndpointDescription endpoint = UaTcpStackClient.getEndpoints(discoveryUri).thenApply(endpoints -> {         if (LOG.isDebugEnabled()) {             LOG.debug("Found enpoints:").             for (final EndpointDescription ep : endpoints) {                 LOG.debug("\t{}", ep).             }         }         try {             return findEndpoint(endpoints).         } catch (final URISyntaxException e) {             throw new RuntimeException("Failed to find endpoints", e).         }     }).get().     LOG.debug("Selected endpoint: {}", endpoint).     final URI uri = URI.create(getEndpointDiscoveryUri()).     // set identity providers     final List<IdentityProvider> providers = new LinkedList<>().     final String user = uri.getUserInfo().     if (user != null && !user.isEmpty()) {         final String[] creds = user.split(":", 2).         if (creds != null && creds.length == 2) {             LOG.debug("Enable username/password provider: {}", creds[0]).         }         providers.add(new UsernameProvider(creds[0], creds[1])).     }     providers.add(AnonymousProvider.INSTANCE).     final OpcUaClientConfigBuilder cfg = this.configuration.newBuilder().     cfg.setIdentityProvider(new CompositeProvider(providers)).     cfg.setEndpoint(endpoint).     // create client     final OpcUaClient client = new OpcUaClient(cfg.build()).     client.connect().get().     try {         final UaSubscription manager = client.getSubscriptionManager().createSubscription(1_000.0).get().         client.getSubscriptionManager().addSubscriptionListener(new SubscriptionListenerImpl()).         return new Connected(client, manager).     } catch (final Throwable e) {         if (client != null) {             // clean up             client.disconnect().         }         throw e.     } }
false;private;0;12;;private String getEndpointDiscoveryUri() {     if (!Strings.isNullOrEmpty(this.configuration.getDiscoveryEndpointUri())) {         return this.configuration.getDiscoveryEndpointUri().     }     if (!Strings.isNullOrEmpty(this.configuration.getDiscoveryEndpointSuffix())) {         return this.configuration.getEndpointUri() + this.configuration.getDiscoveryEndpointSuffix().     }     return this.configuration.getEndpointUri(). }
false;public;0;16;;public void dispose() {     Connected connected.     synchronized (this) {         if (this.disposed) {             return.         }         this.disposed = true.         connected = this.connected.     }     if (connected != null) {         // dispose outside of lock         connected.dispose().     } }
false;private,synchronized;1;14;;private synchronized void triggerReconnect(final boolean immediate) {     LOG.info("Trigger re-connect (immediate: {})", immediate).     if (this.reconnectJob != null) {         LOG.info("Re-connect already scheduled").         return.     }     if (immediate) {         this.reconnectJob = this.executor.submit(this::connect).     } else {         this.reconnectJob = this.executor.schedule(this::connect, this.reconnectTimeout, TimeUnit.MILLISECONDS).     } }
false;private;1;27;;private EndpointDescription findEndpoint(final EndpointDescription[] endpoints) throws URISyntaxException {     final Predicate<String> allowed.     final Set<String> uris = this.configuration.getAllowedSecurityPolicies().     if (this.configuration.getAllowedSecurityPolicies() == null || this.configuration.getAllowedSecurityPolicies().isEmpty()) {         allowed = uri -> true.     } else {         allowed = uris::contains.     }     EndpointDescription best = null.     for (final EndpointDescription ep : endpoints) {         if (!allowed.test(ep.getSecurityPolicyUri())) {             continue.         }         if (best == null || ep.getSecurityLevel().compareTo(best.getSecurityLevel()) > 0) {             best = ep.         }     }     return overrideHost(best). }
true;private;1;12;/**  * Optionally override the host of the endpoint URL with the configured one.  * <br>  * The method will call {@link #overrideHost(String)} if the endpoint is not  * {@code null} and {@link MiloClientConfiguration#isOverrideHost()} returns  * {@code true}.  *  * @param desc The endpoint descriptor to work on  * @return Either the provided or updated endpoint descriptor. Only returns  *         {@code null} when the input was {@code null}.  * @throws URISyntaxException on case the URI is malformed  */ ;/**  * Optionally override the host of the endpoint URL with the configured one.  * <br>  * The method will call {@link #overrideHost(String)} if the endpoint is not  * {@code null} and {@link MiloClientConfiguration#isOverrideHost()} returns  * {@code true}.  *  * @param desc The endpoint descriptor to work on  * @return Either the provided or updated endpoint descriptor. Only returns  *         {@code null} when the input was {@code null}.  * @throws URISyntaxException on case the URI is malformed  */ private EndpointDescription overrideHost(final EndpointDescription desc) throws URISyntaxException {     if (desc == null) {         return null.     }     if (!this.configuration.isOverrideHost()) {         return desc.     }     return new EndpointDescription(overrideHost(desc.getEndpointUrl()), desc.getServer(), desc.getServerCertificate(), desc.getSecurityMode(), desc.getSecurityPolicyUri(), desc.getUserIdentityTokens(), desc.getTransportProfileUri(), desc.getSecurityLevel()). }
true;private;1;11;/**  * Override host part of the endpoint URL with the configured one.  *  * @param endpointUrl the server provided endpoint URL  * @return A new endpoint URL with the host part exchanged by the configured  *         host. Will be {@code null} when the input is {@code null}.  * @throws URISyntaxException on case the URI is malformed  */ ;/**  * Override host part of the endpoint URL with the configured one.  *  * @param endpointUrl the server provided endpoint URL  * @return A new endpoint URL with the host part exchanged by the configured  *         host. Will be {@code null} when the input is {@code null}.  * @throws URISyntaxException on case the URI is malformed  */ private String overrideHost(final String endpointUrl) throws URISyntaxException {     if (endpointUrl == null) {         return null.     }     final URI uri = URI.create(endpointUrl).     final URI originalUri = URI.create(configuration.getEndpointUri()).     return new URI(uri.getScheme(), uri.getUserInfo(), originalUri.getHost(), uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment()).toString(). }
false;protected,synchronized;1;9;;protected synchronized void whenConnected(final Worker<Connected> worker) {     if (this.connected != null) {         try {             worker.work(this.connected).         } catch (final Exception e) {             handleConnectionFailue(e).         }     } }
false;private,static;0;5;;private static <T> CompletableFuture<T> newNotConnectedResult() {     final CompletableFuture<T> result = new CompletableFuture<>().     result.completeExceptionally(new IllegalStateException("No connected")).     return result. }
false;public;3;15;;public UInteger registerItem(final ExpandedNodeId nodeId, final Double samplingInterval, final Consumer<DataValue> valueConsumer) {     final UInteger clientHandle = Unsigned.uint(this.clientHandleCounter.incrementAndGet()).     final Subscription subscription = new Subscription(nodeId, samplingInterval, valueConsumer).     synchronized (this) {         this.subscriptions.put(clientHandle, subscription).         whenConnected(connected -> {             connected.activate(clientHandle, subscription).         }).     }     return clientHandle. }
false;public,synchronized;1;7;;public synchronized void unregisterItem(final UInteger clientHandle) {     if (this.subscriptions.remove(clientHandle) != null) {         whenConnected(connected -> {             connected.deactivate(clientHandle).         }).     } }
false;public;3;16;;public CompletableFuture<CallMethodResult> call(final ExpandedNodeId nodeId, final ExpandedNodeId methodId, final Variant[] inputArguments) {     synchronized (this) {         if (this.connected == null) {             return newNotConnectedResult().         }         return this.connected.call(nodeId, methodId, inputArguments).handleAsync((status, e) -> {             // handleAsync             if (e != null) {                 handleConnectionFailue(e).             }             return null.         }, this.executor).     } }
false;public;2;16;;public CompletableFuture<?> write(final ExpandedNodeId nodeId, final DataValue value) {     synchronized (this) {         if (this.connected == null) {             return newNotConnectedResult().         }         return this.connected.write(nodeId, value).handleAsync((status, e) -> {             // handleAsync             if (e != null) {                 handleConnectionFailue(e).             }             return null.         }, this.executor).     } }
