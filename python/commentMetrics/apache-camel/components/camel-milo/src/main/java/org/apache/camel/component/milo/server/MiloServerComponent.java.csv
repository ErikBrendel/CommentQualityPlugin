commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void validate(final X509Certificate certificate) throws UaException {     throw new UaException(StatusCodes.Bad_CertificateUseNotAllowed). }
false;public;1;4;;@Override public void verifyTrustChain(List<X509Certificate> certificateChain) throws UaException {     throw new UaException(StatusCodes.Bad_CertificateUseNotAllowed). }
false;protected;0;9;;@Override protected void doStart() throws Exception {     this.server = new OpcUaServer(buildServerConfig()).     this.namespace = this.server.getNamespaceManager().registerAndAdd(this.namespaceUri, index -> new CamelNamespace(index, this.namespaceUri, this.server)).     super.doStart().     this.server.startup(). }
true;private;0;52;/**  * Build the final server configuration, apply all complex configuration  *  * @return the new server configuration, never returns {@code null}  */ ;/**  * Build the final server configuration, apply all complex configuration  *  * @return the new server configuration, never returns {@code null}  */ private OpcUaServerConfig buildServerConfig() {     if (this.userMap != null || this.enableAnonymousAuthentication != null) {         // set identity validator         final Map<String, String> userMap = this.userMap != null ? new HashMap<>(this.userMap) : Collections.emptyMap().         final boolean allowAnonymous = Boolean.TRUE.equals(this.enableAnonymousAuthentication).         final IdentityValidator identityValidator = new UsernameIdentityValidator(allowAnonymous, challenge -> {             final String pwd = userMap.get(challenge.getUsername()).             if (pwd == null) {                 return false.             }             return pwd.equals(challenge.getPassword()).         }).         this.serverConfig.setIdentityValidator(identityValidator).         // add token policies         final List<UserTokenPolicy> tokenPolicies = new LinkedList<>().         if (allowAnonymous) {             tokenPolicies.add(OpcUaServerConfig.USER_TOKEN_POLICY_ANONYMOUS).         }         if (userMap != null) {             tokenPolicies.add(getUsernamePolicy()).         }         this.serverConfig.setUserTokenPolicies(tokenPolicies).     }     if (this.bindAddresses != null) {         this.serverConfig.setBindAddresses(new ArrayList<>(this.bindAddresses)).     }     if (this.certificateValidator != null) {         final CertificateValidator validator = this.certificateValidator.get().         log.debug("Using validator: {}", validator).         if (validator instanceof Closeable) {             runOnStop(() -> {                 try {                     log.debug("Closing: {}", validator).                     ((Closeable) validator).close().                 } catch (final IOException e) {                     log.warn("Failed to close", e).                 }             }).         }         this.serverConfig.setCertificateValidator(validator).     }     return this.serverConfig.build(). }
true;private;0;6;/**  * Get the user token policy for using with username authentication  *  * @return the user token policy to use for username authentication  */ ;/**  * Get the user token policy for using with username authentication  *  * @return the user token policy to use for username authentication  */ private UserTokenPolicy getUsernamePolicy() {     if (this.usernameSecurityPolicyUri == null || this.usernameSecurityPolicyUri.isEmpty()) {         return OpcUaServerConfig.USER_TOKEN_POLICY_USERNAME.     }     return new UserTokenPolicy("username", UserTokenType.UserName, null, null, this.usernameSecurityPolicyUri). }
false;private;1;3;;private void runOnStop(final Runnable runnable) {     this.runOnStop.add(runnable). }
false;protected;0;14;;@Override protected void doStop() throws Exception {     this.server.shutdown().     super.doStop().     this.runOnStop.forEach(runnable -> {         try {             runnable.run().         } catch (final Exception e) {             log.warn("Failed to run on stop", e).         }     }).     this.runOnStop.clear(). }
false;protected;3;18;;@Override protected Endpoint createEndpoint(final String uri, final String remaining, final Map<String, Object> parameters) throws Exception {     synchronized (this) {         if (remaining == null || remaining.isEmpty()) {             return null.         }         MiloServerEndpoint endpoint = this.endpoints.get(remaining).         if (endpoint == null) {             endpoint = new MiloServerEndpoint(uri, remaining, this.namespace, this).             setProperties(endpoint, parameters).             this.endpoints.put(remaining, endpoint).         }         return endpoint.     } }
true;public;1;3;/**  * The URI of the namespace, defaults to <code>urn:org:apache:camel</code>  */ ;/**  * The URI of the namespace, defaults to <code>urn:org:apache:camel</code>  */ public void setNamespaceUri(final String namespaceUri) {     this.namespaceUri = namespaceUri. }
true;public;1;4;/**  * The application name  */ ;/**  * The application name  */ public void setApplicationName(final String applicationName) {     Objects.requireNonNull(applicationName).     this.serverConfig.setApplicationName(LocalizedText.english(applicationName)). }
true;public;1;4;/**  * The application URI  */ ;/**  * The application URI  */ public void setApplicationUri(final String applicationUri) {     Objects.requireNonNull(applicationUri).     this.serverConfig.setApplicationUri(applicationUri). }
true;public;1;4;/**  * The product URI  */ ;/**  * The product URI  */ public void setProductUri(final String productUri) {     Objects.requireNonNull(productUri).     this.serverConfig.setProductUri(productUri). }
true;public;1;3;/**  * The TCP port the server binds to  */ ;/**  * The TCP port the server binds to  */ public void setBindPort(final int port) {     this.serverConfig.setBindPort(port). }
true;public;1;3;/**  * Set whether strict endpoint URLs are enforced  */ ;/**  * Set whether strict endpoint URLs are enforced  */ public void setStrictEndpointUrlsEnabled(final boolean strictEndpointUrlsEnforced) {     this.serverConfig.setStrictEndpointUrlsEnabled(strictEndpointUrlsEnforced). }
true;public;1;3;/**  * Server name  */ ;/**  * Server name  */ public void setServerName(final String serverName) {     this.serverConfig.setServerName(serverName). }
true;public;1;3;/**  * Server hostname  */ ;/**  * Server hostname  */ public void setHostname(final String hostname) {     this.serverConfig.setServerName(hostname). }
true;public;1;7;/**  * Security policies  */ ;/**  * Security policies  */ public void setSecurityPolicies(final Set<SecurityPolicy> securityPolicies) {     if (securityPolicies == null || securityPolicies.isEmpty()) {         this.serverConfig.setSecurityPolicies(EnumSet.noneOf(SecurityPolicy.class)).     } else {         this.serverConfig.setSecurityPolicies(EnumSet.copyOf(securityPolicies)).     } }
true;public;1;12;/**  * Security policies by URI or name  */ ;/**  * Security policies by URI or name  */ public void setSecurityPoliciesById(final Collection<String> securityPolicies) {     final EnumSet<SecurityPolicy> policies = EnumSet.noneOf(SecurityPolicy.class).     if (securityPolicies != null) {         for (final String policyName : securityPolicies) {             final SecurityPolicy policy = SecurityPolicy.fromUriSafe(policyName).orElseGet(() -> SecurityPolicy.valueOf(policyName)).             policies.add(policy).         }     }     this.serverConfig.setSecurityPolicies(policies). }
true;public;1;7;/**  * Security policies by URI or name  */ ;/**  * Security policies by URI or name  */ public void setSecurityPoliciesById(final String... ids) {     if (ids != null) {         setSecurityPoliciesById(Arrays.asList(ids)).     } else {         setSecurityPoliciesById((Collection<String>) null).     } }
true;public;1;18;/**  * Set user password combinations in the form of "user1:pwd1,user2:pwd2"  * <p>  * Usernames and passwords will be URL decoded  * </p>  */ ;/**  * Set user password combinations in the form of "user1:pwd1,user2:pwd2"  * <p>  * Usernames and passwords will be URL decoded  * </p>  */ public void setUserAuthenticationCredentials(final String userAuthenticationCredentials) {     if (userAuthenticationCredentials != null) {         this.userMap = new HashMap<>().         for (final String creds : userAuthenticationCredentials.split(",")) {             final String[] toks = creds.split(":", 2).             if (toks.length == 2) {                 try {                     this.userMap.put(URLDecoder.decode(toks[0], URL_CHARSET), URLDecoder.decode(toks[1], URL_CHARSET)).                 } catch (final UnsupportedEncodingException e) {                     log.warn("Failed to decode user map entry", e).                 }             }         }     } else {         this.userMap = null.     } }
true;public;1;3;/**  * Enable anonymous authentication, disabled by default  */ ;/**  * Enable anonymous authentication, disabled by default  */ public void setEnableAnonymousAuthentication(final boolean enableAnonymousAuthentication) {     this.enableAnonymousAuthentication = enableAnonymousAuthentication. }
true;public;1;3;/**  * Set the {@link UserTokenPolicy} used when  */ ;/**  * Set the {@link UserTokenPolicy} used when  */ public void setUsernameSecurityPolicyUri(final SecurityPolicy usernameSecurityPolicy) {     this.usernameSecurityPolicyUri = usernameSecurityPolicy.getSecurityPolicyUri(). }
true;public;1;3;/**  * Set the {@link UserTokenPolicy} used when  */ ;/**  * Set the {@link UserTokenPolicy} used when  */ public void setUsernameSecurityPolicyUri(String usernameSecurityPolicyUri) {     this.usernameSecurityPolicyUri = usernameSecurityPolicyUri. }
true;public;1;7;/**  * Set the addresses of the local addresses the server should bind to  */ ;/**  * Set the addresses of the local addresses the server should bind to  */ public void setBindAddresses(final String bindAddresses) {     if (bindAddresses != null) {         this.bindAddresses = Arrays.asList(bindAddresses.split(",")).     } else {         this.bindAddresses = null.     } }
true;public;1;3;/**  * Server build info  */ ;/**  * Server build info  */ public void setBuildInfo(final BuildInfo buildInfo) {     this.serverConfig.setBuildInfo(buildInfo). }
true;public;1;12;/**  * Server certificate  */ ;/**  * Server certificate  */ public void setServerCertificate(final KeyStoreLoader.Result result) {     /*          * We are not implicitly deactivating the server certificate manager. If          * the key could not be found by the KeyStoreLoader, it will return          * "null" from the load() method. So if someone calls          * setServerCertificate ( loader.load () ). he may, by accident, disable          * the server certificate. If disabling the server certificate is          * desired, do it explicitly.          */     Objects.requireNonNull(result, "Setting a null is not supported. call setCertificateManager(null) instead.)").     setServerCertificate(result.getKeyPair(), result.getCertificate()). }
true;public;2;3;/**  * Server certificate  */ ;/**  * Server certificate  */ public void setServerCertificate(final KeyPair keyPair, final X509Certificate certificate) {     setCertificateManager(new DefaultCertificateManager(keyPair, certificate)). }
true;public;1;7;/**  * Server certificate manager  */ ;/**  * Server certificate manager  */ public void setCertificateManager(final CertificateManager certificateManager) {     if (certificateManager != null) {         this.serverConfig.setCertificateManager(certificateManager).     } else {         this.serverConfig.setCertificateManager(new DefaultCertificateManager()).     } }
true;public;1;3;/**  * Validator for client certificates  */ ;/**  * Validator for client certificates  */ public void setCertificateValidator(final Supplier<CertificateValidator> certificateValidator) {     this.certificateValidator = certificateValidator. }
true;public;1;3;/**  * Validator for client certificates using default file based approach  */ ;/**  * Validator for client certificates using default file based approach  */ public void setDefaultCertificateValidator(final File certificatesBaseDir) {     this.certificateValidator = () -> new DefaultCertificateValidator(certificatesBaseDir). }
