commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;12;;// ********************************* // Parameters validation // ********************************* @Override protected Result verifyParameters(Map<String, Object> parameters) {     ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS).     // Validate using the catalog but do not report unknown options as error     // as the may be used to customize the underlying component     super.verifyParametersAgainstCatalog(builder, parameters, CUSTOMIZER).     verifyUnderlyingComponent(Scope.PARAMETERS, builder, parameters).     return builder.build(). }
false;protected;1;8;;// ********************************* // Connectivity validation // ********************************* @Override protected Result verifyConnectivity(Map<String, Object> parameters) {     ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.CONNECTIVITY).     verifyUnderlyingComponent(Scope.CONNECTIVITY, builder, parameters).     return builder.build(). }
false;protected;3;65;;// ********************************* // Helpers // ********************************* protected void verifyUnderlyingComponent(Scope scope, ResultBuilder builder, Map<String, Object> parameters) {     // componentName is required for validation even at runtime camel might     // be able to find a suitable component at runtime.     String componentName = (String) parameters.get("componentName").     if (ObjectHelper.isNotEmpty(componentName)) {         try {             final Component component = getTransportComponent(componentName).             final Optional<ComponentVerifierExtension> extension = component.getExtension(ComponentVerifierExtension.class).             if (extension.isPresent()) {                 final ComponentVerifierExtension verifier = extension.get().                 final RuntimeCamelCatalog catalog = getCamelContext().getExtension(RuntimeCamelCatalog.class).                 final String json = catalog.componentJSonSchema("rest").                 final Map<String, Object> restParameters = new HashMap<>(parameters).                 for (Map<String, String> m : JSonSchemaHelper.parseJsonSchema("componentProperties", json, true)) {                     String name = m.get("name").                     Object val = restParameters.remove(name).                     if (val != null) {                         // Add rest prefix to properties belonging to the rest                         // component so the underlying component know we want                         // to validate rest-related stuffs.                         restParameters.put("rest." + name, parameters.get(name)).                     }                 }                 for (Map<String, String> m : JSonSchemaHelper.parseJsonSchema("properties", json, true)) {                     String name = m.get("name").                     Object val = restParameters.remove(name).                     if (val != null) {                         // Add rest prefix to properties belonging to the rest                         // component so the underlying component know we want                         // to validate rest-related stuffs.                         restParameters.put("rest." + name, parameters.get(name)).                     }                 }                 // restParameters now should contains rest-component related                 // properties with "rest." prefix and all the remaining can                 // be used to customize the underlying component (i.e. http                 // proxies, auth, etc)                 Result result = verifier.verify(scope, restParameters).                 // they comes from                 for (VerificationError error : result.getErrors()) {                     builder.error(ResultErrorBuilder.fromError(error).detail("component", componentName).build()).                 }             } else {                 builder.error(ResultErrorBuilder.withUnsupportedComponent(componentName).build()).             }         } catch (Exception e) {             builder.error(ResultErrorBuilder.withException(e).build()).         }     } else {         builder.error(ResultErrorBuilder.withMissingOption("componentName").build()).     } }
false;private;1;7;;private Component getTransportComponent(String componentName) throws Exception {     return Suppliers.firstMatching(comp -> comp != null && (comp instanceof RestConsumerFactory || comp instanceof RestProducerFactory), () -> getCamelContext().getRegistry().lookupByNameAndType(componentName, Component.class), () -> getCamelContext().getComponent(componentName, true, false)).orElse(null). }
