commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;83;;@Override protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {     String restConfigurationName = getAndRemoveParameter(parameters, "componentName", String.class, componentName).     RestEndpoint answer = new RestEndpoint(uri, this).     answer.setComponentName(restConfigurationName).     answer.setApiDoc(apiDoc).     RestConfiguration config = new RestConfiguration().     mergeConfigurations(config, findGlobalRestConfiguration()).     mergeConfigurations(config, getCamelContext().getRestConfiguration(restConfigurationName, true)).     // if no explicit host was given, then fallback and use default configured host     String h = getAndRemoveOrResolveReferenceParameter(parameters, "host", String.class, host).     if (h == null) {         h = config.getHost().         int port = config.getPort().         // is there a custom port number         if (port > 0 && port != 80 && port != 443) {             h += ":" + port.         }     }     // host must start with http:// or https://     if (h != null && !(h.startsWith("http://") || h.startsWith("https://"))) {         h = "http://" + h.     }     answer.setHost(h).     setProperties(answer, parameters).     if (!parameters.isEmpty()) {         // use only what remains and at this point parameters that have been used have been removed         // without overwriting any query parameters set via queryParameters endpoint option         final Map<String, Object> queryParameters = new LinkedHashMap<>(parameters).         final Map<String, Object> existingQueryParameters = URISupport.parseQuery(answer.getQueryParameters()).         queryParameters.putAll(existingQueryParameters).         final String remainingParameters = URISupport.createQueryString(queryParameters).         answer.setQueryParameters(remainingParameters).     }     answer.setParameters(parameters).     if (!remaining.contains(":")) {         throw new IllegalArgumentException("Invalid syntax. Must be rest:method:path[:uriTemplate] where uriTemplate is optional").     }     String method = StringHelper.before(remaining, ":").     String s = StringHelper.after(remaining, ":").     String path.     String uriTemplate.     if (s != null && s.contains(":")) {         path = StringHelper.before(s, ":").         uriTemplate = StringHelper.after(s, ":").     } else {         path = s.         uriTemplate = null.     }     // remove trailing slashes     path = FileUtil.stripTrailingSeparator(path).     uriTemplate = FileUtil.stripTrailingSeparator(uriTemplate).     answer.setMethod(method).     answer.setPath(path).     answer.setUriTemplate(uriTemplate).     // if no explicit component name was given, then fallback and use default configured component name     if (answer.getComponentName() == null) {         String name = config.getProducerComponent().         if (name == null) {             // fallback and use the consumer name             name = config.getComponent().         }         answer.setComponentName(name).     }     // if no explicit producer api was given, then fallback and use default configured     if (answer.getApiDoc() == null) {         answer.setApiDoc(config.getProducerApiDoc()).     }     return answer. }
false;public;0;3;;public String getComponentName() {     return componentName. }
true;public;1;3;/**  * The Camel Rest component to use for the REST transport, such as restlet, spark-rest.  * If no component has been explicit configured, then Camel will lookup if there is a Camel component  * that integrates with the Rest DSL, or if a org.apache.camel.spi.RestConsumerFactory (consumer)  * or org.apache.camel.spi.RestProducerFactory (producer) is registered in the registry.  * If either one is found, then that is being used.  */ ;/**  * The Camel Rest component to use for the REST transport, such as restlet, spark-rest.  * If no component has been explicit configured, then Camel will lookup if there is a Camel component  * that integrates with the Rest DSL, or if a org.apache.camel.spi.RestConsumerFactory (consumer)  * or org.apache.camel.spi.RestProducerFactory (producer) is registered in the registry.  * If either one is found, then that is being used.  */ public void setComponentName(String componentName) {     this.componentName = componentName. }
false;public;0;3;;public String getApiDoc() {     return apiDoc. }
true;public;1;3;/**  * The swagger api doc resource to use.  * The resource is loaded from classpath by default and must be in JSon format.  */ ;/**  * The swagger api doc resource to use.  * The resource is loaded from classpath by default and must be in JSon format.  */ public void setApiDoc(String apiDoc) {     this.apiDoc = apiDoc. }
false;public;0;3;;public String getHost() {     return host. }
true;public;1;3;/**  * Host and port of HTTP service to use (override host in swagger schema)  */ ;/**  * Host and port of HTTP service to use (override host in swagger schema)  */ public void setHost(String host) {     this.host = host. }
false;private;0;10;;// **************************************** // Helpers // **************************************** private RestConfiguration findGlobalRestConfiguration() {     CamelContext context = getCamelContext().     RestConfiguration conf = CamelContextHelper.lookup(context, DEFAULT_REST_CONFIGURATION_ID, RestConfiguration.class).     if (conf == null) {         conf = CamelContextHelper.findByType(getCamelContext(), RestConfiguration.class).     }     return conf. }
false;private;2;30;;private RestConfiguration mergeConfigurations(RestConfiguration conf, RestConfiguration from) throws Exception {     if (conf == from) {         return conf.     }     if (from != null) {         Map<String, Object> map = IntrospectionSupport.getNonNullProperties(from).         // Remove properties as they need to be manually managed         Iterator<Map.Entry<String, Object>> it = map.entrySet().iterator().         while (it.hasNext()) {             Map.Entry<String, Object> entry = it.next().             if (entry.getValue() instanceof Map) {                 it.remove().             }         }         // Copy common options, will override those in conf         IntrospectionSupport.setProperties(getCamelContext(), getCamelContext().getTypeConverter(), conf, map).         // Merge properties         mergeProperties(conf::getComponentProperties, from::getComponentProperties, conf::setComponentProperties).         mergeProperties(conf::getEndpointProperties, from::getEndpointProperties, conf::setEndpointProperties).         mergeProperties(conf::getConsumerProperties, from::getConsumerProperties, conf::setConsumerProperties).         mergeProperties(conf::getDataFormatProperties, from::getDataFormatProperties, conf::setDataFormatProperties).         mergeProperties(conf::getApiProperties, from::getApiProperties, conf::setApiProperties).         mergeProperties(conf::getCorsHeaders, from::getCorsHeaders, conf::setCorsHeaders).     }     return conf. }
false;private;3;16;;private <T> void mergeProperties(Supplier<Map<String, T>> base, Supplier<Map<String, T>> addons, Consumer<Map<String, T>> consumer) {     Map<String, T> baseMap = base.get().     Map<String, T> addonsMap = addons.get().     if (baseMap != null || addonsMap != null) {         HashMap<String, T> result = new HashMap<>().         if (baseMap != null) {             result.putAll(baseMap).         }         if (addonsMap != null) {             result.putAll(addonsMap).         }         consumer.accept(result).     } }
false;public;0;3;;public ComponentVerifierExtension getVerifier() {     return (scope, parameters) -> getExtension(ComponentVerifierExtension.class).orElseThrow(UnsupportedOperationException::new).verify(scope, parameters). }
