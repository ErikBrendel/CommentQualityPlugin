commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Producer createProducer() throws Exception {     return new HBaseProducer(this). }
false;public;1;6;;public Consumer createConsumer(Processor processor) throws Exception {     HBaseConsumer consumer = new HBaseConsumer(this, processor).     configureConsumer(consumer).     consumer.setMaxMessagesPerPoll(maxMessagesPerPoll).     return consumer. }
false;public;0;3;;public boolean isSingleton() {     return true. }
false;public;0;3;;public Configuration getConfiguration() {     return configuration. }
false;public;1;3;;public void setConfiguration(Configuration configuration) {     this.configuration = configuration. }
false;public;0;3;;public HBaseAdmin getAdmin() {     return admin. }
false;public;1;3;;public void setAdmin(HBaseAdmin admin) {     this.admin = admin. }
false;public;0;3;;public int getMaxResults() {     return maxResults. }
true;public;1;3;/**  * The maximum number of rows to scan.  */ ;/**  * The maximum number of rows to scan.  */ public void setMaxResults(int maxResults) {     this.maxResults = maxResults. }
false;public;0;3;;public List<Filter> getFilters() {     return filters. }
true;public;1;3;/**  * A list of filters to use.  */ ;/**  * A list of filters to use.  */ public void setFilters(List<Filter> filters) {     this.filters = filters. }
false;public;0;3;;public String getOperation() {     return operation. }
true;public;1;3;/**  * The HBase operation to perform  */ ;/**  * The HBase operation to perform  */ public void setOperation(String operation) {     this.operation = operation. }
false;public;0;3;;public CellMappingStrategyFactory getCellMappingStrategyFactory() {     return cellMappingStrategyFactory. }
true;public;1;3;/**  * To use a custom CellMappingStrategyFactory that is responsible for mapping cells.  */ ;/**  * To use a custom CellMappingStrategyFactory that is responsible for mapping cells.  */ public void setCellMappingStrategyFactory(CellMappingStrategyFactory cellMappingStrategyFactory) {     this.cellMappingStrategyFactory = cellMappingStrategyFactory. }
false;public;0;3;;public String getMappingStrategyName() {     return mappingStrategyName. }
true;public;1;3;/**  * The strategy to use for mapping Camel messages to HBase columns. Supported values: header, or body.  */ ;/**  * The strategy to use for mapping Camel messages to HBase columns. Supported values: header, or body.  */ public void setMappingStrategyName(String mappingStrategyName) {     this.mappingStrategyName = mappingStrategyName. }
false;public;0;3;;public String getMappingStrategyClassName() {     return mappingStrategyClassName. }
true;public;1;3;/**  * The class name of a custom mapping strategy implementation.  */ ;/**  * The class name of a custom mapping strategy implementation.  */ public void setMappingStrategyClassName(String mappingStrategyClassName) {     this.mappingStrategyClassName = mappingStrategyClassName. }
false;public;0;3;;public HBaseRow getRowModel() {     return rowModel. }
true;public;1;3;/**  * An instance of org.apache.camel.component.hbase.model.HBaseRow which describes how each row should be modeled  */ ;/**  * An instance of org.apache.camel.component.hbase.model.HBaseRow which describes how each row should be modeled  */ public void setRowModel(HBaseRow rowModel) {     this.rowModel = rowModel. }
false;public;0;3;;public boolean isRemove() {     return remove. }
true;public;1;3;/**  * If the option is true, Camel HBase Consumer will remove the rows which it processes.  */ ;/**  * If the option is true, Camel HBase Consumer will remove the rows which it processes.  */ public void setRemove(boolean remove) {     this.remove = remove. }
false;public;0;3;;public HBaseRemoveHandler getRemoveHandler() {     return removeHandler. }
true;public;1;3;/**  * To use a custom HBaseRemoveHandler that is executed when a row is to be removed.  */ ;/**  * To use a custom HBaseRemoveHandler that is executed when a row is to be removed.  */ public void setRemoveHandler(HBaseRemoveHandler removeHandler) {     this.removeHandler = removeHandler. }
false;public;0;3;;public int getMaxMessagesPerPoll() {     return maxMessagesPerPoll. }
true;public;1;3;/**  * Gets the maximum number of messages as a limit to poll at each polling.  * <p/>  * Is default unlimited, but use 0 or negative number to disable it as unlimited.  */ ;/**  * Gets the maximum number of messages as a limit to poll at each polling.  * <p/>  * Is default unlimited, but use 0 or negative number to disable it as unlimited.  */ public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {     this.maxMessagesPerPoll = maxMessagesPerPoll. }
false;public;0;3;;public UserGroupInformation getUserGroupInformation() {     return userGroupInformation. }
true;public;1;3;/**  * Defines privileges to communicate with HBase such as using kerberos.  */ ;/**  * Defines privileges to communicate with HBase such as using kerberos.  */ public void setUserGroupInformation(UserGroupInformation userGroupInformation) {     this.userGroupInformation = userGroupInformation. }
false;public;0;3;;public Map<String, Object> getRowMapping() {     return rowMapping. }
true;public;1;3;/**  * To map the key/values from the Map to a {@link HBaseRow}.  * <p/>  * The following keys is supported:  * <ul>  *     <li>rowId - The id of the row. This has limited use as the row usually changes per Exchange.</li>  *     <li>rowType - The type to covert row id to. Supported operations: CamelHBaseScan.</li>  *     <li>family - The column family. Supports a number suffix for referring to more than one columns.</li>  *     <li>qualifier - The column qualifier. Supports a number suffix for referring to more than one columns.</li>  *     <li>value - The value. Supports a number suffix for referring to more than one columns</li>  *     <li>valueType - The value type. Supports a number suffix for referring to more than one columns. Supported operations: CamelHBaseGet, and CamelHBaseScan.</li>  * </ul>  */ ;/**  * To map the key/values from the Map to a {@link HBaseRow}.  * <p/>  * The following keys is supported:  * <ul>  *     <li>rowId - The id of the row. This has limited use as the row usually changes per Exchange.</li>  *     <li>rowType - The type to covert row id to. Supported operations: CamelHBaseScan.</li>  *     <li>family - The column family. Supports a number suffix for referring to more than one columns.</li>  *     <li>qualifier - The column qualifier. Supports a number suffix for referring to more than one columns.</li>  *     <li>value - The value. Supports a number suffix for referring to more than one columns</li>  *     <li>valueType - The value type. Supports a number suffix for referring to more than one columns. Supported operations: CamelHBaseGet, and CamelHBaseScan.</li>  * </ul>  */ public void setRowMapping(Map<String, Object> rowMapping) {     this.rowMapping = rowMapping. }
false;protected;0;8;;@Override protected void doStart() throws Exception {     super.doStart().     if (rowModel == null && rowMapping != null) {         rowModel = createRowModel(rowMapping).     } }
false;protected;0;4;;@Override protected void doStop() throws Exception {     super.doStop(). }
false;public;0;8;;@Override public Table run() {     try {         return connection.getTable(TableName.valueOf(tableNameBytes)).     } catch (IOException e) {         throw new RuntimeException(e).     } }
true;public;0;16;/**  * Gets connection to the table (secured or not, depends on the object initialization)  * please remember to close the table after use  * @return table, remember to close!  */ ;/**  * Gets connection to the table (secured or not, depends on the object initialization)  * please remember to close the table after use  * @return table, remember to close!  */ public Table getTable() throws IOException {     if (userGroupInformation != null) {         return userGroupInformation.doAs(new PrivilegedAction<Table>() {              @Override             public Table run() {                 try {                     return connection.getTable(TableName.valueOf(tableNameBytes)).                 } catch (IOException e) {                     throw new RuntimeException(e).                 }             }         }).     } else {         return connection.getTable(TableName.valueOf(tableNameBytes)).     } }
true;private;1;24;/**  * Creates an {@link HBaseRow} model from the specified endpoint parameters.  */ ;/**  * Creates an {@link HBaseRow} model from the specified endpoint parameters.  */ private HBaseRow createRowModel(Map<String, Object> parameters) {     HBaseRow rowModel = new HBaseRow().     if (parameters.containsKey(HBaseAttribute.HBASE_ROW_TYPE.asOption())) {         String rowType = String.valueOf(parameters.remove(HBaseAttribute.HBASE_ROW_TYPE.asOption())).         if (rowType != null && !rowType.isEmpty()) {             rowModel.setRowType(getCamelContext().getClassResolver().resolveClass(rowType)).         }     }     for (int i = 1. parameters.get(HBaseAttribute.HBASE_FAMILY.asOption(i)) != null && parameters.get(HBaseAttribute.HBASE_QUALIFIER.asOption(i)) != null. i++) {         HBaseCell cellModel = new HBaseCell().         cellModel.setFamily(String.valueOf(parameters.remove(HBaseAttribute.HBASE_FAMILY.asOption(i)))).         cellModel.setQualifier(String.valueOf(parameters.remove(HBaseAttribute.HBASE_QUALIFIER.asOption(i)))).         cellModel.setValue(String.valueOf(parameters.remove(HBaseAttribute.HBASE_VALUE.asOption(i)))).         if (parameters.containsKey(HBaseAttribute.HBASE_VALUE_TYPE.asOption(i))) {             String valueType = String.valueOf(parameters.remove(HBaseAttribute.HBASE_VALUE_TYPE.asOption(i))).             if (valueType != null && !valueType.isEmpty()) {                 rowModel.setRowType(getCamelContext().getClassResolver().resolveClass(valueType)).             }         }         rowModel.getCells().add(cellModel).     }     return rowModel. }
