commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public Consumer createConsumer(final Processor processor) throws Exception {     throw new UnsupportedOperationException("Consumer not supported"). }
false;public;0;37;;@Override public Producer createProducer() throws Exception {     final CamelContext camelContext = getCamelContext().     final Swagger swagger = loadSpecificationFrom(camelContext, specificationUri).     final Map<String, Path> paths = swagger.getPaths().     for (final Entry<String, Path> pathEntry : paths.entrySet()) {         final Path path = pathEntry.getValue().         final Optional<Entry<HttpMethod, Operation>> maybeOperationEntry = path.getOperationMap().entrySet().stream().filter(operationEntry -> operationId.equals(operationEntry.getValue().getOperationId())).findAny().         if (maybeOperationEntry.isPresent()) {             final Entry<HttpMethod, Operation> operationEntry = maybeOperationEntry.get().             final Operation operation = operationEntry.getValue().             final Map<String, Parameter> pathParameters = operation.getParameters().stream().filter(p -> "path".equals(p.getIn())).collect(Collectors.toMap(Parameter::getName, Function.identity())).             final String uriTemplate = resolveUri(pathEntry.getKey(), pathParameters).             final HttpMethod httpMethod = operationEntry.getKey().             final String method = httpMethod.name().             return createProducerFor(swagger, operation, method, uriTemplate).         }     }     final String supportedOperations = paths.values().stream().flatMap(p -> p.getOperations().stream()).map(Operation::getOperationId).collect(Collectors.joining(", ")).     throw new IllegalArgumentException("The specified operation with ID: `" + operationId + "` cannot be found in the Swagger specification loaded from `" + specificationUri + "`. Operations defined in the specification are: " + supportedOperations). }
false;public;0;3;;public String getBasePath() {     return basePath. }
false;public;0;3;;public String getComponentName() {     return componentName. }
false;public;0;3;;public String getConsumes() {     return consumes. }
false;public;0;3;;public String getHost() {     return host. }
false;public;0;3;;public String getOperationId() {     return operationId. }
false;public;0;3;;public String getProduces() {     return produces. }
false;public;0;3;;public URI getSpecificationUri() {     return specificationUri. }
false;public;0;4;;@Override public boolean isLenientProperties() {     return true. }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;public;1;3;;public void setBasePath(final String basePath) {     this.basePath = notEmpty(basePath, "basePath"). }
false;public;1;3;;public void setComponentName(final String componentName) {     this.componentName = notEmpty(componentName, "componentName"). }
false;public;1;3;;public void setConsumes(final String consumes) {     this.consumes = isMediaRange(consumes, "consumes"). }
false;public;1;3;;public void setHost(final String host) {     this.host = isHostParam(host). }
false;public;1;3;;public void setOperationId(final String operationId) {     this.operationId = notEmpty(operationId, "operationId"). }
false;public;1;3;;public void setProduces(final String produces) {     this.produces = isMediaRange(produces, "produces"). }
false;public;1;3;;public void setSpecificationUri(final URI specificationUri) {     this.specificationUri = notNull(specificationUri, "specificationUri"). }
false;;0;3;;RestSwaggerComponent component() {     return (RestSwaggerComponent) getComponent(). }
false;;4;15;;Producer createProducerFor(final Swagger swagger, final Operation operation, final String method, final String uriTemplate) throws Exception {     final String basePath = determineBasePath(swagger).     final StringBuilder componentEndpointUri = new StringBuilder(200).append("rest:").append(method).append(":").append(basePath).append(":").append(uriTemplate).     final CamelContext camelContext = getCamelContext().     final Endpoint endpoint = camelContext.getEndpoint(componentEndpointUri.toString()).     setProperties(endpoint, determineEndpointParameters(swagger, operation)).     return endpoint.createProducer(). }
false;;1;29;;String determineBasePath(final Swagger swagger) {     if (isNotEmpty(basePath)) {         return basePath.     }     final String componentBasePath = component().getBasePath().     if (isNotEmpty(componentBasePath)) {         return componentBasePath.     }     final String specificationBasePath = swagger.getBasePath().     if (isNotEmpty(specificationBasePath)) {         return specificationBasePath.     }     final CamelContext camelContext = getCamelContext().     final RestConfiguration specificConfiguration = camelContext.getRestConfiguration(assignedComponentName, false).     if (specificConfiguration != null && isNotEmpty(specificConfiguration.getContextPath())) {         return specificConfiguration.getContextPath().     }     final RestConfiguration restConfiguration = camelContext.getRestConfiguration("rest-swagger", true).     final String restConfigurationBasePath = restConfiguration.getContextPath().     if (isNotEmpty(restConfigurationBasePath)) {         return restConfigurationBasePath.     }     return RestSwaggerComponent.DEFAULT_BASE_PATH. }
false;;0;3;;String determineComponentName() {     return Optional.ofNullable(componentName).orElse(component().getComponentName()). }
false;;2;61;;Map<String, Object> determineEndpointParameters(final Swagger swagger, final Operation operation) {     final Map<String, Object> parameters = new HashMap<>().     final String componentName = determineComponentName().     if (componentName != null) {         parameters.put("componentName", componentName).     }     final String host = determineHost(swagger).     if (host != null) {         parameters.put("host", host).     }     final RestSwaggerComponent component = component().     // what we consume is what the API defined by Swagger specification     // produces     final String determinedConsumes = determineOption(swagger.getProduces(), operation.getProduces(), component.getConsumes(), consumes).     if (isNotEmpty(determinedConsumes)) {         parameters.put("consumes", determinedConsumes).     }     // what we produce is what the API defined by Swagger specification     // consumes     final String determinedProducers = determineOption(swagger.getConsumes(), operation.getConsumes(), component.getProduces(), produces).     if (isNotEmpty(determinedProducers)) {         parameters.put("produces", determinedProducers).     }     final String queryParameters = operation.getParameters().stream().filter(p -> "query".equals(p.getIn())).map(this::queryParameter).collect(Collectors.joining("&")).     if (isNotEmpty(queryParameters)) {         parameters.put("queryParameters", queryParameters).     }     // pass properties that might be applied if the delegate component is created, i.e. if it's not     // present in the Camel Context already     final Map<String, Object> componentParameters = new HashMap<>().     if (component.isUseGlobalSslContextParameters()) {         // by default it's false         componentParameters.put("useGlobalSslContextParameters", component.isUseGlobalSslContextParameters()).     }     if (component.getSslContextParameters() != null) {         componentParameters.put("sslContextParameters", component.getSslContextParameters()).     }     if (!componentParameters.isEmpty()) {         final Map<Object, Object> nestedParameters = new HashMap<>().         nestedParameters.put("component", componentParameters).         // we're trying to set RestEndpoint.parameters['component']         parameters.put("parameters", nestedParameters).     }     return parameters. }
false;;1;56;;String determineHost(final Swagger swagger) {     if (isNotEmpty(host)) {         return host.     }     final String componentHost = component().getHost().     if (isNotEmpty(componentHost)) {         return componentHost.     }     final String swaggerScheme = pickBestScheme(specificationUri.getScheme(), swagger.getSchemes()).     final String swaggerHost = swagger.getHost().     if (isNotEmpty(swaggerScheme) && isNotEmpty(swaggerHost)) {         return swaggerScheme + "://" + swaggerHost.     }     final CamelContext camelContext = getCamelContext().     final RestConfiguration specificRestConfiguration = camelContext.getRestConfiguration(assignedComponentName, false).     final String specificConfigurationHost = hostFrom(specificRestConfiguration).     if (specificConfigurationHost != null) {         return specificConfigurationHost.     }     final RestConfiguration componentRestConfiguration = camelContext.getRestConfiguration("rest-swagger", false).     final String componentConfigurationHost = hostFrom(componentRestConfiguration).     if (componentConfigurationHost != null) {         return componentConfigurationHost.     }     final RestConfiguration globalRestConfiguration = camelContext.getRestConfiguration().     final String globalConfigurationHost = hostFrom(globalRestConfiguration).     if (globalConfigurationHost != null) {         return globalConfigurationHost.     }     final String specificationScheme = specificationUri.getScheme().     if (specificationUri.isAbsolute() && specificationScheme.toLowerCase().startsWith("http")) {         try {             return new URI(specificationUri.getScheme(), specificationUri.getUserInfo(), specificationUri.getHost(), specificationUri.getPort(), null, null, null).toString().         } catch (final URISyntaxException e) {             throw new IllegalStateException("Unable to create a new URI from: " + specificationUri, e).         }     }     final boolean areTheSame = "rest-swagger".equals(assignedComponentName).     throw new IllegalStateException("Unable to determine destination host for requests. The Swagger specification" + " does not specify `scheme` and `host` parameters, the specification URI is not absolute with `http` or" + " `https` scheme, and no RestConfigurations configured with `scheme`, `host` and `port` were found for `" + (areTheSame ? "rest-swagger` component" : assignedComponentName + "` or `rest-swagger` components") + " and there is no global RestConfiguration with those properties"). }
false;;1;8;;String literalPathParameterValue(final Parameter parameter) {     final String name = parameter.getName().     final String valueStr = String.valueOf(parameters.get(name)).     final String encoded = UnsafeUriCharactersEncoder.encode(valueStr).     return encoded. }
false;;1;8;;String literalQueryParameterValue(final Parameter parameter) {     final String name = parameter.getName().     final String valueStr = String.valueOf(parameters.get(name)).     final String encoded = UnsafeUriCharactersEncoder.encode(valueStr).     return name + "=" + encoded. }
false;;1;12;;String queryParameter(final Parameter parameter) {     final String name = parameter.getName().     if (ObjectHelper.isEmpty(name)) {         return "".     }     if (parameters.containsKey(name)) {         return literalQueryParameterValue(parameter).     }     return queryParameterExpression(parameter). }
false;;2;38;;String resolveUri(final String uriTemplate, final Map<String, Parameter> pathParameters) {     if (pathParameters.isEmpty()) {         return uriTemplate.     }     int start = uriTemplate.indexOf('{').     if (start == -1) {         return uriTemplate.     }     int pos = 0.     final StringBuilder resolved = new StringBuilder(uriTemplate.length() * 2).     while (start != -1) {         resolved.append(uriTemplate.substring(pos, start)).         final int end = uriTemplate.indexOf('}', start).         final String name = uriTemplate.substring(start + 1, end).         if (parameters.containsKey(name)) {             final Parameter parameter = pathParameters.get(name).             final Object value = literalPathParameterValue(parameter).             resolved.append(value).         } else {             resolved.append('{').append(name).append('}').         }         pos = end + 1.         start = uriTemplate.indexOf('{', pos).     }     if (pos < uriTemplate.length()) {         resolved.append(uriTemplate.substring(pos)).     }     return resolved.toString(). }
false;static;4;20;;static String determineOption(final List<String> specificationLevel, final List<String> operationLevel, final String componentLevel, final String endpointLevel) {     if (isNotEmpty(endpointLevel)) {         return endpointLevel.     }     if (isNotEmpty(componentLevel)) {         return componentLevel.     }     if (operationLevel != null && !operationLevel.isEmpty()) {         return String.join(", ", operationLevel).     }     if (specificationLevel != null && !specificationLevel.isEmpty()) {         return String.join(", ", specificationLevel).     }     return null. }
false;static;1;21;;static String hostFrom(final RestConfiguration restConfiguration) {     if (restConfiguration == null) {         return null.     }     final String scheme = restConfiguration.getScheme().     final String host = restConfiguration.getHost().     final int port = restConfiguration.getPort().     if (scheme == null || host == null) {         return null.     }     final StringBuilder answer = new StringBuilder(scheme).append("://").append(host).     if (port > 0 && !("http".equalsIgnoreCase(scheme) && port == 80) && !("https".equalsIgnoreCase(scheme) && port == 443)) {         answer.append(':').append(port).     }     return answer.toString(). }
true;static;2;26;/**  * Loads the Swagger definition model from the given path. Tries to resolve  * the resource using Camel's resource loading support, if it fails uses  * Swagger's resource loading support instead.  *  * @param uri URI of the specification  * @param camelContext context to use  * @return the specification  * @throws IOException  */ ;/**  * Loads the Swagger definition model from the given path. Tries to resolve  * the resource using Camel's resource loading support, if it fails uses  * Swagger's resource loading support instead.  *  * @param uri URI of the specification  * @param camelContext context to use  * @return the specification  * @throws IOException  */ static Swagger loadSpecificationFrom(final CamelContext camelContext, final URI uri) throws IOException {     final ObjectMapper mapper = Json.mapper().     final SwaggerParser swaggerParser = new SwaggerParser().     final String uriAsString = uri.toString().     try (InputStream stream = ResourceHelper.resolveMandatoryResourceAsInputStream(camelContext, uriAsString)) {         final JsonNode node = mapper.readTree(stream).         return swaggerParser.read(node).     } catch (final Exception e) {         // try Swaggers loader         final Swagger swagger = swaggerParser.read(uriAsString).         if (swagger != null) {             return swagger.         }         throw new IllegalArgumentException("The given Swagger specification could not be loaded from `" + uri + "`. Tried loading using Camel's resource resolution and using Swagger's own resource resolution." + " Swagger tends to swallow exceptions while parsing, try specifying Java system property `debugParser`" + " (e.g. `-DdebugParser=true`), the exception that occurred when loading using Camel's resource" + " loader follows", e).     } }
false;static;2;19;;static String pickBestScheme(final String specificationScheme, final List<Scheme> schemes) {     if (schemes != null && !schemes.isEmpty()) {         if (schemes.contains(Scheme.HTTPS)) {             return "https".         }         if (schemes.contains(Scheme.HTTP)) {             return "http".         }     }     if (specificationScheme != null) {         return specificationScheme.     }     return null. }
false;static;1;11;;static String queryParameterExpression(final Parameter parameter) {     final String name = parameter.getName().     final StringBuilder expression = new StringBuilder(name).append("={").append(name).     if (!parameter.getRequired()) {         expression.append('?').     }     expression.append('}').     return expression.toString(). }
