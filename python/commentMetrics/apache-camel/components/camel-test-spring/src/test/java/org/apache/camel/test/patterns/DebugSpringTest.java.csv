commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override public boolean isUseDebugger() {     // must enable debugger     return true. }
false;protected;5;8;;@Override protected void debugBefore(Exchange exchange, Processor processor, ProcessorDefinition<?> definition, String id, String shortName) {     // this method is invoked before we are about to enter the given processor     // from your Java editor you can just add a breakpoint in the code line below     log.info("Before " + definition + " with body " + exchange.getIn().getBody()).     debugged = true. }
false;public;0;13;;@Test public void testDebugger() throws Exception {     // set mock expectations     getMockEndpoint("mock:a").expectedMessageCount(1).     getMockEndpoint("mock:b").expectedMessageCount(1).     // send a message     template.sendBody("direct:start", "World").     // assert mocks     assertMockEndpointsSatisfied().     assertTrue("The debugger is not called!", debugged). }
false;public;0;8;;@Override public void configure() throws Exception {     // this is the route we want to debug     from("direct:start").to("mock:a").transform(body().prepend("Hello ")).to("mock:b"). }
false;protected;0;13;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             // this is the route we want to debug             from("direct:start").to("mock:a").transform(body().prepend("Hello ")).to("mock:b").         }     }. }
false;protected;0;4;;@Override protected AbstractApplicationContext createApplicationContext() {     return new GenericApplicationContext(). }
