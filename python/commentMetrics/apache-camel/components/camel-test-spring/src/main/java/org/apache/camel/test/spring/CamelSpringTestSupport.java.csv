# id;timestamp;commentText;codeText;commentWords;codeWords
CamelSpringTestSupport -> protected Class<?> excludeRoute();1357639877;Template method used to exclude a {@link org.apache.camel.Route} from the test camel context;protected Class<?> excludeRoute() {_        return null__    };template,method,used,to,exclude,a,link,org,apache,camel,route,from,the,test,camel,context;protected,class,exclude,route,return,null
CamelSpringTestSupport -> protected Class<?> excludeRoute();1392400400;Template method used to exclude a {@link org.apache.camel.Route} from the test camel context;protected Class<?> excludeRoute() {_        return null__    };template,method,used,to,exclude,a,link,org,apache,camel,route,from,the,test,camel,context;protected,class,exclude,route,return,null
CamelSpringTestSupport -> protected Class<?> excludeRoute();1521646309;Template method used to exclude a {@link org.apache.camel.Route} from the test camel context;protected Class<?> excludeRoute() {_        return null__    };template,method,used,to,exclude,a,link,org,apache,camel,route,from,the,test,camel,context;protected,class,exclude,route,return,null
CamelSpringTestSupport -> protected Class<?> excludeRoute();1524063209;Template method used to exclude a {@link org.apache.camel.Route} from the test camel context;protected Class<?> excludeRoute() {_        return null__    };template,method,used,to,exclude,a,link,org,apache,camel,route,from,the,test,camel,context;protected,class,exclude,route,return,null
CamelSpringTestSupport -> protected Class<?> excludeRoute();1528210046;Template method used to exclude a {@link org.apache.camel.Route} from the test camel context;protected Class<?> excludeRoute() {_        return null__    };template,method,used,to,exclude,a,link,org,apache,camel,route,from,the,test,camel,context;protected,class,exclude,route,return,null
CamelSpringTestSupport -> protected Class<?>[] excludeRoutes();1357639877;Template method used to exclude {@link org.apache.camel.Route} from the test time context_route scanning__@return Class[] the classes to be excluded from test time context route scanning;protected Class<?>[] excludeRoutes() {_        Class<?> excludedRoute = excludeRoute()__        return excludedRoute != null ? new Class[] {excludedRoute} : new Class[0]__    };template,method,used,to,exclude,link,org,apache,camel,route,from,the,test,time,context,route,scanning,return,class,the,classes,to,be,excluded,from,test,time,context,route,scanning;protected,class,exclude,routes,class,excluded,route,exclude,route,return,excluded,route,null,new,class,excluded,route,new,class,0
CamelSpringTestSupport -> protected Class<?>[] excludeRoutes();1392400400;Template method used to exclude {@link org.apache.camel.Route} from the test time context_route scanning__@return Class[] the classes to be excluded from test time context route scanning;protected Class<?>[] excludeRoutes() {_        Class<?> excludedRoute = excludeRoute()__        return excludedRoute != null ? new Class[] {excludedRoute} : new Class[0]__    };template,method,used,to,exclude,link,org,apache,camel,route,from,the,test,time,context,route,scanning,return,class,the,classes,to,be,excluded,from,test,time,context,route,scanning;protected,class,exclude,routes,class,excluded,route,exclude,route,return,excluded,route,null,new,class,excluded,route,new,class,0
CamelSpringTestSupport -> protected Class<?>[] excludeRoutes();1521646309;Template method used to exclude {@link org.apache.camel.Route} from the test time context_route scanning__@return Class[] the classes to be excluded from test time context route scanning;protected Class<?>[] excludeRoutes() {_        Class<?> excludedRoute = excludeRoute()__        return excludedRoute != null ? new Class[] {excludedRoute} : new Class[0]__    };template,method,used,to,exclude,link,org,apache,camel,route,from,the,test,time,context,route,scanning,return,class,the,classes,to,be,excluded,from,test,time,context,route,scanning;protected,class,exclude,routes,class,excluded,route,exclude,route,return,excluded,route,null,new,class,excluded,route,new,class,0
CamelSpringTestSupport -> protected Class<?>[] excludeRoutes();1524063209;Template method used to exclude {@link org.apache.camel.Route} from the test time context_route scanning__@return Class[] the classes to be excluded from test time context route scanning;protected Class<?>[] excludeRoutes() {_        Class<?> excludedRoute = excludeRoute()__        return excludedRoute != null ? new Class[] {excludedRoute} : new Class[0]__    };template,method,used,to,exclude,link,org,apache,camel,route,from,the,test,time,context,route,scanning,return,class,the,classes,to,be,excluded,from,test,time,context,route,scanning;protected,class,exclude,routes,class,excluded,route,exclude,route,return,excluded,route,null,new,class,excluded,route,new,class,0
CamelSpringTestSupport -> protected Class<?>[] excludeRoutes();1528210046;Template method used to exclude {@link org.apache.camel.Route} from the test time context_route scanning__@return Class[] the classes to be excluded from test time context route scanning;protected Class<?>[] excludeRoutes() {_        Class<?> excludedRoute = excludeRoute()__        return excludedRoute != null ? new Class[] {excludedRoute} : new Class[0]__    };template,method,used,to,exclude,link,org,apache,camel,route,from,the,test,time,context,route,scanning,return,class,the,classes,to,be,excluded,from,test,time,context,route,scanning;protected,class,exclude,routes,class,excluded,route,exclude,route,return,excluded,route,null,new,class,excluded,route,new,class,0
CamelSpringTestSupport -> protected String[] activeProfiles();1357639877;Which active profiles should be used._<p/>_<b>Important:</b> When using active profiles, then the code in {@link #createApplicationContext()} should create_the Spring {@link org.springframework.context.support.AbstractApplicationContext} without refreshing. For example creating an_{@link org.springframework.context.support.ClassPathXmlApplicationContext} you would need to pass in_<tt>false</tt> in the refresh parameter, in the constructor._Camel will thrown an {@link IllegalStateException} if this is not correct stating this problem._The reason is that we cannot active profiles <b>after</b> a Spring application context has already_been refreshed, and is active.__@return an array of active profiles to use, use <tt>null</tt> to not use any active profiles.;protected String[] activeProfiles() {_        return null__    };which,active,profiles,should,be,used,p,b,important,b,when,using,active,profiles,then,the,code,in,link,create,application,context,should,create,the,spring,link,org,springframework,context,support,abstract,application,context,without,refreshing,for,example,creating,an,link,org,springframework,context,support,class,path,xml,application,context,you,would,need,to,pass,in,tt,false,tt,in,the,refresh,parameter,in,the,constructor,camel,will,thrown,an,link,illegal,state,exception,if,this,is,not,correct,stating,this,problem,the,reason,is,that,we,cannot,active,profiles,b,after,b,a,spring,application,context,has,already,been,refreshed,and,is,active,return,an,array,of,active,profiles,to,use,use,tt,null,tt,to,not,use,any,active,profiles;protected,string,active,profiles,return,null
CamelSpringTestSupport -> protected String[] activeProfiles();1392400400;Which active profiles should be used._<p/>_<b>Important:</b> When using active profiles, then the code in {@link #createApplicationContext()} should create_the Spring {@link org.springframework.context.support.AbstractApplicationContext} without refreshing. For example creating an_{@link org.springframework.context.support.ClassPathXmlApplicationContext} you would need to pass in_<tt>false</tt> in the refresh parameter, in the constructor._Camel will thrown an {@link IllegalStateException} if this is not correct stating this problem._The reason is that we cannot active profiles <b>after</b> a Spring application context has already_been refreshed, and is active.__@return an array of active profiles to use, use <tt>null</tt> to not use any active profiles.;protected String[] activeProfiles() {_        return null__    };which,active,profiles,should,be,used,p,b,important,b,when,using,active,profiles,then,the,code,in,link,create,application,context,should,create,the,spring,link,org,springframework,context,support,abstract,application,context,without,refreshing,for,example,creating,an,link,org,springframework,context,support,class,path,xml,application,context,you,would,need,to,pass,in,tt,false,tt,in,the,refresh,parameter,in,the,constructor,camel,will,thrown,an,link,illegal,state,exception,if,this,is,not,correct,stating,this,problem,the,reason,is,that,we,cannot,active,profiles,b,after,b,a,spring,application,context,has,already,been,refreshed,and,is,active,return,an,array,of,active,profiles,to,use,use,tt,null,tt,to,not,use,any,active,profiles;protected,string,active,profiles,return,null
CamelSpringTestSupport -> protected String[] activeProfiles();1521646309;Which active profiles should be used._<p/>_<b>Important:</b> When using active profiles, then the code in {@link #createApplicationContext()} should create_the Spring {@link org.springframework.context.support.AbstractApplicationContext} without refreshing. For example creating an_{@link org.springframework.context.support.ClassPathXmlApplicationContext} you would need to pass in_<tt>false</tt> in the refresh parameter, in the constructor._Camel will thrown an {@link IllegalStateException} if this is not correct stating this problem._The reason is that we cannot active profiles <b>after</b> a Spring application context has already_been refreshed, and is active.__@return an array of active profiles to use, use <tt>null</tt> to not use any active profiles.;protected String[] activeProfiles() {_        return null__    };which,active,profiles,should,be,used,p,b,important,b,when,using,active,profiles,then,the,code,in,link,create,application,context,should,create,the,spring,link,org,springframework,context,support,abstract,application,context,without,refreshing,for,example,creating,an,link,org,springframework,context,support,class,path,xml,application,context,you,would,need,to,pass,in,tt,false,tt,in,the,refresh,parameter,in,the,constructor,camel,will,thrown,an,link,illegal,state,exception,if,this,is,not,correct,stating,this,problem,the,reason,is,that,we,cannot,active,profiles,b,after,b,a,spring,application,context,has,already,been,refreshed,and,is,active,return,an,array,of,active,profiles,to,use,use,tt,null,tt,to,not,use,any,active,profiles;protected,string,active,profiles,return,null
CamelSpringTestSupport -> protected String[] activeProfiles();1524063209;Which active profiles should be used._<p/>_<b>Important:</b> When using active profiles, then the code in {@link #createApplicationContext()} should create_the Spring {@link org.springframework.context.support.AbstractApplicationContext} without refreshing. For example creating an_{@link org.springframework.context.support.ClassPathXmlApplicationContext} you would need to pass in_<tt>false</tt> in the refresh parameter, in the constructor._Camel will thrown an {@link IllegalStateException} if this is not correct stating this problem._The reason is that we cannot active profiles <b>after</b> a Spring application context has already_been refreshed, and is active.__@return an array of active profiles to use, use <tt>null</tt> to not use any active profiles.;protected String[] activeProfiles() {_        return null__    };which,active,profiles,should,be,used,p,b,important,b,when,using,active,profiles,then,the,code,in,link,create,application,context,should,create,the,spring,link,org,springframework,context,support,abstract,application,context,without,refreshing,for,example,creating,an,link,org,springframework,context,support,class,path,xml,application,context,you,would,need,to,pass,in,tt,false,tt,in,the,refresh,parameter,in,the,constructor,camel,will,thrown,an,link,illegal,state,exception,if,this,is,not,correct,stating,this,problem,the,reason,is,that,we,cannot,active,profiles,b,after,b,a,spring,application,context,has,already,been,refreshed,and,is,active,return,an,array,of,active,profiles,to,use,use,tt,null,tt,to,not,use,any,active,profiles;protected,string,active,profiles,return,null
CamelSpringTestSupport -> protected String[] activeProfiles();1528210046;Which active profiles should be used._<p/>_<b>Important:</b> When using active profiles, then the code in {@link #createApplicationContext()} should create_the Spring {@link org.springframework.context.support.AbstractApplicationContext} without refreshing. For example creating an_{@link org.springframework.context.support.ClassPathXmlApplicationContext} you would need to pass in_<tt>false</tt> in the refresh parameter, in the constructor._Camel will thrown an {@link IllegalStateException} if this is not correct stating this problem._The reason is that we cannot active profiles <b>after</b> a Spring application context has already_been refreshed, and is active.__@return an array of active profiles to use, use <tt>null</tt> to not use any active profiles.;protected String[] activeProfiles() {_        return null__    };which,active,profiles,should,be,used,p,b,important,b,when,using,active,profiles,then,the,code,in,link,create,application,context,should,create,the,spring,link,org,springframework,context,support,abstract,application,context,without,refreshing,for,example,creating,an,link,org,springframework,context,support,class,path,xml,application,context,you,would,need,to,pass,in,tt,false,tt,in,the,refresh,parameter,in,the,constructor,camel,will,thrown,an,link,illegal,state,exception,if,this,is,not,correct,stating,this,problem,the,reason,is,that,we,cannot,active,profiles,b,after,b,a,spring,application,context,has,already,been,refreshed,and,is,active,return,an,array,of,active,profiles,to,use,use,tt,null,tt,to,not,use,any,active,profiles;protected,string,active,profiles,return,null
CamelSpringTestSupport -> public <T> T getMandatoryBean(Class<T> type, String name);1357639877;Looks up the mandatory spring bean of the given name and type, failing if_it is not present or the correct type;public <T> T getMandatoryBean(Class<T> type, String name) {_        Object value = applicationContext.getBean(name)__        assertNotNull("No spring bean found for name <" + name + ">", value)__        if (type.isInstance(value)) {_            return type.cast(value)__        } else {_            fail("Spring bean <" + name + "> is not an instanceof " + type.getName() + " but is of type " + ObjectHelper.className(value))__            return null__        }_    };looks,up,the,mandatory,spring,bean,of,the,given,name,and,type,failing,if,it,is,not,present,or,the,correct,type;public,t,t,get,mandatory,bean,class,t,type,string,name,object,value,application,context,get,bean,name,assert,not,null,no,spring,bean,found,for,name,name,value,if,type,is,instance,value,return,type,cast,value,else,fail,spring,bean,name,is,not,an,instanceof,type,get,name,but,is,of,type,object,helper,class,name,value,return,null
CamelSpringTestSupport -> public <T> T getMandatoryBean(Class<T> type, String name);1392400400;Looks up the mandatory spring bean of the given name and type, failing if_it is not present or the correct type;public <T> T getMandatoryBean(Class<T> type, String name) {_        Object value = applicationContext.getBean(name)__        assertNotNull("No spring bean found for name <" + name + ">", value)__        if (type.isInstance(value)) {_            return type.cast(value)__        } else {_            fail("Spring bean <" + name + "> is not an instanceof " + type.getName() + " but is of type " + ObjectHelper.className(value))__            return null__        }_    };looks,up,the,mandatory,spring,bean,of,the,given,name,and,type,failing,if,it,is,not,present,or,the,correct,type;public,t,t,get,mandatory,bean,class,t,type,string,name,object,value,application,context,get,bean,name,assert,not,null,no,spring,bean,found,for,name,name,value,if,type,is,instance,value,return,type,cast,value,else,fail,spring,bean,name,is,not,an,instanceof,type,get,name,but,is,of,type,object,helper,class,name,value,return,null
CamelSpringTestSupport -> public <T> T getMandatoryBean(Class<T> type, String name);1521646309;Looks up the mandatory spring bean of the given name and type, failing if_it is not present or the correct type;public <T> T getMandatoryBean(Class<T> type, String name) {_        Object value = applicationContext.getBean(name)__        assertNotNull("No spring bean found for name <" + name + ">", value)__        if (type.isInstance(value)) {_            return type.cast(value)__        } else {_            fail("Spring bean <" + name + "> is not an instanceof " + type.getName() + " but is of type " + ObjectHelper.className(value))__            return null__        }_    };looks,up,the,mandatory,spring,bean,of,the,given,name,and,type,failing,if,it,is,not,present,or,the,correct,type;public,t,t,get,mandatory,bean,class,t,type,string,name,object,value,application,context,get,bean,name,assert,not,null,no,spring,bean,found,for,name,name,value,if,type,is,instance,value,return,type,cast,value,else,fail,spring,bean,name,is,not,an,instanceof,type,get,name,but,is,of,type,object,helper,class,name,value,return,null
CamelSpringTestSupport -> public <T> T getMandatoryBean(Class<T> type, String name);1524063209;Looks up the mandatory spring bean of the given name and type, failing if_it is not present or the correct type;public <T> T getMandatoryBean(Class<T> type, String name) {_        Object value = applicationContext.getBean(name)__        assertNotNull("No spring bean found for name <" + name + ">", value)__        if (type.isInstance(value)) {_            return type.cast(value)__        } else {_            fail("Spring bean <" + name + "> is not an instanceof " + type.getName() + " but is of type " + ObjectHelper.className(value))__            return null__        }_    };looks,up,the,mandatory,spring,bean,of,the,given,name,and,type,failing,if,it,is,not,present,or,the,correct,type;public,t,t,get,mandatory,bean,class,t,type,string,name,object,value,application,context,get,bean,name,assert,not,null,no,spring,bean,found,for,name,name,value,if,type,is,instance,value,return,type,cast,value,else,fail,spring,bean,name,is,not,an,instanceof,type,get,name,but,is,of,type,object,helper,class,name,value,return,null
CamelSpringTestSupport -> public <T> T getMandatoryBean(Class<T> type, String name);1528210046;Looks up the mandatory spring bean of the given name and type, failing if_it is not present or the correct type;public <T> T getMandatoryBean(Class<T> type, String name) {_        Object value = applicationContext.getBean(name)__        assertNotNull("No spring bean found for name <" + name + ">", value)__        if (type.isInstance(value)) {_            return type.cast(value)__        } else {_            fail("Spring bean <" + name + "> is not an instanceof " + type.getName() + " but is of type " + ObjectHelper.className(value))__            return null__        }_    };looks,up,the,mandatory,spring,bean,of,the,given,name,and,type,failing,if,it,is,not,present,or,the,correct,type;public,t,t,get,mandatory,bean,class,t,type,string,name,object,value,application,context,get,bean,name,assert,not,null,no,spring,bean,found,for,name,name,value,if,type,is,instance,value,return,type,cast,value,else,fail,spring,bean,name,is,not,an,instanceof,type,get,name,but,is,of,type,object,helper,class,name,value,return,null
CamelSpringTestSupport -> @Override     public void postProcessTest() throws Exception;1357639877;Lets post process this test instance to process any Camel annotations._Note that using Spring Test or Guice is a more powerful approach.;@Override_    public void postProcessTest() throws Exception {_        super.postProcessTest()__        if (isCreateCamelContextPerClass()) {_            applicationContext = threadAppContext.get()__        }__        _        CamelBeanPostProcessor processor = new CamelBeanPostProcessor()__        processor.setApplicationContext(applicationContext)__        processor.setCamelContext(context)__        processor.postProcessBeforeInitialization(this, getClass().getName())__        processor.postProcessAfterInitialization(this, getClass().getName())__    };lets,post,process,this,test,instance,to,process,any,camel,annotations,note,that,using,spring,test,or,guice,is,a,more,powerful,approach;override,public,void,post,process,test,throws,exception,super,post,process,test,if,is,create,camel,context,per,class,application,context,thread,app,context,get,camel,bean,post,processor,processor,new,camel,bean,post,processor,processor,set,application,context,application,context,processor,set,camel,context,context,processor,post,process,before,initialization,this,get,class,get,name,processor,post,process,after,initialization,this,get,class,get,name
CamelSpringTestSupport -> @Override     public void postProcessTest() throws Exception;1392400400;Lets post process this test instance to process any Camel annotations._Note that using Spring Test or Guice is a more powerful approach.;@Override_    public void postProcessTest() throws Exception {_        super.postProcessTest()__        if (isCreateCamelContextPerClass()) {_            applicationContext = threadAppContext.get()__        }__        _        CamelBeanPostProcessor processor = new CamelBeanPostProcessor()__        processor.setApplicationContext(applicationContext)__        processor.setCamelContext(context)__        processor.postProcessBeforeInitialization(this, getClass().getName())__        processor.postProcessAfterInitialization(this, getClass().getName())__    };lets,post,process,this,test,instance,to,process,any,camel,annotations,note,that,using,spring,test,or,guice,is,a,more,powerful,approach;override,public,void,post,process,test,throws,exception,super,post,process,test,if,is,create,camel,context,per,class,application,context,thread,app,context,get,camel,bean,post,processor,processor,new,camel,bean,post,processor,processor,set,application,context,application,context,processor,set,camel,context,context,processor,post,process,before,initialization,this,get,class,get,name,processor,post,process,after,initialization,this,get,class,get,name
CamelSpringTestSupport -> @Override     public void postProcessTest() throws Exception;1521646309;Lets post process this test instance to process any Camel annotations._Note that using Spring Test or Guice is a more powerful approach.;@Override_    public void postProcessTest() throws Exception {_        super.postProcessTest()__        if (isCreateCamelContextPerClass()) {_            applicationContext = threadAppContext.get()__        }__        _        CamelBeanPostProcessor processor = new CamelBeanPostProcessor()__        processor.setApplicationContext(applicationContext)__        processor.setCamelContext(context)__        processor.postProcessBeforeInitialization(this, getClass().getName())__        processor.postProcessAfterInitialization(this, getClass().getName())__    };lets,post,process,this,test,instance,to,process,any,camel,annotations,note,that,using,spring,test,or,guice,is,a,more,powerful,approach;override,public,void,post,process,test,throws,exception,super,post,process,test,if,is,create,camel,context,per,class,application,context,thread,app,context,get,camel,bean,post,processor,processor,new,camel,bean,post,processor,processor,set,application,context,application,context,processor,set,camel,context,context,processor,post,process,before,initialization,this,get,class,get,name,processor,post,process,after,initialization,this,get,class,get,name
CamelSpringTestSupport -> @Override     public void postProcessTest() throws Exception;1524063209;Lets post process this test instance to process any Camel annotations._Note that using Spring Test or Guice is a more powerful approach.;@Override_    public void postProcessTest() throws Exception {_        super.postProcessTest()__        if (isCreateCamelContextPerClass()) {_            applicationContext = threadAppContext.get()__        }__        _        CamelBeanPostProcessor processor = new CamelBeanPostProcessor()__        processor.setApplicationContext(applicationContext)__        processor.setCamelContext(context)__        processor.postProcessBeforeInitialization(this, getClass().getName())__        processor.postProcessAfterInitialization(this, getClass().getName())__    };lets,post,process,this,test,instance,to,process,any,camel,annotations,note,that,using,spring,test,or,guice,is,a,more,powerful,approach;override,public,void,post,process,test,throws,exception,super,post,process,test,if,is,create,camel,context,per,class,application,context,thread,app,context,get,camel,bean,post,processor,processor,new,camel,bean,post,processor,processor,set,application,context,application,context,processor,set,camel,context,context,processor,post,process,before,initialization,this,get,class,get,name,processor,post,process,after,initialization,this,get,class,get,name
CamelSpringTestSupport -> @Override     public void postProcessTest() throws Exception;1528210046;Lets post process this test instance to process any Camel annotations._Note that using Spring Test or Guice is a more powerful approach.;@Override_    public void postProcessTest() throws Exception {_        super.postProcessTest()__        if (isCreateCamelContextPerClass()) {_            applicationContext = threadAppContext.get()__        }__        _        CamelBeanPostProcessor processor = new CamelBeanPostProcessor()__        processor.setApplicationContext(applicationContext)__        processor.setCamelContext(context)__        processor.postProcessBeforeInitialization(this, getClass().getName())__        processor.postProcessAfterInitialization(this, getClass().getName())__    };lets,post,process,this,test,instance,to,process,any,camel,annotations,note,that,using,spring,test,or,guice,is,a,more,powerful,approach;override,public,void,post,process,test,throws,exception,super,post,process,test,if,is,create,camel,context,per,class,application,context,thread,app,context,get,camel,bean,post,processor,processor,new,camel,bean,post,processor,processor,set,application,context,application,context,processor,set,camel,context,context,processor,post,process,before,initialization,this,get,class,get,name,processor,post,process,after,initialization,this,get,class,get,name
CamelSpringTestSupport -> protected ApplicationContext getRouteExcludingApplicationContext();1357639877;Create a parent context that initializes a_{@link org.apache.camel.spi.PackageScanClassResolver} to exclude a set of given classes from_being resolved. Typically this is used at test time to exclude certain routes,_which might otherwise be just noisy, from being discovered and initialized._<p/>_To use this filtering mechanism it is necessary to provide the_{@link org.springframework.context.ApplicationContext} returned from here as the parent context to_your test context e.g.__<pre>_protected AbstractXmlApplicationContext createApplicationContext() {_return new ClassPathXmlApplicationContext(new String[] {&quot_test-context.xml&quot_}, getRouteExcludingApplicationContext())___</pre>__This will, in turn, call the template methods <code>excludedRoutes</code>_and <code>excludedRoute</code> to determine the classes to be excluded from scanning.__@return ApplicationContext a parent {@link org.springframework.context.ApplicationContext} configured_to exclude certain classes from package scanning;protected ApplicationContext getRouteExcludingApplicationContext() {_        GenericApplicationContext routeExcludingContext = new GenericApplicationContext()__        routeExcludingContext.registerBeanDefinition("excludingResolver", new RootBeanDefinition(ExcludingPackageScanClassResolver.class))__        routeExcludingContext.refresh()___        ExcludingPackageScanClassResolver excludingResolver = routeExcludingContext.getBean("excludingResolver", ExcludingPackageScanClassResolver.class)__        List<Class<?>> excluded = Arrays.asList(excludeRoutes())__        excludingResolver.setExcludedClasses(new HashSet<Class<?>>(excluded))___        return routeExcludingContext__    };create,a,parent,context,that,initializes,a,link,org,apache,camel,spi,package,scan,class,resolver,to,exclude,a,set,of,given,classes,from,being,resolved,typically,this,is,used,at,test,time,to,exclude,certain,routes,which,might,otherwise,be,just,noisy,from,being,discovered,and,initialized,p,to,use,this,filtering,mechanism,it,is,necessary,to,provide,the,link,org,springframework,context,application,context,returned,from,here,as,the,parent,context,to,your,test,context,e,g,pre,protected,abstract,xml,application,context,create,application,context,return,new,class,path,xml,application,context,new,string,quot,test,context,xml,quot,get,route,excluding,application,context,pre,this,will,in,turn,call,the,template,methods,code,excluded,routes,code,and,code,excluded,route,code,to,determine,the,classes,to,be,excluded,from,scanning,return,application,context,a,parent,link,org,springframework,context,application,context,configured,to,exclude,certain,classes,from,package,scanning;protected,application,context,get,route,excluding,application,context,generic,application,context,route,excluding,context,new,generic,application,context,route,excluding,context,register,bean,definition,excluding,resolver,new,root,bean,definition,excluding,package,scan,class,resolver,class,route,excluding,context,refresh,excluding,package,scan,class,resolver,excluding,resolver,route,excluding,context,get,bean,excluding,resolver,excluding,package,scan,class,resolver,class,list,class,excluded,arrays,as,list,exclude,routes,excluding,resolver,set,excluded,classes,new,hash,set,class,excluded,return,route,excluding,context
CamelSpringTestSupport -> protected ApplicationContext getRouteExcludingApplicationContext();1392400400;Create a parent context that initializes a_{@link org.apache.camel.spi.PackageScanClassResolver} to exclude a set of given classes from_being resolved. Typically this is used at test time to exclude certain routes,_which might otherwise be just noisy, from being discovered and initialized._<p/>_To use this filtering mechanism it is necessary to provide the_{@link org.springframework.context.ApplicationContext} returned from here as the parent context to_your test context e.g.__<pre>_protected AbstractXmlApplicationContext createApplicationContext() {_return new ClassPathXmlApplicationContext(new String[] {&quot_test-context.xml&quot_}, getRouteExcludingApplicationContext())___</pre>__This will, in turn, call the template methods <code>excludedRoutes</code>_and <code>excludedRoute</code> to determine the classes to be excluded from scanning.__@return ApplicationContext a parent {@link org.springframework.context.ApplicationContext} configured_to exclude certain classes from package scanning;protected ApplicationContext getRouteExcludingApplicationContext() {_        GenericApplicationContext routeExcludingContext = new GenericApplicationContext()__        routeExcludingContext.registerBeanDefinition("excludingResolver", new RootBeanDefinition(ExcludingPackageScanClassResolver.class))__        routeExcludingContext.refresh()___        ExcludingPackageScanClassResolver excludingResolver = routeExcludingContext.getBean("excludingResolver", ExcludingPackageScanClassResolver.class)__        List<Class<?>> excluded = Arrays.asList(excludeRoutes())__        excludingResolver.setExcludedClasses(new HashSet<Class<?>>(excluded))___        return routeExcludingContext__    };create,a,parent,context,that,initializes,a,link,org,apache,camel,spi,package,scan,class,resolver,to,exclude,a,set,of,given,classes,from,being,resolved,typically,this,is,used,at,test,time,to,exclude,certain,routes,which,might,otherwise,be,just,noisy,from,being,discovered,and,initialized,p,to,use,this,filtering,mechanism,it,is,necessary,to,provide,the,link,org,springframework,context,application,context,returned,from,here,as,the,parent,context,to,your,test,context,e,g,pre,protected,abstract,xml,application,context,create,application,context,return,new,class,path,xml,application,context,new,string,quot,test,context,xml,quot,get,route,excluding,application,context,pre,this,will,in,turn,call,the,template,methods,code,excluded,routes,code,and,code,excluded,route,code,to,determine,the,classes,to,be,excluded,from,scanning,return,application,context,a,parent,link,org,springframework,context,application,context,configured,to,exclude,certain,classes,from,package,scanning;protected,application,context,get,route,excluding,application,context,generic,application,context,route,excluding,context,new,generic,application,context,route,excluding,context,register,bean,definition,excluding,resolver,new,root,bean,definition,excluding,package,scan,class,resolver,class,route,excluding,context,refresh,excluding,package,scan,class,resolver,excluding,resolver,route,excluding,context,get,bean,excluding,resolver,excluding,package,scan,class,resolver,class,list,class,excluded,arrays,as,list,exclude,routes,excluding,resolver,set,excluded,classes,new,hash,set,class,excluded,return,route,excluding,context
CamelSpringTestSupport -> protected ApplicationContext getRouteExcludingApplicationContext();1521646309;Create a parent context that initializes a_{@link org.apache.camel.spi.PackageScanClassResolver} to exclude a set of given classes from_being resolved. Typically this is used at test time to exclude certain routes,_which might otherwise be just noisy, from being discovered and initialized._<p/>_To use this filtering mechanism it is necessary to provide the_{@link org.springframework.context.ApplicationContext} returned from here as the parent context to_your test context e.g.__<pre>_protected AbstractXmlApplicationContext createApplicationContext() {_return new ClassPathXmlApplicationContext(new String[] {&quot_test-context.xml&quot_}, getRouteExcludingApplicationContext())___</pre>__This will, in turn, call the template methods <code>excludedRoutes</code>_and <code>excludedRoute</code> to determine the classes to be excluded from scanning.__@return ApplicationContext a parent {@link org.springframework.context.ApplicationContext} configured_to exclude certain classes from package scanning;protected ApplicationContext getRouteExcludingApplicationContext() {_        GenericApplicationContext routeExcludingContext = new GenericApplicationContext()__        routeExcludingContext.registerBeanDefinition("excludingResolver", new RootBeanDefinition(ExcludingPackageScanClassResolver.class))__        routeExcludingContext.refresh()___        ExcludingPackageScanClassResolver excludingResolver = routeExcludingContext.getBean("excludingResolver", ExcludingPackageScanClassResolver.class)__        List<Class<?>> excluded = Arrays.asList(excludeRoutes())__        excludingResolver.setExcludedClasses(new HashSet<Class<?>>(excluded))___        return routeExcludingContext__    };create,a,parent,context,that,initializes,a,link,org,apache,camel,spi,package,scan,class,resolver,to,exclude,a,set,of,given,classes,from,being,resolved,typically,this,is,used,at,test,time,to,exclude,certain,routes,which,might,otherwise,be,just,noisy,from,being,discovered,and,initialized,p,to,use,this,filtering,mechanism,it,is,necessary,to,provide,the,link,org,springframework,context,application,context,returned,from,here,as,the,parent,context,to,your,test,context,e,g,pre,protected,abstract,xml,application,context,create,application,context,return,new,class,path,xml,application,context,new,string,quot,test,context,xml,quot,get,route,excluding,application,context,pre,this,will,in,turn,call,the,template,methods,code,excluded,routes,code,and,code,excluded,route,code,to,determine,the,classes,to,be,excluded,from,scanning,return,application,context,a,parent,link,org,springframework,context,application,context,configured,to,exclude,certain,classes,from,package,scanning;protected,application,context,get,route,excluding,application,context,generic,application,context,route,excluding,context,new,generic,application,context,route,excluding,context,register,bean,definition,excluding,resolver,new,root,bean,definition,excluding,package,scan,class,resolver,class,route,excluding,context,refresh,excluding,package,scan,class,resolver,excluding,resolver,route,excluding,context,get,bean,excluding,resolver,excluding,package,scan,class,resolver,class,list,class,excluded,arrays,as,list,exclude,routes,excluding,resolver,set,excluded,classes,new,hash,set,class,excluded,return,route,excluding,context
CamelSpringTestSupport -> protected ApplicationContext getRouteExcludingApplicationContext();1524063209;Create a parent context that initializes a_{@link org.apache.camel.spi.PackageScanClassResolver} to exclude a set of given classes from_being resolved. Typically this is used at test time to exclude certain routes,_which might otherwise be just noisy, from being discovered and initialized._<p/>_To use this filtering mechanism it is necessary to provide the_{@link org.springframework.context.ApplicationContext} returned from here as the parent context to_your test context e.g.__<pre>_protected AbstractXmlApplicationContext createApplicationContext() {_return new ClassPathXmlApplicationContext(new String[] {&quot_test-context.xml&quot_}, getRouteExcludingApplicationContext())___</pre>__This will, in turn, call the template methods <code>excludedRoutes</code>_and <code>excludedRoute</code> to determine the classes to be excluded from scanning.__@return ApplicationContext a parent {@link org.springframework.context.ApplicationContext} configured_to exclude certain classes from package scanning;protected ApplicationContext getRouteExcludingApplicationContext() {_        GenericApplicationContext routeExcludingContext = new GenericApplicationContext()__        routeExcludingContext.registerBeanDefinition("excludingResolver", new RootBeanDefinition(ExcludingPackageScanClassResolver.class))__        routeExcludingContext.refresh()___        ExcludingPackageScanClassResolver excludingResolver = routeExcludingContext.getBean("excludingResolver", ExcludingPackageScanClassResolver.class)__        List<Class<?>> excluded = Arrays.asList(excludeRoutes())__        excludingResolver.setExcludedClasses(new HashSet<>(excluded))___        return routeExcludingContext__    };create,a,parent,context,that,initializes,a,link,org,apache,camel,spi,package,scan,class,resolver,to,exclude,a,set,of,given,classes,from,being,resolved,typically,this,is,used,at,test,time,to,exclude,certain,routes,which,might,otherwise,be,just,noisy,from,being,discovered,and,initialized,p,to,use,this,filtering,mechanism,it,is,necessary,to,provide,the,link,org,springframework,context,application,context,returned,from,here,as,the,parent,context,to,your,test,context,e,g,pre,protected,abstract,xml,application,context,create,application,context,return,new,class,path,xml,application,context,new,string,quot,test,context,xml,quot,get,route,excluding,application,context,pre,this,will,in,turn,call,the,template,methods,code,excluded,routes,code,and,code,excluded,route,code,to,determine,the,classes,to,be,excluded,from,scanning,return,application,context,a,parent,link,org,springframework,context,application,context,configured,to,exclude,certain,classes,from,package,scanning;protected,application,context,get,route,excluding,application,context,generic,application,context,route,excluding,context,new,generic,application,context,route,excluding,context,register,bean,definition,excluding,resolver,new,root,bean,definition,excluding,package,scan,class,resolver,class,route,excluding,context,refresh,excluding,package,scan,class,resolver,excluding,resolver,route,excluding,context,get,bean,excluding,resolver,excluding,package,scan,class,resolver,class,list,class,excluded,arrays,as,list,exclude,routes,excluding,resolver,set,excluded,classes,new,hash,set,excluded,return,route,excluding,context
CamelSpringTestSupport -> protected ApplicationContext getRouteExcludingApplicationContext();1528210046;Create a parent context that initializes a_{@link org.apache.camel.spi.PackageScanClassResolver} to exclude a set of given classes from_being resolved. Typically this is used at test time to exclude certain routes,_which might otherwise be just noisy, from being discovered and initialized._<p/>_To use this filtering mechanism it is necessary to provide the_{@link org.springframework.context.ApplicationContext} returned from here as the parent context to_your test context e.g.__<pre>_protected AbstractXmlApplicationContext createApplicationContext() {_return new ClassPathXmlApplicationContext(new String[] {&quot_test-context.xml&quot_}, getRouteExcludingApplicationContext())___</pre>__This will, in turn, call the template methods <code>excludedRoutes</code>_and <code>excludedRoute</code> to determine the classes to be excluded from scanning.__@return ApplicationContext a parent {@link org.springframework.context.ApplicationContext} configured_to exclude certain classes from package scanning;protected ApplicationContext getRouteExcludingApplicationContext() {_        GenericApplicationContext routeExcludingContext = new GenericApplicationContext()__        routeExcludingContext.registerBeanDefinition("excludingResolver", new RootBeanDefinition(ExcludingPackageScanClassResolver.class))__        routeExcludingContext.refresh()___        ExcludingPackageScanClassResolver excludingResolver = routeExcludingContext.getBean("excludingResolver", ExcludingPackageScanClassResolver.class)__        List<Class<?>> excluded = Arrays.asList(excludeRoutes())__        excludingResolver.setExcludedClasses(new HashSet<>(excluded))___        return routeExcludingContext__    };create,a,parent,context,that,initializes,a,link,org,apache,camel,spi,package,scan,class,resolver,to,exclude,a,set,of,given,classes,from,being,resolved,typically,this,is,used,at,test,time,to,exclude,certain,routes,which,might,otherwise,be,just,noisy,from,being,discovered,and,initialized,p,to,use,this,filtering,mechanism,it,is,necessary,to,provide,the,link,org,springframework,context,application,context,returned,from,here,as,the,parent,context,to,your,test,context,e,g,pre,protected,abstract,xml,application,context,create,application,context,return,new,class,path,xml,application,context,new,string,quot,test,context,xml,quot,get,route,excluding,application,context,pre,this,will,in,turn,call,the,template,methods,code,excluded,routes,code,and,code,excluded,route,code,to,determine,the,classes,to,be,excluded,from,scanning,return,application,context,a,parent,link,org,springframework,context,application,context,configured,to,exclude,certain,classes,from,package,scanning;protected,application,context,get,route,excluding,application,context,generic,application,context,route,excluding,context,new,generic,application,context,route,excluding,context,register,bean,definition,excluding,resolver,new,root,bean,definition,excluding,package,scan,class,resolver,class,route,excluding,context,refresh,excluding,package,scan,class,resolver,excluding,resolver,route,excluding,context,get,bean,excluding,resolver,excluding,package,scan,class,resolver,class,list,class,excluded,arrays,as,list,exclude,routes,excluding,resolver,set,excluded,classes,new,hash,set,excluded,return,route,excluding,context
