commented;modifiers;parameterAmount;loc;comment;code
false;public;4;7;;public void init(Exchange exchange, JettyHttpBinding jettyBinding, final HttpClient client, AsyncCallback callback) {     this.exchange = exchange.     this.jettyBinding = jettyBinding.     this.client = client.     this.callback = callback. }
false;protected;0;4;;protected void onRequestComplete() {     LOG.trace("onRequestComplete").     closeRequestContentSource(). }
false;protected;2;17;;protected void onResponseComplete(Result result, byte[] content) {     LOG.trace("onResponseComplete").     done.countDown().     this.response = result.getResponse().     this.responseContent = content.     if (callback == null) {         // this is only for the async callback         return.     }     try {         jettyBinding.populateResponse(exchange, this).     } catch (Exception e) {         exchange.setException(e).     } finally {         callback.done(false).     } }
false;protected;0;7;;protected void onExpire() {     LOG.trace("onExpire").     // need to close the request input stream     closeRequestContentSource().     doTaskCompleted(new ExchangeTimedOutException(exchange, client.getConnectTimeout())). }
false;protected;1;7;;protected void onException(Throwable ex) {     LOG.trace("onException {}", ex).     // need to close the request input stream     closeRequestContentSource().     doTaskCompleted(ex). }
false;protected;1;7;;protected void onConnectionFailed(Throwable ex) {     LOG.trace("onConnectionFailed {}", ex).     // need to close the request input stream     closeRequestContentSource().     doTaskCompleted(ex). }
false;public;0;4;;public byte[] getBody() {     // must return the content as raw bytes     return getResponseContentBytes(). }
false;public;0;7;;public String getUrl() {     try {         return this.request.getURI().toURL().toExternalForm().     } catch (MalformedURLException e) {         throw new IllegalStateException(e.getMessage(), e).     } }
false;protected;0;3;;protected void closeRequestContentSource() {     tryClose(this.request.getContent()). }
false;private;1;9;;private void tryClose(Object obj) {     if (obj instanceof Closeable) {         try {             ((Closeable) obj).close().         } catch (IOException e) {         // Ignore         }     } }
false;protected;1;13;;protected void doTaskCompleted(Throwable ex) {     if (ex instanceof TimeoutException) {         exchange.setException(new ExchangeTimedOutException(exchange, request.getTimeout())).     } else {         exchange.setException(new CamelExchangeException("JettyClient failed cause by: " + ex.getMessage(), exchange, ex)).     }     done.countDown().     if (callback != null) {         // now invoke callback to indicate we are done async         callback.done(false).     } }
false;public;1;3;;public void setRequestContentType(String contentType) {     this.requestContentType = contentType. }
false;public;0;3;;public int getResponseStatus() {     return this.response.getStatus(). }
false;public;1;3;;public void setMethod(String method) {     this.request.method(method). }
false;public;1;3;;public void setTimeout(long timeout) {     this.request.timeout(timeout, TimeUnit.MILLISECONDS). }
false;public;1;3;;public void setURL(String url) {     this.request = client.newRequest(url). }
false;public;1;3;;public void setRequestContent(byte[] byteArray) {     this.request.content(new BytesContentProvider(byteArray), this.requestContentType). }
false;public;2;4;;public void setRequestContent(String data, String charset) throws UnsupportedEncodingException {     StringContentProvider cp = charset != null ? new StringContentProvider(data, charset) : new StringContentProvider(data).     this.request.content(cp, this.requestContentType). }
false;public;1;3;;public void setRequestContent(InputStream ins) {     this.request.content(new InputStreamContentProvider(ins), this.requestContentType). }
false;public;2;3;;public void setRequestContent(InputStream ins, int contentLength) {     this.request.content(new CamelInputStreamContentProvider(ins, contentLength), this.requestContentType). }
false;public;2;3;;public void addRequestHeader(String key, String s) {     this.request.header(key, s). }
false;public;1;4;;@Override public void onSuccess(Request request) {     onRequestComplete(). }
false;public;2;4;;@Override public void onFailure(Request request, Throwable failure) {     onConnectionFailed(failure). }
false;public;3;11;;@Override public void onContent(Response response, ByteBuffer content, Callback callback) {     byte[] buffer = new byte[content.limit()].     content.get(buffer).     try {         osb.write(buffer).         callback.succeeded().     } catch (IOException e) {         callback.failed(e).     } }
false;public;1;20;;@Override public void onComplete(Result result) {     if (result.isFailed()) {         doTaskCompleted(result.getFailure()).     } else {         try {             Object content = osb.build().             if (content instanceof byte[]) {                 onResponseComplete(result, (byte[]) content).             } else {                 StreamCache cos = (StreamCache) content.                 ByteArrayOutputStream baos = new ByteArrayOutputStream().                 cos.writeTo(baos).                 onResponseComplete(result, baos.toByteArray()).             }         } catch (IOException e) {             doTaskCompleted(e).         }     } }
false;public;1;53;;public void send(HttpClient client) throws IOException {     org.eclipse.jetty.client.api.Request.Listener listener = new Request.Listener.Adapter() {          @Override         public void onSuccess(Request request) {             onRequestComplete().         }          @Override         public void onFailure(Request request, Throwable failure) {             onConnectionFailed(failure).         }     }.     InputStreamResponseListener responseListener = new InputStreamResponseListener() {          OutputStreamBuilder osb = OutputStreamBuilder.withExchange(exchange).          @Override         public void onContent(Response response, ByteBuffer content, Callback callback) {             byte[] buffer = new byte[content.limit()].             content.get(buffer).             try {                 osb.write(buffer).                 callback.succeeded().             } catch (IOException e) {                 callback.failed(e).             }         }          @Override         public void onComplete(Result result) {             if (result.isFailed()) {                 doTaskCompleted(result.getFailure()).             } else {                 try {                     Object content = osb.build().                     if (content instanceof byte[]) {                         onResponseComplete(result, (byte[]) content).                     } else {                         StreamCache cos = (StreamCache) content.                         ByteArrayOutputStream baos = new ByteArrayOutputStream().                         cos.writeTo(baos).                         onResponseComplete(result, baos.toByteArray()).                     }                 } catch (IOException e) {                     doTaskCompleted(e).                 }             }         }     }.     request.followRedirects(supportRedirect).listener(listener).send(responseListener). }
false;protected;1;3;;protected void setResponse(Response response) {     this.response = response. }
false;public;0;3;;public byte[] getResponseContentBytes() {     return responseContent. }
false;private;1;7;;private Map<String, Collection<String>> getFieldsAsMap(HttpFields fields) {     final Map<String, Collection<String>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER).     for (String name : getFieldNamesCollection(fields)) {         result.put(name, fields.getValuesList(name)).     }     return result. }
false;private;1;17;;@SuppressWarnings("unchecked") private Collection<String> getFieldNamesCollection(HttpFields fields) {     try {         return fields.getFieldNamesCollection().     } catch (NoSuchMethodError e) {         try {             // In newer versions of Jetty the return type has been changed to Set.             // This causes problems at byte-code level. Try recovering.             Method reflGetFieldNamesCollection = HttpFields.class.getMethod("getFieldNamesCollection").             Object result = reflGetFieldNamesCollection.invoke(fields).             return (Collection<String>) result.         } catch (Exception reflectionException) {             // Suppress, throwing the original exception             throw e.         }     } }
false;public;0;3;;public Map<String, Collection<String>> getRequestHeaders() {     return getFieldsAsMap(request.getHeaders()). }
false;public;0;3;;public Map<String, Collection<String>> getResponseHeaders() {     return getFieldsAsMap(response.getHeaders()). }
false;public;1;4;;@Override public void setSupportRedirect(boolean supportRedirect) {     this.supportRedirect = supportRedirect. }
