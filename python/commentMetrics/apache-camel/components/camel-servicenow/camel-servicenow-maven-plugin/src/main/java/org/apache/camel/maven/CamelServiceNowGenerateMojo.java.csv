commented;modifiers;parameterAmount;loc;comment;code
false;public;0;33;;// ************************************ //  // ************************************ @Override public void execute() throws MojoExecutionException, MojoFailureException {     final DefaultCamelContext context = new DefaultCamelContext().     final ServiceNowComponent component = new ServiceNowComponent(context).     for (String objectName : objects) {         Map<String, Object> parameters = new HashMap<>().         parameters.put("instanceName", instanceName).         parameters.put("userName", userName).         parameters.put("password", userPassword).         parameters.put("oauthClientId", oauthClientId).         parameters.put("oauthClientSecret", oauthClientSecret).         parameters.put("objectType", "table").         parameters.put("objectName", objectName).         for (Map.Entry<String, String> entry : fields.entrySet()) {             parameters.put("object." + entry.getKey() + ".fields", entry.getValue()).         }         for (Map.Entry<String, String> entry : fieldsExcludePattern.entrySet()) {             parameters.put("object." + entry.getKey() + ".fields.exclude.pattern", entry.getValue()).         }         JsonNode schema = component.getExtension(MetaDataExtension.class).flatMap(e -> e.meta(parameters)).flatMap(m -> Optional.ofNullable(m.getPayload(JsonNode.class))).orElseThrow(() -> new MojoExecutionException("Unable to get grab MetaData for object: " + objectName)).         validateSchema(schema).         generateBean(objectName, schema).     } }
false;private;2;28;;// ************************************ // Beans // ************************************ private void generateBean(String name, JsonNode schema) throws MojoExecutionException {     try {         TypeSpec.Builder typeBuilder = TypeSpec.classBuilder(toCamelCase(name, false)).addModifiers(Modifier.PUBLIC, Modifier.FINAL).addAnnotation(Generated.class).addAnnotation(AnnotationSpec.builder(ServiceNowSysParm.class).addMember("name", "$S", "sysparm_exclude_reference_link").addMember("value", "$S", "true").build()).addAnnotation(AnnotationSpec.builder(JsonIgnoreProperties.class).addMember("ignoreUnknown", "$L", "true").build()).addAnnotation(AnnotationSpec.builder(JsonInclude.class).addMember("value", "$L", "JsonInclude.Include.NON_NULL").build()).         schema.get("properties").fields().forEachRemaining(entry -> generateBeanProperty(typeBuilder, schema, entry.getKey(), entry.getValue())).         JavaFile.builder(packageName, typeBuilder.build()).indent("    ").build().writeTo(outputDirectory).     } catch (IOException e) {         throw new MojoExecutionException("Unable to generate Class", e).     } }
false;private;4;61;;private void generateBeanProperty(TypeSpec.Builder typeBuilder, JsonNode schema, String name, JsonNode definition) {     final ArrayNode required = (ArrayNode) schema.get("required").     final String fieldName = toCamelCase(name, true).     final String methodName = toCamelCase(name, false).     final JsonNode type = definition.get("type").     final JsonNode format = definition.get("format").     Class<?> javaType = String.class.     if (type != null) {         if ("boolean".equalsIgnoreCase(type.textValue())) {             javaType = boolean.class.         }         if ("integer".equalsIgnoreCase(type.textValue())) {             javaType = Integer.class.         }         if ("number".equalsIgnoreCase(type.textValue())) {             javaType = Double.class.         }         if ("string".equalsIgnoreCase(type.textValue())) {             javaType = String.class.         }     }     if (javaType == String.class && format != null) {         if ("date".equalsIgnoreCase(format.textValue())) {             javaType = LocalDate.class.         }         if ("time".equalsIgnoreCase(format.textValue())) {             javaType = LocalTime.class.         }         if ("date-time".equalsIgnoreCase(format.textValue())) {             javaType = LocalDateTime.class.         }     }     FieldSpec field = FieldSpec.builder(javaType, toCamelCase(name, true)).addModifiers(Modifier.PRIVATE).addAnnotation(AnnotationSpec.builder(JsonProperty.class).addMember("value", "$S", name).addMember("required", "$L", required.has(name)).build()).build().     MethodSpec getter = MethodSpec.methodBuilder("get" + methodName).addModifiers(Modifier.PUBLIC).returns(javaType).addStatement("return this.$L", fieldName).build().     MethodSpec setter = MethodSpec.methodBuilder("set" + methodName).addModifiers(Modifier.PUBLIC).returns(void.class).addParameter(javaType, fieldName).addStatement("this.$L = $L", fieldName, fieldName).build().     typeBuilder.addField(field).     typeBuilder.addMethod(getter).     typeBuilder.addMethod(setter). }
false;private;2;11;;// ************************************ // Helpers // ************************************ private String toCamelCase(String text, boolean lowerCaseFirst) {     String result = Stream.of(text.split("[^a-zA-Z0-9]")).map(v -> v.substring(0, 1).toUpperCase() + v.substring(1).toLowerCase()).collect(Collectors.joining()).     if (lowerCaseFirst) {         result = result.substring(0, 1).toLowerCase() + result.substring(1).     }     return result. }
false;private;2;3;;private Optional<String> getNodeTextValue(JsonNode root, String... path) {     return getNode(root, path).map(JsonNode::asText). }
false;private;2;11;;private Optional<JsonNode> getNode(JsonNode root, String... path) {     JsonNode node = root.     for (String name : path) {         node = node.get(name).         if (node == null) {             break.         }     }     return Optional.ofNullable(node). }
false;private;1;4;;private void validateSchema(JsonNode schema) throws MojoExecutionException {     getNode(schema, "required").orElseThrow(() -> new MojoExecutionException("Invalid JsonSchema: 'required' element not found")). }
