commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public void prepareOnStartup(GenericFileOperations<File> operations, GenericFileEndpoint<File> endpoint) { // noop }
false;public;3;89;;@Override public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {     // must call super     if (!super.acquireExclusiveReadLock(operations, file, exchange)) {         return false.     }     File target = new File(file.getAbsoluteFilePath()).     LOG.trace("Waiting for exclusive read lock to file: {}", target).     FileChannel channel = null.     RandomAccessFile randomAccessFile = null.     boolean exclusive = false.     FileLock lock = null.     try {         randomAccessFile = new RandomAccessFile(target, "rw").         // try to acquire rw lock on the file before we can consume it         channel = randomAccessFile.getChannel().         StopWatch watch = new StopWatch().         while (!exclusive) {             // timeout check             if (timeout > 0) {                 long delta = watch.taken().                 if (delta > timeout) {                     CamelLogger.log(LOG, readLockLoggingLevel, "Cannot acquire read lock within " + timeout + " millis. Will skip the file: " + target).                     // we could not get the lock within the timeout period, so return false                     return false.                 }             }             if (!target.exists()) {                 CamelLogger.log(LOG, readLockLoggingLevel, "Cannot acquire read lock as file no longer exists. Will skip the file: " + file).                 return false.             }             // get the lock using either try lock or not depending on if we are using timeout or not             try {                 lock = timeout > 0 ? channel.tryLock() : channel.lock().             } catch (IllegalStateException ex) {             // Also catch the OverlappingFileLockException here. Do nothing here             }             if (lock != null) {                 LOG.trace("Acquired exclusive read lock: {} to file: {}", lock, target).                 exclusive = true.             } else {                 boolean interrupted = sleep().                 if (interrupted) {                     // we were interrupted while sleeping, we are likely being shutdown so return false                     return false.                 }             }         }     } catch (IOException e) {         // such as AntiVirus or MS Office that has special locks for it's supported files         if (timeout == 0) {             // if not using timeout, then we cant retry, so return false             return false.         }         LOG.debug("Cannot acquire read lock. Will try again.", e).         boolean interrupted = sleep().         if (interrupted) {             // we were interrupted while sleeping, we are likely being shutdown so return false             return false.         }     } finally {         // close channels if we did not grab the lock         if (!exclusive) {             IOHelper.close(channel, "while acquiring exclusive read lock for file: " + target, LOG).             IOHelper.close(randomAccessFile, "while acquiring exclusive read lock for file: " + target, LOG).             // and also must release super lock             super.releaseExclusiveReadLockOnAbort(operations, file, exchange).         }     }     // store read-lock state     exchange.setProperty(asReadLockKey(file, Exchange.FILE_LOCK_EXCLUSIVE_LOCK), lock).     exchange.setProperty(asReadLockKey(file, Exchange.FILE_LOCK_RANDOM_ACCESS_FILE), randomAccessFile).     // we grabbed the lock     return true. }
false;protected;3;21;;@Override protected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {     // must call super     super.doReleaseExclusiveReadLock(operations, file, exchange).     FileLock lock = exchange.getProperty(asReadLockKey(file, Exchange.FILE_LOCK_EXCLUSIVE_LOCK), FileLock.class).     RandomAccessFile rac = exchange.getProperty(asReadLockKey(file, Exchange.FILE_LOCK_EXCLUSIVE_LOCK), RandomAccessFile.class).     String target = file.getFileName().     if (lock != null) {         Channel channel = lock.acquiredBy().         try {             lock.release().         } finally {             // close channel as well             IOHelper.close(channel, "while releasing exclusive read lock for file: " + target, LOG).             IOHelper.close(rac, "while releasing exclusive read lock for file: " + target, LOG).         }     } }
false;private;0;10;;private boolean sleep() {     LOG.trace("Exclusive read lock not granted. Sleeping for {} millis.", checkInterval).     try {         Thread.sleep(checkInterval).         return false.     } catch (InterruptedException e) {         LOG.debug("Sleep interrupted while waiting for exclusive read lock, so breaking out").         return true.     } }
false;public;0;3;;public long getTimeout() {     return timeout. }
false;public;1;4;;@Override public void setTimeout(long timeout) {     this.timeout = timeout. }
false;public;1;4;;@Override public void setCheckInterval(long checkInterval) {     this.checkInterval = checkInterval. }
false;public;1;4;;@Override public void setReadLockLoggingLevel(LoggingLevel readLockLoggingLevel) {     this.readLockLoggingLevel = readLockLoggingLevel. }
false;private,static;2;7;;private static String asReadLockKey(GenericFile file, String key) {     // use the copy from absolute path as that was the original path of the file when the lock was acquired     // for example if the file consumer uses preMove then the file is moved and therefore has another name     // that would no longer match     String path = file.getCopyFromAbsoluteFilePath() != null ? file.getCopyFromAbsoluteFilePath() : file.getAbsoluteFilePath().     return path + "-" + key. }
