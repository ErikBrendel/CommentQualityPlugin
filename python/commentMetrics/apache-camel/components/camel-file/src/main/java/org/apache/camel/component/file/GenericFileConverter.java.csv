commented;modifiers;parameterAmount;loc;comment;code
false;public,static;4;55;;@FallbackConverter public static Object convertTo(Class<?> type, Exchange exchange, Object value, TypeConverterRegistry registry) throws IOException, NoTypeConversionAvailableException {     // use a fallback type converter so we can convert the embedded body if the value is GenericFile     if (GenericFile.class.isAssignableFrom(value.getClass())) {         GenericFile<?> file = (GenericFile<?>) value.         Class<?> from = file.getBody().getClass().         // maybe from is already the type we want         if (from.isAssignableFrom(type)) {             return file.getBody().         }         // no then try to lookup a type converter         TypeConverter tc = registry.lookup(type, from).         if (tc != null) {             Object body = file.getBody().             // if the desired type is InputStream or Reader we can use the optimized methods             if (Reader.class.isAssignableFrom(type)) {                 Reader reader = genericFileToReader(file, exchange).                 if (reader != null) {                     return reader.                 }             }             if (InputStream.class.isAssignableFrom(type)) {                 InputStream is = genericFileToInputStream(file, exchange).                 if (is != null) {                     return is.                 }             }             // which mean we have to use the Reader first, and then convert from there             if (body instanceof File && file.getCharset() != null) {                 Reader reader = genericFileToReader(file, exchange).                 // we dont want a reader back, so use the type converter registry to find a suitable converter                 TypeConverter readerTc = registry.lookup(type, Reader.class).                 if (readerTc != null) {                     // use the reader based type converter                     return readerTc.convertTo(type, exchange, reader).                 }             }             // fallback and use the type suitable type converter             return tc.convertTo(type, exchange, body).         }     }     return null. }
false;public,static;2;26;;@Converter public static InputStream genericFileToInputStream(GenericFile<?> file, Exchange exchange) throws IOException {     if (file.getFile() instanceof File) {         // prefer to use a file input stream if its a java.io.File         File f = (File) file.getFile().         // the file must exists         if (f.exists()) {             // read the file using the specified charset             String charset = file.getCharset().             if (charset != null) {                 LOG.debug("Read file {} with charset {}", f, file.getCharset()).             } else {                 LOG.debug("Read file {} (no charset)", f).             }             return toInputStream(f, charset).         }     }     if (exchange != null) {         // otherwise ensure the body is loaded as we want the input stream of the body         file.getBinding().loadContent(exchange, file).         return exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, file.getBody()).     } else {         // should revert to fallback converter if we don't have an exchange         return null.     } }
false;public,static;2;16;;@Converter public static String genericFileToString(GenericFile<?> file, Exchange exchange) throws IOException, NoTypeConversionAvailableException {     // use reader first as it supports the file charset     BufferedReader reader = genericFileToReader(file, exchange).     if (reader != null) {         return toString(reader).     }     if (exchange != null) {         // otherwise ensure the body is loaded as we want the content of the body         file.getBinding().loadContent(exchange, file).         return exchange.getContext().getTypeConverter().convertTo(String.class, exchange, file.getBody()).     } else {         // should revert to fallback converter if we don't have an exchange         return null.     } }
false;public,static;2;16;;@Converter public static Serializable genericFileToSerializable(GenericFile<?> file, Exchange exchange) throws IOException {     if (exchange != null) {         // load the file using input stream         InputStream is = genericFileToInputStream(file, exchange).         if (is != null) {             // need to double convert to convert correctly             byte[] data = exchange.getContext().getTypeConverter().convertTo(byte[].class, exchange, is).             if (data != null) {                 return exchange.getContext().getTypeConverter().convertTo(Serializable.class, exchange, data).             }         }     }     // should revert to fallback converter if we don't have an exchange     return null. }
false;private,static;2;20;;private static BufferedReader genericFileToReader(GenericFile<?> file, Exchange exchange) throws IOException {     if (file.getFile() instanceof File) {         // prefer to use a file input stream if its a java.io.File         File f = (File) file.getFile().         // the file must exists         if (!f.exists()) {             return null.         }         // and use the charset if the file was explicit configured with a charset         String charset = file.getCharset().         if (charset != null) {             LOG.debug("Read file {} with charset {}", f, file.getCharset()).             return toReader(f, charset).         } else {             LOG.debug("Read file {} (no charset)", f).             return toReader(f, ExchangeHelper.getCharsetName(exchange)).         }     }     return null. }
false;private,static;2;4;;private static BufferedReader toReader(File file, String charset) throws IOException {     FileInputStream in = new FileInputStream(file).     return IOHelper.buffered(new EncodingFileReader(in, charset)). }
false;private,static;2;7;;private static InputStream toInputStream(File file, String charset) throws IOException {     if (charset != null) {         return new EncodingInputStream(file, charset).     } else {         return toInputStream(file).     } }
false;private,static;1;3;;private static InputStream toInputStream(File file) throws IOException {     return IOHelper.buffered(new FileInputStream(file)). }
false;private,static;1;15;;private static String toString(BufferedReader reader) throws IOException {     StringBuilder sb = new StringBuilder(1024).     char[] buf = new char[1024].     try {         int len.         // read until we reach then end which is the -1 marker         while ((len = reader.read(buf)) != -1) {             sb.append(buf, 0, len).         }     } finally {         IOHelper.close(reader, "reader", LOG).     }     return sb.toString(). }
false;public;0;8;;@Override public void close() throws IOException {     try {         super.close().     } finally {         in.close().     } }
false;public;0;13;;@Override public int read() throws IOException {     if (bufferBytes == null || bufferBytes.remaining() <= 0) {         bufferedChars.clear().         int len = reader.read(bufferedChars).         bufferedChars.flip().         if (len == -1) {             return -1.         }         bufferBytes = defaultStreamCharset.encode(bufferedChars).     }     return bufferBytes.get(). }
false;public;0;4;;@Override public void close() throws IOException {     reader.close(). }
false;public;0;4;;@Override public void reset() throws IOException {     reader.reset(). }
false;public;0;3;;public InputStream toOriginalInputStream() throws FileNotFoundException {     return new FileInputStream(file). }
