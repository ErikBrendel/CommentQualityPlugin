commented;modifiers;parameterAmount;loc;comment;code
false;public;2;7;;@Override public void prepareOnStartup(GenericFileOperations<File> operations, GenericFileEndpoint<File> endpoint) throws Exception {     this.endpoint = endpoint.     log.info("Using FileIdempotentRepositoryReadLockStrategy: {} on endpoint: {}", idempotentRepository, endpoint).     changed.prepareOnStartup(operations, endpoint). }
false;public;3;26;;@Override public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {     // in clustered mode then another node may have processed the file so we must check here again if the file exists     File path = file.getFile().     if (!path.exists()) {         return false.     }     // check if we can begin on this file     String key = asKey(file).     boolean answer = idempotentRepository.add(key).     if (!answer) {         // another node is processing the file so skip         CamelLogger.log(log, readLockLoggingLevel, "Cannot acquire read lock. Will skip the file: " + file).     }     if (answer) {         // if we acquired during idempotent then check changed also         answer = changed.acquireExclusiveReadLock(operations, file, exchange).         if (!answer) {             // remove from idempontent as we did not acquire it from changed             idempotentRepository.remove(key).         }     }     return answer. }
false;public;3;4;;@Override public void releaseExclusiveReadLockOnAbort(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {     changed.releaseExclusiveReadLockOnAbort(operations, file, exchange). }
false;public;3;29;;@Override public void releaseExclusiveReadLockOnRollback(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {     String key = asKey(file).     Runnable r = () -> {         if (removeOnRollback) {             idempotentRepository.remove(key).         } else {             // okay we should not remove then confirm it instead             idempotentRepository.confirm(key).         }         try {             changed.releaseExclusiveReadLockOnRollback(operations, file, exchange).         } catch (Exception e) {             log.warn("Error during releasing exclusive readlock on rollback. This exception is ignored.", e).         }     }.     if (readLockIdempotentReleaseDelay > 0 && readLockIdempotentReleaseExecutorService != null) {         log.debug("Scheduling readlock release task to run asynchronous delayed after {} millis", readLockIdempotentReleaseDelay).         readLockIdempotentReleaseExecutorService.schedule(r, readLockIdempotentReleaseDelay, TimeUnit.MILLISECONDS).     } else if (readLockIdempotentReleaseDelay > 0) {         log.debug("Delaying readlock release task {} millis", readLockIdempotentReleaseDelay).         Thread.sleep(readLockIdempotentReleaseDelay).         r.run().     } else {         r.run().     } }
false;public;3;29;;@Override public void releaseExclusiveReadLockOnCommit(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {     String key = asKey(file).     Runnable r = () -> {         if (removeOnCommit) {             idempotentRepository.remove(key).         } else {             // confirm on commit             idempotentRepository.confirm(key).         }         try {             changed.releaseExclusiveReadLockOnCommit(operations, file, exchange).         } catch (Exception e) {             log.warn("Error during releasing exclusive readlock on rollback. This exception is ignored.", e).         }     }.     if (readLockIdempotentReleaseDelay > 0 && readLockIdempotentReleaseExecutorService != null) {         log.debug("Scheduling readlock release task to run asynchronous delayed after {} millis", readLockIdempotentReleaseDelay).         readLockIdempotentReleaseExecutorService.schedule(r, readLockIdempotentReleaseDelay, TimeUnit.MILLISECONDS).     } else if (readLockIdempotentReleaseDelay > 0) {         log.debug("Delaying readlock release task {} millis", readLockIdempotentReleaseDelay).         Thread.sleep(readLockIdempotentReleaseDelay).         r.run().     } else {         r.run().     } }
false;public;1;3;;public void setTimeout(long timeout) {     changed.setTimeout(timeout). }
false;public;1;3;;public void setCheckInterval(long checkInterval) {     changed.setCheckInterval(checkInterval). }
false;public;1;4;;public void setReadLockLoggingLevel(LoggingLevel readLockLoggingLevel) {     this.readLockLoggingLevel = readLockLoggingLevel.     changed.setReadLockLoggingLevel(readLockLoggingLevel). }
false;public;1;3;;public void setMarkerFiler(boolean markerFile) { // we do not use marker files }
false;public;1;3;;public void setDeleteOrphanLockFiles(boolean deleteOrphanLockFiles) { // we do not use marker files }
false;public;1;3;;public void setMinLength(long minLength) {     changed.setMinLength(minLength). }
false;public;1;3;;public void setMinAge(long minAge) {     changed.setMinAge(minAge). }
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;1;3;;public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
true;public;0;3;/**  * The idempotent repository to use as the store for the read locks.  */ ;/**  * The idempotent repository to use as the store for the read locks.  */ public IdempotentRepository getIdempotentRepository() {     return idempotentRepository. }
true;public;1;3;/**  * The idempotent repository to use as the store for the read locks.  */ ;/**  * The idempotent repository to use as the store for the read locks.  */ public void setIdempotentRepository(IdempotentRepository idempotentRepository) {     this.idempotentRepository = idempotentRepository. }
true;public;0;3;/**  * Whether to remove the file from the idempotent repository when doing a rollback.  * <p/>  * By default this is true.  */ ;/**  * Whether to remove the file from the idempotent repository when doing a rollback.  * <p/>  * By default this is true.  */ public boolean isRemoveOnRollback() {     return removeOnRollback. }
true;public;1;3;/**  * Whether to remove the file from the idempotent repository when doing a rollback.  * <p/>  * By default this is true.  */ ;/**  * Whether to remove the file from the idempotent repository when doing a rollback.  * <p/>  * By default this is true.  */ public void setRemoveOnRollback(boolean removeOnRollback) {     this.removeOnRollback = removeOnRollback. }
true;public;0;3;/**  * Whether to remove the file from the idempotent repository when doing a commit.  * <p/>  * By default this is false.  */ ;/**  * Whether to remove the file from the idempotent repository when doing a commit.  * <p/>  * By default this is false.  */ public boolean isRemoveOnCommit() {     return removeOnCommit. }
true;public;1;3;/**  * Whether to remove the file from the idempotent repository when doing a commit.  * <p/>  * By default this is false.  */ ;/**  * Whether to remove the file from the idempotent repository when doing a commit.  * <p/>  * By default this is false.  */ public void setRemoveOnCommit(boolean removeOnCommit) {     this.removeOnCommit = removeOnCommit. }
true;public;1;3;/**  * Whether to delay the release task for a period of millis.  */ ;/**  * Whether to delay the release task for a period of millis.  */ public void setReadLockIdempotentReleaseDelay(int readLockIdempotentReleaseDelay) {     this.readLockIdempotentReleaseDelay = readLockIdempotentReleaseDelay. }
false;public;0;3;;public boolean isReadLockIdempotentReleaseAsync() {     return readLockIdempotentReleaseAsync. }
true;public;1;3;/**  * Whether the delayed release task should be synchronous or asynchronous.  */ ;/**  * Whether the delayed release task should be synchronous or asynchronous.  */ public void setReadLockIdempotentReleaseAsync(boolean readLockIdempotentReleaseAsync) {     this.readLockIdempotentReleaseAsync = readLockIdempotentReleaseAsync. }
false;public;0;3;;public int getReadLockIdempotentReleaseAsyncPoolSize() {     return readLockIdempotentReleaseAsyncPoolSize. }
true;public;1;3;/**  * The number of threads in the scheduled thread pool when using asynchronous release tasks.  */ ;/**  * The number of threads in the scheduled thread pool when using asynchronous release tasks.  */ public void setReadLockIdempotentReleaseAsyncPoolSize(int readLockIdempotentReleaseAsyncPoolSize) {     this.readLockIdempotentReleaseAsyncPoolSize = readLockIdempotentReleaseAsyncPoolSize. }
false;public;0;3;;public ScheduledExecutorService getReadLockIdempotentReleaseExecutorService() {     return readLockIdempotentReleaseExecutorService. }
true;public;1;3;/**  * To use a custom and shared thread pool for asynchronous release tasks.  */ ;/**  * To use a custom and shared thread pool for asynchronous release tasks.  */ public void setReadLockIdempotentReleaseExecutorService(ScheduledExecutorService readLockIdempotentReleaseExecutorService) {     this.readLockIdempotentReleaseExecutorService = readLockIdempotentReleaseExecutorService. }
false;protected;1;9;;protected String asKey(GenericFile<File> file) {     // use absolute file path as default key, but evaluate if an expression key was configured     String key = file.getAbsoluteFilePath().     if (endpoint.getIdempotentKey() != null) {         Exchange dummy = endpoint.createExchange(file).         key = endpoint.getIdempotentKey().evaluate(dummy, String.class).     }     return key. }
false;protected;0;11;;@Override protected void doStart() throws Exception {     ObjectHelper.notNull(camelContext, "camelContext", this).     ObjectHelper.notNull(idempotentRepository, "idempotentRepository", this).     if (readLockIdempotentReleaseAsync && readLockIdempotentReleaseExecutorService == null) {         readLockIdempotentReleaseExecutorService = camelContext.getExecutorServiceManager().newScheduledThreadPool(this, "ReadLockChangedIdempotentReleaseTask", readLockIdempotentReleaseAsyncPoolSize).         shutdownExecutorService = true.     } }
false;protected;0;7;;@Override protected void doStop() throws Exception {     if (shutdownExecutorService && readLockIdempotentReleaseExecutorService != null) {         camelContext.getExecutorServiceManager().shutdownGraceful(readLockIdempotentReleaseExecutorService, 30000).         readLockIdempotentReleaseExecutorService = null.     } }
