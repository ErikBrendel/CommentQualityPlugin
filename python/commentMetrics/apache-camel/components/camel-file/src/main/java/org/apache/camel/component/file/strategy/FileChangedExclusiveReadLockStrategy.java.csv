commented;modifiers;parameterAmount;loc;comment;code
false;public;3;60;;@Override public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {     // must call super     if (!super.acquireExclusiveReadLock(operations, file, exchange)) {         return false.     }     File target = new File(file.getAbsoluteFilePath()).     boolean exclusive = false.     LOG.trace("Waiting for exclusive read lock to file: {}", file).     long lastModified = Long.MIN_VALUE.     long length = Long.MIN_VALUE.     StopWatch watch = new StopWatch().     long startTime = (new Date()).getTime().     while (!exclusive) {         // timeout check         if (timeout > 0) {             long delta = watch.taken().             if (delta > timeout) {                 CamelLogger.log(LOG, readLockLoggingLevel, "Cannot acquire read lock within " + timeout + " millis. Will skip the file: " + file).                 // we could not get the lock within the timeout period, so return false                 return false.             }         }         if (!target.exists()) {             CamelLogger.log(LOG, readLockLoggingLevel, "Cannot acquire read lock as file no longer exists. Will skip the file: " + file).             return false.         }         long newLastModified = target.lastModified().         long newLength = target.length().         long newOlderThan = startTime + watch.taken() - minAge.         LOG.trace("Previous last modified: {}, new last modified: {}", lastModified, newLastModified).         LOG.trace("Previous length: {}, new length: {}", length, newLength).         LOG.trace("New older than threshold: {}", newOlderThan).         if (newLength >= minLength && ((minAge == 0 && newLastModified == lastModified && newLength == length) || (minAge != 0 && newLastModified < newOlderThan))) {             LOG.trace("Read lock acquired.").             exclusive = true.         } else {             // set new base file change information             lastModified = newLastModified.             length = newLength.             boolean interrupted = sleep().             if (interrupted) {                 // we were interrupted while sleeping, we are likely being shutdown so return false                 return false.             }         }     }     return exclusive. }
false;private;0;10;;private boolean sleep() {     LOG.trace("Exclusive read lock not granted. Sleeping for {} millis.", checkInterval).     try {         Thread.sleep(checkInterval).         return false.     } catch (InterruptedException e) {         LOG.debug("Sleep interrupted while waiting for exclusive read lock, so breaking out").         return true.     } }
false;public;0;3;;public long getTimeout() {     return timeout. }
false;public;1;4;;@Override public void setTimeout(long timeout) {     this.timeout = timeout. }
false;public;0;3;;public long getCheckInterval() {     return checkInterval. }
false;public;1;4;;@Override public void setCheckInterval(long checkInterval) {     this.checkInterval = checkInterval. }
false;public;1;4;;@Override public void setReadLockLoggingLevel(LoggingLevel readLockLoggingLevel) {     this.readLockLoggingLevel = readLockLoggingLevel. }
false;public;0;3;;public long getMinLength() {     return minLength. }
false;public;1;3;;public void setMinLength(long minLength) {     this.minLength = minLength. }
false;public;0;3;;public long getMinAge() {     return minAge. }
false;public;1;3;;public void setMinAge(long minAge) {     this.minAge = minAge. }
