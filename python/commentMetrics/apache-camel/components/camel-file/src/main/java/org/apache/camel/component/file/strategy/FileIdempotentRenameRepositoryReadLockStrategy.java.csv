commented;modifiers;parameterAmount;loc;comment;code
false;public;2;7;;@Override public void prepareOnStartup(GenericFileOperations<File> operations, GenericFileEndpoint<File> endpoint) throws Exception {     this.endpoint = endpoint.     log.info("Using FileIdempotentRepositoryReadLockStrategy: {} on endpoint: {}", idempotentRepository, endpoint).     rename.prepareOnStartup(operations, endpoint). }
false;public;3;26;;@Override public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {     // in clustered mode then another node may have processed the file so we must check here again if the file exists     File path = file.getFile().     if (!path.exists()) {         return false.     }     // check if we can begin on this file     String key = asKey(file).     boolean answer = idempotentRepository.add(key).     if (!answer) {         // another node is processing the file so skip         CamelLogger.log(log, readLockLoggingLevel, "Cannot acquire read lock. Will skip the file: " + file).     }     if (answer) {         // if we acquired during idempotent then check rename also         answer = rename.acquireExclusiveReadLock(operations, file, exchange).         if (!answer) {             // remove from idempontent as we did not acquire it from changed             idempotentRepository.remove(key).         }     }     return answer. }
false;public;3;4;;@Override public void releaseExclusiveReadLockOnAbort(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {     rename.releaseExclusiveReadLockOnAbort(operations, file, exchange). }
false;public;3;12;;@Override public void releaseExclusiveReadLockOnRollback(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {     String key = asKey(file).     if (removeOnRollback) {         idempotentRepository.remove(key).     } else {         // okay we should not remove then confirm it instead         idempotentRepository.confirm(key).     }     rename.releaseExclusiveReadLockOnRollback(operations, file, exchange). }
false;public;3;12;;@Override public void releaseExclusiveReadLockOnCommit(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {     String key = asKey(file).     if (removeOnCommit) {         idempotentRepository.remove(key).     } else {         // confirm on commit         idempotentRepository.confirm(key).     }     rename.releaseExclusiveReadLockOnCommit(operations, file, exchange). }
false;public;1;3;;public void setTimeout(long timeout) {     rename.setTimeout(timeout). }
false;public;1;3;;public void setCheckInterval(long checkInterval) {     rename.setCheckInterval(checkInterval). }
false;public;1;4;;public void setReadLockLoggingLevel(LoggingLevel readLockLoggingLevel) {     this.readLockLoggingLevel = readLockLoggingLevel.     rename.setReadLockLoggingLevel(readLockLoggingLevel). }
false;public;1;3;;public void setMarkerFiler(boolean markerFile) { // we do not use marker files }
false;public;1;3;;public void setDeleteOrphanLockFiles(boolean deleteOrphanLockFiles) { // we do not use marker files }
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;1;3;;public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
true;public;0;3;/**  * The idempotent repository to use as the store for the read locks.  */ ;/**  * The idempotent repository to use as the store for the read locks.  */ public IdempotentRepository getIdempotentRepository() {     return idempotentRepository. }
true;public;1;3;/**  * The idempotent repository to use as the store for the read locks.  */ ;/**  * The idempotent repository to use as the store for the read locks.  */ public void setIdempotentRepository(IdempotentRepository idempotentRepository) {     this.idempotentRepository = idempotentRepository. }
true;public;0;3;/**  * Whether to remove the file from the idempotent repository when doing a rollback.  * <p/>  * By default this is true.  */ ;/**  * Whether to remove the file from the idempotent repository when doing a rollback.  * <p/>  * By default this is true.  */ public boolean isRemoveOnRollback() {     return removeOnRollback. }
true;public;1;3;/**  * Whether to remove the file from the idempotent repository when doing a rollback.  * <p/>  * By default this is true.  */ ;/**  * Whether to remove the file from the idempotent repository when doing a rollback.  * <p/>  * By default this is true.  */ public void setRemoveOnRollback(boolean removeOnRollback) {     this.removeOnRollback = removeOnRollback. }
true;public;0;3;/**  * Whether to remove the file from the idempotent repository when doing a commit.  * <p/>  * By default this is false.  */ ;/**  * Whether to remove the file from the idempotent repository when doing a commit.  * <p/>  * By default this is false.  */ public boolean isRemoveOnCommit() {     return removeOnCommit. }
true;public;1;3;/**  * Whether to remove the file from the idempotent repository when doing a commit.  * <p/>  * By default this is false.  */ ;/**  * Whether to remove the file from the idempotent repository when doing a commit.  * <p/>  * By default this is false.  */ public void setRemoveOnCommit(boolean removeOnCommit) {     this.removeOnCommit = removeOnCommit. }
false;protected;1;9;;protected String asKey(GenericFile<File> file) {     // use absolute file path as default key, but evaluate if an expression key was configured     String key = file.getAbsoluteFilePath().     if (endpoint.getIdempotentKey() != null) {         Exchange dummy = endpoint.createExchange(file).         key = endpoint.getIdempotentKey().evaluate(dummy, String.class).     }     return key. }
false;protected;0;8;;@Override protected void doStart() throws Exception {     ObjectHelper.notNull(camelContext, "camelContext", this).     ObjectHelper.notNull(idempotentRepository, "idempotentRepository", this).     // ensure the idempotent repository is added as a service so CamelContext will stop the repo when it shutdown itself     camelContext.addService(idempotentRepository, true). }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
