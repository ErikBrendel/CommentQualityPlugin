commented;modifiers;parameterAmount;loc;comment;code
false;public;1;53;;public FileConsumer createConsumer(Processor processor) throws Exception {     ObjectHelper.notNull(operations, "operations").     ObjectHelper.notNull(file, "file").     // auto create starting directory if needed     if (!file.exists() && !file.isDirectory()) {         if (isAutoCreate()) {             log.debug("Creating non existing starting directory: {}", file).             boolean absolute = FileUtil.isAbsolute(file).             boolean created = operations.buildDirectory(file.getPath(), absolute).             if (!created) {                 log.warn("Cannot auto create starting directory: {}", file).             }         } else if (isStartingDirectoryMustExist()) {             throw new FileNotFoundException("Starting directory does not exist: " + file).         }     }     FileConsumer result = newFileConsumer(processor, operations).     if (isDelete() && getMove() != null) {         throw new IllegalArgumentException("You cannot set both delete=true and move options").     }     // if noop=true then idempotent should also be configured     if (isNoop() && !isIdempotentSet()) {         log.info("Endpoint is configured with noop=true so forcing endpoint to be idempotent as well").         setIdempotent(true).     }     // if idempotent and no repository set then create a default one     if (isIdempotentSet() && isIdempotent() && idempotentRepository == null) {         log.info("Using default memory based idempotent repository with cache max size: {}", DEFAULT_IDEMPOTENT_CACHE_SIZE).         idempotentRepository = MemoryIdempotentRepository.memoryIdempotentRepository(DEFAULT_IDEMPOTENT_CACHE_SIZE).     }     if (ObjectHelper.isNotEmpty(getReadLock())) {         // check if its a valid         String valid = "none,markerFile,fileLock,rename,changed,idempotent,idempotent-changed,idempotent-rename".         String[] arr = valid.split(",").         boolean matched = Arrays.stream(arr).anyMatch(n -> n.equals(getReadLock())).         if (!matched) {             throw new IllegalArgumentException("ReadLock invalid: " + getReadLock() + ", must be one of: " + valid).         }     }     // set max messages per poll     result.setMaxMessagesPerPoll(getMaxMessagesPerPoll()).     result.setEagerLimitMaxMessagesPerPoll(isEagerMaxMessagesPerPoll()).     configureConsumer(result).     return result. }
false;public;0;16;;@Override public PollingConsumer createPollingConsumer() throws Exception {     ObjectHelper.notNull(operations, "operations").     ObjectHelper.notNull(file, "file").     if (log.isDebugEnabled()) {         log.debug("Creating GenericFilePollingConsumer with queueSize: {} blockWhenFull: {} blockTimeout: {}", getPollingConsumerQueueSize(), isPollingConsumerBlockWhenFull(), getPollingConsumerBlockTimeout()).     }     GenericFilePollingConsumer result = new GenericFilePollingConsumer(this).     // should not call configurePollingConsumer when its GenericFilePollingConsumer     result.setBlockWhenFull(isPollingConsumerBlockWhenFull()).     result.setBlockTimeout(getPollingConsumerBlockTimeout()).     return result. }
false;public;0;19;;public GenericFileProducer<File> createProducer() throws Exception {     ObjectHelper.notNull(operations, "operations").     // you cannot use temp file and file exists append     if (getFileExist() == GenericFileExist.Append && ((getTempPrefix() != null) || (getTempFileName() != null))) {         throw new IllegalArgumentException("You cannot set both fileExist=Append and tempPrefix/tempFileName options").     }     // ensure fileExist and moveExisting is configured correctly if in use     if (getFileExist() == GenericFileExist.Move && getMoveExisting() == null) {         throw new IllegalArgumentException("You must configure moveExisting option when fileExist=Move").     } else if (getMoveExisting() != null && getFileExist() != GenericFileExist.Move) {         throw new IllegalArgumentException("You must configure fileExist=Move when moveExisting has been set").     }     if (this.getMoveExistingFileStrategy() == null) {         this.setMoveExistingFileStrategy(createDefaultMoveExistingFileStrategy()).     }     return new GenericFileProducer<>(this, operations). }
false;public;1;7;;public Exchange createExchange(GenericFile<File> file) {     Exchange exchange = createExchange().     if (file != null) {         file.bindToExchange(exchange, probeContentType).     }     return exchange. }
true;protected;2;3;/**  * Strategy to create a new {@link FileConsumer}  *  * @param processor  the given processor  * @param operations file operations  * @return the created consumer  */ ;/**  * Strategy to create a new {@link FileConsumer}  *  * @param processor  the given processor  * @param operations file operations  * @return the created consumer  */ protected FileConsumer newFileConsumer(Processor processor, GenericFileOperations<File> operations) {     return new FileConsumer(this, processor, operations, processStrategy != null ? processStrategy : createGenericFileStrategy()). }
true;private;0;3;/**  * Default Existing File Move Strategy  * @return the default implementation for file component  */ ;/**  * Default Existing File Move Strategy  * @return the default implementation for file component  */ private FileMoveExistingStrategy createDefaultMoveExistingFileStrategy() {     return new GenericFileDefaultMoveExistingFileStrategy(). }
false;public;0;3;;public File getFile() {     return file. }
true;public;1;5;/**  * The starting directory  */ ;/**  * The starting directory  */ public void setFile(File file) {     this.file = file.     // update configuration as well     getConfiguration().setDirectory(FileUtil.isAbsolute(file) ? file.getAbsolutePath() : file.getPath()). }
false;public;0;4;;@Override public String getScheme() {     return "file". }
false;protected;0;4;;@Override protected String createEndpointUri() {     return getFile().toURI().toString(). }
false;public;0;4;;@Override public char getFileSeparator() {     return File.separatorChar. }
false;public;1;5;;@Override public boolean isAbsolute(String name) {     // relative or absolute path?     return FileUtil.isAbsolute(new File(name)). }
false;public;0;3;;public boolean isCopyAndDeleteOnRenameFail() {     return copyAndDeleteOnRenameFail. }
true;public;1;3;/**  * Whether to fallback and do a copy and delete file, in case the file could not be renamed directly. This option is not available for the FTP component.  */ ;/**  * Whether to fallback and do a copy and delete file, in case the file could not be renamed directly. This option is not available for the FTP component.  */ public void setCopyAndDeleteOnRenameFail(boolean copyAndDeleteOnRenameFail) {     this.copyAndDeleteOnRenameFail = copyAndDeleteOnRenameFail. }
false;public;0;3;;public boolean isRenameUsingCopy() {     return renameUsingCopy. }
true;public;1;3;/**  * Perform rename operations using a copy and delete strategy.  * This is primarily used in environments where the regular rename operation is unreliable (e.g. across different file systems or networks).  * This option takes precedence over the copyAndDeleteOnRenameFail parameter that will automatically fall back to the copy and delete strategy,  * but only after additional delays.  */ ;/**  * Perform rename operations using a copy and delete strategy.  * This is primarily used in environments where the regular rename operation is unreliable (e.g. across different file systems or networks).  * This option takes precedence over the copyAndDeleteOnRenameFail parameter that will automatically fall back to the copy and delete strategy,  * but only after additional delays.  */ public void setRenameUsingCopy(boolean renameUsingCopy) {     this.renameUsingCopy = renameUsingCopy. }
false;public;0;3;;public boolean isForceWrites() {     return forceWrites. }
true;public;1;3;/**  * Whether to force syncing writes to the file system.  * You can turn this off if you do not want this level of guarantee, for example if writing to logs / audit logs etc. this would yield better performance.  */ ;/**  * Whether to force syncing writes to the file system.  * You can turn this off if you do not want this level of guarantee, for example if writing to logs / audit logs etc. this would yield better performance.  */ public void setForceWrites(boolean forceWrites) {     this.forceWrites = forceWrites. }
false;public;0;3;;public boolean isProbeContentType() {     return probeContentType. }
true;public;1;3;/**  * Whether to enable probing of the content type. If enable then the consumer uses {@link Files#probeContentType(java.nio.file.Path)} to  * determine the content-type of the file, and store that as a header with key {@link Exchange#FILE_CONTENT_TYPE} on the {@link Message}.  */ ;/**  * Whether to enable probing of the content type. If enable then the consumer uses {@link Files#probeContentType(java.nio.file.Path)} to  * determine the content-type of the file, and store that as a header with key {@link Exchange#FILE_CONTENT_TYPE} on the {@link Message}.  */ public void setProbeContentType(boolean probeContentType) {     this.probeContentType = probeContentType. }
false;public;0;3;;public String getExtendedAttributes() {     return extendedAttributes. }
true;public;1;3;/**  * To define which file attributes of interest. Like posix:permissions,posix:owner,basic:lastAccessTime,  * it supports basic wildcard like posix:*, basic:lastAccessTime  */ ;/**  * To define which file attributes of interest. Like posix:permissions,posix:owner,basic:lastAccessTime,  * it supports basic wildcard like posix:*, basic:lastAccessTime  */ public void setExtendedAttributes(String extendedAttributes) {     this.extendedAttributes = extendedAttributes. }
true;public;1;13;/**  * Chmod value must be between 000 and 777. If there is a leading digit like in 0755 we will ignore it.  */ ;/**  * Chmod value must be between 000 and 777. If there is a leading digit like in 0755 we will ignore it.  */ public boolean chmodPermissionsAreValid(String chmod) {     if (chmod == null || chmod.length() < 3 || chmod.length() > 4) {         return false.     }     // if 4 digits chop off leading one     String permissionsString = chmod.trim().substring(chmod.length() - 3).     for (int i = 0. i < permissionsString.length(). i++) {         Character c = permissionsString.charAt(i).         if (!Character.isDigit(c) || Integer.parseInt(c.toString()) > 7) {             return false.         }     }     return true. }
false;public;0;44;;public Set<PosixFilePermission> getPermissions() {     Set<PosixFilePermission> permissions = new HashSet<>().     if (ObjectHelper.isEmpty(chmod)) {         return permissions.     }     // if 4 digits chop off leading one     String chmodString = chmod.substring(chmod.length() - 3).     Integer ownerValue = Integer.parseInt(chmodString.substring(0, 1)).     Integer groupValue = Integer.parseInt(chmodString.substring(1, 2)).     Integer othersValue = Integer.parseInt(chmodString.substring(2, 3)).     if ((ownerValue & CHMOD_WRITE_MASK) > 0) {         permissions.add(PosixFilePermission.OWNER_WRITE).     }     if ((ownerValue & CHMOD_READ_MASK) > 0) {         permissions.add(PosixFilePermission.OWNER_READ).     }     if ((ownerValue & CHMOD_EXECUTE_MASK) > 0) {         permissions.add(PosixFilePermission.OWNER_EXECUTE).     }     if ((groupValue & CHMOD_WRITE_MASK) > 0) {         permissions.add(PosixFilePermission.GROUP_WRITE).     }     if ((groupValue & CHMOD_READ_MASK) > 0) {         permissions.add(PosixFilePermission.GROUP_READ).     }     if ((groupValue & CHMOD_EXECUTE_MASK) > 0) {         permissions.add(PosixFilePermission.GROUP_EXECUTE).     }     if ((othersValue & CHMOD_WRITE_MASK) > 0) {         permissions.add(PosixFilePermission.OTHERS_WRITE).     }     if ((othersValue & CHMOD_READ_MASK) > 0) {         permissions.add(PosixFilePermission.OTHERS_READ).     }     if ((othersValue & CHMOD_EXECUTE_MASK) > 0) {         permissions.add(PosixFilePermission.OTHERS_EXECUTE).     }     return permissions. }
false;public;0;3;;public String getChmod() {     return chmod. }
true;public;1;7;/**  * Specify the file permissions which is sent by the producer, the chmod value must be between 000 and 777.  * If there is a leading digit like in 0755 we will ignore it.  */ ;/**  * Specify the file permissions which is sent by the producer, the chmod value must be between 000 and 777.  * If there is a leading digit like in 0755 we will ignore it.  */ public void setChmod(String chmod) throws Exception {     if (ObjectHelper.isNotEmpty(chmod) && chmodPermissionsAreValid(chmod)) {         this.chmod = chmod.trim().     } else {         throw new IllegalArgumentException("chmod option [" + chmod + "] is not valid").     } }
false;public;0;44;;public Set<PosixFilePermission> getDirectoryPermissions() {     Set<PosixFilePermission> permissions = new HashSet<>().     if (ObjectHelper.isEmpty(chmodDirectory)) {         return permissions.     }     // if 4 digits chop off leading one     String chmodString = chmodDirectory.substring(chmodDirectory.length() - 3).     Integer ownerValue = Integer.parseInt(chmodString.substring(0, 1)).     Integer groupValue = Integer.parseInt(chmodString.substring(1, 2)).     Integer othersValue = Integer.parseInt(chmodString.substring(2, 3)).     if ((ownerValue & CHMOD_WRITE_MASK) > 0) {         permissions.add(PosixFilePermission.OWNER_WRITE).     }     if ((ownerValue & CHMOD_READ_MASK) > 0) {         permissions.add(PosixFilePermission.OWNER_READ).     }     if ((ownerValue & CHMOD_EXECUTE_MASK) > 0) {         permissions.add(PosixFilePermission.OWNER_EXECUTE).     }     if ((groupValue & CHMOD_WRITE_MASK) > 0) {         permissions.add(PosixFilePermission.GROUP_WRITE).     }     if ((groupValue & CHMOD_READ_MASK) > 0) {         permissions.add(PosixFilePermission.GROUP_READ).     }     if ((groupValue & CHMOD_EXECUTE_MASK) > 0) {         permissions.add(PosixFilePermission.GROUP_EXECUTE).     }     if ((othersValue & CHMOD_WRITE_MASK) > 0) {         permissions.add(PosixFilePermission.OTHERS_WRITE).     }     if ((othersValue & CHMOD_READ_MASK) > 0) {         permissions.add(PosixFilePermission.OTHERS_READ).     }     if ((othersValue & CHMOD_EXECUTE_MASK) > 0) {         permissions.add(PosixFilePermission.OTHERS_EXECUTE).     }     return permissions. }
false;public;0;3;;public String getChmodDirectory() {     return chmodDirectory. }
true;public;1;7;/**  * Specify the directory permissions used when the producer creates missing directories, the chmod value must be between 000 and 777.  * If there is a leading digit like in 0755 we will ignore it.  */ ;/**  * Specify the directory permissions used when the producer creates missing directories, the chmod value must be between 000 and 777.  * If there is a leading digit like in 0755 we will ignore it.  */ public void setChmodDirectory(String chmodDirectory) throws Exception {     if (ObjectHelper.isNotEmpty(chmodDirectory) && chmodPermissionsAreValid(chmodDirectory)) {         this.chmodDirectory = chmodDirectory.trim().     } else {         throw new IllegalArgumentException("chmodDirectory option [" + chmodDirectory + "] is not valid").     } }
