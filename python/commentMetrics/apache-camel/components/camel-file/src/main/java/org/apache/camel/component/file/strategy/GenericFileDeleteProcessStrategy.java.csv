commented;modifiers;parameterAmount;loc;comment;code
false;public;4;20;;@Override public boolean begin(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint, Exchange exchange, GenericFile<T> file) throws Exception {     // must invoke super     boolean result = super.begin(operations, endpoint, exchange, file).     if (!result) {         return false.     }     // okay we got the file then execute the begin renamer     if (beginRenamer != null) {         GenericFile<T> newName = beginRenamer.renameFile(exchange, file).         GenericFile<T> to = renameFile(operations, file, newName).         if (to != null) {             to.bindToExchange(exchange).         }     }     return true. }
false;public;4;47;;@Override public void commit(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint, Exchange exchange, GenericFile<T> file) throws Exception {     // special for file lock strategy as we must release that lock first before we can delete the file     boolean releaseEager = exclusiveReadLockStrategy instanceof FileLockExclusiveReadLockStrategy.     if (releaseEager) {         exclusiveReadLockStrategy.releaseExclusiveReadLockOnCommit(operations, file, exchange).     }     try {         deleteLocalWorkFile(exchange).         operations.releaseRetrievedFileResources(exchange).         int retries = 3.         boolean deleted = false.         while (retries > 0 && !deleted) {             retries--.             if (operations.deleteFile(file.getAbsoluteFilePath())) {                 // file is deleted                 deleted = true.                 break.             }             // some OS can report false when deleting but the file is still deleted             // use exists to check instead             boolean exits = operations.existsFile(file.getAbsoluteFilePath()).             if (!exits) {                 deleted = true.             } else {                 log.trace("File was not deleted at this attempt will try again in 1 sec.: {}", file).                 // sleep a bit and try again                 Thread.sleep(1000).             }         }         if (!deleted) {             throw new GenericFileOperationFailedException("Cannot delete file: " + file).         }     } finally {         // must release lock last         if (!releaseEager && exclusiveReadLockStrategy != null) {             exclusiveReadLockStrategy.releaseExclusiveReadLockOnCommit(operations, file, exchange).         }     } }
false;public;4;25;;@Override public void rollback(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint, Exchange exchange, GenericFile<T> file) throws Exception {     try {         deleteLocalWorkFile(exchange).         operations.releaseRetrievedFileResources(exchange).         // moved the failed file if specifying the moveFailed option         if (failureRenamer != null) {             // create a copy and bind the file to the exchange to be used by the renamer to evaluate the file name             Exchange copy = ExchangeHelper.createCopy(exchange, true).             file.bindToExchange(copy).             // must preserve message id             copy.getIn().setMessageId(exchange.getIn().getMessageId()).             copy.setExchangeId(exchange.getExchangeId()).             GenericFile<T> newName = failureRenamer.renameFile(copy, file).             renameFile(operations, file, newName).         }     } finally {         // must release lock last         if (exclusiveReadLockStrategy != null) {             exclusiveReadLockStrategy.releaseExclusiveReadLockOnRollback(operations, file, exchange).         }     } }
false;public;0;3;;public GenericFileRenamer<T> getFailureRenamer() {     return failureRenamer. }
false;public;1;3;;public void setFailureRenamer(GenericFileRenamer<T> failureRenamer) {     this.failureRenamer = failureRenamer. }
false;public;0;3;;public GenericFileRenamer<T> getBeginRenamer() {     return beginRenamer. }
false;public;1;3;;public void setBeginRenamer(GenericFileRenamer<T> beginRenamer) {     this.beginRenamer = beginRenamer. }
