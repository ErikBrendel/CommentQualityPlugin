commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public char getFileSeparator() {     return File.separatorChar. }
true;public;1;26;/**  * Creates a copy based on the source  *  * @param source the source  * @return a copy of the source  */ ;/**  * Creates a copy based on the source  *  * @param source the source  * @return a copy of the source  */ @SuppressWarnings("unchecked") public GenericFile<T> copyFrom(GenericFile<T> source) {     GenericFile<T> result.     try {         result = source.getClass().newInstance().     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     }     result.setCopyFromAbsoluteFilePath(source.getAbsoluteFilePath()).     result.setEndpointPath(source.getEndpointPath()).     result.setAbsolute(source.isAbsolute()).     result.setDirectory(source.isDirectory()).     result.setAbsoluteFilePath(source.getAbsoluteFilePath()).     result.setRelativeFilePath(source.getRelativeFilePath()).     result.setFileName(source.getFileName()).     result.setFileNameOnly(source.getFileNameOnly()).     result.setFileLength(source.getFileLength()).     result.setLastModified(source.getLastModified()).     result.setFile(source.getFile()).     result.setBody(source.getBody()).     result.setBinding(source.getBinding()).     result.setCharset(source.getCharset()).     copyFromPopulateAdditional(source, result).     return result. }
true;public;2;3;/**  * Copies additional information from the source to the result.  * <p/>  * Inherited classes can override this method and copy their specific data.  *  * @param source  the source  * @param result  the result  */ ;/**  * Copies additional information from the source to the result.  * <p/>  * Inherited classes can override this method and copy their specific data.  *  * @param source  the source  * @param result  the result  */ public void copyFromPopulateAdditional(GenericFile<T> source, GenericFile<T> result) { // noop }
true;public;1;4;/**  * Bind this GenericFile to an Exchange  */ ;/**  * Bind this GenericFile to an Exchange  */ public void bindToExchange(Exchange exchange) {     GenericFileMessage<T> msg = commonBindToExchange(exchange).     populateHeaders(msg, false). }
true;public;2;4;/**  * Bind this GenericFile to an Exchange  */ ;/**  * Bind this GenericFile to an Exchange  */ public void bindToExchange(Exchange exchange, boolean isProbeContentTypeFromEndpoint) {     GenericFileMessage<T> msg = commonBindToExchange(exchange).     populateHeaders(msg, isProbeContentTypeFromEndpoint). }
false;private;1;21;;private GenericFileMessage<T> commonBindToExchange(Exchange exchange) {     Map<String, Object> headers.     exchange.setProperty(FileComponent.FILE_EXCHANGE_FILE, this).     GenericFileMessage<T> msg = new GenericFileMessage<>(exchange, this).     if (exchange.hasOut()) {         headers = exchange.getOut().hasHeaders() ? exchange.getOut().getHeaders() : null.         exchange.setOut(msg).     } else {         headers = exchange.getIn().hasHeaders() ? exchange.getIn().getHeaders() : null.         exchange.setIn(msg).     }     // preserve any existing (non file) headers, before we re-populate headers     if (headers != null) {         msg.setHeaders(headers).         // remove any file related headers, as we will re-populate file headers         msg.removeHeaders("CamelFile*").     }     return msg. }
true;public;2;41;/**  * Populates the {@link GenericFileMessage} relevant headers  *  * @param message the message to populate with headers  */ ;/**  * Populates the {@link GenericFileMessage} relevant headers  *  * @param message the message to populate with headers  */ public void populateHeaders(GenericFileMessage<T> message, boolean isProbeContentTypeFromEndpoint) {     if (message != null) {         message.setHeader(Exchange.FILE_NAME_ONLY, getFileNameOnly()).         message.setHeader(Exchange.FILE_NAME, getFileName()).         message.setHeader(Exchange.FILE_NAME_CONSUMED, getFileName()).         message.setHeader("CamelFileAbsolute", isAbsolute()).         message.setHeader("CamelFileAbsolutePath", getAbsoluteFilePath()).         if (extendedAttributes != null) {             message.setHeader("CamelFileExtendedAttributes", extendedAttributes).         }         if ((isProbeContentTypeFromEndpoint || probeContentType) && file instanceof File) {             File f = (File) file.             Path path = f.toPath().             try {                 message.setHeader(Exchange.FILE_CONTENT_TYPE, Files.probeContentType(path)).             } catch (Throwable e) {             // just ignore the exception             }         }         if (isAbsolute()) {             message.setHeader(Exchange.FILE_PATH, getAbsoluteFilePath()).         } else {             // we must normalize path according to protocol if we build our own paths             String path = normalizePathToProtocol(getEndpointPath() + File.separator + getRelativeFilePath()).             message.setHeader(Exchange.FILE_PATH, path).         }         message.setHeader("CamelFileRelativePath", getRelativeFilePath()).         message.setHeader(Exchange.FILE_PARENT, getParent()).         if (getFileLength() >= 0) {             message.setHeader(Exchange.FILE_LENGTH, getFileLength()).         }         if (getLastModified() > 0) {             message.setHeader(Exchange.FILE_LAST_MODIFIED, getLastModified()).         }     } }
false;protected;1;3;;protected boolean isAbsolute(String name) {     return FileUtil.isAbsolute(new File(name)). }
false;protected;1;3;;protected String normalizePath(String name) {     return FileUtil.normalizePath(name). }
true;public;1;59;/**  * Changes the name of this remote file. This method alters the absolute and  * relative names as well.  *  * @param newName the new name  */ ;/**  * Changes the name of this remote file. This method alters the absolute and  * relative names as well.  *  * @param newName the new name  */ public void changeFileName(String newName) {     LOG.trace("Changing name to: {}", newName).     // Make sure the names is normalized.     String newFileName = FileUtil.normalizePath(newName).     String newEndpointPath = FileUtil.normalizePath(endpointPath.endsWith("" + File.separatorChar) ? endpointPath : endpointPath + File.separatorChar).     LOG.trace("Normalized endpointPath: {}", newEndpointPath).     LOG.trace("Normalized newFileName: ()", newFileName).     File file = new File(newFileName).     if (!absolute) {         // for relative then we should avoid having the endpoint path duplicated so clip it         if (ObjectHelper.isNotEmpty(newEndpointPath) && newFileName.startsWith(newEndpointPath)) {             // in this logic here             if (newEndpointPath.endsWith("" + File.separatorChar)) {                 newFileName = StringHelper.after(newFileName, newEndpointPath).             } else {                 newFileName = StringHelper.after(newFileName, newEndpointPath + File.separatorChar).             }             // reconstruct file with clipped name             file = new File(newFileName).         }     }     // store the file name only     setFileNameOnly(file.getName()).     setFileName(file.getName()).     // relative path     if (file.getParent() != null) {         setRelativeFilePath(file.getParent() + getFileSeparator() + file.getName()).     } else {         setRelativeFilePath(file.getName()).     }     // absolute path     if (isAbsolute(newFileName)) {         setAbsolute(true).         setAbsoluteFilePath(newFileName).     } else {         setAbsolute(false).         // construct a pseudo absolute filename that the file operations uses even for relative only         String path = ObjectHelper.isEmpty(endpointPath) ? "" : endpointPath + getFileSeparator().         setAbsoluteFilePath(path + getRelativeFilePath()).     }     if (LOG.isTraceEnabled()) {         LOG.trace("FileNameOnly: {}", getFileNameOnly()).         LOG.trace("FileName: {}", getFileName()).         LOG.trace("Absolute: {}", isAbsolute()).         LOG.trace("Relative path: {}", getRelativeFilePath()).         LOG.trace("Absolute path: {}", getAbsoluteFilePath()).         LOG.trace("Name changed to: {}", this).     } }
false;public;0;3;;public String getRelativeFilePath() {     return relativeFilePath. }
false;public;1;3;;public void setRelativeFilePath(String relativeFilePath) {     this.relativeFilePath = normalizePathToProtocol(relativeFilePath). }
false;public;0;3;;public String getFileName() {     return fileName. }
false;public;1;3;;public void setFileName(String fileName) {     this.fileName = normalizePathToProtocol(fileName). }
false;public;0;3;;public long getFileLength() {     return fileLength. }
false;public;1;3;;public void setFileLength(long fileLength) {     this.fileLength = fileLength. }
false;public;0;3;;public long getLastModified() {     return lastModified. }
false;public;1;3;;public void setLastModified(long lastModified) {     this.lastModified = lastModified. }
false;public;0;3;;public String getCharset() {     return charset. }
false;public;1;3;;public void setCharset(String charset) {     this.charset = charset. }
false;public;0;3;;public Map<String, Object> getExtendedAttributes() {     return extendedAttributes. }
false;public;1;3;;public void setExtendedAttributes(Map<String, Object> extendedAttributes) {     this.extendedAttributes = extendedAttributes. }
false;public;0;4;;@Override public T getFile() {     return file. }
false;public;1;3;;public void setFile(T file) {     this.file = file. }
false;public;0;3;;public Object getBody() {     return getBinding().getBody(this). }
false;public;1;3;;public void setBody(Object os) {     getBinding().setBody(this, os). }
false;public;0;18;;public String getParent() {     String parent.     if (isAbsolute()) {         String name = getAbsoluteFilePath().         File path = new File(name).         parent = path.getParent().     } else {         String name = getRelativeFilePath().         File path.         if (name != null) {             path = new File(endpointPath, name).         } else {             path = new File(endpointPath).         }         parent = path.getParent().     }     return normalizePathToProtocol(parent). }
false;public;0;6;;public GenericFileBinding<T> getBinding() {     if (binding == null) {         binding = new GenericFileDefaultBinding<>().     }     return binding. }
false;public;1;3;;public void setBinding(GenericFileBinding<T> binding) {     this.binding = binding. }
false;public;1;3;;public void setAbsoluteFilePath(String absoluteFilePath) {     this.absoluteFilePath = normalizePathToProtocol(absoluteFilePath). }
false;public;0;3;;public String getAbsoluteFilePath() {     return absoluteFilePath. }
false;public;0;3;;public boolean isAbsolute() {     return absolute. }
false;public;1;3;;public void setAbsolute(boolean absolute) {     this.absolute = absolute. }
false;public;0;3;;public String getEndpointPath() {     return endpointPath. }
false;public;1;3;;public void setEndpointPath(String endpointPath) {     this.endpointPath = normalizePathToProtocol(endpointPath). }
false;public;0;3;;public String getFileNameOnly() {     return fileNameOnly. }
false;public;1;3;;public void setFileNameOnly(String fileNameOnly) {     this.fileNameOnly = fileNameOnly. }
false;public;0;3;;public boolean isDirectory() {     return directory. }
false;public;1;3;;public void setDirectory(boolean directory) {     this.directory = directory. }
false;public;0;3;;public String getCopyFromAbsoluteFilePath() {     return copyFromAbsoluteFilePath. }
false;public;1;3;;public void setCopyFromAbsoluteFilePath(String copyFromAbsoluteFilePath) {     this.copyFromAbsoluteFilePath = copyFromAbsoluteFilePath. }
true;protected;1;8;/**  * Fixes the path separator to be according to the protocol  */ ;/**  * Fixes the path separator to be according to the protocol  */ protected String normalizePathToProtocol(String path) {     if (ObjectHelper.isEmpty(path)) {         return path.     }     path = path.replace('/', getFileSeparator()).     path = path.replace('\\', getFileSeparator()).     return path. }
false;public;0;4;;@Override public String toString() {     return "GenericFile[" + (absolute ? absoluteFilePath : relativeFilePath) + "]". }
