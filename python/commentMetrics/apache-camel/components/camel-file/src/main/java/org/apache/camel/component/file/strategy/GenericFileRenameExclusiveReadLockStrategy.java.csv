commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public void prepareOnStartup(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint) throws Exception { // noop }
false;public;3;51;;@Override public boolean acquireExclusiveReadLock(GenericFileOperations<T> operations, GenericFile<T> file, Exchange exchange) throws Exception {     LOG.trace("Waiting for exclusive read lock to file: {}", file).     // the trick is to try to rename the file, if we can rename then we have exclusive read     // since its a Generic file we cannot use java.nio to get a RW lock     String newName = file.getFileName() + ".camelExclusiveReadLock".     // make a copy as result and change its file name     GenericFile<T> newFile = file.copyFrom(file).     newFile.changeFileName(newName).     StopWatch watch = new StopWatch().     boolean exclusive = false.     while (!exclusive) {         // timeout check         if (timeout > 0) {             long delta = watch.taken().             if (delta > timeout) {                 CamelLogger.log(LOG, readLockLoggingLevel, "Cannot acquire read lock within " + timeout + " millis. Will skip the file: " + file).                 // we could not get the lock within the timeout period, so return false                 return false.             }         }         try {             exclusive = operations.renameFile(file.getAbsoluteFilePath(), newFile.getAbsoluteFilePath()).         } catch (GenericFileOperationFailedException ex) {             if (ex.getCause() instanceof FileNotFoundException) {                 exclusive = false.             } else {                 throw ex.             }         }         if (exclusive) {             LOG.trace("Acquired exclusive read lock to file: {}", file).             // rename it back so we can read it             operations.renameFile(newFile.getAbsoluteFilePath(), file.getAbsoluteFilePath()).         } else {             boolean interrupted = sleep().             if (interrupted) {                 // we were interrupted while sleeping, we are likely being shutdown so return false                 return false.             }         }     }     return true. }
false;public;3;4;;@Override public void releaseExclusiveReadLockOnAbort(GenericFileOperations<T> operations, GenericFile<T> file, Exchange exchange) throws Exception { // noop }
false;public;3;4;;@Override public void releaseExclusiveReadLockOnRollback(GenericFileOperations<T> operations, GenericFile<T> file, Exchange exchange) throws Exception { // noop }
false;public;3;4;;@Override public void releaseExclusiveReadLockOnCommit(GenericFileOperations<T> operations, GenericFile<T> file, Exchange exchange) throws Exception { // noop }
false;private;0;10;;private boolean sleep() {     LOG.trace("Exclusive read lock not granted. Sleeping for {} millis.", checkInterval).     try {         Thread.sleep(checkInterval).         return false.     } catch (InterruptedException e) {         LOG.debug("Sleep interrupted while waiting for exclusive read lock, so breaking out").         return true.     } }
false;public;0;3;;public long getTimeout() {     return timeout. }
false;public;1;4;;@Override public void setTimeout(long timeout) {     this.timeout = timeout. }
false;public;1;4;;@Override public void setCheckInterval(long checkInterval) {     this.checkInterval = checkInterval. }
false;public;1;4;;@Override public void setReadLockLoggingLevel(LoggingLevel readLockLoggingLevel) {     this.readLockLoggingLevel = readLockLoggingLevel. }
false;public;1;4;;@Override public void setMarkerFiler(boolean markerFile) { // noop - we do not use marker file with the rename strategy }
false;public;1;4;;@Override public void setDeleteOrphanLockFiles(boolean deleteOrphanLockFiles) { // noop - we do not use marker file with the rename strategy }
