commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;@Override public void close() throws IOException { }
false;;0;3;;Publisher<Exchange> getPublisher() {     return publisher. }
false;synchronized;1;30;;synchronized void attach(ReactiveStreamsProducer producer) {     Objects.requireNonNull(producer, "producer cannot be null, use the detach method").     if (this.camelProducer != null) {         throw new IllegalStateException("A producer is already attached to the stream '" + name + "'").     }     if (this.camelProducer != producer) {         detach().         ReactiveStreamsBackpressureStrategy strategy = producer.getEndpoint().getBackpressureStrategy().         Flux<Exchange> flux = Flux.create(camelSink::set, FluxSink.OverflowStrategy.IGNORE).         if (ObjectHelper.equal(strategy, ReactiveStreamsBackpressureStrategy.OLDEST)) {             // signal item emitted for non-dropped items only             flux = flux.onBackpressureDrop(this::onBackPressure).handle(this::onItemEmitted).         } else if (ObjectHelper.equal(strategy, ReactiveStreamsBackpressureStrategy.LATEST)) {             // Since there is no callback for dropped elements on backpressure "latest", item emission is signaled before dropping             // No exception is reported back to the exchanges             flux = flux.handle(this::onItemEmitted).onBackpressureLatest().         } else {             // Default strategy is BUFFER             flux = flux.onBackpressureBuffer(Queues.SMALL_BUFFER_SIZE, this::onBackPressure).handle(this::onItemEmitted).         }         flux.subscribe(this.publisher).         camelProducer = producer.     } }
false;synchronized;0;5;;synchronized void detach() {     this.camelProducer = null.     this.camelSink.set(null). }
false;;1;6;;void send(Exchange exchange) {     if (service.isRunAllowed()) {         FluxSink<Exchange> sink = ObjectHelper.notNull(camelSink.get(), "FluxSink").         sink.next(exchange).     } }
false;private;2;6;;// ************************************** // Helpers // ************************************** private void onItemEmitted(Exchange exchange, SynchronousSink<Exchange> sink) {     if (service.isRunAllowed()) {         sink.next(exchange).         ReactiveStreamsHelper.invokeDispatchCallback(exchange).     } }
false;private;1;6;;private void onBackPressure(Exchange exchange) {     ReactiveStreamsHelper.invokeDispatchCallback(exchange, new ReactiveStreamsDiscardedException("Discarded by back pressure strategy", exchange, name)). }
