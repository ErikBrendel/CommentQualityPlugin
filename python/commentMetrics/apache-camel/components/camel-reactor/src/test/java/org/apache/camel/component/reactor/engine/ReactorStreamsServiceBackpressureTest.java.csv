commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override public void configure() throws Exception {     from("timer:gen?period=20&repeatCount=20").setBody().header(Exchange.TIMER_COUNTER).to("reactive-streams:integers"). }
false;public;0;34;;@Test public void testBufferStrategy() throws Exception {     getReactiveStreamsComponent().setBackpressureStrategy(ReactiveStreamsBackpressureStrategy.BUFFER).     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             from("timer:gen?period=20&repeatCount=20").setBody().header(Exchange.TIMER_COUNTER).to("reactive-streams:integers").         }     }).     Flux<Integer> integers = Flux.from(crs.fromStream("integers", Integer.class)).     ConcurrentLinkedQueue<Integer> queue = new ConcurrentLinkedQueue<>().     CountDownLatch latch = new CountDownLatch(1).     Flux.range(0, 50).zipWith(integers, (l, i) -> i).timeout(Duration.ofMillis(2000), Flux.empty()).doOnComplete(latch::countDown).subscribe(queue::add).     context.start().     Assert.assertTrue(latch.await(5, TimeUnit.SECONDS)).     Assert.assertEquals(20, queue.size()).     int num = 1.     for (int i : queue) {         Assert.assertEquals(num++, i).     } }
false;public;0;7;;@Override public void configure() throws Exception {     from("timer:gen?period=20&repeatCount=20").setBody().header(Exchange.TIMER_COUNTER).to("reactive-streams:integers"). }
false;public;1;6;;@Override public void onNext(Integer o) {     queue.add(o).     latch.countDown().     latch2.countDown(). }
false;public;0;46;;@Test public void testDropStrategy() throws Exception {     getReactiveStreamsComponent().setBackpressureStrategy(ReactiveStreamsBackpressureStrategy.OLDEST).     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             from("timer:gen?period=20&repeatCount=20").setBody().header(Exchange.TIMER_COUNTER).to("reactive-streams:integers").         }     }).     final ConcurrentLinkedQueue<Integer> queue = new ConcurrentLinkedQueue<>().     final CountDownLatch latch = new CountDownLatch(1).     final CountDownLatch latch2 = new CountDownLatch(2).     TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>() {          @Override         public void onNext(Integer o) {             queue.add(o).             latch.countDown().             latch2.countDown().         }     }.     subscriber.setInitiallyRequested(1).     crs.fromStream("integers", Integer.class).subscribe(subscriber).     context.start().     Assert.assertTrue(latch.await(5, TimeUnit.SECONDS)).     // wait for all numbers to be generated     Thread.sleep(1000).     subscriber.request(19).     Assert.assertTrue(latch2.await(1, TimeUnit.SECONDS)).     // add other time to ensure no other items arrive     Thread.sleep(200).     Assert.assertEquals(2, queue.size()).     int sum = queue.stream().reduce((i, j) -> i + j).get().     // 1 + 2 = 3     Assert.assertEquals(3, sum).     subscriber.cancel(). }
false;public;0;7;;@Override public void configure() throws Exception {     from("timer:gen?period=20&repeatCount=20").setBody().header(Exchange.TIMER_COUNTER).to("reactive-streams:integers"). }
false;public;1;6;;@Override public void onNext(Integer o) {     queue.add(o).     latch1.countDown().     latch2.countDown(). }
false;public;0;50;;@Test public void testLatestStrategy() throws Exception {     getReactiveStreamsComponent().setBackpressureStrategy(ReactiveStreamsBackpressureStrategy.LATEST).     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             from("timer:gen?period=20&repeatCount=20").setBody().header(Exchange.TIMER_COUNTER).to("reactive-streams:integers").         }     }).     final ConcurrentLinkedQueue<Integer> queue = new ConcurrentLinkedQueue<>().     final CountDownLatch latch1 = new CountDownLatch(1).     final CountDownLatch latch2 = new CountDownLatch(2).     TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>() {          @Override         public void onNext(Integer o) {             queue.add(o).             latch1.countDown().             latch2.countDown().         }     }.     subscriber.setInitiallyRequested(1).     crs.fromStream("integers", Integer.class).subscribe(subscriber).     context.start().     Assert.assertTrue(latch1.await(5, TimeUnit.SECONDS)).     // wait for all numbers to be generated     Thread.sleep(1000).     subscriber.request(19).     Assert.assertTrue(latch2.await(1, TimeUnit.SECONDS)).     // add other time to ensure no other items arrive     Thread.sleep(200).     // TODO: the chain caches two elements instead of one: change it if you find an EmitterProcessor without prefetch     // Assert.assertEquals(2, queue.size()).     Assert.assertEquals(3, queue.size()).     int sum = queue.stream().reduce((i, j) -> i + j).get().     // Assert.assertEquals(21, sum). // 1 + 20 = 21     // 1 + 2 + 20 = 23     Assert.assertEquals(23, sum).     subscriber.cancel(). }
