commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;7;;// ************************************************ // Setup // ************************************************ @Override protected JndiRegistry createRegistry() throws Exception {     JndiRegistry registry = super.createRegistry().     registry.bind("hello", new SampleBean()).     return registry. }
false;public;1;3;;public String hello(String name) {     return "Hello " + name. }
false;public;0;4;;public void configure() {     from("direct:reactive").to("reactive-streams:numbers"). }
false;public;0;22;;// ************************************************ // fromStream/from // ************************************************ @Test public void testFromStreamDirect() throws Exception {     context.addRoutes(new RouteBuilder() {          public void configure() {             from("direct:reactive").to("reactive-streams:numbers").         }     }).     context.start().     ProducerTemplate template = context.createProducerTemplate().     AtomicInteger value = new AtomicInteger(0).     Flux.from(crs.fromStream("numbers", Integer.class)).doOnNext(res -> Assert.assertEquals(value.incrementAndGet(), res.intValue())).subscribe().     template.sendBody("direct:reactive", 1).     template.sendBody("direct:reactive", 2).     template.sendBody("direct:reactive", 3). }
false;public;0;7;;@Override public void configure() throws Exception {     from("timer:tick?period=5&repeatCount=30").setBody().header(Exchange.TIMER_COUNTER).to("reactive-streams:tick"). }
false;public;0;27;;@Test public void testFromStreamTimer() throws Exception {     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             from("timer:tick?period=5&repeatCount=30").setBody().header(Exchange.TIMER_COUNTER).to("reactive-streams:tick").         }     }).     final int num = 30.     final CountDownLatch latch = new CountDownLatch(num).     final AtomicInteger value = new AtomicInteger(0).     Flux.from(crs.fromStream("tick", Integer.class)).doOnNext(res -> Assert.assertEquals(value.incrementAndGet(), res.intValue())).doOnNext(n -> latch.countDown()).subscribe().     context.start().     latch.await(5, TimeUnit.SECONDS).     Assert.assertEquals(num, value.get()). }
false;public;0;5;;@Override public void configure() throws Exception {     from("direct:reactive").to("reactive-streams:direct"). }
false;public;0;27;;@Test public void testFromStreamMultipleSubscriptionsWithDirect() throws Exception {     context.start().     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             from("direct:reactive").to("reactive-streams:direct").         }     }).     CountDownLatch latch1 = new CountDownLatch(2).     Flux.from(crs.fromStream("direct", Integer.class)).doOnNext(res -> latch1.countDown()).subscribe().     CountDownLatch latch2 = new CountDownLatch(2).     Flux.from(crs.fromStream("direct", Integer.class)).doOnNext(res -> latch2.countDown()).subscribe().     template.sendBody("direct:reactive", 1).     template.sendBody("direct:reactive", 2).     Assert.assertTrue(latch1.await(5, TimeUnit.SECONDS)).     Assert.assertTrue(latch2.await(5, TimeUnit.SECONDS)). }
false;public;0;6;;@Override public void configure() throws Exception {     from("timer:tick?period=50").setBody().header(Exchange.TIMER_COUNTER).to("reactive-streams:tick"). }
false;public;0;37;;@Test public void testMultipleSubscriptionsWithTimer() throws Exception {     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             from("timer:tick?period=50").setBody().header(Exchange.TIMER_COUNTER).to("reactive-streams:tick").         }     }).     CountDownLatch latch1 = new CountDownLatch(5).     Disposable disp1 = Flux.from(crs.fromStream("tick", Integer.class)).subscribe(res -> latch1.countDown()).     context.start().     // Add another subscription     CountDownLatch latch2 = new CountDownLatch(5).     Disposable disp2 = Flux.from(crs.fromStream("tick", Integer.class)).subscribe(res -> latch2.countDown()).     assertTrue(latch1.await(5, TimeUnit.SECONDS)).     assertTrue(latch2.await(5, TimeUnit.SECONDS)).     // Un subscribe both     disp1.dispose().     disp2.dispose().     // No active subscriptions, warnings expected     Thread.sleep(60).     // Add another subscription     CountDownLatch latch3 = new CountDownLatch(5).     Disposable disp3 = Flux.from(crs.fromStream("tick", Integer.class)).subscribe(res -> latch3.countDown()).     assertTrue(latch3.await(5, TimeUnit.SECONDS)).     disp3.dispose(). }
false;public;0;17;;@Test public void testFrom() throws Exception {     context.start().     Publisher<Exchange> timer = crs.from("timer:reactive?period=250&repeatCount=3").     AtomicInteger value = new AtomicInteger(0).     CountDownLatch latch = new CountDownLatch(3).     Flux.from(timer).map(exchange -> ExchangeHelper.getHeaderOrProperty(exchange, Exchange.TIMER_COUNTER, Integer.class)).doOnNext(res -> Assert.assertEquals(value.incrementAndGet(), res.intValue())).doOnNext(res -> latch.countDown()).subscribe().     Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)). }
false;public;0;7;;@Override public void configure() throws Exception {     from("direct:source").to("direct:stream").setBody().simple("after stream: ${body}"). }
false;public;0;32;;// ************************************************ // fromPublisher // ************************************************ @Test public void testFromPublisher() throws Exception {     context.start().     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             from("direct:source").to("direct:stream").setBody().simple("after stream: ${body}").         }     }).     crs.process("direct:stream", publisher -> Flux.from(publisher).map(e -> {         int i = e.getIn().getBody(Integer.class).         e.getOut().setBody(-i).         return e.     })).     for (int i = 1. i <= 3. i++) {         Assert.assertEquals("after stream: " + (-i), template.requestBody("direct:source", i, String.class)).     } }
false;public;0;7;;@Override public void configure() throws Exception {     from("direct:source").to("direct:stream").setBody().simple("after stream: ${body}"). }
false;public;0;26;;@Test public void testFromPublisherWithConversion() throws Exception {     context.start().     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             from("direct:source").to("direct:stream").setBody().simple("after stream: ${body}").         }     }).     crs.process("direct:stream", Integer.class, publisher -> Flux.from(publisher).map(Math::negateExact)).     for (int i = 1. i <= 3. i++) {         Assert.assertEquals("after stream: " + (-i), template.requestBody("direct:source", i, String.class)).     } }
false;public;0;4;;public void configure() {     from("reactive-streams:reactive").setBody().constant("123"). }
false;public;0;21;;// ************************************************ // toStream/to // ************************************************ @Test public void testToStream() throws Exception {     context.addRoutes(new RouteBuilder() {          public void configure() {             from("reactive-streams:reactive").setBody().constant("123").         }     }).     context.start().     Publisher<Exchange> publisher = crs.toStream("reactive", new DefaultExchange(context)).     Exchange res = Flux.from(publisher).blockFirst().     Assert.assertNotNull(res).     String content = res.getIn().getBody(String.class).     Assert.assertNotNull(content).     Assert.assertEquals("123", content). }
false;public;0;16;;@Test public void testTo() throws Exception {     context.start().     Set<String> values = Collections.synchronizedSet(new TreeSet<>()).     CountDownLatch latch = new CountDownLatch(3).     Flux.just(1, 2, 3).flatMap(e -> crs.to("bean:hello", e, String.class)).doOnNext(res -> values.add(res)).doOnNext(res -> latch.countDown()).subscribe().     Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)).     Assert.assertEquals(new TreeSet<>(Arrays.asList("Hello 1", "Hello 2", "Hello 3")), values). }
false;public;0;18;;@Test public void testToWithExchange() throws Exception {     context.start().     Set<String> values = Collections.synchronizedSet(new TreeSet<>()).     CountDownLatch latch = new CountDownLatch(3).     Flux.just(1, 2, 3).flatMap(e -> crs.to("bean:hello", e)).map(e -> e.getOut()).map(e -> e.getBody(String.class)).doOnNext(res -> values.add(res)).doOnNext(res -> latch.countDown()).subscribe().     Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)).     Assert.assertEquals(new TreeSet<>(Arrays.asList("Hello 1", "Hello 2", "Hello 3")), values). }
false;public;0;17;;@Test public void testToFunction() throws Exception {     context.start().     Set<String> values = Collections.synchronizedSet(new TreeSet<>()).     CountDownLatch latch = new CountDownLatch(3).     Function<Object, Publisher<String>> fun = crs.to("bean:hello", String.class).     Flux.just(1, 2, 3).flatMap(fun).doOnNext(res -> values.add(res)).doOnNext(res -> latch.countDown()).subscribe().     Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)).     Assert.assertEquals(new TreeSet<>(Arrays.asList("Hello 1", "Hello 2", "Hello 3")), values). }
false;public;0;19;;@Test public void testToFunctionWithExchange() throws Exception {     context.start().     Set<String> values = Collections.synchronizedSet(new TreeSet<>()).     CountDownLatch latch = new CountDownLatch(3).     Function<Object, Publisher<Exchange>> fun = crs.to("bean:hello").     Flux.just(1, 2, 3).flatMap(fun).map(e -> e.getOut()).map(e -> e.getBody(String.class)).doOnNext(res -> values.add(res)).doOnNext(res -> latch.countDown()).subscribe().     Assert.assertTrue(latch.await(2, TimeUnit.SECONDS)).     Assert.assertEquals(new TreeSet<>(Arrays.asList("Hello 1", "Hello 2", "Hello 3")), values). }
false;public;0;5;;@Override public void configure() throws Exception {     from("direct:reactor").to("mock:result"). }
false;public;0;23;;// ************************************************ // subscriber // ************************************************ @Test public void testSubscriber() throws Exception {     context.start().     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             from("direct:reactor").to("mock:result").         }     }).     Flux.just(1, 2, 3).subscribe(crs.subscriber("direct:reactor", Integer.class)).     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMessageCount(3).     mock.assertIsSatisfied().     int idx = 1.     for (Exchange ex : mock.getExchanges()) {         Assert.assertEquals(new Integer(idx++), ex.getIn().getBody(Integer.class)).     } }
false;public;0;7;;@Override public void configure() throws Exception {     from("direct:one").to("reactive-streams:stream").     from("direct:two").to("reactive-streams:stream"). }
false;public;0;14;;// ************************************************ // misc // ************************************************ @Test(expected = FailedToCreateRouteException.class) public void testOnlyOneCamelProducerPerPublisher() throws Exception {     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             from("direct:one").to("reactive-streams:stream").             from("direct:two").to("reactive-streams:stream").         }     }).     context.start(). }
