commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isSingleton() {     return true. }
false;public;1;3;;public Consumer createConsumer(Processor processor) throws Exception {     throw new UnsupportedOperationException("Not supported"). }
false;public;0;3;;public Producer createProducer() throws Exception {     return new JdbcProducer(this, dataSource, readSize, parameters). }
false;public;0;3;;public String getDataSourceName() {     return dataSourceName. }
true;public;1;3;/**  * Name of DataSource to lookup in the Registry. If the name is dataSource or default, then Camel  * will attempt to lookup a default DataSource from the registry, meaning if there is a only  * one instance of DataSource found, then this DataSource will be used.  */ ;/**  * Name of DataSource to lookup in the Registry. If the name is dataSource or default, then Camel  * will attempt to lookup a default DataSource from the registry, meaning if there is a only  * one instance of DataSource found, then this DataSource will be used.  */ public void setDataSourceName(String dataSourceName) {     this.dataSourceName = dataSourceName. }
false;public;0;3;;public int getReadSize() {     return readSize. }
true;public;1;3;/**  * The default maximum number of rows that can be read by a polling query. The default value is 0.  */ ;/**  * The default maximum number of rows that can be read by a polling query. The default value is 0.  */ public void setReadSize(int readSize) {     this.readSize = readSize. }
false;public;0;3;;public boolean isTransacted() {     return transacted. }
true;public;1;3;/**  * Whether transactions are in use.  */ ;/**  * Whether transactions are in use.  */ public void setTransacted(boolean transacted) {     this.transacted = transacted. }
false;public;0;3;;public boolean isResetAutoCommit() {     return resetAutoCommit. }
true;public;1;3;/**  * Camel will set the autoCommit on the JDBC connection to be false, commit the change after executed the statement and reset  * the autoCommit flag of the connection at the end, if the resetAutoCommit is true. If the JDBC connection doesn't support  * to reset the autoCommit flag, you can set the resetAutoCommit flag to be false, and Camel will not try to reset the autoCommit flag.  * When used with XA transactions you most likely need to set it to false so that the transaction manager is in charge of committing this tx.  */ ;/**  * Camel will set the autoCommit on the JDBC connection to be false, commit the change after executed the statement and reset  * the autoCommit flag of the connection at the end, if the resetAutoCommit is true. If the JDBC connection doesn't support  * to reset the autoCommit flag, you can set the resetAutoCommit flag to be false, and Camel will not try to reset the autoCommit flag.  * When used with XA transactions you most likely need to set it to false so that the transaction manager is in charge of committing this tx.  */ public void setResetAutoCommit(boolean resetAutoCommit) {     this.resetAutoCommit = resetAutoCommit. }
false;public;0;3;;public DataSource getDataSource() {     return dataSource. }
true;public;1;3;/**  * The data source to use  */ ;/**  * The data source to use  */ public void setDataSource(DataSource dataSource) {     this.dataSource = dataSource. }
false;public;0;3;;public Map<String, Object> getParameters() {     return parameters. }
true;public;1;3;/**  * Optional parameters to the {@link java.sql.Statement}.  * <p/>  * For example to set maxRows, fetchSize etc.  *  * @param parameters parameters which will be set using reflection  */ ;/**  * Optional parameters to the {@link java.sql.Statement}.  * <p/>  * For example to set maxRows, fetchSize etc.  *  * @param parameters parameters which will be set using reflection  */ public void setParameters(Map<String, Object> parameters) {     this.parameters = parameters. }
false;public;0;3;;public boolean isUseJDBC4ColumnNameAndLabelSemantics() {     return useJDBC4ColumnNameAndLabelSemantics. }
true;public;1;3;/**  * Sets whether to use JDBC 4 or JDBC 3.0 or older semantic when retrieving column name.  * <p/>  * JDBC 4.0 uses columnLabel to get the column name where as JDBC 3.0 uses both columnName or columnLabel.  * Unfortunately JDBC drivers behave differently so you can use this option to work out issues around your  * JDBC driver if you get problem using this component  * <p/>  * This option is default <tt>true</tt>.  *  * @param useJDBC4ColumnNameAndLabelSemantics <tt>true</tt> to use JDBC 4.0 semantics, <tt>false</tt> to use JDBC 3.0.  */ ;/**  * Sets whether to use JDBC 4 or JDBC 3.0 or older semantic when retrieving column name.  * <p/>  * JDBC 4.0 uses columnLabel to get the column name where as JDBC 3.0 uses both columnName or columnLabel.  * Unfortunately JDBC drivers behave differently so you can use this option to work out issues around your  * JDBC driver if you get problem using this component  * <p/>  * This option is default <tt>true</tt>.  *  * @param useJDBC4ColumnNameAndLabelSemantics <tt>true</tt> to use JDBC 4.0 semantics, <tt>false</tt> to use JDBC 3.0.  */ public void setUseJDBC4ColumnNameAndLabelSemantics(boolean useJDBC4ColumnNameAndLabelSemantics) {     this.useJDBC4ColumnNameAndLabelSemantics = useJDBC4ColumnNameAndLabelSemantics. }
false;public;0;3;;public JdbcPrepareStatementStrategy getPrepareStatementStrategy() {     return prepareStatementStrategy. }
true;public;1;3;/**  * Allows to plugin to use a custom org.apache.camel.component.jdbc.JdbcPrepareStatementStrategy to control preparation of the query and prepared statement.  */ ;/**  * Allows to plugin to use a custom org.apache.camel.component.jdbc.JdbcPrepareStatementStrategy to control preparation of the query and prepared statement.  */ public void setPrepareStatementStrategy(JdbcPrepareStatementStrategy prepareStatementStrategy) {     this.prepareStatementStrategy = prepareStatementStrategy. }
false;public;0;3;;public boolean isAllowNamedParameters() {     return allowNamedParameters. }
true;public;1;3;/**  * Whether to allow using named parameters in the queries.  */ ;/**  * Whether to allow using named parameters in the queries.  */ public void setAllowNamedParameters(boolean allowNamedParameters) {     this.allowNamedParameters = allowNamedParameters. }
false;public;0;3;;public boolean isUseHeadersAsParameters() {     return useHeadersAsParameters. }
true;public;1;3;/**  * Set this option to true to use the prepareStatementStrategy with named parameters.  * This allows to define queries with named placeholders, and use headers with the dynamic values for the query placeholders.  */ ;/**  * Set this option to true to use the prepareStatementStrategy with named parameters.  * This allows to define queries with named placeholders, and use headers with the dynamic values for the query placeholders.  */ public void setUseHeadersAsParameters(boolean useHeadersAsParameters) {     this.useHeadersAsParameters = useHeadersAsParameters. }
false;public;0;3;;public JdbcOutputType getOutputType() {     return outputType. }
true;public;1;3;/**  * Determines the output the producer should use.  */ ;/**  * Determines the output the producer should use.  */ public void setOutputType(JdbcOutputType outputType) {     this.outputType = outputType. }
false;public;0;3;;public String getOutputClass() {     return outputClass. }
true;public;1;3;/**  * Specify the full package and class name to use as conversion when outputType=SelectOne or SelectList.  */ ;/**  * Specify the full package and class name to use as conversion when outputType=SelectOne or SelectList.  */ public void setOutputClass(String outputClass) {     this.outputClass = outputClass. }
false;public;0;3;;public BeanRowMapper getBeanRowMapper() {     return beanRowMapper. }
true;public;1;3;/**  * To use a custom org.apache.camel.component.jdbc.BeanRowMapper when using outputClass.  * The default implementation will lower case the row names and skip underscores, and dashes. For example "CUST_ID" is mapped as "custId".  */ ;/**  * To use a custom org.apache.camel.component.jdbc.BeanRowMapper when using outputClass.  * The default implementation will lower case the row names and skip underscores, and dashes. For example "CUST_ID" is mapped as "custId".  */ public void setBeanRowMapper(BeanRowMapper beanRowMapper) {     this.beanRowMapper = beanRowMapper. }
false;public;0;3;;public boolean isUseGetBytesForBlob() {     return this.useGetBytesForBlob. }
true;public;1;3;/**  * To read BLOB columns as bytes instead of string data.  * <p/>  * This may be needed for certain databases such as Oracle where you must read BLOB columns as bytes.  */ ;/**  * To read BLOB columns as bytes instead of string data.  * <p/>  * This may be needed for certain databases such as Oracle where you must read BLOB columns as bytes.  */ public void setUseGetBytesForBlob(boolean useGetBytesForBlob) {     this.useGetBytesForBlob = useGetBytesForBlob. }
false;protected;0;4;;@Override protected String createEndpointUri() {     return dataSourceName != null ? "jdbc:" + dataSourceName : "jdbc". }
