commented;modifiers;parameterAmount;loc;comment;code
false;public;2;13;;@Override public String prepareQuery(String query, boolean allowNamedParameters) throws SQLException {     String answer.     if (allowNamedParameters && hasNamedParameters(query)) {         // replace all :?word with just ?         answer = query.replaceAll("\\:\\?\\w+", "\\?").     } else {         answer = query.     }     LOG.trace("Prepared query: {}", answer).     return answer. }
false;public;0;8;;@Override public boolean hasNext() {     if (!done && !preFetched) {         next().         preFetched = true.     }     return !done. }
false;public;0;18;;@Override public Object next() {     if (!preFetched) {         String key = parser.next().         if (key == null) {             done = true.             return null.         }         // the key is expected to exist, if not report so end user can see this         boolean contains = headerMap != null && headerMap.containsKey(key).         if (!contains) {             throw new RuntimeExchangeException("Cannot find key [" + key + "] in message body or headers to use when setting named parameter in query [" + query + "]", exchange).         }         next = headerMap.get(key).     }     preFetched = false.     return next. }
false;public;0;4;;@Override public void remove() { // noop }
false;public;5;67;;@Override public Iterator<?> createPopulateIterator(final String query, final String preparedQuery, final int expectedParams, final Exchange exchange, final Object value) throws SQLException {     Map<?, ?> map = null.     if (exchange.getIn().hasHeaders()) {         if (exchange.getIn().getHeader(JdbcConstants.JDBC_PARAMETERS) != null) {             // header JDBC_PARAMETERS takes precedence over regular headers             map = exchange.getIn().getHeader(JdbcConstants.JDBC_PARAMETERS, Map.class).         } else {             map = exchange.getIn().getHeaders().         }     }     final Map<?, ?> headerMap = map.     if (hasNamedParameters(query)) {         // create an iterator that returns the value in the named order         try {             return new Iterator<Object>() {                  private NamedQueryParser parser = new NamedQueryParser(query).                  private Object next.                  private boolean done.                  private boolean preFetched.                  @Override                 public boolean hasNext() {                     if (!done && !preFetched) {                         next().                         preFetched = true.                     }                     return !done.                 }                  @Override                 public Object next() {                     if (!preFetched) {                         String key = parser.next().                         if (key == null) {                             done = true.                             return null.                         }                         // the key is expected to exist, if not report so end user can see this                         boolean contains = headerMap != null && headerMap.containsKey(key).                         if (!contains) {                             throw new RuntimeExchangeException("Cannot find key [" + key + "] in message body or headers to use when setting named parameter in query [" + query + "]", exchange).                         }                         next = headerMap.get(key).                     }                     preFetched = false.                     return next.                 }                  @Override                 public void remove() {                 // noop                 }             }.         } catch (Exception e) {             throw new SQLException("Error iterating parameters for the query: " + query, e).         }     } else {         // just use a regular iterator         return exchange.getContext().getTypeConverter().convertTo(Iterator.class, headerMap != null ? headerMap.values() : null).     } }
false;public;3;17;;@Override public void populateStatement(PreparedStatement ps, Iterator<?> iterator, int expectedParams) throws SQLException {     int argNumber = 1.     if (expectedParams > 0) {         // as the headers may have more values than the SQL needs we just break out when we reached the expected number         while (iterator != null && iterator.hasNext() && argNumber <= expectedParams) {             Object value = iterator.next().             LOG.trace("Setting parameter #{} with value: {}", argNumber, value).             ps.setObject(argNumber, value).             argNumber++.         }     }     if (argNumber - 1 != expectedParams) {         throw new SQLException("Number of parameters mismatch. Expected: " + expectedParams + ", was:" + (argNumber - 1)).     } }
false;protected;1;4;;protected boolean hasNamedParameters(String query) {     NamedQueryParser parser = new NamedQueryParser(query).     return parser.next() != null. }
false;public;0;7;;public String next() {     if (!matcher.find()) {         return null.     }     return matcher.group(1). }
