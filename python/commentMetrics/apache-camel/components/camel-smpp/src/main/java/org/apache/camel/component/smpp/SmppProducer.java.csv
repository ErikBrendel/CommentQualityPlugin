commented;modifiers;parameterAmount;loc;comment;code
false;public;3;12;;@Override public void onStateChange(SessionState newState, SessionState oldState, Session source) {     if (configuration.getSessionStateListener() != null) {         configuration.getSessionStateListener().onStateChange(newState, oldState, source).     }     if (newState.equals(SessionState.CLOSED)) {         log.warn("Lost connection to: {} - trying to reconnect...", getEndpoint().getConnectionString()).         closeSession().         reconnect(configuration.getInitialReconnectDelay()).     } }
false;protected;0;14;;@Override protected void doStart() throws Exception {     super.doStart().     if (!getConfiguration().isLazySessionCreation()) {         if (connectLock.tryLock()) {             try {                 session = createSession().             } finally {                 connectLock.unlock().             }         }     } }
false;private;0;23;;private SMPPSession createSession() throws IOException {     log.debug("Connecting to: {}...", getEndpoint().getConnectionString()).     SMPPSession session = createSMPPSession().     session.setEnquireLinkTimer(this.configuration.getEnquireLinkTimer()).     session.setTransactionTimer(this.configuration.getTransactionTimer()).     session.addSessionStateListener(internalSessionStateListener).     session.connectAndBind(this.configuration.getHost(), this.configuration.getPort(), new BindParameter(BindType.BIND_TX, this.configuration.getSystemId(), this.configuration.getPassword(), this.configuration.getSystemType(), TypeOfNumber.valueOf(configuration.getTypeOfNumber()), NumberingPlanIndicator.valueOf(configuration.getNumberingPlanIndicator()), "")).     log.info("Connected to: {}", getEndpoint().getConnectionString()).     return session. }
true;;0;5;/**  * Factory method to easily instantiate a mock SMPPSession  *  * @return the SMPPSession  */ ;/**  * Factory method to easily instantiate a mock SMPPSession  *  * @return the SMPPSession  */ SMPPSession createSMPPSession() {     return new SMPPSession(new SynchronizedPDUSender(new DefaultPDUSender(new DefaultComposer())), new DefaultPDUReader(), SmppConnectionFactory.getInstance(configuration)). }
false;public;1;32;;public void process(Exchange exchange) throws Exception {     if (session == null) {         if (this.configuration.isLazySessionCreation()) {             if (connectLock.tryLock()) {                 try {                     if (session == null) {                         // set the system id and password with which we will try to connect to the SMSC                         Message in = exchange.getIn().                         String systemId = in.getHeader(SmppConstants.SYSTEM_ID, String.class).                         String password = in.getHeader(SmppConstants.PASSWORD, String.class).                         if (systemId != null && password != null) {                             log.info("using the system id '{}' to connect to the SMSC...", systemId).                             this.configuration.setSystemId(systemId).                             this.configuration.setPassword(password).                         }                         session = createSession().                     }                 } finally {                     connectLock.unlock().                 }             }         }     }     // only possible by trying to reconnect     if (this.session == null) {         throw new IOException("Lost connection to " + getEndpoint().getConnectionString() + " and yet not reconnected").     }     SmppCommand command = getEndpoint().getBinding().createSmppCommand(session, exchange).     command.execute(exchange). }
false;protected;0;9;;@Override protected void doStop() throws Exception {     log.debug("Disconnecting from: {}...", getEndpoint().getConnectionString()).     super.doStop().     closeSession().     log.info("Disconnected from: {}", getEndpoint().getConnectionString()). }
false;private;0;8;;private void closeSession() {     if (session != null) {         session.removeSessionStateListener(this.internalSessionStateListener).         session.unbindAndClose().         // clear session as we closed it successfully         session = null.     } }
false;public;0;31;;public void run() {     boolean reconnected = false.     log.info("Schedule reconnect after {} millis", initialReconnectDelay).     try {         Thread.sleep(initialReconnectDelay).     } catch (InterruptedException e) {     }     int attempt = 0.     while (!(isStopping() || isStopped()) && (session == null || session.getSessionState().equals(SessionState.CLOSED)) && attempt < configuration.getMaxReconnect()) {         try {             attempt++.             log.info("Trying to reconnect to {} - attempt #{}", getEndpoint().getConnectionString(), attempt).             session = createSession().             reconnected = true.         } catch (IOException e) {             log.warn("Failed to reconnect to {}", getEndpoint().getConnectionString()).             closeSession().             try {                 Thread.sleep(configuration.getReconnectDelay()).             } catch (InterruptedException ee) {             }         }     }     if (reconnected) {         log.info("Reconnected to {}", getEndpoint().getConnectionString()).     } }
false;private;1;47;;private void reconnect(final long initialReconnectDelay) {     if (connectLock.tryLock()) {         try {             Runnable r = new Runnable() {                  public void run() {                     boolean reconnected = false.                     log.info("Schedule reconnect after {} millis", initialReconnectDelay).                     try {                         Thread.sleep(initialReconnectDelay).                     } catch (InterruptedException e) {                     }                     int attempt = 0.                     while (!(isStopping() || isStopped()) && (session == null || session.getSessionState().equals(SessionState.CLOSED)) && attempt < configuration.getMaxReconnect()) {                         try {                             attempt++.                             log.info("Trying to reconnect to {} - attempt #{}", getEndpoint().getConnectionString(), attempt).                             session = createSession().                             reconnected = true.                         } catch (IOException e) {                             log.warn("Failed to reconnect to {}", getEndpoint().getConnectionString()).                             closeSession().                             try {                                 Thread.sleep(configuration.getReconnectDelay()).                             } catch (InterruptedException ee) {                             }                         }                     }                     if (reconnected) {                         log.info("Reconnected to {}", getEndpoint().getConnectionString()).                     }                 }             }.             Thread t = new Thread(r).             t.start().             t.join().         } catch (InterruptedException e) {         // noop         } finally {             connectLock.unlock().         }     } }
false;public;0;4;;@Override public SmppEndpoint getEndpoint() {     return (SmppEndpoint) super.getEndpoint(). }
true;public;0;3;/**  * Returns the smppConfiguration for this producer  *  * @return the configuration  */ ;/**  * Returns the smppConfiguration for this producer  *  * @return the configuration  */ public SmppConfiguration getConfiguration() {     return configuration. }
false;public;0;4;;@Override public String toString() {     return "SmppProducer[" + getEndpoint().getConnectionString() + "]". }
