commented;modifiers;parameterAmount;loc;comment;code
true;public;1;20;/**  * A POJO which contains all necessary configuration parameters for the SMPP connection  *  * @param uri the full URI of the endpoint  */ ;/**  * A POJO which contains all necessary configuration parameters for the SMPP connection  *  * @param uri the full URI of the endpoint  */ public void configureFromURI(URI uri) {     String userInfo = uri.getUserInfo().     if (userInfo != null) {         setSystemId(uri.getUserInfo()).     }     String host = uri.getHost().     if (host != null) {         setHost(host).     }     int port = uri.getPort().     if (port > 0) {         setPort(port).     }     if (uri.getScheme().startsWith("smpps")) {         setUsingSSL(true).     } }
false;public;0;7;;public SmppConfiguration copy() {     try {         return (SmppConfiguration) clone().     } catch (CloneNotSupportedException e) {         throw new RuntimeCamelException(e).     } }
false;public;0;3;;public String getHost() {     return host. }
true;public;1;3;/**  * Hostname for the SMSC server to use.  */ ;/**  * Hostname for the SMSC server to use.  */ public void setHost(String host) {     this.host = host. }
false;public;0;3;;public Integer getPort() {     return port. }
true;public;1;3;/**  * Port number for the SMSC server to use.  */ ;/**  * Port number for the SMSC server to use.  */ public void setPort(Integer port) {     this.port = port. }
false;public;0;3;;public String getSystemId() {     return systemId. }
true;public;1;3;/**  * The system id (username) for connecting to SMSC server.  */ ;/**  * The system id (username) for connecting to SMSC server.  */ public void setSystemId(String systemId) {     this.systemId = systemId. }
true;public;0;3;/**  * The password for connecting to SMSC server.  */ ;/**  * The password for connecting to SMSC server.  */ public String getPassword() {     return password. }
false;public;0;3;;public byte getDataCoding() {     return dataCoding. }
true;public;1;3;/**  * Defines the data coding according the SMPP 3.4 specification, section 5.2.19.  * Example data encodings are:  * <ul>  *     <li>0: SMSC Default Alphabet</li>  *     <li>3: Latin 1 (ISO-8859-1)</li>  *     <li>4: Octet unspecified (8-bit binary)</li>  *     <li>8: UCS2 (ISO/IEC-10646)</li>  *     <li>13: Extended Kanji JIS(X 0212-1990)</li>  * </ul>  */ ;/**  * Defines the data coding according the SMPP 3.4 specification, section 5.2.19.  * Example data encodings are:  * <ul>  *     <li>0: SMSC Default Alphabet</li>  *     <li>3: Latin 1 (ISO-8859-1)</li>  *     <li>4: Octet unspecified (8-bit binary)</li>  *     <li>8: UCS2 (ISO/IEC-10646)</li>  *     <li>13: Extended Kanji JIS(X 0212-1990)</li>  * </ul>  */ public void setDataCoding(byte dataCoding) {     this.dataCoding = dataCoding. }
false;public;0;3;;public byte getAlphabet() {     return alphabet. }
true;public;1;3;/**  * Defines encoding of data according the SMPP 3.4 specification, section 5.2.19.  * <ul>  *     <li>0: SMSC Default Alphabet  *     <li>4: 8 bit Alphabet</li>  *     <li>8: UCS2 Alphabet</li></li>  * </ul>  */ ;/**  * Defines encoding of data according the SMPP 3.4 specification, section 5.2.19.  * <ul>  *     <li>0: SMSC Default Alphabet  *     <li>4: 8 bit Alphabet</li>  *     <li>8: UCS2 Alphabet</li></li>  * </ul>  */ public void setAlphabet(byte alphabet) {     this.alphabet = alphabet. }
false;public;0;3;;public String getEncoding() {     return encoding. }
true;public;1;6;/**  * Defines the encoding scheme of the short message user data.  * Only for SubmitSm, ReplaceSm and SubmitMulti.  */ ;/**  * Defines the encoding scheme of the short message user data.  * Only for SubmitSm, ReplaceSm and SubmitMulti.  */ public void setEncoding(String encoding) {     if (!Charset.isSupported(encoding)) {         LOG.warn("Unsupported encoding \"{}\" is being set.", encoding).     }     this.encoding = encoding. }
false;public;1;3;;public void setPassword(String password) {     this.password = password. }
false;public;0;3;;public Integer getEnquireLinkTimer() {     return enquireLinkTimer. }
true;public;1;3;/**  * Defines the interval in milliseconds between the confidence checks.  * The confidence check is used to test the communication path between an ESME and an SMSC.  */ ;/**  * Defines the interval in milliseconds between the confidence checks.  * The confidence check is used to test the communication path between an ESME and an SMSC.  */ public void setEnquireLinkTimer(Integer enquireLinkTimer) {     this.enquireLinkTimer = enquireLinkTimer. }
false;public;0;3;;public Integer getTransactionTimer() {     return transactionTimer. }
true;public;1;3;/**  * Defines the maximum period of inactivity allowed after a transaction, after which  * an SMPP entity may assume that the session is no longer active.  * This timer may be active on either communicating SMPP entity (i.e. SMSC or ESME).  */ ;/**  * Defines the maximum period of inactivity allowed after a transaction, after which  * an SMPP entity may assume that the session is no longer active.  * This timer may be active on either communicating SMPP entity (i.e. SMSC or ESME).  */ public void setTransactionTimer(Integer transactionTimer) {     this.transactionTimer = transactionTimer. }
false;public;0;3;;public String getSystemType() {     return systemType. }
true;public;1;3;/**  * This parameter is used to categorize the type of ESME (External Short Message Entity) that is binding to the SMSC (max. 13 characters).  */ ;/**  * This parameter is used to categorize the type of ESME (External Short Message Entity) that is binding to the SMSC (max. 13 characters).  */ public void setSystemType(String systemType) {     this.systemType = systemType. }
false;public;0;3;;public byte getRegisteredDelivery() {     return registeredDelivery. }
true;public;1;3;/**  * Is used to request an SMSC delivery receipt and/or SME originated acknowledgements. The following values are defined:  * <ul>  *     <li>0: No SMSC delivery receipt requested.</li>  *     <li>1: SMSC delivery receipt requested where final delivery outcome is success or failure.</li>  *     <li>2: SMSC delivery receipt requested where the final delivery outcome is delivery failure.</li>  * </ul>  */ ;/**  * Is used to request an SMSC delivery receipt and/or SME originated acknowledgements. The following values are defined:  * <ul>  *     <li>0: No SMSC delivery receipt requested.</li>  *     <li>1: SMSC delivery receipt requested where final delivery outcome is success or failure.</li>  *     <li>2: SMSC delivery receipt requested where the final delivery outcome is delivery failure.</li>  * </ul>  */ public void setRegisteredDelivery(byte registeredDelivery) {     this.registeredDelivery = registeredDelivery. }
false;public;0;3;;public String getServiceType() {     return serviceType. }
true;public;1;3;/**  * The service type parameter can be used to indicate the SMS Application service associated with the message.  * The following generic service_types are defined:  * <ul>  *     <li>CMT: Cellular Messaging</li>  *     <li>CPT: Cellular Paging</li>  *     <li>VMN: Voice Mail Notification</li>  *     <li>VMA: Voice Mail Alerting</li>  *     <li>WAP: Wireless Application Protocol</li>  *     <li>USSD: Unstructured Supplementary Services Data</li>  * </ul>  */ ;/**  * The service type parameter can be used to indicate the SMS Application service associated with the message.  * The following generic service_types are defined:  * <ul>  *     <li>CMT: Cellular Messaging</li>  *     <li>CPT: Cellular Paging</li>  *     <li>VMN: Voice Mail Notification</li>  *     <li>VMA: Voice Mail Alerting</li>  *     <li>WAP: Wireless Application Protocol</li>  *     <li>USSD: Unstructured Supplementary Services Data</li>  * </ul>  */ public void setServiceType(String serviceType) {     this.serviceType = serviceType. }
false;public;0;3;;public byte getSourceAddrTon() {     return sourceAddrTon. }
true;public;1;3;/**  * Defines the type of number (TON) to be used in the SME originator address parameters.  * The following TON values are defined:  * <ul>  *     <li>0: Unknown</li>  *     <li>1: International</li>  *     <li>2: National</li>  *     <li>3: Network Specific</li>  *     <li>4: Subscriber Number</li>  *     <li>5: Alphanumeric</li>  *     <li>6: Abbreviated</li>  * </ul>  */ ;/**  * Defines the type of number (TON) to be used in the SME originator address parameters.  * The following TON values are defined:  * <ul>  *     <li>0: Unknown</li>  *     <li>1: International</li>  *     <li>2: National</li>  *     <li>3: Network Specific</li>  *     <li>4: Subscriber Number</li>  *     <li>5: Alphanumeric</li>  *     <li>6: Abbreviated</li>  * </ul>  */ public void setSourceAddrTon(byte sourceAddrTon) {     this.sourceAddrTon = sourceAddrTon. }
false;public;0;3;;public byte getDestAddrTon() {     return destAddrTon. }
true;public;1;3;/**  * Defines the type of number (TON) to be used in the SME destination address parameters.  * Only for SubmitSm, SubmitMulti, CancelSm and DataSm.  * The following TON values are defined:  * <ul>  *     <li>0: Unknown</li>  *     <li>1: International</li>  *     <li>2: National</li>  *     <li>3: Network Specific</li>  *     <li>4: Subscriber Number</li>  *     <li>5: Alphanumeric</li>  *     <li>6: Abbreviated</li>  * </ul>  */ ;/**  * Defines the type of number (TON) to be used in the SME destination address parameters.  * Only for SubmitSm, SubmitMulti, CancelSm and DataSm.  * The following TON values are defined:  * <ul>  *     <li>0: Unknown</li>  *     <li>1: International</li>  *     <li>2: National</li>  *     <li>3: Network Specific</li>  *     <li>4: Subscriber Number</li>  *     <li>5: Alphanumeric</li>  *     <li>6: Abbreviated</li>  * </ul>  */ public void setDestAddrTon(byte destAddrTon) {     this.destAddrTon = destAddrTon. }
false;public;0;3;;public byte getSourceAddrNpi() {     return sourceAddrNpi. }
true;public;1;3;/**  * Defines the numeric plan indicator (NPI) to be used in the SME originator address parameters.  * The following NPI values are defined:  * <ul>  *     <li>0: Unknown</li>  *     <li>1: ISDN (E163/E164)</li>  *     <li>2: Data (X.121)</li>  *     <li>3: Telex (F.69)</li>  *     <li>6: Land Mobile (E.212)</li>  *     <li>8: National</li>  *     <li>9: Private</li>  *     <li>10: ERMES</li>  *     <li>13: Internet (IP)</li>  *     <li>18: WAP Client Id (to be defined by WAP Forum)</li>  * </ul>  */ ;/**  * Defines the numeric plan indicator (NPI) to be used in the SME originator address parameters.  * The following NPI values are defined:  * <ul>  *     <li>0: Unknown</li>  *     <li>1: ISDN (E163/E164)</li>  *     <li>2: Data (X.121)</li>  *     <li>3: Telex (F.69)</li>  *     <li>6: Land Mobile (E.212)</li>  *     <li>8: National</li>  *     <li>9: Private</li>  *     <li>10: ERMES</li>  *     <li>13: Internet (IP)</li>  *     <li>18: WAP Client Id (to be defined by WAP Forum)</li>  * </ul>  */ public void setSourceAddrNpi(byte sourceAddrNpi) {     this.sourceAddrNpi = sourceAddrNpi. }
false;public;0;3;;public byte getDestAddrNpi() {     return destAddrNpi. }
true;public;1;3;/**  * Defines the type of number (TON) to be used in the SME destination address parameters.  * Only for SubmitSm, SubmitMulti, CancelSm and DataSm.  * The following NPI values are defined:  * <ul>  *     <li>0: Unknown</li>  *     <li>1: ISDN (E163/E164)</li>  *     <li>2: Data (X.121)</li>  *     <li>3: Telex (F.69)</li>  *     <li>6: Land Mobile (E.212)</li>  *     <li>8: National</li>  *     <li>9: Private</li>  *     <li>10: ERMES</li>  *     <li>13: Internet (IP)</li>  *     <li>18: WAP Client Id (to be defined by WAP Forum)</li>  * </ul>  */ ;/**  * Defines the type of number (TON) to be used in the SME destination address parameters.  * Only for SubmitSm, SubmitMulti, CancelSm and DataSm.  * The following NPI values are defined:  * <ul>  *     <li>0: Unknown</li>  *     <li>1: ISDN (E163/E164)</li>  *     <li>2: Data (X.121)</li>  *     <li>3: Telex (F.69)</li>  *     <li>6: Land Mobile (E.212)</li>  *     <li>8: National</li>  *     <li>9: Private</li>  *     <li>10: ERMES</li>  *     <li>13: Internet (IP)</li>  *     <li>18: WAP Client Id (to be defined by WAP Forum)</li>  * </ul>  */ public void setDestAddrNpi(byte destAddrNpi) {     this.destAddrNpi = destAddrNpi. }
false;public;0;3;;public byte getProtocolId() {     return protocolId. }
true;public;1;3;/**  * The protocol id  */ ;/**  * The protocol id  */ public void setProtocolId(byte protocolId) {     this.protocolId = protocolId. }
false;public;0;3;;public byte getPriorityFlag() {     return priorityFlag. }
true;public;1;3;/**  * Allows the originating SME to assign a priority level to the short message.  * Only for SubmitSm and SubmitMulti.  * Four Priority Levels are supported:  * <ul>  *     <li>0: Level 0 (lowest) priority</li>  *     <li>1: Level 1 priority</li>  *     <li>2: Level 2 priority</li>  *     <li>3: Level 3 (highest) priority</li>  * </ul>  */ ;/**  * Allows the originating SME to assign a priority level to the short message.  * Only for SubmitSm and SubmitMulti.  * Four Priority Levels are supported:  * <ul>  *     <li>0: Level 0 (lowest) priority</li>  *     <li>1: Level 1 priority</li>  *     <li>2: Level 2 priority</li>  *     <li>3: Level 3 (highest) priority</li>  * </ul>  */ public void setPriorityFlag(byte priorityFlag) {     this.priorityFlag = priorityFlag. }
false;public;0;3;;public byte getReplaceIfPresentFlag() {     return replaceIfPresentFlag. }
true;public;1;3;/**  * Used to request the SMSC to replace a previously submitted message, that is still pending delivery.  * The SMSC will replace an existing message provided that the source address, destination address and service  * type match the same fields in the new message.  * The following replace if present flag values are defined:  * <ul>  *     <li>0: Don't replace</li>  *     <li>1: Replace</li>  * </ul>  */ ;/**  * Used to request the SMSC to replace a previously submitted message, that is still pending delivery.  * The SMSC will replace an existing message provided that the source address, destination address and service  * type match the same fields in the new message.  * The following replace if present flag values are defined:  * <ul>  *     <li>0: Don't replace</li>  *     <li>1: Replace</li>  * </ul>  */ public void setReplaceIfPresentFlag(byte replaceIfPresentFlag) {     this.replaceIfPresentFlag = replaceIfPresentFlag. }
false;public;0;3;;public String getSourceAddr() {     return sourceAddr. }
true;public;1;3;/**  * Defines the address of SME (Short Message Entity) which originated this message.  */ ;/**  * Defines the address of SME (Short Message Entity) which originated this message.  */ public void setSourceAddr(String sourceAddr) {     this.sourceAddr = sourceAddr. }
false;public;0;3;;public String getDestAddr() {     return destAddr. }
true;public;1;3;/**  * Defines the destination SME address. For mobile terminated messages, this is the directory number of the recipient MS.  * Only for SubmitSm, SubmitMulti, CancelSm and DataSm.  */ ;/**  * Defines the destination SME address. For mobile terminated messages, this is the directory number of the recipient MS.  * Only for SubmitSm, SubmitMulti, CancelSm and DataSm.  */ public void setDestAddr(String destAddr) {     this.destAddr = destAddr. }
false;public;0;3;;public byte getTypeOfNumber() {     return typeOfNumber. }
true;public;1;3;/**  * Defines the type of number (TON) to be used in the SME.  * The following TON values are defined:  * <ul>  *     <li>0: Unknown</li>  *     <li>1: International</li>  *     <li>2: National</li>  *     <li>3: Network Specific</li>  *     <li>4: Subscriber Number</li>  *     <li>5: Alphanumeric</li>  *     <li>6: Abbreviated</li>  * </ul>  */ ;/**  * Defines the type of number (TON) to be used in the SME.  * The following TON values are defined:  * <ul>  *     <li>0: Unknown</li>  *     <li>1: International</li>  *     <li>2: National</li>  *     <li>3: Network Specific</li>  *     <li>4: Subscriber Number</li>  *     <li>5: Alphanumeric</li>  *     <li>6: Abbreviated</li>  * </ul>  */ public void setTypeOfNumber(byte typeOfNumber) {     this.typeOfNumber = typeOfNumber. }
false;public;0;3;;public byte getNumberingPlanIndicator() {     return numberingPlanIndicator. }
true;public;1;3;/**  * Defines the numeric plan indicator (NPI) to be used in the SME.  * The following NPI values are defined:  * <ul>  *     <li>0: Unknown</li>  *     <li>1: ISDN (E163/E164)</li>  *     <li>2: Data (X.121)</li>  *     <li>3: Telex (F.69)</li>  *     <li>6: Land Mobile (E.212)</li>  *     <li>8: National</li>  *     <li>9: Private</li>  *     <li>10: ERMES</li>  *     <li>13: Internet (IP)</li>  *     <li>18: WAP Client Id (to be defined by WAP Forum)</li>  * </ul>  */ ;/**  * Defines the numeric plan indicator (NPI) to be used in the SME.  * The following NPI values are defined:  * <ul>  *     <li>0: Unknown</li>  *     <li>1: ISDN (E163/E164)</li>  *     <li>2: Data (X.121)</li>  *     <li>3: Telex (F.69)</li>  *     <li>6: Land Mobile (E.212)</li>  *     <li>8: National</li>  *     <li>9: Private</li>  *     <li>10: ERMES</li>  *     <li>13: Internet (IP)</li>  *     <li>18: WAP Client Id (to be defined by WAP Forum)</li>  * </ul>  */ public void setNumberingPlanIndicator(byte numberingPlanIndicator) {     this.numberingPlanIndicator = numberingPlanIndicator. }
false;public;0;3;;public boolean getUsingSSL() {     return usingSSL. }
true;public;1;3;/**  * Whether using SSL with the smpps protocol  */ ;/**  * Whether using SSL with the smpps protocol  */ public void setUsingSSL(boolean usingSSL) {     this.usingSSL = usingSSL. }
false;public;0;3;;public long getInitialReconnectDelay() {     return initialReconnectDelay. }
true;public;1;3;/**  * Defines the initial delay in milliseconds after the consumer/producer tries to reconnect to the SMSC, after the connection was lost.  */ ;/**  * Defines the initial delay in milliseconds after the consumer/producer tries to reconnect to the SMSC, after the connection was lost.  */ public void setInitialReconnectDelay(long initialReconnectDelay) {     this.initialReconnectDelay = initialReconnectDelay. }
false;public;0;3;;public long getReconnectDelay() {     return reconnectDelay. }
true;public;1;3;/**  * Defines the interval in milliseconds between the reconnect attempts, if the connection to the SMSC was lost and the previous was not succeed.  */ ;/**  * Defines the interval in milliseconds between the reconnect attempts, if the connection to the SMSC was lost and the previous was not succeed.  */ public void setReconnectDelay(long reconnectDelay) {     this.reconnectDelay = reconnectDelay. }
true;public;0;3;/**  * Defines the maximum number of attempts to reconnect to the SMSC, if SMSC returns a negative bind response  */ ;/**  * Defines the maximum number of attempts to reconnect to the SMSC, if SMSC returns a negative bind response  */ public int getMaxReconnect() {     return maxReconnect. }
false;public;1;3;;public void setMaxReconnect(int maxReconnect) {     this.maxReconnect = maxReconnect. }
false;public;0;3;;public boolean isLazySessionCreation() {     return lazySessionCreation. }
true;public;1;3;/**  * Sessions can be lazily created to avoid exceptions, if the SMSC is not available when the Camel producer is started.  * Camel will check the in message headers 'CamelSmppSystemId' and 'CamelSmppPassword' of the first exchange.  * If they are present, Camel will use these data to connect to the SMSC.  */ ;/**  * Sessions can be lazily created to avoid exceptions, if the SMSC is not available when the Camel producer is started.  * Camel will check the in message headers 'CamelSmppSystemId' and 'CamelSmppPassword' of the first exchange.  * If they are present, Camel will use these data to connect to the SMSC.  */ public void setLazySessionCreation(boolean lazySessionCreation) {     this.lazySessionCreation = lazySessionCreation. }
false;public;0;3;;public String getHttpProxyHost() {     return httpProxyHost. }
true;public;1;3;/**  * If you need to tunnel SMPP through a HTTP proxy, set this attribute to the hostname or ip address of your HTTP proxy.  */ ;/**  * If you need to tunnel SMPP through a HTTP proxy, set this attribute to the hostname or ip address of your HTTP proxy.  */ public void setHttpProxyHost(String httpProxyHost) {     this.httpProxyHost = httpProxyHost. }
false;public;0;3;;public Integer getHttpProxyPort() {     return httpProxyPort. }
true;public;1;3;/**  * If you need to tunnel SMPP through a HTTP proxy, set this attribute to the port of your HTTP proxy.  */ ;/**  * If you need to tunnel SMPP through a HTTP proxy, set this attribute to the port of your HTTP proxy.  */ public void setHttpProxyPort(Integer httpProxyPort) {     this.httpProxyPort = httpProxyPort. }
false;public;0;3;;public String getHttpProxyUsername() {     return httpProxyUsername. }
true;public;1;3;/**  * If your HTTP proxy requires basic authentication, set this attribute to the username required for your HTTP proxy.  */ ;/**  * If your HTTP proxy requires basic authentication, set this attribute to the username required for your HTTP proxy.  */ public void setHttpProxyUsername(String httpProxyUsername) {     this.httpProxyUsername = httpProxyUsername. }
false;public;0;3;;public String getHttpProxyPassword() {     return httpProxyPassword. }
true;public;1;3;/**  * If your HTTP proxy requires basic authentication, set this attribute to the password required for your HTTP proxy.  */ ;/**  * If your HTTP proxy requires basic authentication, set this attribute to the password required for your HTTP proxy.  */ public void setHttpProxyPassword(String httpProxyPassword) {     this.httpProxyPassword = httpProxyPassword. }
false;public;0;3;;public SessionStateListener getSessionStateListener() {     return sessionStateListener. }
true;public;1;3;/**  * You can refer to a org.jsmpp.session.SessionStateListener in the Registry to receive callbacks when the session state changed.  */ ;/**  * You can refer to a org.jsmpp.session.SessionStateListener in the Registry to receive callbacks when the session state changed.  */ public void setSessionStateListener(SessionStateListener sessionStateListener) {     this.sessionStateListener = sessionStateListener. }
false;public;0;3;;public String getAddressRange() {     return addressRange. }
true;public;1;3;/**  *  You can specify the address range for the SmppConsumer as defined in section 5.2.7 of the SMPP 3.4 specification.  *  The SmppConsumer will receive messages only from SMSC's which target an address (MSISDN or IP address) within this range.  */ ;/**  *  You can specify the address range for the SmppConsumer as defined in section 5.2.7 of the SMPP 3.4 specification.  *  The SmppConsumer will receive messages only from SMSC's which target an address (MSISDN or IP address) within this range.  */ public void setAddressRange(String addressRange) {     this.addressRange = addressRange. }
false;public;0;3;;public SmppSplittingPolicy getSplittingPolicy() {     return splittingPolicy. }
true;public;1;3;/**  * You can specify a policy for handling long messages:  * <ul>  *     <li>ALLOW - the default, long messages are split to 140 bytes per message</li>  *     <li>TRUNCATE - long messages are split and only the first fragment will be sent to the SMSC.  *     Some carriers drop subsequent fragments so this reduces load on the SMPP connection sending parts of a message that will never be delivered.</li>  *     <li>REJECT - if a message would need to be split, it is rejected with an SMPP NegativeResponseException and the reason code signifying the message is too long.</li>  * </ul>  */ ;/**  * You can specify a policy for handling long messages:  * <ul>  *     <li>ALLOW - the default, long messages are split to 140 bytes per message</li>  *     <li>TRUNCATE - long messages are split and only the first fragment will be sent to the SMSC.  *     Some carriers drop subsequent fragments so this reduces load on the SMPP connection sending parts of a message that will never be delivered.</li>  *     <li>REJECT - if a message would need to be split, it is rejected with an SMPP NegativeResponseException and the reason code signifying the message is too long.</li>  * </ul>  */ public void setSplittingPolicy(SmppSplittingPolicy splittingPolicy) {     this.splittingPolicy = splittingPolicy. }
true;public;1;3;/**  * These headers will be passed to the proxy server while establishing the connection.  */ ;/**  * These headers will be passed to the proxy server while establishing the connection.  */ public void setProxyHeaders(Map<String, String> proxyHeaders) {     this.proxyHeaders = proxyHeaders. }
false;public;0;3;;public Map<String, String> getProxyHeaders() {     return proxyHeaders. }
false;public;0;39;;@Override public String toString() {     return "SmppConfiguration[usingSSL=" + usingSSL + ", enquireLinkTimer=" + enquireLinkTimer + ", host=" + host + ", password=" + password + ", port=" + port + ", systemId=" + systemId + ", systemType=" + systemType + ", dataCoding=" + dataCoding + ", alphabet=" + alphabet + ", encoding=" + encoding + ", transactionTimer=" + transactionTimer + ", registeredDelivery=" + registeredDelivery + ", serviceType=" + serviceType + ", sourceAddrTon=" + sourceAddrTon + ", destAddrTon=" + destAddrTon + ", sourceAddrNpi=" + sourceAddrNpi + ", destAddrNpi=" + destAddrNpi + ", addressRange=" + addressRange + ", protocolId=" + protocolId + ", priorityFlag=" + priorityFlag + ", replaceIfPresentFlag=" + replaceIfPresentFlag + ", sourceAddr=" + sourceAddr + ", destAddr=" + destAddr + ", typeOfNumber=" + typeOfNumber + ", numberingPlanIndicator=" + numberingPlanIndicator + ", initialReconnectDelay=" + initialReconnectDelay + ", reconnectDelay=" + reconnectDelay + ", maxReconnect=" + maxReconnect + ", lazySessionCreation=" + lazySessionCreation + ", httpProxyHost=" + httpProxyHost + ", httpProxyPort=" + httpProxyPort + ", httpProxyUsername=" + httpProxyUsername + ", httpProxyPassword=" + httpProxyPassword + ", splittingPolicy=" + splittingPolicy + ", proxyHeaders=" + proxyHeaders + "]". }
