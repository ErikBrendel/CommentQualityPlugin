commented;modifiers;parameterAmount;loc;comment;code
true;protected,static,synchronized;0;7;/**  * Returns reference number which length is  * {@link #UDHIE_SAR_REF_NUM_LENGTH}.  *  * @return the reference number of the multipart message  */ ;/**  * Returns reference number which length is  * {@link #UDHIE_SAR_REF_NUM_LENGTH}.  *  * @return the reference number of the multipart message  */ protected static synchronized byte getReferenceNumber() {     refNum++.     if (refNum == 256) {         refNum = 1.     }     return (byte) refNum. }
false;protected,static,synchronized;0;3;;protected static synchronized byte getCurrentReferenceNumber() {     return (byte) refNum. }
true;protected,static,synchronized;0;3;/**  * only needed for the unit tests  */ ;/**  * only needed for the unit tests  */ protected static synchronized void resetCurrentReferenceNumber() {     SmppSplitter.refNum = 0. }
false;public;1;52;;public byte[][] split(byte[] message) {     if (!isSplitRequired()) {         return new byte[][] { message }.     }     int segmentLength = getSegmentLength().     // determine how many messages     int segmentNum = message.length / segmentLength.     int messageLength = message.length.     if (segmentNum > MAX_SEG_COUNT) {         // this is too long, can't fit, so chop         segmentNum = MAX_SEG_COUNT.         messageLength = segmentNum * segmentLength.     }     if ((messageLength % segmentLength) > 0) {         segmentNum++.     }     byte[][] segments = new byte[segmentNum][].     int lengthOfData.     byte refNum = getReferenceNumber().     for (int i = 0. i < segmentNum. i++) {         LOG.trace("segment number = {}", i).         if (segmentNum - i == 1) {             lengthOfData = messageLength - i * segmentLength.         } else {             lengthOfData = segmentLength.         }         LOG.trace("Length of data = {}", lengthOfData).         segments[i] = new byte[UDHIE_HEADER_REAL_LENGTH + lengthOfData].         LOG.trace("segments[{}].length = {}", i, segments[i].length).         // doesn't include itself, is header length         segments[i][0] = UDHIE_HEADER_LENGTH.         // SAR identifier         segments[i][1] = UDHIE_IDENTIFIER_SAR.         // SAR length         segments[i][2] = UDHIE_SAR_LENGTH.         // DATAGRAM REFERENCE NUMBER         segments[i][3] = refNum.         // total number of segments         segments[i][4] = (byte) segmentNum.         // segment #         segments[i][5] = (byte) (i + 1).         // now copy the data         System.arraycopy(message, i * segmentLength, segments[i], UDHIE_HEADER_REAL_LENGTH, lengthOfData).     }     return segments. }
false;protected;0;3;;protected boolean isSplitRequired() {     return getCurrentLength() > getMessageLength(). }
true;public;0;3;/**  * Gets maximum message length.  *  * @return maximum message length  */ ;/**  * Gets maximum message length.  *  * @return maximum message length  */ public int getMessageLength() {     return messageLength. }
true;public;0;3;/**  * Gets maximum segment length.  *  * @return maximum segment length  */ ;/**  * Gets maximum segment length.  *  * @return maximum segment length  */ public int getSegmentLength() {     return segmentLength. }
true;public;0;3;/**  * Gets length of the message to split.  *  * @return length of the message to split  */ ;/**  * Gets length of the message to split.  *  * @return length of the message to split  */ public int getCurrentLength() {     return currentLength. }
