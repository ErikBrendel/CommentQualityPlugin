commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Producer createProducer() throws Exception {     return new DirectProducer(this). }
false;public;1;5;;public Consumer createConsumer(Processor processor) throws Exception {     Consumer answer = new DirectConsumer(this, processor).     configureConsumer(answer).     return answer. }
false;public;0;3;;public boolean isSingleton() {     return true. }
false;public;1;9;;public void addConsumer(DirectConsumer consumer) {     String key = getKey().     synchronized (consumers) {         if (consumers.putIfAbsent(key, consumer) != null) {             throw new IllegalArgumentException("Cannot add a 2nd consumer to the same endpoint. Endpoint " + this + " only allows one consumer.").         }         consumers.notifyAll().     } }
false;public;1;7;;public void removeConsumer(DirectConsumer consumer) {     String key = getKey().     synchronized (consumers) {         consumers.remove(key, consumer).         consumers.notifyAll().     } }
false;public;1;5;;public void addProducer(DirectProducer producer) {     synchronized (consumers) {         producers.add(producer).     } }
false;public;1;5;;public void removeProducer(DirectProducer producer) {     synchronized (consumers) {         producers.remove(producer).     } }
false;protected;0;24;;protected DirectConsumer getConsumer() throws InterruptedException {     String key = getKey().     synchronized (consumers) {         DirectConsumer answer = consumers.get(key).         if (answer == null && block) {             StopWatch watch = new StopWatch().             for (. . ) {                 answer = consumers.get(key).                 if (answer != null) {                     break.                 }                 long rem = timeout - watch.taken().                 if (rem <= 0) {                     break.                 }                 consumers.wait(rem).             }         }         // }         return answer.     } }
false;public;0;3;;public boolean isBlock() {     return block. }
true;public;1;3;/**  * If sending a message to a direct endpoint which has no active consumer,  * then we can tell the producer to block and wait for the consumer to become active.  */ ;/**  * If sending a message to a direct endpoint which has no active consumer,  * then we can tell the producer to block and wait for the consumer to become active.  */ public void setBlock(boolean block) {     this.block = block. }
false;public;0;3;;public long getTimeout() {     return timeout. }
true;public;1;3;/**  * The timeout value to use if block is enabled.  *  * @param timeout the timeout value  */ ;/**  * The timeout value to use if block is enabled.  *  * @param timeout the timeout value  */ public void setTimeout(long timeout) {     this.timeout = timeout. }
false;public;0;3;;public boolean isFailIfNoConsumers() {     return failIfNoConsumers. }
true;public;1;3;/**  * Whether the producer should fail by throwing an exception, when sending to a DIRECT endpoint with no active consumers.  */ ;/**  * Whether the producer should fail by throwing an exception, when sending to a DIRECT endpoint with no active consumers.  */ public void setFailIfNoConsumers(boolean failIfNoConsumers) {     this.failIfNoConsumers = failIfNoConsumers. }
false;protected;0;8;;protected String getKey() {     String uri = getEndpointUri().     if (uri.indexOf('?') != -1) {         return StringHelper.before(uri, "?").     } else {         return uri.     } }
