commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;public Consumer createConsumer(Processor processor) throws Exception {     JcrConsumer answer = new JcrConsumer(this, processor).     configureConsumer(answer).     return answer. }
false;public;0;3;;public Producer createProducer() throws Exception {     return new JcrProducer(this). }
false;public;0;3;;public boolean isSingleton() {     return true. }
false;protected;0;13;;@Override protected void doStart() throws Exception {     super.doStart().     StringHelper.notEmpty(host, "host", this).     this.repository = getCamelContext().getRegistry().lookupByNameAndType(host, Repository.class).     if (repository == null) {         throw new RuntimeCamelException("No JCR repository defined under '" + host + "'").     }     if (username != null && password != null) {         this.credentials = new SimpleCredentials(username, password.toCharArray()).     } }
false;public;0;3;;public String getHost() {     return host. }
true;public;1;3;/**  * Name of the {@link javax.jcr.Repository} to lookup from the Camel registry to be used.  */ ;/**  * Name of the {@link javax.jcr.Repository} to lookup from the Camel registry to be used.  */ public void setHost(String host) {     this.host = host. }
true;protected;0;3;/**  * Get the {@link Repository}  *  * @return the repository  */ ;/**  * Get the {@link Repository}  *  * @return the repository  */ protected Repository getRepository() {     return repository. }
true;protected;0;3;/**  * Get the {@link Credentials} for establishing the JCR repository connection  *  * @return the credentials  */ ;/**  * Get the {@link Credentials} for establishing the JCR repository connection  *  * @return the credentials  */ protected Credentials getCredentials() {     return credentials. }
true;protected;0;3;/**  * Get the base node when accessing the repository  *  * @return the base node  */ ;/**  * Get the base node when accessing the repository  *  * @return the base node  */ protected String getBase() {     return base. }
false;public;1;3;;public void setBase(String base) {     this.base = base. }
false;public;0;3;;public String getUsername() {     return username. }
true;public;1;3;/**  * Username for login  */ ;/**  * Username for login  */ public void setUsername(String username) {     this.username = username. }
false;public;0;3;;public String getPassword() {     return password. }
true;public;1;3;/**  * Password for login  */ ;/**  * Password for login  */ public void setPassword(String password) {     this.password = password. }
true;public;0;3;/**  * <code>eventTypes</code> (a combination of one or more event types encoded  * as a bit mask value such as javax.jcr.observation.Event.NODE_ADDED, javax.jcr.observation.Event.NODE_REMOVED, etc.).  *  * @return eventTypes  * @see {@link javax.jcr.observation.Event}  * @see {@link javax.jcr.observation.ObservationManager#addEventListener(javax.jcr.observation.EventListener, int, String, boolean, String[], String[], boolean)}  */ ;/**  * <code>eventTypes</code> (a combination of one or more event types encoded  * as a bit mask value such as javax.jcr.observation.Event.NODE_ADDED, javax.jcr.observation.Event.NODE_REMOVED, etc.).  *  * @return eventTypes  * @see {@link javax.jcr.observation.Event}  * @see {@link javax.jcr.observation.ObservationManager#addEventListener(javax.jcr.observation.EventListener, int, String, boolean, String[], String[], boolean)}  */ public int getEventTypes() {     return eventTypes. }
false;public;1;3;;public void setEventTypes(int eventTypes) {     this.eventTypes = eventTypes. }
true;public;0;3;/**  * When <code>isDeep</code> is true, events whose associated parent node is at  * <code>absPath</code> or within its subgraph are received.  * @return deep  */ ;/**  * When <code>isDeep</code> is true, events whose associated parent node is at  * <code>absPath</code> or within its subgraph are received.  * @return deep  */ public boolean isDeep() {     return deep. }
false;public;1;3;;public void setDeep(boolean deep) {     this.deep = deep. }
true;public;0;3;/**  * When a comma separated uuid list string is set, only events whose associated parent node has one of  * the identifiers in the comma separated uuid list will be received.  * @return comma separated uuid list string  */ ;/**  * When a comma separated uuid list string is set, only events whose associated parent node has one of  * the identifiers in the comma separated uuid list will be received.  * @return comma separated uuid list string  */ public String getUuids() {     return uuids. }
false;public;1;3;;public void setUuids(String uuids) {     this.uuids = uuids. }
true;public;0;3;/**  * When a comma separated <code>nodeTypeName</code> list string is set, only events whose associated parent node has  * one of the node types (or a subtype of one of the node types) in this  * list will be received.  */ ;/**  * When a comma separated <code>nodeTypeName</code> list string is set, only events whose associated parent node has  * one of the node types (or a subtype of one of the node types) in this  * list will be received.  */ public String getNodeTypeNames() {     return nodeTypeNames. }
false;public;1;3;;public void setNodeTypeNames(String nodeTypeNames) {     this.nodeTypeNames = nodeTypeNames. }
true;public;0;3;/**  * If <code>noLocal</code> is <code>true</code>, then events  * generated by the session through which the listener was registered are  * ignored. Otherwise, they are not ignored.  * @return noLocal  */ ;/**  * If <code>noLocal</code> is <code>true</code>, then events  * generated by the session through which the listener was registered are  * ignored. Otherwise, they are not ignored.  * @return noLocal  */ public boolean isNoLocal() {     return noLocal. }
false;public;1;3;;public void setNoLocal(boolean noLocal) {     this.noLocal = noLocal. }
true;public;0;3;/**  * Interval in milliseconds to wait before the first session live checking.  * The default value is 3000 ms.  *  * @return sessionLiveCheckIntervalOnStart  */ ;/**  * Interval in milliseconds to wait before the first session live checking.  * The default value is 3000 ms.  *  * @return sessionLiveCheckIntervalOnStart  */ public long getSessionLiveCheckIntervalOnStart() {     return sessionLiveCheckIntervalOnStart. }
false;public;1;7;;public void setSessionLiveCheckIntervalOnStart(long sessionLiveCheckIntervalOnStart) {     if (sessionLiveCheckIntervalOnStart <= 0) {         throw new IllegalArgumentException("sessionLiveCheckIntervalOnStart must be positive value").     }     this.sessionLiveCheckIntervalOnStart = sessionLiveCheckIntervalOnStart. }
true;public;0;3;/**  * Interval in milliseconds to wait before each session live checking  * The default value is 60000 ms.  */ ;/**  * Interval in milliseconds to wait before each session live checking  * The default value is 60000 ms.  */ public long getSessionLiveCheckInterval() {     return sessionLiveCheckInterval. }
false;public;1;7;;public void setSessionLiveCheckInterval(long sessionLiveCheckInterval) {     if (sessionLiveCheckInterval <= 0) {         throw new IllegalArgumentException("sessionLiveCheckInterval must be positive value").     }     this.sessionLiveCheckInterval = sessionLiveCheckInterval. }
true;public;0;3;/**  * The workspace to access. If it's not specified then the default one will be used  */ ;/**  * The workspace to access. If it's not specified then the default one will be used  */ public String getWorkspaceName() {     return workspaceName. }
false;public;1;3;;public void setWorkspaceName(String workspaceName) {     this.workspaceName = workspaceName. }
true;public;0;18;/**  * Gets the destination name which was configured from the endpoint uri.  *  * @return the destination name resolved from the endpoint uri  */ ;/**  * Gets the destination name which was configured from the endpoint uri.  *  * @return the destination name resolved from the endpoint uri  */ public String getEndpointConfiguredDestinationName() {     String remainder = StringHelper.after(getEndpointKey(), "//").     if (remainder != null && remainder.contains("@")) {         remainder = remainder.substring(remainder.indexOf('@')).     }     if (remainder != null && remainder.contains("?")) {         // remove parameters         remainder = StringHelper.before(remainder, "?").     }     if (ObjectHelper.isEmpty(remainder)) {         return remainder.     }     return remainder. }
