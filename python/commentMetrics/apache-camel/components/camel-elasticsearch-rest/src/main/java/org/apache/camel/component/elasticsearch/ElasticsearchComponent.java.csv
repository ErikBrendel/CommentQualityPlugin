commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;20;;protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {     ElasticsearchConfiguration config = new ElasticsearchConfiguration().     config.setHostAddresses(this.getHostAddresses()).     config.setSocketTimeout(this.getSocketTimeout()).     config.setMaxRetryTimeout(this.getMaxRetryTimeout()).     config.setConnectionTimeout(this.getConnectionTimeout()).     config.setUser(this.getUser()).     config.setEnableSSL(this.getEnableSSL()).     config.setPassword(this.getPassword()).     config.setEnableSniffer(this.getEnableSniffer()).     config.setSnifferInterval(this.getSnifferInterval()).     config.setSniffAfterFailureDelay(this.getSniffAfterFailureDelay()).     config.setClusterName(remaining).     setProperties(config, parameters).     config.setHostAddressesList(parseHostAddresses(config.getHostAddresses(), config)).     Endpoint endpoint = new ElasticsearchEndpoint(uri, this, config, client).     return endpoint. }
false;private;2;19;;private List<HttpHost> parseHostAddresses(String ipsString, ElasticsearchConfiguration config) throws UnknownHostException {     if (ipsString == null || ipsString.isEmpty()) {         return null.     }     List<String> addressesStr = Arrays.asList(ipsString.split(",")).     List<HttpHost> addressesTrAd = new ArrayList<>(addressesStr.size()).     for (String address : addressesStr) {         String[] split = address.split(":").         String hostname.         if (split.length > 0) {             hostname = split[0].         } else {             throw new IllegalArgumentException().         }         Integer port = split.length > 1 ? Integer.parseInt(split[1]) : ElasticsearchConstants.DEFAULT_PORT.         addressesTrAd.add(new HttpHost(hostname, port, config.getEnableSSL() ? "HTTPS" : "HTTP")).     }     return addressesTrAd. }
false;public;0;3;;public RestClient getClient() {     return client. }
true;public;1;3;/**  * To use an existing configured Elasticsearch client, instead of creating a client per endpoint.  * This allow to customize the client with specific settings.  */ ;/**  * To use an existing configured Elasticsearch client, instead of creating a client per endpoint.  * This allow to customize the client with specific settings.  */ public void setClient(RestClient client) {     this.client = client. }
true;public;0;3;/**  * Comma separated list with ip:port formatted remote transport addresses to use.  * The ip and port options must be left blank for hostAddresses to be considered instead.  */ ;/**  * Comma separated list with ip:port formatted remote transport addresses to use.  * The ip and port options must be left blank for hostAddresses to be considered instead.  */ public String getHostAddresses() {     return hostAddresses. }
false;public;1;3;;public void setHostAddresses(String hostAddresses) {     this.hostAddresses = hostAddresses. }
true;public;0;3;/**  * The timeout in ms to wait before the socket will timeout.  */ ;/**  * The timeout in ms to wait before the socket will timeout.  */ public int getSocketTimeout() {     return socketTimeout. }
false;public;1;3;;public void setSocketTimeout(int socketTimeout) {     this.socketTimeout = socketTimeout. }
true;public;0;3;/**  *  The time in ms to wait before connection will timeout.  */ ;/**  *  The time in ms to wait before connection will timeout.  */ public int getConnectionTimeout() {     return connectionTimeout. }
false;public;1;3;;public void setConnectionTimeout(int connectionTimeout) {     this.connectionTimeout = connectionTimeout. }
true;public;0;3;/**  *  Basic authenticate user  */ ;/**  *  Basic authenticate user  */ public String getUser() {     return user. }
false;public;1;3;;public void setUser(String user) {     this.user = user. }
true;public;0;3;/**  *  Password for authenticate  */ ;/**  *  Password for authenticate  */ public String getPassword() {     return password. }
false;public;1;3;;public void setPassword(String password) {     this.password = password. }
true;public;0;3;/**  * Enable SSL  */ ;/**  * Enable SSL  */ public Boolean getEnableSSL() {     return enableSSL. }
false;public;1;3;;public void setEnableSSL(Boolean enableSSL) {     this.enableSSL = enableSSL. }
true;public;0;3;/**  * The time in ms before retry  */ ;/**  * The time in ms before retry  */ public int getMaxRetryTimeout() {     return maxRetryTimeout. }
false;public;1;3;;public void setMaxRetryTimeout(int maxRetryTimeout) {     this.maxRetryTimeout = maxRetryTimeout. }
true;public;0;3;/**  * Enable automatically discover nodes from a running Elasticsearch cluster  */ ;/**  * Enable automatically discover nodes from a running Elasticsearch cluster  */ public Boolean getEnableSniffer() {     return enableSniffer. }
false;public;1;3;;public void setEnableSniffer(Boolean enableSniffer) {     this.enableSniffer = enableSniffer. }
true;public;0;3;/**  * The interval between consecutive ordinary sniff executions in milliseconds. Will be honoured when  * sniffOnFailure is disabled or when there are no failures between consecutive sniff executions  */ ;/**  * The interval between consecutive ordinary sniff executions in milliseconds. Will be honoured when  * sniffOnFailure is disabled or when there are no failures between consecutive sniff executions  */ public int getSnifferInterval() {     return snifferInterval. }
false;public;1;3;;public void setSnifferInterval(int snifferInterval) {     this.snifferInterval = snifferInterval. }
true;public;0;3;/**  * The delay of a sniff execution scheduled after a failure (in milliseconds)  */ ;/**  * The delay of a sniff execution scheduled after a failure (in milliseconds)  */ public int getSniffAfterFailureDelay() {     return sniffAfterFailureDelay. }
false;public;1;3;;public void setSniffAfterFailureDelay(int sniffAfterFailureDelay) {     this.sniffAfterFailureDelay = sniffAfterFailureDelay. }
