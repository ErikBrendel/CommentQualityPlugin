commented;modifiers;parameterAmount;loc;comment;code
false;private;1;45;;private ElasticsearchOperation resolveOperation(Exchange exchange) {     // 1. Operation can be driven by either (in order of preference):     // a. If the body is an ActionRequest the operation is set by the type     // of request.     // b. If the body is not an ActionRequest, the operation is set by the     // header if it exists.     // c. If neither the operation can not be derived from the body or     // header, the configuration is used.     // In the event we can't discover the operation from a, b or c we throw     // an error.     Object request = exchange.getIn().getBody().     if (request instanceof IndexRequest) {         return ElasticsearchOperation.Index.     } else if (request instanceof GetRequest) {         return ElasticsearchOperation.GetById.     } else if (request instanceof MultiGetRequest) {         return ElasticsearchOperation.MultiGet.     } else if (request instanceof UpdateRequest) {         return ElasticsearchOperation.Update.     } else if (request instanceof BulkRequest) {         // do we want bulk or bulk_index?         if (configuration.getOperation() == ElasticsearchOperation.BulkIndex) {             return ElasticsearchOperation.BulkIndex.         } else {             return ElasticsearchOperation.Bulk.         }     } else if (request instanceof DeleteRequest) {         return ElasticsearchOperation.Delete.     } else if (request instanceof SearchRequest) {         return ElasticsearchOperation.Search.     } else if (request instanceof MultiSearchRequest) {         return ElasticsearchOperation.MultiSearch.     } else if (request instanceof DeleteIndexRequest) {         return ElasticsearchOperation.DeleteIndex.     }     ElasticsearchOperation operationConfig = exchange.getIn().getHeader(ElasticsearchConstants.PARAM_OPERATION, ElasticsearchOperation.class).     if (operationConfig == null) {         operationConfig = configuration.getOperation().     }     if (operationConfig == null) {         throw new IllegalArgumentException(ElasticsearchConstants.PARAM_OPERATION + " value '" + operationConfig + "' is not supported").     }     return operationConfig. }
false;public;1;131;;public void process(Exchange exchange) throws Exception {     if (configuration.getDisconnect() && client == null) {         startClient().     }     RestHighLevelClient restHighLevelClient = new HighLevelClient(client).     // 2. Index and type will be set by:     // a. If the incoming body is already an action request     // b. If the body is not an action request we will use headers if they     // are set.     // c. If the body is not an action request and the headers aren't set we     // will use the configuration.     // No error is thrown by the component in the event none of the above     // conditions are met. The java es client     // will throw.     Message message = exchange.getIn().     final ElasticsearchOperation operation = resolveOperation(exchange).     // Set the index/type headers on the exchange if necessary. This is used     // for type conversion.     boolean configIndexName = false.     String indexName = message.getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class).     if (indexName == null) {         message.setHeader(ElasticsearchConstants.PARAM_INDEX_NAME, configuration.getIndexName()).         configIndexName = true.     }     boolean configIndexType = false.     String indexType = message.getHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, String.class).     if (indexType == null) {         message.setHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, configuration.getIndexType()).         configIndexType = true.     }     boolean configWaitForActiveShards = false.     Integer waitForActiveShards = message.getHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, Integer.class).     if (waitForActiveShards == null) {         message.setHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, configuration.getWaitForActiveShards()).         configWaitForActiveShards = true.     }     if (operation == ElasticsearchOperation.Index) {         IndexRequest indexRequest = message.getBody(IndexRequest.class).         message.setBody(restHighLevelClient.index(indexRequest, RequestOptions.DEFAULT).getId()).     } else if (operation == ElasticsearchOperation.Update) {         UpdateRequest updateRequest = message.getBody(UpdateRequest.class).         message.setBody(restHighLevelClient.update(updateRequest, RequestOptions.DEFAULT).getId()).     } else if (operation == ElasticsearchOperation.GetById) {         GetRequest getRequest = message.getBody(GetRequest.class).         message.setBody(restHighLevelClient.get(getRequest, RequestOptions.DEFAULT)).     } else if (operation == ElasticsearchOperation.Bulk) {         BulkRequest bulkRequest = message.getBody(BulkRequest.class).         message.setBody(restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT).getItems()).     } else if (operation == ElasticsearchOperation.BulkIndex) {         BulkRequest bulkRequest = message.getBody(BulkRequest.class).         message.setBody(restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT).getItems()).     } else if (operation == ElasticsearchOperation.Delete) {         DeleteRequest deleteRequest = message.getBody(DeleteRequest.class).         message.setBody(restHighLevelClient.delete(deleteRequest, RequestOptions.DEFAULT).getResult()).     } else if (operation == ElasticsearchOperation.DeleteIndex) {         DeleteRequest deleteRequest = message.getBody(DeleteRequest.class).         message.setBody(client.performRequest("Delete", deleteRequest.index()).getStatusLine().getStatusCode()).     } else if (operation == ElasticsearchOperation.Exists) {         // ExistsRequest API is deprecated, using SearchRequest instead with size=0 and terminate_after=1         SearchSourceBuilder sourceBuilder = new SearchSourceBuilder().         sourceBuilder.size(0).         sourceBuilder.terminateAfter(1).         SearchRequest searchRequest = new SearchRequest(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class)).         searchRequest.source(sourceBuilder).         try {             restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT).             message.setBody(true).         } catch (ElasticsearchStatusException e) {             if (e.status().equals(RestStatus.NOT_FOUND)) {                 message.setBody(false).             } else {                 throw new IllegalStateException(e).             }         }     } else if (operation == ElasticsearchOperation.Search) {         SearchRequest searchRequest = message.getBody(SearchRequest.class).         // is it a scroll request ?         boolean useScroll = message.getHeader(PARAM_SCROLL, configuration.getUseScroll(), Boolean.class).         if (useScroll) {             int scrollKeepAliveMs = message.getHeader(PARAM_SCROLL_KEEP_ALIVE_MS, configuration.getScrollKeepAliveMs(), Integer.class).             ElasticsearchScrollRequestIterator scrollRequestIterator = new ElasticsearchScrollRequestIterator(searchRequest, restHighLevelClient, scrollKeepAliveMs, exchange).             exchange.getIn().setBody(scrollRequestIterator).         } else {             message.setBody(restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT).getHits()).         }     } else if (operation == ElasticsearchOperation.MultiSearch) {         MultiSearchRequest searchRequest = message.getBody(MultiSearchRequest.class).         message.setBody(restHighLevelClient.msearch(searchRequest, RequestOptions.DEFAULT).getResponses()).     } else if (operation == ElasticsearchOperation.Ping) {         message.setBody(restHighLevelClient.ping(RequestOptions.DEFAULT)).     } else if (operation == ElasticsearchOperation.Info) {         message.setBody(restHighLevelClient.info(RequestOptions.DEFAULT)).     } else {         throw new IllegalArgumentException(ElasticsearchConstants.PARAM_OPERATION + " value '" + operation + "' is not supported").     }     // subsequent endpoint index/type with the first endpoint index/type.     if (configIndexName) {         message.removeHeader(ElasticsearchConstants.PARAM_INDEX_NAME).     }     if (configIndexType) {         message.removeHeader(ElasticsearchConstants.PARAM_INDEX_TYPE).     }     if (configWaitForActiveShards) {         message.removeHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS).     }     if (configuration.getDisconnect()) {         IOHelper.close(client).         IOHelper.close(restHighLevelClient).         client = null.         if (configuration.getEnableSniffer()) {             IOHelper.close(sniffer).             sniffer = null.         }     } }
false;protected;0;8;;@Override @SuppressWarnings("unchecked") protected void doStart() throws Exception {     super.doStart().     if (!configuration.getDisconnect()) {         startClient().     } }
false;private;0;11;;private void startClient() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, UnknownHostException {     if (client == null) {         log.info("Connecting to the ElasticSearch cluster: {}", configuration.getClusterName()).         if (configuration.getHostAddressesList() != null && !configuration.getHostAddressesList().isEmpty()) {             client = createClient().         } else {             log.warn("Incorrect ip address and port parameters settings for ElasticSearch cluster").         }     } }
false;private;0;22;;private RestClient createClient() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {     final RestClientBuilder builder = RestClient.builder(configuration.getHostAddressesList().toArray(new HttpHost[0])).     builder.setMaxRetryTimeoutMillis(configuration.getMaxRetryTimeout()).     builder.setRequestConfigCallback(requestConfigBuilder -> requestConfigBuilder.setConnectTimeout(configuration.getConnectionTimeout()).setSocketTimeout(configuration.getSocketTimeout())).     if (configuration.getUser() != null && configuration.getPassword() != null) {         final CredentialsProvider credentialsProvider = new BasicCredentialsProvider().         credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(configuration.getUser(), configuration.getPassword())).         builder.setHttpClientConfigCallback(httpClientBuilder -> {             httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider).             return httpClientBuilder.         }).     }     final RestClient restClient = builder.build().     if (configuration.getEnableSniffer()) {         SnifferBuilder snifferBuilder = Sniffer.builder(restClient).         snifferBuilder.setSniffIntervalMillis(configuration.getSnifferInterval()).         snifferBuilder.setSniffAfterFailureDelayMillis(configuration.getSniffAfterFailureDelay()).         sniffer = snifferBuilder.build().     }     return restClient. }
false;protected;0;11;;@Override protected void doStop() throws Exception {     if (client != null) {         log.info("Disconnecting from ElasticSearch cluster: {}", configuration.getClusterName()).         client.close().         if (sniffer != null) {             sniffer.close().         }     }     super.doStop(). }
false;public;0;3;;public RestClient getClient() {     return client. }
