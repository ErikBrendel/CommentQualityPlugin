commented;modifiers;parameterAmount;loc;comment;code
false;public;1;17;;@Override public void register(ServiceDefinition definition) {     synchronized (this) {         // shutdown         if (definitions.stream().noneMatch(d -> matchById(d, definition))) {             LOGGER.debug("Register service with definition: {} with registrations: {}", definition, registrationType).             // compute registration from definition             Registration result = convertServiceDefinition(definition).             serviceRegistry.register(result).             definitions.add(definition).         }     } }
false;public;1;16;;@Override public void deregister(ServiceDefinition definition) {     synchronized (this) {         if (definitions.stream().noneMatch(d -> matchById(d, definition))) {             LOGGER.debug("Deregister service with definition: {} with registrations: {}", definition, registrationType).             // compute registration from definition             Registration result = convertServiceDefinition(definition).             serviceRegistry.deregister(result).         }         // remove any instance with the same id         definitions.removeIf(d -> matchById(d, definition)).     } }
false;protected;0;3;;@Override protected void doStart() throws Exception { }
false;protected;0;6;;@Override protected void doStop() throws Exception {     synchronized (this) {         new ArrayList<>(definitions).forEach(this::deregister).     } }
false;public;0;3;;public ServiceRegistry getNativeServiceRegistry() {     return this.serviceRegistry. }
false;public;1;3;;public <R extends Registration, T extends ServiceRegistry<R>> T getNativeServiceRegistry(Class<T> type) {     return type.cast(this.serviceRegistry). }
true;private;1;27;/**  * Determine the native registration type. This is needed because the registry  * specific implementation provided by spring-cloud-xyz does not handle generic  * Registration object but needs a Registration specific to the underlying  * technology used.  *  * @return the registration type  */ ;/**  * Determine the native registration type. This is needed because the registry  * specific implementation provided by spring-cloud-xyz does not handle generic  * Registration object but needs a Registration specific to the underlying  * technology used.  *  * @return the registration type  */ private Class<? extends Registration> determineRegistrationType(String methodName) {     Class<? extends Registration> type = null.     Method[] methods = serviceRegistry.getClass().getDeclaredMethods().     for (Method method : methods) {         if (!methodName.equals(method.getName())) {             continue.         }         if (method.getParameterCount() != 1) {             continue.         }         Class<?> parameterType = method.getParameterTypes()[0].         if (Registration.class.isAssignableFrom(parameterType)) {             if (type == null) {                 type = (Class<? extends Registration>) parameterType.             } else {                 if (type.isAssignableFrom(parameterType)) {                     type = (Class<? extends Registration>) parameterType.                 }             }         }     }     return type != null ? type : Registration.class. }
false;private;2;7;;private boolean matchById(ServiceDefinition definition, ServiceDefinition reference) {     if (definition.getId() == null || reference.getId() == null) {         return false.     }     return Objects.equals(definition.getId(), reference.getId()). }
false;private;1;11;;private Registration convertServiceDefinition(ServiceDefinition definition) {     for (int i = 0. i < conversionServices.size(). i++) {         ConversionService cs = conversionServices.get(i).         if (cs.canConvert(ServiceDefinition.class, registrationType)) {             return cs.convert(definition, registrationType).         }     }     throw new IllegalStateException("Unable to convert service definition to native registration of type:" + registrationType). }
