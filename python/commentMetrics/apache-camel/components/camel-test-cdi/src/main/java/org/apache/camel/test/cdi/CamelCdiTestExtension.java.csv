commented;modifiers;parameterAmount;loc;comment;code
true;private;1;21;/**  * Activates the alternatives declared with {@code @Beans} globally for the  * application.  * <p/>  * For every types and every methods of every types declared with  * {@link Beans#alternatives()}, the {@code Priority} annotation is added  * so that the corresponding alternatives are selected globally for the  * entire application.  *  * @see Beans  */ ;/**  * Activates the alternatives declared with {@code @Beans} globally for the  * application.  * <p/>  * For every types and every methods of every types declared with  * {@link Beans#alternatives()}, the {@code Priority} annotation is added  * so that the corresponding alternatives are selected globally for the  * entire application.  *  * @see Beans  */ private <T> void alternatives(@Observes @WithAnnotations(Alternative.class) ProcessAnnotatedType<T> pat) {     AnnotatedType<T> type = pat.getAnnotatedType().     if (!Arrays.asList(beans.alternatives()).contains(type.getJavaClass())) {         // Only select globally the alternatives that are declared with @Beans         return.     }     Set<AnnotatedMethod<? super T>> methods = new HashSet<>().     for (AnnotatedMethod<? super T> method : type.getMethods()) {         if (method.isAnnotationPresent(Alternative.class) && !method.isAnnotationPresent(Priority.class)) {             methods.add(new AnnotatedMethodDecorator<>(method, PriorityLiteral.of(APPLICATION))).         }     }     if (type.isAnnotationPresent(Alternative.class) && !type.isAnnotationPresent(Priority.class)) {         pat.setAnnotatedType(new AnnotatedTypeDecorator<>(type, PriorityLiteral.of(APPLICATION), methods)).     } else if (!methods.isEmpty()) {         pat.setAnnotatedType(new AnnotatedTypeDecorator<>(type, methods)).     } }
