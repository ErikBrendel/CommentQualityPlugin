commented;modifiers;parameterAmount;loc;comment;code
false;public;0;15;;@Before @Override public void setUp() throws Exception {     localServer = ServerBootstrap.bootstrap().setHttpProcessor(getBasicHttpProcessor()).setConnectionReuseStrategy(getConnectionReuseStrategy()).setResponseFactory(getHttpResponseFactory()).setExpectationVerifier(getHttpExpectationVerifier()).setSslContext(getSSLContext()).registerHandler("/test/", new BasicValidationHandler("GET", null, null, getExpectedContent())).create().     localServer.start().     super.setUp(). }
false;public;0;9;;@After @Override public void tearDown() throws Exception {     super.tearDown().     if (localServer != null) {         localServer.stop().     } }
false;public;1;2;;public void process(Exchange exchange) throws Exception { }
false;public;0;22;;@Test public void httpDisableStreamCache() throws Exception {     Exchange exchange = template.request("http4://" + localServer.getInetAddress().getHostName() + ":" + localServer.getLocalPort() + "/test/?disableStreamCache=true", new Processor() {          public void process(Exchange exchange) throws Exception {         }     }).     InputStream is = assertIsInstanceOf(InputStream.class, exchange.getOut().getBody()).     assertNotNull(is).     String name = is.getClass().getName().     // should not be stream cache     assertFalse(name.contains("CachedOutputStream")).     // should be closed by http client     try {         assertEquals("camel rocks!", context.getTypeConverter().convertTo(String.class, exchange, is)).         fail("Should fail").     } catch (TypeConversionException e) {     // expected     } }
