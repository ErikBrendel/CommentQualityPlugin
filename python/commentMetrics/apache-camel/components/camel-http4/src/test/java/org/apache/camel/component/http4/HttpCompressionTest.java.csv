commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;@Before @Override public void setUp() throws Exception {     Map<String, String> expectedHeaders = new HashMap<>().     expectedHeaders.put("Content-Type", "text/plain").     expectedHeaders.put("Content-Encoding", "gzip").     localServer = ServerBootstrap.bootstrap().setHttpProcessor(getBasicHttpProcessor()).setConnectionReuseStrategy(getConnectionReuseStrategy()).setResponseFactory(getHttpResponseFactory()).setExpectationVerifier(getHttpExpectationVerifier()).setSslContext(getSSLContext()).registerHandler("/", new HeaderValidationHandler("POST", null, getBody(), getExpectedContent(), expectedHeaders)).create().     localServer.start().     super.setUp(). }
false;public;0;9;;@After @Override public void tearDown() throws Exception {     super.tearDown().     if (localServer != null) {         localServer.stop().     } }
false;public;1;5;;public void process(Exchange exchange) throws Exception {     exchange.getIn().setHeader(Exchange.CONTENT_TYPE, "text/plain").     exchange.getIn().setHeader(Exchange.CONTENT_ENCODING, "gzip").     exchange.getIn().setBody(getBody()). }
false;public;0;20;;@Test public void compressedHttpPost() throws Exception {     Exchange exchange = template.request("http4://" + localServer.getInetAddress().getHostName() + ":" + localServer.getLocalPort() + "/", new Processor() {          public void process(Exchange exchange) throws Exception {             exchange.getIn().setHeader(Exchange.CONTENT_TYPE, "text/plain").             exchange.getIn().setHeader(Exchange.CONTENT_ENCODING, "gzip").             exchange.getIn().setBody(getBody()).         }     }).     assertNotNull(exchange).     Message out = exchange.getOut().     assertNotNull(out).     Map<String, Object> headers = out.getHeaders().     assertEquals(HttpStatus.SC_OK, headers.get(Exchange.HTTP_RESPONSE_CODE)).     assertBody(out.getBody(String.class)). }
false;protected;0;10;;@Override protected HttpProcessor getBasicHttpProcessor() {     List<HttpRequestInterceptor> requestInterceptors = new ArrayList<>().     requestInterceptors.add(new RequestDecompressingInterceptor()).     List<HttpResponseInterceptor> responseInterceptors = new ArrayList<>().     responseInterceptors.add(new ResponseCompressingInterceptor()).     responseInterceptors.add(new ResponseBasicUnauthorized()).     ImmutableHttpProcessor httpproc = new ImmutableHttpProcessor(requestInterceptors, responseInterceptors).     return httpproc. }
false;protected;0;3;;protected String getBody() {     return "hl=en&q=camel". }
false;public;2;11;;public void process(HttpRequest request, HttpContext context) throws HttpException, IOException {     Header contentEncoding = request.getFirstHeader("Content-Encoding").     if (contentEncoding != null && contentEncoding.getValue().equalsIgnoreCase("gzip")) {         HttpEntity entity = ((HttpEntityEnclosingRequest) request).getEntity().         ((HttpEntityEnclosingRequest) request).setEntity(new GzipDecompressingEntity(entity)).     } }
false;public;0;6;;@Override public InputStream getContent() throws IOException, IllegalStateException {     InputStream wrappedin = wrappedEntity.getContent().     return new GZIPInputStream(wrappedin). }
false;public;0;4;;@Override public long getContentLength() {     return -1. }
false;public;0;4;;@Override public boolean isStreaming() {     return false. }
false;public;2;5;;public void process(HttpResponse response, HttpContext context) throws HttpException, IOException {     response.setHeader("Content-Encoding", "gzip").     HttpEntity entity = response.getEntity().     response.setEntity(new GzipCompressingEntity(entity)). }
false;public;0;4;;@Override public Header getContentEncoding() {     return new BasicHeader("Content-Encoding", "gzip"). }
false;public;1;6;;@Override public void writeTo(OutputStream outstream) throws IOException {     GZIPOutputStream gzip = new GZIPOutputStream(outstream).     gzip.write(EntityUtils.toByteArray(wrappedEntity)).     gzip.close(). }
false;public;0;4;;@Override public long getContentLength() {     return -1. }
false;public;0;4;;@Override public boolean isStreaming() {     return false. }
