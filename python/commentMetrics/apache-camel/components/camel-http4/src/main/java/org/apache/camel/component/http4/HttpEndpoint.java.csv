commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Producer createProducer() throws Exception {     return new HttpProducer(this). }
false;public;1;4;;@Override public Consumer createConsumer(Processor processor) throws Exception {     throw new UnsupportedOperationException("Cannot consume from http endpoint"). }
false;public;0;5;;public PollingConsumer createPollingConsumer() throws Exception {     HttpPollingConsumer answer = new HttpPollingConsumer(this).     configurePollingConsumer(answer).     return answer. }
false;public,synchronized;0;6;;public synchronized HttpClient getHttpClient() {     if (httpClient == null) {         httpClient = createHttpClient().     }     return httpClient. }
true;public;1;3;/**  * Sets a custom HttpClient to be used by the producer  */ ;/**  * Sets a custom HttpClient to be used by the producer  */ public void setHttpClient(HttpClient httpClient) {     this.httpClient = httpClient. }
true;protected;0;48;/**  * Factory method to create a new {@link HttpClient} instance  * <p/>  * Producers and consumers should use the {@link #getHttpClient()} method instead.  */ ;/**  * Factory method to create a new {@link HttpClient} instance  * <p/>  * Producers and consumers should use the {@link #getHttpClient()} method instead.  */ protected HttpClient createHttpClient() {     ObjectHelper.notNull(clientBuilder, "httpClientBuilder").     ObjectHelper.notNull(clientConnectionManager, "httpConnectionManager").     // setup the cookieStore     clientBuilder.setDefaultCookieStore(cookieStore).     // setup the httpConnectionManager     clientBuilder.setConnectionManager(clientConnectionManager).     if (getComponent() != null && getComponent().getClientConnectionManager() == getClientConnectionManager()) {         clientBuilder.setConnectionManagerShared(true).     }     if (!useSystemProperties) {         // configure http proxy from camelContext         if (ObjectHelper.isNotEmpty(getCamelContext().getGlobalOption("http.proxyHost")) && ObjectHelper.isNotEmpty(getCamelContext().getGlobalOption("http.proxyPort"))) {             String host = getCamelContext().getGlobalOption("http.proxyHost").             int port = Integer.parseInt(getCamelContext().getGlobalOption("http.proxyPort")).             String scheme = getCamelContext().getGlobalOption("http.proxyScheme").             // fallback and use either http or https depending on secure             if (scheme == null) {                 scheme = HttpHelper.isSecureConnection(getEndpointUri()) ? "https" : "http".             }             log.debug("CamelContext properties http.proxyHost, http.proxyPort, and http.proxyScheme detected. Using http proxy host: {} port: {} scheme: {}", host, port, scheme).             HttpHost proxy = new HttpHost(host, port, scheme).             clientBuilder.setProxy(proxy).         }     } else {         clientBuilder.useSystemProperties().     }     if (isAuthenticationPreemptive()) {         // setup the PreemptiveAuthInterceptor here         clientBuilder.addInterceptorFirst(new PreemptiveAuthInterceptor()).     }     HttpClientConfigurer configurer = getHttpClientConfigurer().     if (configurer != null) {         configurer.configureHttpClient(clientBuilder).     }     if (isBridgeEndpoint()) {         // need to use noop cookiestore as we do not want to keep cookies in memory         clientBuilder.setDefaultCookieStore(new NoopCookieStore()).     }     log.debug("Setup the HttpClientBuilder {}", clientBuilder).     return clientBuilder.build(). }
false;public;0;4;;@Override public HttpComponent getComponent() {     return (HttpComponent) super.getComponent(). }
false;protected;0;10;;@Override protected void doStop() throws Exception {     if (getComponent() != null && getComponent().getClientConnectionManager() != clientConnectionManager) {         // need to shutdown the ConnectionManager         clientConnectionManager.shutdown().     }     if (httpClient instanceof Closeable) {         IOHelper.close((Closeable) httpClient).     } }
false;public;0;3;;// Properties // ------------------------------------------------------------------------- public HttpClientBuilder getClientBuilder() {     return clientBuilder. }
true;public;1;3;/**  * Provide access to the http client request parameters used on new {@link RequestConfig} instances  * used by producers or consumers of this endpoint.  */ ;/**  * Provide access to the http client request parameters used on new {@link RequestConfig} instances  * used by producers or consumers of this endpoint.  */ public void setClientBuilder(HttpClientBuilder clientBuilder) {     this.clientBuilder = clientBuilder. }
false;public;0;3;;public HttpClientConfigurer getHttpClientConfigurer() {     return httpClientConfigurer. }
true;public;1;3;/**  * Register a custom configuration strategy for new {@link HttpClient} instances  * created by producers or consumers such as to configure authentication mechanisms etc  */ ;/**  * Register a custom configuration strategy for new {@link HttpClient} instances  * created by producers or consumers such as to configure authentication mechanisms etc  */ public void setHttpClientConfigurer(HttpClientConfigurer httpClientConfigurer) {     this.httpClientConfigurer = httpClientConfigurer. }
false;public;0;3;;public HttpContext getHttpContext() {     return httpContext. }
true;public;1;3;/**  * To use a custom HttpContext instance  */ ;/**  * To use a custom HttpContext instance  */ public void setHttpContext(HttpContext httpContext) {     this.httpContext = httpContext. }
false;public;0;3;;public HttpClientConnectionManager getClientConnectionManager() {     return clientConnectionManager. }
true;public;1;3;/**  * To use a custom HttpClientConnectionManager to manage connections  */ ;/**  * To use a custom HttpClientConnectionManager to manage connections  */ public void setClientConnectionManager(HttpClientConnectionManager clientConnectionManager) {     this.clientConnectionManager = clientConnectionManager. }
false;public;0;3;;public boolean isClearExpiredCookies() {     return clearExpiredCookies. }
true;public;1;3;/**  * Whether to clear expired cookies before sending the HTTP request.  * This ensures the cookies store does not keep growing by adding new cookies which is newer removed when they are expired.  */ ;/**  * Whether to clear expired cookies before sending the HTTP request.  * This ensures the cookies store does not keep growing by adding new cookies which is newer removed when they are expired.  */ public void setClearExpiredCookies(boolean clearExpiredCookies) {     this.clearExpiredCookies = clearExpiredCookies. }
false;public;0;3;;public boolean isDeleteWithBody() {     return deleteWithBody. }
true;public;1;3;/**  * Whether the HTTP DELETE should include the message body or not.  * <p/>  * By default HTTP DELETE do not include any HTTP message. However in some rare cases users may need to be able to include the  * message body.  */ ;/**  * Whether the HTTP DELETE should include the message body or not.  * <p/>  * By default HTTP DELETE do not include any HTTP message. However in some rare cases users may need to be able to include the  * message body.  */ public void setDeleteWithBody(boolean deleteWithBody) {     this.deleteWithBody = deleteWithBody. }
false;public;0;3;;public CookieStore getCookieStore() {     return cookieStore. }
true;public;1;3;/**  * To use a custom CookieStore.  * By default the BasicCookieStore is used which is an in-memory only cookie store.  * Notice if bridgeEndpoint=true then the cookie store is forced to be a noop cookie store as cookie  * shouldn't be stored as we are just bridging (eg acting as a proxy).  * If a cookieHandler is set then the cookie store is also forced to be a noop cookie store as cookie handling is  * then performed by the cookieHandler.  */ ;/**  * To use a custom CookieStore.  * By default the BasicCookieStore is used which is an in-memory only cookie store.  * Notice if bridgeEndpoint=true then the cookie store is forced to be a noop cookie store as cookie  * shouldn't be stored as we are just bridging (eg acting as a proxy).  * If a cookieHandler is set then the cookie store is also forced to be a noop cookie store as cookie handling is  * then performed by the cookieHandler.  */ public void setCookieStore(CookieStore cookieStore) {     this.cookieStore = cookieStore. }
false;public;1;5;;public void setCookieHandler(CookieHandler cookieHandler) {     super.setCookieHandler(cookieHandler).     // if we set an explicit cookie handler     this.cookieStore = new NoopCookieStore(). }
false;public;0;3;;public boolean isAuthenticationPreemptive() {     return authenticationPreemptive. }
true;public;1;3;/**  * If this option is true, camel-http4 sends preemptive basic authentication to the server.  */ ;/**  * If this option is true, camel-http4 sends preemptive basic authentication to the server.  */ public void setAuthenticationPreemptive(boolean authenticationPreemptive) {     this.authenticationPreemptive = authenticationPreemptive. }
false;public;0;3;;public Map<String, Object> getHttpClientOptions() {     return httpClientOptions. }
true;public;1;3;/**  * To configure the HttpClient using the key/values from the Map.  */ ;/**  * To configure the HttpClient using the key/values from the Map.  */ public void setHttpClientOptions(Map<String, Object> httpClientOptions) {     this.httpClientOptions = httpClientOptions. }
false;public;0;3;;public boolean isUseSystemProperties() {     return useSystemProperties. }
true;public;1;3;/**  * To use System Properties as fallback for configuration  */ ;/**  * To use System Properties as fallback for configuration  */ public void setUseSystemProperties(boolean useSystemProperties) {     this.useSystemProperties = useSystemProperties. }
false;public;0;3;;public int getMaxTotalConnections() {     return maxTotalConnections. }
true;public;1;3;/**  * The maximum number of connections.  */ ;/**  * The maximum number of connections.  */ public void setMaxTotalConnections(int maxTotalConnections) {     this.maxTotalConnections = maxTotalConnections. }
false;public;0;3;;public int getConnectionsPerRoute() {     return connectionsPerRoute. }
true;public;1;3;/**  * The maximum number of connections per route.  */ ;/**  * The maximum number of connections per route.  */ public void setConnectionsPerRoute(int connectionsPerRoute) {     this.connectionsPerRoute = connectionsPerRoute. }
false;public;0;3;;public HostnameVerifier getX509HostnameVerifier() {     return x509HostnameVerifier. }
true;public;1;3;/**  * To use a custom X509HostnameVerifier such as {@link DefaultHostnameVerifier}  * or {@link org.apache.http.conn.ssl.NoopHostnameVerifier}.  */ ;/**  * To use a custom X509HostnameVerifier such as {@link DefaultHostnameVerifier}  * or {@link org.apache.http.conn.ssl.NoopHostnameVerifier}.  */ public void setX509HostnameVerifier(HostnameVerifier x509HostnameVerifier) {     this.x509HostnameVerifier = x509HostnameVerifier. }
false;public;0;3;;public SSLContextParameters getSslContextParameters() {     return sslContextParameters. }
true;public;1;3;/**  * To configure security using SSLContextParameters.  * Important: Only one instance of org.apache.camel.util.jsse.SSLContextParameters is supported per HttpComponent.  * If you need to use 2 or more different instances, you need to define a new HttpComponent per instance you need.  */ ;/**  * To configure security using SSLContextParameters.  * Important: Only one instance of org.apache.camel.util.jsse.SSLContextParameters is supported per HttpComponent.  * If you need to use 2 or more different instances, you need to define a new HttpComponent per instance you need.  */ public void setSslContextParameters(SSLContextParameters sslContextParameters) {     this.sslContextParameters = sslContextParameters. }
false;public;0;3;;public int getConnectionRequestTimeout() {     return connectionRequestTimeout. }
true;public;1;3;/**  * The timeout in milliseconds used when requesting a connection  * from the connection manager. A timeout value of zero is interpreted  * as an infinite timeout.  * <p>  * A timeout value of zero is interpreted as an infinite timeout.  * A negative value is interpreted as undefined (system default).  * </p>  * <p>  * Default: {@code -1}  * </p>  */ ;/**  * The timeout in milliseconds used when requesting a connection  * from the connection manager. A timeout value of zero is interpreted  * as an infinite timeout.  * <p>  * A timeout value of zero is interpreted as an infinite timeout.  * A negative value is interpreted as undefined (system default).  * </p>  * <p>  * Default: {@code -1}  * </p>  */ public void setConnectionRequestTimeout(int connectionRequestTimeout) {     this.connectionRequestTimeout = connectionRequestTimeout. }
false;public;0;3;;public int getConnectTimeout() {     return connectTimeout. }
true;public;1;3;/**  * Determines the timeout in milliseconds until a connection is established.  * A timeout value of zero is interpreted as an infinite timeout.  * <p>  * A timeout value of zero is interpreted as an infinite timeout.  * A negative value is interpreted as undefined (system default).  * </p>  * <p>  * Default: {@code -1}  * </p>  */ ;/**  * Determines the timeout in milliseconds until a connection is established.  * A timeout value of zero is interpreted as an infinite timeout.  * <p>  * A timeout value of zero is interpreted as an infinite timeout.  * A negative value is interpreted as undefined (system default).  * </p>  * <p>  * Default: {@code -1}  * </p>  */ public void setConnectTimeout(int connectTimeout) {     this.connectTimeout = connectTimeout. }
false;public;0;3;;public int getSocketTimeout() {     return socketTimeout. }
true;public;1;3;/**  * Defines the socket timeout ({@code SO_TIMEOUT}) in milliseconds,  * which is the timeout for waiting for data  or, put differently,  * a maximum period inactivity between two consecutive data packets).  * <p>  * A timeout value of zero is interpreted as an infinite timeout.  * A negative value is interpreted as undefined (system default).  * </p>  * <p>  * Default: {@code -1}  * </p>  */ ;/**  * Defines the socket timeout ({@code SO_TIMEOUT}) in milliseconds,  * which is the timeout for waiting for data  or, put differently,  * a maximum period inactivity between two consecutive data packets).  * <p>  * A timeout value of zero is interpreted as an infinite timeout.  * A negative value is interpreted as undefined (system default).  * </p>  * <p>  * Default: {@code -1}  * </p>  */ public void setSocketTimeout(int socketTimeout) {     this.socketTimeout = socketTimeout. }
false;public;0;14;;@ManagedAttribute(description = "Maximum number of allowed persistent connections") public int getClientConnectionsPoolStatsMax() {     ConnPoolControl<?> pool = null.     if (clientConnectionManager instanceof ConnPoolControl) {         pool = (ConnPoolControl<?>) clientConnectionManager.     }     if (pool != null) {         PoolStats stats = pool.getTotalStats().         if (stats != null) {             return stats.getMax().         }     }     return -1. }
false;public;0;14;;@ManagedAttribute(description = "Number of available idle persistent connections") public int getClientConnectionsPoolStatsAvailable() {     ConnPoolControl<?> pool = null.     if (clientConnectionManager instanceof ConnPoolControl) {         pool = (ConnPoolControl<?>) clientConnectionManager.     }     if (pool != null) {         PoolStats stats = pool.getTotalStats().         if (stats != null) {             return stats.getAvailable().         }     }     return -1. }
false;public;0;14;;@ManagedAttribute(description = "Number of persistent connections tracked by the connection manager currently being used to execute requests") public int getClientConnectionsPoolStatsLeased() {     ConnPoolControl<?> pool = null.     if (clientConnectionManager instanceof ConnPoolControl) {         pool = (ConnPoolControl<?>) clientConnectionManager.     }     if (pool != null) {         PoolStats stats = pool.getTotalStats().         if (stats != null) {             return stats.getLeased().         }     }     return -1. }
false;public;0;15;;@ManagedAttribute(description = "Number of connection requests being blocked awaiting a free connection." + " This can happen only if there are more worker threads contending for fewer connections.") public int getClientConnectionsPoolStatsPending() {     ConnPoolControl<?> pool = null.     if (clientConnectionManager instanceof ConnPoolControl) {         pool = (ConnPoolControl<?>) clientConnectionManager.     }     if (pool != null) {         PoolStats stats = pool.getTotalStats().         if (stats != null) {             return stats.getPending().         }     }     return -1. }
