commented;modifiers;parameterAmount;loc;comment;code
true;protected;2;13;/**  * Creates the HttpClientConfigurer based on the given parameters  *  * @param parameters the map of parameters  * @param secure whether the endpoint is secure (eg https4)  * @return the configurer  * @throws Exception is thrown if error creating configurer  */ ;/**  * Creates the HttpClientConfigurer based on the given parameters  *  * @param parameters the map of parameters  * @param secure whether the endpoint is secure (eg https4)  * @return the configurer  * @throws Exception is thrown if error creating configurer  */ protected HttpClientConfigurer createHttpClientConfigurer(Map<String, Object> parameters, boolean secure) throws Exception {     // prefer to use endpoint configured over component configured     HttpClientConfigurer configurer = resolveAndRemoveReferenceParameter(parameters, "httpClientConfigurer", HttpClientConfigurer.class).     if (configurer == null) {         // fallback to component configured         configurer = getHttpClientConfigurer().     }     configurer = configureBasicAuthentication(parameters, configurer).     configurer = configureHttpProxy(parameters, configurer, secure).     return configurer. }
false;private;2;18;;private HttpClientConfigurer configureBasicAuthentication(Map<String, Object> parameters, HttpClientConfigurer configurer) {     String authUsername = getParameter(parameters, "authUsername", String.class).     String authPassword = getParameter(parameters, "authPassword", String.class).     if (authUsername != null && authPassword != null) {         String authDomain = getParameter(parameters, "authDomain", String.class).         String authHost = getParameter(parameters, "authHost", String.class).         return CompositeHttpConfigurer.combineConfigurers(configurer, new BasicAuthenticationHttpClientConfigurer(authUsername, authPassword, authDomain, authHost)).     } else if (this.httpConfiguration != null) {         if ("basic".equalsIgnoreCase(this.httpConfiguration.getAuthMethod())) {             return CompositeHttpConfigurer.combineConfigurers(configurer, new BasicAuthenticationHttpClientConfigurer(this.httpConfiguration.getAuthUsername(), this.httpConfiguration.getAuthPassword(), this.httpConfiguration.getAuthDomain(), this.httpConfiguration.getAuthHost())).         }     }     return configurer. }
false;private;3;25;;private HttpClientConfigurer configureHttpProxy(Map<String, Object> parameters, HttpClientConfigurer configurer, boolean secure) throws Exception {     String proxyAuthScheme = getParameter(parameters, "proxyAuthScheme", String.class).     if (proxyAuthScheme == null) {         // fallback and use either http or https depending on secure         proxyAuthScheme = secure ? "https" : "http".     }     String proxyAuthHost = getParameter(parameters, "proxyAuthHost", String.class).     Integer proxyAuthPort = getParameter(parameters, "proxyAuthPort", Integer.class).     if (proxyAuthHost != null && proxyAuthPort != null) {         String proxyAuthUsername = getParameter(parameters, "proxyAuthUsername", String.class).         String proxyAuthPassword = getParameter(parameters, "proxyAuthPassword", String.class).         String proxyAuthDomain = getParameter(parameters, "proxyAuthDomain", String.class).         String proxyAuthNtHost = getParameter(parameters, "proxyAuthNtHost", String.class).         if (proxyAuthUsername != null && proxyAuthPassword != null) {             return CompositeHttpConfigurer.combineConfigurers(configurer, new ProxyHttpClientConfigurer(proxyAuthHost, proxyAuthPort, proxyAuthScheme, proxyAuthUsername, proxyAuthPassword, proxyAuthDomain, proxyAuthNtHost)).         } else {             return CompositeHttpConfigurer.combineConfigurers(configurer, new ProxyHttpClientConfigurer(proxyAuthHost, proxyAuthPort, proxyAuthScheme)).         }     }     return configurer. }
false;protected;3;131;;@Override protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {     Map<String, Object> httpClientParameters = new HashMap<>(parameters).     final Map<String, Object> httpClientOptions = new HashMap<>().     // timeout values can be configured on both component and endpoint level, where endpoint take priority     int val = getAndRemoveParameter(parameters, "connectionRequestTimeout", int.class, connectionRequestTimeout).     if (val != -1) {         httpClientOptions.put("connectionRequestTimeout", val).     }     val = getAndRemoveParameter(parameters, "connectTimeout", int.class, connectTimeout).     if (val != -1) {         httpClientOptions.put("connectTimeout", val).     }     val = getAndRemoveParameter(parameters, "socketTimeout", int.class, socketTimeout).     if (val != -1) {         httpClientOptions.put("socketTimeout", val).     }     final HttpClientBuilder clientBuilder = createHttpClientBuilder(uri, parameters, httpClientOptions).     HttpBinding httpBinding = resolveAndRemoveReferenceParameter(parameters, "httpBinding", HttpBinding.class).     HttpContext httpContext = resolveAndRemoveReferenceParameter(parameters, "httpContext", HttpContext.class).     SSLContextParameters sslContextParameters = resolveAndRemoveReferenceParameter(parameters, "sslContextParameters", SSLContextParameters.class).     if (sslContextParameters == null) {         sslContextParameters = getSslContextParameters().     }     if (sslContextParameters == null) {         sslContextParameters = retrieveGlobalSslContextParameters().     }     String httpMethodRestrict = getAndRemoveParameter(parameters, "httpMethodRestrict", String.class).     HeaderFilterStrategy headerFilterStrategy = resolveAndRemoveReferenceParameter(parameters, "headerFilterStrategy", HeaderFilterStrategy.class).     UrlRewrite urlRewrite = resolveAndRemoveReferenceParameter(parameters, "urlRewrite", UrlRewrite.class).     boolean secure = HttpHelper.isSecureConnection(uri) || sslContextParameters != null.     // need to set scheme on address uri depending on if its secure or not     String addressUri = (secure ? "https://" : "http://") + remaining.     addressUri = UnsafeUriCharactersEncoder.encodeHttpURI(addressUri).     URI uriHttpUriAddress = new URI(addressUri).     // validate http uri that end-user did not duplicate the http part that can be a common error     int pos = uri.indexOf("//").     if (pos != -1) {         String part = uri.substring(pos + 2).         if (part.startsWith("http:") || part.startsWith("https:")) {             throw new ResolveEndpointFailedException(uri, "The uri part is not configured correctly. You have duplicated the http(s) protocol.").         }     }     // create the configurer to use for this endpoint     HttpClientConfigurer configurer = createHttpClientConfigurer(parameters, secure).     URI endpointUri = URISupport.createRemainingURI(uriHttpUriAddress, httpClientParameters).     // the endpoint uri should use the component name as scheme, so we need to re-create it once more     String scheme = StringHelper.before(uri, "://").     endpointUri = URISupport.createRemainingURI(new URI(scheme, endpointUri.getUserInfo(), endpointUri.getHost(), endpointUri.getPort(), endpointUri.getPath(), endpointUri.getQuery(), endpointUri.getFragment()), httpClientParameters).     // create the endpoint and set the http uri to be null     String endpointUriString = endpointUri.toString().     log.debug("Creating endpoint uri {}", endpointUriString).     final HttpClientConnectionManager localConnectionManager = createConnectionManager(parameters, sslContextParameters).     HttpEndpoint endpoint = new HttpEndpoint(endpointUriString, this, clientBuilder, localConnectionManager, configurer).     // configure the endpoint with the common configuration from the component     if (getHttpConfiguration() != null) {         Map<String, Object> properties = new HashMap<>().         IntrospectionSupport.getProperties(getHttpConfiguration(), properties, null).         setProperties(endpoint, properties).     }     if (urlRewrite != null) {         // let CamelContext deal with the lifecycle of the url rewrite         // this ensures its being shutdown when Camel shutdown etc.         getCamelContext().addService(urlRewrite).         endpoint.setUrlRewrite(urlRewrite).     }     // configure the endpoint     setProperties(endpoint, parameters).     // we can not change the port of an URI, we must create a new one with an explicit port value     URI httpUri = URISupport.createRemainingURI(new URI(uriHttpUriAddress.getScheme(), uriHttpUriAddress.getUserInfo(), uriHttpUriAddress.getHost(), uriHttpUriAddress.getPort(), uriHttpUriAddress.getPath(), uriHttpUriAddress.getQuery(), uriHttpUriAddress.getFragment()), parameters).     endpoint.setHttpUri(httpUri).     if (headerFilterStrategy != null) {         endpoint.setHeaderFilterStrategy(headerFilterStrategy).     } else {         setEndpointHeaderFilterStrategy(endpoint).     }     endpoint.setHttpBinding(getHttpBinding()).     if (httpBinding != null) {         endpoint.setHttpBinding(httpBinding).     }     if (httpMethodRestrict != null) {         endpoint.setHttpMethodRestrict(httpMethodRestrict).     }     endpoint.setHttpContext(getHttpContext()).     if (httpContext != null) {         endpoint.setHttpContext(httpContext).     }     if (endpoint.getCookieStore() == null) {         endpoint.setCookieStore(getCookieStore()).     }     endpoint.setHttpClientOptions(httpClientOptions).     return endpoint. }
false;protected;2;17;;protected HttpClientConnectionManager createConnectionManager(final Map<String, Object> parameters, final SSLContextParameters sslContextParameters) throws GeneralSecurityException, IOException {     if (clientConnectionManager != null) {         return clientConnectionManager.     }     final HostnameVerifier resolvedHostnameVerifier = resolveAndRemoveReferenceParameter(parameters, "x509HostnameVerifier", HostnameVerifier.class).     final HostnameVerifier hostnameVerifier = Optional.ofNullable(resolvedHostnameVerifier).orElse(x509HostnameVerifier).     // need to check the parameters of maxTotalConnections and connectionsPerRoute     final int maxTotalConnections = getAndRemoveParameter(parameters, "maxTotalConnections", int.class, 0).     final int connectionsPerRoute = getAndRemoveParameter(parameters, "connectionsPerRoute", int.class, 0).     final Registry<ConnectionSocketFactory> connectionRegistry = createConnectionRegistry(hostnameVerifier, sslContextParameters).     return createConnectionManager(connectionRegistry, maxTotalConnections, connectionsPerRoute). }
false;protected;3;17;;protected HttpClientBuilder createHttpClientBuilder(final String uri, final Map<String, Object> parameters, final Map<String, Object> httpClientOptions) throws Exception {     // http client can be configured from URI options     HttpClientBuilder clientBuilder = HttpClientBuilder.create().     // allow the builder pattern     httpClientOptions.putAll(IntrospectionSupport.extractProperties(parameters, "httpClient.")).     IntrospectionSupport.setProperties(clientBuilder, httpClientOptions).     // set the Request configure this way and allow the builder pattern     RequestConfig.Builder requestConfigBuilder = RequestConfig.custom().     IntrospectionSupport.setProperties(requestConfigBuilder, httpClientOptions).     clientBuilder.setDefaultRequestConfig(requestConfigBuilder.build()).     // validate that we could resolve all httpClient. parameters as this component is lenient     validateParameters(uri, httpClientOptions, null).     return clientBuilder. }
false;protected;2;15;;protected Registry<ConnectionSocketFactory> createConnectionRegistry(HostnameVerifier x509HostnameVerifier, SSLContextParameters sslContextParams) throws GeneralSecurityException, IOException {     // create the default connection registry to use     RegistryBuilder<ConnectionSocketFactory> builder = RegistryBuilder.<ConnectionSocketFactory>create().     builder.register("http", PlainConnectionSocketFactory.getSocketFactory()).     builder.register("http4", PlainConnectionSocketFactory.getSocketFactory()).     if (sslContextParams != null) {         builder.register("https", new SSLConnectionSocketFactory(sslContextParams.createSSLContext(getCamelContext()), x509HostnameVerifier)).         builder.register("https4", new SSLConnectionSocketFactory(sslContextParams.createSSLContext(getCamelContext()), x509HostnameVerifier)).     } else {         builder.register("https", new SSLConnectionSocketFactory(SSLContexts.createDefault(), x509HostnameVerifier)).         builder.register("https4", new SSLConnectionSocketFactory(SSLContexts.createDefault(), x509HostnameVerifier)).     }     return builder.build(). }
false;protected;1;3;;protected HttpClientConnectionManager createConnectionManager(Registry<ConnectionSocketFactory> registry) {     return createConnectionManager(registry, 0, 0). }
false;protected;3;22;;protected HttpClientConnectionManager createConnectionManager(Registry<ConnectionSocketFactory> registry, int maxTotalConnections, int connectionsPerRoute) {     // setup the connection live time     PoolingHttpClientConnectionManager answer = new PoolingHttpClientConnectionManager(registry, null, null, null, getConnectionTimeToLive(), TimeUnit.MILLISECONDS).     int localMaxTotalConnections = maxTotalConnections.     if (localMaxTotalConnections == 0) {         localMaxTotalConnections = getMaxTotalConnections().     }     if (localMaxTotalConnections > 0) {         answer.setMaxTotal(localMaxTotalConnections).     }     int localConnectionsPerRoute = connectionsPerRoute.     if (localConnectionsPerRoute == 0) {         localConnectionsPerRoute = getConnectionsPerRoute().     }     if (localConnectionsPerRoute > 0) {         answer.setDefaultMaxPerRoute(localConnectionsPerRoute).     }     log.info("Created ClientConnectionManager {}", answer).     return answer. }
false;protected;0;4;;@Override protected boolean useIntrospectionOnEndpoint() {     return false. }
false;public;10;58;;@Override public Producer createProducer(CamelContext camelContext, String host, String verb, String basePath, String uriTemplate, String queryParameters, String consumes, String produces, RestConfiguration configuration, Map<String, Object> parameters) throws Exception {     // avoid leading slash     basePath = FileUtil.stripLeadingSeparator(basePath).     uriTemplate = FileUtil.stripLeadingSeparator(uriTemplate).     // replace http with http4 in the host part     host = host.replaceFirst(":", "4:").     // get the endpoint     String url = host.     if (!ObjectHelper.isEmpty(basePath)) {         url += "/" + basePath.     }     if (!ObjectHelper.isEmpty(uriTemplate)) {         url += "/" + uriTemplate.     }     RestConfiguration config = configuration.     if (config == null) {         config = camelContext.getRestConfiguration("http4", true).     }     Map<String, Object> map = new HashMap<>().     // build query string, and append any endpoint configuration properties     if (config.getComponent() == null || config.getComponent().equals("http4")) {         // setup endpoint options         if (config.getEndpointProperties() != null && !config.getEndpointProperties().isEmpty()) {             map.putAll(config.getEndpointProperties()).         }     }     // get the endpoint     String query = URISupport.createQueryString(map).     if (!query.isEmpty()) {         url = url + "?" + query.     }     // there are cases where we might end up here without component being created beforehand     // we need to abide by the component properties specified in the parameters when creating     // the component, one such case is when we switch from "http4" to "https4" component name     RestProducerFactoryHelper.setupComponentFor(url, camelContext, (Map<String, Object>) parameters.get("component")).     HttpEndpoint endpoint = camelContext.getEndpoint(url, HttpEndpoint.class).     if (parameters != null && !parameters.isEmpty()) {         setProperties(camelContext, endpoint, parameters).     }     String path = uriTemplate != null ? uriTemplate : basePath.     endpoint.setHeaderFilterStrategy(new HttpRestHeaderFilterStrategy(path, queryParameters)).     // the endpoint must be started before creating the producer     ServiceHelper.startService(endpoint).     return endpoint.createProducer(). }
false;public;0;3;;public HttpClientConfigurer getHttpClientConfigurer() {     return httpClientConfigurer. }
true;public;1;3;/**  * To use the custom HttpClientConfigurer to perform configuration of the HttpClient that will be used.  */ ;/**  * To use the custom HttpClientConfigurer to perform configuration of the HttpClient that will be used.  */ public void setHttpClientConfigurer(HttpClientConfigurer httpClientConfigurer) {     this.httpClientConfigurer = httpClientConfigurer. }
false;public;0;3;;public HttpClientConnectionManager getClientConnectionManager() {     return clientConnectionManager. }
true;public;1;3;/**  * To use a custom and shared HttpClientConnectionManager to manage connections.  * If this has been configured then this is always used for all endpoints created by this component.  */ ;/**  * To use a custom and shared HttpClientConnectionManager to manage connections.  * If this has been configured then this is always used for all endpoints created by this component.  */ public void setClientConnectionManager(HttpClientConnectionManager clientConnectionManager) {     this.clientConnectionManager = clientConnectionManager. }
false;public;0;3;;public HttpContext getHttpContext() {     return httpContext. }
true;public;1;3;/**  * To use a custom org.apache.http.protocol.HttpContext when executing requests.  */ ;/**  * To use a custom org.apache.http.protocol.HttpContext when executing requests.  */ public void setHttpContext(HttpContext httpContext) {     this.httpContext = httpContext. }
false;public;0;3;;public SSLContextParameters getSslContextParameters() {     return sslContextParameters. }
true;public;1;3;/**  * To configure security using SSLContextParameters.  * Important: Only one instance of org.apache.camel.support.jsse.SSLContextParameters is supported per HttpComponent.  * If you need to use 2 or more different instances, you need to define a new HttpComponent per instance you need.  */ ;/**  * To configure security using SSLContextParameters.  * Important: Only one instance of org.apache.camel.support.jsse.SSLContextParameters is supported per HttpComponent.  * If you need to use 2 or more different instances, you need to define a new HttpComponent per instance you need.  */ public void setSslContextParameters(SSLContextParameters sslContextParameters) {     this.sslContextParameters = sslContextParameters. }
false;public;0;4;;@Override public boolean isUseGlobalSslContextParameters() {     return this.useGlobalSslContextParameters. }
true;public;1;4;/**  * Enable usage of global SSL context parameters.  */ ;/**  * Enable usage of global SSL context parameters.  */ @Override public void setUseGlobalSslContextParameters(boolean useGlobalSslContextParameters) {     this.useGlobalSslContextParameters = useGlobalSslContextParameters. }
false;public;0;3;;public HostnameVerifier getX509HostnameVerifier() {     return x509HostnameVerifier. }
true;public;1;3;/**  * To use a custom X509HostnameVerifier such as DefaultHostnameVerifier or NoopHostnameVerifier.  */ ;/**  * To use a custom X509HostnameVerifier such as DefaultHostnameVerifier or NoopHostnameVerifier.  */ public void setX509HostnameVerifier(HostnameVerifier x509HostnameVerifier) {     this.x509HostnameVerifier = x509HostnameVerifier. }
false;public;0;3;;public int getMaxTotalConnections() {     return maxTotalConnections. }
true;public;1;3;/**  * The maximum number of connections.  */ ;/**  * The maximum number of connections.  */ public void setMaxTotalConnections(int maxTotalConnections) {     this.maxTotalConnections = maxTotalConnections. }
false;public;0;3;;public int getConnectionsPerRoute() {     return connectionsPerRoute. }
true;public;1;3;/**  * The maximum number of connections per route.  */ ;/**  * The maximum number of connections per route.  */ public void setConnectionsPerRoute(int connectionsPerRoute) {     this.connectionsPerRoute = connectionsPerRoute. }
false;public;0;3;;public long getConnectionTimeToLive() {     return connectionTimeToLive. }
true;public;1;3;/**  * The time for connection to live, the time unit is millisecond, the default value is always keep alive.  */ ;/**  * The time for connection to live, the time unit is millisecond, the default value is always keep alive.  */ public void setConnectionTimeToLive(long connectionTimeToLive) {     this.connectionTimeToLive = connectionTimeToLive. }
false;public;0;3;;public CookieStore getCookieStore() {     return cookieStore. }
true;public;1;3;/**  * To use a custom org.apache.http.client.CookieStore.  * By default the org.apache.http.impl.client.BasicCookieStore is used which is an in-memory only cookie store.  * Notice if bridgeEndpoint=true then the cookie store is forced to be a noop cookie store as cookie  * shouldn't be stored as we are just bridging (eg acting as a proxy).  */ ;/**  * To use a custom org.apache.http.client.CookieStore.  * By default the org.apache.http.impl.client.BasicCookieStore is used which is an in-memory only cookie store.  * Notice if bridgeEndpoint=true then the cookie store is forced to be a noop cookie store as cookie  * shouldn't be stored as we are just bridging (eg acting as a proxy).  */ public void setCookieStore(CookieStore cookieStore) {     this.cookieStore = cookieStore. }
false;public;0;3;;public int getConnectionRequestTimeout() {     return connectionRequestTimeout. }
true;public;1;3;/**  * The timeout in milliseconds used when requesting a connection  * from the connection manager. A timeout value of zero is interpreted  * as an infinite timeout.  * <p>  * A timeout value of zero is interpreted as an infinite timeout.  * A negative value is interpreted as undefined (system default).  * </p>  * <p>  * Default: -1  * </p>  */ ;/**  * The timeout in milliseconds used when requesting a connection  * from the connection manager. A timeout value of zero is interpreted  * as an infinite timeout.  * <p>  * A timeout value of zero is interpreted as an infinite timeout.  * A negative value is interpreted as undefined (system default).  * </p>  * <p>  * Default: -1  * </p>  */ public void setConnectionRequestTimeout(int connectionRequestTimeout) {     this.connectionRequestTimeout = connectionRequestTimeout. }
false;public;0;3;;public int getConnectTimeout() {     return connectTimeout. }
true;public;1;3;/**  * Determines the timeout in milliseconds until a connection is established.  * A timeout value of zero is interpreted as an infinite timeout.  * <p>  * A timeout value of zero is interpreted as an infinite timeout.  * A negative value is interpreted as undefined (system default).  * </p>  * <p>  * Default: -1  * </p>  */ ;/**  * Determines the timeout in milliseconds until a connection is established.  * A timeout value of zero is interpreted as an infinite timeout.  * <p>  * A timeout value of zero is interpreted as an infinite timeout.  * A negative value is interpreted as undefined (system default).  * </p>  * <p>  * Default: -1  * </p>  */ public void setConnectTimeout(int connectTimeout) {     this.connectTimeout = connectTimeout. }
false;public;0;3;;public int getSocketTimeout() {     return socketTimeout. }
true;public;1;3;/**  * Defines the socket timeout (SO_TIMEOUT) in milliseconds,  * which is the timeout for waiting for data  or, put differently,  * a maximum period inactivity between two consecutive data packets).  * <p>  * A timeout value of zero is interpreted as an infinite timeout.  * A negative value is interpreted as undefined (system default).  * </p>  * <p>  * Default: -1  * </p>  */ ;/**  * Defines the socket timeout (SO_TIMEOUT) in milliseconds,  * which is the timeout for waiting for data  or, put differently,  * a maximum period inactivity between two consecutive data packets).  * <p>  * A timeout value of zero is interpreted as an infinite timeout.  * A negative value is interpreted as undefined (system default).  * </p>  * <p>  * Default: -1  * </p>  */ public void setSocketTimeout(int socketTimeout) {     this.socketTimeout = socketTimeout. }
false;public;0;4;;@Override public void doStart() throws Exception {     super.doStart(). }
false;public;0;11;;@Override public void doStop() throws Exception {     // shutdown connection manager     if (clientConnectionManager != null) {         log.info("Shutting down ClientConnectionManager: {}", clientConnectionManager).         clientConnectionManager.shutdown().         clientConnectionManager = null.     }     super.doStop(). }
false;public;0;3;;public ComponentVerifierExtension getVerifier() {     return (scope, parameters) -> getExtension(ComponentVerifierExtension.class).orElseThrow(UnsupportedOperationException::new).verify(scope, parameters). }
