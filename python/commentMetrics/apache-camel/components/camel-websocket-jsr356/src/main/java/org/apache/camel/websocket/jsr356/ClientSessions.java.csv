commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public void prepare() {     sessions.addAll(IntStream.range(0, expectedCount).mapToObj(idx -> doConnect()).collect(toList())). }
false;public;1;24;;public void execute(final Consumer<Session> apply) {     Session session = null.     try {         session = sessions.take().         apply.accept(session).     } catch (final RuntimeException re) {         log.error(re.getMessage(), re).         if (session.isOpen()) {             try {                 session.close(new CloseReason(CloseReason.CloseCodes.CLOSED_ABNORMALLY, re.getMessage())).             } catch (final IOException errorOnClose) {                 log.debug(errorOnClose.getMessage(), errorOnClose).             }         }         session = null.         throw re.     } catch (final InterruptedException ex) {         Thread.currentThread().interrupt().     } finally {         if (session != null) {             sessions.offer(session).         }     } }
false;public;2;4;;@Override public void onOpen(final Session session, final EndpointConfig endpointConfig) {     log.debug("Session opened #{}", session.getId()). }
false;public;2;5;;@Override public void onClose(final Session session, final CloseReason closeReason) {     sessions.remove(session).     log.debug("Session closed #{}", session.getId()). }
false;public;2;17;;@Override public void onError(final Session session, final Throwable throwable) {     if (session.isOpen()) {         try {             session.close(new CloseReason(CloseReason.CloseCodes.CLOSED_ABNORMALLY, "an exception occured")).         } catch (final IOException e) {             log.debug("Error closing session #{}", session.getId(), e).         }     }     sessions.remove(session).     log.debug("Error on session #{}", session.getId(), throwable).     if (!closed.get()) {         // try to repopulate it         sessions.offer(doConnect()).     } }
false;private;0;41;;private Session doConnect() {     try {         final Session session = container.connectToServer(new Endpoint() {              @Override             public void onOpen(final Session session, final EndpointConfig endpointConfig) {                 log.debug("Session opened #{}", session.getId()).             }              @Override             public void onClose(final Session session, final CloseReason closeReason) {                 sessions.remove(session).                 log.debug("Session closed #{}", session.getId()).             }              @Override             public void onError(final Session session, final Throwable throwable) {                 if (session.isOpen()) {                     try {                         session.close(new CloseReason(CloseReason.CloseCodes.CLOSED_ABNORMALLY, "an exception occured")).                     } catch (final IOException e) {                         log.debug("Error closing session #{}", session.getId(), e).                     }                 }                 sessions.remove(session).                 log.debug("Error on session #{}", session.getId(), throwable).                 if (!closed.get()) {                     // try to repopulate it                     sessions.offer(doConnect()).                 }             }         }, config, uri).         if (onMessage != null) {             session.addMessageHandler(InputStream.class, message -> onMessage.accept(session, message)).             session.addMessageHandler(String.class, message -> onMessage.accept(session, message)).         }         return session.     } catch (final DeploymentException | IOException e) {         throw new IllegalStateException(e).     } }
false;public;0;14;;@Override public void close() {     closed.set(true).     sessions.forEach(it -> {         if (it.isOpen()) {             try {                 it.close().             } catch (final IOException e) {                 log.debug(e.getMessage(), e).             }         }     }).     sessions.clear(). }
