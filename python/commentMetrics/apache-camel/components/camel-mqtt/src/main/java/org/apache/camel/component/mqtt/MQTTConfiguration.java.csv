commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getQualityOfService() {     return qualityOfService. }
true;public;1;4;/**  * Quality of service level to use for topics.  */ ;/**  * Quality of service level to use for topics.  */ public void setQualityOfService(String qualityOfService) {     this.qos = getQoS(qualityOfService).     this.qualityOfService = qualityOfService. }
false;public;0;3;;public QoS getQoS() {     return qos. }
false;public;0;4;;@Deprecated public String getSubscribeTopicName() {     return subscribeTopicName. }
true;public;1;4;/**  * The name of the Topic to subscribe to for messages.  */ ;/**  * The name of the Topic to subscribe to for messages.  */ @Deprecated public void setSubscribeTopicName(String subscribeTopicName) {     this.subscribeTopicName = subscribeTopicName. }
false;public;0;3;;public String getSubscribeTopicNames() {     return subscribeTopicNames. }
true;public;1;3;/**  * A comma-delimited list of Topics to subscribe to for messages.  * Note that each item of this list can contain MQTT wildcards (+ and/or #), in order to subscribe  * to topics matching a certain pattern within a hierarchy.  * For example, + is a wildcard for all topics at a level within the hierarchy,  * so if a broker has topics topics/one and topics/two, then topics/+ can be used to subscribe to both.  * A caveat to consider here is that if the broker adds topics/three, the route would also begin to receive messages from that topic.  */ ;/**  * A comma-delimited list of Topics to subscribe to for messages.  * Note that each item of this list can contain MQTT wildcards (+ and/or #), in order to subscribe  * to topics matching a certain pattern within a hierarchy.  * For example, + is a wildcard for all topics at a level within the hierarchy,  * so if a broker has topics topics/one and topics/two, then topics/+ can be used to subscribe to both.  * A caveat to consider here is that if the broker adds topics/three, the route would also begin to receive messages from that topic.  */ public void setSubscribeTopicNames(String subscribeTopicNames) {     this.subscribeTopicNames = subscribeTopicNames. }
false;public;0;3;;public String getPublishTopicName() {     return publishTopicName. }
true;public;1;3;/**  * The default Topic to publish messages on  */ ;/**  * The default Topic to publish messages on  */ public void setPublishTopicName(String publishTopicName) {     this.publishTopicName = publishTopicName. }
true;public;0;4;/**  * Please use MQTT_SUBSCRIBE_TOPIC and MQTT_PUBLISH_TOPIC to set or get the topic name  */ ;/**  * Please use MQTT_SUBSCRIBE_TOPIC and MQTT_PUBLISH_TOPIC to set or get the topic name  */ @Deprecated public String getMqttTopicPropertyName() {     return mqttTopicPropertyName. }
true;public;1;4;/**  * Please use MQTT_SUBSCRIBE_TOPIC and MQTT_PUBLISH_TOPIC to set or get the topic name  */ ;/**  * Please use MQTT_SUBSCRIBE_TOPIC and MQTT_PUBLISH_TOPIC to set or get the topic name  */ @Deprecated public void setMqttTopicPropertyName(String mqttTopicPropertyName) {     this.mqttTopicPropertyName = mqttTopicPropertyName. }
false;public;0;3;;public String getMqttRetainPropertyName() {     return mqttRetainPropertyName. }
true;public;1;3;/**  * The property name to look for on an Exchange for an individual published message.  * If this is set (expects a Boolean value) - then the retain property will be set on the message sent to the MQTT message broker.  */ ;/**  * The property name to look for on an Exchange for an individual published message.  * If this is set (expects a Boolean value) - then the retain property will be set on the message sent to the MQTT message broker.  */ public void setMqttRetainPropertyName(String mqttRetainPropertyName) {     this.mqttRetainPropertyName = mqttRetainPropertyName. }
false;public;0;3;;public String getMqttQosPropertyName() {     return mqttQosPropertyName. }
true;public;1;3;/**  * The property name to look for on an Exchange for an individual published message.  * If this is set (one of AtMostOnce, AtLeastOnce or ExactlyOnce ) - then that QoS will be set on the message sent to the MQTT message broker.  */ ;/**  * The property name to look for on an Exchange for an individual published message.  * If this is set (one of AtMostOnce, AtLeastOnce or ExactlyOnce ) - then that QoS will be set on the message sent to the MQTT message broker.  */ public void setMqttQosPropertyName(String mqttQosPropertyName) {     this.mqttQosPropertyName = mqttQosPropertyName. }
false;public;0;3;;public int getConnectWaitInSeconds() {     return connectWaitInSeconds. }
true;public;1;3;/**  * Delay in seconds the Component will wait for a connection to be established to the MQTT broker  */ ;/**  * Delay in seconds the Component will wait for a connection to be established to the MQTT broker  */ public void setConnectWaitInSeconds(int connectWaitInSeconds) {     this.connectWaitInSeconds = connectWaitInSeconds. }
false;public;0;3;;public int getDisconnectWaitInSeconds() {     return disconnectWaitInSeconds. }
true;public;1;3;/**  * The number of seconds the Component will wait for a valid disconnect on stop() from the MQTT broker  */ ;/**  * The number of seconds the Component will wait for a valid disconnect on stop() from the MQTT broker  */ public void setDisconnectWaitInSeconds(int disconnectWaitInSeconds) {     this.disconnectWaitInSeconds = disconnectWaitInSeconds. }
false;public;0;3;;public int getSendWaitInSeconds() {     return sendWaitInSeconds. }
true;public;1;3;/**  * The maximum time the Component will wait for a receipt from the MQTT broker to acknowledge a published message before throwing an exception  */ ;/**  * The maximum time the Component will wait for a receipt from the MQTT broker to acknowledge a published message before throwing an exception  */ public void setSendWaitInSeconds(int sendWaitInSeconds) {     this.sendWaitInSeconds = sendWaitInSeconds. }
false;public;0;3;;public boolean isByDefaultRetain() {     return byDefaultRetain. }
true;public;1;3;/**  * The default retain policy to be used on messages sent to the MQTT broker  */ ;/**  * The default retain policy to be used on messages sent to the MQTT broker  */ public void setByDefaultRetain(boolean byDefaultRetain) {     this.byDefaultRetain = byDefaultRetain. }
false;static;1;17;;static QoS getQoS(String qualityOfService) {     for (QoS q : QoS.values()) {         if (q.name().equalsIgnoreCase(qualityOfService)) {             return q.         }     }     if (qualityOfService.equalsIgnoreCase("ATMOSTONCE")) {         return QoS.AT_MOST_ONCE.     }     if (qualityOfService.equalsIgnoreCase("EXACTLYONCE")) {         return QoS.EXACTLY_ONCE.     }     if (qualityOfService.equalsIgnoreCase("ATLEASTONCE")) {         return QoS.AT_LEAST_ONCE.     }     throw new IllegalArgumentException("There is no QoS with name " + qualityOfService). }
true;public;1;4;/**  *  Use to set the client Id of the session.  *  This is what an MQTT server uses to identify a session where setCleanSession(false). is being used.  *  The id must be 23 characters or less. Defaults to auto generated id (based on your socket address, port and timestamp).  */ ;/**  *  Use to set the client Id of the session.  *  This is what an MQTT server uses to identify a session where setCleanSession(false). is being used.  *  The id must be 23 characters or less. Defaults to auto generated id (based on your socket address, port and timestamp).  */ @Override public void setClientId(String clientId) {     super.setClientId(clientId). }
true;public;1;4;/**  * Set to false if you want the MQTT server to persist topic subscriptions and ack positions across client sessions. Defaults to true.  */ ;/**  * Set to false if you want the MQTT server to persist topic subscriptions and ack positions across client sessions. Defaults to true.  */ @Override public void setCleanSession(boolean cleanSession) {     super.setCleanSession(cleanSession). }
true;public;1;4;/**  * Configures the Keep Alive timer in seconds. Defines the maximum time interval between messages received from a client.  * It enables the server to detect that the network connection to a client has dropped, without having to wait for the long TCP/IP timeout.  */ ;/**  * Configures the Keep Alive timer in seconds. Defines the maximum time interval between messages received from a client.  * It enables the server to detect that the network connection to a client has dropped, without having to wait for the long TCP/IP timeout.  */ @Override public void setKeepAlive(short keepAlive) {     super.setKeepAlive(keepAlive). }
true;public;1;4;/**  * Password to be used for authentication against the MQTT broker  */ ;/**  * Password to be used for authentication against the MQTT broker  */ @Override public void setPassword(String password) {     super.setPassword(password). }
true;public;1;4;/**  * Username to be used for authentication against the MQTT broker  */ ;/**  * Username to be used for authentication against the MQTT broker  */ @Override public void setUserName(String userName) {     super.setUserName(userName). }
true;public;1;4;/**  * The Will message to send. Defaults to a zero length message.  */ ;/**  * The Will message to send. Defaults to a zero length message.  */ @Override public void setWillMessage(String willMessage) {     super.setWillMessage(willMessage). }
true;public;1;4;/**  * Sets the quality of service to use for the Will message. Defaults to AT_MOST_ONCE.  */ ;/**  * Sets the quality of service to use for the Will message. Defaults to AT_MOST_ONCE.  */ @Override public void setWillQos(QoS willQos) {     super.setWillQos(willQos). }
true;public;1;4;/**  * Set to 3.1.1 to use MQTT version 3.1.1. Otherwise defaults to the 3.1 protocol version.  */ ;/**  * Set to 3.1.1 to use MQTT version 3.1.1. Otherwise defaults to the 3.1 protocol version.  */ @Override public void setVersion(String version) {     super.setVersion(version). }
false;public;0;4;;@Override public String getVersion() {     return super.getVersion(). }
true;public;1;4;/**  * Set to true if you want the Will to be published with the retain option.  */ ;/**  * Set to true if you want the Will to be published with the retain option.  */ @Override public void setWillRetain(boolean willRetain) {     super.setWillRetain(willRetain). }
true;public;1;4;/**  * If set the server will publish the client's Will message to the specified topics if the client has an unexpected disconnection.  */ ;/**  * If set the server will publish the client's Will message to the specified topics if the client has an unexpected disconnection.  */ @Override public void setWillTopic(String willTopic) {     super.setWillTopic(willTopic). }
false;public;0;4;;@Override public Executor getBlockingExecutor() {     return super.getBlockingExecutor(). }
true;public;1;4;/**  * SSL connections perform blocking operations against internal thread pool unless you call the setBlockingExecutor method to configure that executor they will use instead.  */ ;/**  * SSL connections perform blocking operations against internal thread pool unless you call the setBlockingExecutor method to configure that executor they will use instead.  */ @Override public void setBlockingExecutor(Executor blockingExecutor) {     super.setBlockingExecutor(blockingExecutor). }
false;public;0;4;;@Override public DispatchQueue getDispatchQueue() {     return super.getDispatchQueue(). }
true;public;1;4;/**  * A HawtDispatch dispatch queue is used to synchronize access to the connection.  * If an explicit queue is not configured via the setDispatchQueue method, then a new queue will be created for the connection.  * Setting an explicit queue might be handy if you want multiple connection to share the same queue for synchronization.  */ ;/**  * A HawtDispatch dispatch queue is used to synchronize access to the connection.  * If an explicit queue is not configured via the setDispatchQueue method, then a new queue will be created for the connection.  * Setting an explicit queue might be handy if you want multiple connection to share the same queue for synchronization.  */ @Override public void setDispatchQueue(DispatchQueue dispatchQueue) {     super.setDispatchQueue(dispatchQueue). }
false;public;0;4;;@Override public URI getLocalAddress() {     return super.getLocalAddress(). }
true;public;1;4;/**  * The local InetAddress and port to use  */ ;/**  * The local InetAddress and port to use  */ @Override public void setLocalAddress(String localAddress) throws URISyntaxException {     super.setLocalAddress(localAddress). }
false;public;1;4;;@Override public void setLocalAddress(URI localAddress) {     super.setLocalAddress(localAddress). }
false;public;0;4;;@Override public int getMaxReadRate() {     return super.getMaxReadRate(). }
true;public;1;4;/**  * Sets the maximum bytes per second that this transport will receive data at.  * This setting throttles reads so that the rate is not exceeded. Defaults to 0 which disables throttling.  */ ;/**  * Sets the maximum bytes per second that this transport will receive data at.  * This setting throttles reads so that the rate is not exceeded. Defaults to 0 which disables throttling.  */ @Override public void setMaxReadRate(int maxReadRate) {     super.setMaxReadRate(maxReadRate). }
false;public;0;4;;@Override public int getMaxWriteRate() {     return super.getMaxWriteRate(). }
true;public;1;4;/**  * Sets the maximum bytes per second that this transport will send data at.  * This setting throttles writes so that the rate is not exceeded. Defaults to 0 which disables throttling.  */ ;/**  * Sets the maximum bytes per second that this transport will send data at.  * This setting throttles writes so that the rate is not exceeded. Defaults to 0 which disables throttling.  */ @Override public void setMaxWriteRate(int maxWriteRate) {     super.setMaxWriteRate(maxWriteRate). }
false;public;0;4;;@Override public int getReceiveBufferSize() {     return super.getReceiveBufferSize(). }
true;public;1;4;/**  * Sets the size of the internal socket receive buffer. Defaults to 65536 (64k)  */ ;/**  * Sets the size of the internal socket receive buffer. Defaults to 65536 (64k)  */ @Override public void setReceiveBufferSize(int receiveBufferSize) {     super.setReceiveBufferSize(receiveBufferSize). }
false;public;0;4;;@Override public URI getHost() {     return super.getHost(). }
true;public;1;4;/**  * The URI of the MQTT broker to connect too - this component also supports SSL - e.g. ssl://127.0.0.1:8883  */ ;/**  * The URI of the MQTT broker to connect too - this component also supports SSL - e.g. ssl://127.0.0.1:8883  */ @Override public void setHost(String host) throws URISyntaxException {     super.setHost(host). }
true;public;1;4;/**  * The URI of the MQTT broker to connect too - this component also supports SSL - e.g. ssl://127.0.0.1:8883  */ ;/**  * The URI of the MQTT broker to connect too - this component also supports SSL - e.g. ssl://127.0.0.1:8883  */ @Override public void setHost(URI host) {     super.setHost(host). }
false;public;0;4;;@Override public int getSendBufferSize() {     return super.getSendBufferSize(). }
true;public;1;4;/**  *  Sets the size of the internal socket send buffer. Defaults to 65536 (64k)  */ ;/**  *  Sets the size of the internal socket send buffer. Defaults to 65536 (64k)  */ @Override public void setSendBufferSize(int sendBufferSize) {     super.setSendBufferSize(sendBufferSize). }
false;public;0;4;;@Override public SSLContext getSslContext() {     return super.getSslContext(). }
true;public;1;4;/**  * To configure security using SSLContext configuration  */ ;/**  * To configure security using SSLContext configuration  */ @Override public void setSslContext(SSLContext sslContext) {     super.setSslContext(sslContext). }
false;public;0;4;;@Override public int getTrafficClass() {     return super.getTrafficClass(). }
true;public;1;4;/**  * Sets traffic class or type-of-service octet in the IP header for packets sent from the transport.  * Defaults to 8 which means the traffic should be optimized for throughput.  */ ;/**  * Sets traffic class or type-of-service octet in the IP header for packets sent from the transport.  * Defaults to 8 which means the traffic should be optimized for throughput.  */ @Override public void setTrafficClass(int trafficClass) {     super.setTrafficClass(trafficClass). }
false;public;0;4;;@Override public long getConnectAttemptsMax() {     return super.getConnectAttemptsMax(). }
true;public;1;4;/**  * The maximum number of reconnect attempts before an error is reported back to the client on the first attempt  * by the client to connect to a server. Set to -1 to use unlimited attempts. Defaults to -1.  */ ;/**  * The maximum number of reconnect attempts before an error is reported back to the client on the first attempt  * by the client to connect to a server. Set to -1 to use unlimited attempts. Defaults to -1.  */ @Override public void setConnectAttemptsMax(long connectAttemptsMax) {     super.setConnectAttemptsMax(connectAttemptsMax). }
false;public;0;4;;@Override public long getReconnectAttemptsMax() {     return super.getReconnectAttemptsMax(). }
true;public;1;4;/**  * The maximum number of reconnect attempts before an error is reported back to the client after a server  * connection had previously been established. Set to -1 to use unlimited attempts. Defaults to -1.  */ ;/**  * The maximum number of reconnect attempts before an error is reported back to the client after a server  * connection had previously been established. Set to -1 to use unlimited attempts. Defaults to -1.  */ @Override public void setReconnectAttemptsMax(long reconnectAttemptsMax) {     super.setReconnectAttemptsMax(reconnectAttemptsMax). }
false;public;0;4;;@Override public double getReconnectBackOffMultiplier() {     return super.getReconnectBackOffMultiplier(). }
true;public;1;4;/**  * The Exponential backoff be used between reconnect attempts. Set to 1 to disable exponential backoff. Defaults to 2.  */ ;/**  * The Exponential backoff be used between reconnect attempts. Set to 1 to disable exponential backoff. Defaults to 2.  */ @Override public void setReconnectBackOffMultiplier(double reconnectBackOffMultiplier) {     super.setReconnectBackOffMultiplier(reconnectBackOffMultiplier). }
false;public;0;4;;@Override public long getReconnectDelay() {     return super.getReconnectDelay(). }
true;public;1;4;/**  * How long to wait in ms before the first reconnect attempt. Defaults to 10.  */ ;/**  * How long to wait in ms before the first reconnect attempt. Defaults to 10.  */ @Override public void setReconnectDelay(long reconnectDelay) {     super.setReconnectDelay(reconnectDelay). }
false;public;0;4;;@Override public long getReconnectDelayMax() {     return super.getReconnectDelayMax(). }
true;public;1;4;/**  * The maximum amount of time in ms to wait between reconnect attempts. Defaults to 30,000.  */ ;/**  * The maximum amount of time in ms to wait between reconnect attempts. Defaults to 30,000.  */ @Override public void setReconnectDelayMax(long reconnectDelayMax) {     super.setReconnectDelayMax(reconnectDelayMax). }
false;public;0;3;;public boolean isLazySessionCreation() {     return lazySessionCreation. }
true;public;1;3;/**  * Sessions can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.  */ ;/**  * Sessions can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.  */ public void setLazySessionCreation(boolean lazySessionCreation) {     this.lazySessionCreation = lazySessionCreation. }
