commented;modifiers;parameterAmount;loc;comment;code
true;protected,static,final;1;44;/**  * Replaces unprintable characters by their escaped (or unicode escaped)  * equivalents in the given string  */ ;/**  * Replaces unprintable characters by their escaped (or unicode escaped)  * equivalents in the given string  */ protected static final String addEscapes(String str) {     StringBuffer retval = new StringBuffer().     char ch.     for (int i = 0. i < str.length(). i++) {         switch(str.charAt(i)) {             case 0:                 continue.             case '\b':                 retval.append("\\b").                 continue.             case '\t':                 retval.append("\\t").                 continue.             case '\n':                 retval.append("\\n").                 continue.             case '\f':                 retval.append("\\f").                 continue.             case '\r':                 retval.append("\\r").                 continue.             case '\"':                 retval.append("\\\"").                 continue.             case '\'':                 retval.append("\\\'").                 continue.             case '\\':                 retval.append("\\\\").                 continue.             default:                 if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {                     String s = "0000" + Integer.toString(ch, 16).                     retval.append("\\u" + s.substring(s.length() - 4, s.length())).                 } else {                     retval.append(ch).                 }                 continue.         }     }     return retval.toString(). }
true;protected,static;6;7;/**  * Returns a detailed message for the Error when it is thrown by the  * token manager to indicate a lexical error.  * Parameters :  *    EOFSeen     : indicates if EOF caused the lexical error  *    curLexState : lexical state in which this error occurred  *    errorLine   : line number when the error occurred  *    errorColumn : column number when the error occurred  *    errorAfter  : prefix that was seen before this error occurred  *    curchar     : the offending character  * Note: You can customize the lexical error message by modifying this method.  */ ;/**  * Returns a detailed message for the Error when it is thrown by the  * token manager to indicate a lexical error.  * Parameters :  *    EOFSeen     : indicates if EOF caused the lexical error  *    curLexState : lexical state in which this error occurred  *    errorLine   : line number when the error occurred  *    errorColumn : column number when the error occurred  *    errorAfter  : prefix that was seen before this error occurred  *    curchar     : the offending character  * Note: You can customize the lexical error message by modifying this method.  */ protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {     return ("Lexical error at line " + errorLine + ", column " + errorColumn + ".  Encountered: " + (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int) curChar + "), ") + "after : \"" + addEscapes(errorAfter) + "\""). }
true;public;0;3;/**  * You can also modify the body of this method to customize your error messages.  * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not  * of end-users concern, so you can return something like :  *  *     "Internal Error : Please file a bug report .... "  *  * from this method for such cases in the release version of your parser.  */ ;/**  * You can also modify the body of this method to customize your error messages.  * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not  * of end-users concern, so you can return something like :  *  *     "Internal Error : Please file a bug report .... "  *  * from this method for such cases in the release version of your parser.  */ public String getMessage() {     return super.getMessage(). }
