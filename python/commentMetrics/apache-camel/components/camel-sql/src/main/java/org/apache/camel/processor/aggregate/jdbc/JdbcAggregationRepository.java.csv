commented;modifiers;parameterAmount;loc;comment;code
true;public,final;1;3;/**  * @param repositoryName the repositoryName to set  */ ;/**  * @param repositoryName the repositoryName to set  */ public final void setRepositoryName(String repositoryName) {     this.repositoryName = repositoryName. }
false;public,final;1;10;;public final void setTransactionManager(PlatformTransactionManager transactionManager) {     this.transactionManager = transactionManager.     transactionTemplate = new TransactionTemplate(transactionManager).     transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED).     transactionTemplateReadOnly = new TransactionTemplate(transactionManager).     transactionTemplateReadOnly.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED).     transactionTemplateReadOnly.setReadOnly(true). }
true;public,final;1;5;/**  * @param dataSource The DataSource to use for accessing the database  */ ;/**  * @param dataSource The DataSource to use for accessing the database  */ public final void setDataSource(DataSource dataSource) {     this.dataSource = dataSource.     jdbcTemplate = new JdbcTemplate(dataSource). }
false;public;4;14;;@Override public Exchange add(final CamelContext camelContext, final String correlationId, final Exchange oldExchange, final Exchange newExchange) throws OptimisticLockingException {     try {         return add(camelContext, correlationId, newExchange).     } catch (Exception e) {         if (jdbcOptimisticLockingExceptionMapper != null && jdbcOptimisticLockingExceptionMapper.isOptimisticLocking(e)) {             throw new OptimisticLockingException().         } else {             throw RuntimeCamelException.wrapRuntimeCamelException(e).         }     } }
false;public;1;27;;public Exchange doInTransaction(TransactionStatus status) {     Exchange result = null.     final String key = correlationId.     try {         LOG.debug("Adding exchange with key: [{}]", key).         boolean present = jdbcTemplate.queryForObject("SELECT COUNT(*) FROM " + getRepositoryName() + " WHERE " + ID + " = ?", Integer.class, key) != 0.         // Recover existing exchange with that ID         if (isReturnOldExchange() && present) {             result = get(key, getRepositoryName(), camelContext).         }         if (present) {             update(camelContext, correlationId, exchange, getRepositoryName()).         } else {             insert(camelContext, correlationId, exchange, getRepositoryName()).         }     } catch (Exception e) {         throw new RuntimeException("Error adding to repository " + repositoryName + " with key " + key, e).     }     return result. }
false;public;3;33;;@Override public Exchange add(final CamelContext camelContext, final String correlationId, final Exchange exchange) {     return transactionTemplate.execute(new TransactionCallback<Exchange>() {          public Exchange doInTransaction(TransactionStatus status) {             Exchange result = null.             final String key = correlationId.             try {                 LOG.debug("Adding exchange with key: [{}]", key).                 boolean present = jdbcTemplate.queryForObject("SELECT COUNT(*) FROM " + getRepositoryName() + " WHERE " + ID + " = ?", Integer.class, key) != 0.                 // Recover existing exchange with that ID                 if (isReturnOldExchange() && present) {                     result = get(key, getRepositoryName(), camelContext).                 }                 if (present) {                     update(camelContext, correlationId, exchange, getRepositoryName()).                 } else {                     insert(camelContext, correlationId, exchange, getRepositoryName()).                 }             } catch (Exception e) {                 throw new RuntimeException("Error adding to repository " + repositoryName + " with key " + key, e).             }             return result.         }     }). }
true;protected;4;20;/**  * Updates the current exchange details in the given repository table  *  * @param camelContext   the current CamelContext  * @param key            the correlation key  * @param exchange       the aggregated exchange  * @param repositoryName The name of the table  * @throws Exception  */ ;/**  * Updates the current exchange details in the given repository table  *  * @param camelContext   the current CamelContext  * @param key            the correlation key  * @param exchange       the aggregated exchange  * @param repositoryName The name of the table  * @throws Exception  */ protected void update(final CamelContext camelContext, final String key, final Exchange exchange, String repositoryName) throws Exception {     StringBuilder queryBuilder = new StringBuilder().append("UPDATE ").append(repositoryName).append(" SET ").append(EXCHANGE).append(" = ?").     if (storeBodyAsText) {         queryBuilder.append(", ").append(BODY).append(" = ?").     }     if (hasHeadersToStoreAsText()) {         for (String headerName : headersToStoreAsText) {             queryBuilder.append(", ").append(headerName).append(" = ?").         }     }     queryBuilder.append(" WHERE ").append(ID).append(" = ?").     String sql = queryBuilder.toString().     insertAndUpdateHelper(camelContext, key, exchange, sql, false). }
true;protected;4;32;/**  * Inserts a new record into the given repository table.  * note : the exchange properties are NOT persisted.  *  * @param camelContext   the current CamelContext  * @param correlationId  the correlation key  * @param exchange       the aggregated exchange to insert. The headers will be persisted but not the properties.  * @param repositoryName The name of the table  * @throws Exception  */ ;/**  * Inserts a new record into the given repository table.  * note : the exchange properties are NOT persisted.  *  * @param camelContext   the current CamelContext  * @param correlationId  the correlation key  * @param exchange       the aggregated exchange to insert. The headers will be persisted but not the properties.  * @param repositoryName The name of the table  * @throws Exception  */ protected void insert(final CamelContext camelContext, final String correlationId, final Exchange exchange, String repositoryName) throws Exception {     // The default totalParameterIndex is 2 for ID and Exchange. Depending on logic this will be increased     int totalParameterIndex = 2.     StringBuilder queryBuilder = new StringBuilder().append("INSERT INTO ").append(repositoryName).append('(').append(EXCHANGE).append(", ").append(ID).     if (storeBodyAsText) {         queryBuilder.append(", ").append(BODY).         totalParameterIndex++.     }     if (hasHeadersToStoreAsText()) {         for (String headerName : headersToStoreAsText) {             queryBuilder.append(", ").append(headerName).             totalParameterIndex++.         }     }     queryBuilder.append(") VALUES (").     for (int i = 0. i < totalParameterIndex - 1. i++) {         queryBuilder.append("?, ").     }     queryBuilder.append("?)").     String sql = queryBuilder.toString().     insertAndUpdateHelper(camelContext, correlationId, exchange, sql, true). }
false;protected;2;20;;@Override protected void setValues(PreparedStatement ps, LobCreator lobCreator) throws SQLException {     int totalParameterIndex = 0.     lobCreator.setBlobAsBytes(ps, ++totalParameterIndex, data).     if (idComesFirst) {         ps.setString(++totalParameterIndex, key).     }     if (storeBodyAsText) {         ps.setString(++totalParameterIndex, exchange.getIn().getBody(String.class)).     }     if (hasHeadersToStoreAsText()) {         for (String headerName : headersToStoreAsText) {             String headerValue = exchange.getIn().getHeader(headerName, String.class).             ps.setString(++totalParameterIndex, headerValue).         }     }     if (!idComesFirst) {         ps.setString(++totalParameterIndex, key).     } }
false;protected;5;26;;protected void insertAndUpdateHelper(final CamelContext camelContext, final String key, final Exchange exchange, String sql, final boolean idComesFirst) throws Exception {     final byte[] data = codec.marshallExchange(camelContext, exchange, allowSerializedHeaders).     jdbcTemplate.execute(sql, new AbstractLobCreatingPreparedStatementCallback(getLobHandler()) {          @Override         protected void setValues(PreparedStatement ps, LobCreator lobCreator) throws SQLException {             int totalParameterIndex = 0.             lobCreator.setBlobAsBytes(ps, ++totalParameterIndex, data).             if (idComesFirst) {                 ps.setString(++totalParameterIndex, key).             }             if (storeBodyAsText) {                 ps.setString(++totalParameterIndex, exchange.getIn().getBody(String.class)).             }             if (hasHeadersToStoreAsText()) {                 for (String headerName : headersToStoreAsText) {                     String headerValue = exchange.getIn().getHeader(headerName, String.class).                     ps.setString(++totalParameterIndex, headerValue).                 }             }             if (!idComesFirst) {                 ps.setString(++totalParameterIndex, key).             }         }     }). }
false;public;2;9;;@Override public Exchange get(final CamelContext camelContext, final String correlationId) {     final String key = correlationId.     Exchange result = get(key, getRepositoryName(), camelContext).     LOG.debug("Getting key  [{}] -> {}", key, result).     return result. }
false;public;1;16;;public Exchange doInTransaction(TransactionStatus status) {     try {         final byte[] data = jdbcTemplate.queryForObject("SELECT " + EXCHANGE + " FROM " + repositoryName + " WHERE " + ID + " = ?", new Object[] { key }, byte[].class).         return codec.unmarshallExchange(camelContext, data).     } catch (EmptyResultDataAccessException ex) {         return null.     } catch (IOException ex) {         // Rollback the transaction         throw new RuntimeException("Error getting key " + key + " from repository " + repositoryName, ex).     } catch (ClassNotFoundException ex) {         // Rollback the transaction         throw new RuntimeException(ex).     } }
false;private;3;20;;private Exchange get(final String key, final String repositoryName, final CamelContext camelContext) {     return transactionTemplateReadOnly.execute(new TransactionCallback<Exchange>() {          public Exchange doInTransaction(TransactionStatus status) {             try {                 final byte[] data = jdbcTemplate.queryForObject("SELECT " + EXCHANGE + " FROM " + repositoryName + " WHERE " + ID + " = ?", new Object[] { key }, byte[].class).                 return codec.unmarshallExchange(camelContext, data).             } catch (EmptyResultDataAccessException ex) {                 return null.             } catch (IOException ex) {                 // Rollback the transaction                 throw new RuntimeException("Error getting key " + key + " from repository " + repositoryName, ex).             } catch (ClassNotFoundException ex) {                 // Rollback the transaction                 throw new RuntimeException(ex).             }         }     }). }
false;protected;1;14;;protected void doInTransactionWithoutResult(TransactionStatus status) {     final String key = correlationId.     final String confirmKey = exchange.getExchangeId().     try {         LOG.debug("Removing key [{}]", key).         jdbcTemplate.update("DELETE FROM " + getRepositoryName() + " WHERE " + ID + " = ?", key).         insert(camelContext, confirmKey, exchange, getRepositoryNameCompleted()).     } catch (Exception e) {         throw new RuntimeException("Error removing key " + key + " from repository " + repositoryName, e).     } }
false;public;3;19;;@Override public void remove(final CamelContext camelContext, final String correlationId, final Exchange exchange) {     transactionTemplate.execute(new TransactionCallbackWithoutResult() {          protected void doInTransactionWithoutResult(TransactionStatus status) {             final String key = correlationId.             final String confirmKey = exchange.getExchangeId().             try {                 LOG.debug("Removing key [{}]", key).                 jdbcTemplate.update("DELETE FROM " + getRepositoryName() + " WHERE " + ID + " = ?", key).                 insert(camelContext, confirmKey, exchange, getRepositoryNameCompleted()).             } catch (Exception e) {                 throw new RuntimeException("Error removing key " + key + " from repository " + repositoryName, e).             }         }     }). }
false;protected;1;8;;protected void doInTransactionWithoutResult(TransactionStatus status) {     LOG.debug("Confirming exchangeId [{}]", exchangeId).     final String confirmKey = exchangeId.     jdbcTemplate.update("DELETE FROM " + getRepositoryNameCompleted() + " WHERE " + ID + " = ?", new Object[] { confirmKey }). }
false;public;2;13;;@Override public void confirm(final CamelContext camelContext, final String exchangeId) {     transactionTemplate.execute(new TransactionCallbackWithoutResult() {          protected void doInTransactionWithoutResult(TransactionStatus status) {             LOG.debug("Confirming exchangeId [{}]", exchangeId).             final String confirmKey = exchangeId.             jdbcTemplate.update("DELETE FROM " + getRepositoryNameCompleted() + " WHERE " + ID + " = ?", new Object[] { confirmKey }).         }     }). }
false;public;0;4;;@Override public Set<String> getKeys() {     return getKeys(getRepositoryName()). }
false;public;1;4;;@Override public Set<String> scan(CamelContext camelContext) {     return getKeys(getRepositoryNameCompleted()). }
false;public;2;5;;public String mapRow(ResultSet rs, int rowNum) throws SQLException {     String id = rs.getString(ID).     LOG.trace("getKey [{}]", id).     return id. }
false;public;1;11;;public LinkedHashSet<String> doInTransaction(TransactionStatus status) {     List<String> keys = jdbcTemplate.query("SELECT " + ID + " FROM " + repositoryName, new RowMapper<String>() {          public String mapRow(ResultSet rs, int rowNum) throws SQLException {             String id = rs.getString(ID).             LOG.trace("getKey [{}]", id).             return id.         }     }).     return new LinkedHashSet<>(keys). }
true;protected;1;15;/**  * Returns the keys in the given repository  *  * @param repositoryName The name of the table  * @return Set of keys in the given repository name  */ ;/**  * Returns the keys in the given repository  *  * @param repositoryName The name of the table  * @return Set of keys in the given repository name  */ protected Set<String> getKeys(final String repositoryName) {     return transactionTemplateReadOnly.execute(new TransactionCallback<LinkedHashSet<String>>() {          public LinkedHashSet<String> doInTransaction(TransactionStatus status) {             List<String> keys = jdbcTemplate.query("SELECT " + ID + " FROM " + repositoryName, new RowMapper<String>() {                  public String mapRow(ResultSet rs, int rowNum) throws SQLException {                     String id = rs.getString(ID).                     LOG.trace("getKey [{}]", id).                     return id.                 }             }).             return new LinkedHashSet<>(keys).         }     }). }
false;public;2;9;;@Override public Exchange recover(CamelContext camelContext, String exchangeId) {     final String key = exchangeId.     Exchange answer = get(key, getRepositoryNameCompleted(), camelContext).     LOG.debug("Recovering exchangeId [{}] -> {}", key, answer).     return answer. }
true;public;2;3;/**  *  If recovery is enabled then a background task is run every x'th time to scan for failed exchanges to recover  *  and resubmit. By default this interval is 5000 millis.  * @param interval  the interval  * @param timeUnit  the time unit  */ ;/**  *  If recovery is enabled then a background task is run every x'th time to scan for failed exchanges to recover  *  and resubmit. By default this interval is 5000 millis.  * @param interval  the interval  * @param timeUnit  the time unit  */ public void setRecoveryInterval(long interval, TimeUnit timeUnit) {     this.recoveryInterval = timeUnit.toMillis(interval). }
false;public;1;3;;public void setRecoveryInterval(long interval) {     this.recoveryInterval = interval. }
false;public;0;3;;public long getRecoveryIntervalInMillis() {     return recoveryInterval. }
false;public;0;3;;public boolean isUseRecovery() {     return useRecovery. }
true;public;1;3;/**  * @param useRecovery Whether or not recovery is enabled. This option is by default true. When enabled the Camel  *                    Aggregator automatic recover failed aggregated exchange and have them resubmittedd  */ ;/**  * @param useRecovery Whether or not recovery is enabled. This option is by default true. When enabled the Camel  *                    Aggregator automatic recover failed aggregated exchange and have them resubmittedd  */ public void setUseRecovery(boolean useRecovery) {     this.useRecovery = useRecovery. }
false;public;0;3;;public int getMaximumRedeliveries() {     return maximumRedeliveries. }
false;public;1;3;;public void setMaximumRedeliveries(int maximumRedeliveries) {     this.maximumRedeliveries = maximumRedeliveries. }
false;public;0;3;;public String getDeadLetterUri() {     return deadLetterUri. }
true;public;1;3;/**  * @param deadLetterUri  An endpoint uri for a Dead Letter Channel where exhausted recovered Exchanges will be  *                       moved. If this option is used then the maximumRedeliveries option must also be provided.  *                       Important note : if the deadletter route throws an exception, it will be send again to DLQ  *                       until it succeed !  */ ;/**  * @param deadLetterUri  An endpoint uri for a Dead Letter Channel where exhausted recovered Exchanges will be  *                       moved. If this option is used then the maximumRedeliveries option must also be provided.  *                       Important note : if the deadletter route throws an exception, it will be send again to DLQ  *                       until it succeed !  */ public void setDeadLetterUri(String deadLetterUri) {     this.deadLetterUri = deadLetterUri. }
false;public;0;3;;public boolean isReturnOldExchange() {     return returnOldExchange. }
true;public;1;3;/**  * @param returnOldExchange Whether the get operation should return the old existing Exchange if any existed.  *                          By default this option is false to optimize as we do not need the old exchange when  *                          aggregating  */ ;/**  * @param returnOldExchange Whether the get operation should return the old existing Exchange if any existed.  *                          By default this option is false to optimize as we do not need the old exchange when  *                          aggregating  */ public void setReturnOldExchange(boolean returnOldExchange) {     this.returnOldExchange = returnOldExchange. }
false;public;1;3;;public void setJdbcCamelCodec(JdbcCamelCodec codec) {     this.codec = codec. }
false;public;0;3;;public boolean hasHeadersToStoreAsText() {     return this.headersToStoreAsText != null && !this.headersToStoreAsText.isEmpty(). }
true;public;1;3;/**  * Allows to store headers as String which is human readable. By default this option is disabled,  * storing the headers in binary format.  * @param headersToStoreAsText the list of headers to store as String  */ ;/**  * Allows to store headers as String which is human readable. By default this option is disabled,  * storing the headers in binary format.  * @param headersToStoreAsText the list of headers to store as String  */ public void setHeadersToStoreAsText(List<String> headersToStoreAsText) {     this.headersToStoreAsText = headersToStoreAsText. }
true;public;1;3;/**  * @param storeBodyAsText Whether to store the message body as String which is human readable.  *                        By default this option is false storing the body in binary format.  */ ;/**  * @param storeBodyAsText Whether to store the message body as String which is human readable.  *                        By default this option is false storing the body in binary format.  */ public void setStoreBodyAsText(boolean storeBodyAsText) {     this.storeBodyAsText = storeBodyAsText. }
false;public;0;3;;public boolean isAllowSerializedHeaders() {     return allowSerializedHeaders. }
false;public;1;3;;public void setAllowSerializedHeaders(boolean allowSerializedHeaders) {     this.allowSerializedHeaders = allowSerializedHeaders. }
true;public;0;3;/**  * @return the lobHandler  */ ;/**  * @return the lobHandler  */ public LobHandler getLobHandler() {     return lobHandler. }
true;public;1;3;/**  * @param lobHandler the lobHandler to set  */ ;/**  * @param lobHandler the lobHandler to set  */ public void setLobHandler(LobHandler lobHandler) {     this.lobHandler = lobHandler. }
false;public;0;3;;public JdbcOptimisticLockingExceptionMapper getJdbcOptimisticLockingExceptionMapper() {     return jdbcOptimisticLockingExceptionMapper. }
false;public;1;3;;public void setJdbcOptimisticLockingExceptionMapper(JdbcOptimisticLockingExceptionMapper jdbcOptimisticLockingExceptionMapper) {     this.jdbcOptimisticLockingExceptionMapper = jdbcOptimisticLockingExceptionMapper. }
false;public;0;3;;public String getRepositoryName() {     return repositoryName. }
false;public;0;3;;public String getRepositoryNameCompleted() {     return getRepositoryName() + "_completed". }
false;protected;0;21;;@Override protected void doStart() throws Exception {     ObjectHelper.notNull(repositoryName, "RepositoryName").     ObjectHelper.notNull(transactionManager, "TransactionManager").     ObjectHelper.notNull(dataSource, "DataSource").     // log number of existing exchanges     int current = getKeys().size().     int completed = scan(null).size().     if (current > 0) {         LOG.info("On startup there are " + current + " aggregate exchanges (not completed) in repository: " + getRepositoryName()).     } else {         LOG.info("On startup there are no existing aggregate exchanges (not completed) in repository: {}", getRepositoryName()).     }     if (completed > 0) {         LOG.warn("On startup there are " + completed + " completed exchanges to be recovered in repository: " + getRepositoryNameCompleted()).     } else {         LOG.info("On startup there are no completed exchanges to be recovered in repository: {}", getRepositoryNameCompleted()).     } }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
