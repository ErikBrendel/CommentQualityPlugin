commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isSingleton() {     return true. }
false;public;0;3;;public JdbcTemplate getJdbcTemplate() {     return jdbcTemplate. }
false;public;1;3;;public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {     this.jdbcTemplate = jdbcTemplate. }
false;public;0;3;;public boolean isTransacted() {     return transacted. }
true;public;1;3;/**  * Enables or disables transaction. If enabled then if processing an exchange failed then the consumer  *     + break out processing any further exchanges to cause a rollback eager  */ ;/**  * Enables or disables transaction. If enabled then if processing an exchange failed then the consumer  *     + break out processing any further exchanges to cause a rollback eager  */ public void setTransacted(boolean transacted) {     this.transacted = transacted. }
false;public;0;3;;public boolean isBatch() {     return batch. }
true;public;1;3;/**  * Enables or disables batch mode  */ ;/**  * Enables or disables batch mode  */ public void setBatch(boolean batch) {     this.batch = batch. }
false;public;0;3;;public int getMaxMessagesPerPoll() {     return maxMessagesPerPoll. }
true;public;1;3;/**  * Sets the maximum number of messages to poll  */ ;/**  * Sets the maximum number of messages to poll  */ public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {     this.maxMessagesPerPoll = maxMessagesPerPoll. }
false;public;0;3;;public SqlProcessingStrategy getProcessingStrategy() {     return processingStrategy. }
true;public;1;3;/**  * Allows to plugin to use a custom org.apache.camel.component.sql.SqlProcessingStrategy to execute queries when the consumer has processed the rows/batch.  */ ;/**  * Allows to plugin to use a custom org.apache.camel.component.sql.SqlProcessingStrategy to execute queries when the consumer has processed the rows/batch.  */ public void setProcessingStrategy(SqlProcessingStrategy processingStrategy) {     this.processingStrategy = processingStrategy. }
false;public;0;3;;public SqlPrepareStatementStrategy getPrepareStatementStrategy() {     return prepareStatementStrategy. }
true;public;1;3;/**  * Allows to plugin to use a custom org.apache.camel.component.sql.SqlPrepareStatementStrategy to control preparation of the query and prepared statement.  */ ;/**  * Allows to plugin to use a custom org.apache.camel.component.sql.SqlPrepareStatementStrategy to control preparation of the query and prepared statement.  */ public void setPrepareStatementStrategy(SqlPrepareStatementStrategy prepareStatementStrategy) {     this.prepareStatementStrategy = prepareStatementStrategy. }
false;public;0;3;;public String getOnConsume() {     return onConsume. }
true;public;1;3;/**  * After processing each row then this query can be executed, if the Exchange was processed successfully, for example to mark the row as processed. The query can have parameter.  */ ;/**  * After processing each row then this query can be executed, if the Exchange was processed successfully, for example to mark the row as processed. The query can have parameter.  */ public void setOnConsume(String onConsume) {     this.onConsume = onConsume. }
false;public;0;3;;public String getOnConsumeFailed() {     return onConsumeFailed. }
true;public;1;3;/**  * After processing each row then this query can be executed, if the Exchange failed, for example to mark the row as failed. The query can have parameter.  */ ;/**  * After processing each row then this query can be executed, if the Exchange failed, for example to mark the row as failed. The query can have parameter.  */ public void setOnConsumeFailed(String onConsumeFailed) {     this.onConsumeFailed = onConsumeFailed. }
false;public;0;3;;public String getOnConsumeBatchComplete() {     return onConsumeBatchComplete. }
true;public;1;3;/**  * After processing the entire batch, this query can be executed to bulk update rows etc. The query cannot have parameters.  */ ;/**  * After processing the entire batch, this query can be executed to bulk update rows etc. The query cannot have parameters.  */ public void setOnConsumeBatchComplete(String onConsumeBatchComplete) {     this.onConsumeBatchComplete = onConsumeBatchComplete. }
false;public;0;3;;public boolean isAllowNamedParameters() {     return allowNamedParameters. }
true;public;1;3;/**  * Whether to allow using named parameters in the queries.  */ ;/**  * Whether to allow using named parameters in the queries.  */ public void setAllowNamedParameters(boolean allowNamedParameters) {     this.allowNamedParameters = allowNamedParameters. }
false;public;0;3;;public boolean isAlwaysPopulateStatement() {     return alwaysPopulateStatement. }
true;public;1;3;/**  * If enabled then the populateStatement method from org.apache.camel.component.sql.SqlPrepareStatementStrategy is always invoked,  * also if there is no expected parameters to be prepared. When this is false then the populateStatement is only invoked if there  * is 1 or more expected parameters to be set. for example this avoids reading the message body/headers for SQL queries with no parameters.  */ ;/**  * If enabled then the populateStatement method from org.apache.camel.component.sql.SqlPrepareStatementStrategy is always invoked,  * also if there is no expected parameters to be prepared. When this is false then the populateStatement is only invoked if there  * is 1 or more expected parameters to be set. for example this avoids reading the message body/headers for SQL queries with no parameters.  */ public void setAlwaysPopulateStatement(boolean alwaysPopulateStatement) {     this.alwaysPopulateStatement = alwaysPopulateStatement. }
false;public;0;3;;public char getSeparator() {     return separator. }
true;public;1;3;/**  * The separator to use when parameter values is taken from message body (if the body is a String type), to be inserted at # placeholders.  * Notice if you use named parameters, then a Map type is used instead.  * <p/>  * The default value is comma.  */ ;/**  * The separator to use when parameter values is taken from message body (if the body is a String type), to be inserted at # placeholders.  * Notice if you use named parameters, then a Map type is used instead.  * <p/>  * The default value is comma.  */ public void setSeparator(char separator) {     this.separator = separator. }
false;public;0;3;;public SqlOutputType getOutputType() {     return outputType. }
true;public;1;3;/**  * Make the output of consumer or producer to SelectList as List of Map, or SelectOne as single Java object in the following way:  * a) If the query has only single column, then that JDBC Column object is returned. (such as SELECT COUNT( * ) FROM PROJECT will return a Long object.  * b) If the query has more than one column, then it will return a Map of that result.  * c) If the outputClass is set, then it will convert the query result into an Java bean object by calling all the setters that match the column names.  * It will assume your class has a default constructor to create instance with.  * d) If the query resulted in more than one rows, it throws an non-unique result exception.  */ ;/**  * Make the output of consumer or producer to SelectList as List of Map, or SelectOne as single Java object in the following way:  * a) If the query has only single column, then that JDBC Column object is returned. (such as SELECT COUNT( * ) FROM PROJECT will return a Long object.  * b) If the query has more than one column, then it will return a Map of that result.  * c) If the outputClass is set, then it will convert the query result into an Java bean object by calling all the setters that match the column names.  * It will assume your class has a default constructor to create instance with.  * d) If the query resulted in more than one rows, it throws an non-unique result exception.  */ public void setOutputType(SqlOutputType outputType) {     this.outputType = outputType. }
false;public;0;3;;public String getOutputClass() {     return outputClass. }
true;public;1;3;/**  * Specify the full package and class name to use as conversion when outputType=SelectOne.  */ ;/**  * Specify the full package and class name to use as conversion when outputType=SelectOne.  */ public void setOutputClass(String outputClass) {     this.outputClass = outputClass. }
false;public;0;3;;public int getParametersCount() {     return parametersCount. }
true;public;1;3;/**  * If set greater than zero, then Camel will use this count value of parameters to replace instead of querying via JDBC metadata API.  * This is useful if the JDBC vendor could not return correct parameters count, then user may override instead.  */ ;/**  * If set greater than zero, then Camel will use this count value of parameters to replace instead of querying via JDBC metadata API.  * This is useful if the JDBC vendor could not return correct parameters count, then user may override instead.  */ public void setParametersCount(int parametersCount) {     this.parametersCount = parametersCount. }
false;public;0;3;;public boolean isNoop() {     return noop. }
true;public;1;3;/**  * If set, will ignore the results of the SQL query and use the existing IN message as the OUT message for the continuation of processing  */ ;/**  * If set, will ignore the results of the SQL query and use the existing IN message as the OUT message for the continuation of processing  */ public void setNoop(boolean noop) {     this.noop = noop. }
false;public;0;3;;public String getOutputHeader() {     return outputHeader. }
true;public;1;3;/**  * Store the query result in a header instead of the message body.  * By default, outputHeader == null and the query result is stored in the message body,  * any existing content in the message body is discarded.  * If outputHeader is set, the value is used as the name of the header to store the  * query result and the original message body is preserved.  */ ;/**  * Store the query result in a header instead of the message body.  * By default, outputHeader == null and the query result is stored in the message body,  * any existing content in the message body is discarded.  * If outputHeader is set, the value is used as the name of the header to store the  * query result and the original message body is preserved.  */ public void setOutputHeader(String outputHeader) {     this.outputHeader = outputHeader. }
false;public;0;3;;public boolean isUseMessageBodyForSql() {     return useMessageBodyForSql. }
true;public;1;3;/**  * Whether to use the message body as the SQL and then headers for parameters.  * <p/>  * If this option is enabled then the SQL in the uri is not used.  */ ;/**  * Whether to use the message body as the SQL and then headers for parameters.  * <p/>  * If this option is enabled then the SQL in the uri is not used.  */ public void setUseMessageBodyForSql(boolean useMessageBodyForSql) {     this.useMessageBodyForSql = useMessageBodyForSql. }
false;public;0;3;;public String getDataSourceRef() {     return dataSourceRef. }
true;public;1;3;/**  * Sets the reference to a DataSource to lookup from the registry, to use for communicating with the database.  */ ;/**  * Sets the reference to a DataSource to lookup from the registry, to use for communicating with the database.  */ public void setDataSourceRef(String dataSourceRef) {     this.dataSourceRef = dataSourceRef. }
false;public;0;3;;public DataSource getDataSource() {     return dataSource. }
true;public;1;3;/**  * Sets the DataSource to use to communicate with the database.  */ ;/**  * Sets the DataSource to use to communicate with the database.  */ public void setDataSource(DataSource dataSource) {     this.dataSource = dataSource. }
false;public;0;3;;public boolean isUseIterator() {     return useIterator. }
true;public;1;3;/**  * Sets how resultset should be delivered to route. Indicates delivery as either a list or individual object. defaults to true.  */ ;/**  * Sets how resultset should be delivered to route. Indicates delivery as either a list or individual object. defaults to true.  */ public void setUseIterator(boolean useIterator) {     this.useIterator = useIterator. }
false;public;0;3;;public boolean isRouteEmptyResultSet() {     return routeEmptyResultSet. }
true;public;1;3;/**  * Sets whether empty resultset should be allowed to be sent to the next hop.  * Defaults to false. So the empty resultset will be filtered out.  */ ;/**  * Sets whether empty resultset should be allowed to be sent to the next hop.  * Defaults to false. So the empty resultset will be filtered out.  */ public void setRouteEmptyResultSet(boolean routeEmptyResultSet) {     this.routeEmptyResultSet = routeEmptyResultSet. }
false;public;0;3;;public int getExpectedUpdateCount() {     return expectedUpdateCount. }
true;public;1;3;/**  * Sets an expected update count to validate when using onConsume.  */ ;/**  * Sets an expected update count to validate when using onConsume.  */ public void setExpectedUpdateCount(int expectedUpdateCount) {     this.expectedUpdateCount = expectedUpdateCount. }
false;public;0;3;;public boolean isBreakBatchOnConsumeFail() {     return breakBatchOnConsumeFail. }
true;public;1;3;/**  * Sets whether to break batch if onConsume failed.  */ ;/**  * Sets whether to break batch if onConsume failed.  */ public void setBreakBatchOnConsumeFail(boolean breakBatchOnConsumeFail) {     this.breakBatchOnConsumeFail = breakBatchOnConsumeFail. }
false;public;0;3;;public String getPlaceholder() {     return placeholder. }
true;public;1;3;/**  * Specifies a character that will be replaced to ? in SQL query.  * Notice, that it is simple String.replaceAll() operation and no SQL parsing is involved (quoted strings will also change).  */ ;/**  * Specifies a character that will be replaced to ? in SQL query.  * Notice, that it is simple String.replaceAll() operation and no SQL parsing is involved (quoted strings will also change).  */ public void setPlaceholder(String placeholder) {     this.placeholder = placeholder. }
false;public;0;3;;public boolean isUsePlaceholder() {     return usePlaceholder. }
true;public;1;3;/**  * Sets whether to use placeholder and replace all placeholder characters with ? sign in the SQL queries.  * <p/>  * This option is default <tt>true</tt>  */ ;/**  * Sets whether to use placeholder and replace all placeholder characters with ? sign in the SQL queries.  * <p/>  * This option is default <tt>true</tt>  */ public void setUsePlaceholder(boolean usePlaceholder) {     this.usePlaceholder = usePlaceholder. }
false;public;0;3;;public Map<String, Object> getTemplateOptions() {     return templateOptions. }
true;public;1;3;/**  * Configures the Spring JdbcTemplate with the key/values from the Map  */ ;/**  * Configures the Spring JdbcTemplate with the key/values from the Map  */ public void setTemplateOptions(Map<String, Object> templateOptions) {     this.templateOptions = templateOptions. }
false;public;2;15;;@SuppressWarnings("unchecked") public List<?> queryForList(ResultSet rs, boolean allowMapToClass) throws SQLException {     if (allowMapToClass && outputClass != null) {         Class<?> outputClazz = getCamelContext().getClassResolver().resolveClass(outputClass).         RowMapper rowMapper = new BeanPropertyRowMapper(outputClazz).         RowMapperResultSetExtractor<?> mapper = new RowMapperResultSetExtractor(rowMapper).         List<?> data = mapper.extractData(rs).         return data.     } else {         ColumnMapRowMapper rowMapper = new ColumnMapRowMapper().         RowMapperResultSetExtractor<Map<String, Object>> mapper = new RowMapperResultSetExtractor<>(rowMapper).         List<Map<String, Object>> data = mapper.extractData(rs).         return data.     } }
false;public;1;33;;@SuppressWarnings("unchecked") public Object queryForObject(ResultSet rs) throws SQLException {     Object result = null.     if (outputClass == null) {         RowMapper rowMapper = new ColumnMapRowMapper().         RowMapperResultSetExtractor<Map<String, Object>> mapper = new RowMapperResultSetExtractor<Map<String, Object>>(rowMapper).         List<Map<String, Object>> data = mapper.extractData(rs).         if (data.size() > 1) {             throw new SQLDataException("Query result not unique for outputType=SelectOne. Got " + data.size() + " count instead.").         } else if (data.size() == 1) {             // Set content depend on number of column from query result             Map<String, Object> row = data.get(0).             if (row.size() == 1) {                 result = row.values().iterator().next().             } else {                 result = row.             }         }     } else {         Class<?> outputClzz = getCamelContext().getClassResolver().resolveClass(outputClass).         RowMapper rowMapper = new BeanPropertyRowMapper(outputClzz).         RowMapperResultSetExtractor<?> mapper = new RowMapperResultSetExtractor(rowMapper).         List<?> data = mapper.extractData(rs).         if (data.size() > 1) {             throw new SQLDataException("Query result not unique for outputType=SelectOne. Got " + data.size() + " count instead.").         } else if (data.size() == 1) {             result = data.get(0).         }     }     // If data.size is zero, let result be null.     return result. }
false;public;3;11;;@SuppressWarnings("unchecked") public ResultSetIterator queryForStreamList(Connection connection, Statement statement, ResultSet rs) throws SQLException {     if (outputClass == null) {         RowMapper rowMapper = new ColumnMapRowMapper().         return new ResultSetIterator(connection, statement, rs, rowMapper).     } else {         Class<?> outputClzz = getCamelContext().getClassResolver().resolveClass(outputClass).         RowMapper rowMapper = new BeanPropertyRowMapper(outputClzz).         return new ResultSetIterator(connection, statement, rs, rowMapper).     } }
