commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public SqlStoredEndpoint getEndpoint() {     return (SqlStoredEndpoint) super.getEndpoint(). }
false;public;1;59;;@Override public void execute(StatementWrapper ps) throws SQLException, DataAccessException {     // transfer incoming message body data to prepared statement parameters, if necessary     if (getEndpoint().isBatch()) {         Iterator<?> iterator.         if (getEndpoint().isUseMessageBodyForTemplate()) {             iterator = exchange.getIn().getHeader(SqlStoredConstants.SQL_STORED_PARAMETERS, Iterator.class).         } else {             iterator = exchange.getIn().getBody(Iterator.class).         }         if (iterator == null) {             throw new IllegalStateException("batch=true but Iterator cannot be found from body or header").         }         while (iterator.hasNext()) {             Object value = iterator.next().             ps.addBatch(value, exchange).         }     } else {         Object value.         if (getEndpoint().isUseMessageBodyForTemplate()) {             value = exchange.getIn().getHeader(SqlStoredConstants.SQL_STORED_PARAMETERS).         } else {             value = exchange.getIn().getBody().         }         ps.populateStatement(value, exchange).     }     // call the prepared statement and populate the outgoing message     if (getEndpoint().isBatch()) {         int[] updateCounts = ps.executeBatch().         int total = 0.         for (int count : updateCounts) {             total += count.         }         exchange.getIn().setHeader(SqlStoredConstants.SQL_STORED_UPDATE_COUNT, total).     } else {         Object result = ps.executeStatement().         // preserve headers first, so we can override the SQL_ROW_COUNT and SQL_UPDATE_COUNT headers         // if statement returns them         exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders()).         if (result != null) {             if (getEndpoint().isNoop()) {                 exchange.getOut().setBody(exchange.getIn().getBody()).             } else if (getEndpoint().getOutputHeader() != null) {                 exchange.getOut().setBody(exchange.getIn().getBody()).                 exchange.getOut().setHeader(getEndpoint().getOutputHeader(), result).             } else {                 exchange.getOut().setBody(result).             }         }         if (ps.getUpdateCount() != null) {             exchange.getOut().setHeader(SqlStoredConstants.SQL_STORED_UPDATE_COUNT, ps.getUpdateCount()).         }     } }
false;public;1;64;;public void process(final Exchange exchange) throws Exception {     StatementWrapper statementWrapper = createStatement(exchange).     statementWrapper.call(new WrapperExecuteCallback() {          @Override         public void execute(StatementWrapper ps) throws SQLException, DataAccessException {             // transfer incoming message body data to prepared statement parameters, if necessary             if (getEndpoint().isBatch()) {                 Iterator<?> iterator.                 if (getEndpoint().isUseMessageBodyForTemplate()) {                     iterator = exchange.getIn().getHeader(SqlStoredConstants.SQL_STORED_PARAMETERS, Iterator.class).                 } else {                     iterator = exchange.getIn().getBody(Iterator.class).                 }                 if (iterator == null) {                     throw new IllegalStateException("batch=true but Iterator cannot be found from body or header").                 }                 while (iterator.hasNext()) {                     Object value = iterator.next().                     ps.addBatch(value, exchange).                 }             } else {                 Object value.                 if (getEndpoint().isUseMessageBodyForTemplate()) {                     value = exchange.getIn().getHeader(SqlStoredConstants.SQL_STORED_PARAMETERS).                 } else {                     value = exchange.getIn().getBody().                 }                 ps.populateStatement(value, exchange).             }             // call the prepared statement and populate the outgoing message             if (getEndpoint().isBatch()) {                 int[] updateCounts = ps.executeBatch().                 int total = 0.                 for (int count : updateCounts) {                     total += count.                 }                 exchange.getIn().setHeader(SqlStoredConstants.SQL_STORED_UPDATE_COUNT, total).             } else {                 Object result = ps.executeStatement().                 // preserve headers first, so we can override the SQL_ROW_COUNT and SQL_UPDATE_COUNT headers                 // if statement returns them                 exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders()).                 if (result != null) {                     if (getEndpoint().isNoop()) {                         exchange.getOut().setBody(exchange.getIn().getBody()).                     } else if (getEndpoint().getOutputHeader() != null) {                         exchange.getOut().setBody(exchange.getIn().getBody()).                         exchange.getOut().setHeader(getEndpoint().getOutputHeader(), result).                     } else {                         exchange.getOut().setBody(result).                     }                 }                 if (ps.getUpdateCount() != null) {                     exchange.getOut().setHeader(SqlStoredConstants.SQL_STORED_UPDATE_COUNT, ps.getUpdateCount()).                 }             }         }     }). }
false;private;1;17;;private StatementWrapper createStatement(Exchange exchange) throws SQLException {     String sql.     if (getEndpoint().isUseMessageBodyForTemplate()) {         sql = exchange.getIn().getBody(String.class).     } else {         String templateHeader = exchange.getIn().getHeader(SqlStoredConstants.SQL_STORED_TEMPLATE, String.class).         sql = templateHeader != null ? templateHeader : resolvedTemplate.     }     try {         sql = SqlHelper.resolveQuery(getEndpoint().getCamelContext(), sql, null).     } catch (Exception e) {         throw new SQLException("Error loading template resource: " + sql, e).     }     return getEndpoint().getWrapperFactory().create(sql). }
false;protected;0;6;;@Override protected void doStart() throws Exception {     super.doStart().     resolvedTemplate = SqlHelper.resolveQuery(getEndpoint().getCamelContext(), getEndpoint().getTemplate(), null). }
