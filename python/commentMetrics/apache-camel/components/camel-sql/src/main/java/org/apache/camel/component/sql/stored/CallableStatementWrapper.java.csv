commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void call(final WrapperExecuteCallback cb) throws Exception {     cb.execute(this). }
false;public;1;5;;@Override public CallableStatement createCallableStatement(Connection connection) throws SQLException {     return batchFactory.newCallableStatementCreator(params.next()).createCallableStatement(connection). }
false;public;1;11;;@Override public int[] doInCallableStatement(CallableStatement callableStatement) throws SQLException, DataAccessException {     // add first item to batch     callableStatement.addBatch().     while (params.hasNext()) {         batchFactory.addParameter(callableStatement, params.next()).         callableStatement.addBatch().     }     return callableStatement.executeBatch(). }
false;public;0;30;;@Override public int[] executeBatch() throws SQLException {     if (this.batchItems == null) {         throw new IllegalArgumentException("Batch must have at least one item").     }     final Iterator<Map<String, ?>> params = batchItems.iterator().     return factory.getJdbcTemplate().execute(new CallableStatementCreator() {          @Override         public CallableStatement createCallableStatement(Connection connection) throws SQLException {             return batchFactory.newCallableStatementCreator(params.next()).createCallableStatement(connection).         }     }, new CallableStatementCallback<int[]>() {          @Override         public int[] doInCallableStatement(CallableStatement callableStatement) throws SQLException, DataAccessException {             // add first item to batch             callableStatement.addBatch().             while (params.hasNext()) {                 batchFactory.addParameter(callableStatement, params.next()).                 callableStatement.addBatch().             }             return callableStatement.executeBatch().         }     }). }
false;public;0;4;;@Override public Integer getUpdateCount() throws SQLException {     return this.updateCount. }
false;public;0;4;;@Override public Object executeStatement() throws SQLException {     return this.result. }
false;public;2;6;;@Override public void populateStatement(Object value, Exchange exchange) throws SQLException {     this.result = this.factory.getTemplateStoredProcedure(this.template).execute(exchange, value).     // Spring sets #update-result-1     this.updateCount = (Integer) this.result.get("#update-count-1"). }
false;public;2;19;;@Override public void addBatch(Object value, Exchange exchange) {     if (this.batchFactory == null) {         this.batchFactory = factory.getTemplateForBatch(template).     }     Map<String, Object> batchValues = new HashMap<>().     // only IN-parameters supported by template     for (Object param : this.batchFactory.getTemplate().getParameterList()) {         InParameter inputParameter = (InParameter) param.         Object paramValue = inputParameter.getValueExtractor().eval(exchange, value).         batchValues.put(inputParameter.getName(), paramValue).     }     if (this.batchItems == null) {         this.batchItems = new ArrayList<>().     }     batchItems.add(batchValues). }
