commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before public void setUp() throws Exception {     db = new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.DERBY).addScript("sql/storedProcedureTest.sql").build().     super.setUp(). }
false;public;0;5;;@After public void tearDown() throws Exception {     super.tearDown().     db.shutdown(). }
false;public;0;30;;@Test public void shouldExecuteBatch() throws InterruptedException {     MockEndpoint mock = getMockEndpoint("mock:query").     mock.expectedMessageCount(1).     List<Map<String, Object>> batchParams = new ArrayList<>().     Map<String, Object> batch1 = new HashMap<>().     batchParams.add(batch1).     batch1.put("num", "1").     Map<String, Object> batch2 = new HashMap<>().     batch2.put("num", "3").     batchParams.add(batch2).     final long batchfnCallsBefore = TestStoredProcedure.BATCHFN_CALL_COUNTER.get().     template.requestBody("direct:query", batchParams).     assertMockEndpointsSatisfied().     Exchange exchange = mock.getExchanges().get(0).     assertNotNull(exchange.getIn().getHeader(SqlStoredConstants.SQL_STORED_UPDATE_COUNT)).     assertEquals(batchfnCallsBefore + 2, TestStoredProcedure.BATCHFN_CALL_COUNTER.get()). }
false;public;0;7;;@Override public void configure() throws Exception {     // required for the sql component     getContext().getComponent("sql-stored", SqlStoredComponent.class).setDataSource(db).     from("direct:query").to("sql-stored:BATCHFN(INTEGER :#num)?batch=true").to("mock:query"). }
false;protected;0;12;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             // required for the sql component             getContext().getComponent("sql-stored", SqlStoredComponent.class).setDataSource(db).             from("direct:query").to("sql-stored:BATCHFN(INTEGER :#num)?batch=true").to("mock:query").         }     }. }
