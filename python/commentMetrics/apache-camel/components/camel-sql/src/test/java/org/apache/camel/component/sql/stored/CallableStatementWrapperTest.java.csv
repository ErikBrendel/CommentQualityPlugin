commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Before public void setUp() throws Exception {     db = new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.DERBY).addScript("sql/storedProcedureTest.sql").build().     jdbcTemplate = new JdbcTemplate(db).     super.setUp(). }
false;protected;0;6;;@Override protected void startCamelContext() throws Exception {     super.startCamelContext().     templateParser = new TemplateParser(context().getClassResolver()).     this.factory = new CallableStatementWrapperFactory(jdbcTemplate, templateParser, false). }
false;public;1;7;;@Override public void execute(StatementWrapper statementWrapper) throws SQLException, DataAccessException {     statementWrapper.populateStatement(null, exchange).     Map resultOfQuery = (Map) statementWrapper.executeStatement().     Assert.assertEquals(-1, resultOfQuery.get("resultofsub")). }
false;public;0;19;;@Test public void shouldExecuteStoredProcedure() throws Exception {     CallableStatementWrapper wrapper = new CallableStatementWrapper("SUBNUMBERS" + "(INTEGER ${header.v1},INTEGER ${header.v2},OUT INTEGER resultofsub)", factory).     final Exchange exchange = createExchangeWithBody(null).     exchange.getIn().setHeader("v1", 1).     exchange.getIn().setHeader("v2", 2).     wrapper.call(new WrapperExecuteCallback() {          @Override         public void execute(StatementWrapper statementWrapper) throws SQLException, DataAccessException {             statementWrapper.populateStatement(null, exchange).             Map resultOfQuery = (Map) statementWrapper.executeStatement().             Assert.assertEquals(-1, resultOfQuery.get("resultofsub")).         }     }). }
false;public;1;7;;@Override public void execute(StatementWrapper statementWrapper) throws SQLException, DataAccessException {     statementWrapper.populateStatement(null, exchange).     Map resultOfQuery = (Map) statementWrapper.executeStatement().     Assert.assertEquals(-1, resultOfQuery.get("resultofsub")). }
false;public;0;21;;@Test public void shouldExecuteStoredFunction() throws Exception {     CallableStatementWrapperFactory factory = new CallableStatementWrapperFactory(jdbcTemplate, templateParser, true).     CallableStatementWrapper wrapper = new CallableStatementWrapper("SUBNUMBERS_FUNCTION" + "(OUT INTEGER resultofsub, INTEGER ${header.v1},INTEGER ${header.v2})", factory).     final Exchange exchange = createExchangeWithBody(null).     exchange.getIn().setHeader("v1", 1).     exchange.getIn().setHeader("v2", 2).     wrapper.call(new WrapperExecuteCallback() {          @Override         public void execute(StatementWrapper statementWrapper) throws SQLException, DataAccessException {             statementWrapper.populateStatement(null, exchange).             Map resultOfQuery = (Map) statementWrapper.executeStatement().             Assert.assertEquals(-1, resultOfQuery.get("resultofsub")).         }     }). }
false;public;1;10;;@Override public void execute(StatementWrapper statementWrapper) throws SQLException, DataAccessException {     statementWrapper.populateStatement(null, null).     Map result = (Map) statementWrapper.executeStatement().     // no output parameter in stored procedure NILADIC()     // Spring sets #update-count-1     assertNotNull(result.get("#update-count-1")). }
false;public;0;17;;@Test public void shouldExecuteNilacidProcedure() throws Exception {     CallableStatementWrapper wrapper = new CallableStatementWrapper("NILADIC()", factory).     wrapper.call(new WrapperExecuteCallback() {          @Override         public void execute(StatementWrapper statementWrapper) throws SQLException, DataAccessException {             statementWrapper.populateStatement(null, null).             Map result = (Map) statementWrapper.executeStatement().             // no output parameter in stored procedure NILADIC()             // Spring sets #update-count-1             assertNotNull(result.get("#update-count-1")).         }     }). }
false;public;0;5;;@After public void tearDown() throws Exception {     super.tearDown().     db.shutdown(). }
