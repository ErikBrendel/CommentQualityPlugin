commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;public IrcConfiguration copy() {     try {         return (IrcConfiguration) clone().     } catch (CloneNotSupportedException e) {         throw new RuntimeCamelException(e).     } }
false;public;0;3;;public String getCacheKey() {     return hostname + ":" + nickname. }
true;public;0;7;/*      * Return space separated list of channel names without pwd      */ ;/*      * Return space separated list of channel names without pwd      */ public String getListOfChannels() {     StringBuilder retval = new StringBuilder().     for (IrcChannel channel : channels) {         retval.append(retval.length() == 0 ? "" : " ").append(channel.getName()).     }     return retval.toString(). }
false;public;1;49;;public void configure(String uriStr) throws URISyntaxException, UnsupportedEncodingException {     // fix provided URI and handle that we can use # to indicate the IRC room     if (uriStr.startsWith("ircs")) {         setUsingSSL(true).         if (!uriStr.startsWith("ircs://")) {             uriStr = uriStr.replace("ircs:", "ircs://").         }     } else if (!uriStr.startsWith("irc://")) {         uriStr = uriStr.replace("irc:", "irc://").     }     if (uriStr.contains("?")) {         uriStr = StringHelper.before(uriStr, "?").     }     URI uri = new URI(uriStr).     // Because we can get a "sanitized" URI, we need to deal with the situation where the     // user info includes the username and password together or else we get a mangled username     // that includes the user's secret being sent to the server.     String userInfo = uri.getUserInfo().     String username = null.     String password = null.     if (userInfo != null) {         int colonIndex = userInfo.indexOf(":").         if (colonIndex != -1) {             username = userInfo.substring(0, colonIndex).             password = userInfo.substring(colonIndex + 1).         } else {             username = userInfo.         }     }     if (uri.getPort() != -1) {         setPorts(new int[] { uri.getPort() }).         setPort(uri.getPort()).     }     setNickname(username).     setUsername(username).     setRealname(username).     setPassword(password).     setHostname(uri.getHost()).     String path = uri.getPath().     if (path != null && !path.isEmpty()) {         LOG.warn("Channel {} should not be specified in the URI path. Use an @channel query parameter instead.", path).     } }
false;public;1;3;;public void setChannel(String channel) {     channels.add(createChannel(channel)). }
false;public;1;5;;public void setChannel(List<String> channels) {     for (String ci : channels) {         this.channels.add(createChannel(ci)).     } }
false;public;0;3;;public List<IrcChannel> getChannels() {     return channels. }
false;public;1;8;;public IrcChannel findChannel(String name) {     for (IrcChannel channel : channels) {         if (channel.getName().equals(name)) {             return channel.         }     }     return null. }
true;public;1;3;/**  * The trust manager used to verify the SSL server's certificate.  */ ;/**  * The trust manager used to verify the SSL server's certificate.  */ public void setTrustManager(SSLTrustManager trustManager) {     this.trustManager = trustManager. }
false;public;0;3;;public SSLTrustManager getTrustManager() {     return trustManager. }
false;public;0;3;;public boolean getUsingSSL() {     return usingSSL. }
false;private;1;3;;private void setUsingSSL(boolean usingSSL) {     this.usingSSL = usingSSL. }
false;public;0;3;;public String getHostname() {     return hostname. }
true;public;1;3;/**  * Hostname for the IRC chat server  */ ;/**  * Hostname for the IRC chat server  */ public void setHostname(String hostname) {     this.hostname = hostname. }
false;public;0;3;;public String getPassword() {     return password. }
true;public;1;3;/**  * The IRC server password.  */ ;/**  * The IRC server password.  */ public void setPassword(String password) {     this.password = password. }
false;public;0;3;;public String getNickname() {     return nickname. }
true;public;1;3;/**  * The nickname used in chat.  */ ;/**  * The nickname used in chat.  */ public void setNickname(String nickname) {     this.nickname = nickname. }
false;public;0;3;;public String getRealname() {     return realname. }
true;public;1;3;/**  * The IRC user's actual name.  */ ;/**  * The IRC user's actual name.  */ public void setRealname(String realname) {     this.realname = realname. }
false;public;0;3;;public String getUsername() {     return username. }
true;public;1;3;/**  * The IRC server user name.  */ ;/**  * The IRC server user name.  */ public void setUsername(String username) {     this.username = username. }
false;public;0;3;;public int[] getPorts() {     return ports. }
true;public;1;3;/**  * Port numbers for the IRC chat server  */ ;/**  * Port numbers for the IRC chat server  */ public void setPorts(int[] ports) {     this.ports = ports. }
false;public;0;3;;public int getPort() {     return port. }
true;public;1;3;/**  * Port number for the IRC chat server. If no port is configured then a default port of either 6667, 6668 or 6669 is used.  */ ;/**  * Port number for the IRC chat server. If no port is configured then a default port of either 6667, 6668 or 6669 is used.  */ public void setPort(int port) {     this.port = port. }
false;public;0;3;;public boolean isPersistent() {     return persistent. }
true;public;1;4;/**  * Use persistent messages.  * @deprecated not in use  */ ;/**  * Use persistent messages.  * @deprecated not in use  */ @Deprecated public void setPersistent(boolean persistent) {     this.persistent = persistent. }
false;public;0;3;;public boolean isColors() {     return colors. }
true;public;1;3;/**  * Whether or not the server supports color codes.  */ ;/**  * Whether or not the server supports color codes.  */ public void setColors(boolean colors) {     this.colors = colors. }
false;public;0;3;;public boolean isOnNick() {     return onNick. }
true;public;1;3;/**  * Handle nickname change events.  */ ;/**  * Handle nickname change events.  */ public void setOnNick(boolean onNick) {     this.onNick = onNick. }
false;public;0;3;;public boolean isOnQuit() {     return onQuit. }
true;public;1;3;/**  * Handle user quit events.  */ ;/**  * Handle user quit events.  */ public void setOnQuit(boolean onQuit) {     this.onQuit = onQuit. }
false;public;0;3;;public boolean isOnJoin() {     return onJoin. }
true;public;1;3;/**  * Handle user join events.  */ ;/**  * Handle user join events.  */ public void setOnJoin(boolean onJoin) {     this.onJoin = onJoin. }
false;public;0;3;;public boolean isOnKick() {     return onKick. }
true;public;1;3;/**  * Handle kick events.  */ ;/**  * Handle kick events.  */ public void setOnKick(boolean onKick) {     this.onKick = onKick. }
false;public;0;3;;public boolean isOnMode() {     return onMode. }
true;public;1;3;/**  * Handle mode change events.  */ ;/**  * Handle mode change events.  */ public void setOnMode(boolean onMode) {     this.onMode = onMode. }
false;public;0;3;;public boolean isOnPart() {     return onPart. }
true;public;1;3;/**  * Handle user part events.  */ ;/**  * Handle user part events.  */ public void setOnPart(boolean onPart) {     this.onPart = onPart. }
false;public;0;3;;public boolean isOnReply() {     return onReply. }
true;public;1;3;/**  * Whether or not to handle general responses to commands or informational messages.  */ ;/**  * Whether or not to handle general responses to commands or informational messages.  */ public void setOnReply(boolean onReply) {     this.onReply = onReply. }
false;public;0;3;;public boolean isOnTopic() {     return onTopic. }
true;public;1;3;/**  * Handle topic change events.  */ ;/**  * Handle topic change events.  */ public void setOnTopic(boolean onTopic) {     this.onTopic = onTopic. }
false;public;0;3;;public boolean isOnPrivmsg() {     return onPrivmsg. }
true;public;1;3;/**  * Handle private message events.  */ ;/**  * Handle private message events.  */ public void setOnPrivmsg(boolean onPrivmsg) {     this.onPrivmsg = onPrivmsg. }
false;public;0;3;;public boolean isAutoRejoin() {     return autoRejoin. }
true;public;1;3;/**  * Whether to auto re-join when being kicked  */ ;/**  * Whether to auto re-join when being kicked  */ public void setAutoRejoin(boolean autoRejoin) {     this.autoRejoin = autoRejoin. }
false;public;0;3;;public SSLContextParameters getSslContextParameters() {     return sslContextParameters. }
true;public;1;3;/**  * Used for configuring security using SSL.  * Reference to a org.apache.camel.support.jsse.SSLContextParameters in the Registry.  * This reference overrides any configured SSLContextParameters at the component level.  * Note that this setting overrides the trustManager option.  */ ;/**  * Used for configuring security using SSL.  * Reference to a org.apache.camel.support.jsse.SSLContextParameters in the Registry.  * This reference overrides any configured SSLContextParameters at the component level.  * Note that this setting overrides the trustManager option.  */ public void setSslContextParameters(SSLContextParameters sslContextParameters) {     this.sslContextParameters = sslContextParameters. }
true;public;0;3;/**  * Your IRC server nickname password.  */ ;/**  * Your IRC server nickname password.  */ public String getNickPassword() {     return nickPassword. }
false;public;1;3;;public void setNickPassword(String nickPassword) {     this.nickPassword = nickPassword. }
true;public;1;3;/**  * Delay in milliseconds before sending commands after the connection is established.  * @param timeout timeout value in milliseconds  */ ;/**  * Delay in milliseconds before sending commands after the connection is established.  * @param timeout timeout value in milliseconds  */ public void setCommandTimeout(long timeout) {     this.commandTimeout = timeout. }
false;public;0;3;;public long getCommandTimeout() {     return commandTimeout. }
false;public;0;3;;public boolean isNamesOnJoin() {     return namesOnJoin. }
true;public;1;3;/**  * Sends <code>NAMES</code> command to channel after joining it.<br>  * {@link #onReply} has to be <code>true</code> in order to process the  * result which will have the header value <code>irc.num = '353'</code>.  */ ;/**  * Sends <code>NAMES</code> command to channel after joining it.<br>  * {@link #onReply} has to be <code>true</code> in order to process the  * result which will have the header value <code>irc.num = '353'</code>.  */ public void setNamesOnJoin(boolean namesOnJoin) {     this.namesOnJoin = namesOnJoin. }
false;public;0;4;;public String toString() {     return "IrcConfiguration[hostname: " + hostname + ", ports=" + Arrays.toString(ports) + ", username=" + username + "]". }
false;private,static;1;4;;private static IrcChannel createChannel(String channelInfo) {     String[] pair = channelInfo.split("!").     return new IrcChannel(pair[0], pair.length > 1 ? pair[1] : null). }
false;public,static;1;116;;@Deprecated public static String sanitize(String uri) {     // may be removed in camel-3.0.0     // make sure it's an URL first     int colon = uri.indexOf(':').     if (colon != -1 && uri.indexOf("://") != colon) {         uri = uri.substring(0, colon) + "://" + uri.substring(colon + 1).     }     try {         URI u = new URI(UnsafeUriCharactersEncoder.encode(uri)).         String[] userInfo = u.getUserInfo() != null ? u.getUserInfo().split(":") : null.         String username = userInfo != null ? userInfo[0] : null.         String password = userInfo != null && userInfo.length > 1 ? userInfo[1] : null.         String path = URLDecoder.decode(u.getPath() != null ? u.getPath() : "", "UTF-8").         if (path.startsWith("/")) {             path = path.substring(1).         }         if (path.startsWith("#") && !path.startsWith("##")) {             path = path.substring(1).         }         Map<String, Object> parameters = URISupport.parseParameters(u).         String user = (String) parameters.get("username").         String nick = (String) parameters.get("nickname").         // not specified in authority         if (user != null) {             if (username == null) {                 username = user.             } else if (!username.equals(user)) {                 LOG.warn("Username specified twice in endpoint URI with different values. " + "The userInfo value ('{}') will be used, paramter ('{}') ignored", username, user).             }             parameters.remove("username").         }         if (nick != null) {             if (username == null) {                 username = nick.             }             if (username.equals(nick)) {                 // redundant                 parameters.remove("nickname").             }         }         if (username == null) {             throw new RuntimeCamelException("IrcEndpoint URI with no user/nick specified is invalid").         }         String pwd = (String) parameters.get("password").         if (pwd != null) {             password = pwd.             parameters.remove("password").         }         // Remove unneeded '#' channel prefixes per convention         // and replace ',' separators and merge channel and key using convention "channel!key"         List<String> cl = new ArrayList<>().         String channels = (String) parameters.get("channels").         String keys = (String) parameters.get("keys").         // if @keys ends with a ',' it will miss the last empty key after split(",")         keys = keys == null ? keys : keys + " ".         if (channels != null) {             String[] chs = channels.split(",").             String[] ks = keys != null ? keys.split(",") : null.             parameters.remove("channels").             int count = chs.length.             if (ks != null) {                 parameters.remove("keys").                 if (!path.isEmpty()) {                     LOG.warn("Specifying a channel '{}' in the URI path is ambiguous" + " when @channels and @keys are provided and will be ignored", path).                     path = "".                 }                 if (ks.length != chs.length) {                     count = count < ks.length ? count : ks.length.                     LOG.warn("Different count of @channels and @keys. Only the first {} are used.", count).                 }             }             for (int i = 0. i < count. i++) {                 String channel = chs[i].trim().                 String key = ks != null ? ks[i].trim() : null.                 if (channel.startsWith("#") && !channel.startsWith("##")) {                     channel = channel.substring(1).                 }                 if (key != null && !key.isEmpty()) {                     channel += "!" + key.                 }                 cl.add(channel).             }         } else {             if (path.isEmpty()) {                 LOG.warn("No channel specified for the irc endpoint").             }             cl.add(path).         }         parameters.put("channel", cl).         StringBuilder sb = new StringBuilder().         sb.append(u.getScheme()).         sb.append("://").         sb.append(username).         sb.append(password == null ? "" : ":" + password).         sb.append("@").         sb.append(u.getHost()).         sb.append(u.getPort() == -1 ? "" : ":" + u.getPort()).         // ignore the path we have it as a @channel now         String query = formatQuery(parameters).         if (!query.isEmpty()) {             sb.append("?").             sb.append(query).         }         // make things a bit more predictable         return sb.toString().     } catch (Exception e) {         throw new RuntimeCamelException(e).     } }
false;private,static;1;19;;private static String formatQuery(Map<String, Object> params) {     if (params == null || params.size() == 0) {         return "".     }     StringBuilder result = new StringBuilder().     for (Map.Entry<String, Object> pair : params.entrySet()) {         Object value = pair.getValue().         // the value may be a list since the same key has multiple values         if (value instanceof List) {             List<?> list = (List<?>) value.             for (Object s : list) {                 addQueryParameter(result, pair.getKey(), s).             }         } else {             addQueryParameter(result, pair.getKey(), value).         }     }     return result.toString(). }
false;private,static;3;8;;private static void addQueryParameter(StringBuilder sb, String key, Object value) {     sb.append(sb.length() == 0 ? "" : "&").     sb.append(key).     if (value != null) {         String s = value.toString().         sb.append(s.isEmpty() ? "" : "=" + UnsafeUriCharactersEncoder.encode(s)).     } }
