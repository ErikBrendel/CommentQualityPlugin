commented;modifiers;parameterAmount;loc;comment;code
false;;2;22;;// ********************************* // Handlers // ********************************* @InvokeOnHeader("PUT") boolean onPut(Message message, AsyncCallback callback) throws Exception {     final DistributedMultiMap<Object, Object> map = getResource(message).     final Object key = message.getHeader(RESOURCE_KEY, configuration::getKey, Object.class).     final Object val = message.getHeader(RESOURCE_VALUE, message::getBody, Object.class).     final long ttl = message.getHeader(RESOURCE_TTL, configuration::getTtl, long.class).     ObjectHelper.notNull(key, RESOURCE_KEY).     ObjectHelper.notNull(val, RESOURCE_VALUE).     if (ttl > 0) {         map.put(key, val, Duration.ofMillis(ttl)).thenAccept(result -> processResult(message, callback, result)).     } else {         map.put(key, val).thenAccept(result -> processResult(message, callback, result)).     }     return false. }
false;;2;20;;@InvokeOnHeader("GET") boolean onGet(Message message, AsyncCallback callback) throws Exception {     final DistributedMultiMap<Object, Object> map = getResource(message).     final Object key = message.getHeader(RESOURCE_KEY, configuration::getKey, Object.class).     final ReadConsistency consistency = message.getHeader(RESOURCE_READ_CONSISTENCY, configuration::getReadConsistency, ReadConsistency.class).     ObjectHelper.notNull(key, RESOURCE_KEY).     if (consistency != null) {         map.get(key, consistency).thenAccept(result -> processResult(message, callback, result)).     } else {         map.get(key).thenAccept(result -> processResult(message, callback, result)).     }     return false. }
false;;2;10;;@InvokeOnHeader("CLEAR") boolean onClear(Message message, AsyncCallback callback) throws Exception {     final DistributedMultiMap<Object, Object> map = getResource(message).     map.clear().thenAccept(result -> processResult(message, callback, result)).     return false. }
false;;2;30;;@InvokeOnHeader("SIZE") boolean onSize(Message message, AsyncCallback callback) throws Exception {     final DistributedMultiMap<Object, Object> map = getResource(message).     final ReadConsistency consistency = message.getHeader(RESOURCE_READ_CONSISTENCY, configuration::getReadConsistency, ReadConsistency.class).     final Object key = message.getHeader(RESOURCE_KEY, message::getBody, Object.class).     if (consistency != null) {         if (key != null) {             map.size(key, consistency).thenAccept(result -> processResult(message, callback, result)).         } else {             map.size(consistency).thenAccept(result -> processResult(message, callback, result)).         }     } else {         if (key != null) {             map.size(key).thenAccept(result -> processResult(message, callback, result)).         } else {             map.size().thenAccept(result -> processResult(message, callback, result)).         }     }     return false. }
false;;2;17;;@InvokeOnHeader("IS_EMPTY") boolean onIsEmpty(Message message, AsyncCallback callback) throws Exception {     final DistributedMultiMap<Object, Object> map = getResource(message).     final ReadConsistency consistency = message.getHeader(RESOURCE_READ_CONSISTENCY, configuration::getReadConsistency, ReadConsistency.class).     if (consistency != null) {         map.isEmpty(consistency).thenAccept(result -> processResult(message, callback, result)).     } else {         map.isEmpty().thenAccept(result -> processResult(message, callback, result)).     }     return false. }
false;;2;20;;@InvokeOnHeader("CONTAINS_KEY") boolean onContainsKey(Message message, AsyncCallback callback) throws Exception {     final DistributedMultiMap<Object, Object> map = getResource(message).     final ReadConsistency consistency = message.getHeader(RESOURCE_READ_CONSISTENCY, configuration::getReadConsistency, ReadConsistency.class).     final Object key = message.getHeader(RESOURCE_KEY, message::getBody, Object.class).     ObjectHelper.notNull(key, RESOURCE_KEY).     if (consistency != null) {         map.containsKey(key, consistency).thenAccept(result -> processResult(message, callback, result)).     } else {         map.containsKey(key).thenAccept(result -> processResult(message, callback, result)).     }     return false. }
false;;2;20;;// @InvokeOnHeader("CONTAINS_VALUE") // boolean onContainsValue(Message message, AsyncCallback callback) throws Exception { // final DistributedMultiMap<Object, Object> map = getResource(message). // final ReadConsistency consistency = message.getHeader(RESOURCE_READ_CONSISTENCY,  configuration::getReadConsistency, ReadConsistency.class). // final Object value = message.getHeader(RESOURCE_VALUE, message::getBody, Object.class). //  // ObjectHelper.notNull(value, RESOURCE_VALUE). //  // if (consistency != null) { // map.containsValue(value, consistency).thenAccept( // result -> processResult(message, callback, result) // ). // } else { // map.containsValue(value).thenAccept( // result -> processResult(message, callback, result) // ). // } //  // return false. // } // @InvokeOnHeader("CONTAINS_ENTRY") // boolean onContainsEntry(Message message, AsyncCallback callback) throws Exception { // final DistributedMultiMap<Object, Object> map = getResource(message). // final ReadConsistency consistency = message.getHeader(RESOURCE_READ_CONSISTENCY,  configuration::getReadConsistency, ReadConsistency.class). // final Object key = message.getHeader(RESOURCE_KEY, message::getBody, Object.class). // final Object value = message.getHeader(RESOURCE_VALUE, message::getBody, Object.class). //  // ObjectHelper.notNull(key, RESOURCE_VALUE). // ObjectHelper.notNull(value, RESOURCE_KEY). //  // if (consistency != null) { // map.containsEntry(key, value, consistency).thenAccept( // result -> processResult(message, callback, result) // ). // } else { // map.containsEntry(key, value).thenAccept( // result -> processResult(message, callback, result) // ). // } //  // return false. // } @InvokeOnHeader("REMOVE") boolean onRemove(Message message, AsyncCallback callback) throws Exception {     final DistributedMultiMap<Object, Object> map = getResource(message).     final Object key = message.getHeader(RESOURCE_KEY, message::getBody, Object.class).     final Object value = message.getHeader(RESOURCE_VALUE, message::getBody, Object.class).     ObjectHelper.notNull(key, RESOURCE_KEY).     if (value != null) {         map.remove(key, value).thenAccept(result -> processResult(message, callback, result)).     } else {         map.remove(key).thenAccept(result -> processResult(message, callback, result)).     }     return false. }
false;;2;13;;@InvokeOnHeader("REMOVE_VALUE") boolean onRemoveValue(Message message, AsyncCallback callback) throws Exception {     final DistributedMultiMap<Object, Object> map = getResource(message).     final Object value = message.getHeader(RESOURCE_VALUE, message::getBody, Object.class).     ObjectHelper.notNull(value, RESOURCE_VALUE).     map.removeValue(value).thenAccept(result -> processResult(message, callback, result)).     return false. }
false;protected;1;4;;// ********************************* // Implementation // ********************************* @Override protected String getProcessorKey(Message message) {     return message.getHeader(RESOURCE_ACTION, configuration::getDefaultAction, String.class). }
false;protected;1;4;;@Override protected String getResourceName(Message message) {     return message.getHeader(RESOURCE_NAME, getAtomixEndpoint()::getResourceName, String.class). }
false;protected;1;10;;@Override protected DistributedMultiMap<Object, Object> createResource(String resourceName) {     return getAtomixEndpoint().getAtomix().getMultiMap(resourceName, new DistributedMultiMap.Config(getAtomixEndpoint().getConfiguration().getResourceOptions(resourceName)), new DistributedMultiMap.Options(getAtomixEndpoint().getConfiguration().getResourceConfig(resourceName))).join(). }
