commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getId() {     return RxJavaStreamsConstants.SERVICE_NAME. }
false;public;0;3;;// ****************************************** // Lifecycle // ****************************************** @Override public void doStart() throws Exception { }
false;public;0;9;;@Override public void doStop() throws Exception {     for (RxJavaCamelProcessor processor : publishers.values()) {         processor.close().     }     for (ReactiveStreamsCamelSubscriber subscriber : subscribers.values()) {         subscriber.close().     } }
false;public;1;4;;// ****************************************** //  // ****************************************** @Override public Publisher<Exchange> fromStream(String name) {     return getCamelProcessor(name).getPublisher(). }
false;public;2;10;;@Override public <T> Publisher<T> fromStream(String name, Class<T> type) {     final Publisher<Exchange> publisher = fromStream(name).     if (Exchange.class.isAssignableFrom(type)) {         return Publisher.class.cast(publisher).     }     return Flowable.fromPublisher(publisher).map(BodyConverter.forType(type)::apply). }
false;public;1;4;;@Override public ReactiveStreamsCamelSubscriber streamSubscriber(String name) {     return subscribers.computeIfAbsent(name, n -> new ReactiveStreamsCamelSubscriber(name)). }
false;public;2;10;;@SuppressWarnings("unchecked") public <T> Subscriber<T> streamSubscriber(String name, Class<T> type) {     final Subscriber<Exchange> subscriber = streamSubscriber(name).     if (Exchange.class.equals(type)) {         return Subscriber.class.cast(subscriber).     }     return new ConvertingSubscriber<>(subscriber, context). }
false;public;2;7;;@Override public Publisher<Exchange> toStream(String name, Object data) {     return doRequest(name, ReactiveStreamsHelper.convertToExchange(context, data)). }
false;public;1;4;;@Override public Function<?, ? extends Publisher<Exchange>> toStream(String name) {     return data -> toStream(name, data). }
false;public;3;4;;@Override public <T> Publisher<T> toStream(String name, Object data, Class<T> type) {     return new ConvertingPublisher<>(toStream(name, data), type). }
false;public;2;4;;@Override public <T> Function<Object, Publisher<T>> toStream(String name, Class<T> type) {     return data -> toStream(name, data, type). }
false;public;0;4;;@Override public void configure() throws Exception {     from(camelUri).to("reactive-streams:" + uuid). }
false;public;1;21;;@Override public Publisher<Exchange> from(String uri) {     final String name = publishedUriToStream.computeIfAbsent(uri, camelUri -> {         try {             String uuid = context.getUuidGenerator().generateUuid().             context.addRoutes(new RouteBuilder() {                  @Override                 public void configure() throws Exception {                     from(camelUri).to("reactive-streams:" + uuid).                 }             }).             return uuid.         } catch (Exception e) {             throw new IllegalStateException("Unable to create source reactive stream from direct URI: " + uri, e).         }     }).     return fromStream(name). }
false;public;2;10;;@Override public <T> Publisher<T> from(String name, Class<T> type) {     final Publisher<Exchange> publisher = from(name).     if (Exchange.class.isAssignableFrom(type)) {         return Publisher.class.cast(publisher).     }     return Flowable.fromPublisher(publisher).map(BodyConverter.forType(type)::apply). }
false;public;0;5;;@Override public void configure() throws Exception {     from("reactive-streams:" + uuid).to(uri). }
false;public;1;17;;@Override public Subscriber<Exchange> subscriber(String uri) {     try {         String uuid = context.getUuidGenerator().generateUuid().         context.addRoutes(new RouteBuilder() {              @Override             public void configure() throws Exception {                 from("reactive-streams:" + uuid).to(uri).             }         }).         return streamSubscriber(uuid).     } catch (Exception e) {         throw new IllegalStateException("Unable to create source reactive stream towards direct URI: " + uri, e).     } }
false;public;2;4;;@Override public <T> Subscriber<T> subscriber(String uri, Class<T> type) {     return new ConvertingSubscriber<>(subscriber(uri), context). }
false;public;0;5;;@Override public void configure() throws Exception {     from("reactive-streams:" + uuid).to(camelUri). }
false;public;2;21;;@Override public Publisher<Exchange> to(String uri, Object data) {     String streamName = requestedUriToStream.computeIfAbsent(uri, camelUri -> {         try {             String uuid = context.getUuidGenerator().generateUuid().             context.addRoutes(new RouteBuilder() {                  @Override                 public void configure() throws Exception {                     from("reactive-streams:" + uuid).to(camelUri).                 }             }).             return uuid.         } catch (Exception e) {             throw new IllegalStateException("Unable to create requested reactive stream from direct URI: " + uri, e).         }     }).     return toStream(streamName, data). }
false;public;1;4;;@Override public Function<Object, Publisher<Exchange>> to(String uri) {     return data -> to(uri, data). }
false;public;3;6;;@Override public <T> Publisher<T> to(String uri, Object data, Class<T> type) {     Publisher<Exchange> publisher = to(uri, data).     return Flowable.fromPublisher(publisher).map(BodyConverter.forType(type)::apply). }
false;public;2;4;;@Override public <T> Function<Object, Publisher<T>> to(String uri, Class<T> type) {     return data -> to(uri, data, type). }
false;public;0;10;;@Override public void configure() throws Exception {     from(uri).process(exchange -> {         Exchange copy = exchange.copy().         Object result = processor.apply(Flowable.just(copy)).         exchange.getIn().setBody(result).     }).process(unwrapStreamProcessorSupplier.get()). }
false;public;2;19;;@Override public void process(String uri, Function<? super Publisher<Exchange>, ?> processor) {     try {         context.addRoutes(new RouteBuilder() {              @Override             public void configure() throws Exception {                 from(uri).process(exchange -> {                     Exchange copy = exchange.copy().                     Object result = processor.apply(Flowable.just(copy)).                     exchange.getIn().setBody(result).                 }).process(unwrapStreamProcessorSupplier.get()).             }         }).     } catch (Exception e) {         throw new IllegalStateException("Unable to add reactive stream processor to the direct URI: " + uri, e).     } }
false;public;3;9;;@Override public <T> void process(String uri, Class<T> type, Function<? super Publisher<T>, ?> processor) {     process(uri, publisher -> processor.apply(Flowable.fromPublisher(publisher).map(BodyConverter.forType(type)::apply))). }
false;public;2;4;;// ****************************************** // Producer // ****************************************** @Override public void attachCamelProducer(String name, ReactiveStreamsProducer producer) {     getCamelProcessor(name).attach(producer). }
false;public;1;4;;@Override public void detachCamelProducer(String name) {     getCamelProcessor(name).detach(). }
false;public;2;4;;@Override public void sendCamelExchange(String name, Exchange exchange) {     getCamelProcessor(name).send(exchange). }
false;private;1;3;;private RxJavaCamelProcessor getCamelProcessor(String name) {     return publishers.computeIfAbsent(name, key -> new RxJavaCamelProcessor(this, key)). }
false;public;2;7;;// ****************************************** // Consumer // ****************************************** @Override public ReactiveStreamsCamelSubscriber attachCamelConsumer(String name, ReactiveStreamsConsumer consumer) {     ReactiveStreamsCamelSubscriber subscriber = streamSubscriber(name).     subscriber.attachConsumer(consumer).     return subscriber. }
false;public;1;5;;@Override public void detachCamelConsumer(String name) {     ReactiveStreamsCamelSubscriber subscriber = streamSubscriber(name).     subscriber.detachConsumer(). }
false;public;1;4;;@Override public void onComplete(Exchange exchange) {     emitter.onSuccess(exchange). }
false;public;1;9;;@Override public void onFailure(Exchange exchange) {     Throwable throwable = exchange.getException().     if (throwable == null) {         throwable = new IllegalStateException("Unknown Exception").     }     emitter.onError(throwable). }
false;protected;2;29;;// ******************************************* // Helpers // ******************************************* protected Publisher<Exchange> doRequest(String name, Exchange data) {     ReactiveStreamsConsumer consumer = streamSubscriber(name).getConsumer().     if (consumer == null) {         throw new IllegalStateException("No consumers attached to the stream " + name).     }     Single<Exchange> source = Single.<Exchange>create(emitter -> data.addOnCompletion(new Synchronization() {          @Override         public void onComplete(Exchange exchange) {             emitter.onSuccess(exchange).         }          @Override         public void onFailure(Exchange exchange) {             Throwable throwable = exchange.getException().             if (throwable == null) {                 throwable = new IllegalStateException("Unknown Exception").             }             emitter.onError(throwable).         }     })).doOnSubscribe(subs -> consumer.process(data, RxJavaStreamsConstants.EMPTY_ASYNC_CALLBACK)).     return source.toFlowable(). }
