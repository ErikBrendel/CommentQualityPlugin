commented;modifiers;parameterAmount;loc;comment;code
false;public;3;17;;@Override public void handle(HttpRequest request, HttpResponse response, HttpContext context) throws HttpException, IOException {     LOGGER.debug("received request {}", request).     final HttpRequestWrapper requestWrapper = HttpRequestWrapper.wrap(request).     // make sure that our writing operations have authentication header     if (!authenticate(requestWrapper)) {         response.setStatusCode(HttpStatus.SC_FORBIDDEN).         response.setEntity(new StringEntity("Forbidden", ContentType.TEXT_PLAIN)).         return.     }     final String responseBody = IOUtils.toString(this.getClass().getResourceAsStream(mockResourceJsonResponse.get(requestWrapper.getMethod()))).     if (responseBody == null) {         LOGGER.warn("Resource not found on {}. Response body null.", mockResourceJsonResponse).     }     response.setStatusCode(HttpStatus.SC_OK).     response.setEntity(new StringEntity(responseBody, ContentType.APPLICATION_JSON)). }
false;private;1;15;;private boolean authenticate(HttpRequestWrapper request) {     // read operations don't need to authenticate     if (request.getMethod().contentEquals("GET")) {         return true.     }     for (Header authorizationHeader : request.getHeaders("Authorization")) {         // Authorization: Basic base64credentials         String base64Credentials = authorizationHeader.getValue().substring("Basic".length()).trim().         String credentials = new String(Base64.getDecoder().decode(base64Credentials), Charset.forName("UTF-8")).         // credentials = username:password         final String[] values = credentials.split(":", 2).         return USERNAME.equals(values[0]) && PASSWORD.equals(values[1]).     }     return false. }
