commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public MyBatisEndpoint getEndpoint() {     return (MyBatisEndpoint) super.getEndpoint(). }
true;protected;0;34;/**  * Polls the database  */ ;/**  * Polls the database  */ @Override protected int poll() throws Exception {     // must reset for each poll     shutdownRunningTask = null.     pendingExchanges = 0.     // poll data from the database     MyBatisEndpoint endpoint = getEndpoint().     log.trace("Polling: {}", endpoint).     List<?> data = endpoint.getProcessingStrategy().poll(this, getEndpoint()).     // create a list of exchange objects with the data     Queue<DataHolder> answer = new LinkedList<>().     if (useIterator) {         for (Object item : data) {             Exchange exchange = createExchange(item).             DataHolder holder = new DataHolder().             holder.exchange = exchange.             holder.data = item.             answer.add(holder).         }     } else {         if (!data.isEmpty() || routeEmptyResultSet) {             Exchange exchange = createExchange(data).             DataHolder holder = new DataHolder().             holder.exchange = exchange.             holder.data = data.             answer.add(holder).         }     }     // process all the exchanges in this batch     return processBatch(CastUtils.cast(answer)). }
false;public;1;50;;public int processBatch(Queue<Object> exchanges) throws Exception {     final MyBatisEndpoint endpoint = getEndpoint().     int total = exchanges.size().     // limit if needed     if (maxMessagesPerPoll > 0 && total > maxMessagesPerPoll) {         log.debug("Limiting to maximum messages to poll " + maxMessagesPerPoll + " as there were " + total + " messages in this poll.").         total = maxMessagesPerPoll.     }     for (int index = 0. index < total && isBatchAllowed(). index++) {         // only loop if we are started (allowed to run)         DataHolder holder = ObjectHelper.cast(DataHolder.class, exchanges.poll()).         Exchange exchange = holder.exchange.         Object data = holder.data.         // add current index and total as properties         exchange.setProperty(Exchange.BATCH_INDEX, index).         exchange.setProperty(Exchange.BATCH_SIZE, total).         exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1).         // update pending number of exchanges         pendingExchanges = total - index - 1.         // process the current exchange         log.debug("Processing exchange: {} with properties: {}", exchange, exchange.getProperties()).         getProcessor().process(exchange).         try {             if (onConsume != null) {                 endpoint.getProcessingStrategy().commit(endpoint, exchange, data, onConsume).             }         } catch (Exception e) {             handleException(e).         }         if (getEndpoint().isTransacted() && exchange.isFailed()) {             // break out as we are transacted and should rollback             Exception cause = exchange.getException().             if (cause != null) {                 throw cause.             } else {                 throw new RollbackExchangeException("Rollback transaction due error processing exchange", exchange).             }         }     }     return total. }
false;private;1;15;;private Exchange createExchange(Object data) {     final MyBatisEndpoint endpoint = getEndpoint().     final Exchange exchange = endpoint.createExchange(ExchangePattern.InOnly).     final String outputHeader = getEndpoint().getOutputHeader().     Message msg = exchange.getIn().     if (outputHeader != null) {         msg.setHeader(outputHeader, data).     } else {         msg.setBody(data).     }     msg.setHeader(MyBatisConstants.MYBATIS_STATEMENT_NAME, endpoint.getStatement()).     return exchange. }
true;public;0;3;/**  * Gets the statement(s) to run after successful processing.  * Use comma to separate multiple statements.  */ ;/**  * Gets the statement(s) to run after successful processing.  * Use comma to separate multiple statements.  */ public String getOnConsume() {     return onConsume. }
true;public;1;3;/**  * Sets the statement to run after successful processing.  * Use comma to separate multiple statements.  */ ;/**  * Sets the statement to run after successful processing.  * Use comma to separate multiple statements.  */ public void setOnConsume(String onConsume) {     this.onConsume = onConsume. }
true;public;0;3;/**  * Indicates how resultset should be delivered to the route  */ ;/**  * Indicates how resultset should be delivered to the route  */ public boolean isUseIterator() {     return useIterator. }
true;public;1;3;/**  * Sets how resultset should be delivered to route.  * Indicates delivery as either a list or individual object.  * defaults to true.  */ ;/**  * Sets how resultset should be delivered to route.  * Indicates delivery as either a list or individual object.  * defaults to true.  */ public void setUseIterator(boolean useIterator) {     this.useIterator = useIterator. }
true;public;0;3;/**  * Indicates whether empty resultset should be allowed to be sent to the next hop or not  */ ;/**  * Indicates whether empty resultset should be allowed to be sent to the next hop or not  */ public boolean isRouteEmptyResultSet() {     return routeEmptyResultSet. }
true;public;1;3;/**  * Sets whether empty resultset should be allowed to be sent to the next hop.  * defaults to false. So the empty resultset will be filtered out.  */ ;/**  * Sets whether empty resultset should be allowed to be sent to the next hop.  * defaults to false. So the empty resultset will be filtered out.  */ public void setRouteEmptyResultSet(boolean routeEmptyResultSet) {     this.routeEmptyResultSet = routeEmptyResultSet. }
