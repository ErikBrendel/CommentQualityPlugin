commented;modifiers;parameterAmount;loc;comment;code
false;public;1;50;;public void process(Exchange exchange) throws Exception {     SqlSession session.     ExecutorType executorType = endpoint.getExecutorType().     if (executorType == null) {         session = endpoint.getSqlSessionFactory().openSession().     } else {         session = endpoint.getSqlSessionFactory().openSession(executorType).     }     try {         switch(endpoint.getStatementType()) {             case SelectOne:                 doSelectOne(exchange, session).                 break.             case SelectList:                 doSelectList(exchange, session).                 break.             case Insert:                 doInsert(exchange, session).                 break.             case InsertList:                 doInsertList(exchange, session).                 break.             case Update:                 doUpdate(exchange, session).                 break.             case UpdateList:                 doUpdateList(exchange, session).                 break.             case Delete:                 doDelete(exchange, session).                 break.             case DeleteList:                 doDeleteList(exchange, session).                 break.             default:                 throw new IllegalArgumentException("Unsupported statementType: " + endpoint.getStatementType()).         }         // flush the batch statements and commit the database connection         session.commit().     } catch (Exception e) {         // discard the pending batch statements and roll the database connection back         session.rollback().         throw e.     } finally {         // and finally close the session as we're done         session.close().     } }
false;private;2;13;;private void doSelectOne(Exchange exchange, SqlSession session) throws Exception {     Object result.     Object in = getInput(exchange).     if (in != null) {         LOG.trace("SelectOne: {} using statement: {}", in, statement).         result = session.selectOne(statement, in).     } else {         LOG.trace("SelectOne using statement: {}", statement).         result = session.selectOne(statement).     }     doProcessResult(exchange, result, session). }
false;private;2;13;;private void doSelectList(Exchange exchange, SqlSession session) throws Exception {     Object result.     Object in = getInput(exchange).     if (in != null) {         LOG.trace("SelectList: {} using statement: {}", in, statement).         result = session.selectList(statement, in).     } else {         LOG.trace("SelectList using statement: {}", statement).         result = session.selectList(statement).     }     doProcessResult(exchange, result, session). }
false;private;2;18;;private void doInsert(Exchange exchange, SqlSession session) throws Exception {     Object result.     Object in = getInput(exchange).     if (in != null) {         // lets handle arrays or collections of objects         Iterator<?> iter = ObjectHelper.createIterator(in).         while (iter.hasNext()) {             Object value = iter.next().             LOG.trace("Inserting: {} using statement: {}", value, statement).             result = session.insert(statement, value).             doProcessResult(exchange, result, session).         }     } else {         LOG.trace("Inserting using statement: {}", statement).         result = session.insert(statement).         doProcessResult(exchange, result, session).     } }
false;private;2;14;;private void doInsertList(Exchange exchange, SqlSession session) throws Exception {     Object result.     Object in = getInput(exchange).     if (in != null) {         // just pass in the body as Object and allow MyBatis to iterate using its own foreach statement         LOG.trace("Inserting: {} using statement: {}", in, statement).         result = session.insert(statement, in).         doProcessResult(exchange, result, session).     } else {         LOG.trace("Inserting using statement: {}", statement).         result = session.insert(statement).         doProcessResult(exchange, result, session).     } }
false;private;2;18;;private void doUpdate(Exchange exchange, SqlSession session) throws Exception {     Object result.     Object in = getInput(exchange).     if (in != null) {         // lets handle arrays or collections of objects         Iterator<?> iter = ObjectHelper.createIterator(in).         while (iter.hasNext()) {             Object value = iter.next().             LOG.trace("Updating: {} using statement: {}", value, statement).             result = session.update(statement, value).             doProcessResult(exchange, result, session).         }     } else {         LOG.trace("Updating using statement: {}", statement).         result = session.update(statement).         doProcessResult(exchange, result, session).     } }
false;private;2;14;;private void doUpdateList(Exchange exchange, SqlSession session) throws Exception {     Object result.     Object in = getInput(exchange).     if (in != null) {         // just pass in the body as Object and allow MyBatis to iterate using its own foreach statement         LOG.trace("Updating: {} using statement: {}", in, statement).         result = session.update(statement, in).         doProcessResult(exchange, result, session).     } else {         LOG.trace("Updating using statement: {}", statement).         result = session.update(statement).         doProcessResult(exchange, result, session).     } }
false;private;2;18;;private void doDelete(Exchange exchange, SqlSession session) throws Exception {     Object result.     Object in = getInput(exchange).     if (in != null) {         // lets handle arrays or collections of objects         Iterator<?> iter = ObjectHelper.createIterator(in).         while (iter.hasNext()) {             Object value = iter.next().             LOG.trace("Deleting: {} using statement: {}", value, statement).             result = session.delete(statement, value).             doProcessResult(exchange, result, session).         }     } else {         LOG.trace("Deleting using statement: {}", statement).         result = session.delete(statement).         doProcessResult(exchange, result, session).     } }
false;private;2;14;;private void doDeleteList(Exchange exchange, SqlSession session) throws Exception {     Object result.     Object in = getInput(exchange).     if (in != null) {         // just pass in the body as Object and allow MyBatis to iterate using its own foreach statement         LOG.trace("Deleting: {} using statement: {}", in, statement).         result = session.delete(statement, in).         doProcessResult(exchange, result, session).     } else {         LOG.trace("Deleting using statement: {}", statement).         result = session.delete(statement).         doProcessResult(exchange, result, session).     } }
false;private;3;50;;private void doProcessResult(Exchange exchange, Object result, SqlSession session) {     final String outputHeader = getEndpoint().getOutputHeader().     Message answer = exchange.getIn().     if (ExchangeHelper.isOutCapable(exchange)) {         answer = exchange.getOut().         // preserve headers         answer.getHeaders().putAll(exchange.getIn().getHeaders()).         if (outputHeader != null) {             // if we put the MyBatis result into a header we should preserve the body as well             answer.setBody(exchange.getIn().getBody()).         }     }     if (endpoint.getStatementType() == StatementType.SelectList || endpoint.getStatementType() == StatementType.SelectOne) {         // we should not set the body if its a stored procedure as the result is already in its OUT parameter         MappedStatement ms = session.getConfiguration().getMappedStatement(statement).         if (ms != null && ms.getStatementType() == org.apache.ibatis.mapping.StatementType.CALLABLE) {             if (result == null) {                 LOG.trace("Setting result as existing body as MyBatis statement type is Callable, and there was no result.").                 answer.setBody(exchange.getIn().getBody()).             } else {                 if (outputHeader != null) {                     // set the result as header for insert                     LOG.trace("Setting result as header [{}]: {}", outputHeader, result).                     answer.setHeader(outputHeader, result).                 } else {                     // set the result as body for insert                     LOG.trace("Setting result as body: {}", result).                     answer.setBody(result).                     answer.setHeader(MyBatisConstants.MYBATIS_RESULT, result).                 }             }         } else {             if (outputHeader != null) {                 LOG.trace("Setting result as header [{}]: {}", outputHeader, result).                 answer.setHeader(outputHeader, result).             } else {                 // set the result as body for insert                 LOG.trace("Setting result as body: {}", result).                 answer.setBody(result).                 answer.setHeader(MyBatisConstants.MYBATIS_RESULT, result).             }         }     } else {         final String headerName = (outputHeader != null) ? outputHeader : MyBatisConstants.MYBATIS_RESULT.         answer.setHeader(headerName, result).     }     answer.setHeader(MyBatisConstants.MYBATIS_STATEMENT_NAME, statement). }
false;public;0;4;;@Override public MyBatisEndpoint getEndpoint() {     return (MyBatisEndpoint) super.getEndpoint(). }
false;private;1;8;;private Object getInput(final Exchange exchange) {     final String inputHeader = getEndpoint().getInputHeader().     if (inputHeader != null) {         return exchange.getIn().getHeader(inputHeader).     } else {         return exchange.getIn().getBody().     } }
