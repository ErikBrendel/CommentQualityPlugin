commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public String get(Message message, String key) {     return message.getHeader(key, String.class). }
false;public;3;4;;@Override public void put(Message message, String key, String value) {     message.setHeader(key, value). }
false;public;3;6;;@Override public RoutePolicy createRoutePolicy(CamelContext camelContext, String routeId, NamedNode route) {     // ensure this zipkin tracer gets initialized when Camel starts     init(camelContext).     return new ZipkinRoutePolicy(). }
true;public;1;11;/**  * Registers this {@link ZipkinTracer} on the {@link CamelContext} if not  * already registered.  */ ;/**  * Registers this {@link ZipkinTracer} on the {@link CamelContext} if not  * already registered.  */ public void init(CamelContext camelContext) {     if (!camelContext.hasService(this)) {         try {             // start this service eager so we init before Camel is starting             // up             camelContext.addService(this, true, true).         } catch (Exception e) {             throw RuntimeCamelException.wrapRuntimeCamelException(e).         }     } }
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;1;3;;public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;0;4;;@ManagedAttribute(description = "The POST URL for zipkin's v2 api.") public String getEndpoint() {     return endpoint. }
true;public;1;3;/**  * Sets the POST URL for zipkin's  * <a href="http://zipkin.io/zipkin-api/#/">v2 api</a>, usually  * "http://zipkinhost:9411/api/v2/spans"  */ ;/**  * Sets the POST URL for zipkin's  * <a href="http://zipkin.io/zipkin-api/#/">v2 api</a>, usually  * "http://zipkinhost:9411/api/v2/spans"  */ public void setEndpoint(String endpoint) {     this.endpoint = endpoint. }
false;public;0;4;;@ManagedAttribute(description = "The hostname for the remote zipkin scribe collector.") public String getHostName() {     return hostName. }
true;public;1;3;/**  * Sets the hostname for the remote zipkin scribe collector.  */ ;/**  * Sets the hostname for the remote zipkin scribe collector.  */ public void setHostName(String hostName) {     this.hostName = hostName. }
false;public;0;4;;@ManagedAttribute(description = "The port number for the remote zipkin scribe collector.") public int getPort() {     return port. }
true;public;1;3;/**  * Sets the port number for the remote zipkin scribe collector.  */ ;/**  * Sets the port number for the remote zipkin scribe collector.  */ public void setPort(int port) {     this.port = port. }
false;public;0;4;;@ManagedAttribute(description = "Rates how many events should be traced by zipkin. The rate is expressed as a percentage (1.0f = 100%, 0.5f is 50%, 0.1f is 10%).") public float getRate() {     return rate. }
true;public;1;3;/**  * Configures a rate that decides how many events should be traced by  * zipkin. The rate is expressed as a percentage (1.0f = 100%, 0.5f is 50%,  * 0.1f is 10%).  *  * @param rate minimum sample rate is 0.0001, or 0.01% of traces  */ ;/**  * Configures a rate that decides how many events should be traced by  * zipkin. The rate is expressed as a percentage (1.0f = 100%, 0.5f is 50%,  * 0.1f is 10%).  *  * @param rate minimum sample rate is 0.0001, or 0.01% of traces  */ public void setRate(float rate) {     this.rate = rate. }
true;public;1;3;/**  * Sets the reporter used to send timing data (spans) to the zipkin server.  */ ;/**  * Sets the reporter used to send timing data (spans) to the zipkin server.  */ public void setSpanReporter(Reporter<zipkin2.Span> spanReporter) {     this.spanReporter = spanReporter. }
true;public;0;3;/**  * Returns the reporter used to send timing data (spans) to the zipkin  * server.  */ ;/**  * Returns the reporter used to send timing data (spans) to the zipkin  * server.  */ public Reporter<zipkin2.Span> getSpanReporter() {     return spanReporter. }
false;public;0;3;;public String getServiceName() {     return clientServiceMappings.get("*"). }
true;public;1;4;/**  * To use a global service name that matches all Camel events  */ ;/**  * To use a global service name that matches all Camel events  */ public void setServiceName(String serviceName) {     clientServiceMappings.put("*", serviceName).     serverServiceMappings.put("*", serviceName). }
false;public;0;3;;public Map<String, String> getClientServiceMappings() {     return clientServiceMappings. }
false;public;1;3;;public void setClientServiceMappings(Map<String, String> clientServiceMappings) {     this.clientServiceMappings = clientServiceMappings. }
true;public;2;3;/**  * Adds a client service mapping that matches Camel events to the given  * zipkin service name. See more details at the class javadoc.  *  * @param pattern the pattern such as route id, endpoint url  * @param serviceName the zipkin service name  */ ;/**  * Adds a client service mapping that matches Camel events to the given  * zipkin service name. See more details at the class javadoc.  *  * @param pattern the pattern such as route id, endpoint url  * @param serviceName the zipkin service name  */ public void addClientServiceMapping(String pattern, String serviceName) {     clientServiceMappings.put(pattern, serviceName). }
false;public;0;3;;public Map<String, String> getServerServiceMappings() {     return serverServiceMappings. }
false;public;1;3;;public void setServerServiceMappings(Map<String, String> serverServiceMappings) {     this.serverServiceMappings = serverServiceMappings. }
true;public;2;3;/**  * Adds a server service mapping that matches Camel events to the given  * zipkin service name. See more details at the class javadoc.  *  * @param pattern the pattern such as route id, endpoint url  * @param serviceName the zipkin service name  */ ;/**  * Adds a server service mapping that matches Camel events to the given  * zipkin service name. See more details at the class javadoc.  *  * @param pattern the pattern such as route id, endpoint url  * @param serviceName the zipkin service name  */ public void addServerServiceMapping(String pattern, String serviceName) {     serverServiceMappings.put(pattern, serviceName). }
false;public;0;3;;public Set<String> getExcludePatterns() {     return excludePatterns. }
false;public;1;3;;public void setExcludePatterns(Set<String> excludePatterns) {     this.excludePatterns = excludePatterns. }
true;public;1;3;/**  * Adds an exclude pattern that will disable tracing with zipkin for Camel  * messages that matches the pattern.  *  * @param pattern the pattern such as route id, endpoint url  */ ;/**  * Adds an exclude pattern that will disable tracing with zipkin for Camel  * messages that matches the pattern.  *  * @param pattern the pattern such as route id, endpoint url  */ public void addExcludePattern(String pattern) {     excludePatterns.add(pattern). }
false;public;0;4;;@ManagedAttribute(description = "Whether to include the Camel message body in the zipkin traces") public boolean isIncludeMessageBody() {     return includeMessageBody. }
true;public;1;4;/**  * Whether to include the Camel message body in the zipkin traces.  * <p/>  * This is not recommended for production usage, or when having big  * payloads. You can limit the size by configuring the <a href=  * "http://camel.apache.org/how-do-i-set-the-max-chars-when-debug-logging-messages-in-camel.html">max  * debug log size</a>.  * <p/>  * By default message bodies that are stream based are <b>not</b> included.  * You can use the option {@link #setIncludeMessageBodyStreams(boolean)} to  * turn that on.  */ ;/**  * Whether to include the Camel message body in the zipkin traces.  * <p/>  * This is not recommended for production usage, or when having big  * payloads. You can limit the size by configuring the <a href=  * "http://camel.apache.org/how-do-i-set-the-max-chars-when-debug-logging-messages-in-camel.html">max  * debug log size</a>.  * <p/>  * By default message bodies that are stream based are <b>not</b> included.  * You can use the option {@link #setIncludeMessageBodyStreams(boolean)} to  * turn that on.  */ @ManagedAttribute(description = "Whether to include the Camel message body in the zipkin traces") public void setIncludeMessageBody(boolean includeMessageBody) {     this.includeMessageBody = includeMessageBody. }
false;public;0;4;;@ManagedAttribute(description = "Whether to include stream based Camel message bodies in the zipkin traces") public boolean isIncludeMessageBodyStreams() {     return includeMessageBodyStreams. }
true;public;1;4;/**  * Whether to include message bodies that are stream based in the zipkin  * traces.  * <p/>  * This requires enabling  * <a href="http://camel.apache.org/stream-caching.html">stream caching</a>  * on the routes or globally on the CamelContext.  * <p/>  * This is not recommended for production usage, or when having big  * payloads. You can limit the size by configuring the <a href=  * "http://camel.apache.org/how-do-i-set-the-max-chars-when-debug-logging-messages-in-camel.html">max  * debug log size</a>.  */ ;/**  * Whether to include message bodies that are stream based in the zipkin  * traces.  * <p/>  * This requires enabling  * <a href="http://camel.apache.org/stream-caching.html">stream caching</a>  * on the routes or globally on the CamelContext.  * <p/>  * This is not recommended for production usage, or when having big  * payloads. You can limit the size by configuring the <a href=  * "http://camel.apache.org/how-do-i-set-the-max-chars-when-debug-logging-messages-in-camel.html">max  * debug log size</a>.  */ @ManagedAttribute(description = "Whether to include stream based Camel message bodies in the zipkin traces") public void setIncludeMessageBodyStreams(boolean includeMessageBodyStreams) {     this.includeMessageBodyStreams = includeMessageBodyStreams. }
false;protected;0;70;;@Override protected void doStart() throws Exception {     ObjectHelper.notNull(camelContext, "CamelContext", this).     camelContext.getManagementStrategy().addEventNotifier(eventNotifier).     if (!camelContext.getRoutePolicyFactories().contains(this)) {         camelContext.addRoutePolicyFactory(this).     }     if (spanReporter == null) {         if (endpoint != null) {             LOG.info("Configuring Zipkin URLConnectionSender using endpoint: {}", endpoint).             spanReporter = AsyncReporter.create(URLConnectionSender.create(endpoint)).         } else if (hostName != null && port > 0) {             LOG.info("Configuring Zipkin ScribeSpanCollector using host: {} and port: {}", hostName, port).             LibthriftSender sender = LibthriftSender.newBuilder().host(hostName).port(port).build().             spanReporter = AsyncReporter.create(sender).         } else {             // is there a zipkin service setup as ENV variable to auto             // register a span reporter             String host = new ServiceHostPropertiesFunction().apply(ZIPKIN_COLLECTOR_HTTP_SERVICE).             String port = new ServicePortPropertiesFunction().apply(ZIPKIN_COLLECTOR_HTTP_SERVICE).             if (ObjectHelper.isNotEmpty(host) && ObjectHelper.isNotEmpty(port)) {                 LOG.info("Auto-configuring Zipkin URLConnectionSender using host: {} and port: {}", host, port).                 int num = camelContext.getTypeConverter().mandatoryConvertTo(Integer.class, port).                 String implicitEndpoint = "http://" + host + ":" + num + "/api/v2/spans".                 spanReporter = AsyncReporter.create(URLConnectionSender.create(implicitEndpoint)).             } else {                 host = new ServiceHostPropertiesFunction().apply(ZIPKIN_COLLECTOR_THRIFT_SERVICE).                 port = new ServicePortPropertiesFunction().apply(ZIPKIN_COLLECTOR_THRIFT_SERVICE).                 if (ObjectHelper.isNotEmpty(host) && ObjectHelper.isNotEmpty(port)) {                     LOG.info("Auto-configuring Zipkin ScribeSpanCollector using host: {} and port: {}", host, port).                     int num = camelContext.getTypeConverter().mandatoryConvertTo(Integer.class, port).                     LibthriftSender sender = LibthriftSender.newBuilder().host(host).port(num).build().                     spanReporter = AsyncReporter.create(sender).                 }             }         }     }     if (spanReporter == null) {         // Try to lookup the span reporter from the registry if only one         // instance is present         Set<Reporter> reporters = camelContext.getRegistry().findByType(Reporter.class).         if (reporters.size() == 1) {             spanReporter = reporters.iterator().next().         }     }     ObjectHelper.notNull(spanReporter, "Reporter<zipkin2.Span>", this).     if (clientServiceMappings.isEmpty() && serverServiceMappings.isEmpty()) {         LOG.warn("No service name(s) has been mapped in clientServiceMappings or serverServiceMappings. Camel will fallback and use endpoint uris as service names.").         useFallbackServiceNames = true.     }     // create braves mapped per service name     for (Map.Entry<String, String> entry : clientServiceMappings.entrySet()) {         String pattern = entry.getKey().         String serviceName = entry.getValue().         createTracingForService(pattern, serviceName).     }     for (Map.Entry<String, String> entry : serverServiceMappings.entrySet()) {         String pattern = entry.getKey().         String serviceName = entry.getValue().         createTracingForService(pattern, serviceName).     }     ServiceHelper.startService(spanReporter, eventNotifier). }
false;protected;0;16;;@Override protected void doStop() throws Exception {     // stop event notifier     camelContext.getManagementStrategy().removeEventNotifier(eventNotifier).     ServiceHelper.stopService(eventNotifier).     // stop and close collector     ServiceHelper.stopAndShutdownService(spanReporter).     if (spanReporter instanceof Closeable) {         IOHelper.close((Closeable) spanReporter).     }     // clear braves     braves.clear().     // remove route policy     camelContext.getRoutePolicyFactories().remove(this). }
false;private;4;9;;private String getServiceName(Exchange exchange, Endpoint endpoint, boolean server, boolean client) {     if (client) {         return getServiceName(exchange, endpoint, clientServiceMappings).     } else if (server) {         return getServiceName(exchange, endpoint, serverServiceMappings).     } else {         return null.     } }
false;private;3;87;;private String getServiceName(Exchange exchange, Endpoint endpoint, Map<String, String> serviceMappings) {     String answer = null.     // endpoint takes precedence over route     if (endpoint != null) {         String url = endpoint.getEndpointUri().         if (url != null) {             // exclude patterns take precedence             for (String pattern : excludePatterns) {                 if (EndpointHelper.matchEndpoint(exchange.getContext(), url, pattern)) {                     return null.                 }             }             for (Map.Entry<String, String> entry : serviceMappings.entrySet()) {                 String pattern = entry.getKey().                 if (EndpointHelper.matchEndpoint(exchange.getContext(), url, pattern)) {                     answer = entry.getValue().                     break.                 }             }         }     }     // route     if (answer == null) {         String id = routeIdExpression().evaluate(exchange, String.class).         if (id != null) {             // exclude patterns take precedence             for (String pattern : excludePatterns) {                 if (PatternHelper.matchPattern(id, pattern)) {                     return null.                 }             }             for (Map.Entry<String, String> entry : serviceMappings.entrySet()) {                 String pattern = entry.getKey().                 if (PatternHelper.matchPattern(id, pattern)) {                     answer = entry.getValue().                     break.                 }             }         }     }     if (answer == null) {         String id = exchange.getFromRouteId().         if (id != null) {             // exclude patterns take precedence             for (String pattern : excludePatterns) {                 if (PatternHelper.matchPattern(id, pattern)) {                     return null.                 }             }             for (Map.Entry<String, String> entry : serviceMappings.entrySet()) {                 String pattern = entry.getKey().                 if (PatternHelper.matchPattern(id, pattern)) {                     answer = entry.getValue().                     break.                 }             }         }     }     if (answer == null && useFallbackServiceNames) {         String key = null.         if (endpoint != null) {             key = endpoint.getEndpointKey().         } else if (exchange.getFromEndpoint() != null) {             key = exchange.getFromEndpoint().getEndpointKey().         }         // exclude patterns take precedence         for (String pattern : excludePatterns) {             if (PatternHelper.matchPattern(key, pattern)) {                 return null.             }         }         String sanitizedKey = URISupport.sanitizeUri(key).         if (LOG.isTraceEnabled() && sanitizedKey != null) {             LOG.trace("Using serviceName: {} as fallback", sanitizedKey).         }         return sanitizedKey.     } else {         if (LOG.isTraceEnabled() && answer != null) {             LOG.trace("Using serviceName: {}", answer).         }         return answer.     } }
false;private;2;7;;private void createTracingForService(String pattern, String serviceName) {     Tracing brave = braves.get(pattern).     if (brave == null && !braves.containsKey(serviceName)) {         brave = newTracing(serviceName).         braves.put(serviceName, brave).     } }
false;private;1;10;;private Tracing newTracing(String serviceName) {     Tracing brave = null.     if (camelContext.isUseMDCLogging()) {         brave = Tracing.newBuilder().currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder().addScopeDecorator(MDCScopeDecorator.create()).build()).localServiceName(serviceName).sampler(Sampler.create(rate)).spanReporter(spanReporter).build().     } else {         brave = Tracing.newBuilder().localServiceName(serviceName).sampler(Sampler.create(rate)).spanReporter(spanReporter).build().     }     return brave. }
false;private;1;14;;private Tracing getTracing(String serviceName) {     Tracing brave = null.     if (serviceName != null) {         brave = braves.get(serviceName).         if (brave == null && useFallbackServiceNames) {             LOG.debug("Creating Tracing assigned to serviceName: {}", serviceName + " as fallback").             brave = newTracing(serviceName).             braves.put(serviceName, brave).         }     }     return brave. }
false;private;3;41;;private void clientRequest(Tracing brave, String serviceName, ExchangeSendingEvent event) {     // reuse existing span if we do multiple requests from the same     ZipkinState state = event.getExchange().getProperty(ZipkinState.KEY, ZipkinState.class).     if (state == null) {         state = new ZipkinState().         event.getExchange().setProperty(ZipkinState.KEY, state).     }     // if we started from a server span then lets reuse that when we call a     // downstream service     Span last = state.peekServerSpan().     Span span.     if (last != null) {         span = brave.tracer().newChild(last.context()).     } else {         span = brave.tracer().nextSpan().     }     span.kind(Span.Kind.CLIENT).start().     ZipkinClientRequestAdapter parser = new ZipkinClientRequestAdapter(this, event.getEndpoint()).     INJECTOR.inject(span.context(), event.getExchange().getIn()).     parser.onRequest(event.getExchange(), span.customizer()).     // store span after request     state.pushClientSpan(span).     TraceContext context = span.context().     String traceId = "" + context.traceIdString().     String spanId = "" + context.spanId().     String parentId = context.parentId() != null ? "" + context.parentId() : null.     if (camelContext.isUseMDCLogging()) {         MDC.put("traceId", traceId).         MDC.put("spanId", spanId).         MDC.put("parentId", parentId).     }     if (LOG.isDebugEnabled()) {         if (parentId != null) {             LOG.debug(String.format("clientRequest [service=%s, traceId=%20s, spanId=%20s, parentId=%20s]", serviceName, traceId, spanId, parentId)).         } else {             LOG.debug(String.format("clientRequest [service=%s, traceId=%20s, spanId=%20s]", serviceName, traceId, spanId)).         }     } }
false;private;3;30;;private void clientResponse(Tracing brave, String serviceName, ExchangeSentEvent event) {     Span span = null.     ZipkinState state = event.getExchange().getProperty(ZipkinState.KEY, ZipkinState.class).     if (state != null) {         // only process if it was a zipkin client event         span = state.popClientSpan().     }     if (span != null) {         ZipkinClientResponseAdaptor parser = new ZipkinClientResponseAdaptor(this, event.getEndpoint()).         parser.onResponse(event.getExchange(), span.customizer()).         span.finish().         TraceContext context = span.context().         String traceId = "" + context.traceIdString().         String spanId = "" + context.spanId().         String parentId = context.parentId() != null ? "" + context.parentId() : null.         if (camelContext.isUseMDCLogging()) {             MDC.put("traceId", traceId).             MDC.put("spanId", spanId).             MDC.put("parentId", parentId).         }         if (LOG.isDebugEnabled()) {             if (parentId != null) {                 LOG.debug(String.format("clientResponse[service=%s, traceId=%20s, spanId=%20s, parentId=%20s]", serviceName, traceId, spanId, parentId)).             } else {                 LOG.debug(String.format("clientResponse[service=%s, traceId=%20s, spanId=%20s]", serviceName, traceId, spanId)).             }         }     } }
false;private;3;40;;private Span serverRequest(Tracing brave, String serviceName, Exchange exchange) {     // reuse existing span if we do multiple requests from the same     ZipkinState state = exchange.getProperty(ZipkinState.KEY, ZipkinState.class).     if (state == null) {         state = new ZipkinState().         exchange.setProperty(ZipkinState.KEY, state).     }     Span span = null.     TraceContextOrSamplingFlags sampleFlag = EXTRACTOR.extract(exchange.getIn()).     if (ObjectHelper.isEmpty(sampleFlag)) {         span = brave.tracer().nextSpan().         INJECTOR.inject(span.context(), exchange.getIn()).     } else {         span = brave.tracer().nextSpan(sampleFlag).     }     span.kind(Span.Kind.SERVER).start().     ZipkinServerRequestAdapter parser = new ZipkinServerRequestAdapter(this, exchange).     parser.onRequest(exchange, span.customizer()).     // store span after request     state.pushServerSpan(span).     TraceContext context = span.context().     String traceId = "" + context.traceIdString().     String spanId = "" + context.spanId().     String parentId = context.parentId() != null ? "" + context.parentId() : null.     if (camelContext.isUseMDCLogging()) {         MDC.put("traceId", traceId).         MDC.put("spanId", spanId).         MDC.put("parentId", parentId).     }     if (LOG.isDebugEnabled()) {         if (parentId != null) {             LOG.debug(String.format("serverRequest [service=%s, traceId=%20s, spanId=%20s, parentId=%20s]", serviceName, traceId, spanId, parentId)).         } else {             LOG.debug(String.format("serverRequest [service=%s, traceId=%20s, spanId=%20s]", serviceName, traceId, spanId)).         }     }     return span. }
false;private;3;30;;private void serverResponse(Tracing brave, String serviceName, Exchange exchange) {     Span span = null.     ZipkinState state = exchange.getProperty(ZipkinState.KEY, ZipkinState.class).     if (state != null) {         // only process if it was a zipkin server event         span = state.popServerSpan().     }     if (span != null) {         ZipkinServerResponseAdapter parser = new ZipkinServerResponseAdapter(this, exchange).         parser.onResponse(exchange, span.customizer()).         span.finish().         TraceContext context = span.context().         String traceId = "" + context.traceIdString().         String spanId = "" + context.spanId().         String parentId = context.parentId() != null ? "" + context.parentId() : null.         if (camelContext.isUseMDCLogging()) {             MDC.put("traceId", traceId).             MDC.put("spanId", spanId).             MDC.put("parentId", parentId).         }         if (LOG.isDebugEnabled()) {             if (parentId != null) {                 LOG.debug(String.format("serverResponse[service=%s, traceId=%20s, spanId=%20s, parentId=%20s]", serviceName, traceId, spanId, parentId)).             } else {                 LOG.debug(String.format("serverResponse[service=%s, traceId=%20s, spanId=%20s]", serviceName, traceId, spanId)).             }         }     } }
false;public;1;23;;@Override public void notify(CamelEvent event) throws Exception {     // client events     if (event instanceof ExchangeSendingEvent) {         ExchangeSendingEvent ese = (ExchangeSendingEvent) event.         String serviceName = getServiceName(ese.getExchange(), ese.getEndpoint(), false, true).         Tracing brave = getTracing(serviceName).         if (brave != null) {             clientRequest(brave, serviceName, ese).         }     } else if (event instanceof ExchangeSentEvent) {         ExchangeSentEvent ese = (ExchangeSentEvent) event.         String serviceName = getServiceName(ese.getExchange(), ese.getEndpoint(), false, true).         Tracing brave = getTracing(serviceName).         if (brave != null) {             clientResponse(brave, serviceName, ese).         }     } }
false;public;1;13;;@Override public boolean isEnabled(CamelEvent event) {     switch(event.getType()) {         case ExchangeSending:         case ExchangeSent:         case ExchangeCreated:         case ExchangeCompleted:         case ExchangeFailed:             return true.         default:             return false.     } }
false;public;0;4;;@Override public String toString() {     return "ZipkinEventNotifier". }
false;public;2;13;;@Override public void onExchangeBegin(Route route, Exchange exchange) {     // use route policy to track events when Camel a Camel route     // begins/end the lifecycle of an Exchange     // these events corresponds to Zipkin server events     String serviceName = getServiceName(exchange, route.getEndpoint(), true, false).     Tracing brave = getTracing(serviceName).     if (brave != null) {         serverRequest(brave, serviceName, exchange).     } }
true;public;2;8;// exchange. ;// Report Server send after route has completed processing of the // exchange. @Override public void onExchangeDone(Route route, Exchange exchange) {     String serviceName = getServiceName(exchange, route.getEndpoint(), true, false).     Tracing brave = getTracing(serviceName).     if (brave != null) {         serverResponse(brave, serviceName, exchange).     } }
