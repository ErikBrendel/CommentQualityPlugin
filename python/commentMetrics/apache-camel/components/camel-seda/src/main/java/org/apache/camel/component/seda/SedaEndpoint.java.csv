commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public SedaComponent getComponent() {     return (SedaComponent) super.getComponent(). }
false;public;0;3;;public Producer createProducer() throws Exception {     return new SedaProducer(this, getWaitForTaskToComplete(), getTimeout(), isBlockWhenFull(), getOfferTimeout()). }
false;public;1;16;;public Consumer createConsumer(Processor processor) throws Exception {     if (getComponent() != null) {         // all consumers must match having the same multipleConsumers options         String key = getComponent().getQueueKey(getEndpointUri()).         QueueReference ref = getComponent().getQueueReference(key).         if (ref != null && ref.getMultipleConsumers() != isMultipleConsumers()) {             // there is already a multiple consumers, so make sure they matches             throw new IllegalArgumentException("Cannot use existing queue " + key + " as the existing queue multiple consumers " + ref.getMultipleConsumers() + " does not match given multiple consumers " + multipleConsumers).         }     }     Consumer answer = createNewConsumer(processor).     configureConsumer(answer).     return answer. }
false;protected;1;3;;protected SedaConsumer createNewConsumer(Processor processor) {     return new SedaConsumer(this, processor). }
false;public;0;6;;@Override public PollingConsumer createPollingConsumer() throws Exception {     SedaPollingConsumer answer = new SedaPollingConsumer(this).     configureConsumer(answer).     return answer. }
false;public,synchronized;0;24;;public synchronized BlockingQueue<Exchange> getQueue() {     if (queue == null) {         // can use the already existing queue referenced from the component         if (getComponent() != null) {             // use null to indicate default size (= use what the existing queue has been configured with)             Integer size = (getSize() == Integer.MAX_VALUE || getSize() == SedaConstants.QUEUE_SIZE) ? null : getSize().             QueueReference ref = getComponent().getOrCreateQueue(this, size, isMultipleConsumers(), queueFactory).             queue = ref.getQueue().             String key = getComponent().getQueueKey(getEndpointUri()).             log.info("Endpoint {} is using shared queue: {} with size: {}", this, key, ref.getSize() != null ? ref.getSize() : Integer.MAX_VALUE).             // and set the size we are using             if (ref.getSize() != null) {                 setSize(ref.getSize()).             }         } else {             // fallback and create queue (as this endpoint has no component)             queue = createQueue().             log.info("Endpoint {} is using queue: {} with size: {}", this, getEndpointUri(), getSize()).         }     }     return queue. }
false;protected;0;7;;protected BlockingQueue<Exchange> createQueue() {     if (size > 0) {         return queueFactory.create(size).     } else {         return queueFactory.create().     } }
true;public,synchronized;0;5;/**  * Get's the {@link QueueReference} for the this endpoint.  * @return the reference, or <tt>null</tt> if no queue reference exists.  */ ;/**  * Get's the {@link QueueReference} for the this endpoint.  * @return the reference, or <tt>null</tt> if no queue reference exists.  */ public synchronized QueueReference getQueueReference() {     String key = getComponent().getQueueKey(getEndpointUri()).     QueueReference ref = getComponent().getQueueReference(key).     return ref. }
false;protected,synchronized;0;8;;protected synchronized AsyncProcessor getConsumerMulticastProcessor() throws Exception {     if (!multicastStarted && consumerMulticastProcessor != null) {         // only start it on-demand to avoid starting it during stopping         ServiceHelper.startService(consumerMulticastProcessor).         multicastStarted = true.     }     return consumerMulticastProcessor. }
false;protected,synchronized;0;28;;protected synchronized void updateMulticastProcessor() throws Exception {     // only needed if we support multiple consumers     if (!isMultipleConsumersSupported()) {         return.     }     // stop old before we create a new     if (consumerMulticastProcessor != null) {         ServiceHelper.stopService(consumerMulticastProcessor).         consumerMulticastProcessor = null.     }     int size = getConsumers().size().     if (size >= 1) {         if (multicastExecutor == null) {             // create multicast executor as we need it when we have more than 1 processor             multicastExecutor = getCamelContext().getExecutorServiceManager().newDefaultThreadPool(this, URISupport.sanitizeUri(getEndpointUri()) + "(multicast)").         }         // create list of consumers to multicast to         List<Processor> processors = new ArrayList<>(size).         for (SedaConsumer consumer : getConsumers()) {             processors.add(consumer.getProcessor()).         }         // create multicast processor         multicastStarted = false.         consumerMulticastProcessor = getCamelContext().createMulticast(processors, multicastExecutor, false).     } }
true;public;1;4;/**  * Define the queue instance which will be used by the endpoint.  * <p/>  * This option is only for rare use-cases where you want to use a custom queue instance.  */ ;/**  * Define the queue instance which will be used by the endpoint.  * <p/>  * This option is only for rare use-cases where you want to use a custom queue instance.  */ public void setQueue(BlockingQueue<Exchange> queue) {     this.queue = queue.     this.size = queue.remainingCapacity(). }
false;public;0;4;;@ManagedAttribute(description = "Queue max capacity") public int getSize() {     return size. }
true;public;1;3;/**  * The maximum capacity of the SEDA queue (i.e., the number of messages it can hold).  * Will by default use the defaultSize set on the SEDA component.  */ ;/**  * The maximum capacity of the SEDA queue (i.e., the number of messages it can hold).  * Will by default use the defaultSize set on the SEDA component.  */ public void setSize(int size) {     this.size = size. }
false;public;0;4;;@ManagedAttribute(description = "Current queue size") public int getCurrentQueueSize() {     return queue.size(). }
true;public;1;3;/**  * Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted.  * By default, an exception will be thrown stating that the queue is full.  * By enabling this option, the calling thread will instead block and wait until the message can be accepted.  */ ;/**  * Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted.  * By default, an exception will be thrown stating that the queue is full.  * By enabling this option, the calling thread will instead block and wait until the message can be accepted.  */ public void setBlockWhenFull(boolean blockWhenFull) {     this.blockWhenFull = blockWhenFull. }
false;public;0;4;;@ManagedAttribute(description = "Whether the caller will block sending to a full queue") public boolean isBlockWhenFull() {     return blockWhenFull. }
true;public;1;3;/**  * Number of concurrent threads processing exchanges.  */ ;/**  * Number of concurrent threads processing exchanges.  */ public void setConcurrentConsumers(int concurrentConsumers) {     this.concurrentConsumers = concurrentConsumers. }
false;public;0;4;;@ManagedAttribute(description = "Number of concurrent consumers") public int getConcurrentConsumers() {     return concurrentConsumers. }
false;public;0;4;;@ManagedAttribute public boolean isLimitConcurrentConsumers() {     return limitConcurrentConsumers. }
true;public;1;3;/**  * Whether to limit the number of concurrentConsumers to the maximum of 500.  * By default, an exception will be thrown if an endpoint is configured with a greater number. You can disable that check by turning this option off.  */ ;/**  * Whether to limit the number of concurrentConsumers to the maximum of 500.  * By default, an exception will be thrown if an endpoint is configured with a greater number. You can disable that check by turning this option off.  */ public void setLimitConcurrentConsumers(boolean limitConcurrentConsumers) {     this.limitConcurrentConsumers = limitConcurrentConsumers. }
false;public;0;3;;public WaitForTaskToComplete getWaitForTaskToComplete() {     return waitForTaskToComplete. }
true;public;1;3;/**  * Option to specify whether the caller should wait for the async task to complete or not before continuing.  * The following three options are supported: Always, Never or IfReplyExpected.  * The first two values are self-explanatory.  * The last value, IfReplyExpected, will only wait if the message is Request Reply based.  * The default option is IfReplyExpected.  */ ;/**  * Option to specify whether the caller should wait for the async task to complete or not before continuing.  * The following three options are supported: Always, Never or IfReplyExpected.  * The first two values are self-explanatory.  * The last value, IfReplyExpected, will only wait if the message is Request Reply based.  * The default option is IfReplyExpected.  */ public void setWaitForTaskToComplete(WaitForTaskToComplete waitForTaskToComplete) {     this.waitForTaskToComplete = waitForTaskToComplete. }
false;public;0;4;;@ManagedAttribute public long getTimeout() {     return timeout. }
true;public;1;3;/**  * Timeout (in milliseconds) before a SEDA producer will stop waiting for an asynchronous task to complete.  * You can disable timeout by using 0 or a negative value.  */ ;/**  * Timeout (in milliseconds) before a SEDA producer will stop waiting for an asynchronous task to complete.  * You can disable timeout by using 0 or a negative value.  */ public void setTimeout(long timeout) {     this.timeout = timeout. }
false;public;0;4;;@ManagedAttribute public long getOfferTimeout() {     return offerTimeout. }
true;public;1;3;/**  * offerTimeout (in milliseconds)  can be added to the block case when queue is full.  * You can disable timeout by using 0 or a negative value.  */ ;/**  * offerTimeout (in milliseconds)  can be added to the block case when queue is full.  * You can disable timeout by using 0 or a negative value.  */ public void setOfferTimeout(long offerTimeout) {     this.offerTimeout = offerTimeout. }
false;public;0;4;;@ManagedAttribute public boolean isFailIfNoConsumers() {     return failIfNoConsumers. }
true;public;1;3;/**  * Whether the producer should fail by throwing an exception, when sending to a queue with no active consumers.  * <p/>  * Only one of the options <tt>discardIfNoConsumers</tt> and <tt>failIfNoConsumers</tt> can be enabled at the same time.  */ ;/**  * Whether the producer should fail by throwing an exception, when sending to a queue with no active consumers.  * <p/>  * Only one of the options <tt>discardIfNoConsumers</tt> and <tt>failIfNoConsumers</tt> can be enabled at the same time.  */ public void setFailIfNoConsumers(boolean failIfNoConsumers) {     this.failIfNoConsumers = failIfNoConsumers. }
false;public;0;4;;@ManagedAttribute public boolean isDiscardIfNoConsumers() {     return discardIfNoConsumers. }
true;public;1;3;/**  * Whether the producer should discard the message (do not add the message to the queue), when sending to a queue with no active consumers.  * <p/>  * Only one of the options <tt>discardIfNoConsumers</tt> and <tt>failIfNoConsumers</tt> can be enabled at the same time.  */ ;/**  * Whether the producer should discard the message (do not add the message to the queue), when sending to a queue with no active consumers.  * <p/>  * Only one of the options <tt>discardIfNoConsumers</tt> and <tt>failIfNoConsumers</tt> can be enabled at the same time.  */ public void setDiscardIfNoConsumers(boolean discardIfNoConsumers) {     this.discardIfNoConsumers = discardIfNoConsumers. }
false;public;0;4;;@ManagedAttribute public boolean isMultipleConsumers() {     return multipleConsumers. }
true;public;1;3;/**  * Specifies whether multiple consumers are allowed. If enabled, you can use SEDA for Publish-Subscribe messaging.  * That is, you can send a message to the SEDA queue and have each consumer receive a copy of the message.  * When enabled, this option should be specified on every consumer endpoint.  */ ;/**  * Specifies whether multiple consumers are allowed. If enabled, you can use SEDA for Publish-Subscribe messaging.  * That is, you can send a message to the SEDA queue and have each consumer receive a copy of the message.  * When enabled, this option should be specified on every consumer endpoint.  */ public void setMultipleConsumers(boolean multipleConsumers) {     this.multipleConsumers = multipleConsumers. }
false;public;0;4;;@ManagedAttribute public int getPollTimeout() {     return pollTimeout. }
true;public;1;3;/**  * The timeout used when polling. When a timeout occurs, the consumer can check whether it is allowed to continue running.  * Setting a lower value allows the consumer to react more quickly upon shutdown.  */ ;/**  * The timeout used when polling. When a timeout occurs, the consumer can check whether it is allowed to continue running.  * Setting a lower value allows the consumer to react more quickly upon shutdown.  */ public void setPollTimeout(int pollTimeout) {     this.pollTimeout = pollTimeout. }
false;public;0;4;;@ManagedAttribute public boolean isPurgeWhenStopping() {     return purgeWhenStopping. }
true;public;1;3;/**  * Whether to purge the task queue when stopping the consumer/route.  * This allows to stop faster, as any pending messages on the queue is discarded.  */ ;/**  * Whether to purge the task queue when stopping the consumer/route.  * This allows to stop faster, as any pending messages on the queue is discarded.  */ public void setPurgeWhenStopping(boolean purgeWhenStopping) {     this.purgeWhenStopping = purgeWhenStopping. }
false;public;0;3;;public boolean isSingleton() {     return true. }
true;public;0;3;/**  * Returns the current pending exchanges  */ ;/**  * Returns the current pending exchanges  */ public List<Exchange> getExchanges() {     return new ArrayList<>(getQueue()). }
false;public;0;4;;@ManagedAttribute public boolean isMultipleConsumersSupported() {     return isMultipleConsumers(). }
true;public;0;5;/**  * Purges the queue  */ ;/**  * Purges the queue  */ @ManagedOperation(description = "Purges the seda queue") public void purgeQueue() {     log.debug("Purging queue with {} exchanges", queue.size()).     queue.clear(). }
true;public;0;3;/**  * Returns the current active consumers on this endpoint  */ ;/**  * Returns the current active consumers on this endpoint  */ public Set<SedaConsumer> getConsumers() {     return consumers. }
true;public;0;3;/**  * Returns the current active producers on this endpoint  */ ;/**  * Returns the current active producers on this endpoint  */ public Set<SedaProducer> getProducers() {     return new HashSet<>(producers). }
false;;1;3;;void onStarted(SedaProducer producer) {     producers.add(producer). }
false;;1;3;;void onStopped(SedaProducer producer) {     producers.remove(producer). }
false;;1;6;;void onStarted(SedaConsumer consumer) throws Exception {     consumers.add(consumer).     if (isMultipleConsumers()) {         updateMulticastProcessor().     } }
false;;1;6;;void onStopped(SedaConsumer consumer) throws Exception {     consumers.remove(consumer).     if (isMultipleConsumers()) {         updateMulticastProcessor().     } }
false;public;0;3;;public boolean hasConsumers() {     return this.consumers.size() > 0. }
false;protected;0;14;;@Override protected void doStart() throws Exception {     super.doStart().     // force creating queue when starting     if (queue == null) {         queue = getQueue().     }     // special for unit testing where we can set a system property to make seda poll faster     // and therefore also react faster upon shutdown, which makes overall testing faster of the Camel project     String override = System.getProperty("CamelSedaPollTimeout", "" + getPollTimeout()).     setPollTimeout(Integer.valueOf(override)). }
false;public;0;8;;@Override public void stop() throws Exception {     if (getConsumers().isEmpty()) {         super.stop().     } else {         log.debug("There is still active consumers.").     } }
false;public;0;18;;@Override public void shutdown() throws Exception {     if (isShutdown()) {         log.trace("Service already shut down").         return.     }     // notify component we are shutting down this endpoint     if (getComponent() != null) {         getComponent().onShutdownEndpoint(this).     }     if (getConsumers().isEmpty()) {         super.shutdown().     } else {         log.debug("There is still active consumers.").     } }
false;protected;0;11;;@Override protected void doShutdown() throws Exception {     // shutdown thread pool if it was in use     if (multicastExecutor != null) {         getCamelContext().getExecutorServiceManager().shutdownNow(multicastExecutor).         multicastExecutor = null.     }     // clear queue, as we are shutdown, so if re-created then the queue must be updated     queue = null. }
