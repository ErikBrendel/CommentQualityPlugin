commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "SedaConsumer[" + endpoint + "]". }
false;public;0;3;;public Endpoint getEndpoint() {     return endpoint. }
false;public;0;3;;public ExceptionHandler getExceptionHandler() {     return exceptionHandler. }
false;public;1;3;;public void setExceptionHandler(ExceptionHandler exceptionHandler) {     this.exceptionHandler = exceptionHandler. }
false;public;0;3;;public Processor getProcessor() {     return processor. }
false;public;1;5;;public boolean deferShutdown(ShutdownRunningTask shutdownRunningTask) {     // depend on this consumer to run, so it can complete its exchanges     return true. }
false;public;0;8;;public int getPendingExchangesSize() {     // or return how many exchanges are still on the queue     if (endpoint.isPurgeWhenStopping()) {         endpoint.purgeQueue().     }     return endpoint.getQueue().size(). }
false;public;2;24;;@Override public void prepareShutdown(boolean suspendOnly, boolean forced) {     // this logic is only when we stop or shutdown the consumer     if (suspendOnly) {         log.debug("Skip preparing to shutdown as consumer is being suspended").         return.     }     // signal we want to shutdown     shutdownPending = true.     forceShutdown = forced.     if (latch != null) {         log.debug("Preparing to shutdown, waiting for {} consumer threads to complete.", latch.getCount()).         // wait for all threads to end         try {             latch.await().         } catch (InterruptedException e) {         // ignore         }     } }
false;public;0;14;;@Override public boolean isRunAllowed() {     // if we force shutdown then do not allow running anymore     if (forceShutdown) {         return false.     }     if (isSuspending() || isSuspended()) {         // keep the thread task running         return true.     }     return super.isRunAllowed(). }
false;public;0;10;;public void run() {     taskCount.incrementAndGet().     try {         doRun().     } finally {         taskCount.decrementAndGet().         latch.countDown().         log.debug("Ending this polling consumer thread, there are still {} consumer threads left.", latch.getCount()).     } }
false;protected;0;79;;protected void doRun() {     BlockingQueue<Exchange> queue = endpoint.getQueue().     // loop while we are allowed, or if we are stopping loop until the queue is empty     while (queue != null && isRunAllowed()) {         // do not poll during CamelContext is starting, as we should only poll when CamelContext is fully started         if (getEndpoint().getCamelContext().getStatus().isStarting()) {             log.trace("CamelContext is starting so skip polling").             try {                 // sleep at most 1 sec                 Thread.sleep(Math.min(pollTimeout, 1000)).             } catch (InterruptedException e) {                 log.debug("Sleep interrupted, are we stopping? {}", isStopping() || isStopped()).             }             continue.         }         // do not poll if we are suspended or starting again after resuming         if (isSuspending() || isSuspended() || isStarting()) {             if (shutdownPending && queue.isEmpty()) {                 log.trace("Consumer is suspended and shutdown is pending, so this consumer thread is breaking out because the task queue is empty.").                 // we want to shutdown so break out if there queue is empty                 break.             } else {                 log.trace("Consumer is suspended so skip polling").                 try {                     // sleep at most 1 sec                     Thread.sleep(Math.min(pollTimeout, 1000)).                 } catch (InterruptedException e) {                     log.debug("Sleep interrupted, are we stopping? {}", isStopping() || isStopped()).                 }                 continue.             }         }         Exchange exchange = null.         try {             // use the end user configured poll timeout             exchange = queue.poll(pollTimeout, TimeUnit.MILLISECONDS).             if (log.isTraceEnabled()) {                 log.trace("Polled queue {} with timeout {} ms. -> {}", ObjectHelper.getIdentityHashCode(queue), pollTimeout, exchange).             }             if (exchange != null) {                 try {                     // send a new copied exchange with new camel context                     Exchange newExchange = prepareExchange(exchange).                     // process the exchange                     sendToConsumers(newExchange).                     // copy the message back                     if (newExchange.hasOut()) {                         exchange.setOut(newExchange.getOut().copy()).                     } else {                         exchange.setIn(newExchange.getIn()).                     }                     // log exception if an exception occurred and was not handled                     if (newExchange.getException() != null) {                         exchange.setException(newExchange.getException()).                         getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException()).                     }                 } catch (Exception e) {                     getExceptionHandler().handleException("Error processing exchange", exchange, e).                 }             } else if (shutdownPending && queue.isEmpty()) {                 log.trace("Shutdown is pending, so this consumer thread is breaking out because the task queue is empty.").                 // we want to shutdown so break out if there queue is empty                 break.             }         } catch (InterruptedException e) {             log.debug("Sleep interrupted, are we stopping? {}", isStopping() || isStopped()).             continue.         } catch (Throwable e) {             if (exchange != null) {                 getExceptionHandler().handleException("Error processing exchange", exchange, e).             } else {                 getExceptionHandler().handleException(e).             }         }     } }
true;protected;1;7;/**  * Strategy to prepare exchange for being processed by this consumer  *  * @param exchange the exchange  * @return the exchange to process by this consumer.  */ ;/**  * Strategy to prepare exchange for being processed by this consumer  *  * @param exchange the exchange  * @return the exchange to process by this consumer.  */ protected Exchange prepareExchange(Exchange exchange) {     // send a new copied exchange with new camel context     Exchange newExchange = ExchangeHelper.copyExchangeAndSetCamelContext(exchange, endpoint.getCamelContext()).     // set the from endpoint     newExchange.setFromEndpoint(endpoint).     return newExchange. }
true;protected;1;31;/**  * Send the given {@link Exchange} to the consumer(s).  * <p/>  * If multiple consumers then they will each receive a copy of the Exchange.  * A multicast processor will send the exchange in parallel to the multiple consumers.  * <p/>  * If there is only a single consumer then its dispatched directly to it using same thread.  *  * @param exchange the exchange  * @throws Exception can be thrown if processing of the exchange failed  */ ;/**  * Send the given {@link Exchange} to the consumer(s).  * <p/>  * If multiple consumers then they will each receive a copy of the Exchange.  * A multicast processor will send the exchange in parallel to the multiple consumers.  * <p/>  * If there is only a single consumer then its dispatched directly to it using same thread.  *  * @param exchange the exchange  * @throws Exception can be thrown if processing of the exchange failed  */ protected void sendToConsumers(final Exchange exchange) throws Exception {     // validate multiple consumers has been enabled     int size = endpoint.getConsumers().size().     if (size > 1 && !endpoint.isMultipleConsumersSupported()) {         throw new IllegalStateException("Multiple consumers for the same endpoint is not allowed: " + endpoint).     }     // if there are multiple consumers then multicast to them     if (endpoint.isMultipleConsumersSupported()) {         if (log.isTraceEnabled()) {             log.trace("Multicasting to {} consumers for Exchange: {}", size, exchange).         }         // handover completions, as we need to done this when the multicast is done         final List<Synchronization> completions = exchange.handoverCompletions().         // use a multicast processor to process it         AsyncProcessor mp = endpoint.getConsumerMulticastProcessor().         ObjectHelper.notNull(mp, "ConsumerMulticastProcessor", this).         // and use the asynchronous routing engine to support it         mp.process(exchange, doneSync -> {             // done the uow on the completions             UnitOfWorkHelper.doneSynchronizations(exchange, completions, log).         }).     } else {         // use the regular processor and use the asynchronous routing engine to support it         processor.process(exchange, EmptyAsyncCallback.get()).     } }
false;protected;0;8;;protected void doStart() throws Exception {     latch = new CountDownLatch(endpoint.getConcurrentConsumers()).     shutdownPending = false.     forceShutdown = false.     setupTasks().     endpoint.onStarted(this). }
false;protected;0;4;;@Override protected void doSuspend() throws Exception {     endpoint.onStopped(this). }
false;protected;0;4;;@Override protected void doResume() throws Exception {     endpoint.onStarted(this). }
false;protected;0;10;;protected void doStop() throws Exception {     // ensure queue is purged if we stop the consumer     if (endpoint.isPurgeWhenStopping()) {         endpoint.purgeQueue().     }     endpoint.onStopped(this).     shutdownExecutor(). }
false;protected;0;4;;@Override protected void doShutdown() throws Exception {     shutdownExecutor(). }
false;private;0;6;;private void shutdownExecutor() {     if (executor != null) {         endpoint.getCamelContext().getExecutorServiceManager().shutdownNow(executor).         executor = null.     } }
true;private;0;15;/**  * Setup the thread pool and ensures tasks gets executed (if needed)  */ ;/**  * Setup the thread pool and ensures tasks gets executed (if needed)  */ private void setupTasks() {     int poolSize = endpoint.getConcurrentConsumers().     // create thread pool if needed     if (executor == null) {         executor = endpoint.getCamelContext().getExecutorServiceManager().newFixedThreadPool(this, endpoint.getEndpointUri(), poolSize).     }     // submit needed number of tasks     int tasks = poolSize - taskCount.get().     log.debug("Creating {} consumer tasks with poll timeout {} ms.", tasks, pollTimeout).     for (int i = 0. i < tasks. i++) {         executor.execute(this).     } }
