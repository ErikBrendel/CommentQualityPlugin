# id;timestamp;commentText;codeText;commentWords;codeWords
SedaConsumer -> private void setupTasks();1547836605;Setup the thread pool and ensures tasks gets executed (if needed);private void setupTasks() {_        int poolSize = endpoint.getConcurrentConsumers()___        _        if (executor == null) {_            executor = endpoint.getCamelContext().getExecutorServiceManager().newFixedThreadPool(this, endpoint.getEndpointUri(), poolSize)__        }__        _        int tasks = poolSize - taskCount.get()__        log.debug("Creating {} consumer tasks with poll timeout {} ms.", tasks, pollTimeout)__        for (int i = 0_ i < tasks_ i++) {_            executor.execute(this)__        }_    };setup,the,thread,pool,and,ensures,tasks,gets,executed,if,needed;private,void,setup,tasks,int,pool,size,endpoint,get,concurrent,consumers,if,executor,null,executor,endpoint,get,camel,context,get,executor,service,manager,new,fixed,thread,pool,this,endpoint,get,endpoint,uri,pool,size,int,tasks,pool,size,task,count,get,log,debug,creating,consumer,tasks,with,poll,timeout,ms,tasks,poll,timeout,for,int,i,0,i,tasks,i,executor,execute,this
SedaConsumer -> private void setupTasks();1548175645;Setup the thread pool and ensures tasks gets executed (if needed);private void setupTasks() {_        int poolSize = endpoint.getConcurrentConsumers()___        _        if (executor == null) {_            executor = endpoint.getCamelContext().getExecutorServiceManager().newFixedThreadPool(this, endpoint.getEndpointUri(), poolSize)__        }__        _        int tasks = poolSize - taskCount.get()__        log.debug("Creating {} consumer tasks with poll timeout {} ms.", tasks, pollTimeout)__        for (int i = 0_ i < tasks_ i++) {_            executor.execute(this)__        }_    };setup,the,thread,pool,and,ensures,tasks,gets,executed,if,needed;private,void,setup,tasks,int,pool,size,endpoint,get,concurrent,consumers,if,executor,null,executor,endpoint,get,camel,context,get,executor,service,manager,new,fixed,thread,pool,this,endpoint,get,endpoint,uri,pool,size,int,tasks,pool,size,task,count,get,log,debug,creating,consumer,tasks,with,poll,timeout,ms,tasks,poll,timeout,for,int,i,0,i,tasks,i,executor,execute,this
SedaConsumer -> private void setupTasks();1548407051;Setup the thread pool and ensures tasks gets executed (if needed);private void setupTasks() {_        int poolSize = endpoint.getConcurrentConsumers()___        _        if (executor == null) {_            executor = endpoint.getCamelContext().getExecutorServiceManager().newFixedThreadPool(this, endpoint.getEndpointUri(), poolSize)__        }__        _        int tasks = poolSize - taskCount.get()__        log.debug("Creating {} consumer tasks with poll timeout {} ms.", tasks, pollTimeout)__        for (int i = 0_ i < tasks_ i++) {_            executor.execute(this)__        }_    };setup,the,thread,pool,and,ensures,tasks,gets,executed,if,needed;private,void,setup,tasks,int,pool,size,endpoint,get,concurrent,consumers,if,executor,null,executor,endpoint,get,camel,context,get,executor,service,manager,new,fixed,thread,pool,this,endpoint,get,endpoint,uri,pool,size,int,tasks,pool,size,task,count,get,log,debug,creating,consumer,tasks,with,poll,timeout,ms,tasks,poll,timeout,for,int,i,0,i,tasks,i,executor,execute,this
SedaConsumer -> protected Exchange prepareExchange(Exchange exchange);1547836605;Strategy to prepare exchange for being processed by this consumer__@param exchange the exchange_@return the exchange to process by this consumer.;protected Exchange prepareExchange(Exchange exchange) {_        _        Exchange newExchange = ExchangeHelper.copyExchangeAndSetCamelContext(exchange, endpoint.getCamelContext())__        _        newExchange.setFromEndpoint(endpoint)__        return newExchange__    };strategy,to,prepare,exchange,for,being,processed,by,this,consumer,param,exchange,the,exchange,return,the,exchange,to,process,by,this,consumer;protected,exchange,prepare,exchange,exchange,exchange,exchange,new,exchange,exchange,helper,copy,exchange,and,set,camel,context,exchange,endpoint,get,camel,context,new,exchange,set,from,endpoint,endpoint,return,new,exchange
SedaConsumer -> protected Exchange prepareExchange(Exchange exchange);1548175645;Strategy to prepare exchange for being processed by this consumer__@param exchange the exchange_@return the exchange to process by this consumer.;protected Exchange prepareExchange(Exchange exchange) {_        _        Exchange newExchange = ExchangeHelper.copyExchangeAndSetCamelContext(exchange, endpoint.getCamelContext())__        _        newExchange.setFromEndpoint(endpoint)__        return newExchange__    };strategy,to,prepare,exchange,for,being,processed,by,this,consumer,param,exchange,the,exchange,return,the,exchange,to,process,by,this,consumer;protected,exchange,prepare,exchange,exchange,exchange,exchange,new,exchange,exchange,helper,copy,exchange,and,set,camel,context,exchange,endpoint,get,camel,context,new,exchange,set,from,endpoint,endpoint,return,new,exchange
SedaConsumer -> protected Exchange prepareExchange(Exchange exchange);1548407051;Strategy to prepare exchange for being processed by this consumer__@param exchange the exchange_@return the exchange to process by this consumer.;protected Exchange prepareExchange(Exchange exchange) {_        _        Exchange newExchange = ExchangeHelper.copyExchangeAndSetCamelContext(exchange, endpoint.getCamelContext())__        _        newExchange.setFromEndpoint(endpoint)__        return newExchange__    };strategy,to,prepare,exchange,for,being,processed,by,this,consumer,param,exchange,the,exchange,return,the,exchange,to,process,by,this,consumer;protected,exchange,prepare,exchange,exchange,exchange,exchange,new,exchange,exchange,helper,copy,exchange,and,set,camel,context,exchange,endpoint,get,camel,context,new,exchange,set,from,endpoint,endpoint,return,new,exchange
SedaConsumer -> protected void sendToConsumers(final Exchange exchange) throws Exception;1547836605;Send the given {@link Exchange} to the consumer(s)._<p/>_If multiple consumers then they will each receive a copy of the Exchange._A multicast processor will send the exchange in parallel to the multiple consumers._<p/>_If there is only a single consumer then its dispatched directly to it using same thread.__@param exchange the exchange_@throws Exception can be thrown if processing of the exchange failed;protected void sendToConsumers(final Exchange exchange) throws Exception {_        _        int size = endpoint.getConsumers().size()__        if (size > 1 && !endpoint.isMultipleConsumersSupported()) {_            throw new IllegalStateException("Multiple consumers for the same endpoint is not allowed: " + endpoint)__        }__        _        if (endpoint.isMultipleConsumersSupported()) {__            if (log.isTraceEnabled()) {_                log.trace("Multicasting to {} consumers for Exchange: {}", size, exchange)__            }__            _            final List<Synchronization> completions = exchange.handoverCompletions()___            _            AsyncProcessor mp = endpoint.getConsumerMulticastProcessor()__            ObjectHelper.notNull(mp, "ConsumerMulticastProcessor", this)___            _            mp.process(exchange, doneSync -> {_                _                UnitOfWorkHelper.doneSynchronizations(exchange, completions, log)__            })__        } else {_            _            processor.process(exchange, EmptyAsyncCallback.get())__        }_    };send,the,given,link,exchange,to,the,consumer,s,p,if,multiple,consumers,then,they,will,each,receive,a,copy,of,the,exchange,a,multicast,processor,will,send,the,exchange,in,parallel,to,the,multiple,consumers,p,if,there,is,only,a,single,consumer,then,its,dispatched,directly,to,it,using,same,thread,param,exchange,the,exchange,throws,exception,can,be,thrown,if,processing,of,the,exchange,failed;protected,void,send,to,consumers,final,exchange,exchange,throws,exception,int,size,endpoint,get,consumers,size,if,size,1,endpoint,is,multiple,consumers,supported,throw,new,illegal,state,exception,multiple,consumers,for,the,same,endpoint,is,not,allowed,endpoint,if,endpoint,is,multiple,consumers,supported,if,log,is,trace,enabled,log,trace,multicasting,to,consumers,for,exchange,size,exchange,final,list,synchronization,completions,exchange,handover,completions,async,processor,mp,endpoint,get,consumer,multicast,processor,object,helper,not,null,mp,consumer,multicast,processor,this,mp,process,exchange,done,sync,unit,of,work,helper,done,synchronizations,exchange,completions,log,else,processor,process,exchange,empty,async,callback,get
SedaConsumer -> protected void sendToConsumers(final Exchange exchange) throws Exception;1548175645;Send the given {@link Exchange} to the consumer(s)._<p/>_If multiple consumers then they will each receive a copy of the Exchange._A multicast processor will send the exchange in parallel to the multiple consumers._<p/>_If there is only a single consumer then its dispatched directly to it using same thread.__@param exchange the exchange_@throws Exception can be thrown if processing of the exchange failed;protected void sendToConsumers(final Exchange exchange) throws Exception {_        _        int size = endpoint.getConsumers().size()__        if (size > 1 && !endpoint.isMultipleConsumersSupported()) {_            throw new IllegalStateException("Multiple consumers for the same endpoint is not allowed: " + endpoint)__        }__        _        if (endpoint.isMultipleConsumersSupported()) {__            if (log.isTraceEnabled()) {_                log.trace("Multicasting to {} consumers for Exchange: {}", size, exchange)__            }__            _            final List<Synchronization> completions = exchange.handoverCompletions()___            _            AsyncProcessor mp = endpoint.getConsumerMulticastProcessor()__            ObjectHelper.notNull(mp, "ConsumerMulticastProcessor", this)___            _            mp.process(exchange, doneSync -> {_                _                UnitOfWorkHelper.doneSynchronizations(exchange, completions, log)__            })__        } else {_            _            processor.process(exchange, EmptyAsyncCallback.get())__        }_    };send,the,given,link,exchange,to,the,consumer,s,p,if,multiple,consumers,then,they,will,each,receive,a,copy,of,the,exchange,a,multicast,processor,will,send,the,exchange,in,parallel,to,the,multiple,consumers,p,if,there,is,only,a,single,consumer,then,its,dispatched,directly,to,it,using,same,thread,param,exchange,the,exchange,throws,exception,can,be,thrown,if,processing,of,the,exchange,failed;protected,void,send,to,consumers,final,exchange,exchange,throws,exception,int,size,endpoint,get,consumers,size,if,size,1,endpoint,is,multiple,consumers,supported,throw,new,illegal,state,exception,multiple,consumers,for,the,same,endpoint,is,not,allowed,endpoint,if,endpoint,is,multiple,consumers,supported,if,log,is,trace,enabled,log,trace,multicasting,to,consumers,for,exchange,size,exchange,final,list,synchronization,completions,exchange,handover,completions,async,processor,mp,endpoint,get,consumer,multicast,processor,object,helper,not,null,mp,consumer,multicast,processor,this,mp,process,exchange,done,sync,unit,of,work,helper,done,synchronizations,exchange,completions,log,else,processor,process,exchange,empty,async,callback,get
SedaConsumer -> protected void sendToConsumers(final Exchange exchange) throws Exception;1548407051;Send the given {@link Exchange} to the consumer(s)._<p/>_If multiple consumers then they will each receive a copy of the Exchange._A multicast processor will send the exchange in parallel to the multiple consumers._<p/>_If there is only a single consumer then its dispatched directly to it using same thread.__@param exchange the exchange_@throws Exception can be thrown if processing of the exchange failed;protected void sendToConsumers(final Exchange exchange) throws Exception {_        _        int size = endpoint.getConsumers().size()__        if (size > 1 && !endpoint.isMultipleConsumersSupported()) {_            throw new IllegalStateException("Multiple consumers for the same endpoint is not allowed: " + endpoint)__        }__        _        if (endpoint.isMultipleConsumersSupported()) {__            if (log.isTraceEnabled()) {_                log.trace("Multicasting to {} consumers for Exchange: {}", size, exchange)__            }__            _            final List<Synchronization> completions = exchange.handoverCompletions()___            _            AsyncProcessor mp = endpoint.getConsumerMulticastProcessor()__            ObjectHelper.notNull(mp, "ConsumerMulticastProcessor", this)___            _            mp.process(exchange, doneSync -> {_                _                UnitOfWorkHelper.doneSynchronizations(exchange, completions, log)__            })__        } else {_            _            processor.process(exchange, EmptyAsyncCallback.get())__        }_    };send,the,given,link,exchange,to,the,consumer,s,p,if,multiple,consumers,then,they,will,each,receive,a,copy,of,the,exchange,a,multicast,processor,will,send,the,exchange,in,parallel,to,the,multiple,consumers,p,if,there,is,only,a,single,consumer,then,its,dispatched,directly,to,it,using,same,thread,param,exchange,the,exchange,throws,exception,can,be,thrown,if,processing,of,the,exchange,failed;protected,void,send,to,consumers,final,exchange,exchange,throws,exception,int,size,endpoint,get,consumers,size,if,size,1,endpoint,is,multiple,consumers,supported,throw,new,illegal,state,exception,multiple,consumers,for,the,same,endpoint,is,not,allowed,endpoint,if,endpoint,is,multiple,consumers,supported,if,log,is,trace,enabled,log,trace,multicasting,to,consumers,for,exchange,size,exchange,final,list,synchronization,completions,exchange,handover,completions,async,processor,mp,endpoint,get,consumer,multicast,processor,object,helper,not,null,mp,consumer,multicast,processor,this,mp,process,exchange,done,sync,unit,of,work,helper,done,synchronizations,exchange,completions,log,else,processor,process,exchange,empty,async,callback,get
