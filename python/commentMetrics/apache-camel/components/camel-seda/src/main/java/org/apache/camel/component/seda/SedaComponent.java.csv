commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Sets the default maximum capacity of the SEDA queue (i.e., the number of messages it can hold).  */ ;/**  * Sets the default maximum capacity of the SEDA queue (i.e., the number of messages it can hold).  */ public void setQueueSize(int size) {     queueSize = size. }
false;public;0;3;;public int getQueueSize() {     return queueSize. }
true;public;1;3;/**  * Sets the default number of concurrent threads processing exchanges.  */ ;/**  * Sets the default number of concurrent threads processing exchanges.  */ public void setConcurrentConsumers(int size) {     concurrentConsumers = size. }
false;public;0;3;;public int getConcurrentConsumers() {     return concurrentConsumers. }
false;public;0;3;;public BlockingQueueFactory<Exchange> getDefaultQueueFactory() {     return defaultQueueFactory. }
true;public;1;3;/**  * Sets the default queue factory.  */ ;/**  * Sets the default queue factory.  */ public void setDefaultQueueFactory(BlockingQueueFactory<Exchange> defaultQueueFactory) {     this.defaultQueueFactory = defaultQueueFactory. }
false;public;0;3;;public boolean isDefaultBlockWhenFull() {     return defaultBlockWhenFull. }
true;public;1;3;/**  * Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted.  * By default, an exception will be thrown stating that the queue is full.  * By enabling this option, the calling thread will instead block and wait until the message can be accepted.  */ ;/**  * Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted.  * By default, an exception will be thrown stating that the queue is full.  * By enabling this option, the calling thread will instead block and wait until the message can be accepted.  */ public void setDefaultBlockWhenFull(boolean defaultBlockWhenFull) {     this.defaultBlockWhenFull = defaultBlockWhenFull. }
false;public;0;3;;public long getDefaultOfferTimeout() {     return defaultOfferTimeout. }
true;public;1;3;/**  * Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted.  * By default, an exception will be thrown stating that the queue is full.  * By enabling this option, where a configured timeout can be added to the block case.  Utilizing the .offer(timeout) method of the underlining java queue  */ ;/**  * Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted.  * By default, an exception will be thrown stating that the queue is full.  * By enabling this option, where a configured timeout can be added to the block case.  Utilizing the .offer(timeout) method of the underlining java queue  */ public void setDefaultOfferTimeout(long defaultOfferTimeout) {     this.defaultOfferTimeout = defaultOfferTimeout. }
false;public,synchronized;4;43;;public synchronized QueueReference getOrCreateQueue(SedaEndpoint endpoint, Integer size, Boolean multipleConsumers, BlockingQueueFactory<Exchange> customQueueFactory) {     String key = getQueueKey(endpoint.getEndpointUri()).     QueueReference ref = getQueues().get(key).     if (ref != null) {         // if the given size is not provided, we just use the existing queue as is         if (size != null && !size.equals(ref.getSize())) {             // there is already a queue, so make sure the size matches             throw new IllegalArgumentException("Cannot use existing queue " + key + " as the existing queue size " + (ref.getSize() != null ? ref.getSize() : SedaConstants.QUEUE_SIZE) + " does not match given queue size " + size).         }         // add the reference before returning queue         ref.addReference(endpoint).         if (log.isDebugEnabled()) {             log.debug("Reusing existing queue {} with size {} and reference count {}", key, size, ref.getCount()).         }         return ref.     }     // create queue     BlockingQueue<Exchange> queue.     BlockingQueueFactory<Exchange> queueFactory = customQueueFactory == null ? defaultQueueFactory : customQueueFactory.     if (size != null && size > 0) {         queue = queueFactory.create(size).     } else {         if (getQueueSize() > 0) {             size = getQueueSize().             queue = queueFactory.create(getQueueSize()).         } else {             queue = queueFactory.create().         }     }     log.debug("Created queue {} with size {}", key, size).     // create and add a new reference queue     ref = new QueueReference(queue, size, multipleConsumers).     ref.addReference(endpoint).     getQueues().put(key, ref).     return ref. }
false;public,synchronized;2;12;;public synchronized QueueReference registerQueue(SedaEndpoint endpoint, BlockingQueue<Exchange> queue) {     String key = getQueueKey(endpoint.getEndpointUri()).     QueueReference ref = getQueues().get(key).     if (ref == null) {         ref = new QueueReference(queue, endpoint.getSize(), endpoint.isMultipleConsumers()).         ref.addReference(endpoint).         getQueues().put(key, ref).     }     return ref. }
false;public;0;3;;public Map<String, QueueReference> getQueues() {     return queues. }
false;public;1;3;;public QueueReference getQueueReference(String key) {     return queues.get(key). }
false;protected;3;34;;@Override @SuppressWarnings("unchecked") protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {     int consumers = getAndRemoveOrResolveReferenceParameter(parameters, "concurrentConsumers", Integer.class, concurrentConsumers).     boolean limitConcurrentConsumers = getAndRemoveOrResolveReferenceParameter(parameters, "limitConcurrentConsumers", Boolean.class, true).     if (limitConcurrentConsumers && consumers > maxConcurrentConsumers) {         throw new IllegalArgumentException("The limitConcurrentConsumers flag in set to true. ConcurrentConsumers cannot be set at a value greater than " + maxConcurrentConsumers + " was " + consumers).     }     // Resolve queue reference     BlockingQueue<Exchange> queue = resolveAndRemoveReferenceParameter(parameters, "queue", BlockingQueue.class).     SedaEndpoint answer.     // Resolve queue factory when no queue specified     if (queue == null) {         BlockingQueueFactory<Exchange> queueFactory = resolveAndRemoveReferenceParameter(parameters, "queueFactory", BlockingQueueFactory.class).         // defer creating queue till endpoint is started, so we pass the queue factory         answer = createEndpoint(uri, this, queueFactory, consumers).     } else {         answer = createEndpoint(uri, this, queue, consumers).     }     // if blockWhenFull is set on endpoint, defaultBlockWhenFull is ignored.     boolean blockWhenFull = getAndRemoveParameter(parameters, "blockWhenFull", Boolean.class, defaultBlockWhenFull).     // if offerTimeout is set on endpoint, defaultOfferTimeout is ignored.     long offerTimeout = getAndRemoveParameter(parameters, "offerTimeout", long.class, defaultOfferTimeout).     answer.setOfferTimeout(offerTimeout).     answer.setBlockWhenFull(blockWhenFull).     answer.configureProperties(parameters).     answer.setConcurrentConsumers(consumers).     answer.setLimitConcurrentConsumers(limitConcurrentConsumers).     return answer. }
false;protected;4;3;;protected SedaEndpoint createEndpoint(String endpointUri, Component component, BlockingQueueFactory<Exchange> queueFactory, int concurrentConsumers) {     return new SedaEndpoint(endpointUri, component, queueFactory, concurrentConsumers). }
false;protected;4;3;;protected SedaEndpoint createEndpoint(String endpointUri, Component component, BlockingQueue<Exchange> queue, int concurrentConsumers) {     return new SedaEndpoint(endpointUri, component, queue, concurrentConsumers). }
false;public;1;7;;public String getQueueKey(String uri) {     if (uri.contains("?")) {         // strip parameters         uri = uri.substring(0, uri.indexOf('?')).     }     return uri. }
false;protected;0;5;;@Override protected void doStop() throws Exception {     getQueues().clear().     super.doStop(). }
true;;1;13;/**  * On shutting down the endpoint  *  * @param endpoint the endpoint  */ ;/**  * On shutting down the endpoint  *  * @param endpoint the endpoint  */ void onShutdownEndpoint(SedaEndpoint endpoint) {     // we need to remove the endpoint from the reference counter     String key = getQueueKey(endpoint.getEndpointUri()).     QueueReference ref = getQueues().get(key).     if (ref != null && endpoint.getConsumers().size() == 0) {         // only remove the endpoint when the consumers are removed         ref.removeReference(endpoint).         if (ref.getCount() <= 0) {             // reference no longer needed so remove from queues             getQueues().remove(key).         }     } }
