commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isPrettyPrint() {     return prettyPrint. }
true;public;1;3;/**  * Whether the JAXB converter should use pretty print or not (default is true)  */ ;/**  * Whether the JAXB converter should use pretty print or not (default is true)  */ public void setPrettyPrint(boolean prettyPrint) {     this.prettyPrint = prettyPrint. }
false;public;0;3;;public boolean isObjectFactory() {     return objectFactory. }
true;public;1;3;/**  * Whether the JAXB converter supports using ObjectFactory classes to create the POJO classes during conversion.  * This only applies to POJO classes that has not been annotated with JAXB and providing jaxb.index descriptor files.  */ ;/**  * Whether the JAXB converter supports using ObjectFactory classes to create the POJO classes during conversion.  * This only applies to POJO classes that has not been annotated with JAXB and providing jaxb.index descriptor files.  */ public void setObjectFactory(boolean objectFactory) {     this.objectFactory = objectFactory. }
false;public;0;3;;public boolean allowNull() {     return false. }
false;public;1;3;;public void setTypeConverter(TypeConverter parentTypeConverter) {     this.parentTypeConverter = parentTypeConverter. }
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;1;25;;public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext.     if (camelContext != null) {         // configure pretty print         String property = camelContext.getGlobalOption(PRETTY_PRINT).         if (property != null) {             if (property.equalsIgnoreCase("false")) {                 setPrettyPrint(false).             } else {                 setPrettyPrint(true).             }         }         // configure object factory         property = camelContext.getGlobalOption(OBJECT_FACTORY).         if (property != null) {             if (property.equalsIgnoreCase("false")) {                 setObjectFactory(false).             } else {                 setObjectFactory(true).             }         }     } }
false;public;2;3;;public <T> T convertTo(Class<T> type, Object value) {     return convertTo(type, null, value). }
false;public;3;30;;public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {     if (BeanInvocation.class.isAssignableFrom(type) || Processor.class.isAssignableFrom(type)) {         // to avoid Camel trying to do this when using beans with JAXB payloads         return null.     }     try {         if (isJaxbType(type)) {             return unmarshall(type, exchange, value).         }         if (value != null && isNotStreamCacheType(type)) {             if (hasXmlRootElement(value.getClass())) {                 return marshall(type, exchange, value, null).             }             if (isObjectFactory()) {                 CamelContext context = exchange != null ? exchange.getContext() : camelContext.                 Method objectFactoryMethod = JaxbHelper.getJaxbElementFactoryMethod(context, value.getClass()).                 if (objectFactoryMethod != null) {                     return marshall(type, exchange, value, objectFactoryMethod).                 }             }         }     } catch (Exception e) {         throw new TypeConversionException(value, type, e).     }     // should return null if didn't even try to convert at all or for whatever reason the conversion is failed     return null. }
false;public;2;3;;public <T> T mandatoryConvertTo(Class<T> type, Object value) throws NoTypeConversionAvailableException {     return mandatoryConvertTo(type, null, value). }
false;public;3;7;;public <T> T mandatoryConvertTo(Class<T> type, Exchange exchange, Object value) throws NoTypeConversionAvailableException {     T answer = convertTo(type, exchange, value).     if (answer == null) {         throw new NoTypeConversionAvailableException(value, type).     }     return answer. }
false;public;2;7;;public <T> T tryConvertTo(Class<T> type, Object value) {     try {         return convertTo(type, null, value).     } catch (Exception e) {         return null.     } }
false;public;3;7;;public <T> T tryConvertTo(Class<T> type, Exchange exchange, Object value) {     try {         return convertTo(type, exchange, value).     } catch (Exception e) {         return null.     } }
false;protected;0;4;;@Override protected void doStart() throws Exception {     log.info("Jaxb FallbackTypeConverter[prettyPrint={}, objectFactory={}]", prettyPrint, objectFactory). }
false;protected;0;4;;@Override protected void doStop() throws Exception {     contexts.clear(). }
false;private;1;3;;private <T> boolean hasXmlRootElement(Class<T> type) {     return type.getAnnotation(XmlRootElement.class) != null. }
false;protected;1;7;;protected <T> boolean isJaxbType(Class<T> type) {     if (isObjectFactory()) {         return hasXmlRootElement(type) || JaxbHelper.getJaxbElementFactoryMethod(camelContext, type) != null.     } else {         return hasXmlRootElement(type).     } }
false;private;2;7;;private <T> T castJaxbType(Object o, Class<T> type) {     if (type.isAssignableFrom(o.getClass())) {         return type.cast(o).     } else {         return type.cast(((JAXBElement) o).getValue()).     } }
true;protected;3;50;/**  * Lets try parse via JAXB  */ ;/**  * Lets try parse via JAXB  */ protected <T> T unmarshall(Class<T> type, Exchange exchange, Object value) throws Exception {     log.trace("Unmarshal to {} with value {}", type, value).     if (value == null) {         throw new IllegalArgumentException("Cannot convert from null value to JAXBSource").     }     Unmarshaller unmarshaller = getUnmarshaller(type).     if (parentTypeConverter != null) {         if (!needFiltering(exchange)) {             // we cannot filter the XMLStreamReader if necessary             XMLStreamReader xmlReader = parentTypeConverter.convertTo(XMLStreamReader.class, exchange, value).             if (xmlReader != null) {                 try {                     Object unmarshalled = unmarshal(unmarshaller, exchange, xmlReader).                     return castJaxbType(unmarshalled, type).                 } catch (Exception ex) {                     // There is some issue on the StaxStreamReader to CXFPayload message body with different namespaces                     log.debug("Cannot use StaxStreamReader to unmarshal the message, due to {}", ex).                 }             }         }         InputStream inputStream = parentTypeConverter.convertTo(InputStream.class, exchange, value).         if (inputStream != null) {             Object unmarshalled = unmarshal(unmarshaller, exchange, inputStream).             return castJaxbType(unmarshalled, type).         }         Reader reader = parentTypeConverter.convertTo(Reader.class, exchange, value).         if (reader != null) {             Object unmarshalled = unmarshal(unmarshaller, exchange, reader).             return castJaxbType(unmarshalled, type).         }         Source source = parentTypeConverter.convertTo(Source.class, exchange, value).         if (source != null) {             Object unmarshalled = unmarshal(unmarshaller, exchange, source).             return castJaxbType(unmarshalled, type).         }     }     if (value instanceof String) {         value = new StringReader((String) value).     }     if (value instanceof InputStream || value instanceof Reader) {         Object unmarshalled = unmarshal(unmarshaller, exchange, value).         return castJaxbType(unmarshalled, type).     }     return null. }
false;protected;4;43;;protected <T> T marshall(Class<T> type, Exchange exchange, Object value, Method objectFactoryMethod) throws JAXBException, XMLStreamException, FactoryConfigurationError, TypeConversionException {     log.trace("Marshal from value {} to type {}", value, type).     T answer = null.     if (parentTypeConverter != null) {         // lets convert the object to a JAXB source and try convert that to         // the required source         JAXBContext context = createContext(value.getClass()).         // must create a new instance of marshaller as its not thread safe         Marshaller marshaller = context.createMarshaller().         Writer buffer = new StringWriter().         if (isPrettyPrint()) {             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE).         }         String charset = exchange != null ? exchange.getProperty(Exchange.CHARSET_NAME, String.class) : null.         if (charset != null) {             marshaller.setProperty(Marshaller.JAXB_ENCODING, charset).         }         Object toMarshall = value.         if (objectFactoryMethod != null) {             try {                 Object instance = objectFactoryMethod.getDeclaringClass().newInstance().                 if (instance != null) {                     toMarshall = objectFactoryMethod.invoke(instance, value).                 }             } catch (Exception e) {                 log.debug("Unable to create JAXBElement object for type " + value.getClass() + " due to " + e.getMessage(), e).             }         }         if (needFiltering(exchange)) {             XMLStreamWriter writer = parentTypeConverter.convertTo(XMLStreamWriter.class, buffer).             FilteringXmlStreamWriter filteringWriter = new FilteringXmlStreamWriter(writer, charset).             marshaller.marshal(toMarshall, filteringWriter).         } else {             marshaller.marshal(toMarshall, buffer).         }         // we need to pass the exchange         answer = parentTypeConverter.convertTo(type, exchange, buffer.toString()).     }     return answer. }
false;protected;3;32;;protected Object unmarshal(Unmarshaller unmarshaller, Exchange exchange, Object value) throws JAXBException, UnsupportedEncodingException, XMLStreamException {     try {         XMLStreamReader xmlReader.         if (value instanceof XMLStreamReader) {             xmlReader = (XMLStreamReader) value.         } else if (value instanceof InputStream) {             if (needFiltering(exchange)) {                 xmlReader = staxConverter.createXMLStreamReader(new NonXmlFilterReader(new InputStreamReader((InputStream) value, ExchangeHelper.getCharsetName(exchange)))).             } else {                 xmlReader = staxConverter.createXMLStreamReader((InputStream) value, exchange).             }         } else if (value instanceof Reader) {             Reader reader = (Reader) value.             if (needFiltering(exchange)) {                 if (!(value instanceof NonXmlFilterReader)) {                     reader = new NonXmlFilterReader((Reader) value).                 }             }             xmlReader = staxConverter.createXMLStreamReader(reader).         } else if (value instanceof Source) {             xmlReader = staxConverter.createXMLStreamReader((Source) value).         } else {             throw new IllegalArgumentException("Cannot convert from " + value.getClass()).         }         return unmarshaller.unmarshal(xmlReader).     } finally {         if (value instanceof Closeable) {             IOHelper.close((Closeable) value, "Unmarshalling", log).         }     } }
false;protected;1;4;;protected boolean needFiltering(Exchange exchange) {     // exchange property takes precedence over data format property     return exchange != null && exchange.getProperty(Exchange.FILTER_NON_XML_CHARS, Boolean.FALSE, Boolean.class). }
false;protected,synchronized;1;14;;protected synchronized <T> JAXBContext createContext(Class<T> type) throws JAXBException {     AnnotatedElement ae = hasXmlRootElement(type) ? type : type.getPackage().     JAXBContext context = contexts.get(ae).     if (context == null) {         if (hasXmlRootElement(type)) {             context = JAXBContext.newInstance(type).             contexts.put(type, context).         } else {             context = JAXBContext.newInstance(type.getPackage().getName()).             contexts.put(type.getPackage(), context).         }     }     return context. }
false;protected;1;4;;protected <T> Unmarshaller getUnmarshaller(Class<T> type) throws JAXBException {     JAXBContext context = createContext(type).     return context.createUnmarshaller(). }
false;private,static;1;3;;private static <T> boolean isNotStreamCacheType(Class<T> type) {     return !StreamCache.class.isAssignableFrom(type). }
