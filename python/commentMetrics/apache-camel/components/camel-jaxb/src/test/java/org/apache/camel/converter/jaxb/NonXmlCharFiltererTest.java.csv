commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Before public void setUp() {     nonXmlCharFilterer = new NonXmlCharFilterer(). }
false;public;0;13;;@Test public void testIsFilteredValidChars() {     // Per http://www.w3.org/TR/2004/REC-xml-20040204/#NT-Char     // Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] |     // [#x10000-#x10FFFF]     checkSingleValid(0x9).     checkSingleValid(0xA).     checkSingleValid(0xD).     checkRangeValid(0x20, 0xD7FF).     checkRangeValid(0xE000, 0xFFFD). // not checking [0x10000, 0x10FFFF], as it goes beyond // Character.MAX_VALUE }
false;public;0;13;;@Test public void testIsFilteredInvalidChars() {     // Per http://www.w3.org/TR/2004/REC-xml-20040204/#NT-Char     // Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] |     // [#x10000-#x10FFFF]     checkRangeInvalid(0x0, 0x8).     checkRangeInvalid(0xB, 0xC).     checkRangeInvalid(0xE, 0x1F).     checkRangeInvalid(0xD800, 0xDFFF).     checkRangeInvalid(0xFFFE, 0xFFFF). // no need to check beyond #x10FFFF as this is greater than // Character.MAX_VALUE }
false;public;0;12;;@Test public void testFilter1ArgNonFiltered() {     when(nonXmlCharFiltererMock.filter(anyString())).thenCallRealMethod().     when(nonXmlCharFiltererMock.filter(any(char[].class), anyInt(), anyInt())).thenReturn(false).     String string = "abc".     String result = nonXmlCharFiltererMock.filter(string).     verify(nonXmlCharFiltererMock).filter(new char[] { 'a', 'b', 'c' }, 0, 3).     assertSame("Should have returned the same string if nothing was filtered", string, result). }
false;public;1;6;;public Boolean answer(InvocationOnMock invocation) throws Throwable {     char[] buffer = (char[]) invocation.getArguments()[0].     buffer[0] = 'i'.     buffer[1] = 'o'.     return true. }
false;public;0;17;;@Test public void testFilter1ArgFiltered() {     when(nonXmlCharFiltererMock.filter(anyString())).thenCallRealMethod().     when(nonXmlCharFiltererMock.filter(eq(new char[] { 'a', 'b', 'c' }), anyInt(), anyInt())).thenAnswer(new Answer<Boolean>() {          public Boolean answer(InvocationOnMock invocation) throws Throwable {             char[] buffer = (char[]) invocation.getArguments()[0].             buffer[0] = 'i'.             buffer[1] = 'o'.             return true.         }     }).     String result = nonXmlCharFiltererMock.filter("abc").     verify(nonXmlCharFiltererMock).filter(any(char[].class), eq(0), eq(3)).     assertEquals("Should have returned filtered string", "ioc", result). }
false;public;0;5;;@Test public void testFilter1ArgNullArg() {     nonXmlCharFiltererMock.filter(null).     verify(nonXmlCharFiltererMock, never()).filter(any(char[].class), anyInt(), anyInt()). }
false;public;0;15;;@Test public void testFilter3Args() {     when(nonXmlCharFiltererMock.filter(any(char[].class), anyInt(), anyInt())).thenCallRealMethod().     when(nonXmlCharFiltererMock.isFiltered(anyChar())).thenReturn(true, false, true).     char[] buffer = new char[] { '1', '2', '3', '4', '5', '6' }.     nonXmlCharFiltererMock.filter(buffer, 2, 3).     verify(nonXmlCharFiltererMock).isFiltered('3').     verify(nonXmlCharFiltererMock).isFiltered('4').     verify(nonXmlCharFiltererMock).isFiltered('5').     assertArrayEquals("Unexpected buffer contents", new char[] { '1', '2', ' ', '4', ' ', '6' }, buffer). }
false;public;0;4;;@Test public void testFilter3ArgsNullArg() {     nonXmlCharFilterer.filter(null, 2, 3). }
false;private;1;3;;private void checkSingleValid(int charCode) {     checkRangeValid(charCode, charCode). }
false;private;2;10;;private void checkRangeValid(int startCharCodeInclusive, int endCharCodeInclusive) {     for (int charCode = startCharCodeInclusive. charCode <= endCharCodeInclusive. charCode++) {         if (nonXmlCharFilterer.isFiltered((char) charCode)) {             fail("Character " + asHex(charCode) + " from range [" + asHex(startCharCodeInclusive) + "-" + asHex(endCharCodeInclusive) + "] should be valid, but it is not").         }     } }
false;private;2;9;;private void checkRangeInvalid(int startCharCodeInclusive, int endCharCodeInclusive) {     for (int charCode = startCharCodeInclusive. charCode <= endCharCodeInclusive. charCode++) {         if (!nonXmlCharFilterer.isFiltered((char) charCode)) {             fail("Character " + asHex(charCode) + " from range [" + asHex(startCharCodeInclusive) + "-" + asHex(endCharCodeInclusive) + "] should not be valid, but it is").         }     } }
false;private;1;3;;private String asHex(int charCode) {     return "#x" + Integer.toHexString(charCode). }
