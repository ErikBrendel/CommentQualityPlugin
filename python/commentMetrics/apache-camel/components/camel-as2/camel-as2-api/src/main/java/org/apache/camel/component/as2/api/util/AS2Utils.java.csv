commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;14;/**  * Validates if the given <code>name</code> is a valid AS2 Name  *  * @param name - the name to validate.  * @throws InvalidAS2NameException - If <code>name</code> is invalid.  */ ;/**  * Validates if the given <code>name</code> is a valid AS2 Name  *  * @param name - the name to validate.  * @throws InvalidAS2NameException - If <code>name</code> is invalid.  */ public static void validateAS2Name(String name) throws InvalidAS2NameException {     Matcher matcher = AS_NAME_PATTERN.matcher(name).     if (!matcher.matches()) {         // if name does not match, determine where it fails to match.         int i = 0.         for (i = name.length() - 1. i > 0. i--) {             Matcher region = matcher.region(0, i).             if (region.matches() || region.hitEnd()) {                 break.             }         }         throw new InvalidAS2NameException(name, i).     } }
true;public,static;1;4;/**  * Generates a globally unique message ID which includes <code>fqdn</code>: a fully qualified domain name (FQDN)  * @param fqdn - the fully qualified domain name to use in message id.  * @return The generated message id.  */ ;/**  * Generates a globally unique message ID which includes <code>fqdn</code>: a fully qualified domain name (FQDN)  * @param fqdn - the fully qualified domain name to use in message id.  * @return The generated message id.  */ public static String createMessageId(String fqdn) {     /* Fully Qualified Domain Name */     return "<" + Long.toString(System.nanoTime(), 36) + "." + Long.toString(generator.nextLong(), 36) + "@" + fqdn + ">". }
true;public,static;1;5;/**  * Determines if <code>c</code> is a printable character.  * @param c - the character to test  * @return <code>true</code> if <code>c</code> is a printable character. <code>false</code> otherwise.  */ ;/**  * Determines if <code>c</code> is a printable character.  * @param c - the character to test  * @return <code>true</code> if <code>c</code> is a printable character. <code>false</code> otherwise.  */ public static boolean isPrintableChar(char c) {     Character.UnicodeBlock block = Character.UnicodeBlock.of(c).     return (!Character.isISOControl(c)) && c != KeyEvent.CHAR_UNDEFINED && block != null && block != Character.UnicodeBlock.SPECIALS. }
false;public,static;1;8;;public static String printRequest(HttpRequest request) throws IOException {     try (ByteArrayOutputStream baos = new ByteArrayOutputStream().         PrintStream ps = new PrintStream(baos, true, "utf-8")) {         printRequest(ps, request).         String content = new String(baos.toByteArray(), StandardCharsets.UTF_8).         return content.     } }
false;public,static;1;8;;public static String printMessage(HttpMessage message) throws IOException {     try (ByteArrayOutputStream baos = new ByteArrayOutputStream().         PrintStream ps = new PrintStream(baos, true, "utf-8")) {         printMessage(ps, message).         String content = new String(baos.toByteArray(), StandardCharsets.UTF_8).         return content.     } }
true;public,static;2;18;/**  * Prints the contents of request to given print stream.  *  * @param out  *            - the stream printed to.  * @param request  *            - the request printed.  * @throws IOException - If failed to print request.  */ ;/**  * Prints the contents of request to given print stream.  *  * @param out  *            - the stream printed to.  * @param request  *            - the request printed.  * @throws IOException - If failed to print request.  */ public static void printRequest(PrintStream out, HttpRequest request) throws IOException {     // Print request line     RequestLine requestLine = request.getRequestLine().     out.println(requestLine.getMethod() + ' ' + requestLine.getUri() + ' ' + requestLine.getProtocolVersion()).     // Write headers     for (final HeaderIterator it = request.headerIterator(). it.hasNext(). ) {         Header header = it.nextHeader().         out.println(header.getName() + ": " + (header.getValue() == null ? "" : header.getValue())).     }     // write empty line separating header from body.     out.println().     if (request instanceof HttpEntityEnclosingRequest) {         // Write entity         HttpEntity entity = ((HttpEntityEnclosingRequest) request).getEntity().         entity.writeTo(out).     } }
true;public,static;2;30;/**  * Prints the contents of an Http Message to given print stream.  *  * @param out - the stream printed to.  * @param message - the request printed.  * @throws IOException - If failed to print message.  */ ;/**  * Prints the contents of an Http Message to given print stream.  *  * @param out - the stream printed to.  * @param message - the request printed.  * @throws IOException - If failed to print message.  */ public static void printMessage(PrintStream out, HttpMessage message) throws IOException {     // Print request line     if (message instanceof HttpRequest) {         RequestLine requestLine = ((HttpRequest) message).getRequestLine().         out.println(requestLine.getMethod() + ' ' + requestLine.getUri() + ' ' + requestLine.getProtocolVersion()).     } else {         // HttpResponse         StatusLine statusLine = ((HttpResponse) message).getStatusLine().         out.println(statusLine.toString()).     }     // Write headers     for (final HeaderIterator it = message.headerIterator(). it.hasNext(). ) {         Header header = it.nextHeader().         out.println(header.getName() + ": " + (header.getValue() == null ? "" : header.getValue())).     }     // write empty line separating header from body.     out.println().     if (message instanceof HttpEntityEnclosingRequest) {         // Write entity         HttpEntity entity = ((HttpEntityEnclosingRequest) message).getEntity().         if (entity != null) {             entity.writeTo(out).         }     } else if (message instanceof HttpResponse) {         // Write entity         HttpEntity entity = ((HttpResponse) message).getEntity().         if (entity != null) {             entity.writeTo(out).         }     } }
