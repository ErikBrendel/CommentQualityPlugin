commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;6;;@Override protected void doStart() throws Exception {     super.doStart().     watch(). }
false;protected;0;4;;@Override protected void doStop() throws Exception {     super.doStop(). }
false;public;1;80;;@Override public void onResponse(ResponsePromise<EtcdKeysResponse> promise) {     if (!isRunAllowed()) {         return.     }     Exchange exchange = null.     Throwable throwable = promise.getException().     if (throwable instanceof EtcdException) {         EtcdException exception = (EtcdException) throwable.         // So we set the index to the one returned by the exception + 1         if (EtcdHelper.isOutdatedIndexException(exception)) {             LOGGER.debug("Outdated index, key: {}, cause={}", getPath(), exception.etcdCause).             // We set the index to the one returned by the exception + 1.             index.set(exception.index + 1).             // Clean-up the exception so it is not rethrown/handled             throwable = null.         }     } else {         try {             EtcdKeysResponse response = promise.get().             exchange = endpoint.createExchange().             exchange.getIn().setHeader(EtcdConstants.ETCD_NAMESPACE, getNamespace()).             exchange.getIn().setHeader(EtcdConstants.ETCD_PATH, response.node.key).             exchange.getIn().setBody(response).             // Watch from the modifiedIndex + 1 of the node we got for ensuring             // no events are missed between watch commands             index.set(response.node.modifiedIndex + 1).         } catch (TimeoutException e) {             LOGGER.debug("Timeout watching for {}", getPath()).             if (configuration.isSendEmptyExchangeOnTimeout()) {                 exchange = endpoint.createExchange().                 exchange.getIn().setHeader(EtcdConstants.ETCD_NAMESPACE, getNamespace()).                 exchange.getIn().setHeader(EtcdConstants.ETCD_TIMEOUT, true).                 exchange.getIn().setHeader(EtcdConstants.ETCD_PATH, getPath()).                 exchange.getIn().setBody(null).             }             throwable = null.         } catch (Exception e1) {             throwable = e1.         }         if (exchange != null) {             try {                 throwable = null.                 getProcessor().process(exchange).             } catch (Exception e) {                 getExceptionHandler().handleException("Error processing exchange", exchange, e).             }         }     }     if (throwable != null) {         handleException("Error processing etcd response", throwable).     }     try {         watch().     } catch (Exception e) {         handleException("Error watching key " + getPath(), e).     } }
false;private;0;15;;private void watch() throws Exception {     if (!isRunAllowed()) {         return.     }     EtcdKeyGetRequest request = getClient().get(getPath()).waitForChange(index.get()).     if (configuration.isRecursive()) {         request.recursive().     }     if (configuration.getTimeout() != null) {         request.timeout(configuration.getTimeout(), TimeUnit.MILLISECONDS).     }     request.send().addListener(this). }
