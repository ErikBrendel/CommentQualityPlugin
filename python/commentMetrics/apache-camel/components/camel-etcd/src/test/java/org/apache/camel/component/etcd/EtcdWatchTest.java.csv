commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Test public void testWatchWithPath() throws Exception {     testWatch("mock:watch-with-path", "/myKey1", 10). }
false;public;0;4;;@Test public void testWatchWithConfigPath() throws Exception {     testWatch("mock:watch-with-config-path", "/myKey2", 10). }
false;public;0;4;;@Test public void testWatchRecursive() throws Exception {     testWatch("mock:watch-recursive", "/recursive/myKey1", 10). }
false;public;0;23;;@Test public void testWatchRecovery() throws Exception {     final String key = "/myKeyRecovery".     final EtcdClient client = getClient().     try {         // Delete the key if present         client.delete(key).send().get().     } catch (EtcdException e) {         if (!e.isErrorCode(EtcdErrorCode.KeyNotFound)) {             throw e.         }     }     // Fill the vent backlog ( > 1000)     for (int i = 0. i < 2000. i++) {         client.put(key, "v" + i).send().get().     }     context().getRouteController().startRoute("watchRecovery").     testWatch("mock:watch-recovery", key, 10). }
false;public;0;10;;@Test public void testWatchWithTimeout() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:watch-with-timeout").     mock.expectedMessageCount(1).     mock.expectedHeaderReceived(EtcdConstants.ETCD_NAMESPACE, EtcdNamespace.watch.name()).     mock.expectedHeaderReceived(EtcdConstants.ETCD_PATH, "/timeoutKey").     mock.expectedHeaderReceived(EtcdConstants.ETCD_TIMEOUT, true).     mock.allMessages().body().isNull().     mock.assertIsSatisfied(). }
false;private;3;19;;private void testWatch(String mockEndpoint, final String key, int updates) throws Exception {     final String[] values = new String[updates].     for (int i = 0. i < updates. i++) {         values[i] = key + "=myValue-" + i.     }     MockEndpoint mock = getMockEndpoint(mockEndpoint).     mock.expectedMessageCount(2).     mock.expectedHeaderReceived(EtcdConstants.ETCD_NAMESPACE, EtcdNamespace.watch.name()).     mock.expectedHeaderReceived(EtcdConstants.ETCD_PATH, key).     mock.expectedBodiesReceived(values).     final EtcdClient client = getClient().     for (int i = 0. i < updates. i++) {         client.put(key, "myValue-" + i).send().get().     }     mock.assertIsSatisfied(). }
false;public;0;19;;public void configure() {     from("etcd:watch/myKey1").process(NODE_TO_VALUE_IN).to("mock:watch-with-path").     fromF("etcd:watch/myKeyRecovery?timeout=%s&fromIndex=%s", 1000 * 60 * 5, 1).id("watchRecovery").autoStartup(false).process(NODE_TO_VALUE_IN).to("mock:watch-recovery").     from("etcd:watch/recursive?recursive=true").process(NODE_TO_VALUE_IN).to("log:org.apache.camel.component.etcd?level=INFO").to("mock:watch-recursive").     from("etcd:watch/myKey2").process(NODE_TO_VALUE_IN).to("mock:watch-with-config-path").     from("etcd:watch/timeoutKey?timeout=250&sendEmptyExchangeOnTimeout=true").to("mock:watch-with-timeout"). }
false;protected;0;24;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          public void configure() {             from("etcd:watch/myKey1").process(NODE_TO_VALUE_IN).to("mock:watch-with-path").             fromF("etcd:watch/myKeyRecovery?timeout=%s&fromIndex=%s", 1000 * 60 * 5, 1).id("watchRecovery").autoStartup(false).process(NODE_TO_VALUE_IN).to("mock:watch-recovery").             from("etcd:watch/recursive?recursive=true").process(NODE_TO_VALUE_IN).to("log:org.apache.camel.component.etcd?level=INFO").to("mock:watch-recursive").             from("etcd:watch/myKey2").process(NODE_TO_VALUE_IN).to("mock:watch-with-config-path").             from("etcd:watch/timeoutKey?timeout=250&sendEmptyExchangeOnTimeout=true").to("mock:watch-with-timeout").         }     }. }
