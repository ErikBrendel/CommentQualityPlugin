commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public AhcComponent getComponent() {     return (AhcComponent) super.getComponent(). }
false;public;0;7;;@Override public Producer createProducer() throws Exception {     ObjectHelper.notNull(client, "AsyncHttpClient", this).     ObjectHelper.notNull(httpUri, "HttpUri", this).     ObjectHelper.notNull(binding, "AhcBinding", this).     return new AhcProducer(this). }
false;public;1;4;;@Override public Consumer createConsumer(Processor processor) throws Exception {     throw new UnsupportedOperationException("This component does not support consuming from this endpoint"). }
false;public;0;5;;@Override public boolean isLenientProperties() {     // true to allow dynamic URI options to be configured and passed to external system for eg. the HttpProducer     return true. }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;public;0;3;;public AsyncHttpClient getClient() {     return client. }
true;public;1;3;/**  * To use a custom {@link AsyncHttpClient}  */ ;/**  * To use a custom {@link AsyncHttpClient}  */ public void setClient(AsyncHttpClient client) {     this.client = client. }
false;public;0;3;;public AsyncHttpClientConfig getClientConfig() {     return clientConfig. }
true;public;1;3;/**  * To configure the AsyncHttpClient to use a custom com.ning.http.client.AsyncHttpClientConfig instance.  */ ;/**  * To configure the AsyncHttpClient to use a custom com.ning.http.client.AsyncHttpClientConfig instance.  */ public void setClientConfig(AsyncHttpClientConfig clientConfig) {     this.clientConfig = clientConfig. }
false;public;0;3;;public URI getHttpUri() {     return httpUri. }
true;public;1;3;/**  * The URI to use such as http://hostname:port/path  */ ;/**  * The URI to use such as http://hostname:port/path  */ public void setHttpUri(URI httpUri) {     this.httpUri = httpUri. }
false;public;0;3;;public AhcBinding getBinding() {     return binding. }
true;public;1;3;/**  * To use a custom {@link AhcBinding} which allows to control how to bind between AHC and Camel.  */ ;/**  * To use a custom {@link AhcBinding} which allows to control how to bind between AHC and Camel.  */ public void setBinding(AhcBinding binding) {     this.binding = binding. }
false;public;0;3;;public HeaderFilterStrategy getHeaderFilterStrategy() {     return headerFilterStrategy. }
true;public;1;3;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ ;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {     this.headerFilterStrategy = headerFilterStrategy. }
false;public;0;3;;public boolean isBridgeEndpoint() {     return bridgeEndpoint. }
true;public;1;3;/**  * If the option is true, then the Exchange.HTTP_URI header is ignored, and use the endpoint's URI for request.  * You may also set the throwExceptionOnFailure to be false to let the AhcProducer send all the fault response back.  */ ;/**  * If the option is true, then the Exchange.HTTP_URI header is ignored, and use the endpoint's URI for request.  * You may also set the throwExceptionOnFailure to be false to let the AhcProducer send all the fault response back.  */ public void setBridgeEndpoint(boolean bridgeEndpoint) {     this.bridgeEndpoint = bridgeEndpoint. }
false;public;0;3;;public boolean isThrowExceptionOnFailure() {     return throwExceptionOnFailure. }
true;public;1;3;/**  * Option to disable throwing the AhcOperationFailedException in case of failed responses from the remote server.  * This allows you to get all responses regardless of the HTTP status code.  */ ;/**  * Option to disable throwing the AhcOperationFailedException in case of failed responses from the remote server.  * This allows you to get all responses regardless of the HTTP status code.  */ public void setThrowExceptionOnFailure(boolean throwExceptionOnFailure) {     this.throwExceptionOnFailure = throwExceptionOnFailure. }
false;public;0;3;;public boolean isTransferException() {     return transferException. }
true;public;1;3;/**  * If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized  * in the response as a application/x-java-serialized-object content type (for example using Jetty or Servlet Camel components).  * On the producer side the exception will be deserialized and thrown as is, instead of the AhcOperationFailedException.  * The caused exception is required to be serialized.  * <p/>  * This is by default turned off. If you enable this then be aware that Java will deserialize the incoming  * data from the request to Java and that can be a potential security risk.  */ ;/**  * If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized  * in the response as a application/x-java-serialized-object content type (for example using Jetty or Servlet Camel components).  * On the producer side the exception will be deserialized and thrown as is, instead of the AhcOperationFailedException.  * The caused exception is required to be serialized.  * <p/>  * This is by default turned off. If you enable this then be aware that Java will deserialize the incoming  * data from the request to Java and that can be a potential security risk.  */ public void setTransferException(boolean transferException) {     this.transferException = transferException. }
false;public;0;3;;public SSLContextParameters getSslContextParameters() {     return sslContextParameters. }
true;public;1;3;/**  * Reference to a org.apache.camel.support.jsse.SSLContextParameters in the Registry.  * This reference overrides any configured SSLContextParameters at the component level.  * See Using the JSSE Configuration Utility.  * Note that configuring this option will override any SSL/TLS configuration options provided through the clientConfig option at the endpoint or component level.  */ ;/**  * Reference to a org.apache.camel.support.jsse.SSLContextParameters in the Registry.  * This reference overrides any configured SSLContextParameters at the component level.  * See Using the JSSE Configuration Utility.  * Note that configuring this option will override any SSL/TLS configuration options provided through the clientConfig option at the endpoint or component level.  */ public void setSslContextParameters(SSLContextParameters sslContextParameters) {     this.sslContextParameters = sslContextParameters. }
false;public;0;3;;public int getBufferSize() {     return bufferSize. }
true;public;1;3;/**  * The initial in-memory buffer size used when transferring data between Camel and AHC Client.  */ ;/**  * The initial in-memory buffer size used when transferring data between Camel and AHC Client.  */ public void setBufferSize(int bufferSize) {     this.bufferSize = bufferSize. }
false;public;0;3;;public Map<String, Object> getClientConfigOptions() {     return clientConfigOptions. }
true;public;1;3;/**  * To configure the AsyncHttpClientConfig using the key/values from the Map.  */ ;/**  * To configure the AsyncHttpClientConfig using the key/values from the Map.  */ public void setClientConfigOptions(Map<String, Object> clientConfigOptions) {     this.clientConfigOptions = clientConfigOptions. }
false;public;0;3;;public Map<String, Object> getClientConfigRealmOptions() {     return clientConfigRealmOptions. }
true;public;1;3;/**  * To configure the AsyncHttpClientConfig Realm using the key/values from the Map.  */ ;/**  * To configure the AsyncHttpClientConfig Realm using the key/values from the Map.  */ public void setClientConfigRealmOptions(Map<String, Object> clientConfigRealmOptions) {     this.clientConfigRealmOptions = clientConfigRealmOptions. }
false;public;0;3;;public boolean isConnectionClose() {     return connectionClose. }
true;public;1;3;/**  * Define if the Connection Close header has to be added to HTTP Request. This parameter is false by default  */ ;/**  * Define if the Connection Close header has to be added to HTTP Request. This parameter is false by default  */ public void setConnectionClose(boolean connectionClose) {     this.connectionClose = connectionClose. }
false;public;0;3;;public CookieHandler getCookieHandler() {     return cookieHandler. }
true;public;1;3;/**  * Configure a cookie handler to maintain a HTTP session  */ ;/**  * Configure a cookie handler to maintain a HTTP session  */ public void setCookieHandler(CookieHandler cookieHandler) {     this.cookieHandler = cookieHandler. }
false;protected;0;34;;@Override protected void doStart() throws Exception {     super.doStart().     if (client == null) {         AsyncHttpClientConfig config.         if (clientConfig != null) {             DefaultAsyncHttpClientConfig.Builder builder = AhcComponent.cloneConfig(clientConfig).             if (sslContextParameters != null) {                 SSLContext sslContext = sslContextParameters.createSSLContext(getCamelContext()).                 JdkSslContext ssl = new JdkSslContext(sslContext, true, ClientAuth.REQUIRE).                 builder.setSslContext(ssl).             }             config = builder.build().         } else {             DefaultAsyncHttpClientConfig.Builder builder = new DefaultAsyncHttpClientConfig.Builder().             /*                  * Not doing this will always create a cookie handler per endpoint, which is incompatible                  * to prior versions and interferes with the cookie handling in camel                  */             builder.setCookieStore(null).             if (sslContextParameters != null) {                 SSLContext sslContext = sslContextParameters.createSSLContext(getCamelContext()).                 JdkSslContext ssl = new JdkSslContext(sslContext, true, ClientAuth.REQUIRE).                 builder.setSslContext(ssl).             }             config = builder.build().         }         client = createClient(config).     } }
false;protected;1;7;;protected AsyncHttpClient createClient(AsyncHttpClientConfig config) {     if (config == null) {         return new DefaultAsyncHttpClient().     } else {         return new DefaultAsyncHttpClient(config).     } }
false;protected;0;9;;@Override protected void doStop() throws Exception {     super.doStop().     // ensure client is closed when stopping     if (client != null && !client.isClosed()) {         client.close().     }     client = null. }
