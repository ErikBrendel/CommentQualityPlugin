commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getDataFormatName() {     return "asn1". }
false;public;3;26;;@Override public void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception {     InputStream berOut = null.     if (usingIterator) {         if (clazzName != null) {             Class<?> clazz = exchange.getContext().getClassResolver().resolveMandatoryClass(clazzName).             encodeGenericTypeObject(exchange, clazz, stream).             return.         }         Object record = exchange.getIn().getBody().         if (record instanceof ASN1Primitive) {             ASN1Primitive asn1Primitive = ObjectHelper.cast(ASN1Primitive.class, record).             berOut = new ByteArrayInputStream(asn1Primitive.getEncoded()).         } else if (record instanceof byte[]) {             berOut = new ByteArrayInputStream(ObjectHelper.cast(byte[].class, record)).         }     } else {         byte[] byteInput = exchange.getContext().getTypeConverter().mandatoryConvertTo(byte[].class, exchange, graph).         berOut = new ByteArrayInputStream(byteInput).     }     try {         IOHelper.copy(berOut, stream).     } finally {         IOHelper.close(berOut, stream).     } }
false;private;3;9;;private void encodeGenericTypeObject(Exchange exchange, Class<?> clazz, OutputStream stream) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, IOException {     Class<?>[] paramOut = new Class<?>[1].     paramOut[0] = OutputStream.class.     ReverseByteArrayOutputStream berOut = new ReverseByteArrayOutputStream(IOHelper.DEFAULT_BUFFER_SIZE / 256, true).     Method encodeMethod = exchange.getIn().getBody().getClass().getDeclaredMethod("encode", paramOut).     encodeMethod.invoke(exchange.getIn().getBody(), berOut).     stream.write(berOut.getArray()). }
false;public;2;24;;@SuppressWarnings({ "rawtypes", "unchecked" }) @Override public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {     if (usingIterator) {         if (clazzName != null) {             Class<?> clazz = exchange.getContext().getClassResolver().resolveMandatoryClass(clazzName).             ASN1GenericIterator asn1GenericIterator = new ASN1GenericIterator(clazz, stream).             return asn1GenericIterator.         }         ASN1MessageIterator asn1MessageIterator = new ASN1MessageIterator(exchange, stream).         return asn1MessageIterator.     } else {         ASN1Primitive asn1Record = null.         byte[] asn1Bytes.         try (ASN1InputStream ais = new ASN1InputStream(stream).             ByteArrayOutputStream asn1Out = new ByteArrayOutputStream()) {             while (ais.available() > 0) {                 asn1Record = ais.readObject().                 asn1Out.write(asn1Record.getEncoded()).             }             asn1Bytes = asn1Out.toByteArray().         }         return asn1Bytes.     } }
false;public;0;3;;public boolean isUsingIterator() {     return usingIterator. }
false;public;1;3;;public void setUsingIterator(boolean usingIterator) {     this.usingIterator = usingIterator. }
false;public;0;3;;public String getClazzName() {     return clazzName. }
false;public;1;3;;public void setClazzName(String clazzName) {     this.clazzName = clazzName. }
false;protected;0;4;;@Override protected void doStart() throws Exception { // no op }
false;protected;0;4;;@Override protected void doStop() throws Exception { // no op }
