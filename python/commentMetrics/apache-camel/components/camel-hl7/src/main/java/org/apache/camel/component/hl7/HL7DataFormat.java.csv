commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getDataFormatName() {     return "hl7". }
false;public;3;6;;public void marshal(Exchange exchange, Object body, OutputStream outputStream) throws Exception {     Message message = ExchangeHelper.convertToMandatoryType(exchange, Message.class, body).     String charsetName = HL7Charset.getCharsetName(message, exchange).     String encoded = parser.encode(message).     outputStream.write(encoded.getBytes(charsetName)). }
false;public;2;15;;public Object unmarshal(Exchange exchange, InputStream inputStream) throws Exception {     byte[] body = ExchangeHelper.convertToMandatoryType(exchange, byte[].class, inputStream).     String charsetName = HL7Charset.getCharsetName(body, guessCharsetName(body, exchange)).     String bodyAsString = new String(body, charsetName).     Message message = parser.parse(bodyAsString).     // add MSH fields as message out headers     Terser terser = new Terser(message).     for (Map.Entry<String, String> entry : HEADER_MAP.entrySet()) {         exchange.getOut().setHeader(entry.getKey(), terser.get(entry.getValue())).     }     exchange.getOut().setHeader(HL7_CONTEXT, hapiContext).     exchange.getOut().setHeader(Exchange.CHARSET_NAME, charsetName).     return message. }
false;public;0;3;;public boolean isValidate() {     return validate. }
false;public;1;3;;public void setValidate(boolean validate) {     this.validate = validate. }
false;public;0;3;;public HapiContext getHapiContext() {     return hapiContext. }
false;public;1;3;;public void setHapiContext(HapiContext context) {     this.hapiContext = context. }
false;public;0;3;;public Parser getParser() {     return parser. }
false;public;1;3;;public void setParser(Parser parser) {     this.parser = parser. }
false;protected;0;26;;@Override protected void doStart() throws Exception {     if (hapiContext == null) {         ValidationContext validationContext.         if (validate) {             validationContext = ValidationContextFactory.defaultValidation().         } else {             validationContext = ValidationContextFactory.noValidation().         }         ParserConfiguration parserConfiguration.         if (parser == null) {             parserConfiguration = new ParserConfiguration().             parserConfiguration.setDefaultObx2Type("ST").             parserConfiguration.setInvalidObx2Type("ST").             parserConfiguration.setUnexpectedSegmentBehaviour(UnexpectedSegmentBehaviourEnum.ADD_INLINE).         } else {             parserConfiguration = parser.getParserConfiguration().         }         hapiContext = new DefaultHapiContext(parserConfiguration, validationContext, new DefaultModelClassFactory()).     }     if (parser == null) {         parser = hapiContext.getGenericParser().     } }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
true;protected;2;3;/**  * In HL7 the charset of the message can be set in MSH-18,  * but you need to decode the input stream in order to be able to read MSH-18.  * This works well for differentiating e.g. between ASCII, UTF-8 and ISI-8859 charsets,  * but not for multi-byte charsets like UTF-16, Big5 etc.  *  * This method is called to "guess" the initial encoding, and subclasses can overwrite it  * using 3rd party libraries like ICU4J that provide a CharsetDetector.  *  * The implementation in this class just assumes the charset defined in the exchange property or header by  * calling {@link ExchangeHelper#getCharsetName(Exchange)}.  *  * @param b byte array  * @param exchange the exchange  * @return charset name  */ ;/**  * In HL7 the charset of the message can be set in MSH-18,  * but you need to decode the input stream in order to be able to read MSH-18.  * This works well for differentiating e.g. between ASCII, UTF-8 and ISI-8859 charsets,  * but not for multi-byte charsets like UTF-16, Big5 etc.  *  * This method is called to "guess" the initial encoding, and subclasses can overwrite it  * using 3rd party libraries like ICU4J that provide a CharsetDetector.  *  * The implementation in this class just assumes the charset defined in the exchange property or header by  * calling {@link ExchangeHelper#getCharsetName(Exchange)}.  *  * @param b byte array  * @param exchange the exchange  * @return charset name  */ protected String guessCharsetName(byte[] b, Exchange exchange) {     return ExchangeHelper.getCharsetName(exchange). }
