commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;22;;@Override protected Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception {     ByteBuf buf = (ByteBuf) super.decode(ctx, buffer).     if (buf != null) {         try {             int pos = buf.bytesBefore((byte) config.getStartByte()).             if (pos >= 0) {                 ByteBuf msg = buf.readerIndex(pos + 1).slice().                 LOG.debug("Message ends with length {}", msg.readableBytes()).                 return config.isProduceString() ? asString(msg) : asByteArray(msg).             } else {                 throw new DecoderException("Did not find start byte " + (int) config.getStartByte()).             }         } finally {             // We need to release the buf here to avoid the memory leak             buf.release().         }     }     // Message not complete yet - return null to be called again     LOG.debug("No complete messages yet at position {}", buffer.readableBytes()).     return null. }
false;private;1;12;;private byte[] asByteArray(ByteBuf msg) {     byte[] bytes = new byte[msg.readableBytes()].     msg.getBytes(0, bytes).     if (config.isConvertLFtoCR()) {         for (int i = 0. i < bytes.length. i++) {             if (bytes[i] == (byte) '\n') {                 bytes[i] = (byte) '\r'.             }         }     }     return bytes. }
false;private;1;7;;private String asString(ByteBuf msg) {     String s = msg.toString(config.getCharset()).     if (config.isConvertLFtoCR()) {         return s.replace('\n', '\r').     }     return s. }
