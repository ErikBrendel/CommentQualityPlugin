commented;modifiers;parameterAmount;loc;comment;code
false;public;1;22;;@Override public Consumer createConsumer(final Processor processor) throws Exception {     final SqlProcessingStrategy proStrategy = new ElsqlSqlProcessingStrategy(elSql).     final SqlPrepareStatementStrategy preStategy = new ElsqlSqlPrepareStatementStrategy().     final Exchange dummy = createExchange().     final SqlParameterSource param = new ElsqlSqlMapSource(dummy, null).     final String sql = elSql.getSql(elsqlName, new SpringSqlParams(param)).     log.debug("ElsqlConsumer @{} using sql: {}", elsqlName, sql).     final ElsqlConsumer consumer = new ElsqlConsumer(this, processor, namedJdbcTemplate, sql, param, preStategy, proStrategy).     consumer.setMaxMessagesPerPoll(getMaxMessagesPerPoll()).     consumer.setOnConsume(getOnConsume()).     consumer.setOnConsumeFailed(getOnConsumeFailed()).     consumer.setOnConsumeBatchComplete(getOnConsumeBatchComplete()).     consumer.setBreakBatchOnConsumeFail(isBreakBatchOnConsumeFail()).     consumer.setExpectedUpdateCount(getExpectedUpdateCount()).     consumer.setUseIterator(isUseIterator()).     consumer.setRouteEmptyResultSet(isRouteEmptyResultSet()).     configureConsumer(consumer).     return consumer. }
false;public;0;6;;@Override public Producer createProducer() throws Exception {     final SqlPrepareStatementStrategy prepareStrategy = getPrepareStatementStrategy() != null ? getPrepareStatementStrategy() : new DefaultSqlPrepareStatementStrategy(getSeparator()).     final ElsqlProducer result = new ElsqlProducer(this, elSql, elsqlName, namedJdbcTemplate, dataSource, prepareStrategy, isBatch()).     return result. }
false;protected;0;23;;@Override protected void doStart() throws Exception {     super.doStart().     org.apache.camel.util.ObjectHelper.notNull(resourceUri, "resourceUri", this).     if (elSqlConfig == null && databaseVendor != null) {         elSqlConfig = databaseVendor.asElSqlConfig().     } else if (elSqlConfig == null) {         elSqlConfig = ElSqlDatabaseVendor.Default.asElSqlConfig().     }     // there can be multiple resources     // so we have all this lovely code to turn that into an URL[]     final List<URL> list = new ArrayList<>().     final Iterable it = ObjectHelper.createIterable(resourceUri).     for (final Object path : it) {         final URL url = ResourceHelper.resolveMandatoryResourceAsUrl(getCamelContext().getClassResolver(), path.toString()).         list.add(url).     }     final URL[] urls = list.toArray(new URL[list.size()]).     elSql = ElSql.parse(elSqlConfig, urls). }
true;public;0;3;/**  * The name of the elsql to use (is @NAMED in the elsql file)  */ ;/**  * The name of the elsql to use (is @NAMED in the elsql file)  */ public String getElsqlName() {     return elsqlName. }
false;public;0;3;;public ElSqlDatabaseVendor getDatabaseVendor() {     return databaseVendor. }
true;public;1;3;/**  * To use a vendor specific {@link com.opengamma.elsql.ElSqlConfig}  */ ;/**  * To use a vendor specific {@link com.opengamma.elsql.ElSqlConfig}  */ public void setDatabaseVendor(final ElSqlDatabaseVendor databaseVendor) {     this.databaseVendor = databaseVendor. }
false;public;0;3;;public ElSqlConfig getElSqlConfig() {     return elSqlConfig. }
true;public;1;3;/**  * To use a specific configured ElSqlConfig. It may be better to use the <tt>databaseVendor</tt> option instead.  */ ;/**  * To use a specific configured ElSqlConfig. It may be better to use the <tt>databaseVendor</tt> option instead.  */ public void setElSqlConfig(final ElSqlConfig elSqlConfig) {     this.elSqlConfig = elSqlConfig. }
false;public;0;3;;public String getResourceUri() {     return resourceUri. }
true;public;1;3;/**  * The resource file which contains the elsql SQL statements to use. You can specify multiple resources separated by comma.  * The resources are loaded on the classpath by default, you can prefix with <tt>file:</tt> to load from file system.  * Notice you can set this option on the component and then you do not have to configure this on the endpoint.  */ ;/**  * The resource file which contains the elsql SQL statements to use. You can specify multiple resources separated by comma.  * The resources are loaded on the classpath by default, you can prefix with <tt>file:</tt> to load from file system.  * Notice you can set this option on the component and then you do not have to configure this on the endpoint.  */ public void setResourceUri(final String resourceUri) {     this.resourceUri = resourceUri. }
false;public;0;3;;public DataSource getDataSource() {     return dataSource. }
true;public;1;3;/**  * Sets the DataSource to use to communicate with the database.  */ ;/**  * Sets the DataSource to use to communicate with the database.  */ public void setDataSource(final DataSource dataSource) {     this.dataSource = dataSource. }
