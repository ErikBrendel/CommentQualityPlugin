commented;modifiers;parameterAmount;loc;comment;code
false;public;1;32;;@Override public void process(Exchange exchange) throws Exception {     Message in = exchange.getIn().     Object message = in.getMandatoryBody().     if (!(message == null || message instanceof String || message instanceof byte[])) {         message = in.getMandatoryBody(String.class).     }     if (isSendToAllSet(in)) {         sendToAll(store, message, exchange).     } else {         // look for connection key and get Websocket         String connectionKey = in.getHeader(WebsocketConstants.CONNECTION_KEY, String.class).         if (connectionKey != null) {             String pathSpec = "".             if (endpoint.getResourceUri() != null) {                 pathSpec = WebsocketComponent.createPathSpec(endpoint.getResourceUri()).             }             DefaultWebsocket websocket = store.get(connectionKey + pathSpec).             log.debug("Sending to connection key {} -> {}", connectionKey, message).             Future<Void> future = sendMessage(websocket, message).             if (future != null) {                 int timeout = endpoint.getSendTimeout().                 future.get(timeout, TimeUnit.MILLISECONDS).                 if (!future.isCancelled() && !future.isDone()) {                     throw new WebsocketSendException("Failed to send message to the connection within " + timeout + " millis.", exchange).                 }             }         } else {             throw new WebsocketSendException("Failed to send message to single connection. connection key not set.", exchange).         }     } }
false;public;0;3;;public WebsocketEndpoint getEndpoint() {     return endpoint. }
false;public;0;5;;@Override public void doStart() throws Exception {     super.doStart().     endpoint.connect(this). }
false;public;0;5;;@Override public void doStop() throws Exception {     endpoint.disconnect(this).     super.doStop(). }
false;;1;5;;boolean isSendToAllSet(Message in) {     // header may be null. have to be careful here (and fallback to use sendToAll option configured from endpoint)     Boolean value = in.getHeader(WebsocketConstants.SEND_TO_ALL, sendToAll, Boolean.class).     return value == null ? false : value. }
false;;3;57;;void sendToAll(WebsocketStore store, Object message, Exchange exchange) throws Exception {     log.debug("Sending to all {}", message).     Collection<DefaultWebsocket> websockets = store.getAll().     Exception exception = null.     List<Future> futures = new CopyOnWriteArrayList<>().     for (DefaultWebsocket websocket : websockets) {         boolean isOkToSendMessage = false.         if (endpoint.getResourceUri() == null) {             isOkToSendMessage = true.         } else if (websocket.getPathSpec().equals(WebsocketComponent.createPathSpec(endpoint.getResourceUri()))) {             isOkToSendMessage = true.         }         if (isOkToSendMessage) {             try {                 Future<Void> future = sendMessage(websocket, message).                 if (future != null) {                     futures.add(future).                 }             } catch (Exception e) {                 if (exception == null) {                     exception = new WebsocketSendException("Failed to deliver message to one or more recipients.", exchange, e).                 }             }         }     }     // check if they are all done within the timed out period     StopWatch watch = new StopWatch().     int timeout = endpoint.getSendTimeout().     while (!futures.isEmpty() && watch.taken() < timeout) {         // remove all that are done/cancelled         for (Future future : futures) {             if (future.isDone() || future.isCancelled()) {                 futures.remove(future).             }             // if there are still more then we need to wait a little bit before checking again, to avoid burning cpu cycles in the while loop             if (!futures.isEmpty()) {                 long interval = Math.min(1000, timeout).                 log.debug("Sleeping {} millis waiting for sendToAll to complete sending with timeout {} millis", interval, timeout).                 try {                     Thread.sleep(interval).                 } catch (InterruptedException e) {                     handleSleepInterruptedException(e, exchange).                 }             }         }     }     if (!futures.isEmpty()) {         exception = new WebsocketSendException("Failed to deliver message within " + endpoint.getSendTimeout() + " millis to one or more recipients.", exchange).     }     if (exception != null) {         throw exception.     } }
false;;2;14;;Future<Void> sendMessage(DefaultWebsocket websocket, Object message) throws IOException {     Future<Void> future = null.     // in case there is web socket and socket connection is open - send message     if (websocket != null && websocket.getSession().isOpen()) {         log.trace("Sending to websocket {} -> {}", websocket.getConnectionKey(), message).         if (message instanceof String) {             future = websocket.getSession().getRemote().sendStringByFuture((String) message).         } else if (message instanceof byte[]) {             ByteBuffer buf = ByteBuffer.wrap((byte[]) message).             future = websocket.getSession().getRemote().sendBytesByFuture(buf).         }     }     return future. }
true;public;1;3;// Store is set/unset upon connect/disconnect of the producer ;// Store is set/unset upon connect/disconnect of the producer public void setStore(WebsocketStore store) {     this.store = store. }
true;protected;2;7;/**  * Called when a sleep is interrupted. allows derived classes to handle this case differently  */ ;/**  * Called when a sleep is interrupted. allows derived classes to handle this case differently  */ protected void handleSleepInterruptedException(InterruptedException e, Exchange exchange) throws InterruptedException {     if (log.isDebugEnabled()) {         log.debug("Sleep interrupted, are we stopping? {}", isStopping() || isStopped()).     }     Thread.currentThread().interrupt().     throw e. }
