commented;modifiers;parameterAmount;loc;comment;code
false;public;3;29;;public Exchange add(final CamelContext camelContext, final String key, final Exchange exchange) {     log.debug("Adding key [{}] -> {}", key, exchange).     try {         byte[] lDbKey = keyBuilder(repositoryName, key).         final Buffer exchangeBuffer = codec.marshallExchange(camelContext, exchange, allowSerializedHeaders).         byte[] rc = null.         if (isReturnOldExchange()) {             rc = levelDBFile.getDb().get(lDbKey).         }         log.trace("Adding key index {} for repository {}", key, repositoryName).         levelDBFile.getDb().put(lDbKey, exchangeBuffer.toByteArray(), levelDBFile.getWriteOptions()).         log.trace("Added key index {}", key).         if (rc == null) {             return null.         }         // only return old exchange if enabled         if (isReturnOldExchange()) {             return codec.unmarshallExchange(camelContext, new Buffer(rc)).         }     } catch (IOException e) {         throw new RuntimeException("Error adding to repository " + repositoryName + " with key " + key, e).     }     return null. }
false;public;2;18;;public Exchange get(final CamelContext camelContext, final String key) {     Exchange answer = null.     try {         byte[] lDbKey = keyBuilder(repositoryName, key).         log.trace("Getting key index {}", key).         byte[] rc = levelDBFile.getDb().get(lDbKey).         if (rc != null) {             answer = codec.unmarshallExchange(camelContext, new Buffer(rc)).         }     } catch (IOException e) {         throw new RuntimeException("Error getting key " + key + " from repository " + repositoryName, e).     }     log.debug("Getting key  [{}] -> {}", key, answer).     return answer. }
false;public;3;32;;public void remove(final CamelContext camelContext, final String key, final Exchange exchange) {     log.debug("Removing key [{}]", key).     try {         byte[] lDbKey = keyBuilder(repositoryName, key).         final String exchangeId = exchange.getExchangeId().         final Buffer exchangeBuffer = codec.marshallExchange(camelContext, exchange, allowSerializedHeaders).         // remove the exchange         byte[] rc = levelDBFile.getDb().get(lDbKey).         if (rc != null) {             WriteBatch batch = levelDBFile.getDb().createWriteBatch().             try {                 batch.delete(lDbKey).                 log.trace("Removed key index {} -> {}", key, new Buffer(rc)).                 // add exchange to confirmed index                 byte[] confirmedLDBKey = keyBuilder(getRepositoryNameCompleted(), exchangeId).                 batch.put(confirmedLDBKey, exchangeBuffer.toByteArray()).                 log.trace("Added confirm index {} for repository {}", exchangeId, getRepositoryNameCompleted()).                 levelDBFile.getDb().write(batch, levelDBFile.getWriteOptions()).             } finally {                 batch.close().             }         }     } catch (IOException e) {         throw new RuntimeException("Error removing key " + key + " from repository " + repositoryName, e).     } }
false;public;2;12;;public void confirm(final CamelContext camelContext, final String exchangeId) {     log.debug("Confirming exchangeId [{}]", exchangeId).     byte[] confirmedLDBKey = keyBuilder(getRepositoryNameCompleted(), exchangeId).     byte[] rc = levelDBFile.getDb().get(confirmedLDBKey).     if (rc != null) {         levelDBFile.getDb().delete(confirmedLDBKey).         log.trace("Removed confirm index {} -> {}", exchangeId, new Buffer(rc)).     } }
false;public;0;35;;public Set<String> getKeys() {     final Set<String> keys = new LinkedHashSet<>().     // interval task could potentially be running while we are shutting down so check for that     if (!isRunAllowed()) {         return null.     }     DBIterator it = levelDBFile.getDb().iterator().     String keyBuffer.     try {         String prefix = repositoryName + '\0'.         for (it.seek(keyBuilder(repositoryName, "")). it.hasNext(). it.next()) {             if (!isRunAllowed()) {                 break.             }             keyBuffer = asString(it.peekNext().getKey()).             if (!keyBuffer.startsWith(prefix)) {                 break.             }             String key = keyBuffer.substring(prefix.length()).             log.trace("getKey [{}]", key).             keys.add(key).         }     } finally {         // Make sure you close the iterator to avoid resource leaks.         IOHelper.close(it).     }     return Collections.unmodifiableSet(keys). }
false;public;1;39;;public Set<String> scan(CamelContext camelContext) {     final Set<String> answer = new LinkedHashSet<>().     if (!isRunAllowed()) {         return null.     }     DBIterator it = levelDBFile.getDb().iterator().     String keyBuffer.     try {         String prefix = getRepositoryNameCompleted() + '\0'.         for (it.seek(keyBuilder(getRepositoryNameCompleted(), "")). it.hasNext(). it.next()) {             keyBuffer = asString(it.peekNext().getKey()).             if (!keyBuffer.startsWith(prefix)) {                 break.             }             String exchangeId = keyBuffer.substring(prefix.length()).             log.trace("Scan exchangeId [{}]", exchangeId).             answer.add(exchangeId).         }     } finally {         // Make sure you close the iterator to avoid resource leaks.         IOHelper.close(it).     }     if (answer.size() == 0) {         log.trace("Scanned and found no exchange to recover.").     } else {         if (log.isDebugEnabled()) {             log.debug("Scanned and found {} exchange(s) to recover (note some of them may already be in progress).", answer.size()).         }     }     return answer. }
false;public;2;18;;public Exchange recover(CamelContext camelContext, final String exchangeId) {     Exchange answer = null.     try {         byte[] completedLDBKey = keyBuilder(getRepositoryNameCompleted(), exchangeId).         byte[] rc = levelDBFile.getDb().get(completedLDBKey).         if (rc != null) {             answer = codec.unmarshallExchange(camelContext, new Buffer(rc)).         }     } catch (IOException e) {         throw new RuntimeException("Error recovering exchangeId " + exchangeId + " from repository " + repositoryName, e).     }     log.debug("Recovering exchangeId [{}] -> {}", exchangeId, answer).     return answer. }
false;private;1;20;;private int size(final String repositoryName) {     DBIterator it = levelDBFile.getDb().iterator().     String prefix = repositoryName + '\0'.     int count = 0.     try {         for (it.seek(keyBuilder(repositoryName, "")). it.hasNext(). it.next()) {             if (!asString(it.peekNext().getKey()).startsWith(prefix)) {                 break.             }             count++.         }     } finally {         // Make sure you close the iterator to avoid resource leaks.         IOHelper.close(it).     }     log.debug("Size of repository [{}] -> {}", repositoryName, count).     return count. }
false;public;0;3;;public LevelDBFile getLevelDBFile() {     return levelDBFile. }
false;public;1;3;;public void setLevelDBFile(LevelDBFile levelDBFile) {     this.levelDBFile = levelDBFile. }
false;public;0;3;;public String getRepositoryName() {     return repositoryName. }
false;private;0;3;;private String getRepositoryNameCompleted() {     return repositoryName + "-completed". }
false;public;1;3;;public void setRepositoryName(String repositoryName) {     this.repositoryName = repositoryName. }
false;public;0;3;;public boolean isSync() {     return sync. }
false;public;1;3;;public void setSync(boolean sync) {     this.sync = sync. }
false;public;0;3;;public boolean isReturnOldExchange() {     return returnOldExchange. }
false;public;1;3;;public void setReturnOldExchange(boolean returnOldExchange) {     this.returnOldExchange = returnOldExchange. }
false;public;2;3;;public void setRecoveryInterval(long interval, TimeUnit timeUnit) {     this.recoveryInterval = timeUnit.toMillis(interval). }
false;public;1;3;;public void setRecoveryInterval(long interval) {     this.recoveryInterval = interval. }
false;public;0;3;;public long getRecoveryIntervalInMillis() {     return recoveryInterval. }
false;public;0;3;;public boolean isUseRecovery() {     return useRecovery. }
false;public;1;3;;public void setUseRecovery(boolean useRecovery) {     this.useRecovery = useRecovery. }
false;public;0;3;;public int getMaximumRedeliveries() {     return maximumRedeliveries. }
false;public;1;3;;public void setMaximumRedeliveries(int maximumRedeliveries) {     this.maximumRedeliveries = maximumRedeliveries. }
false;public;0;3;;public String getDeadLetterUri() {     return deadLetterUri. }
false;public;1;3;;public void setDeadLetterUri(String deadLetterUri) {     this.deadLetterUri = deadLetterUri. }
false;public;0;3;;public String getPersistentFileName() {     return persistentFileName. }
false;public;1;3;;public void setPersistentFileName(String persistentFileName) {     this.persistentFileName = persistentFileName. }
false;public;0;3;;public boolean isAllowSerializedHeaders() {     return allowSerializedHeaders. }
false;public;1;3;;public void setAllowSerializedHeaders(boolean allowSerializedHeaders) {     this.allowSerializedHeaders = allowSerializedHeaders. }
false;protected;0;29;;@Override protected void doStart() throws Exception {     // either we have a LevelDB configured or we use a provided fileName     if (levelDBFile == null && persistentFileName != null) {         levelDBFile = new LevelDBFile().         levelDBFile.setSync(isSync()).         levelDBFile.setFileName(persistentFileName).     }     ObjectHelper.notNull(levelDBFile, "Either set a persistentFileName or a levelDBFile").     ObjectHelper.notNull(repositoryName, "repositoryName").     ServiceHelper.startService(levelDBFile).     // log number of existing exchanges     int current = size(getRepositoryName()).     int completed = size(getRepositoryNameCompleted()).     if (current > 0) {         log.info("On startup there are " + current + " aggregate exchanges (not completed) in repository: " + getRepositoryName()).     } else {         log.info("On startup there are no existing aggregate exchanges (not completed) in repository: " + getRepositoryName()).     }     if (completed > 0) {         log.warn("On startup there are " + completed + " completed exchanges to be recovered in repository: " + getRepositoryNameCompleted()).     } else {         log.info("On startup there are no completed exchanges to be recovered in repository: " + getRepositoryNameCompleted()).     } }
false;protected;0;4;;@Override protected void doStop() throws Exception {     ServiceHelper.stopService(levelDBFile). }
false;public,static;2;7;;public static byte[] keyBuilder(String repo, String key) {     try {         return (repo + '\0' + key).getBytes("UTF-8").     } catch (UnsupportedEncodingException e) {         throw new RuntimeException(e).     } }
false;public,static;1;11;;public static String asString(byte[] value) {     if (value == null) {         return null.     } else {         try {             return new String(value, "UTF-8").         } catch (UnsupportedEncodingException var2) {             throw new RuntimeException(var2).         }     } }
