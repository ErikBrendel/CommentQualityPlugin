commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;public void run() {     try {         LOCK.close().     } catch (Exception ex) {     // ignore     } }
true;public,static,synchronized;0;5;/**  * Gets the next available port starting at the lowest number. This is the preferred  * method to use. The port return is immediately marked in use and doesn't rely on the caller actually opening  * the port.  *  * @throws IllegalArgumentException is thrown if the port number is out of range  * @throws NoSuchElementException if there are no ports available  * @return the available port  */ ;/**  * Gets the next available port starting at the lowest number. This is the preferred  * method to use. The port return is immediately marked in use and doesn't rely on the caller actually opening  * the port.  *  * @throws IllegalArgumentException is thrown if the port number is out of range  * @throws NoSuchElementException if there are no ports available  * @return the available port  */ public static synchronized int getNextAvailable() {     int next = getNextAvailable(currentMinPort.get()).     currentMinPort.set(next + 1).     return next. }
true;public,static,synchronized;1;14;/**  * Gets the next available port starting at a given from port.  *  * @param fromPort the from port to scan for availability  * @throws IllegalArgumentException is thrown if the port number is out of range  * @throws NoSuchElementException if there are no ports available  * @return the available port  */ ;/**  * Gets the next available port starting at a given from port.  *  * @param fromPort the from port to scan for availability  * @throws IllegalArgumentException is thrown if the port number is out of range  * @throws NoSuchElementException if there are no ports available  * @return the available port  */ public static synchronized int getNextAvailable(int fromPort) {     if (fromPort < currentMinPort.get() || fromPort > MAX_PORT_NUMBER) {         throw new IllegalArgumentException("From port number not in valid range: " + fromPort).     }     for (int i = fromPort. i <= MAX_PORT_NUMBER. i++) {         if (available(i)) {             LOG.info("getNextAvailable({}) -> {}", fromPort, i).             return i.         }     }     throw new NoSuchElementException("Could not find an available port above " + fromPort). }
true;public,static;1;31;/**  * Checks to see if a specific port is available.  *  * @param port the port number to check for availability  * @return <tt>true</tt> if the port is available, or <tt>false</tt> if not  * @throws IllegalArgumentException is thrown if the port number is out of range  */ ;/**  * Checks to see if a specific port is available.  *  * @param port the port number to check for availability  * @return <tt>true</tt> if the port is available, or <tt>false</tt> if not  * @throws IllegalArgumentException is thrown if the port number is out of range  */ public static boolean available(int port) throws IllegalArgumentException {     if (port < currentMinPort.get() || port > MAX_PORT_NUMBER) {         throw new IllegalArgumentException("Invalid start currentMinPort: " + port).     }     ServerSocket ss = null.     DatagramSocket ds = null.     try {         ss = new ServerSocket(port).         ss.setReuseAddress(true).         ds = new DatagramSocket(port).         ds.setReuseAddress(true).         return true.     } catch (IOException e) {     // Do nothing     } finally {         if (ds != null) {             ds.close().         }         if (ss != null) {             try {                 ss.close().             } catch (IOException e) {             /* should not be thrown */             }         }     }     return false. }
