commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Returns a value builder for the given header  */ ;// Builder methods for expressions used when testing // ------------------------------------------------------------------------- /**  * Returns a value builder for the given header  */ public static ValueBuilder header(String name) {     return Builder.header(name). }
true;public,static;1;4;/**  * Returns a value builder for the given property  *  * @deprecated use {@link #exchangeProperty(String)}  */ ;/**  * Returns a value builder for the given property  *  * @deprecated use {@link #exchangeProperty(String)}  */ @Deprecated public static ValueBuilder property(String name) {     return Builder.exchangeProperty(name). }
true;public,static;1;3;/**  * Returns a value builder for the given exchange property  */ ;/**  * Returns a value builder for the given exchange property  */ public static ValueBuilder exchangeProperty(String name) {     return Builder.exchangeProperty(name). }
true;public,static;0;3;/**  * Returns a predicate and value builder for the inbound body on an exchange  */ ;/**  * Returns a predicate and value builder for the inbound body on an exchange  */ public static ValueBuilder body() {     return Builder.body(). }
true;public,static;1;3;/**  * Returns a predicate and value builder for the inbound message body as a  * specific type  */ ;/**  * Returns a predicate and value builder for the inbound message body as a  * specific type  */ public static <T> ValueBuilder bodyAs(Class<T> type) {     return Builder.bodyAs(type). }
true;public,static;1;3;/**  * Returns a value builder for the given system property  */ ;/**  * Returns a value builder for the given system property  */ public static ValueBuilder systemProperty(String name) {     return Builder.systemProperty(name). }
true;public,static;2;3;/**  * Returns a value builder for the given system property  */ ;/**  * Returns a value builder for the given system property  */ public static ValueBuilder systemProperty(String name, String defaultValue) {     return Builder.systemProperty(name, defaultValue). }
false;public,static;2;6;;// Assertions // ----------------------------------------------------------------------- public static <T> T assertIsInstanceOf(Class<T> expectedType, Object value) {     assertNotNull("Expected an instance of type: " + expectedType.getName() + " but was null", value).     assertTrue("Object should be of type " + expectedType.getName() + " but was: " + value + " with the type: " + value.getClass().getName(), expectedType.isInstance(value)).     return expectedType.cast(value). }
false;public,static;2;4;;public static void assertEndpointUri(Endpoint endpoint, String uri) {     assertNotNull("Endpoint is null when expecting endpoint for: " + uri, endpoint).     assertEquals("Endpoint uri for: " + endpoint, uri, endpoint.getEndpointUri()). }
true;public,static;3;3;/**  * Asserts the In message on the exchange contains the expected value  */ ;/**  * Asserts the In message on the exchange contains the expected value  */ public static Object assertInMessageHeader(Exchange exchange, String name, Object expected) {     return assertMessageHeader(exchange.getIn(), name, expected). }
true;public,static;3;3;/**  * Asserts the Out message on the exchange contains the expected value  */ ;/**  * Asserts the Out message on the exchange contains the expected value  */ public static Object assertOutMessageHeader(Exchange exchange, String name, Object expected) {     return assertMessageHeader(exchange.getOut(), name, expected). }
true;public,static;2;14;/**  * Asserts that the given exchange has an OUT message of the given body value  *  * @param exchange the exchange which should have an OUT message  * @param expected the expected value of the OUT message  * @throws InvalidPayloadException is thrown if the payload is not the expected class type  */ ;/**  * Asserts that the given exchange has an OUT message of the given body value  *  * @param exchange the exchange which should have an OUT message  * @param expected the expected value of the OUT message  * @throws InvalidPayloadException is thrown if the payload is not the expected class type  */ public static void assertInMessageBodyEquals(Exchange exchange, Object expected) throws InvalidPayloadException {     assertNotNull("Should have a response exchange!", exchange).     Object actual.     if (expected == null) {         actual = exchange.getIn().getMandatoryBody().         assertEquals("in body of: " + exchange, expected, actual).     } else {         actual = exchange.getIn().getMandatoryBody(expected.getClass()).     }     assertEquals("in body of: " + exchange, expected, actual).     LOG.debug("Received response: " + exchange + " with in: " + exchange.getIn()). }
true;public,static;2;14;/**  * Asserts that the given exchange has an OUT message of the given body value  *  * @param exchange the exchange which should have an OUT message  * @param expected the expected value of the OUT message  * @throws InvalidPayloadException is thrown if the payload is not the expected class type  */ ;/**  * Asserts that the given exchange has an OUT message of the given body value  *  * @param exchange the exchange which should have an OUT message  * @param expected the expected value of the OUT message  * @throws InvalidPayloadException is thrown if the payload is not the expected class type  */ public static void assertOutMessageBodyEquals(Exchange exchange, Object expected) throws InvalidPayloadException {     assertNotNull("Should have a response exchange!", exchange).     Object actual.     if (expected == null) {         actual = exchange.getOut().getMandatoryBody().         assertEquals("output body of: " + exchange, expected, actual).     } else {         actual = exchange.getOut().getMandatoryBody(expected.getClass()).     }     assertEquals("output body of: " + exchange, expected, actual).     LOG.debug("Received response: " + exchange + " with out: " + exchange.getOut()). }
false;public,static;3;5;;public static Object assertMessageHeader(Message message, String name, Object expected) {     Object value = message.getHeader(name).     assertEquals("Header: " + name + " on Message: " + message, expected, value).     return value. }
true;public,static;3;13;/**  * Asserts that the given expression when evaluated returns the given answer  */ ;/**  * Asserts that the given expression when evaluated returns the given answer  */ public static Object assertExpression(Expression expression, Exchange exchange, Object expected) {     Object value.     if (expected != null) {         value = expression.evaluate(exchange, expected.getClass()).     } else {         value = expression.evaluate(exchange, Object.class).     }     LOG.debug("Evaluated expression: " + expression + " on exchange: " + exchange + " result: " + value).     assertEquals("Expression: " + expression + " on Exchange: " + exchange, expected, value).     return value. }
true;public,static;2;3;/**  * Asserts that the predicate returns the expected value on the exchange  */ ;/**  * Asserts that the predicate returns the expected value on the exchange  */ public static void assertPredicateMatches(Predicate predicate, Exchange exchange) {     assertPredicate(predicate, exchange, true). }
true;public,static;2;8;/**  * Asserts that the predicate returns the expected value on the exchange  */ ;/**  * Asserts that the predicate returns the expected value on the exchange  */ public static void assertPredicateDoesNotMatch(Predicate predicate, Exchange exchange) {     try {         PredicateAssertHelper.assertMatches(predicate, "Predicate should match: ", exchange).     } catch (AssertionError e) {         LOG.debug("Caught expected assertion error: " + e).     }     assertPredicate(predicate, exchange, false). }
true;public,static;3;11;/**  * Asserts that the predicate returns the expected value on the exchange  */ ;/**  * Asserts that the predicate returns the expected value on the exchange  */ public static boolean assertPredicate(final Predicate predicate, Exchange exchange, boolean expected) {     if (expected) {         PredicateAssertHelper.assertMatches(predicate, "Predicate failed: ", exchange).     }     boolean value = predicate.matches(exchange).     LOG.debug("Evaluated predicate: " + predicate + " on exchange: " + exchange + " result: " + value).     assertEquals("Predicate: " + predicate + " on Exchange: " + exchange, expected, value).     return value. }
true;public,static;2;7;/**  * Resolves an endpoint and asserts that it is found  */ ;/**  * Resolves an endpoint and asserts that it is found  */ public static Endpoint resolveMandatoryEndpoint(CamelContext context, String uri) {     Endpoint endpoint = context.getEndpoint(uri).     assertNotNull("No endpoint found for URI: " + uri, endpoint).     return endpoint. }
true;public,static;3;8;/**  * Resolves an endpoint and asserts that it is found  */ ;/**  * Resolves an endpoint and asserts that it is found  */ public static <T extends Endpoint> T resolveMandatoryEndpoint(CamelContext context, String uri, Class<T> endpointType) {     T endpoint = context.getEndpoint(uri, endpointType).     assertNotNull("No endpoint found for URI: " + uri, endpoint).     return endpoint. }
true;protected;2;7;/**  * Creates an exchange with the given body  */ ;/**  * Creates an exchange with the given body  */ protected Exchange createExchangeWithBody(CamelContext camelContext, Object body) {     Exchange exchange = new DefaultExchange(camelContext).     Message message = exchange.getIn().     message.setHeader("testClass", getClass().getName()).     message.setBody(body).     return exchange. }
false;public,static;1;4;;public static <T> T assertOneElement(List<T> list) {     assertEquals("Size of list should be 1: " + list, 1, list.size()).     return list.get(0). }
true;public,static;2;3;/**  * Asserts that a list is of the given size  */ ;/**  * Asserts that a list is of the given size  */ public static <T> List<T> assertListSize(List<T> list, int size) {     return assertListSize("List", list, size). }
true;public,static;3;5;/**  * Asserts that a list is of the given size  */ ;/**  * Asserts that a list is of the given size  */ public static <T> List<T> assertListSize(String message, List<T> list, int size) {     assertEquals(message + " should be of size: " + size + " but is: " + list, size, list.size()).     return list. }
true;public,static;2;3;/**  * Asserts that a list is of the given size  */ ;/**  * Asserts that a list is of the given size  */ public static <T> Collection<T> assertCollectionSize(Collection<T> list, int size) {     return assertCollectionSize("List", list, size). }
true;public,static;3;5;/**  * Asserts that a list is of the given size  */ ;/**  * Asserts that a list is of the given size  */ public static <T> Collection<T> assertCollectionSize(String message, Collection<T> list, int size) {     assertEquals(message + " should be of size: " + size + " but is: " + list, size, list.size()).     return list. }
true;public,static;1;8;/**  * A helper method to create a list of Route objects for a given route builder  */ ;/**  * A helper method to create a list of Route objects for a given route builder  */ public static List<Route> getRouteList(RouteBuilder builder) throws Exception {     CamelContext context = new DefaultCamelContext().     context.addRoutes(builder).     context.start().     List<Route> answer = context.getRoutes().     context.stop().     return answer. }
true;public,static;2;4;/**  * Asserts that the text contains the given string  *  * @param text the text to compare  * @param containedText the text which must be contained inside the other text parameter  */ ;/**  * Asserts that the text contains the given string  *  * @param text the text to compare  * @param containedText the text which must be contained inside the other text parameter  */ public static void assertStringContains(String text, String containedText) {     assertNotNull("Text should not be null!", text).     assertTrue("Text: " + text + " does not contain: " + containedText, text.contains(containedText)). }
true;public,static;1;3;/**  * Recursively delete a directory, useful to zapping test data  *  * @param file the directory to be deleted  * @return <tt>false</tt> if error deleting directory  */ ;/**  * Recursively delete a directory, useful to zapping test data  *  * @param file the directory to be deleted  * @return <tt>false</tt> if error deleting directory  */ public static boolean deleteDirectory(String file) {     return deleteDirectory(new File(file)). }
true;public,static;1;18;/**  * Recursively delete a directory, useful to zapping test data  *  * @param file the directory to be deleted  * @return <tt>false</tt> if error deleting directory  */ ;/**  * Recursively delete a directory, useful to zapping test data  *  * @param file the directory to be deleted  * @return <tt>false</tt> if error deleting directory  */ public static boolean deleteDirectory(File file) {     int tries = 0.     int maxTries = 5.     boolean exists = true.     while (exists && (tries < maxTries)) {         recursivelyDeleteDirectory(file).         tries++.         exists = file.exists().         if (exists) {             try {                 Thread.sleep(1000).             } catch (InterruptedException e) {             // Ignore             }         }     }     return !exists. }
false;private,static;1;16;;private static void recursivelyDeleteDirectory(File file) {     if (!file.exists()) {         return.     }     if (file.isDirectory()) {         File[] files = file.listFiles().         for (File child : files) {             recursivelyDeleteDirectory(child).         }     }     boolean success = file.delete().     if (!success) {         LOG.warn("Deletion of file: " + file.getAbsolutePath() + " failed").     } }
true;public,static;1;4;/**  * create the directory  *  * @param file the directory to be created  */ ;/**  * create the directory  *  * @param file the directory to be created  */ public static void createDirectory(String file) {     File dir = new File(file).     dir.mkdirs(). }
true;public,static;2;3;/**  * To be used for folder/directory comparison that works across different platforms such  * as Window, Mac and Linux.  */ ;/**  * To be used for folder/directory comparison that works across different platforms such  * as Window, Mac and Linux.  */ public static void assertDirectoryEquals(String expected, String actual) {     assertDirectoryEquals(null, expected, actual). }
true;public,static;3;11;/**  * To be used for folder/directory comparison that works across different platforms such  * as Window, Mac and Linux.  */ ;/**  * To be used for folder/directory comparison that works across different platforms such  * as Window, Mac and Linux.  */ public static void assertDirectoryEquals(String message, String expected, String actual) {     // must use single / as path separators     String expectedPath = expected.replace('\\', '/').     String actualPath = actual.replace('\\', '/').     if (message != null) {         assertEquals(message, expectedPath, actualPath).     } else {         assertEquals(expectedPath, actualPath).     } }
true;public,static;1;5;/**  * To be used to check is a directory is found in the file system  */ ;/**  * To be used to check is a directory is found in the file system  */ public static void assertDirectoryExists(String filename) {     File file = new File(filename).     assertTrue("Directory " + filename + " should exist", file.exists()).     assertTrue("Directory " + filename + " should be a directory", file.isDirectory()). }
true;public,static;1;5;/**  * To be used to check is a file is found in the file system  */ ;/**  * To be used to check is a file is found in the file system  */ public static void assertFileExists(String filename) {     File file = new File(filename).     assertTrue("File " + filename + " should exist", file.exists()).     assertTrue("File " + filename + " should be a file", file.isFile()). }
true;public,static;1;4;/**  * To be used to check is a file is <b>not</b> found in the file system  */ ;/**  * To be used to check is a file is <b>not</b> found in the file system  */ public static void assertFileNotExists(String filename) {     File file = new File(filename).     assertFalse("File " + filename + " should not exist", file.exists()). }
true;public,static;1;4;/**  * Is this OS the given platform.  * <p/>  * Uses <tt>os.name</tt> from the system properties to determine the OS.  *  * @param platform such as Windows  * @return <tt>true</tt> if its that platform.  */ ;/**  * Is this OS the given platform.  * <p/>  * Uses <tt>os.name</tt> from the system properties to determine the OS.  *  * @param platform such as Windows  * @return <tt>true</tt> if its that platform.  */ public static boolean isPlatform(String platform) {     String osName = System.getProperty("os.name").toLowerCase(Locale.US).     return osName.contains(platform.toLowerCase(Locale.US)). }
true;public,static;1;4;/**  * Is this Java by the given vendor.  * <p/>  * Uses <tt>java.vendor</tt> from the system properties to determine the vendor.  *  * @param vendor such as IBM  * @return <tt>true</tt> if its that vendor.  */ ;/**  * Is this Java by the given vendor.  * <p/>  * Uses <tt>java.vendor</tt> from the system properties to determine the vendor.  *  * @param vendor such as IBM  * @return <tt>true</tt> if its that vendor.  */ public static boolean isJavaVendor(String vendor) {     String javaVendor = System.getProperty("java.vendor").toLowerCase(Locale.US).     return javaVendor.contains(vendor.toLowerCase(Locale.US)). }
true;public,static;0;4;/**  * Is this Java 1.5  *  * @return <tt>true</tt> if its Java 1.5, <tt>false</tt> if its not (for example Java 1.6 or better)  * @deprecated will be removed in the future as Camel requires JDK1.8+  */ ;/**  * Is this Java 1.5  *  * @return <tt>true</tt> if its Java 1.5, <tt>false</tt> if its not (for example Java 1.6 or better)  * @deprecated will be removed in the future as Camel requires JDK1.8+  */ @Deprecated public static boolean isJava15() {     return getJavaMajorVersion() == 5. }
true;public,static;0;5;/**  * Is this Java 1.6  *  * @return <tt>true</tt> if its Java 1.6, <tt>false</tt> if its not (for example Java 1.7 or better)  * @deprecated will be removed in the future as Camel requires JDK1.8+  */ ;/**  * Is this Java 1.6  *  * @return <tt>true</tt> if its Java 1.6, <tt>false</tt> if its not (for example Java 1.7 or better)  * @deprecated will be removed in the future as Camel requires JDK1.8+  */ @Deprecated public static boolean isJava16() {     return getJavaMajorVersion() == 6. }
true;public,static;0;5;/**  * Is this Java 1.7  *  * @return <tt>true</tt> if its Java 1.7, <tt>false</tt> if its not (for example Java 1.6 or older)  * @deprecated will be removed in the future as Camel requires JDK1.8+  */ ;/**  * Is this Java 1.7  *  * @return <tt>true</tt> if its Java 1.7, <tt>false</tt> if its not (for example Java 1.6 or older)  * @deprecated will be removed in the future as Camel requires JDK1.8+  */ @Deprecated public static boolean isJava17() {     return getJavaMajorVersion() == 7. }
true;public,static;0;4;/**  * Is this Java 1.8  *  * @return <tt>true</tt> if its Java 1.8, <tt>false</tt> if its not (for example Java 1.7 or older)  */ ;/**  * Is this Java 1.8  *  * @return <tt>true</tt> if its Java 1.8, <tt>false</tt> if its not (for example Java 1.7 or older)  */ public static boolean isJava18() {     return getJavaMajorVersion() == 8. }
true;public,static;0;4;/**  * Is this Java 1.9  *  * @return <tt>true</tt> if its Java 1.9, <tt>false</tt> if its not (for example Java 1.8 or older)  */ ;/**  * Is this Java 1.9  *  * @return <tt>true</tt> if its Java 1.9, <tt>false</tt> if its not (for example Java 1.8 or older)  */ public static boolean isJava19() {     return getJavaMajorVersion() == 9. }
true;public,static;0;8;/**  * Returns the current major Java version e.g 8.  * <p/>  * Uses <tt>java.specification.version</tt> from the system properties to determine the major version.  *  * @return the current major Java version.  */ ;/**  * Returns the current major Java version e.g 8.  * <p/>  * Uses <tt>java.specification.version</tt> from the system properties to determine the major version.  *  * @return the current major Java version.  */ public static int getJavaMajorVersion() {     String javaSpecVersion = System.getProperty("java.specification.version").     if (javaSpecVersion.contains(".")) {         // before jdk 9         return Integer.parseInt(javaSpecVersion.split("\\.")[1]).     } else {         return Integer.parseInt(javaSpecVersion).     } }
true;public;0;4;/**  * Gets the current test name  *  * @return the test name  */ ;/**  * Gets the current test name  *  * @return the test name  */ @Rule public TestName getTestName() {     return testName. }
true;public;0;3;/**  * Gets the current test method name  *  * @return the method name  */ ;/**  * Gets the current test method name  *  * @return the method name  */ public String getTestMethodName() {     return testName.getMethodName(). }
