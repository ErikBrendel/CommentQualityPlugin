commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public SpringWebserviceEndpoint getEndpoint() {     return (SpringWebserviceEndpoint) super.getEndpoint(). }
false;public;1;5;;@Override public void doWithMessage(WebServiceMessage requestMessage) throws IOException, TransformerException {     toResult(sourcePayload, requestMessage.getPayloadResult()).     callback.doWithMessage(requestMessage). }
false;public;1;12;;@Override public void doWithMessage(WebServiceMessage responseMessage) throws IOException, TransformerException {     SoapMessage soapMessage = (SoapMessage) responseMessage.     if (ExchangeHelper.isOutCapable(exchange)) {         exchange.getOut().copyFromWithNewBody(exchange.getIn(), soapMessage.getPayloadSource()).         populateHeaderAndAttachmentsFromResponse(exchange.getOut(), soapMessage).     } else {         exchange.getIn().setBody(soapMessage.getPayloadSource()).         populateHeaderAndAttachmentsFromResponse(exchange.getIn(), soapMessage).     } }
false;public;1;39;;public void process(Exchange exchange) throws Exception {     // Let Camel TypeConverter hierarchy handle the conversion of XML messages to Source objects     Source sourcePayload = exchange.getIn().getMandatoryBody(Source.class).     // Extract optional headers     String endpointUriHeader = exchange.getIn().getHeader(SpringWebserviceConstants.SPRING_WS_ENDPOINT_URI, String.class).     String soapActionHeader = exchange.getIn().getHeader(SpringWebserviceConstants.SPRING_WS_SOAP_ACTION, String.class).     URI wsAddressingActionHeader = exchange.getIn().getHeader(SpringWebserviceConstants.SPRING_WS_ADDRESSING_ACTION, URI.class).     URI wsReplyToHeader = exchange.getIn().getHeader(SpringWebserviceConstants.SPRING_WS_ADDRESSING_PRODUCER_REPLY_TO, URI.class).     URI wsFaultToHeader = exchange.getIn().getHeader(SpringWebserviceConstants.SPRING_WS_ADDRESSING_PRODUCER_FAULT_TO, URI.class).     Source soapHeaderSource = exchange.getIn().getHeader(SpringWebserviceConstants.SPRING_WS_SOAP_HEADER, Source.class).     WebServiceMessageCallback callback = new DefaultWebserviceMessageCallback(soapActionHeader, wsAddressingActionHeader, wsReplyToHeader, wsFaultToHeader, soapHeaderSource, getEndpoint().getConfiguration(), exchange).     if (endpointUriHeader == null) {         endpointUriHeader = getEndpoint().getConfiguration().getWebServiceTemplate().getDefaultUri().     }     getEndpoint().getConfiguration().getWebServiceTemplate().sendAndReceive(endpointUriHeader, new WebServiceMessageCallback() {          @Override         public void doWithMessage(WebServiceMessage requestMessage) throws IOException, TransformerException {             toResult(sourcePayload, requestMessage.getPayloadResult()).             callback.doWithMessage(requestMessage).         }     }, new WebServiceMessageCallback() {          @Override         public void doWithMessage(WebServiceMessage responseMessage) throws IOException, TransformerException {             SoapMessage soapMessage = (SoapMessage) responseMessage.             if (ExchangeHelper.isOutCapable(exchange)) {                 exchange.getOut().copyFromWithNewBody(exchange.getIn(), soapMessage.getPayloadSource()).                 populateHeaderAndAttachmentsFromResponse(exchange.getOut(), soapMessage).             } else {                 exchange.getIn().setBody(soapMessage.getPayloadSource()).                 populateHeaderAndAttachmentsFromResponse(exchange.getIn(), soapMessage).             }         }     }). }
true;private;2;8;/**  * Populates soap message headers and attachments from soap response  */ ;/**  * Populates soap message headers and attachments from soap response  */ private void populateHeaderAndAttachmentsFromResponse(Message inOrOut, SoapMessage soapMessage) {     if (soapMessage.getSoapHeader() != null && getEndpoint().getConfiguration().isAllowResponseHeaderOverride()) {         populateMessageHeaderFromResponse(inOrOut, soapMessage.getSoapHeader()).     }     if (soapMessage.getAttachments() != null && getEndpoint().getConfiguration().isAllowResponseAttachmentOverride()) {         populateMessageAttachmentsFromResponse(inOrOut, soapMessage.getAttachments()).     } }
true;private;2;18;/**  * Populates message headers from soapHeader response  */ ;/**  * Populates message headers from soapHeader response  */ private void populateMessageHeaderFromResponse(Message message, SoapHeader soapHeader) {     message.setHeader(SpringWebserviceConstants.SPRING_WS_SOAP_HEADER, soapHeader.getSource()).     // Set header values for the soap header attributes     Iterator<QName> attIter = soapHeader.getAllAttributes().     while (attIter.hasNext()) {         QName name = attIter.next().         message.getHeaders().put(name.getLocalPart(), soapHeader.getAttributeValue(name)).     }     // Set header values for the soap header elements     Iterator<SoapHeaderElement> elementIter = soapHeader.examineAllHeaderElements().     while (elementIter.hasNext()) {         SoapHeaderElement element = elementIter.next().         QName name = element.getName().         message.getHeaders().put(name.getLocalPart(), element).     } }
true;private;2;6;/**  * Populates message attachments from soap response attachments  */ ;/**  * Populates message attachments from soap response attachments  */ private void populateMessageAttachmentsFromResponse(Message inOrOut, Iterator<Attachment> attachments) {     while (attachments.hasNext()) {         Attachment attachment = attachments.next().         inOrOut.getAttachments().put(attachment.getContentId(), attachment.getDataHandler()).     } }
false;private;1;39;;private void prepareMessageSenders(SpringWebserviceConfiguration configuration) {     // Skip this whole thing if none of the relevant config options are set.     if (!(configuration.getTimeout() > -1) && configuration.getSslContextParameters() == null) {         return.     }     WebServiceTemplate webServiceTemplate = configuration.getWebServiceTemplate().     WebServiceMessageSender[] messageSenders = webServiceTemplate.getMessageSenders().     for (int i = 0. i < messageSenders.length. i++) {         WebServiceMessageSender messageSender = messageSenders[i].         if (messageSender instanceof HttpComponentsMessageSender) {             if (configuration.getSslContextParameters() != null) {                 log.warn("Not applying SSLContextParameters based configuration to HttpComponentsMessageSender.  " + "If you are using this MessageSender, which you are not by default, you will need " + "to configure SSL using the Commons HTTP 3.x Protocol registry.").             }             if (configuration.getTimeout() > -1) {                 if (messageSender.getClass().equals(HttpComponentsMessageSender.class)) {                     ((HttpComponentsMessageSender) messageSender).setReadTimeout(configuration.getTimeout()).                 } else {                     log.warn("Not applying timeout configuration to HttpComponentsMessageSender based implementation.  " + "You are using what appears to be a custom MessageSender, which you are not doing by default. " + "You will need configure timeout on your own.").                 }             }         } else if (messageSender.getClass().equals(HttpUrlConnectionMessageSender.class)) {             // Only if exact match denoting likely use of default configuration.  We don't want to get             // sub-classes that might have been otherwise injected.             messageSenders[i] = new AbstractHttpWebServiceMessageSenderDecorator((HttpUrlConnectionMessageSender) messageSender, configuration, getEndpoint().getCamelContext()).         } else {             // For example this will be the case during unit-testing with the net.javacrumbs.spring-ws-test API             log.warn("Ignoring the timeout and SSLContextParameters options for {}.  You will need to configure " + "these options directly on your custom configured WebServiceMessageSender", messageSender).         }     } }
false;public;1;30;;@Override public WebServiceConnection createConnection(URI uri) throws IOException {     WebServiceConnection wsc = delegate.createConnection(uri).     if (wsc instanceof HttpUrlConnection) {         HttpURLConnection connection = ((HttpUrlConnection) wsc).getConnection().         if (configuration.getTimeout() > -1) {             connection.setReadTimeout(configuration.getTimeout()).         }         if (configuration.getSslContextParameters() != null && connection instanceof HttpsURLConnection) {             try {                 synchronized (this) {                     if (sslContext == null) {                         sslContext = configuration.getSslContextParameters().createSSLContext(camelContext).                     }                 }             } catch (GeneralSecurityException e) {                 throw new RuntimeCamelException("Error creating SSLContext based on SSLContextParameters.", e).             }             ((HttpsURLConnection) connection).setSSLSocketFactory(sslContext.getSocketFactory()).         }     } else {         throw new RuntimeCamelException("Unsupported delegate.  Delegate must return a org.springframework.ws.transport.http.HttpUrlConnection.  Found " + wsc.getClass()).     }     return wsc. }
false;public;0;4;;@Override public boolean isAcceptGzipEncoding() {     return delegate.isAcceptGzipEncoding(). }
false;public;1;4;;@Override public void setAcceptGzipEncoding(boolean acceptGzipEncoding) {     delegate.setAcceptGzipEncoding(acceptGzipEncoding). }
false;public;1;4;;@Override public boolean supports(URI uri) {     return delegate.supports(uri). }
false;public;1;34;;public void doWithMessage(WebServiceMessage message) throws IOException, TransformerException {     // Add SoapAction to webservice request. Note that exchange header     // takes precedence over endpoint option     String soapAction = soapActionHeader != null ? soapActionHeader : configuration.getSoapAction().     if (soapAction != null) {         new SoapActionCallback(soapAction).doWithMessage(message).     }     // Add WS-Addressing Action to webservice request (the WS-Addressing     // 'to' header will default to the URL of the connection).     // Note that exchange header takes precedence over endpoint option     URI wsAddressingAction = wsAddressingActionHeader != null ? wsAddressingActionHeader : configuration.getWsAddressingAction().     URI wsReplyTo = wsReplyToHeader != null ? wsReplyToHeader : configuration.getReplyTo().     URI wsFaultTo = wsFaultToHeader != null ? wsFaultToHeader : configuration.getFaultTo().     // Create the SOAP header     if (soapHeaderSource != null) {         SoapHeader header = ((SoapMessage) message).getSoapHeader().         toResult(soapHeaderSource, header.getResult()).     }     if (wsAddressingAction != null) {         ActionCallback actionCallback = new ActionCallback(wsAddressingAction).         if (wsReplyTo != null) {             actionCallback.setReplyTo(new EndpointReference(wsReplyTo)).         }         if (wsFaultTo != null) {             actionCallback.setFaultTo(new EndpointReference(wsFaultTo)).         }         actionCallback.doWithMessage(message).     }     configuration.getMessageFilter().filterProducer(exchange, message). }
