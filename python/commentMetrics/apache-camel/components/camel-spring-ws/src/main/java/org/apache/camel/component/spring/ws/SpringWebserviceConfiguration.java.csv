commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public WebServiceTemplate getWebServiceTemplate() {     return webServiceTemplate. }
true;public;1;3;/**  * Option to provide a custom WebServiceTemplate.  * This allows for full control over client-side web services handling. like adding a custom interceptor  * or specifying a fault resolver, message sender or message factory.  */ ;/**  * Option to provide a custom WebServiceTemplate.  * This allows for full control over client-side web services handling. like adding a custom interceptor  * or specifying a fault resolver, message sender or message factory.  */ public void setWebServiceTemplate(WebServiceTemplate webServiceTemplate) {     this.webServiceTemplate = webServiceTemplate. }
false;public;0;3;;public WebServiceMessageFactory getMessageFactory() {     return messageFactory. }
true;public;1;3;/**  * Option to provide a custom WebServiceMessageFactory. For example when you want Apache Axiom to handle web service messages instead of SAAJ.  */ ;/**  * Option to provide a custom WebServiceMessageFactory. For example when you want Apache Axiom to handle web service messages instead of SAAJ.  */ public void setMessageFactory(WebServiceMessageFactory messageFactory) {     this.messageFactory = messageFactory. }
false;public;0;3;;public String getWebServiceEndpointUri() {     return webServiceEndpointUri. }
true;public;1;3;/**  * The default Web Service endpoint uri to use for the producer.  */ ;/**  * The default Web Service endpoint uri to use for the producer.  */ public void setWebServiceEndpointUri(String webServiceEndpointUri) {     this.webServiceEndpointUri = webServiceEndpointUri. }
false;public;0;3;;public String getExpression() {     return expression. }
true;public;1;3;/**  * The XPath expression to use when option type=xpathresult. Then this option is required to be configured.  */ ;/**  * The XPath expression to use when option type=xpathresult. Then this option is required to be configured.  */ public void setExpression(String expression) {     this.expression = expression. }
false;public;0;3;;public String getSoapAction() {     return soapAction. }
true;public;1;3;/**  * SOAP action to include inside a SOAP request when accessing remote web services  */ ;/**  * SOAP action to include inside a SOAP request when accessing remote web services  */ public void setSoapAction(String soapAction) {     this.soapAction = soapAction. }
false;public;0;9;;public String getEndpointUri() {     if (endpointMappingKey != null) {         // only for consumers, use lookup key as endpoint uri/key         return encode(endpointMappingKey.getLookupKey()).     } else if (webServiceTemplate != null) {         return webServiceTemplate.getDefaultUri().     }     return null. }
false;public;0;3;;public URI getWsAddressingAction() {     return wsAddressingAction. }
true;public;1;3;/**  * WS-Addressing 1.0 action header to include when accessing web services.  * The To header is set to the address of the web service as specified in the endpoint URI (default Spring-WS behavior).  */ ;/**  * WS-Addressing 1.0 action header to include when accessing web services.  * The To header is set to the address of the web service as specified in the endpoint URI (default Spring-WS behavior).  */ public void setWsAddressingAction(URI wsAddressingAction) {     this.wsAddressingAction = wsAddressingAction. }
false;public;1;5;;public void setWsAddressingAction(String wsAddressingAction) throws URISyntaxException {     if (StringUtils.hasText(wsAddressingAction)) {         setWsAddressingAction(new URI(wsAddressingAction)).     } }
false;public;0;3;;public int getTimeout() {     return timeout. }
true;public;1;3;/**  * Sets the socket read timeout (in milliseconds) while invoking a webservice using the producer,  * see URLConnection.setReadTimeout() and CommonsHttpMessageSender.setReadTimeout().  * This option works when using the built-in message sender implementations:  * CommonsHttpMessageSender and HttpUrlConnectionMessageSender.  * One of these implementations will be used by default for HTTP based services unless you customize the  * Spring WS configuration options supplied to the component.  * If you are using a non-standard sender, it is assumed that you will handle your own timeout configuration.  * The built-in message sender HttpComponentsMessageSender is considered instead of CommonsHttpMessageSender  * which has been deprecated, see HttpComponentsMessageSender.setReadTimeout().  */ ;/**  * Sets the socket read timeout (in milliseconds) while invoking a webservice using the producer,  * see URLConnection.setReadTimeout() and CommonsHttpMessageSender.setReadTimeout().  * This option works when using the built-in message sender implementations:  * CommonsHttpMessageSender and HttpUrlConnectionMessageSender.  * One of these implementations will be used by default for HTTP based services unless you customize the  * Spring WS configuration options supplied to the component.  * If you are using a non-standard sender, it is assumed that you will handle your own timeout configuration.  * The built-in message sender HttpComponentsMessageSender is considered instead of CommonsHttpMessageSender  * which has been deprecated, see HttpComponentsMessageSender.setReadTimeout().  */ public void setTimeout(int timeout) {     this.timeout = timeout. }
false;public;0;3;;public CamelSpringWSEndpointMapping getEndpointMapping() {     return endpointMapping. }
true;public;1;3;/**  * Reference to an instance of org.apache.camel.component.spring.ws.bean.CamelEndpointMapping in the Registry/ApplicationContext.  * Only one bean is required in the registry to serve all Camel/Spring-WS endpoints.  * This bean is auto-discovered by the MessageDispatcher and used to map requests to Camel endpoints based  * on characteristics specified on the endpoint (like root QName, SOAP action, etc)  */ ;/**  * Reference to an instance of org.apache.camel.component.spring.ws.bean.CamelEndpointMapping in the Registry/ApplicationContext.  * Only one bean is required in the registry to serve all Camel/Spring-WS endpoints.  * This bean is auto-discovered by the MessageDispatcher and used to map requests to Camel endpoints based  * on characteristics specified on the endpoint (like root QName, SOAP action, etc)  */ public void setEndpointMapping(CamelSpringWSEndpointMapping endpointMapping) {     this.endpointMapping = endpointMapping. }
false;public;0;3;;public EndpointMappingKey getEndpointMappingKey() {     return endpointMappingKey. }
false;public;1;3;;public void setEndpointMappingKey(EndpointMappingKey endpointMappingKey) {     this.endpointMappingKey = endpointMappingKey. }
false;public;0;3;;public SSLContextParameters getSslContextParameters() {     return sslContextParameters. }
true;public;1;3;/**  * To configure security using SSLContextParameters  */ ;/**  * To configure security using SSLContextParameters  */ public void setSslContextParameters(SSLContextParameters sslContextParameters) {     this.sslContextParameters = sslContextParameters. }
false;public;0;3;;public CamelEndpointDispatcher getEndpointDispatcher() {     return endpointDispatcher. }
true;public;1;3;/**  * Spring {@link org.springframework.ws.server.endpoint.MessageEndpoint} for dispatching messages received by Spring-WS to a Camel endpoint,  * to integrate with existing (legacy) endpoint mappings like PayloadRootQNameEndpointMapping, SoapActionEndpointMapping, etc.  */ ;/**  * Spring {@link org.springframework.ws.server.endpoint.MessageEndpoint} for dispatching messages received by Spring-WS to a Camel endpoint,  * to integrate with existing (legacy) endpoint mappings like PayloadRootQNameEndpointMapping, SoapActionEndpointMapping, etc.  */ public void setEndpointDispatcher(CamelEndpointDispatcher endpointDispatcher) {     this.endpointDispatcher = endpointDispatcher. }
false;public,static;1;4;;public static String encode(String uri) {     int i = uri.lastIndexOf('}').     return i == -1 ? uri : (uri.subSequence(0, i) + ")" + uri.substring(i + 1)).replaceFirst("\\{", "("). }
false;public,static;1;4;;public static String decode(String uri) {     int i = uri.lastIndexOf(')').     return i == -1 ? uri : (uri.subSequence(0, i) + "}" + uri.substring(i + 1)).replaceFirst("\\(", "{"). }
true;public;1;3;/**  * Option to provide a custom MessageFilter. For example when you want to process your headers or attachments by your own.  */ ;/**  * Option to provide a custom MessageFilter. For example when you want to process your headers or attachments by your own.  */ public void setMessageFilter(MessageFilter messageFilter) {     this.messageFilter = messageFilter. }
false;public;0;3;;public MessageFilter getMessageFilter() {     return messageFilter. }
false;public;0;3;;public URI getOutputAction() {     return outputAction. }
true;public;1;3;/**  * Signifies the value for the response WS-Addressing <code>Action</code>  * header that is provided by the method.  *  * @see {@link Action}  */ ;/**  * Signifies the value for the response WS-Addressing <code>Action</code>  * header that is provided by the method.  *  * @see {@link Action}  */ public void setOutputAction(URI outputAction) {     this.outputAction = outputAction. }
false;public;1;5;;public void setOutputAction(String output) throws URISyntaxException {     if (StringUtils.hasText(output)) {         setOutputAction(new URI(output)).     } }
false;public;0;3;;public URI getFaultAction() {     return faultAction. }
true;public;1;5;/**  * Signifies the value for the faultAction response WS-Addressing  * <code>Fault Action</code> header that is provided by the method.  *  * @see {@link Action}  */ ;/**  * Signifies the value for the faultAction response WS-Addressing  * <code>Fault Action</code> header that is provided by the method.  *  * @see {@link Action}  */ public void setFaultAction(String fault) throws URISyntaxException {     if (StringUtils.hasText(fault)) {         setFaultAction(new URI(fault)).     } }
true;public;1;3;/**  * Signifies the value for the faultAction response WS-Addressing  * <code>Fault Action</code> header that is provided by the method.  *  * @see {@link Action}  */ ;/**  * Signifies the value for the faultAction response WS-Addressing  * <code>Fault Action</code> header that is provided by the method.  *  * @see {@link Action}  */ public void setFaultAction(URI fault) {     this.faultAction = fault. }
false;public;0;3;;public URI getFaultTo() {     return faultTo. }
true;public;1;5;/**  * Signifies the value for the faultAction response WS-Addressing  * <code>FaultTo</code> header that is provided by the method.  *  * @see {@link Action}  */ ;/**  * Signifies the value for the faultAction response WS-Addressing  * <code>FaultTo</code> header that is provided by the method.  *  * @see {@link Action}  */ public void setFaultTo(String faultTo) throws URISyntaxException {     if (StringUtils.hasText(faultTo)) {         setFaultTo(new URI(faultTo)).     } }
true;public;1;3;/**  * Signifies the value for the faultAction response WS-Addressing  * <code>FaultTo</code> header that is provided by the method.  *  * @see {@link Action}  */ ;/**  * Signifies the value for the faultAction response WS-Addressing  * <code>FaultTo</code> header that is provided by the method.  *  * @see {@link Action}  */ public void setFaultTo(URI faultTo) {     this.faultTo = faultTo. }
false;public;0;3;;public URI getReplyTo() {     return replyTo. }
true;public;1;5;/**  * Signifies the value for the replyTo response WS-Addressing  * <code>ReplyTo</code> header that is provided by the method.  *  * @see {@link Action}  */ ;/**  * Signifies the value for the replyTo response WS-Addressing  * <code>ReplyTo</code> header that is provided by the method.  *  * @see {@link Action}  */ public void setReplyTo(String replyToAction) throws URISyntaxException {     if (StringUtils.hasText(replyToAction)) {         setReplyTo(new URI(replyToAction)).     } }
true;public;1;3;/**  * Signifies the value for the replyTo response WS-Addressing  * <code>ReplyTo</code> header that is provided by the method.  *  * @see {@link Action}  */ ;/**  * Signifies the value for the replyTo response WS-Addressing  * <code>ReplyTo</code> header that is provided by the method.  *  * @see {@link Action}  */ public void setReplyTo(URI replyToAction) {     this.replyTo = replyToAction. }
false;public;0;3;;public WebServiceMessageSender getMessageSender() {     return messageSender. }
true;public;1;3;/**  * Option to provide a custom WebServiceMessageSender. For example to perform authentication or use alternative transports  */ ;/**  * Option to provide a custom WebServiceMessageSender. For example to perform authentication or use alternative transports  */ public void setMessageSender(WebServiceMessageSender messageSender) {     this.messageSender = messageSender. }
false;public;0;3;;public MessageIdStrategy getMessageIdStrategy() {     return messageIdStrategy. }
true;public;1;3;/**  * Option to provide a custom MessageIdStrategy to control generation of unique message ids.  */ ;/**  * Option to provide a custom MessageIdStrategy to control generation of unique message ids.  */ public void setMessageIdStrategy(MessageIdStrategy messageIdStrategy) {     this.messageIdStrategy = messageIdStrategy. }
false;public;0;3;;public boolean isAllowResponseHeaderOverride() {     return allowResponseHeaderOverride. }
true;public;1;3;/**  * Option to override soap response header in in/out exchange with header info from the actual service layer.  * If the invoked service appends or rewrites the soap header this option when set to true, allows the modified  * soap header to be overwritten in in/out message headers  *  * @param allowResponseHeaderOverride - true, will override header with spring-ws response message header  */ ;/**  * Option to override soap response header in in/out exchange with header info from the actual service layer.  * If the invoked service appends or rewrites the soap header this option when set to true, allows the modified  * soap header to be overwritten in in/out message headers  *  * @param allowResponseHeaderOverride - true, will override header with spring-ws response message header  */ public void setAllowResponseHeaderOverride(boolean allowResponseHeaderOverride) {     this.allowResponseHeaderOverride = allowResponseHeaderOverride. }
false;public;0;3;;public boolean isAllowResponseAttachmentOverride() {     return allowResponseAttachmentOverride. }
true;public;1;3;/**  * Option to override soap response attachments in in/out exchange with attachments from the actual service layer.  * If the invoked service appends or rewrites the soap attachments this option when set to true, allows the modified  * soap attachments to be overwritten in in/out message attachments  *  * @param allowResponseAttachmentOverride - true, will override attachments with spring-ws response message attachments  */ ;/**  * Option to override soap response attachments in in/out exchange with attachments from the actual service layer.  * If the invoked service appends or rewrites the soap attachments this option when set to true, allows the modified  * soap attachments to be overwritten in in/out message attachments  *  * @param allowResponseAttachmentOverride - true, will override attachments with spring-ws response message attachments  */ public void setAllowResponseAttachmentOverride(boolean allowResponseAttachmentOverride) {     this.allowResponseAttachmentOverride = allowResponseAttachmentOverride. }
