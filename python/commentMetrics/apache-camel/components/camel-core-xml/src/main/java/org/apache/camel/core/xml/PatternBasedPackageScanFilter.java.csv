commented;modifiers;parameterAmount;loc;comment;code
true;public;1;6;/**  * add and exclude pattern to the filter. Classes matching this pattern will  * not match the filter  */ ;/**  * add and exclude pattern to the filter. Classes matching this pattern will  * not match the filter  */ public void addExcludePattern(String excludePattern) {     if (excludePatterns == null) {         excludePatterns = new ArrayList<>().     }     excludePatterns.add(excludePattern). }
true;public;1;6;/**  * add and include pattern to the filter. Classes must match one of supplied  * include patterns to match the filter  */ ;/**  * add and include pattern to the filter. Classes must match one of supplied  * include patterns to match the filter  */ public void addIncludePattern(String includePattern) {     if (includePatterns == null) {         includePatterns = new ArrayList<>().     }     includePatterns.add(includePattern). }
false;public;1;6;;public void addIncludePatterns(Collection<String> includes) {     if (includePatterns == null) {         includePatterns = new ArrayList<>().     }     includePatterns.addAll(includes). }
false;public;1;6;;public void addExcludePatterns(Collection<String> excludes) {     if (excludePatterns == null) {         excludePatterns = new ArrayList<>().     }     excludePatterns.addAll(excludes). }
true;public;1;17;/**  * Tests if a given class matches the patterns in this filter. Patterns are  * specified by {@link AntPathMatcher}  * <p>  * if no include or exclude patterns are set then all classes match.  * <p>  * If the filter contains only include filters, then the candidate class  * must match one of the include patterns to match the filter and return  * true.  * <p>  * If the filter contains only exclude filters, then the filter will return  * true unless the candidate class matches an exclude pattern.  * <p>  * if this contains both include and exclude filters, then the above rules  * apply with excludes taking precedence over includes i.e. an include  * pattern of java.util.* and an exclude pattern of java.util.jar.* will  * include a file only if it is in the util pkg and not in the util.jar  * package.  *  * @return true if candidate class matches according to the above rules  */ ;/**  * Tests if a given class matches the patterns in this filter. Patterns are  * specified by {@link AntPathMatcher}  * <p>  * if no include or exclude patterns are set then all classes match.  * <p>  * If the filter contains only include filters, then the candidate class  * must match one of the include patterns to match the filter and return  * true.  * <p>  * If the filter contains only exclude filters, then the filter will return  * true unless the candidate class matches an exclude pattern.  * <p>  * if this contains both include and exclude filters, then the above rules  * apply with excludes taking precedence over includes i.e. an include  * pattern of java.util.* and an exclude pattern of java.util.jar.* will  * include a file only if it is in the util pkg and not in the util.jar  * package.  *  * @return true if candidate class matches according to the above rules  */ public boolean matches(Class<?> candidateClass) {     String candidate = candidateClass.getName().     if (includePatterns != null || excludePatterns != null) {         if (excludePatterns != null && excludePatterns.size() > 0) {             if (matchesAny(excludePatterns, candidate)) {                 return false.             }         }         if (includePatterns != null && includePatterns.size() > 0) {             return matchesAny(includePatterns, candidate).         }     }     return true. }
false;private;2;8;;private boolean matchesAny(List<String> patterns, String candidate) {     for (String pattern : patterns) {         if (matcher.match(pattern, candidate)) {             return true.         }     }     return false. }
