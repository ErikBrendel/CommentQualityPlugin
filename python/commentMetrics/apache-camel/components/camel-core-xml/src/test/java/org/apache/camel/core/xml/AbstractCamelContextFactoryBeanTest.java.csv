commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public <T> T newInstance(Class<T> type) {     return ObjectHelper.newInstance(type). }
false;public;0;4;;@Override public boolean supportsAutoWiring() {     return false. }
false;public;0;54;;@Test public void shouldSupportPropertyPlaceholdersOnAllProperties() throws Exception {     final Set<Invocation> invocations = new LinkedHashSet<>().     final ModelCamelContext context = mock(ModelCamelContext.class, withSettings().invocationListeners(i -> invocations.add((Invocation) i.getInvocation()))).     // program the property resolution in context mock     when(context.resolvePropertyPlaceholders(anyString())).thenAnswer(invocation -> {         final String placeholder = invocation.getArgument(0).         // value that can be converted to boolean         if (valuesThatReturnBoolean.contains(placeholder) || placeholder.endsWith("Enabled}}")) {             return "true".         }         // or long         if (valuesThatReturnLong.contains(placeholder)) {             return "1".         }         // else is just plain string         return "string".     }).     when(context.getTypeConverter()).thenReturn(typeConverter).     when(context.getRuntimeEndpointRegistry()).thenReturn(mock(RuntimeEndpointRegistry.class)).     when(context.getManagementNameStrategy()).thenReturn(mock(ManagementNameStrategy.class)).     when(context.getExecutorServiceManager()).thenReturn(mock(ExecutorServiceManager.class)).     @SuppressWarnings("unchecked")     final AbstractCamelContextFactoryBean<ModelCamelContext> factory = mock(AbstractCamelContextFactoryBean.class).     when(factory.getContext()).thenReturn(context).     doCallRealMethod().when(factory).initCamelContext(context).     final Set<String> expectedPropertiesToBeResolved = propertiesToBeResolved(factory).     // method under test     factory.initCamelContext(context).     // we want to capture the arguments initCamelContext tried to resolve     // and check if it tried to resolve all placeholders we expected     final ArgumentCaptor<String> capturedPlaceholders = ArgumentCaptor.forClass(String.class).     verify(context, atLeastOnce()).resolvePropertyPlaceholders(capturedPlaceholders.capture()).     // removes any properties that are not using property placeholders     expectedPropertiesToBeResolved.removeAll(propertiesThatAreNotPlaceholdered).     assertThat(capturedPlaceholders.getAllValues()).as("The expectation is that all abstract getter methods that return Strings should support property " + "placeholders, and that for those will delegate to CamelContext::resolvePropertyPlaceholders, " + "we captured all placeholders that tried to resolve and found differences").containsAll(expectedPropertiesToBeResolved). }
false;;1;32;;Set<String> propertiesToBeResolved(final AbstractCamelContextFactoryBean<ModelCamelContext> factory) {     final Set<String> expectedPropertiesToBeResolved = new HashSet<>().     // looks at all abstract methods in AbstractCamelContextFactoryBean that     // do have no declared parameters and programs the mock to return     // "{{methodName}}" on calling that method, this happens when     // AbstractCamelContextFactoryBean::initContext invokes the programmed     // mock, so the returned collection will be empty until initContext     // invokes the mocked method     stream(AbstractCamelContextFactoryBean.class.getDeclaredMethods()).filter(m -> Modifier.isAbstract(m.getModifiers()) && m.getParameterCount() == 0).forEach(m -> {         try {             when(m.invoke(factory)).thenAnswer(invocation -> {                 final Method method = invocation.getMethod().                 final String name = method.getName().                 if (String.class.equals(method.getReturnType())) {                     final String placeholder = "{{" + name + "}}".                     expectedPropertiesToBeResolved.add(placeholder).                     return placeholder.                 }                 return null.             }).         } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException ignored) {         // ignored         }     }).     return expectedPropertiesToBeResolved. }
false;static;1;12;;static boolean shouldProvidePropertyPlaceholderSupport(final Method method) {     // all abstract getter methods that return String are possibly returning     // strings that contain property placeholders     final boolean isAbstract = Modifier.isAbstract(method.getModifiers()).     final boolean isGetter = method.getName().startsWith("get").     final Class<?> returnType = method.getReturnType().     final boolean isCompatibleReturnType = String.class.isAssignableFrom(returnType).     return isAbstract && isGetter && isCompatibleReturnType. }
