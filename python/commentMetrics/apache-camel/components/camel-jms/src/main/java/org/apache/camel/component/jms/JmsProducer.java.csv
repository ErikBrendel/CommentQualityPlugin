commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public JmsEndpoint getEndpoint() {     return (JmsEndpoint) super.getEndpoint(). }
false;protected;0;45;;protected void initReplyManager() {     if (!started.get()) {         synchronized (this) {             if (started.get()) {                 return.             }             // must use the classloader from the application context when creating reply manager,             // as it should inherit the classloader from app context and not the current which may be             // a different classloader             ClassLoader current = Thread.currentThread().getContextClassLoader().             ClassLoader ac = endpoint.getCamelContext().getApplicationContextClassLoader().             try {                 if (ac != null) {                     Thread.currentThread().setContextClassLoader(ac).                 }                 // validate that replyToType and replyTo is configured accordingly                 if (endpoint.getReplyToType() != null) {                     // setting temporary with a fixed replyTo is not supported                     if (endpoint.getReplyTo() != null && endpoint.getReplyToType().equals(ReplyToType.Temporary.name())) {                         throw new IllegalArgumentException("ReplyToType " + ReplyToType.Temporary + " is not supported when replyTo " + endpoint.getReplyTo() + " is also configured.").                     }                 }                 if (endpoint.getReplyTo() != null) {                     replyManager = createReplyManager(endpoint.getReplyTo()).                     if (log.isDebugEnabled()) {                         log.debug("Using JmsReplyManager: {} to process replies from: {}", replyManager, endpoint.getReplyTo()).                     }                 } else {                     replyManager = createReplyManager().                     log.debug("Using JmsReplyManager: {} to process replies from temporary queue", replyManager).                 }             } catch (Exception e) {                 throw new FailedToCreateProducerException(endpoint, e).             } finally {                 if (ac != null) {                     Thread.currentThread().setContextClassLoader(current).                 }             }             started.set(true).         }     } }
false;protected;0;15;;protected void unInitReplyManager() {     try {         if (replyManager != null) {             if (log.isDebugEnabled()) {                 log.debug("Stopping JmsReplyManager: {} from processing replies from: {}", replyManager, endpoint.getReplyTo() != null ? endpoint.getReplyTo() : "temporary queue").             }             ServiceHelper.stopService(replyManager).         }     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } finally {         started.set(false).     } }
false;public;2;27;;public boolean process(Exchange exchange, AsyncCallback callback) {     // deny processing if we are not started     if (!isRunAllowed()) {         if (exchange.getException() == null) {             exchange.setException(new RejectedExecutionException()).         }         // we cannot process so invoke callback         callback.done(true).         return true.     }     try {         if (!endpoint.isDisableReplyTo() && exchange.getPattern().isOutCapable()) {             // in out requires a bit more work than in only             return processInOut(exchange, callback).         } else {             // in only             return processInOnly(exchange, callback).         }     } catch (Throwable e) {         // must catch exception to ensure callback is invoked as expected         // to let Camel error handling deal with this         exchange.setException(e).         callback.done(true).         return true.     } }
false;public;1;32;;public Message createMessage(Session session) throws JMSException {     Message answer = endpoint.getBinding().makeJmsMessage(exchange, in, session, null).     Destination replyTo = null.     String replyToOverride = configuration.getReplyToOverride().     if (replyToOverride != null) {         replyTo = resolveOrCreateDestination(replyToOverride, session).     } else {         // get the reply to destination to be used from the reply manager         replyTo = replyManager.getReplyTo().     }     if (replyTo == null) {         throw new RuntimeExchangeException("Failed to resolve replyTo destination", exchange).     }     JmsMessageHelper.setJMSReplyTo(answer, replyTo).     replyManager.setReplyToSelectorHeader(in, answer).     String correlationId = determineCorrelationId(answer, provisionalCorrelationId).     replyManager.registerReply(replyManager, exchange, callback, originalCorrelationId, correlationId, timeout).     if (correlationProperty != null) {         replyManager.setCorrelationProperty(correlationProperty).     }     if (log.isDebugEnabled()) {         log.debug("Using {}: {}, JMSReplyTo destination: {}, with request timeout: {} ms.", new Object[] { correlationPropertyToUse, correlationId, replyTo, timeout }).     }     log.trace("Created javax.jms.Message: {}", answer).     return answer. }
false;protected;2;91;;protected boolean processInOut(final Exchange exchange, final AsyncCallback callback) {     final org.apache.camel.Message in = exchange.getIn().     String destinationName = in.getHeader(JmsConstants.JMS_DESTINATION_NAME, String.class).     // remove the header so it wont be propagated     in.removeHeader(JmsConstants.JMS_DESTINATION_NAME).     if (destinationName == null) {         destinationName = endpoint.getDestinationName().     }     Destination destination = in.getHeader(JmsConstants.JMS_DESTINATION, Destination.class).     // remove the header so it wont be propagated     in.removeHeader(JmsConstants.JMS_DESTINATION).     if (destination == null) {         destination = endpoint.getDestination().     }     if (destination != null) {         // prefer to use destination over destination name         destinationName = null.     }     initReplyManager().     // the request timeout can be overruled by a header otherwise the endpoint configured value is used     final long timeout = exchange.getIn().getHeader(JmsConstants.JMS_REQUEST_TIMEOUT, endpoint.getRequestTimeout(), long.class).     final JmsConfiguration configuration = endpoint.getConfiguration().     // when using message id as correlation id, we need at first to use a provisional correlation id     // which we then update to the real JMSMessageID when the message has been sent     // this is done with the help of the MessageSentCallback     final boolean msgIdAsCorrId = configuration.isUseMessageIDAsCorrelationID().     final String provisionalCorrelationId = msgIdAsCorrId ? getUuidGenerator().generateUuid() : null.     MessageSentCallback messageSentCallback = null.     if (msgIdAsCorrId) {         messageSentCallback = new UseMessageIdAsCorrelationIdMessageSentCallback(replyManager, provisionalCorrelationId, timeout).     }     final String correlationProperty = configuration.getCorrelationProperty().     final String correlationPropertyToUse = ofNullable(correlationProperty).orElse("JMSCorrelationID").     final String originalCorrelationId = in.getHeader(correlationPropertyToUse, String.class).     boolean generateFreshCorrId = (ObjectHelper.isEmpty(originalCorrelationId) && !msgIdAsCorrId) || (originalCorrelationId != null && originalCorrelationId.startsWith(GENERATED_CORRELATION_ID_PREFIX)).     if (generateFreshCorrId) {         // we append the 'Camel-' prefix to know it was generated by us         in.setHeader(correlationPropertyToUse, GENERATED_CORRELATION_ID_PREFIX + getUuidGenerator().generateUuid()).     }     MessageCreator messageCreator = new MessageCreator() {          public Message createMessage(Session session) throws JMSException {             Message answer = endpoint.getBinding().makeJmsMessage(exchange, in, session, null).             Destination replyTo = null.             String replyToOverride = configuration.getReplyToOverride().             if (replyToOverride != null) {                 replyTo = resolveOrCreateDestination(replyToOverride, session).             } else {                 // get the reply to destination to be used from the reply manager                 replyTo = replyManager.getReplyTo().             }             if (replyTo == null) {                 throw new RuntimeExchangeException("Failed to resolve replyTo destination", exchange).             }             JmsMessageHelper.setJMSReplyTo(answer, replyTo).             replyManager.setReplyToSelectorHeader(in, answer).             String correlationId = determineCorrelationId(answer, provisionalCorrelationId).             replyManager.registerReply(replyManager, exchange, callback, originalCorrelationId, correlationId, timeout).             if (correlationProperty != null) {                 replyManager.setCorrelationProperty(correlationProperty).             }             if (log.isDebugEnabled()) {                 log.debug("Using {}: {}, JMSReplyTo destination: {}, with request timeout: {} ms.", new Object[] { correlationPropertyToUse, correlationId, replyTo, timeout }).             }             log.trace("Created javax.jms.Message: {}", answer).             return answer.         }     }.     doSend(true, destinationName, destination, messageCreator, messageSentCallback).     // continue routing asynchronously (reply will be processed async when its received)     return false. }
true;protected;2;28;/**  * Strategy to determine which correlation id to use among <tt>JMSMessageID</tt> and <tt>JMSCorrelationID</tt>.  *  * @param message   the JMS message  * @param provisionalCorrelationId an optional provisional correlation id, which is preferred to be used  * @return the correlation id to use  * @throws JMSException can be thrown  */ ;/**  * Strategy to determine which correlation id to use among <tt>JMSMessageID</tt> and <tt>JMSCorrelationID</tt>.  *  * @param message   the JMS message  * @param provisionalCorrelationId an optional provisional correlation id, which is preferred to be used  * @return the correlation id to use  * @throws JMSException can be thrown  */ protected String determineCorrelationId(Message message, String provisionalCorrelationId) throws JMSException {     if (provisionalCorrelationId != null) {         return provisionalCorrelationId.     }     final JmsConfiguration configuration = endpoint.getConfiguration().     final String correlationProperty = configuration.getCorrelationProperty().     final String messageId = message.getJMSMessageID().     final String correlationId = message.getJMSCorrelationID().     final String correlationPropertyValue.     if (correlationProperty == null) {         correlationPropertyValue = null.     } else {         correlationPropertyValue = message.getStringProperty(correlationProperty).     }     if (!ObjectHelper.isEmpty(correlationPropertyValue)) {         return correlationPropertyValue.     } else if (configuration.isUseMessageIDAsCorrelationID()) {         return messageId.     } else if (ObjectHelper.isEmpty(correlationId)) {         // correlation id is empty so fallback to message id         return messageId.     } else {         return correlationId.     } }
false;public;1;66;;public Message createMessage(Session session) throws JMSException {     Message answer = endpoint.getBinding().makeJmsMessage(exchange, in, session, null).     // when in InOnly mode the JMSReplyTo is a bit complicated     // we only want to set the JMSReplyTo on the answer if     // there is a JMSReplyTo from the header/endpoint and     // we have been told to preserveMessageQos     Object jmsReplyTo = JmsMessageHelper.getJMSReplyTo(answer).     if (endpoint.isDisableReplyTo()) {         // honor disable reply to configuration         log.trace("ReplyTo is disabled on endpoint: {}", endpoint).         JmsMessageHelper.setJMSReplyTo(answer, null).     } else {         // if the binding did not create the reply to then we have to try to create it here         if (jmsReplyTo == null) {             // prefer reply to from header over endpoint configured             jmsReplyTo = exchange.getIn().getHeader("JMSReplyTo", String.class).             if (jmsReplyTo == null) {                 jmsReplyTo = endpoint.getReplyTo().             }         }     }     // unless we use preserveMessageQos=true to tell that we still want to use JMSReplyTo     if (jmsReplyTo != null && !(endpoint.isPreserveMessageQos() || endpoint.isExplicitQosEnabled())) {         // this behavior is also documented at the camel website         if (log.isDebugEnabled()) {             log.debug("Disabling JMSReplyTo: {} for destination: {}. Use preserveMessageQos=true to force Camel to keep the JMSReplyTo on endpoint: {}", new Object[] { jmsReplyTo, to, endpoint }).         }         jmsReplyTo = null.     }     // and if needed create the destination using the session if needed to     if (jmsReplyTo instanceof String) {         String replyTo = (String) jmsReplyTo.         // we need to null it as we use the String to resolve it as a Destination instance         jmsReplyTo = resolveOrCreateDestination(replyTo, session).     }     // set the JMSReplyTo on the answer if we are to use it     Destination replyTo = null.     String replyToOverride = endpoint.getConfiguration().getReplyToOverride().     if (replyToOverride != null) {         replyTo = resolveOrCreateDestination(replyToOverride, session).     } else if (jmsReplyTo instanceof Destination) {         replyTo = (Destination) jmsReplyTo.     }     if (replyTo != null) {         log.debug("Using JMSReplyTo destination: {}", replyTo).         JmsMessageHelper.setJMSReplyTo(answer, replyTo).     } else {         // do not use JMSReplyTo         log.trace("Not using JMSReplyTo").         JmsMessageHelper.setJMSReplyTo(answer, null).     }     log.trace("Created javax.jms.Message: {}", answer).     return answer. }
false;protected;2;106;;protected boolean processInOnly(final Exchange exchange, final AsyncCallback callback) {     final org.apache.camel.Message in = exchange.getIn().     String destinationName = in.getHeader(JmsConstants.JMS_DESTINATION_NAME, String.class).     if (destinationName != null) {         // remove the header so it wont be propagated         in.removeHeader(JmsConstants.JMS_DESTINATION_NAME).     }     if (destinationName == null) {         destinationName = endpoint.getDestinationName().     }     Destination destination = in.getHeader(JmsConstants.JMS_DESTINATION, Destination.class).     if (destination != null) {         // remove the header so it wont be propagated         in.removeHeader(JmsConstants.JMS_DESTINATION).     }     if (destination == null) {         destination = endpoint.getDestination().     }     if (destination != null) {         // prefer to use destination over destination name         destinationName = null.     }     final String to = destinationName != null ? destinationName : "" + destination.     MessageSentCallback messageSentCallback = getEndpoint().getConfiguration().isIncludeSentJMSMessageID() ? new InOnlyMessageSentCallback(exchange) : null.     MessageCreator messageCreator = new MessageCreator() {          public Message createMessage(Session session) throws JMSException {             Message answer = endpoint.getBinding().makeJmsMessage(exchange, in, session, null).             // when in InOnly mode the JMSReplyTo is a bit complicated             // we only want to set the JMSReplyTo on the answer if             // there is a JMSReplyTo from the header/endpoint and             // we have been told to preserveMessageQos             Object jmsReplyTo = JmsMessageHelper.getJMSReplyTo(answer).             if (endpoint.isDisableReplyTo()) {                 // honor disable reply to configuration                 log.trace("ReplyTo is disabled on endpoint: {}", endpoint).                 JmsMessageHelper.setJMSReplyTo(answer, null).             } else {                 // if the binding did not create the reply to then we have to try to create it here                 if (jmsReplyTo == null) {                     // prefer reply to from header over endpoint configured                     jmsReplyTo = exchange.getIn().getHeader("JMSReplyTo", String.class).                     if (jmsReplyTo == null) {                         jmsReplyTo = endpoint.getReplyTo().                     }                 }             }             // unless we use preserveMessageQos=true to tell that we still want to use JMSReplyTo             if (jmsReplyTo != null && !(endpoint.isPreserveMessageQos() || endpoint.isExplicitQosEnabled())) {                 // this behavior is also documented at the camel website                 if (log.isDebugEnabled()) {                     log.debug("Disabling JMSReplyTo: {} for destination: {}. Use preserveMessageQos=true to force Camel to keep the JMSReplyTo on endpoint: {}", new Object[] { jmsReplyTo, to, endpoint }).                 }                 jmsReplyTo = null.             }             // and if needed create the destination using the session if needed to             if (jmsReplyTo instanceof String) {                 String replyTo = (String) jmsReplyTo.                 // we need to null it as we use the String to resolve it as a Destination instance                 jmsReplyTo = resolveOrCreateDestination(replyTo, session).             }             // set the JMSReplyTo on the answer if we are to use it             Destination replyTo = null.             String replyToOverride = endpoint.getConfiguration().getReplyToOverride().             if (replyToOverride != null) {                 replyTo = resolveOrCreateDestination(replyToOverride, session).             } else if (jmsReplyTo instanceof Destination) {                 replyTo = (Destination) jmsReplyTo.             }             if (replyTo != null) {                 log.debug("Using JMSReplyTo destination: {}", replyTo).                 JmsMessageHelper.setJMSReplyTo(answer, replyTo).             } else {                 // do not use JMSReplyTo                 log.trace("Not using JMSReplyTo").                 JmsMessageHelper.setJMSReplyTo(answer, null).             }             log.trace("Created javax.jms.Message: {}", answer).             return answer.         }     }.     doSend(false, destinationName, destination, messageCreator, messageSentCallback).     // after sending then set the OUT message id to the JMSMessageID so its identical     setMessageId(exchange).     // we are synchronous so return true     callback.done(true).     return true. }
true;protected;5;34;/**  * Sends the message using the JmsTemplate.  *  * @param inOut           use inOut or inOnly template  * @param destinationName the destination name  * @param destination     the destination (if no name provided)  * @param messageCreator  the creator to create the {@link Message} to send  * @param callback        optional callback to invoke when message has been sent  */ ;/**  * Sends the message using the JmsTemplate.  *  * @param inOut           use inOut or inOnly template  * @param destinationName the destination name  * @param destination     the destination (if no name provided)  * @param messageCreator  the creator to create the {@link Message} to send  * @param callback        optional callback to invoke when message has been sent  */ protected void doSend(boolean inOut, String destinationName, Destination destination, MessageCreator messageCreator, MessageSentCallback callback) {     CamelJmsTemplate template = (CamelJmsTemplate) (inOut ? getInOutTemplate() : getInOnlyTemplate()).     if (log.isTraceEnabled()) {         log.trace("Using {} jms template", inOut ? "inOut" : "inOnly").     }     // destination should be preferred     if (destination != null) {         if (inOut) {             if (template != null) {                 template.send(destination, messageCreator, callback).             }         } else {             if (template != null) {                 template.send(destination, messageCreator, callback).             }         }     } else if (destinationName != null) {         if (inOut) {             if (template != null) {                 template.send(destinationName, messageCreator, callback).             }         } else {             if (template != null) {                 template.send(destinationName, messageCreator, callback).             }         }     } else {         throw new IllegalArgumentException("Neither destination nor destinationName is specified on this endpoint: " + endpoint).     } }
false;protected;2;32;;protected Destination resolveOrCreateDestination(String destinationName, Session session) throws JMSException {     Destination dest = null.     boolean isPubSub = isTopicPrefix(destinationName) || (!isQueuePrefix(destinationName) && endpoint.isPubSubDomain()).     // try using destination resolver to lookup the destination     if (endpoint.getDestinationResolver() != null) {         dest = endpoint.getDestinationResolver().resolveDestinationName(session, destinationName, isPubSub).         if (log.isDebugEnabled()) {             log.debug("Resolved JMSReplyTo destination {} using DestinationResolver {} as PubSubDomain {} -> {}", new Object[] { destinationName, endpoint.getDestinationResolver(), isPubSub, dest }).         }     }     if (dest == null) {         // must normalize the destination name         String before = destinationName.         destinationName = normalizeDestinationName(destinationName).         log.trace("Normalized JMSReplyTo destination name {} -> {}", before, destinationName).         // okay then fallback and create the queue/topic         if (isPubSub) {             log.debug("Creating JMSReplyTo topic: {}", destinationName).             dest = session.createTopic(destinationName).         } else {             log.debug("Creating JMSReplyTo queue: {}", destinationName).             dest = session.createQueue(destinationName).         }     }     return dest. }
false;protected;1;12;;protected void setMessageId(Exchange exchange) {     if (exchange.hasOut()) {         JmsMessage out = exchange.getOut(JmsMessage.class).         try {             if (out != null && out.getJmsMessage() != null) {                 out.setMessageId(out.getJmsMessage().getJMSMessageID()).             }         } catch (JMSException e) {             log.warn("Unable to retrieve JMSMessageID from outgoing JMS Message and set it into Camel's MessageId", e).         }     } }
false;public;0;6;;public JmsOperations getInOnlyTemplate() {     if (inOnlyTemplate == null) {         inOnlyTemplate = endpoint.createInOnlyTemplate().     }     return inOnlyTemplate. }
false;public;1;3;;public void setInOnlyTemplate(JmsOperations inOnlyTemplate) {     this.inOnlyTemplate = inOnlyTemplate. }
false;public;0;6;;public JmsOperations getInOutTemplate() {     if (inOutTemplate == null) {         inOutTemplate = endpoint.createInOutTemplate().     }     return inOutTemplate. }
false;public;1;3;;public void setInOutTemplate(JmsOperations inOutTemplate) {     this.inOutTemplate = inOutTemplate. }
false;public;0;3;;public UuidGenerator getUuidGenerator() {     return uuidGenerator. }
false;public;1;3;;public void setUuidGenerator(UuidGenerator uuidGenerator) {     this.uuidGenerator = uuidGenerator. }
true;protected;0;16;/**  * Pre tests the connection before starting the listening.  * <p/>  * In case of connection failure the exception is thrown which prevents Camel from starting.  *  * @throws FailedToCreateProducerException is thrown if testing the connection failed  */ ;/**  * Pre tests the connection before starting the listening.  * <p/>  * In case of connection failure the exception is thrown which prevents Camel from starting.  *  * @throws FailedToCreateProducerException is thrown if testing the connection failed  */ protected void testConnectionOnStartup() throws FailedToCreateProducerException {     try {         CamelJmsTemplate template = (CamelJmsTemplate) getInOnlyTemplate().         if (log.isDebugEnabled()) {             log.debug("Testing JMS Connection on startup for destination: {}", template.getDefaultDestinationName()).         }         Connection conn = template.getConnectionFactory().createConnection().         JmsUtils.closeConnection(conn).         log.debug("Successfully tested JMS Connection on startup for destination: {}", template.getDefaultDestinationName()).     } catch (Exception e) {         throw new FailedToCreateProducerException(getEndpoint(), e).     } }
false;protected;0;10;;protected void doStart() throws Exception {     super.doStart().     if (uuidGenerator == null) {         // use the generator configured on the camel context         uuidGenerator = getEndpoint().getCamelContext().getUuidGenerator().     }     if (endpoint.isTestConnectionOnStartup()) {         testConnectionOnStartup().     } }
false;protected;0;6;;protected void doStop() throws Exception {     super.doStop().     // must stop/un-init reply manager if it was in use     unInitReplyManager(). }
false;protected;0;22;;protected ReplyManager createReplyManager() throws Exception {     // use a temporary queue     ReplyManager replyManager = new TemporaryQueueReplyManager(getEndpoint().getCamelContext()).     replyManager.setEndpoint(getEndpoint()).     String name = "JmsReplyManagerTimeoutChecker[" + getEndpoint().getEndpointConfiguredDestinationName() + "]".     ScheduledExecutorService replyManagerScheduledExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(name, name).     replyManager.setScheduledExecutorService(replyManagerScheduledExecutorService).     name = "JmsReplyManagerOnTimeout[" + getEndpoint().getEndpointConfiguredDestinationName() + "]".     // allow the timeout thread to timeout so during normal operation we do not have a idle thread     int max = getEndpoint().getReplyToOnTimeoutMaxConcurrentConsumers().     if (max <= 0) {         throw new IllegalArgumentException("The option replyToOnTimeoutMaxConcurrentConsumers must be >= 1").     }     ExecutorService replyManagerExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager().newThreadPool(replyManager, name, 0, max).     replyManager.setOnTimeoutExecutorService(replyManagerExecutorService).     ServiceHelper.startService(replyManager).     return replyManager. }
false;protected;1;22;;protected ReplyManager createReplyManager(String replyTo) throws Exception {     // use a regular queue     ReplyManager replyManager = new QueueReplyManager(getEndpoint().getCamelContext()).     replyManager.setEndpoint(getEndpoint()).     String name = "JmsReplyManagerTimeoutChecker[" + replyTo + "]".     ScheduledExecutorService replyManagerScheduledExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(name, name).     replyManager.setScheduledExecutorService(replyManagerScheduledExecutorService).     name = "JmsReplyManagerOnTimeout[" + replyTo + "]".     // allow the timeout thread to timeout so during normal operation we do not have a idle thread     int max = getEndpoint().getReplyToOnTimeoutMaxConcurrentConsumers().     if (max <= 0) {         throw new IllegalArgumentException("The option replyToOnTimeoutMaxConcurrentConsumers must be >= 1").     }     ExecutorService replyManagerExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager().newThreadPool(replyManager, name, 0, max).     replyManager.setOnTimeoutExecutorService(replyManagerExecutorService).     ServiceHelper.startService(replyManager).     return replyManager. }
