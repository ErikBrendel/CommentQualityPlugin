commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public JmsEndpoint getEndpoint() {     return (JmsEndpoint) super.getEndpoint(). }
false;public;0;6;;public AbstractMessageListenerContainer getListenerContainer() throws Exception {     if (listenerContainer == null) {         createMessageListenerContainer().     }     return listenerContainer. }
false;public;0;6;;public EndpointMessageListener getEndpointMessageListener() {     if (messageListener == null) {         createMessageListener(getEndpoint(), getProcessor()).     }     return messageListener. }
false;protected;2;6;;protected void createMessageListener(JmsEndpoint endpoint, Processor processor) {     messageListener = new EndpointMessageListener(endpoint, processor).     getEndpoint().getConfiguration().configureMessageListener(messageListener).     messageListener.setBinding(endpoint.getBinding()).     messageListener.setAsync(endpoint.getConfiguration().isAsyncConsumer()). }
false;protected;0;5;;protected void createMessageListenerContainer() throws Exception {     listenerContainer = getEndpoint().createMessageListenerContainer().     getEndpoint().configureListenerContainer(listenerContainer, this).     listenerContainer.setMessageListener(getEndpointMessageListener()). }
true;;2;4;/**  * Sets the {@link ExecutorService} the {@link AbstractMessageListenerContainer} is using (if any).  * <p/>  * The {@link AbstractMessageListenerContainer} may use a private thread pool, and then when this consumer  * is stopped, we need to shutdown this thread pool as well, to clean up all resources.  * If a shared thread pool is used by the {@link AbstractMessageListenerContainer} then the lifecycle  * of that shared thread pool is handled elsewhere (not by this consumer). and therefore  * the <tt>shutdownExecutorService</tt> parameter should be <tt>false</tt>.  *  * @param executorService         the thread pool  * @param shutdownExecutorService whether to shutdown the thread pool when this consumer stops  */ ;/**  * Sets the {@link ExecutorService} the {@link AbstractMessageListenerContainer} is using (if any).  * <p/>  * The {@link AbstractMessageListenerContainer} may use a private thread pool, and then when this consumer  * is stopped, we need to shutdown this thread pool as well, to clean up all resources.  * If a shared thread pool is used by the {@link AbstractMessageListenerContainer} then the lifecycle  * of that shared thread pool is handled elsewhere (not by this consumer). and therefore  * the <tt>shutdownExecutorService</tt> parameter should be <tt>false</tt>.  *  * @param executorService         the thread pool  * @param shutdownExecutorService whether to shutdown the thread pool when this consumer stops  */ void setListenerContainerExecutorService(ExecutorService executorService, boolean shutdownExecutorService) {     this.executorService = executorService.     this.shutdownExecutorService = shutdownExecutorService. }
true;public;0;5;/**  * Starts the JMS listener container  * <p/>  * Can be used to start this consumer later if it was configured to not auto startup.  */ ;/**  * Starts the JMS listener container  * <p/>  * Can be used to start this consumer later if it was configured to not auto startup.  */ public void startListenerContainer() {     log.trace("Starting listener container {} on destination {}", listenerContainer, getDestinationName()).     listenerContainer.start().     log.debug("Started listener container {} on destination {}", listenerContainer, getDestinationName()). }
true;protected;0;11;/**  * Pre tests the connection before starting the listening.  * <p/>  * In case of connection failure the exception is thrown which prevents Camel from starting.  *  * @throws FailedToCreateConsumerException is thrown if testing the connection failed  */ ;/**  * Pre tests the connection before starting the listening.  * <p/>  * In case of connection failure the exception is thrown which prevents Camel from starting.  *  * @throws FailedToCreateConsumerException is thrown if testing the connection failed  */ protected void testConnectionOnStartup() throws FailedToCreateConsumerException {     try {         log.debug("Testing JMS Connection on startup for destination: {}", getDestinationName()).         Connection con = listenerContainer.getConnectionFactory().createConnection().         JmsUtils.closeConnection(con).         log.debug("Successfully tested JMS Connection on startup for destination: {}", getDestinationName()).     } catch (Exception e) {         String msg = "Cannot get JMS Connection on startup for destination " + getDestinationName().         throw new FailedToCreateConsumerException(getEndpoint(), msg, e).     } }
false;public;0;8;;@Override public void run() {     try {         prepareAndStartListenerContainer().     } catch (Throwable e) {         log.warn("Error starting listener container on destination: " + getDestinationName() + ". This exception will be ignored.", e).     } }
false;public;0;4;;@Override public String toString() {     return "AsyncStartListenerTask[" + getDestinationName() + "]". }
false;protected;0;33;;@Override protected void doStart() throws Exception {     super.doStart().     // create listener container     if (listenerContainer == null) {         createMessageListenerContainer().     }     getEndpoint().onListenerContainerStarting(listenerContainer).     if (getEndpoint().getConfiguration().isAsyncStartListener()) {         getEndpoint().getAsyncStartStopExecutorService().submit(new Runnable() {              @Override             public void run() {                 try {                     prepareAndStartListenerContainer().                 } catch (Throwable e) {                     log.warn("Error starting listener container on destination: " + getDestinationName() + ". This exception will be ignored.", e).                 }             }              @Override             public String toString() {                 return "AsyncStartListenerTask[" + getDestinationName() + "]".             }         }).     } else {         prepareAndStartListenerContainer().     }     // mark as initialized for the first time     initialized = true. }
false;protected;0;12;;protected void prepareAndStartListenerContainer() {     listenerContainer.afterPropertiesSet().     // only start listener if auto start is enabled or we are explicit invoking start later     if (initialized || getEndpoint().isAutoStartup()) {         // should we pre test connections before starting?         if (getEndpoint().isTestConnectionOnStartup()) {             testConnectionOnStartup().         }         startListenerContainer().     } }
false;protected;0;21;;protected void stopAndDestroyListenerContainer() {     if (listenerContainer != null) {         try {             listenerContainer.stop().             listenerContainer.destroy().         } finally {             getEndpoint().onListenerContainerStopped(listenerContainer).         }     }     // null container and listener so they are fully re created if this consumer is restarted     // then we will use updated configuration from jms endpoint that may have been managed using JMX     listenerContainer = null.     messageListener = null.     initialized = false.     // shutdown thread pool if listener container was using a private thread pool     if (shutdownExecutorService && executorService != null) {         getEndpoint().getCamelContext().getExecutorServiceManager().shutdownNow(executorService).     }     executorService = null. }
false;public;0;8;;@Override public void run() {     try {         stopAndDestroyListenerContainer().     } catch (Throwable e) {         log.warn("Error stopping listener container on destination: " + getDestinationName() + ". This exception will be ignored.", e).     } }
false;public;0;4;;@Override public String toString() {     return "AsyncStopListenerTask[" + getDestinationName() + "]". }
false;protected;0;27;;@Override protected void doStop() throws Exception {     if (listenerContainer != null) {         if (getEndpoint().getConfiguration().isAsyncStopListener()) {             getEndpoint().getAsyncStartStopExecutorService().submit(new Runnable() {                  @Override                 public void run() {                     try {                         stopAndDestroyListenerContainer().                     } catch (Throwable e) {                         log.warn("Error stopping listener container on destination: " + getDestinationName() + ". This exception will be ignored.", e).                     }                 }                  @Override                 public String toString() {                     return "AsyncStopListenerTask[" + getDestinationName() + "]".                 }             }).         } else {             stopAndDestroyListenerContainer().         }     }     super.doStop(). }
false;protected;0;6;;@Override protected void doSuspend() throws Exception {     if (listenerContainer != null) {         listenerContainer.stop().     } }
false;protected;0;13;;@Override protected void doResume() throws Exception {     // we may not have been started before, and now the end user calls resume, so lets handle that and start it first     if (!initialized) {         doStart().     } else {         if (listenerContainer != null) {             startListenerContainer().         } else {             log.warn("The listenerContainer is not instantiated. Probably there was a timeout during the Suspend operation. Please restart your consumer route.").         }     } }
false;private;0;7;;private String getDestinationName() {     if (listenerContainer.getDestination() != null) {         return listenerContainer.getDestination().toString().     } else {         return listenerContainer.getDestinationName().     } }
true;public;0;8;/**  * Set the JMS message selector expression (or {@code null} if none).  * Default is none.  * <p>See the JMS specification for a detailed definition of selector expressions.  * <p>Note: The message selector may be replaced at runtime, with the listener  * container picking up the new selector value immediately (works e.g. with  * DefaultMessageListenerContainer, as long as the cache level is less than  * CACHE_CONSUMER). However, this is considered advanced usage. use it with care!  */ ;/**  * Set the JMS message selector expression (or {@code null} if none).  * Default is none.  * <p>See the JMS specification for a detailed definition of selector expressions.  * <p>Note: The message selector may be replaced at runtime, with the listener  * container picking up the new selector value immediately (works e.g. with  * DefaultMessageListenerContainer, as long as the cache level is less than  * CACHE_CONSUMER). However, this is considered advanced usage. use it with care!  */ @ManagedAttribute(description = "Changes the JMS selector, as long the cache level is less than CACHE_CONSUMER.") public String getMessageSelector() {     if (listenerContainer != null) {         return listenerContainer.getMessageSelector().     } else {         return null.     } }
false;public;1;6;;@ManagedAttribute(description = "Changes the JMS selector, as long the cache level is less than CACHE_CONSUMER.") public void setMessageSelector(String messageSelector) {     if (listenerContainer != null) {         listenerContainer.setMessageSelector(messageSelector).     } }
