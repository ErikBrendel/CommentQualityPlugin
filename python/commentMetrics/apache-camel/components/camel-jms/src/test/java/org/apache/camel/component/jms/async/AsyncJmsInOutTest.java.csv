commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;8;;protected CamelContext createCamelContext() throws Exception {     CamelContext camelContext = super.createCamelContext().     ConnectionFactory connectionFactory = CamelJmsTestHelper.createConnectionFactory().     camelContext.addComponent("activemq", jmsComponentAutoAcknowledge(connectionFactory)).     return camelContext. }
false;public;0;17;;@Test public void testAsyncJmsInOut() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMessageCount(100).     mock.expectsNoDuplicates(body()).     StopWatch watch = new StopWatch().     for (int i = 0. i < 100. i++) {         template.sendBody("seda:start", "" + i).     }     // just in case we run on slow boxes     assertMockEndpointsSatisfied(20, TimeUnit.SECONDS).     log.info("Took " + watch.taken() + " ms. to process 100 messages request/reply over JMS"). }
false;public;0;21;;@Override public void configure() throws Exception {     // in a fully sync mode it would take at least 5 + 5 sec to process the 100 messages     // (there are delays in both routes)     // however due async routing, we can leverage the fact to let threads non blocked     // in the first route, and therefore can have the messages processed faster     // because we can have messages wait concurrently in both routes     // this means the async processing model is about 2x faster     from("seda:start").delay(50).inOut("activemq:queue:bar").to("mock:result").     from("activemq:queue:bar").log("Using ${threadName} to process ${body}").delay(50).transform(body().prepend("Bye ")). }
false;protected;0;26;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             // in a fully sync mode it would take at least 5 + 5 sec to process the 100 messages             // (there are delays in both routes)             // however due async routing, we can leverage the fact to let threads non blocked             // in the first route, and therefore can have the messages processed faster             // because we can have messages wait concurrently in both routes             // this means the async processing model is about 2x faster             from("seda:start").delay(50).inOut("activemq:queue:bar").to("mock:result").             from("activemq:queue:bar").log("Using ${threadName} to process ${body}").delay(50).transform(body().prepend("Bye ")).         }     }. }
