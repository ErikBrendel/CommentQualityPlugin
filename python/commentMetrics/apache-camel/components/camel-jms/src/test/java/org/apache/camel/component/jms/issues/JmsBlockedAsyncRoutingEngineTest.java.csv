commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public void onFailure(Exchange exchange) {     LOG.info(">>>> Callback onFailure").     latch.countDown(). }
false;public;1;5;;@Override public void onComplete(Exchange exchange) {     LOG.info(">>>> Callback onComplete").     latch.countDown(). }
false;public;0;12;;public void startBroker() throws Exception {     String brokerName = "test-broker-" + System.currentTimeMillis().     String brokerUri = "vm://" + brokerName.     broker = new BrokerService().     broker.setBrokerName(brokerName).     broker.setBrokerId(brokerName).     broker.addConnector(brokerUri).     broker.setPersistent(false).     // This Broker Plugin simulates Producer Flow Control by delaying the broker's ACK by 2 seconds     broker.setPlugins(new BrokerPlugin[] { new DelayerBrokerPlugin() }).     broker.start(). }
false;protected;0;7;;protected CamelContext createCamelContext() throws Exception {     CamelContext camelContext = super.createCamelContext().     startBroker().     ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(broker.getVmConnectorURI()).     camelContext.addComponent("activemq", jmsComponentAutoAcknowledge(connectionFactory)).     return camelContext. }
false;public;0;21;;@Test public void testBlockedAsyncRoutingEngineTest() throws Exception {     // Until then, the correlation ID doesn't get updated locally     try {         template.asyncRequestBody("activemq:queue:test?requestTimeout=500&useMessageIDAsCorrelationID=true", "hello").     } catch (Exception e) {     }     // 1. We wait a bit for the CorrelationTimeoutMap purge process to run     Thread.sleep(3000).     // 2. We send 5 messages that take 2 seconds so that they time out     template.asyncCallbackRequestBody("activemq:queue:test?requestTimeout=500&useMessageIDAsCorrelationID=true", "beSlow", callback).     template.asyncCallbackRequestBody("activemq:queue:test?requestTimeout=500&useMessageIDAsCorrelationID=true", "beSlow", callback).     template.asyncCallbackRequestBody("activemq:queue:test?requestTimeout=500&useMessageIDAsCorrelationID=true", "beSlow", callback).     template.asyncCallbackRequestBody("activemq:queue:test?requestTimeout=500&useMessageIDAsCorrelationID=true", "beSlow", callback).     template.asyncCallbackRequestBody("activemq:queue:test?requestTimeout=500&useMessageIDAsCorrelationID=true", "beSlow", callback).     // 3. We assert that we were notified of all timeout exceptions     assertTrue(latch.await(3000, TimeUnit.MILLISECONDS)). }
false;public;0;4;;@After public void cleanup() {     LOG.info(">>>>> Latch countdown count was: " + latch.getCount()). }
false;public;0;9;;public void configure() throws Exception {     from("activemq:queue:test?concurrentConsumers=5&useMessageIDAsCorrelationID=true&transacted=true").filter().simple("${in.body} == 'beSlow'").delay(constant(2000)).log(">>>>> Received message on test queue").setBody(constant("Reply")).log(">>>>> Sending back reply"). }
false;protected;0;13;;protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          public void configure() throws Exception {             from("activemq:queue:test?concurrentConsumers=5&useMessageIDAsCorrelationID=true&transacted=true").filter().simple("${in.body} == 'beSlow'").delay(constant(2000)).log(">>>>> Received message on test queue").setBody(constant("Reply")).log(">>>>> Sending back reply").         }     }. }
false;public;2;14;;@Override public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {     String destinationName = messageSend.getDestination().getPhysicalName().     LOG.info("******** Received message for destination " + destinationName).     // do not intercept sends to DLQ     if (destinationName.toLowerCase().contains("test") && i == 0) {         Thread.sleep(2000).         LOG.info("******** Waited 2 seconds for destination: " + destinationName).         i++.     }     super.send(producerExchange, messageSend). }
