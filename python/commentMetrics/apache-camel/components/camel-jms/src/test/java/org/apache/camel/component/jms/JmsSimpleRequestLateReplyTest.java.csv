commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Test public void testRequestLateReplyUsingCustomDestinationHeaderForReply() throws Exception {     doTest(new SendLateReply()). }
false;protected;1;13;;protected void doTest(Runnable runnable) throws InterruptedException {     // use another thread to send the late reply to simulate that we do it later, not     // from the original route anyway     new Thread(runnable).start().     getMockEndpoint("mock:result").expectedMessageCount(1).     Object body = template.requestBody(getQueueEndpointName(), "Hello World").     assertMockEndpointsSatisfied().     assertEquals(expectedBody, body). }
false;public;0;18;;public void run() {     try {         LOG.info("Waiting for latch").         latch.await(30, TimeUnit.SECONDS).         // wait 1 sec after latch before sending he late replay         Thread.sleep(1000).     } catch (Exception e) {     // ignore     }     LOG.info("Sending late reply").     // use some dummy queue as we override this with the property: JmsConstants.JMS_DESTINATION     Map<String, Object> headers = new HashMap<>().     headers.put(JmsConstants.JMS_DESTINATION, replyDestination).     headers.put("JMSCorrelationID", cid).     template.sendBodyAndHeaders("activemq:dummy", expectedBody, headers). }
false;protected;0;11;;protected CamelContext createCamelContext() throws Exception {     CamelContext camelContext = super.createCamelContext().     ConnectionFactory connectionFactory = CamelJmsTestHelper.createConnectionFactory().     camelContext.addComponent("activemq", jmsComponentAutoAcknowledge(connectionFactory)).     activeMQComponent = camelContext.getComponent("activemq", JmsComponent.class).     // as this is a unit test I dont want to wait 20 sec before timeout occurs, so we use 10     activeMQComponent.getConfiguration().setRequestTimeout(10000).     return camelContext. }
false;public;1;18;;public void process(Exchange exchange) throws Exception {     // set the MEP to InOnly as we are not able to send a reply right now but will do it later     // from that other thread     exchange.setPattern(ExchangePattern.InOnly).     Message in = exchange.getIn().     assertEquals("Hello World", in.getBody()).     replyDestination = in.getHeader("JMSReplyTo", Destination.class).     cid = in.getHeader("JMSCorrelationID", String.class).     LOG.info("ReplyDestination: " + replyDestination).     LOG.info("JMSCorrelationID: " + cid).     LOG.info("Ahh I cannot send a reply. Someone else must do it.").     // signal to the other thread to send back the reply message     latch.countDown(). }
false;public;0;24;;public void configure() throws Exception {     from(getQueueEndpointName()).process(new Processor() {          public void process(Exchange exchange) throws Exception {             // set the MEP to InOnly as we are not able to send a reply right now but will do it later             // from that other thread             exchange.setPattern(ExchangePattern.InOnly).             Message in = exchange.getIn().             assertEquals("Hello World", in.getBody()).             replyDestination = in.getHeader("JMSReplyTo", Destination.class).             cid = in.getHeader("JMSCorrelationID", String.class).             LOG.info("ReplyDestination: " + replyDestination).             LOG.info("JMSCorrelationID: " + cid).             LOG.info("Ahh I cannot send a reply. Someone else must do it.").             // signal to the other thread to send back the reply message             latch.countDown().         }     }).to("mock:result"). }
false;protected;0;28;;protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          public void configure() throws Exception {             from(getQueueEndpointName()).process(new Processor() {                  public void process(Exchange exchange) throws Exception {                     // set the MEP to InOnly as we are not able to send a reply right now but will do it later                     // from that other thread                     exchange.setPattern(ExchangePattern.InOnly).                     Message in = exchange.getIn().                     assertEquals("Hello World", in.getBody()).                     replyDestination = in.getHeader("JMSReplyTo", Destination.class).                     cid = in.getHeader("JMSCorrelationID", String.class).                     LOG.info("ReplyDestination: " + replyDestination).                     LOG.info("JMSCorrelationID: " + cid).                     LOG.info("Ahh I cannot send a reply. Someone else must do it.").                     // signal to the other thread to send back the reply message                     latch.countDown().                 }             }).to("mock:result").         }     }. }
false;protected,static;0;4;;protected static String getQueueEndpointName() {     // need to use a fixed queue for reply as a temp queue may be deleted     return "activemq:queue:hello.queue?replyTo=myReplyQueue". }
