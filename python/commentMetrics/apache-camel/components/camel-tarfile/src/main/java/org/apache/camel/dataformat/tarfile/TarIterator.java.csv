commented;modifiers;parameterAmount;loc;comment;code
false;public;0;22;;@Override public boolean hasNext() {     try {         if (tarInputStream == null) {             return false.         }         boolean availableDataInCurrentEntry = tarInputStream.available() > 0.         if (!availableDataInCurrentEntry) {             // advance to the next entry.             parent = getNextElement().             if (parent == null) {                 tarInputStream.close().                 availableDataInCurrentEntry = false.             } else {                 availableDataInCurrentEntry = true.             }         }         return availableDataInCurrentEntry.     } catch (IOException exception) {         throw new RuntimeCamelException(exception).     } }
false;public;0;11;;@Override public Message next() {     if (parent == null) {         parent = getNextElement().     }     Message answer = parent.     parent = null.     checkNullAnswer(answer).     return answer. }
false;private;0;29;;private Message getNextElement() {     if (tarInputStream == null) {         return null.     }     try {         TarArchiveEntry current = getNextEntry().         if (current != null) {             LOGGER.debug("Reading tarEntry {}", current.getName()).             Message answer = new DefaultMessage(exchange.getContext()).             answer.getHeaders().putAll(exchange.getIn().getHeaders()).             answer.setHeader(TARFILE_ENTRY_NAME_HEADER, current.getName()).             answer.setHeader(Exchange.FILE_NAME, current.getName()).             if (current.getSize() > 0) {                 answer.setBody(new TarElementInputStreamWrapper(tarInputStream)).             } else {                 // Workaround for the case when the entry is zero bytes big                 answer.setBody(new ByteArrayInputStream(new byte[0])).             }             return answer.         } else {             LOGGER.trace("Closed tarInputStream").             return null.         }     } catch (IOException exception) {         throw new RuntimeCamelException(exception).     } }
false;public;1;6;;public void checkNullAnswer(Message answer) {     if (answer == null && tarInputStream != null) {         IOHelper.close(tarInputStream).         tarInputStream = null.     } }
false;private;0;15;;private TarArchiveEntry getNextEntry() throws IOException {     TarArchiveEntry entry.     while ((entry = tarInputStream.getNextTarEntry()) != null) {         if (!entry.isDirectory()) {             return entry.         } else {             if (allowEmptyDirectory) {                 return entry.             }         }     }     return null. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;0;5;;@Override public void close() throws IOException {     IOHelper.close(tarInputStream).     tarInputStream = null. }
false;public;0;3;;public boolean isAllowEmptyDirectory() {     return allowEmptyDirectory. }
false;public;1;3;;public void setAllowEmptyDirectory(boolean allowEmptyDirectory) {     this.allowEmptyDirectory = allowEmptyDirectory. }
