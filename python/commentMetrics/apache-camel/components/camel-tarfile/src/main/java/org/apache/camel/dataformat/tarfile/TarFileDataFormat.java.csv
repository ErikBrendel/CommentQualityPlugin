commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getDataFormatName() {     return "tarfile". }
false;public;3;37;;@Override public void marshal(final Exchange exchange, final Object graph, final OutputStream stream) throws Exception {     String filename.     String filepath = exchange.getIn().getHeader(FILE_NAME, String.class).     Long filelength = exchange.getIn().getHeader(FILE_LENGTH, Long.class).     if (filepath == null) {         // generate the file name as the camel file component would do         filename = filepath = StringHelper.sanitize(exchange.getIn().getMessageId()).     } else {         // remove any path elements         filename = Paths.get(filepath).getFileName().toString().     }     TarArchiveOutputStream tos = new TarArchiveOutputStream(stream).     tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX).     tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX).     InputStream is = exchange.getContext().getTypeConverter().mandatoryConvertTo(InputStream.class, graph).     if (filelength == null) {         filelength = (long) is.available().     }     if (preservePathElements) {         createTarEntries(tos, filepath, filelength).     } else {         createTarEntries(tos, filename, filelength).     }     try {         IOHelper.copy(is, tos).     } finally {         tos.closeArchiveEntry().         IOHelper.close(is, tos).     }     String newFilename = filename + ".tar".     exchange.getOut().setHeader(FILE_NAME, newFilename). }
false;public;2;30;;@Override public Object unmarshal(final Exchange exchange, final InputStream stream) throws Exception {     if (usingIterator) {         TarIterator tarIterator = new TarIterator(exchange, stream).         tarIterator.setAllowEmptyDirectory(allowEmptyDirectory).         return tarIterator.     } else {         BufferedInputStream bis = new BufferedInputStream(stream).         TarArchiveInputStream tis = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.TAR, bis).         OutputStreamBuilder osb = OutputStreamBuilder.withExchange(exchange).         try {             TarArchiveEntry entry = tis.getNextTarEntry().             if (entry != null) {                 exchange.getOut().setHeader(FILE_NAME, entry.getName()).                 IOHelper.copy(tis, osb).             }             entry = tis.getNextTarEntry().             if (entry != null) {                 throw new IllegalStateException("Tar file has more than 1 entry.").             }             return osb.build().         } finally {             IOHelper.close(osb, tis, bis).         }     } }
false;private;3;24;;private void createTarEntries(TarArchiveOutputStream tos, String filepath, Long filelength) throws IOException {     Iterator<Path> elements = Paths.get(filepath).iterator().     StringBuilder sb = new StringBuilder().     while (elements.hasNext()) {         Path path = elements.next().         String element = path.toString().         Long length = filelength.         // The "/" at the end tells the TarEntry it is a folder         if (elements.hasNext()) {             element += "/".             length = 0L.         }         // Each entry needs the complete path, including previous created folders.         TarArchiveEntry entry = new TarArchiveEntry(sb + element).         entry.setSize(length).         tos.putArchiveEntry(entry).         sb.append(element).     } }
false;public;0;3;;public boolean isUsingIterator() {     return usingIterator. }
false;public;1;3;;public void setUsingIterator(boolean usingIterator) {     this.usingIterator = usingIterator. }
false;public;0;3;;public boolean isAllowEmptyDirectory() {     return allowEmptyDirectory. }
false;public;1;3;;public void setAllowEmptyDirectory(boolean allowEmptyDirectory) {     this.allowEmptyDirectory = allowEmptyDirectory. }
false;public;0;3;;public boolean isPreservePathElements() {     return preservePathElements. }
false;public;1;3;;public void setPreservePathElements(boolean preservePathElements) {     this.preservePathElements = preservePathElements. }
false;protected;0;4;;@Override protected void doStart() throws Exception { // noop }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
