commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;public;0;4;;@Override public ExchangePattern getExchangePattern() {     return ExchangePattern.InOut. }
false;public;0;3;;public char getDelimiterStart() {     return delimiterStart. }
true;public;1;3;/**  * The variable start delimiter  */ ;/**  * The variable start delimiter  */ public void setDelimiterStart(char delimiterStart) {     this.delimiterStart = delimiterStart. }
false;public;0;3;;public char getDelimiterStop() {     return delimiterStop. }
true;public;1;3;/**  * The variable end delimiter  */ ;/**  * The variable end delimiter  */ public void setDelimiterStop(char delimiterStop) {     this.delimiterStop = delimiterStop. }
false;protected;1;26;;@Override protected void onExchange(Exchange exchange) throws Exception {     StringWriter buffer = new StringWriter().     @SuppressWarnings("unchecked")     Map<String, Object> variableMap = exchange.getIn().getHeader(StringTemplateConstants.STRINGTEMPLATE_VARIABLE_MAP, Map.class).     if (variableMap == null) {         variableMap = ExchangeHelper.createVariableMap(exchange).     }     // getResourceAsInputStream also considers the content cache     String text = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, getResourceAsInputStream()).     ST template = new ST(text, delimiterStart, delimiterStop).     for (Map.Entry<String, Object> entry : variableMap.entrySet()) {         template.add(entry.getKey(), entry.getValue()).     }     log.debug("StringTemplate is writing using attributes: {}", variableMap).     template.write(new NoIndentWriter(buffer)).     // now lets output the results to the exchange     Message out = exchange.getOut().     out.setBody(buffer.toString()).     out.setHeaders(exchange.getIn().getHeaders()).     out.setHeader(StringTemplateConstants.STRINGTEMPLATE_RESOURCE_URI, getResourceUri()).     out.setAttachments(exchange.getIn().getAttachments()). }
