commented;modifiers;parameterAmount;loc;comment;code
true;public;0;7;/**  * Returns a copy of this configuration  */ ;/**  * Returns a copy of this configuration  */ public Mina2Configuration copy() {     try {         return (Mina2Configuration) clone().     } catch (CloneNotSupportedException e) {         throw new RuntimeCamelException(e).     } }
false;public;0;10;;public String getCharsetName() {     if (encoding == null) {         return null.     }     if (!Charset.isSupported(encoding)) {         throw new IllegalArgumentException("The encoding: " + encoding + " is not supported").     }     return Charset.forName(encoding).name(). }
false;public;0;3;;public String getProtocol() {     return protocol. }
true;public;1;3;/**  * Protocol to use  */ ;/**  * Protocol to use  */ public void setProtocol(String protocol) {     this.protocol = protocol. }
false;public;0;3;;public String getHost() {     return host. }
true;public;1;3;/**  * Hostname to use. Use localhost or 0.0.0.0 for local server as consumer. For producer use the hostname or ip address of the remote server.  */ ;/**  * Hostname to use. Use localhost or 0.0.0.0 for local server as consumer. For producer use the hostname or ip address of the remote server.  */ public void setHost(String host) {     this.host = host. }
false;public;0;3;;public int getPort() {     return port. }
true;public;1;3;/**  * Port number  */ ;/**  * Port number  */ public void setPort(int port) {     this.port = port. }
false;public;0;3;;public boolean isSync() {     return sync. }
true;public;1;3;/**  * Setting to set endpoint as one-way or request-response.  */ ;/**  * Setting to set endpoint as one-way or request-response.  */ public void setSync(boolean sync) {     this.sync = sync. }
false;public;0;3;;public boolean isTextline() {     return textline. }
true;public;1;3;/**  * Only used for TCP. If no codec is specified, you can use this flag to indicate a text line based codec.  * if not specified or the value is false, then Object Serialization is assumed over TCP.  */ ;/**  * Only used for TCP. If no codec is specified, you can use this flag to indicate a text line based codec.  * if not specified or the value is false, then Object Serialization is assumed over TCP.  */ public void setTextline(boolean textline) {     this.textline = textline. }
false;public;0;3;;public Mina2TextLineDelimiter getTextlineDelimiter() {     return textlineDelimiter. }
true;public;1;3;/**  * Only used for TCP and if textline=true. Sets the text line delimiter to use.  * If none provided, Camel will use DEFAULT.  * This delimiter is used to mark the end of text.  */ ;/**  * Only used for TCP and if textline=true. Sets the text line delimiter to use.  * If none provided, Camel will use DEFAULT.  * This delimiter is used to mark the end of text.  */ public void setTextlineDelimiter(Mina2TextLineDelimiter textlineDelimiter) {     this.textlineDelimiter = textlineDelimiter. }
false;public;0;3;;public ProtocolCodecFactory getCodec() {     return codec. }
true;public;1;3;/**  * To use a custom minda codec implementation.  */ ;/**  * To use a custom minda codec implementation.  */ public void setCodec(ProtocolCodecFactory codec) {     this.codec = codec. }
false;public;0;3;;public String getEncoding() {     return encoding. }
true;public;1;3;/**  * You can configure the encoding (a charset name) to use for the TCP textline codec and the UDP protocol.  * If not provided, Camel will use the JVM default Charset  */ ;/**  * You can configure the encoding (a charset name) to use for the TCP textline codec and the UDP protocol.  * If not provided, Camel will use the JVM default Charset  */ public void setEncoding(String encoding) {     this.encoding = encoding. }
false;public;0;3;;public long getWriteTimeout() {     return writeTimeout. }
true;public;1;3;/**  * Maximum amount of time it should take to send data to the MINA session. Default is 10000 milliseconds.  */ ;/**  * Maximum amount of time it should take to send data to the MINA session. Default is 10000 milliseconds.  */ public void setWriteTimeout(long writeTimeout) {     this.writeTimeout = writeTimeout. }
false;public;0;3;;public long getTimeout() {     return timeout. }
true;public;1;3;/**  * You can configure the timeout that specifies how long to wait for a response from a remote server.  * The timeout unit is in milliseconds, so 60000 is 60 seconds.  */ ;/**  * You can configure the timeout that specifies how long to wait for a response from a remote server.  * The timeout unit is in milliseconds, so 60000 is 60 seconds.  */ public void setTimeout(long timeout) {     this.timeout = timeout. }
false;public;0;3;;public boolean isLazySessionCreation() {     return lazySessionCreation. }
true;public;1;3;/**  * Sessions can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.  */ ;/**  * Sessions can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.  */ public void setLazySessionCreation(boolean lazySessionCreation) {     this.lazySessionCreation = lazySessionCreation. }
false;public;0;3;;public boolean isTransferExchange() {     return transferExchange. }
true;public;1;3;/**  * Only used for TCP. You can transfer the exchange over the wire instead of just the body.  * The following fields are transferred: In body, Out body, fault body, In headers, Out headers, fault headers, exchange properties, exchange exception.  * This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.  */ ;/**  * Only used for TCP. You can transfer the exchange over the wire instead of just the body.  * The following fields are transferred: In body, Out body, fault body, In headers, Out headers, fault headers, exchange properties, exchange exception.  * This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.  */ public void setTransferExchange(boolean transferExchange) {     this.transferExchange = transferExchange. }
true;public;1;3;/**  * To set the textline protocol encoder max line length. By default the default value of Mina itself is used which are Integer.MAX_VALUE.  */ ;/**  * To set the textline protocol encoder max line length. By default the default value of Mina itself is used which are Integer.MAX_VALUE.  */ public void setEncoderMaxLineLength(int encoderMaxLineLength) {     this.encoderMaxLineLength = encoderMaxLineLength. }
false;public;0;3;;public int getEncoderMaxLineLength() {     return encoderMaxLineLength. }
true;public;1;3;/**  * To set the textline protocol decoder max line length. By default the default value of Mina itself is used which are 1024.  */ ;/**  * To set the textline protocol decoder max line length. By default the default value of Mina itself is used which are 1024.  */ public void setDecoderMaxLineLength(int decoderMaxLineLength) {     this.decoderMaxLineLength = decoderMaxLineLength. }
false;public;0;3;;public int getDecoderMaxLineLength() {     return decoderMaxLineLength. }
false;public;0;3;;public boolean isMinaLogger() {     return minaLogger. }
true;public;1;3;/**  * You can enable the Apache MINA logging filter. Apache MINA uses slf4j logging at INFO level to log all input and output.  */ ;/**  * You can enable the Apache MINA logging filter. Apache MINA uses slf4j logging at INFO level to log all input and output.  */ public void setMinaLogger(boolean minaLogger) {     this.minaLogger = minaLogger. }
false;public;0;3;;public List<IoFilter> getFilters() {     return filters. }
true;public;1;3;/**  * You can set a list of Mina IoFilters to use.  */ ;/**  * You can set a list of Mina IoFilters to use.  */ public void setFilters(List<IoFilter> filters) {     this.filters = filters. }
false;public;0;3;;public boolean isDatagramProtocol() {     return protocol.equals("udp"). }
true;public;1;3;/**  * The mina component installs a default codec if both, codec is null and textline is false.  * Setting allowDefaultCodec to false prevents the mina component from installing a default codec as the first element in the filter chain.  * This is useful in scenarios where another filter must be the first in the filter chain, like the SSL filter.  */ ;/**  * The mina component installs a default codec if both, codec is null and textline is false.  * Setting allowDefaultCodec to false prevents the mina component from installing a default codec as the first element in the filter chain.  * This is useful in scenarios where another filter must be the first in the filter chain, like the SSL filter.  */ public void setAllowDefaultCodec(boolean allowDefaultCodec) {     this.allowDefaultCodec = allowDefaultCodec. }
false;public;0;3;;public boolean isAllowDefaultCodec() {     return allowDefaultCodec. }
false;public;0;3;;public boolean isDisconnect() {     return disconnect. }
true;public;1;3;/**  * Whether or not to disconnect(close) from Mina session right after use. Can be used for both consumer and producer.  */ ;/**  * Whether or not to disconnect(close) from Mina session right after use. Can be used for both consumer and producer.  */ public void setDisconnect(boolean disconnect) {     this.disconnect = disconnect. }
false;public;0;3;;public boolean isDisconnectOnNoReply() {     return disconnectOnNoReply. }
true;public;1;3;/**  * If sync is enabled then this option dictates MinaConsumer if it should disconnect where there is no reply to send back.  */ ;/**  * If sync is enabled then this option dictates MinaConsumer if it should disconnect where there is no reply to send back.  */ public void setDisconnectOnNoReply(boolean disconnectOnNoReply) {     this.disconnectOnNoReply = disconnectOnNoReply. }
false;public;0;3;;public LoggingLevel getNoReplyLogLevel() {     return noReplyLogLevel. }
true;public;1;3;/**  * If sync is enabled this option dictates MinaConsumer which logging level to use when logging a there is no reply to send back.  */ ;/**  * If sync is enabled this option dictates MinaConsumer which logging level to use when logging a there is no reply to send back.  */ public void setNoReplyLogLevel(LoggingLevel noReplyLogLevel) {     this.noReplyLogLevel = noReplyLogLevel. }
false;public;0;3;;public SSLContextParameters getSslContextParameters() {     return sslContextParameters. }
true;public;1;3;/**  * To configure SSL security.  */ ;/**  * To configure SSL security.  */ public void setSslContextParameters(SSLContextParameters sslContextParameters) {     this.sslContextParameters = sslContextParameters. }
false;public;0;3;;public boolean isAutoStartTls() {     return autoStartTls. }
true;public;1;3;/**  * Whether to auto start SSL handshake.  */ ;/**  * Whether to auto start SSL handshake.  */ public void setAutoStartTls(boolean autoStartTls) {     this.autoStartTls = autoStartTls. }
false;public;0;3;;public int getMaximumPoolSize() {     return maximumPoolSize. }
true;public;1;3;/**  * Number of worker threads in the worker pool for TCP and UDP  */ ;/**  * Number of worker threads in the worker pool for TCP and UDP  */ public void setMaximumPoolSize(int maximumPoolSize) {     this.maximumPoolSize = maximumPoolSize. }
false;public;0;3;;public boolean isOrderedThreadPoolExecutor() {     return orderedThreadPoolExecutor. }
true;public;1;3;/**  * Whether to use ordered thread pool, to ensure events are processed orderly on the same channel.  */ ;/**  * Whether to use ordered thread pool, to ensure events are processed orderly on the same channel.  */ public void setOrderedThreadPoolExecutor(boolean orderedThreadPoolExecutor) {     this.orderedThreadPoolExecutor = orderedThreadPoolExecutor. }
true;public;1;3;/**  * Whether to create the InetAddress once and reuse. Setting this to false allows to pickup DNS changes in the network.  */ ;/**  * Whether to create the InetAddress once and reuse. Setting this to false allows to pickup DNS changes in the network.  */ public void setCachedAddress(boolean shouldCacheAddress) {     this.cachedAddress = shouldCacheAddress. }
false;public;0;3;;public boolean isCachedAddress() {     return cachedAddress. }
true;public;1;3;/**  * If the clientMode is true, mina consumer will connect the address as a TCP client.  */ ;/**  * If the clientMode is true, mina consumer will connect the address as a TCP client.  */ public void setClientMode(boolean clientMode) {     this.clientMode = clientMode. }
false;public;0;3;;public boolean isClientMode() {     return clientMode. }
true;public;0;3;// here we just shows the option setting of host, port, protocol ;// here we just shows the option setting of host, port, protocol public String getUriString() {     return "mina2:" + getProtocol() + ":" + getHost() + ":" + getPort(). }
