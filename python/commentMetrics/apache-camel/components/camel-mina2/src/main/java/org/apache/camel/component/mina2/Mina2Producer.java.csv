commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Mina2Endpoint getEndpoint() {     return (Mina2Endpoint) super.getEndpoint(). }
false;public;0;6;;@Override public boolean isSingleton() {     // use request/reply with correct correlation     return !sync. }
false;public;1;9;;@Override public void process(Exchange exchange) throws Exception {     try {         doProcess(exchange).     } finally {         // ensure we always disconnect if configured         maybeDisconnectOnDone(exchange).     } }
false;protected;1;68;;protected void doProcess(Exchange exchange) throws Exception {     if (session == null && !lazySessionCreation) {         throw new IllegalStateException("Not started yet!").     }     if (session == null || !session.isConnected()) {         openConnection().     }     // set the exchange encoding property     if (getEndpoint().getConfiguration().getCharsetName() != null) {         exchange.setProperty(Exchange.CHARSET_NAME, IOHelper.normalizeCharset(getEndpoint().getConfiguration().getCharsetName())).     }     Object body = Mina2PayloadHelper.getIn(getEndpoint(), exchange).     if (body == null) {         noReplyLogger.log("No payload to send for exchange: " + exchange).         // exit early since nothing to write         return.     }     // if textline enabled then covert to a String which must be used for textline     if (getEndpoint().getConfiguration().isTextline()) {         body = getEndpoint().getCamelContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body).     }     // if sync is true then we should also wait for a response (synchronous mode)     if (sync) {         // only initialize responseLatch if we should get a response         responseLatch = new CountDownLatch(1).         // reset handler if we expect a response         handler.reset().     }     // log what we are writing     if (LOG.isDebugEnabled()) {         Object out = body.         if (body instanceof byte[]) {             // byte arrays is not readable so convert to string             out = exchange.getContext().getTypeConverter().convertTo(String.class, body).         }         LOG.debug("Writing body: {}", out).     }     // write the body     Mina2Helper.writeBody(session, body, exchange, writeTimeout).     if (sync) {         // wait for response, consider timeout         LOG.debug("Waiting for response using timeout {} millis.", timeout).         boolean done = responseLatch.await(timeout, TimeUnit.MILLISECONDS).         if (!done) {             throw new ExchangeTimedOutException(exchange, timeout).         }         // did we get a response         if (handler.getCause() != null) {             throw new CamelExchangeException("Error occurred in ResponseHandler", exchange, handler.getCause()).         } else if (!handler.isMessageReceived()) {             // no message received             throw new ExchangeTimedOutException(exchange, timeout).         } else {             // set the result on either IN or OUT on the original exchange depending on its pattern             if (ExchangeHelper.isOutCapable(exchange)) {                 Mina2PayloadHelper.setOut(exchange, handler.getMessage()).             } else {                 Mina2PayloadHelper.setIn(exchange, handler.getMessage()).             }         }     } }
false;protected;1;23;;protected void maybeDisconnectOnDone(Exchange exchange) throws InterruptedException {     if (session == null) {         return.     }     // should session be closed after complete?     Boolean close.     if (ExchangeHelper.isOutCapable(exchange)) {         close = exchange.getOut().getHeader(Mina2Constants.MINA_CLOSE_SESSION_WHEN_COMPLETE, Boolean.class).     } else {         close = exchange.getIn().getHeader(Mina2Constants.MINA_CLOSE_SESSION_WHEN_COMPLETE, Boolean.class).     }     // should we disconnect, the header can override the configuration     boolean disconnect = getEndpoint().getConfiguration().isDisconnect().     if (close != null) {         disconnect = close.     }     if (disconnect) {         LOG.debug("Closing session when complete at address: {}", address).         closeSessionIfNeededAndAwaitCloseInHandler(session).     } }
false;private;1;8;;private void closeSessionIfNeededAndAwaitCloseInHandler(IoSession sessionToBeClosed) throws InterruptedException {     closeLatch = new CountDownLatch(1).     if (!sessionToBeClosed.isClosing()) {         CloseFuture closeFuture = sessionToBeClosed.closeNow().         closeFuture.await(timeout, TimeUnit.MILLISECONDS).         closeLatch.await(timeout, TimeUnit.MILLISECONDS).     } }
false;public;0;3;;public DefaultIoFilterChainBuilder getFilterChain() {     return connector.getFilterChain(). }
false;protected;0;7;;@Override protected void doStart() throws Exception {     super.doStart().     if (!lazySessionCreation) {         openConnection().     } }
false;protected;0;8;;@Override protected void doStop() throws Exception {     if (LOG.isDebugEnabled()) {         LOG.debug("Stopping connector: {} at address: {}", connector, address).     }     closeConnection().     super.doStop(). }
false;protected;0;7;;@Override protected void doShutdown() throws Exception {     if (workerPool != null) {         workerPool.shutdown().     }     super.doShutdown(). }
false;private;0;7;;private void closeConnection() throws InterruptedException {     if (session != null) {         closeSessionIfNeededAndAwaitCloseInHandler(session).     }     connector.dispose(true). }
false;private;0;16;;private void openConnection() {     if (this.address == null || !this.configuration.isCachedAddress()) {         setSocketAddress(this.configuration.getProtocol()).     }     if (LOG.isDebugEnabled()) {         LOG.debug("Creating connector to address: {} using connector: {} timeout: {} millis.", address, connector, timeout).     }     // connect and wait until the connection is established     if (connectorConfig != null) {         connector.getSessionConfig().setAll(connectorConfig).     }     ConnectFuture future = connector.connect(address).     future.awaitUninterruptibly().     session = future.getSession(). }
true;protected;1;18;// ------------------------------------------------------------------------- ;// Implementation methods // ------------------------------------------------------------------------- protected void setupVmProtocol(String uri) {     boolean minaLogger = configuration.isMinaLogger().     List<IoFilter> filters = configuration.getFilters().     address = new VmPipeAddress(configuration.getPort()).     connector = new VmPipeConnector().     // connector config     if (minaLogger) {         connector.getFilterChain().addLast("logger", new LoggingFilter()).     }     appendIoFiltersToChain(filters, connector.getFilterChain()).     if (configuration.getSslContextParameters() != null) {         LOG.warn("Using vm protocol" + ", but an SSLContextParameters instance was provided.  SSLContextParameters is only supported on the TCP protocol.").     }     configureCodecFactory("Mina2Producer", connector). }
false;protected;1;31;;protected void setupSocketProtocol(String uri) throws Exception {     boolean minaLogger = configuration.isMinaLogger().     long timeout = configuration.getTimeout().     List<IoFilter> filters = configuration.getFilters().     address = new InetSocketAddress(configuration.getHost(), configuration.getPort()).     final int processorCount = Runtime.getRuntime().availableProcessors() + 1.     connector = new NioSocketConnector(processorCount).     // connector config     connectorConfig = connector.getSessionConfig().     if (configuration.isOrderedThreadPoolExecutor()) {         workerPool = new OrderedThreadPoolExecutor(configuration.getMaximumPoolSize()).     } else {         workerPool = new UnorderedThreadPoolExecutor(configuration.getMaximumPoolSize()).     }     connector.getFilterChain().addLast("threadPool", new ExecutorFilter(workerPool)).     if (minaLogger) {         connector.getFilterChain().addLast("logger", new LoggingFilter()).     }     appendIoFiltersToChain(filters, connector.getFilterChain()).     if (configuration.getSslContextParameters() != null) {         SslFilter filter = new SslFilter(configuration.getSslContextParameters().createSSLContext(getEndpoint().getCamelContext()), configuration.isAutoStartTls()).         filter.setUseClientMode(true).         connector.getFilterChain().addFirst("sslFilter", filter).     }     configureCodecFactory("Mina2Producer", connector).     connector.setConnectTimeoutMillis(timeout). }
false;protected;2;7;;protected void configureCodecFactory(String type, IoService service) {     if (configuration.getCodec() != null) {         addCodecFactory(service, configuration.getCodec()).     } else if (configuration.isAllowDefaultCodec()) {         configureDefaultCodecFactory(type, service).     } }
false;protected;2;22;;protected void configureDefaultCodecFactory(String type, IoService service) {     if (configuration.isTextline()) {         Charset charset = getEncodingParameter(type, configuration).         LineDelimiter delimiter = getLineDelimiterParameter(configuration.getTextlineDelimiter()).         Mina2TextLineCodecFactory codecFactory = new Mina2TextLineCodecFactory(charset, delimiter).         if (configuration.getEncoderMaxLineLength() > 0) {             codecFactory.setEncoderMaxLineLength(configuration.getEncoderMaxLineLength()).         }         if (configuration.getDecoderMaxLineLength() > 0) {             codecFactory.setDecoderMaxLineLength(configuration.getDecoderMaxLineLength()).         }         addCodecFactory(service, codecFactory).         LOG.debug("{}: Using TextLineCodecFactory: {} using encoding: {} line delimiter: {}({})", type, codecFactory, charset, configuration.getTextlineDelimiter(), delimiter).         LOG.debug("Encoder maximum line length: {}. Decoder maximum line length: {}", codecFactory.getEncoderMaxLineLength(), codecFactory.getDecoderMaxLineLength()).     } else {         ObjectSerializationCodecFactory codecFactory = new ObjectSerializationCodecFactory().         addCodecFactory(service, codecFactory).         LOG.debug("{}: Using ObjectSerializationCodecFactory: {}", type, codecFactory).     } }
false;protected;1;32;;protected void setupDatagramProtocol(String uri) {     boolean minaLogger = configuration.isMinaLogger().     boolean transferExchange = configuration.isTransferExchange().     List<IoFilter> filters = configuration.getFilters().     if (transferExchange) {         throw new IllegalArgumentException("transferExchange=true is not supported for datagram protocol").     }     address = new InetSocketAddress(configuration.getHost(), configuration.getPort()).     final int processorCount = Runtime.getRuntime().availableProcessors() + 1.     connector = new NioDatagramConnector(processorCount).     if (configuration.isOrderedThreadPoolExecutor()) {         workerPool = new OrderedThreadPoolExecutor(configuration.getMaximumPoolSize()).     } else {         workerPool = new UnorderedThreadPoolExecutor(configuration.getMaximumPoolSize()).     }     connectorConfig = connector.getSessionConfig().     connector.getFilterChain().addLast("threadPool", new ExecutorFilter(workerPool)).     if (minaLogger) {         connector.getFilterChain().addLast("logger", new LoggingFilter()).     }     appendIoFiltersToChain(filters, connector.getFilterChain()).     if (configuration.getSslContextParameters() != null) {         LOG.warn("Using datagram protocol, " + configuration.getProtocol() + ", but an SSLContextParameters instance was provided.  SSLContextParameters is only supported on the TCP protocol.").     }     configureDataGramCodecFactory("Mina2Producer", connector, configuration).     // set connect timeout to mina in seconds     connector.setConnectTimeoutMillis(timeout). }
true;protected;3;12;/**  * For datagrams the entire message is available as a single IoBuffer so lets just pass those around by default  * and try converting whatever they payload is into IoBuffer unless some custom converter is specified  */ ;/**  * For datagrams the entire message is available as a single IoBuffer so lets just pass those around by default  * and try converting whatever they payload is into IoBuffer unless some custom converter is specified  */ protected void configureDataGramCodecFactory(final String type, final IoService service, final Mina2Configuration configuration) {     ProtocolCodecFactory codecFactory = configuration.getCodec().     if (codecFactory == null) {         codecFactory = new Mina2UdpProtocolCodecFactory(this.getEndpoint().getCamelContext()).         if (LOG.isDebugEnabled()) {             LOG.debug("{}: Using CodecFactory: {}", type, codecFactory).         }     }     addCodecFactory(service, codecFactory). }
false;private;2;5;;private void addCodecFactory(IoService service, ProtocolCodecFactory codecFactory) {     LOG.debug("addCodecFactory name: {}", codecFactory.getClass().getName()).     service.getFilterChain().addLast("codec", new ProtocolCodecFilter(codecFactory)). }
false;private,static;1;6;;private static LineDelimiter getLineDelimiterParameter(Mina2TextLineDelimiter delimiter) {     if (delimiter == null) {         return LineDelimiter.DEFAULT.     }     return delimiter.getLineDelimiter(). }
false;private;2;14;;private Charset getEncodingParameter(String type, Mina2Configuration configuration) {     String encoding = configuration.getEncoding().     if (encoding == null) {         encoding = Charset.defaultCharset().name().         // set in on configuration so its updated         configuration.setEncoding(encoding).         LOG.debug("{}: No encoding parameter using default charset: {}", type, encoding).     }     if (!Charset.isSupported(encoding)) {         throw new IllegalArgumentException("The encoding: " + encoding + " is not supported").     }     return Charset.forName(encoding). }
false;private;2;7;;private void appendIoFiltersToChain(List<IoFilter> filters, DefaultIoFilterChainBuilder filterChain) {     if (filters != null && filters.size() > 0) {         for (IoFilter ioFilter : filters) {             filterChain.addLast(ioFilter.getClass().getCanonicalName(), ioFilter).         }     } }
false;private;1;9;;private void setSocketAddress(String protocol) {     if (protocol.equals("tcp")) {         this.address = new InetSocketAddress(configuration.getHost(), configuration.getPort()).     } else if (configuration.isDatagramProtocol()) {         this.address = new InetSocketAddress(configuration.getHost(), configuration.getPort()).     } else if (protocol.equals("vm")) {         this.address = new VmPipeAddress(configuration.getPort()).     } }
false;public;0;5;;public void reset() {     this.message = null.     this.cause = null.     this.messageReceived = false. }
false;public;2;8;;@Override public void messageReceived(IoSession ioSession, Object message) throws Exception {     LOG.debug("Message received: {}", message).     this.message = message.     messageReceived = true.     cause = null.     notifyResultAvailable(). }
false;protected;0;6;;protected void notifyResultAvailable() {     CountDownLatch downLatch = responseLatch.     if (downLatch != null) {         downLatch.countDown().     } }
false;public;1;11;;@Override public void sessionClosed(IoSession session) throws Exception {     if (sync && !messageReceived) {         // sync=true (InOut mode) so we expected a message as reply but did not get one before the session is closed         LOG.debug("Session closed but no message received from address: {}", address).         // session was closed but no message received. This could be because the remote server had an internal error         // and could not return a response. We should count down to stop waiting for a response         notifyResultAvailable().     }     notifySessionClosed(). }
false;private;0;5;;private void notifySessionClosed() {     if (closeLatch != null) {         closeLatch.countDown().     } }
false;public;2;10;;@Override public void exceptionCaught(IoSession ioSession, Throwable cause) {     this.message = null.     this.messageReceived = false.     this.cause = cause.     if (ioSession != null && !closedByMina(cause)) {         CloseFuture closeFuture = ioSession.closeNow().         closeFuture.awaitUninterruptibly(timeout, TimeUnit.MILLISECONDS).     } }
false;private;1;3;;private boolean closedByMina(Throwable cause) {     return cause instanceof IOException. }
false;public;0;3;;public Throwable getCause() {     return this.cause. }
false;public;0;3;;public Object getMessage() {     return this.message. }
false;public;0;3;;public boolean isMessageReceived() {     return messageReceived. }
