commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isAutoStartScheduler() {     return autoStartScheduler. }
true;public;1;3;/**  * Whether or not the scheduler should be auto started.  * <p/>  * This options is default true  */ ;/**  * Whether or not the scheduler should be auto started.  * <p/>  * This options is default true  */ public void setAutoStartScheduler(boolean autoStartScheduler) {     this.autoStartScheduler = autoStartScheduler. }
false;public;0;3;;public int getStartDelayedSeconds() {     return startDelayedSeconds. }
true;public;1;3;/**  * Seconds to wait before starting the quartz scheduler.  */ ;/**  * Seconds to wait before starting the quartz scheduler.  */ public void setStartDelayedSeconds(int startDelayedSeconds) {     this.startDelayedSeconds = startDelayedSeconds. }
false;public;0;3;;public boolean isPrefixJobNameWithEndpointId() {     return prefixJobNameWithEndpointId. }
true;public;1;3;/**  * Whether to prefix the quartz job with the endpoint id.  * <p/>  * This option is default false.  */ ;/**  * Whether to prefix the quartz job with the endpoint id.  * <p/>  * This option is default false.  */ public void setPrefixJobNameWithEndpointId(boolean prefixJobNameWithEndpointId) {     this.prefixJobNameWithEndpointId = prefixJobNameWithEndpointId. }
false;public;0;3;;public boolean isEnableJmx() {     return enableJmx. }
true;public;1;3;/**  * Whether to enable Quartz JMX which allows to manage the Quartz scheduler from JMX.  * <p/>  * This options is default true  */ ;/**  * Whether to enable Quartz JMX which allows to manage the Quartz scheduler from JMX.  * <p/>  * This options is default true  */ public void setEnableJmx(boolean enableJmx) {     this.enableJmx = enableJmx. }
false;public;0;3;;public Properties getProperties() {     return properties. }
true;public;1;3;/**  * Properties to configure the Quartz scheduler.  */ ;/**  * Properties to configure the Quartz scheduler.  */ public void setProperties(Properties properties) {     this.properties = properties. }
false;public;0;3;;public String getPropertiesFile() {     return propertiesFile. }
true;public;1;3;/**  * File name of the properties to load from the classpath  */ ;/**  * File name of the properties to load from the classpath  */ public void setPropertiesFile(String propertiesFile) {     this.propertiesFile = propertiesFile. }
false;public;0;3;;public boolean isPrefixInstanceName() {     return prefixInstanceName. }
true;public;1;3;/**  * Whether to prefix the Quartz Scheduler instance name with the CamelContext name.  * <p/>  * This is enabled by default, to let each CamelContext use its own Quartz scheduler instance by default.  * You can set this option to <tt>false</tt> to reuse Quartz scheduler instances between multiple CamelContext's.  */ ;/**  * Whether to prefix the Quartz Scheduler instance name with the CamelContext name.  * <p/>  * This is enabled by default, to let each CamelContext use its own Quartz scheduler instance by default.  * You can set this option to <tt>false</tt> to reuse Quartz scheduler instances between multiple CamelContext's.  */ public void setPrefixInstanceName(boolean prefixInstanceName) {     this.prefixInstanceName = prefixInstanceName. }
false;public;0;3;;public boolean isInterruptJobsOnShutdown() {     return interruptJobsOnShutdown. }
true;public;1;3;/**  * Whether to interrupt jobs on shutdown which forces the scheduler to shutdown quicker and attempt to interrupt any running jobs.  * If this is enabled then any running jobs can fail due to being interrupted.  */ ;/**  * Whether to interrupt jobs on shutdown which forces the scheduler to shutdown quicker and attempt to interrupt any running jobs.  * If this is enabled then any running jobs can fail due to being interrupted.  */ public void setInterruptJobsOnShutdown(boolean interruptJobsOnShutdown) {     this.interruptJobsOnShutdown = interruptJobsOnShutdown. }
false;public;0;6;;public SchedulerFactory getSchedulerFactory() throws SchedulerException {     if (schedulerFactory == null) {         schedulerFactory = createSchedulerFactory().     }     return schedulerFactory. }
false;private;0;76;;private SchedulerFactory createSchedulerFactory() throws SchedulerException {     SchedulerFactory answer.     Properties prop = loadProperties().     if (prop != null) {         // force disabling update checker (will do online check over the internet)         prop.put("org.quartz.scheduler.skipUpdateCheck", "true").         prop.put("org.terracotta.quartz.skipUpdateCheck", "true").         // camel context name will be a suffix to use one scheduler per context         if (isPrefixInstanceName()) {             String instName = createInstanceName(prop).             prop.setProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME, instName).         }         if (isInterruptJobsOnShutdown()) {             prop.setProperty(StdSchedulerFactory.PROP_SCHED_INTERRUPT_JOBS_ON_SHUTDOWN, "true").         }         // enable jmx unless configured to not do so         if (enableJmx && !prop.containsKey("org.quartz.scheduler.jmx.export")) {             prop.put("org.quartz.scheduler.jmx.export", "true").             log.info("Setting org.quartz.scheduler.jmx.export=true to ensure QuartzScheduler(s) will be enlisted in JMX.").         }         answer = new StdSchedulerFactory(prop).     } else {         // read default props to be able to use a single scheduler per camel context         // if we need more than one scheduler per context use setScheduler(Scheduler)         // or setFactory(SchedulerFactory) methods         // must use classloader from StdSchedulerFactory to work even in OSGi         InputStream is = StdSchedulerFactory.class.getClassLoader().getResourceAsStream("org/quartz/quartz.properties").         if (is == null) {             throw new SchedulerException("Quartz properties file not found in classpath: org/quartz/quartz.properties").         }         prop = new Properties().         try {             prop.load(is).         } catch (IOException e) {             throw new SchedulerException("Error loading Quartz properties file from classpath: org/quartz/quartz.properties", e).         } finally {             IOHelper.close(is).         }         // camel context name will be a suffix to use one scheduler per context         if (isPrefixInstanceName()) {             // camel context name will be a suffix to use one scheduler per context             String instName = createInstanceName(prop).             prop.setProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME, instName).         }         // force disabling update checker (will do online check over the internet)         prop.put("org.quartz.scheduler.skipUpdateCheck", "true").         prop.put("org.terracotta.quartz.skipUpdateCheck", "true").         if (isInterruptJobsOnShutdown()) {             prop.setProperty(StdSchedulerFactory.PROP_SCHED_INTERRUPT_JOBS_ON_SHUTDOWN, "true").         }         // enable jmx unless configured to not do so         if (enableJmx && !prop.containsKey("org.quartz.scheduler.jmx.export")) {             prop.put("org.quartz.scheduler.jmx.export", "true").             log.info("Setting org.quartz.scheduler.jmx.export=true to ensure QuartzScheduler(s) will be enlisted in JMX.").         }         answer = new StdSchedulerFactory(prop).     }     if (log.isDebugEnabled()) {         String name = prop.getProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME).         log.debug("Creating SchedulerFactory: {} with properties: {}", name, prop).     }     return answer. }
false;protected;1;14;;protected String createInstanceName(Properties prop) {     String instName = prop.getProperty(StdSchedulerFactory.PROP_SCHED_INSTANCE_NAME).     // camel context name will be a suffix to use one scheduler per context     String identity = QuartzHelper.getQuartzContextName(getCamelContext()).     if (identity != null) {         if (instName == null) {             instName = "scheduler-" + identity.         } else {             instName = instName + "-" + identity.         }     }     return instName. }
true;public;0;3;/**  * Is the quartz scheduler clustered?  */ ;/**  * Is the quartz scheduler clustered?  */ public boolean isClustered() throws SchedulerException {     return getScheduler().getMetaData().isJobStoreClustered(). }
false;private;0;17;;private Properties loadProperties() throws SchedulerException {     Properties answer = getProperties().     if (answer == null && getPropertiesFile() != null) {         log.info("Loading Quartz properties file from: {}", getPropertiesFile()).         InputStream is = null.         try {             is = ResourceHelper.resolveMandatoryResourceAsInputStream(getCamelContext(), getPropertiesFile()).             answer = new Properties().             answer.load(is).         } catch (IOException e) {             throw new SchedulerException("Error loading Quartz properties file: " + getPropertiesFile(), e).         } finally {             IOHelper.close(is).         }     }     return answer. }
true;public;1;3;/**  * To use the custom SchedulerFactory which is used to create the Scheduler.  */ ;/**  * To use the custom SchedulerFactory which is used to create the Scheduler.  */ public void setSchedulerFactory(SchedulerFactory schedulerFactory) {     this.schedulerFactory = schedulerFactory. }
false;public;0;3;;public Scheduler getScheduler() {     return scheduler. }
true;public;1;3;/**  * To use the custom configured Quartz scheduler, instead of creating a new Scheduler.  */ ;/**  * To use the custom configured Quartz scheduler, instead of creating a new Scheduler.  */ public void setScheduler(Scheduler scheduler) {     this.scheduler = scheduler. }
false;protected;3;44;;@Override protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {     // Get couple of scheduler settings     Integer startDelayedSeconds = getAndRemoveParameter(parameters, "startDelayedSeconds", Integer.class).     if (startDelayedSeconds != null) {         if (this.startDelayedSeconds != 0 && !(this.startDelayedSeconds == startDelayedSeconds)) {             log.warn("A Quartz job is already configured with a different 'startDelayedSeconds' configuration! " + "All Quartz jobs must share the same 'startDelayedSeconds' configuration! Cannot apply the 'startDelayedSeconds' configuration!").         } else {             this.startDelayedSeconds = startDelayedSeconds.         }     }     Boolean autoStartScheduler = getAndRemoveParameter(parameters, "autoStartScheduler", Boolean.class).     if (autoStartScheduler != null) {         this.autoStartScheduler = autoStartScheduler.     }     Boolean prefixJobNameWithEndpointId = getAndRemoveParameter(parameters, "prefixJobNameWithEndpointId", Boolean.class).     if (prefixJobNameWithEndpointId != null) {         this.prefixJobNameWithEndpointId = prefixJobNameWithEndpointId.     }     // Extract trigger.XXX and job.XXX properties to be set on endpoint below     Map<String, Object> triggerParameters = IntrospectionSupport.extractProperties(parameters, "trigger.").     Map<String, Object> jobParameters = IntrospectionSupport.extractProperties(parameters, "job.").     // Create quartz endpoint     QuartzEndpoint result = new QuartzEndpoint(uri, this).     TriggerKey triggerKey = createTriggerKey(uri, remaining, result).     result.setTriggerKey(triggerKey).     result.setTriggerParameters(triggerParameters).     result.setJobParameters(jobParameters).     if (startDelayedSeconds != null) {         result.setStartDelayedSeconds(startDelayedSeconds).     }     if (autoStartScheduler != null) {         result.setAutoStartScheduler(autoStartScheduler).     }     if (prefixJobNameWithEndpointId != null) {         result.setPrefixJobNameWithEndpointId(prefixJobNameWithEndpointId).     }     return result. }
false;private;3;32;;private TriggerKey createTriggerKey(String uri, String remaining, QuartzEndpoint endpoint) throws Exception {     // Parse uri for trigger name and group     URI u = new URI(uri).     String path = StringHelper.after(u.getPath(), "/").     String host = u.getHost().     // host can be null if the uri did contain invalid host characters such as an underscore     if (host == null) {         host = StringHelper.before(remaining, "/").         if (host == null) {             host = remaining.         }     }     // Trigger group can be optional, if so set it to this context's unique name     String name.     String group.     if (ObjectHelper.isNotEmpty(path) && ObjectHelper.isNotEmpty(host)) {         group = host.         name = path.     } else {         String camelContextName = QuartzHelper.getQuartzContextName(getCamelContext()).         group = camelContextName == null ? "Camel" : "Camel_" + camelContextName.         name = host.     }     if (prefixJobNameWithEndpointId) {         name = endpoint.getId() + "_" + name.     }     return new TriggerKey(name, group). }
false;protected;0;8;;@Override protected void doStart() throws Exception {     super.doStart().     if (scheduler == null) {         createAndInitScheduler().     } }
false;private;0;14;;private void createAndInitScheduler() throws SchedulerException {     log.info("Create and initializing scheduler.").     scheduler = createScheduler().     SchedulerContext quartzContext = storeCamelContextInQuartzContext().     // Set camel job counts to zero. We needed this to prevent shutdown in case there are multiple Camel contexts     // that has not completed yet, and the last one with job counts to zero will eventually shutdown.     AtomicInteger number = (AtomicInteger) quartzContext.get(QuartzConstants.QUARTZ_CAMEL_JOBS_COUNT).     if (number == null) {         number = new AtomicInteger(0).         quartzContext.put(QuartzConstants.QUARTZ_CAMEL_JOBS_COUNT, number).     } }
false;private;0;8;;private SchedulerContext storeCamelContextInQuartzContext() throws SchedulerException {     // Store CamelContext into QuartzContext space     SchedulerContext quartzContext = scheduler.getContext().     String camelContextName = QuartzHelper.getQuartzContextName(getCamelContext()).     log.debug("Storing camelContextName={} into Quartz Context space.", camelContextName).     quartzContext.put(QuartzConstants.QUARTZ_CAMEL_CONTEXT + "-" + camelContextName, getCamelContext()).     return quartzContext. }
false;private;0;3;;private Scheduler createScheduler() throws SchedulerException {     return getSchedulerFactory().getScheduler(). }
false;protected;0;21;;@Override protected void doStop() throws Exception {     super.doStop().     if (scheduler != null) {         if (isInterruptJobsOnShutdown()) {             log.info("Shutting down scheduler. (will interrupts jobs to shutdown quicker.)").             scheduler.shutdown(false).             scheduler = null.         } else {             AtomicInteger number = (AtomicInteger) scheduler.getContext().get(QuartzConstants.QUARTZ_CAMEL_JOBS_COUNT).             if (number != null && number.get() > 0) {                 log.info("Cannot shutdown scheduler: " + scheduler.getSchedulerName() + " as there are still " + number.get() + " jobs registered.").             } else {                 log.info("Shutting down scheduler. (will wait for all jobs to complete first.)").                 scheduler.shutdown(true).                 scheduler = null.             }         }     } }
false;public;2;33;;@Override public void onCamelContextStarted(CamelContext context, boolean alreadyStarted) throws Exception {     // to create and init the scheduler first.     if (scheduler == null) {         createAndInitScheduler().     } else {         // in case custom scheduler was injected (i.e. created elsewhere), we may need to add         // current camel context to quartz context so jobs have access         storeCamelContextInQuartzContext().     }     // Now scheduler is ready, let see how we should start it.     if (!autoStartScheduler) {         log.info("Not starting scheduler because autoStartScheduler is set to false.").     } else {         if (startDelayedSeconds > 0) {             if (scheduler.isStarted()) {                 log.warn("The scheduler has already started. Cannot apply the 'startDelayedSeconds' configuration!").             } else {                 log.info("Starting scheduler with startDelayedSeconds={}", startDelayedSeconds).                 scheduler.startDelayed(startDelayedSeconds).             }         } else {             if (scheduler.isStarted()) {                 log.info("The scheduler has already been started.").             } else {                 log.info("Starting scheduler.").                 scheduler.start().             }         }     } }
