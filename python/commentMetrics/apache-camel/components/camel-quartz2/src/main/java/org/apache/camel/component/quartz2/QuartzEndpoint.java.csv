commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getGroupName() {     return triggerKey.getName(). }
false;public;0;3;;public String getTriggerName() {     return triggerKey.getName(). }
true;public;1;3;/**  * The quartz timer name to use. The combination of group name and timer name should be unique.  */ ;/**  * The quartz timer name to use. The combination of group name and timer name should be unique.  */ public void setTriggerName(String triggerName) {     this.triggerName = triggerName. }
false;public;0;3;;public String getCron() {     return cron. }
false;public;0;3;;public boolean isStateful() {     return stateful. }
false;public;0;3;;public boolean isFireNow() {     return fireNow. }
false;public;0;3;;public long getTriggerStartDelay() {     return triggerStartDelay. }
false;public;0;3;;public boolean isDeleteJob() {     return deleteJob. }
false;public;0;3;;public boolean isPauseJob() {     return pauseJob. }
true;public;1;3;/**  * If set to true, then the trigger automatically pauses when route stop.  * Else if set to false, it will remain in scheduler. When set to false, it will also mean user may reuse  * pre-configured trigger with camel Uri. Just ensure the names match.  * Notice you cannot have both deleteJob and pauseJob set to true.  */ ;/**  * If set to true, then the trigger automatically pauses when route stop.  * Else if set to false, it will remain in scheduler. When set to false, it will also mean user may reuse  * pre-configured trigger with camel Uri. Just ensure the names match.  * Notice you cannot have both deleteJob and pauseJob set to true.  */ public void setPauseJob(boolean pauseJob) {     this.pauseJob = pauseJob. }
true;public;1;3;/**  * In case of scheduler has already started, we want the trigger start slightly after current time to  * ensure endpoint is fully started before the job kicks in.  */ ;/**  * In case of scheduler has already started, we want the trigger start slightly after current time to  * ensure endpoint is fully started before the job kicks in.  */ public void setTriggerStartDelay(long triggerStartDelay) {     this.triggerStartDelay = triggerStartDelay. }
true;public;1;3;/**  * If set to true, then the trigger automatically delete when route stop.  * Else if set to false, it will remain in scheduler. When set to false, it will also mean user may reuse  * pre-configured trigger with camel Uri. Just ensure the names match.  * Notice you cannot have both deleteJob and pauseJob set to true.  */ ;/**  * If set to true, then the trigger automatically delete when route stop.  * Else if set to false, it will remain in scheduler. When set to false, it will also mean user may reuse  * pre-configured trigger with camel Uri. Just ensure the names match.  * Notice you cannot have both deleteJob and pauseJob set to true.  */ public void setDeleteJob(boolean deleteJob) {     this.deleteJob = deleteJob. }
true;public;1;3;/**  * If it is true will fire the trigger when the route is start when using SimpleTrigger.  */ ;/**  * If it is true will fire the trigger when the route is start when using SimpleTrigger.  */ public void setFireNow(boolean fireNow) {     this.fireNow = fireNow. }
true;public;1;3;/**  * Uses a Quartz @PersistJobDataAfterExecution and @DisallowConcurrentExecution instead of the default job.  */ ;/**  * Uses a Quartz @PersistJobDataAfterExecution and @DisallowConcurrentExecution instead of the default job.  */ public void setStateful(boolean stateful) {     this.stateful = stateful. }
false;public;0;3;;public boolean isDurableJob() {     return durableJob. }
true;public;1;3;/**  * Whether or not the job should remain stored after it is orphaned (no triggers point to it).  */ ;/**  * Whether or not the job should remain stored after it is orphaned (no triggers point to it).  */ public void setDurableJob(boolean durableJob) {     this.durableJob = durableJob. }
false;public;0;3;;public boolean isRecoverableJob() {     return recoverableJob. }
true;public;1;3;/**  * Instructs the scheduler whether or not the job should be re-executed if a 'recovery' or 'fail-over' situation is encountered.  */ ;/**  * Instructs the scheduler whether or not the job should be re-executed if a 'recovery' or 'fail-over' situation is encountered.  */ public void setRecoverableJob(boolean recoverableJob) {     this.recoverableJob = recoverableJob. }
false;public;0;3;;public boolean isUsingFixedCamelContextName() {     return usingFixedCamelContextName. }
true;public;1;3;/**  * If it is true, JobDataMap uses the CamelContext name directly to reference the CamelContext,  * if it is false, JobDataMap uses use the CamelContext management name which could be changed during the deploy time.  */ ;/**  * If it is true, JobDataMap uses the CamelContext name directly to reference the CamelContext,  * if it is false, JobDataMap uses use the CamelContext management name which could be changed during the deploy time.  */ public void setUsingFixedCamelContextName(boolean usingFixedCamelContextName) {     this.usingFixedCamelContextName = usingFixedCamelContextName. }
false;public;0;6;;public LoadBalancer getConsumerLoadBalancer() {     if (consumerLoadBalancer == null) {         consumerLoadBalancer = new RoundRobinLoadBalancer().     }     return consumerLoadBalancer. }
false;public;1;3;;public void setConsumerLoadBalancer(LoadBalancer consumerLoadBalancer) {     this.consumerLoadBalancer = consumerLoadBalancer. }
false;public;0;3;;public Map<String, Object> getTriggerParameters() {     return triggerParameters. }
true;public;1;3;/**  * To configure additional options on the trigger.  */ ;/**  * To configure additional options on the trigger.  */ public void setTriggerParameters(Map<String, Object> triggerParameters) {     this.triggerParameters = triggerParameters. }
false;public;0;3;;public Map<String, Object> getJobParameters() {     return jobParameters. }
true;public;1;3;/**  * To configure additional options on the job.  */ ;/**  * To configure additional options on the job.  */ public void setJobParameters(Map<String, Object> jobParameters) {     this.jobParameters = jobParameters. }
false;public;0;3;;public int getStartDelayedSeconds() {     return startDelayedSeconds. }
true;public;1;3;/**  * Seconds to wait before starting the quartz scheduler.  */ ;/**  * Seconds to wait before starting the quartz scheduler.  */ public void setStartDelayedSeconds(int startDelayedSeconds) {     this.startDelayedSeconds = startDelayedSeconds. }
false;public;0;3;;public boolean isAutoStartScheduler() {     return autoStartScheduler. }
true;public;1;3;/**  * Whether or not the scheduler should be auto started.  */ ;/**  * Whether or not the scheduler should be auto started.  */ public void setAutoStartScheduler(boolean autoStartScheduler) {     this.autoStartScheduler = autoStartScheduler. }
false;public;0;3;;public boolean isPrefixJobNameWithEndpointId() {     return prefixJobNameWithEndpointId. }
true;public;1;3;/**  * Whether the job name should be prefixed with endpoint id  * @param prefixJobNameWithEndpointId  */ ;/**  * Whether the job name should be prefixed with endpoint id  * @param prefixJobNameWithEndpointId  */ public void setPrefixJobNameWithEndpointId(boolean prefixJobNameWithEndpointId) {     this.prefixJobNameWithEndpointId = prefixJobNameWithEndpointId. }
true;public;1;3;/**  * Specifies a cron expression to define when to trigger.  */ ;/**  * Specifies a cron expression to define when to trigger.  */ public void setCron(String cron) {     this.cron = cron. }
false;public;0;3;;public TriggerKey getTriggerKey() {     return triggerKey. }
false;public;1;3;;public void setTriggerKey(TriggerKey triggerKey) {     this.triggerKey = triggerKey. }
false;public;0;3;;public Calendar getCustomCalendar() {     return customCalendar. }
true;public;1;3;/**  * Specifies a custom calendar to avoid specific range of date  */ ;/**  * Specifies a custom calendar to avoid specific range of date  */ public void setCustomCalendar(Calendar customCalendar) {     this.customCalendar = customCalendar. }
false;public;0;4;;@Override public Producer createProducer() throws Exception {     throw new UnsupportedOperationException("Quartz producer is not supported."). }
false;public;1;6;;@Override public Consumer createConsumer(Processor processor) throws Exception {     QuartzConsumer result = new QuartzConsumer(this, processor).     configureConsumer(result).     return result. }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;protected;0;10;;@Override protected void doStart() throws Exception {     if (isDeleteJob() && isPauseJob()) {         throw new IllegalArgumentException("Cannot have both options deleteJob and pauseJob enabled").     }     if (ObjectHelper.isNotEmpty(customCalendar)) {         getComponent().getScheduler().addCalendar(QuartzConstants.QUARTZ_CAMEL_CUSTOM_CALENDAR, customCalendar, true, false).     }     addJobInScheduler(). }
false;protected;0;4;;@Override protected void doStop() throws Exception {     removeJobInScheduler(). }
false;private;0;24;;private void removeJobInScheduler() throws Exception {     Scheduler scheduler = getComponent().getScheduler().     if (scheduler == null) {         return.     }     if (deleteJob) {         boolean isClustered = scheduler.getMetaData().isJobStoreClustered().         if (!scheduler.isShutdown() && !isClustered) {             log.info("Deleting job {}", triggerKey).             scheduler.unscheduleJob(triggerKey).             jobAdded.set(false).         }     } else if (pauseJob) {         pauseTrigger().     }     // Decrement camel job count for this endpoint     AtomicInteger number = (AtomicInteger) scheduler.getContext().get(QuartzConstants.QUARTZ_CAMEL_JOBS_COUNT).     if (number != null) {         number.decrementAndGet().     } }
false;private;0;51;;private void addJobInScheduler() throws Exception {     // Add or use existing trigger to/from scheduler     Scheduler scheduler = getComponent().getScheduler().     JobDetail jobDetail.     Trigger oldTrigger = scheduler.getTrigger(triggerKey).     boolean triggerExisted = oldTrigger != null.     if (triggerExisted && !isRecoverableJob()) {         ensureNoDupTriggerKey().     }     jobDetail = createJobDetail().     Trigger trigger = createTrigger(jobDetail).     QuartzHelper.updateJobDataMap(getCamelContext(), jobDetail, getEndpointUri(), isUsingFixedCamelContextName()).     if (triggerExisted) {         // Reschedule job if trigger settings were changed         if (hasTriggerChanged(oldTrigger, trigger)) {             scheduler.rescheduleJob(triggerKey, trigger).         }     } else {         try {             // Schedule it now. Remember that scheduler might not be started it, but we can schedule now.             scheduler.scheduleJob(jobDetail, trigger).         } catch (ObjectAlreadyExistsException ex) {             // some other VM might may have stored the job & trigger in DB in clustered mode, in the mean time             if (!(getComponent().isClustered())) {                 throw ex.             } else {                 trigger = scheduler.getTrigger(triggerKey).                 if (trigger == null) {                     throw new SchedulerException("Trigger could not be found in quartz scheduler.").                 }             }         }     }     if (log.isInfoEnabled()) {         log.info("Job {} (triggerType={}, jobClass={}) is scheduled. Next fire date is {}", new Object[] { trigger.getKey(), trigger.getClass().getSimpleName(), jobDetail.getJobClass().getSimpleName(), trigger.getNextFireTime() }).     }     // Increase camel job count for this endpoint     AtomicInteger number = (AtomicInteger) scheduler.getContext().get(QuartzConstants.QUARTZ_CAMEL_JOBS_COUNT).     if (number != null) {         number.incrementAndGet().     }     jobAdded.set(true). }
false;private;2;14;;private boolean hasTriggerChanged(Trigger oldTrigger, Trigger newTrigger) {     if (newTrigger instanceof CronTrigger && oldTrigger instanceof CronTrigger) {         CronTrigger newCron = (CronTrigger) newTrigger.         CronTrigger oldCron = (CronTrigger) oldTrigger.         return !newCron.getCronExpression().equals(oldCron.getCronExpression()).     } else if (newTrigger instanceof SimpleTrigger && oldTrigger instanceof SimpleTrigger) {         SimpleTrigger newSimple = (SimpleTrigger) newTrigger.         SimpleTrigger oldSimple = (SimpleTrigger) oldTrigger.         return newSimple.getRepeatInterval() != oldSimple.getRepeatInterval() || newSimple.getRepeatCount() != oldSimple.getRepeatCount().     } else {         return !newTrigger.getClass().equals(oldTrigger.getClass()) || !newTrigger.equals(oldTrigger).     } }
false;private;0;11;;private void ensureNoDupTriggerKey() {     for (Route route : getCamelContext().getRoutes()) {         if (route.getEndpoint() instanceof QuartzEndpoint) {             QuartzEndpoint quartzEndpoint = (QuartzEndpoint) route.getEndpoint().             TriggerKey checkTriggerKey = quartzEndpoint.getTriggerKey().             if (triggerKey.equals(checkTriggerKey)) {                 throw new IllegalArgumentException("Trigger key " + triggerKey + " is already in use by " + quartzEndpoint).             }         }     } }
false;private;1;104;;private Trigger createTrigger(JobDetail jobDetail) throws Exception {     Trigger result.     Date startTime = new Date().     if (getComponent().getScheduler().isStarted()) {         startTime = new Date(System.currentTimeMillis() + triggerStartDelay).     }     if (cron != null) {         log.debug("Creating CronTrigger: {}", cron).         String timeZone = (String) triggerParameters.get("timeZone").         if (timeZone != null) {             if (ObjectHelper.isNotEmpty(customCalendar)) {                 result = TriggerBuilder.newTrigger().withIdentity(triggerKey).startAt(startTime).withSchedule(cronSchedule(cron).withMisfireHandlingInstructionFireAndProceed().inTimeZone(TimeZone.getTimeZone(timeZone))).modifiedByCalendar(QuartzConstants.QUARTZ_CAMEL_CUSTOM_CALENDAR).build().             } else {                 result = TriggerBuilder.newTrigger().withIdentity(triggerKey).startAt(startTime).withSchedule(cronSchedule(cron).withMisfireHandlingInstructionFireAndProceed().inTimeZone(TimeZone.getTimeZone(timeZone))).build().             }             jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_CRON_TIMEZONE, timeZone).         } else {             if (ObjectHelper.isNotEmpty(customCalendar)) {                 result = TriggerBuilder.newTrigger().withIdentity(triggerKey).startAt(startTime).withSchedule(cronSchedule(cron).withMisfireHandlingInstructionFireAndProceed()).modifiedByCalendar(QuartzConstants.QUARTZ_CAMEL_CUSTOM_CALENDAR).build().             } else {                 result = TriggerBuilder.newTrigger().withIdentity(triggerKey).startAt(startTime).withSchedule(cronSchedule(cron).withMisfireHandlingInstructionFireAndProceed()).build().             }         }         // enrich job map with details         jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_TYPE, "cron").         jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_CRON_EXPRESSION, cron).     } else {         log.debug("Creating SimpleTrigger.").         int repeat = SimpleTrigger.REPEAT_INDEFINITELY.         String repeatString = (String) triggerParameters.get("repeatCount").         if (repeatString != null) {             repeat = EndpointHelper.resolveParameter(getCamelContext(), repeatString, Integer.class).             // need to update the parameters             triggerParameters.put("repeatCount", repeat).         }         // default use 1 sec interval         long interval = 1000.         String intervalString = (String) triggerParameters.get("repeatInterval").         if (intervalString != null) {             interval = EndpointHelper.resolveParameter(getCamelContext(), intervalString, Long.class).             // need to update the parameters             triggerParameters.put("repeatInterval", interval).         }         TriggerBuilder<SimpleTrigger> triggerBuilder.         if (ObjectHelper.isNotEmpty(customCalendar)) {             triggerBuilder = TriggerBuilder.newTrigger().withIdentity(triggerKey).startAt(startTime).withSchedule(simpleSchedule().withMisfireHandlingInstructionFireNow().withRepeatCount(repeat).withIntervalInMilliseconds(interval)).modifiedByCalendar(QuartzConstants.QUARTZ_CAMEL_CUSTOM_CALENDAR).         } else {             triggerBuilder = TriggerBuilder.newTrigger().withIdentity(triggerKey).startAt(startTime).withSchedule(simpleSchedule().withMisfireHandlingInstructionFireNow().withRepeatCount(repeat).withIntervalInMilliseconds(interval)).         }         if (fireNow) {             triggerBuilder = triggerBuilder.startNow().         }         result = triggerBuilder.build().         // enrich job map with details         jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_TYPE, "simple").         jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_SIMPLE_REPEAT_COUNTER, repeat).         jobDetail.getJobDataMap().put(QuartzConstants.QUARTZ_TRIGGER_SIMPLE_REPEAT_INTERVAL, interval).     }     if (triggerParameters != null && triggerParameters.size() > 0) {         log.debug("Setting user extra triggerParameters {}", triggerParameters).         setProperties(result, triggerParameters).     }     log.debug("Created trigger={}", result).     return result. }
false;private;0;28;;private JobDetail createJobDetail() throws Exception {     // Camel endpoint timer will assume one to one for JobDetail and Trigger, so let's use same name as trigger     String name = triggerKey.getName().     String group = triggerKey.getGroup().     Class<? extends Job> jobClass = stateful ? StatefulCamelJob.class : CamelJob.class.     log.debug("Creating new {}.", jobClass.getSimpleName()).     JobBuilder builder = JobBuilder.newJob(jobClass).withIdentity(name, group).     if (durableJob) {         builder = builder.storeDurably().     }     if (recoverableJob) {         builder = builder.requestRecovery().     }     JobDetail result = builder.build().     // Let user parameters to further set JobDetail properties.     if (jobParameters != null && jobParameters.size() > 0) {         log.debug("Setting user extra jobParameters {}", jobParameters).         setProperties(result, jobParameters).     }     log.debug("Created jobDetail={}", result).     return result. }
false;public;0;4;;@Override public QuartzComponent getComponent() {     return (QuartzComponent) super.getComponent(). }
false;public;0;14;;public void pauseTrigger() throws Exception {     Scheduler scheduler = getComponent().getScheduler().     boolean isClustered = scheduler.getMetaData().isJobStoreClustered().     if (jobPaused.get() || isClustered) {         return.     }     jobPaused.set(true).     if (!scheduler.isShutdown()) {         log.info("Pausing trigger {}", triggerKey).         scheduler.pauseTrigger(triggerKey).     } }
false;public;0;12;;public void resumeTrigger() throws Exception {     if (!jobPaused.get()) {         return.     }     jobPaused.set(false).     Scheduler scheduler = getComponent().getScheduler().     if (scheduler != null) {         log.info("Resuming trigger {}", triggerKey).         scheduler.resumeTrigger(triggerKey).     } }
false;public;1;8;;public void onConsumerStart(QuartzConsumer quartzConsumer) throws Exception {     getConsumerLoadBalancer().addProcessor(quartzConsumer.getAsyncProcessor()).     if (!jobAdded.get()) {         addJobInScheduler().     } else {         resumeTrigger().     } }
false;public;1;6;;public void onConsumerStop(QuartzConsumer quartzConsumer) throws Exception {     getConsumerLoadBalancer().removeProcessor(quartzConsumer.getAsyncProcessor()).     if (jobAdded.get()) {         pauseTrigger().     } }
