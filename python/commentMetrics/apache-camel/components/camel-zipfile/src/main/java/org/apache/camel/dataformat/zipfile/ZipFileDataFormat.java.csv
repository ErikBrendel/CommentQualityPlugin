commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getDataFormatName() {     return "zipfile". }
false;public;3;30;;@Override public void marshal(final Exchange exchange, final Object graph, final OutputStream stream) throws Exception {     String filename.     String filepath = exchange.getIn().getHeader(FILE_NAME, String.class).     if (filepath == null) {         // generate the file name as the camel file component would do         filename = filepath = StringHelper.sanitize(exchange.getIn().getMessageId()).     } else {         // remove any path elements         filename = Paths.get(filepath).getFileName().toString().     }     ZipOutputStream zos = new ZipOutputStream(stream).     if (preservePathElements) {         createZipEntries(zos, filepath).     } else {         createZipEntries(zos, filename).     }     InputStream is = exchange.getContext().getTypeConverter().mandatoryConvertTo(InputStream.class, exchange, graph).     try {         IOHelper.copy(is, zos).     } finally {         IOHelper.close(is, zos).     }     String newFilename = filename + ".zip".     exchange.getOut().setHeader(FILE_NAME, newFilename). }
false;public;2;28;;@Override public Object unmarshal(final Exchange exchange, final InputStream inputStream) throws Exception {     if (usingIterator) {         ZipIterator zipIterator = new ZipIterator(exchange, inputStream).         zipIterator.setAllowEmptyDirectory(allowEmptyDirectory).         return zipIterator.     } else {         ZipInputStream zis = new ZipInputStream(inputStream).         OutputStreamBuilder osb = OutputStreamBuilder.withExchange(exchange).         try {             ZipEntry entry = zis.getNextEntry().             if (entry != null) {                 exchange.getOut().setHeader(FILE_NAME, entry.getName()).                 IOHelper.copy(zis, osb).             }             entry = zis.getNextEntry().             if (entry != null) {                 throw new IllegalStateException("Zip file has more than 1 entry.").             }             return osb.build().         } finally {             IOHelper.close(zis, osb).         }     } }
false;private;2;20;;private void createZipEntries(ZipOutputStream zos, String filepath) throws IOException {     Iterator<Path> elements = Paths.get(filepath).iterator().     StringBuilder sb = new StringBuilder().     while (elements.hasNext()) {         Path path = elements.next().         String element = path.toString().         // The "/" at the end tells the ZipEntry it is a folder         if (elements.hasNext()) {             element += "/".         }         // Each entry needs the complete path, including previous created folders.         zos.putNextEntry(new ZipEntry(sb + element)).         sb.append(element).     } }
false;public;0;3;;public boolean isUsingIterator() {     return usingIterator. }
false;public;1;3;;public void setUsingIterator(boolean usingIterator) {     this.usingIterator = usingIterator. }
false;public;0;3;;public boolean isAllowEmptyDirectory() {     return allowEmptyDirectory. }
false;public;1;3;;public void setAllowEmptyDirectory(boolean allowEmptyDirectory) {     this.allowEmptyDirectory = allowEmptyDirectory. }
false;public;0;3;;public boolean isPreservePathElements() {     return preservePathElements. }
false;public;1;3;;public void setPreservePathElements(boolean preservePathElements) {     this.preservePathElements = preservePathElements. }
false;protected;0;4;;@Override protected void doStart() throws Exception { // noop }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
