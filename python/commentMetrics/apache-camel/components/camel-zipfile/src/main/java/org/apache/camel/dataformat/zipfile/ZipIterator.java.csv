commented;modifiers;parameterAmount;loc;comment;code
false;public;0;22;;@Override public boolean hasNext() {     try {         if (zipInputStream == null) {             return false.         }         boolean availableDataInCurrentEntry = zipInputStream.available() == 1.         if (!availableDataInCurrentEntry) {             // advance to the next entry.             parent = getNextElement().             if (parent == null) {                 zipInputStream.close().                 availableDataInCurrentEntry = false.             } else {                 availableDataInCurrentEntry = true.             }         }         return availableDataInCurrentEntry.     } catch (IOException exception) {         throw new RuntimeCamelException(exception).     } }
false;public;0;11;;@Override public Message next() {     if (parent == null) {         parent = getNextElement().     }     Message answer = parent.     parent = null.     checkNullAnswer(answer).     return answer. }
false;private;0;24;;private Message getNextElement() {     if (zipInputStream == null) {         return null.     }     try {         ZipEntry current = getNextEntry().         if (current != null) {             LOGGER.debug("read zipEntry {}", current.getName()).             Message answer = new DefaultMessage(exchange.getContext()).             answer.getHeaders().putAll(exchange.getIn().getHeaders()).             answer.setHeader("zipFileName", current.getName()).             answer.setHeader(Exchange.FILE_NAME, current.getName()).             answer.setBody(new ZipInputStreamWrapper(zipInputStream)).             return answer.         } else {             LOGGER.trace("close zipInputStream").             return null.         }     } catch (IOException exception) {         throw new RuntimeCamelException(exception).     } }
false;public;1;6;;public void checkNullAnswer(Message answer) {     if (answer == null && zipInputStream != null) {         IOHelper.close(zipInputStream).         zipInputStream = null.     } }
false;private;0;15;;private ZipEntry getNextEntry() throws IOException {     ZipEntry entry.     while ((entry = zipInputStream.getNextEntry()) != null) {         if (!entry.isDirectory()) {             return entry.         } else {             if (allowEmptyDirectory) {                 return entry.             }         }     }     return null. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;0;5;;@Override public void close() throws IOException {     IOHelper.close(zipInputStream).     zipInputStream = null. }
false;public;0;3;;public boolean isSupportIteratorForEmptyDirectory() {     return allowEmptyDirectory. }
false;public;1;3;;public void setAllowEmptyDirectory(boolean allowEmptyDirectory) {     this.allowEmptyDirectory = allowEmptyDirectory. }
