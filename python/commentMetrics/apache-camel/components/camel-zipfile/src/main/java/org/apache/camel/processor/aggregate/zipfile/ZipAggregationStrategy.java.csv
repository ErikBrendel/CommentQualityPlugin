commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Gets the prefix used when creating the ZIP file name.  * @return the prefix  */ ;/**  * Gets the prefix used when creating the ZIP file name.  * @return the prefix  */ public String getFilePrefix() {     return filePrefix. }
true;public;1;3;/**  * Sets the prefix that will be used when creating the ZIP filename.  * @param filePrefix prefix to use on ZIP file.  */ ;/**  * Sets the prefix that will be used when creating the ZIP filename.  * @param filePrefix prefix to use on ZIP file.  */ public void setFilePrefix(String filePrefix) {     this.filePrefix = filePrefix. }
true;public;0;3;/**  * Gets the suffix used when creating the ZIP file name.  * @return the suffix  */ ;/**  * Gets the suffix used when creating the ZIP file name.  * @return the suffix  */ public String getFileSuffix() {     return fileSuffix. }
true;public;1;3;/**  * Sets the suffix that will be used when creating the ZIP filename.  * @param fileSuffix suffix to use on ZIP file.  */ ;/**  * Sets the suffix that will be used when creating the ZIP filename.  * @param fileSuffix suffix to use on ZIP file.  */ public void setFileSuffix(String fileSuffix) {     this.fileSuffix = fileSuffix. }
false;public;0;3;;public File getParentDir() {     return parentDir. }
true;public;1;3;/**  * Sets the parent directory to use for writing temporary files.  */ ;/**  * Sets the parent directory to use for writing temporary files.  */ public void setParentDir(File parentDir) {     this.parentDir = parentDir. }
true;public;1;3;/**  * Sets the parent directory to use for writing temporary files.  */ ;/**  * Sets the parent directory to use for writing temporary files.  */ public void setParentDir(String parentDir) {     this.parentDir = new File(parentDir). }
false;public;2;62;;@Override public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {     File zipFile.     Exchange answer = oldExchange.     // Guard against empty new exchanges     if (newExchange == null) {         return oldExchange.     }     // First time for this aggregation     if (oldExchange == null) {         try {             zipFile = FileUtil.createTempFile(this.filePrefix, this.fileSuffix, this.parentDir).         } catch (IOException e) {             throw new GenericFileOperationFailedException(e.getMessage(), e).         }         answer = newExchange.         answer.addOnCompletion(new DeleteZipFileOnCompletion(zipFile)).     } else {         zipFile = oldExchange.getIn().getBody(File.class).     }     Object body = newExchange.getIn().getBody().     if (body instanceof WrappedFile) {         body = ((WrappedFile) body).getFile().     }     if (body instanceof File) {         try {             File appendFile = (File) body.             // do not try to append empty files             if (appendFile.length() > 0) {                 String entryName = preserveFolderStructure ? newExchange.getIn().getHeader(Exchange.FILE_NAME, String.class) : newExchange.getIn().getMessageId().                 addFileToZip(zipFile, appendFile, this.preserveFolderStructure ? entryName : null).                 GenericFile<File> genericFile = FileConsumer.asGenericFile(zipFile.getParent(), zipFile, Charset.defaultCharset().toString(), false).                 genericFile.bindToExchange(answer).             }         } catch (Exception e) {             throw new GenericFileOperationFailedException(e.getMessage(), e).         }     } else {         // Handle all other messages         try {             byte[] buffer = newExchange.getIn().getMandatoryBody(byte[].class).             // do not try to append empty data             if (buffer.length > 0) {                 String entryName = useFilenameHeader ? newExchange.getIn().getHeader(Exchange.FILE_NAME, String.class) : newExchange.getIn().getMessageId().                 addEntryToZip(zipFile, entryName, buffer, buffer.length).                 GenericFile<File> genericFile = FileConsumer.asGenericFile(zipFile.getParent(), zipFile, Charset.defaultCharset().toString(), false).                 genericFile.bindToExchange(answer).             }         } catch (Exception e) {             throw new GenericFileOperationFailedException(e.getMessage(), e).         }     }     return answer. }
false;private,static;3;33;;private static void addFileToZip(File source, File file, String fileName) throws IOException {     File tmpZip = File.createTempFile(source.getName(), null).     tmpZip.delete().     if (!source.renameTo(tmpZip)) {         throw new IOException("Could not make temp file (" + source.getName() + ")").     }     byte[] buffer = new byte[8192].     FileInputStream fis = new FileInputStream(tmpZip).     ZipInputStream zin = new ZipInputStream(fis).     ZipOutputStream out = new ZipOutputStream(new FileOutputStream(source)).     try {         InputStream in = new FileInputStream(file).         out.putNextEntry(new ZipEntry(fileName == null ? file.getName() : fileName)).         for (int read = in.read(buffer). read > -1. read = in.read(buffer)) {             out.write(buffer, 0, read).         }         out.closeEntry().         IOHelper.close(in).         for (ZipEntry ze = zin.getNextEntry(). ze != null. ze = zin.getNextEntry()) {             out.putNextEntry(ze).             for (int read = zin.read(buffer). read > -1. read = zin.read(buffer)) {                 out.write(buffer, 0, read).             }             out.closeEntry().         }     } finally {         IOHelper.close(fis, zin, out).     }     tmpZip.delete(). }
false;private,static;4;27;;private static void addEntryToZip(File source, String entryName, byte[] buffer, int length) throws IOException {     File tmpZip = File.createTempFile(source.getName(), null).     tmpZip.delete().     if (!source.renameTo(tmpZip)) {         throw new IOException("Cannot create temp file: " + source.getName()).     }     FileInputStream fis = new FileInputStream(tmpZip).     ZipInputStream zin = new ZipInputStream(fis).     ZipOutputStream out = new ZipOutputStream(new FileOutputStream(source)).     try {         out.putNextEntry(new ZipEntry(entryName)).         out.write(buffer, 0, length).         out.closeEntry().         for (ZipEntry ze = zin.getNextEntry(). ze != null. ze = zin.getNextEntry()) {             out.putNextEntry(ze).             for (int read = zin.read(buffer). read > -1. read = zin.read(buffer)) {                 out.write(buffer, 0, read).             }             out.closeEntry().         }     } finally {         IOHelper.close(fis, zin, out).     }     tmpZip.delete(). }
false;public;1;4;;@Override public void onFailure(Exchange exchange) { // Keep the file if something gone a miss. }
false;public;1;4;;@Override public void onComplete(Exchange exchange) {     FileUtil.deleteFile(this.fileToDelete). }
