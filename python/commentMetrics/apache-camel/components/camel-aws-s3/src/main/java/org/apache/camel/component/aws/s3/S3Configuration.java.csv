commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public long getPartSize() {     return partSize. }
true;public;1;3;/**  * Setup the partSize which is used in multi part upload,  * the default size is 25M.  */ ;/**  * Setup the partSize which is used in multi part upload,  * the default size is 25M.  */ public void setPartSize(long partSize) {     this.partSize = partSize. }
false;public;0;3;;public boolean isMultiPartUpload() {     return multiPartUpload. }
true;public;1;3;/**  * If it is true, camel will upload the file with multi part  * format, the part size is decided by the option of `partSize`  */ ;/**  * If it is true, camel will upload the file with multi part  * format, the part size is decided by the option of `partSize`  */ public void setMultiPartUpload(boolean multiPartUpload) {     this.multiPartUpload = multiPartUpload. }
false;public;0;3;;public String getAccessKey() {     return accessKey. }
true;public;1;3;/**  * Amazon AWS Access Key  */ ;/**  * Amazon AWS Access Key  */ public void setAccessKey(String accessKey) {     this.accessKey = accessKey. }
false;public;0;3;;public String getSecretKey() {     return secretKey. }
true;public;1;3;/**  * Amazon AWS Secret Key  */ ;/**  * Amazon AWS Secret Key  */ public void setSecretKey(String secretKey) {     this.secretKey = secretKey. }
false;public;0;3;;public AmazonS3 getAmazonS3Client() {     return amazonS3Client. }
true;public;1;3;/**  * Reference to a `com.amazonaws.services.s3.AmazonS3` in the  * link:registry.html[Registry].  */ ;/**  * Reference to a `com.amazonaws.services.s3.AmazonS3` in the  * link:registry.html[Registry].  */ public void setAmazonS3Client(AmazonS3 amazonS3Client) {     this.amazonS3Client = amazonS3Client. }
false;public;0;3;;public String getPrefix() {     return prefix. }
true;public;1;3;/**  * The prefix which is used in the  * com.amazonaws.services.s3.model.ListObjectsRequest to only consume  * objects we are interested in.  */ ;/**  * The prefix which is used in the  * com.amazonaws.services.s3.model.ListObjectsRequest to only consume  * objects we are interested in.  */ public void setPrefix(String prefix) {     this.prefix = prefix. }
false;public;0;3;;public String getBucketName() {     return bucketName. }
true;public;1;3;/**  * Name of the bucket. The bucket will be created if it doesn't already  * exists.  */ ;/**  * Name of the bucket. The bucket will be created if it doesn't already  * exists.  */ public void setBucketName(String bucketName) {     this.bucketName = bucketName. }
false;public;0;3;;public String getFileName() {     return fileName. }
true;public;1;3;/**  * To get the object from the bucket with the given file name  */ ;/**  * To get the object from the bucket with the given file name  */ public void setFileName(String fileName) {     this.fileName = fileName. }
false;public;0;3;;public String getRegion() {     return region. }
true;public;1;3;/**  * The region in which S3 client needs to work  */ ;/**  * The region in which S3 client needs to work  */ public void setRegion(String region) {     this.region = region. }
true;public;1;3;/**  * If it is true, the exchange body will be set to a stream to the contents  * of the file. If false, the headers will be set with the S3 object  * metadata, but the body will be null. This option is strongly related to  * autocloseBody option. In case of setting includeBody to true and  * autocloseBody to false, it will be up to the caller to close the S3Object  * stream. Setting autocloseBody to true, will close the S3Object stream  * automatically.  */ ;/**  * If it is true, the exchange body will be set to a stream to the contents  * of the file. If false, the headers will be set with the S3 object  * metadata, but the body will be null. This option is strongly related to  * autocloseBody option. In case of setting includeBody to true and  * autocloseBody to false, it will be up to the caller to close the S3Object  * stream. Setting autocloseBody to true, will close the S3Object stream  * automatically.  */ public void setIncludeBody(boolean includeBody) {     this.includeBody = includeBody. }
false;public;0;3;;public boolean isIncludeBody() {     return includeBody. }
false;public;0;3;;public boolean isDeleteAfterRead() {     return deleteAfterRead. }
true;public;1;3;/**  * Delete objects from S3 after they have been retrieved. The delete is only  * performed if the Exchange is committed. If a rollback occurs, the object  * is not deleted.  * <p/>  * If this option is false, then the same objects will be retrieve over and  * over again on the polls. Therefore you need to use the Idempotent  * Consumer EIP in the route to filter out duplicates. You can filter using  * the {@link S3Constants#BUCKET_NAME} and {@link S3Constants#KEY} headers,  * or only the {@link S3Constants#KEY} header.  */ ;/**  * Delete objects from S3 after they have been retrieved. The delete is only  * performed if the Exchange is committed. If a rollback occurs, the object  * is not deleted.  * <p/>  * If this option is false, then the same objects will be retrieve over and  * over again on the polls. Therefore you need to use the Idempotent  * Consumer EIP in the route to filter out duplicates. You can filter using  * the {@link S3Constants#BUCKET_NAME} and {@link S3Constants#KEY} headers,  * or only the {@link S3Constants#KEY} header.  */ public void setDeleteAfterRead(boolean deleteAfterRead) {     this.deleteAfterRead = deleteAfterRead. }
false;public;0;3;;public boolean isDeleteAfterWrite() {     return deleteAfterWrite. }
true;public;1;3;/**  * Delete file object after the S3 file has been uploaded  */ ;/**  * Delete file object after the S3 file has been uploaded  */ public void setDeleteAfterWrite(boolean deleteAfterWrite) {     this.deleteAfterWrite = deleteAfterWrite. }
false;public;0;3;;public String getPolicy() {     return policy. }
true;public;1;3;/**  * The policy for this queue to set in the  * `com.amazonaws.services.s3.AmazonS3#setBucketPolicy()` method.  */ ;/**  * The policy for this queue to set in the  * `com.amazonaws.services.s3.AmazonS3#setBucketPolicy()` method.  */ public void setPolicy(String policy) {     this.policy = policy. }
false;public;0;3;;public String getStorageClass() {     return storageClass. }
true;public;1;3;/**  * The storage class to set in the  * `com.amazonaws.services.s3.model.PutObjectRequest` request.  */ ;/**  * The storage class to set in the  * `com.amazonaws.services.s3.model.PutObjectRequest` request.  */ public void setStorageClass(String storageClass) {     this.storageClass = storageClass. }
false;public;0;3;;public String getServerSideEncryption() {     return serverSideEncryption. }
true;public;1;3;/**  * Sets the server-side encryption algorithm when encrypting  * the object using AWS-managed keys. For example use <tt>AES256</tt>.  */ ;/**  * Sets the server-side encryption algorithm when encrypting  * the object using AWS-managed keys. For example use <tt>AES256</tt>.  */ public void setServerSideEncryption(String serverSideEncryption) {     this.serverSideEncryption = serverSideEncryption. }
false;public;0;3;;public String getProxyHost() {     return proxyHost. }
true;public;1;3;/**  * To define a proxy host when instantiating the SQS client  */ ;/**  * To define a proxy host when instantiating the SQS client  */ public void setProxyHost(String proxyHost) {     this.proxyHost = proxyHost. }
false;public;0;3;;public Integer getProxyPort() {     return proxyPort. }
true;public;1;3;/**  * Specify a proxy port to be used inside the client definition.  */ ;/**  * Specify a proxy port to be used inside the client definition.  */ public void setProxyPort(Integer proxyPort) {     this.proxyPort = proxyPort. }
true;public;1;3;/**  * Whether or not the S3 client should use path style access  */ ;/**  * Whether or not the S3 client should use path style access  */ public void setPathStyleAccess(final boolean pathStyleAccess) {     this.pathStyleAccess = pathStyleAccess. }
false;public;0;3;;public boolean isPathStyleAccess() {     return pathStyleAccess. }
false;public;0;3;;public S3Operations getOperation() {     return operation. }
true;public;1;3;/**  * The operation to do in case the user don't want to do only an upload  */ ;/**  * The operation to do in case the user don't want to do only an upload  */ public void setOperation(S3Operations operation) {     this.operation = operation. }
false;public;0;3;;public boolean isAutocloseBody() {     return autocloseBody. }
true;public;1;3;/**  * If this option is true and includeBody is true, then the S3Object.close()  * method will be called on exchange completion. This option is strongly  * related to includeBody option. In case of setting includeBody to true and  * autocloseBody to false, it will be up to the caller to close the S3Object  * stream. Setting autocloseBody to true, will close the S3Object stream  * automatically.  */ ;/**  * If this option is true and includeBody is true, then the S3Object.close()  * method will be called on exchange completion. This option is strongly  * related to includeBody option. In case of setting includeBody to true and  * autocloseBody to false, it will be up to the caller to close the S3Object  * stream. Setting autocloseBody to true, will close the S3Object stream  * automatically.  */ public void setAutocloseBody(boolean autocloseBody) {     this.autocloseBody = autocloseBody. }
false;public;0;3;;public EncryptionMaterials getEncryptionMaterials() {     return encryptionMaterials. }
true;public;1;3;/**  * The encryption materials to use in case of Symmetric/Asymmetric client  * usage  */ ;/**  * The encryption materials to use in case of Symmetric/Asymmetric client  * usage  */ public void setEncryptionMaterials(EncryptionMaterials encryptionMaterials) {     this.encryptionMaterials = encryptionMaterials. }
false;public;0;3;;public boolean isUseEncryption() {     return useEncryption. }
true;public;1;3;/**  * Define if encryption must be used or not  */ ;/**  * Define if encryption must be used or not  */ public void setUseEncryption(boolean useEncryption) {     this.useEncryption = useEncryption. }
false;public;0;3;;public boolean isUseAwsKMS() {     return useAwsKMS. }
true;public;1;3;/**  * Define if KMS must be used or not  */ ;/**  * Define if KMS must be used or not  */ public void setUseAwsKMS(boolean useAwsKMS) {     this.useAwsKMS = useAwsKMS. }
false;public;0;3;;public String getAwsKMSKeyId() {     return awsKMSKeyId. }
true;public;1;3;/**  * Define the id of KMS key to use in case KMS is enabled  */ ;/**  * Define the id of KMS key to use in case KMS is enabled  */ public void setAwsKMSKeyId(String awsKMSKeyId) {     this.awsKMSKeyId = awsKMSKeyId. }
false;public;0;3;;public boolean isChunkedEncodingDisabled() {     return chunkedEncodingDisabled. }
true;public;1;3;/**  * Define if disabled Chunked Encoding is true or false  */ ;/**  * Define if disabled Chunked Encoding is true or false  */ public void setChunkedEncodingDisabled(boolean chunkedEncodingDisabled) {     this.chunkedEncodingDisabled = chunkedEncodingDisabled. }
false;public;0;3;;public boolean isAccelerateModeEnabled() {     return accelerateModeEnabled. }
true;public;1;3;/**  * Define if Accelerate Mode enabled is true or false  */ ;/**  * Define if Accelerate Mode enabled is true or false  */ public void setAccelerateModeEnabled(boolean accelerateModeEnabled) {     this.accelerateModeEnabled = accelerateModeEnabled. }
false;public;0;3;;public boolean isDualstackEnabled() {     return dualstackEnabled. }
true;public;1;3;/**  * Define if Dualstack enabled is true or false  */ ;/**  * Define if Dualstack enabled is true or false  */ public void setDualstackEnabled(boolean dualstackEnabled) {     this.dualstackEnabled = dualstackEnabled. }
false;public;0;3;;public boolean isPayloadSigningEnabled() {     return payloadSigningEnabled. }
true;public;1;3;/**  * Define if Payload Signing enabled is true or false  */ ;/**  * Define if Payload Signing enabled is true or false  */ public void setPayloadSigningEnabled(boolean payloadSigningEnabled) {     this.payloadSigningEnabled = payloadSigningEnabled. }
false;public;0;3;;public boolean isForceGlobalBucketAccessEnabled() {     return forceGlobalBucketAccessEnabled. }
true;public;1;3;/**  * Define if Force Global Bucket Access enabled is true or false  */ ;/**  * Define if Force Global Bucket Access enabled is true or false  */ public void setForceGlobalBucketAccessEnabled(boolean forceGlobalBucketAccessEnabled) {     this.forceGlobalBucketAccessEnabled = forceGlobalBucketAccessEnabled. }
true;public;1;3;/**  * Set whether the S3 client should expect to load credentials on an EC2 instance or to  * expect static credentials to be passed in.  */ ;/**  * Set whether the S3 client should expect to load credentials on an EC2 instance or to  * expect static credentials to be passed in.  */ public void setUseIAMCredentials(Boolean useIAMCredentials) {     this.useIAMCredentials = useIAMCredentials. }
false;public;0;3;;public Boolean isUseIAMCredentials() {     return useIAMCredentials. }
false;public;0;3;;public boolean hasProxyConfiguration() {     return ObjectHelper.isNotEmpty(getProxyHost()) && ObjectHelper.isNotEmpty(getProxyPort()). }
false;public;0;7;;// ************************************************* //  // ************************************************* public S3Configuration copy() {     try {         return (S3Configuration) super.clone().     } catch (CloneNotSupportedException e) {         throw new RuntimeCamelException(e).     } }
