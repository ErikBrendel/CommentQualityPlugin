commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;public Consumer createConsumer(Processor processor) throws Exception {     S3Consumer s3Consumer = new S3Consumer(this, processor).     configureConsumer(s3Consumer).     s3Consumer.setMaxMessagesPerPoll(maxMessagesPerPoll).     return s3Consumer. }
false;public;0;3;;public Producer createProducer() throws Exception {     return new S3Producer(this). }
false;public;0;3;;public boolean isSingleton() {     return true. }
false;public;0;49;;@Override public void doStart() throws Exception {     super.doStart().     s3Client = configuration.getAmazonS3Client() != null ? configuration.getAmazonS3Client() : S3ClientFactory.getAWSS3Client(configuration, getMaxConnections()).getS3Client().     String fileName = getConfiguration().getFileName().     if (fileName != null) {         LOG.trace("File name [{}] requested, so skipping bucket check...", fileName).         return.     }     String bucketName = getConfiguration().getBucketName().     LOG.trace("Querying whether bucket [{}] already exists...", bucketName).     String prefix = getConfiguration().getPrefix().     try {         s3Client.listObjects(new ListObjectsRequest(bucketName, prefix, null, null, 0)).         LOG.trace("Bucket [{}] already exists", bucketName).         return.     } catch (AmazonServiceException ase) {         /* 404 means the bucket doesn't exist */         if (ase.getStatusCode() != 404) {             throw ase.         }     }     LOG.trace("Bucket [{}] doesn't exist yet", bucketName).     // creates the new bucket because it doesn't exist yet     CreateBucketRequest createBucketRequest = new CreateBucketRequest(getConfiguration().getBucketName()).     LOG.trace("Creating bucket [{}] in region [{}] with request [{}]...", configuration.getBucketName(), configuration.getRegion(), createBucketRequest).     s3Client.createBucket(createBucketRequest).     LOG.trace("Bucket created").     if (configuration.getPolicy() != null) {         LOG.trace("Updating bucket [{}] with policy [{}]", bucketName, configuration.getPolicy()).         s3Client.setBucketPolicy(bucketName, configuration.getPolicy()).         LOG.trace("Bucket policy updated").     } }
false;public;0;9;;@Override public void doStop() throws Exception {     if (ObjectHelper.isEmpty(configuration.getAmazonS3Client())) {         if (s3Client != null) {             s3Client.shutdown().         }     }     super.doStop(). }
false;public;1;3;;public Exchange createExchange(S3Object s3Object) {     return createExchange(getExchangePattern(), s3Object). }
false;public;1;4;;@Override public void onDone(Exchange exchange) {     IOHelper.close(s3Object). }
false;public;2;55;;public Exchange createExchange(ExchangePattern pattern, S3Object s3Object) {     LOG.trace("Getting object with key [{}] from bucket [{}]...", s3Object.getKey(), s3Object.getBucketName()).     ObjectMetadata objectMetadata = s3Object.getObjectMetadata().     LOG.trace("Got object [{}]", s3Object).     Exchange exchange = super.createExchange(pattern).     Message message = exchange.getIn().     if (configuration.isIncludeBody()) {         message.setBody(s3Object.getObjectContent()).     } else {         message.setBody(null).     }     message.setHeader(S3Constants.KEY, s3Object.getKey()).     message.setHeader(S3Constants.BUCKET_NAME, s3Object.getBucketName()).     message.setHeader(S3Constants.E_TAG, objectMetadata.getETag()).     message.setHeader(S3Constants.LAST_MODIFIED, objectMetadata.getLastModified()).     message.setHeader(S3Constants.VERSION_ID, objectMetadata.getVersionId()).     message.setHeader(S3Constants.CONTENT_TYPE, objectMetadata.getContentType()).     message.setHeader(S3Constants.CONTENT_MD5, objectMetadata.getContentMD5()).     message.setHeader(S3Constants.CONTENT_LENGTH, objectMetadata.getContentLength()).     message.setHeader(S3Constants.CONTENT_ENCODING, objectMetadata.getContentEncoding()).     message.setHeader(S3Constants.CONTENT_DISPOSITION, objectMetadata.getContentDisposition()).     message.setHeader(S3Constants.CACHE_CONTROL, objectMetadata.getCacheControl()).     message.setHeader(S3Constants.S3_HEADERS, objectMetadata.getRawMetadata()).     message.setHeader(S3Constants.SERVER_SIDE_ENCRYPTION, objectMetadata.getSSEAlgorithm()).     message.setHeader(S3Constants.USER_METADATA, objectMetadata.getUserMetadata()).     message.setHeader(S3Constants.EXPIRATION_TIME, objectMetadata.getExpirationTime()).     message.setHeader(S3Constants.REPLICATION_STATUS, objectMetadata.getReplicationStatus()).     message.setHeader(S3Constants.STORAGE_CLASS, objectMetadata.getStorageClass()).     /**      * If includeBody != true, it is safe to close the object here. If      * includeBody == true, the caller is responsible for closing the stream      * and object once the body has been fully consumed. As of 2.17, the      * consumer does not close the stream or object on commit.      */     if (!configuration.isIncludeBody()) {         IOHelper.close(s3Object).     } else {         if (configuration.isAutocloseBody()) {             exchange.addOnCompletion(new SynchronizationAdapter() {                  @Override                 public void onDone(Exchange exchange) {                     IOHelper.close(s3Object).                 }             }).         }     }     return exchange. }
false;public;0;3;;public S3Configuration getConfiguration() {     return configuration. }
false;public;1;3;;public void setConfiguration(S3Configuration configuration) {     this.configuration = configuration. }
false;public;1;3;;public void setS3Client(AmazonS3 s3Client) {     this.s3Client = s3Client. }
false;public;0;3;;public AmazonS3 getS3Client() {     return s3Client. }
false;public;0;3;;public int getMaxMessagesPerPoll() {     return maxMessagesPerPoll. }
true;public;1;3;/**  * Gets the maximum number of messages as a limit to poll at each polling.  * <p/>  * Is default unlimited, but use 0 or negative number to disable it as  * unlimited.  */ ;/**  * Gets the maximum number of messages as a limit to poll at each polling.  * <p/>  * Is default unlimited, but use 0 or negative number to disable it as  * unlimited.  */ public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {     this.maxMessagesPerPoll = maxMessagesPerPoll. }
false;public;0;3;;public int getMaxConnections() {     return maxConnections. }
true;public;1;3;/**  * Set the maxConnections parameter in the S3 client configuration  */ ;/**  * Set the maxConnections parameter in the S3 client configuration  */ public void setMaxConnections(int maxConnections) {     this.maxConnections = maxConnections. }
