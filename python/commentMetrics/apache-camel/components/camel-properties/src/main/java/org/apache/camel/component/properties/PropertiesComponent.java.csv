commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;25;;@Override protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {     List<PropertiesLocation> paths = locations.     Boolean ignoreMissingLocationLoc = getAndRemoveParameter(parameters, "ignoreMissingLocation", Boolean.class).     if (ignoreMissingLocationLoc != null) {         ignoreMissingLocation = ignoreMissingLocationLoc.     }     // override default locations     String locations = getAndRemoveParameter(parameters, "locations", String.class).     if (locations != null) {         log.trace("Overriding default locations with location: {}", locations).         paths = Arrays.stream(locations.split(",")).map(PropertiesLocation::new).collect(Collectors.toList()).     }     String endpointUri = parseUri(remaining, paths).     log.debug("Endpoint uri parsed as: {}", endpointUri).     Endpoint delegate = getCamelContext().getEndpoint(endpointUri).     PropertiesEndpoint answer = new PropertiesEndpoint(uri, delegate, this).     setProperties(answer, parameters).     return answer. }
false;public;1;3;;public String parseUri(String uri) throws Exception {     return parseUri(uri, locations). }
false;public;2;7;;public String parseUri(String uri, String... uris) throws Exception {     return parseUri(uri, uris != null ? Arrays.stream(uris).map(PropertiesLocation::new).collect(Collectors.toList()) : Collections.emptyList()). }
false;public;2;59;;public String parseUri(String uri, List<PropertiesLocation> paths) throws Exception {     Properties prop = new Properties().     // use initial properties     if (initialProperties != null) {         prop.putAll(initialProperties).     }     // use locations     if (paths != null) {         // location may contain JVM system property or OS environment variables         // so we need to parse those         List<PropertiesLocation> locations = parseLocations(paths).         // check cache first         CacheKey key = new CacheKey(locations).         Properties locationsProp = cache ? cacheMap.get(key) : null.         if (locationsProp == null) {             locationsProp = propertiesResolver.resolveProperties(getCamelContext(), ignoreMissingLocation, locations).             if (cache) {                 cacheMap.put(key, locationsProp).             }         }         prop.putAll(locationsProp).     }     // use override properties     if (overrideProperties != null) {         // make a copy to avoid affecting the original properties         Properties override = new Properties().         override.putAll(prop).         override.putAll(overrideProperties).         prop = override.     }     // enclose tokens if missing     if (!uri.contains(prefixToken) && !uri.startsWith(prefixToken)) {         uri = prefixToken + uri.     }     if (!uri.contains(suffixToken) && !uri.endsWith(suffixToken)) {         uri = uri + suffixToken.     }     log.trace("Parsing uri {} with properties: {}", uri, prop).     if (propertiesParser instanceof AugmentedPropertyNameAwarePropertiesParser) {         return ((AugmentedPropertyNameAwarePropertiesParser) propertiesParser).parseUri(uri, prop, prefixToken, suffixToken, propertyPrefixResolved, propertySuffixResolved, fallbackToUnaugmentedProperty, defaultFallbackEnabled).     } else {         return propertiesParser.parseUri(uri, prop, prefixToken, suffixToken).     } }
false;public;0;3;;public List<PropertiesLocation> getLocations() {     return locations. }
true;public;1;3;/**  * A list of locations to load properties.  * This option will override any default locations and only use the locations from this option.  */ ;/**  * A list of locations to load properties.  * This option will override any default locations and only use the locations from this option.  */ public void setLocations(List<PropertiesLocation> locations) {     this.locations = Collections.unmodifiableList(locations). }
true;public;1;10;/**  * A list of locations to load properties.  * This option will override any default locations and only use the locations from this option.  */ ;/**  * A list of locations to load properties.  * This option will override any default locations and only use the locations from this option.  */ public void setLocations(String[] locationStrings) {     List<PropertiesLocation> locations = new ArrayList<>().     if (locationStrings != null) {         for (String locationString : locationStrings) {             locations.add(new PropertiesLocation(locationString)).         }     }     setLocations(locations). }
true;public;1;10;/**  * A list of locations to load properties.  * This option will override any default locations and only use the locations from this option.  */ ;/**  * A list of locations to load properties.  * This option will override any default locations and only use the locations from this option.  */ public void setLocations(Collection<String> locationStrings) {     List<PropertiesLocation> locations = new ArrayList<>().     if (locationStrings != null) {         for (String locationString : locationStrings) {             locations.add(new PropertiesLocation(locationString)).         }     }     setLocations(locations). }
false;public;1;13;;public void addLocation(String location) {     if (location != null) {         List<PropertiesLocation> newLocations = new ArrayList<>().         for (String loc : location.split(",")) {             newLocations.add(new PropertiesLocation(loc)).         }         List<PropertiesLocation> current = getLocations().         if (!current.isEmpty()) {             newLocations.addAll(0, current).         }         setLocations(newLocations).     } }
true;public;1;5;/**  * A list of locations to load properties. You can use comma to separate multiple locations.  * This option will override any default locations and only use the locations from this option.  */ ;/**  * A list of locations to load properties. You can use comma to separate multiple locations.  * This option will override any default locations and only use the locations from this option.  */ public void setLocation(String location) {     if (location != null) {         setLocations(location.split(",")).     } }
false;public;0;3;;public String getEncoding() {     return encoding. }
true;public;1;3;/**  * Encoding to use when loading properties file from the file system or classpath.  * <p/>  * If no encoding has been set, then the properties files is loaded using ISO-8859-1 encoding (latin-1)  * as documented by {@link java.util.Properties#load(java.io.InputStream)}  */ ;/**  * Encoding to use when loading properties file from the file system or classpath.  * <p/>  * If no encoding has been set, then the properties files is loaded using ISO-8859-1 encoding (latin-1)  * as documented by {@link java.util.Properties#load(java.io.InputStream)}  */ public void setEncoding(String encoding) {     this.encoding = encoding. }
false;public;0;3;;public PropertiesResolver getPropertiesResolver() {     return propertiesResolver. }
true;public;1;3;/**  * To use a custom PropertiesResolver  */ ;/**  * To use a custom PropertiesResolver  */ public void setPropertiesResolver(PropertiesResolver propertiesResolver) {     this.propertiesResolver = propertiesResolver. }
false;public;0;3;;public PropertiesParser getPropertiesParser() {     return propertiesParser. }
true;public;1;3;/**  * To use a custom PropertiesParser  */ ;/**  * To use a custom PropertiesParser  */ public void setPropertiesParser(PropertiesParser propertiesParser) {     this.propertiesParser = propertiesParser. }
false;public;0;3;;public boolean isCache() {     return cache. }
true;public;1;3;/**  * Whether or not to cache loaded properties. The default value is true.  */ ;/**  * Whether or not to cache loaded properties. The default value is true.  */ public void setCache(boolean cache) {     this.cache = cache. }
false;public;0;3;;public String getPropertyPrefix() {     return propertyPrefix. }
true;public;1;7;/**  * Optional prefix prepended to property names before resolution.  */ ;/**  * Optional prefix prepended to property names before resolution.  */ public void setPropertyPrefix(String propertyPrefix) {     this.propertyPrefix = propertyPrefix.     this.propertyPrefixResolved = propertyPrefix.     if (ObjectHelper.isNotEmpty(this.propertyPrefix)) {         this.propertyPrefixResolved = FilePathResolver.resolvePath(this.propertyPrefix).     } }
false;public;0;3;;public String getPropertySuffix() {     return propertySuffix. }
true;public;1;7;/**  * Optional suffix appended to property names before resolution.  */ ;/**  * Optional suffix appended to property names before resolution.  */ public void setPropertySuffix(String propertySuffix) {     this.propertySuffix = propertySuffix.     this.propertySuffixResolved = propertySuffix.     if (ObjectHelper.isNotEmpty(this.propertySuffix)) {         this.propertySuffixResolved = FilePathResolver.resolvePath(this.propertySuffix).     } }
false;public;0;3;;public boolean isFallbackToUnaugmentedProperty() {     return fallbackToUnaugmentedProperty. }
true;public;1;3;/**  * If true, first attempt resolution of property name augmented with propertyPrefix and propertySuffix  * before falling back the plain property name specified. If false, only the augmented property name is searched.  */ ;/**  * If true, first attempt resolution of property name augmented with propertyPrefix and propertySuffix  * before falling back the plain property name specified. If false, only the augmented property name is searched.  */ public void setFallbackToUnaugmentedProperty(boolean fallbackToUnaugmentedProperty) {     this.fallbackToUnaugmentedProperty = fallbackToUnaugmentedProperty. }
false;public;0;3;;public boolean isDefaultFallbackEnabled() {     return defaultFallbackEnabled. }
true;public;1;3;/**  * If false, the component does not attempt to find a default for the key by looking after the colon separator.  */ ;/**  * If false, the component does not attempt to find a default for the key by looking after the colon separator.  */ public void setDefaultFallbackEnabled(boolean defaultFallbackEnabled) {     this.defaultFallbackEnabled = defaultFallbackEnabled. }
false;public;0;3;;public boolean isIgnoreMissingLocation() {     return ignoreMissingLocation. }
true;public;1;3;/**  * Whether to silently ignore if a location cannot be located, such as a properties file not found.  */ ;/**  * Whether to silently ignore if a location cannot be located, such as a properties file not found.  */ public void setIgnoreMissingLocation(boolean ignoreMissingLocation) {     this.ignoreMissingLocation = ignoreMissingLocation. }
false;public;0;3;;public String getPrefixToken() {     return prefixToken. }
true;public;1;7;/**  * Sets the value of the prefix token used to identify properties to replace.  Setting a value of  * {@code null} restores the default token (@link {@link #DEFAULT_PREFIX_TOKEN}).  */ ;/**  * Sets the value of the prefix token used to identify properties to replace.  Setting a value of  * {@code null} restores the default token (@link {@link #DEFAULT_PREFIX_TOKEN}).  */ public void setPrefixToken(String prefixToken) {     if (prefixToken == null) {         this.prefixToken = DEFAULT_PREFIX_TOKEN.     } else {         this.prefixToken = prefixToken.     } }
false;public;0;3;;public String getSuffixToken() {     return suffixToken. }
true;public;1;7;/**  * Sets the value of the suffix token used to identify properties to replace.  Setting a value of  * {@code null} restores the default token (@link {@link #DEFAULT_SUFFIX_TOKEN}).  */ ;/**  * Sets the value of the suffix token used to identify properties to replace.  Setting a value of  * {@code null} restores the default token (@link {@link #DEFAULT_SUFFIX_TOKEN}).  */ public void setSuffixToken(String suffixToken) {     if (suffixToken == null) {         this.suffixToken = DEFAULT_SUFFIX_TOKEN.     } else {         this.suffixToken = suffixToken.     } }
false;public;0;3;;public Properties getInitialProperties() {     return initialProperties. }
true;public;1;3;/**  * Sets initial properties which will be used before any locations are resolved.  *  * @param initialProperties properties that are added first  */ ;/**  * Sets initial properties which will be used before any locations are resolved.  *  * @param initialProperties properties that are added first  */ public void setInitialProperties(Properties initialProperties) {     this.initialProperties = initialProperties. }
false;public;0;3;;public Properties getOverrideProperties() {     return overrideProperties. }
true;public;1;3;/**  * Sets a special list of override properties that take precedence  * and will use first, if a property exist.  *  * @param overrideProperties properties that is used first  */ ;/**  * Sets a special list of override properties that take precedence  * and will use first, if a property exist.  *  * @param overrideProperties properties that is used first  */ public void setOverrideProperties(Properties overrideProperties) {     this.overrideProperties = overrideProperties. }
true;public;0;3;/**  * Gets the functions registered in this properties component.  */ ;/**  * Gets the functions registered in this properties component.  */ public Map<String, PropertiesFunction> getFunctions() {     return functions. }
true;public;1;3;/**  * Registers the {@link org.apache.camel.component.properties.PropertiesFunction} as a function to this component.  */ ;/**  * Registers the {@link org.apache.camel.component.properties.PropertiesFunction} as a function to this component.  */ public void addFunction(PropertiesFunction function) {     this.functions.put(function.getName(), function). }
true;public;1;3;/**  * Is there a {@link org.apache.camel.component.properties.PropertiesFunction} with the given name?  */ ;/**  * Is there a {@link org.apache.camel.component.properties.PropertiesFunction} with the given name?  */ public boolean hasFunction(String name) {     return functions.containsKey(name). }
false;public;0;3;;public int getSystemPropertiesMode() {     return systemPropertiesMode. }
true;public;1;3;/**  * Sets the system property (and environment variable) mode.  *  * The default mode (override) is to check system properties (and environment variables) first,  * before trying the specified properties.  * This allows system properties/environment variables to override any other property source.  *  * @see #SYSTEM_PROPERTIES_MODE_NEVER  * @see #SYSTEM_PROPERTIES_MODE_FALLBACK  * @see #SYSTEM_PROPERTIES_MODE_OVERRIDE  */ ;/**  * Sets the system property (and environment variable) mode.  *  * The default mode (override) is to check system properties (and environment variables) first,  * before trying the specified properties.  * This allows system properties/environment variables to override any other property source.  *  * @see #SYSTEM_PROPERTIES_MODE_NEVER  * @see #SYSTEM_PROPERTIES_MODE_FALLBACK  * @see #SYSTEM_PROPERTIES_MODE_OVERRIDE  */ public void setSystemPropertiesMode(int systemPropertiesMode) {     this.systemPropertiesMode = systemPropertiesMode. }
false;public;0;3;;public int getEnvironmentVariableMode() {     return environmentVariableMode. }
true;public;1;3;/**  * Sets the OS environment variables mode.  *  * The default mode (fallback) is to check OS environment variables,  * if the property cannot be resolved from its sources first.  * This allows environment variables as fallback values.  *  * @see #ENVIRONMENT_VARIABLES_MODE_NEVER  * @see #ENVIRONMENT_VARIABLES_MODE_FALLBACK  * @see #ENVIRONMENT_VARIABLES_MODE_OVERRIDE  */ ;/**  * Sets the OS environment variables mode.  *  * The default mode (fallback) is to check OS environment variables,  * if the property cannot be resolved from its sources first.  * This allows environment variables as fallback values.  *  * @see #ENVIRONMENT_VARIABLES_MODE_NEVER  * @see #ENVIRONMENT_VARIABLES_MODE_FALLBACK  * @see #ENVIRONMENT_VARIABLES_MODE_OVERRIDE  */ public void setEnvironmentVariableMode(int environmentVariableMode) {     this.environmentVariableMode = environmentVariableMode. }
false;public;0;5;;@Override public boolean isResolvePropertyPlaceholders() {     // its chicken and egg, we cannot resolve placeholders on ourselves     return false. }
false;protected;0;20;;@Override protected void doStart() throws Exception {     super.doStart().     if (systemPropertiesMode != SYSTEM_PROPERTIES_MODE_NEVER && systemPropertiesMode != SYSTEM_PROPERTIES_MODE_FALLBACK && systemPropertiesMode != SYSTEM_PROPERTIES_MODE_OVERRIDE) {         throw new IllegalArgumentException("Option systemPropertiesMode has invalid value: " + systemPropertiesMode).     }     if (environmentVariableMode != ENVIRONMENT_VARIABLES_MODE_NEVER && environmentVariableMode != ENVIRONMENT_VARIABLES_MODE_FALLBACK && environmentVariableMode != ENVIRONMENT_VARIABLES_MODE_OVERRIDE) {         throw new IllegalArgumentException("Option environmentVariableMode has invalid value: " + environmentVariableMode).     }     // inject the component to the parser     if (propertiesParser instanceof DefaultPropertiesParser) {         ((DefaultPropertiesParser) propertiesParser).setPropertiesComponent(this).     } }
false;protected;0;5;;@Override protected void doStop() throws Exception {     cacheMap.clear().     super.doStop(). }
false;private;1;28;;private List<PropertiesLocation> parseLocations(List<PropertiesLocation> locations) {     List<PropertiesLocation> answer = new ArrayList<>().     for (PropertiesLocation location : locations) {         log.trace("Parsing location: {}", location).         try {             String path = FilePathResolver.resolvePath(location.getPath()).             log.debug("Parsed location: {}", path).             if (ObjectHelper.isNotEmpty(path)) {                 answer.add(new PropertiesLocation(location.getResolver(), path, location.isOptional())).             }         } catch (IllegalArgumentException e) {             if (!ignoreMissingLocation && !location.isOptional()) {                 throw e.             } else {                 log.debug("Ignored missing location: {}", location).             }         }     }     // must return a not-null answer     return answer. }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     CacheKey that = (CacheKey) o.     return locations.equals(that.locations). }
false;public;0;4;;@Override public int hashCode() {     return locations.hashCode(). }
false;public;0;4;;@Override public String toString() {     return "LocationKey[" + locations.toString() + "]". }
