commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public PropertiesComponent getPropertiesComponent() {     return propertiesComponent. }
false;public;1;3;;public void setPropertiesComponent(PropertiesComponent propertiesComponent) {     this.propertiesComponent = propertiesComponent. }
false;public;4;4;;@Override public String parseUri(String text, Properties properties, String prefixToken, String suffixToken) throws IllegalArgumentException {     return parseUri(text, properties, prefixToken, suffixToken, null, null, false, false). }
false;public;8;7;;@Override public String parseUri(String text, Properties properties, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty, boolean defaultFallbackEnabled) throws IllegalArgumentException {     ParsingContext context = new ParsingContext(properties, prefixToken, suffixToken, propertyPrefix, propertySuffix, fallbackToUnaugmentedProperty, defaultFallbackEnabled).     return context.parse(text). }
false;public;3;3;;public String parseProperty(String key, String value, Properties properties) {     return value. }
true;public;1;3;/**  * Parses the given input string and replaces all properties  *  * @param input Input string  * @return Evaluated string  */ ;/**  * Parses the given input string and replaces all properties  *  * @param input Input string  * @return Evaluated string  */ public String parse(String input) {     return doParse(input, new HashSet<String>()). }
true;private;2;21;/**  * Recursively parses the given input string and replaces all properties  *  * @param input                Input string  * @param replacedPropertyKeys Already replaced property keys used for tracking circular references  * @return Evaluated string  */ ;/**  * Recursively parses the given input string and replaces all properties  *  * @param input                Input string  * @param replacedPropertyKeys Already replaced property keys used for tracking circular references  * @return Evaluated string  */ private String doParse(String input, Set<String> replacedPropertyKeys) {     if (input == null) {         return null.     }     String answer = input.     Property property.     while ((property = readProperty(answer)) != null) {         // Check for circular references         if (replacedPropertyKeys.contains(property.getKey())) {             throw new IllegalArgumentException("Circular reference detected with key [" + property.getKey() + "] from text: " + input).         }         Set<String> newReplaced = new HashSet<>(replacedPropertyKeys).         newReplaced.add(property.getKey()).         String before = answer.substring(0, property.getBeginIndex()).         String after = answer.substring(property.getEndIndex()).         answer = before + doParse(property.getValue(), newReplaced) + after.     }     return answer. }
true;private;1;22;/**  * Finds a property in the given string. It returns {@code null} if there's no property defined.  *  * @param input Input string  * @return A property in the given string or {@code null} if not found  */ ;/**  * Finds a property in the given string. It returns {@code null} if there's no property defined.  *  * @param input Input string  * @return A property in the given string or {@code null} if not found  */ private Property readProperty(String input) {     // Find the index of the first valid suffix token     int suffix = getSuffixIndex(input).     // If not found, ensure that there is no valid prefix token in the string     if (suffix == -1) {         if (getMatchingPrefixIndex(input, input.length()) != -1) {             throw new IllegalArgumentException(String.format("Missing %s from the text: %s", suffixToken, input)).         }         return null.     }     // Find the index of the prefix token that matches the suffix token     int prefix = getMatchingPrefixIndex(input, suffix).     if (prefix == -1) {         throw new IllegalArgumentException(String.format("Missing %s from the text: %s", prefixToken, input)).     }     String key = input.substring(prefix + prefixToken.length(), suffix).     String value = getPropertyValue(key, input).     return new Property(prefix, suffix + suffixToken.length(), key, value). }
true;private;1;7;/**  * Gets the first index of the suffix token that is not surrounded by quotes  *  * @param input Input string  * @return First index of the suffix token that is not surrounded by quotes  */ ;/**  * Gets the first index of the suffix token that is not surrounded by quotes  *  * @param input Input string  * @return First index of the suffix token that is not surrounded by quotes  */ private int getSuffixIndex(String input) {     int index = -1.     do {         index = input.indexOf(suffixToken, index + 1).     } while (index != -1 && isQuoted(input, index, suffixToken)).     return index. }
true;private;2;7;/**  * Gets the index of the prefix token that matches the suffix at the given index and that is not surrounded by quotes  *  * @param input       Input string  * @param suffixIndex Index of the suffix token  * @return Index of the prefix token that matches the suffix at the given index and that is not surrounded by quotes  */ ;/**  * Gets the index of the prefix token that matches the suffix at the given index and that is not surrounded by quotes  *  * @param input       Input string  * @param suffixIndex Index of the suffix token  * @return Index of the prefix token that matches the suffix at the given index and that is not surrounded by quotes  */ private int getMatchingPrefixIndex(String input, int suffixIndex) {     int index = suffixIndex.     do {         index = input.lastIndexOf(prefixToken, index - 1).     } while (index != -1 && isQuoted(input, index, prefixToken)).     return index. }
true;private;3;10;/**  * Indicates whether or not the token at the given index is surrounded by single or double quotes  *  * @param input Input string  * @param index Index of the token  * @param token Token  * @return {@code true}  */ ;/**  * Indicates whether or not the token at the given index is surrounded by single or double quotes  *  * @param input Input string  * @param index Index of the token  * @param token Token  * @return {@code true}  */ private boolean isQuoted(String input, int index, String token) {     int beforeIndex = index - 1.     int afterIndex = index + token.length().     if (beforeIndex >= 0 && afterIndex < input.length()) {         char before = input.charAt(beforeIndex).         char after = input.charAt(afterIndex).         return (before == after) && (before == '\'' || before == '"').     }     return false. }
true;private;2;60;/**  * Gets the value of the property with given key  *  * @param key   Key of the property  * @param input Input string (used for exception message if value not found)  * @return Value of the property with the given key  */ ;/**  * Gets the value of the property with given key  *  * @param key   Key of the property  * @param input Input string (used for exception message if value not found)  * @return Value of the property with the given key  */ private String getPropertyValue(String key, String input) {     // the key may be a function, so lets check this first     if (propertiesComponent != null) {         for (PropertiesFunction function : propertiesComponent.getFunctions().values()) {             String token = function.getName() + ":".             if (key.startsWith(token)) {                 String remainder = key.substring(token.length()).                 log.debug("Property with key [{}] is applied by function [{}]", key, function.getName()).                 String value = function.apply(remainder).                 if (value == null) {                     throw new IllegalArgumentException("Property with key [" + key + "] using function [" + function.getName() + "]" + " returned null value which is not allowed, from input: " + input).                 } else {                     if (log.isDebugEnabled()) {                         log.debug("Property with key [{}] applied by function [{}] -> {}", key, function.getName(), value).                     }                     return value.                 }             }         }     }     // they key may have a get or else expression     String defaultValue = null.     if (defaultFallbackEnabled && key.contains(GET_OR_ELSE_TOKEN)) {         defaultValue = StringHelper.after(key, GET_OR_ELSE_TOKEN).         key = StringHelper.before(key, GET_OR_ELSE_TOKEN).     }     String augmentedKey = getAugmentedKey(key).     boolean shouldFallback = fallbackToUnaugmentedProperty && !key.equals(augmentedKey).     String value = doGetPropertyValue(augmentedKey).     if (value == null && shouldFallback) {         log.debug("Property with key [{}] not found, attempting with unaugmented key: {}", augmentedKey, key).         value = doGetPropertyValue(key).     }     if (value == null && defaultValue != null) {         log.debug("Property with key [{}] not found, using default value: {}", augmentedKey, defaultValue).         value = defaultValue.     }     if (value == null) {         StringBuilder esb = new StringBuilder().         if (propertiesComponent == null || propertiesComponent.getCamelContext().getGlobalOption(PropertiesComponent.DEFAULT_CREATED) != null) {             // if the component was auto created then include more information that the end user should define it             esb.append("PropertiesComponent with name properties must be defined in CamelContext to support property placeholders. ").         }         esb.append("Property with key [").append(augmentedKey).append("] ").         if (shouldFallback) {             esb.append("(and original key [").append(key).append("]) ").         }         esb.append("not found in properties from text: ").append(input).         throw new IllegalArgumentException(esb.toString()).     }     return value. }
true;private;1;12;/**  * Gets the augmented key of the given base key  *  * @param key Base key  * @return Augmented key  */ ;/**  * Gets the augmented key of the given base key  *  * @param key Base key  * @return Augmented key  */ private String getAugmentedKey(String key) {     String augmentedKey = key.     if (propertyPrefix != null) {         log.debug("Augmenting property key [{}] with prefix: {}", key, propertyPrefix).         augmentedKey = propertyPrefix + augmentedKey.     }     if (propertySuffix != null) {         log.debug("Augmenting property key [{}] with suffix: {}", key, propertySuffix).         augmentedKey = augmentedKey + propertySuffix.     }     return augmentedKey. }
true;private;1;47;/**  * Gets the property with the given key, it returns {@code null} if the property is not found  *  * @param key Key of the property  * @return Value of the property or {@code null} if not found  */ ;/**  * Gets the property with the given key, it returns {@code null} if the property is not found  *  * @param key Key of the property  * @return Value of the property or {@code null} if not found  */ private String doGetPropertyValue(String key) {     if (ObjectHelper.isEmpty(key)) {         return parseProperty(key, null, properties).     }     String value = null.     // override is the default mode for SYS     int sysMode = propertiesComponent != null ? propertiesComponent.getSystemPropertiesMode() : PropertiesComponent.SYSTEM_PROPERTIES_MODE_OVERRIDE.     // fallback is the default mode for ENV     int envMode = propertiesComponent != null ? propertiesComponent.getEnvironmentVariableMode() : PropertiesComponent.ENVIRONMENT_VARIABLES_MODE_FALLBACK.     if (sysMode == PropertiesComponent.SYSTEM_PROPERTIES_MODE_OVERRIDE) {         value = System.getProperty(key).         if (value != null) {             log.debug("Found a JVM system property: {} with value: {} to be used.", key, value).         }     }     if (value == null && envMode == PropertiesComponent.ENVIRONMENT_VARIABLES_MODE_OVERRIDE) {         value = System.getenv(key).         if (value != null) {             log.debug("Found a environment property: {} with value: {} to be used.", key, value).         }     }     if (value == null && properties != null) {         value = properties.getProperty(key).         if (value != null) {             log.debug("Found property: {} with value: {} to be used.", key, value).         }     }     if (value == null && sysMode == PropertiesComponent.SYSTEM_PROPERTIES_MODE_FALLBACK) {         value = System.getProperty(key).         if (value != null) {             log.debug("Found a JVM system property: {} with value: {} to be used.", key, value).         }     }     if (value == null && envMode == PropertiesComponent.ENVIRONMENT_VARIABLES_MODE_FALLBACK) {         value = System.getenv(key).         if (value != null) {             log.debug("Found a environment property: {} with value: {} to be used.", key, value).         }     }     return parseProperty(key, value, properties). }
true;public;0;3;/**  * Gets the begin index of the property (including the prefix token).  */ ;/**  * Gets the begin index of the property (including the prefix token).  */ public int getBeginIndex() {     return beginIndex. }
true;public;0;3;/**  * Gets the end index of the property (including the suffix token).  */ ;/**  * Gets the end index of the property (including the suffix token).  */ public int getEndIndex() {     return endIndex. }
true;public;0;3;/**  * Gets the key of the property.  */ ;/**  * Gets the key of the property.  */ public String getKey() {     return key. }
true;public;0;3;/**  * Gets the value of the property.  */ ;/**  * Gets the value of the property.  */ public String getValue() {     return value. }
