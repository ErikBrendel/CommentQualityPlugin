commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Creates a new MessageConsumerResources instance.  *  * @see org.apache.commons.pool.PoolableObjectFactory#makeObject()  */ ;/**  * Creates a new MessageConsumerResources instance.  *  * @see org.apache.commons.pool.PoolableObjectFactory#makeObject()  */ @Override public MessageConsumerResources makeObject() throws Exception {     return createConsumer(). }
true;public;1;21;/**  * Cleans up the MessageConsumerResources.  *  * @see org.apache.commons.pool.PoolableObjectFactory#destroyObject(java.lang.Object)  */ ;/**  * Cleans up the MessageConsumerResources.  *  * @see org.apache.commons.pool.PoolableObjectFactory#destroyObject(java.lang.Object)  */ @Override public void destroyObject(MessageConsumerResources model) throws Exception {     if (model != null) {         // First clean up our message consumer         if (model.getMessageConsumer() != null) {             model.getMessageConsumer().close().         }         // If the resource has a         if (model.getSession() != null) {             if (model.getSession().getTransacted()) {                 try {                     model.getSession().rollback().                 } catch (Exception e) {                 // Do nothing. Just make sure we are cleaned up                 }             }             model.getSession().close().         }     } }
false;public;0;4;;@Override public SjmsEndpoint getEndpoint() {     return (SjmsEndpoint) super.getEndpoint(). }
false;public;0;8;;@Override public void run() {     try {         fillConsumersPool().     } catch (Throwable e) {         log.warn("Error starting listener container on destination: " + getDestinationName() + ". This exception will be ignored.", e).     } }
false;public;0;4;;@Override public String toString() {     return "AsyncStartListenerTask[" + getDestinationName() + "]". }
false;protected;0;30;;@Override protected void doStart() throws Exception {     super.doStart().     this.executor = getEndpoint().getCamelContext().getExecutorServiceManager().newDefaultThreadPool(this, "SjmsConsumer").     if (consumers == null) {         consumers = new GenericObjectPool<>(new MessageConsumerResourcesFactory()).         consumers.setMaxActive(getConsumerCount()).         consumers.setMaxIdle(getConsumerCount()).         if (getEndpoint().isAsyncStartListener()) {             asyncStart = getEndpoint().getComponent().getAsyncStartStopExecutorService().submit(new Runnable() {                  @Override                 public void run() {                     try {                         fillConsumersPool().                     } catch (Throwable e) {                         log.warn("Error starting listener container on destination: " + getDestinationName() + ". This exception will be ignored.", e).                     }                 }                  @Override                 public String toString() {                     return "AsyncStartListenerTask[" + getDestinationName() + "]".                 }             }).         } else {             fillConsumersPool().         }     } }
false;private;0;5;;private void fillConsumersPool() throws Exception {     while (consumers.getNumIdle() < consumers.getMaxIdle()) {         consumers.addObject().     } }
false;public;0;9;;@Override public void run() {     try {         consumers.close().         consumers = null.     } catch (Throwable e) {         log.warn("Error stopping listener container on destination: " + getDestinationName() + ". This exception will be ignored.", e).     } }
false;public;0;4;;@Override public String toString() {     return "AsyncStopListenerTask[" + getDestinationName() + "]". }
false;protected;0;33;;@Override protected void doStop() throws Exception {     super.doStop().     if (asyncStart != null && !asyncStart.isDone()) {         asyncStart.cancel(true).     }     if (consumers != null) {         if (getEndpoint().isAsyncStopListener()) {             getEndpoint().getComponent().getAsyncStartStopExecutorService().submit(new Runnable() {                  @Override                 public void run() {                     try {                         consumers.close().                         consumers = null.                     } catch (Throwable e) {                         log.warn("Error stopping listener container on destination: " + getDestinationName() + ". This exception will be ignored.", e).                     }                 }                  @Override                 public String toString() {                     return "AsyncStopListenerTask[" + getDestinationName() + "]".                 }             }).         } else {             consumers.close().             consumers = null.         }     }     if (this.executor != null) {         getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(this.executor).     } }
true;private;0;19;/**  * Creates a {@link MessageConsumerResources} with a dedicated  * {@link Session} required for transacted and InOut consumers.  */ ;/**  * Creates a {@link MessageConsumerResources} with a dedicated  * {@link Session} required for transacted and InOut consumers.  */ private MessageConsumerResources createConsumer() throws Exception {     MessageConsumerResources answer.     ConnectionResource connectionResource = getOrCreateConnectionResource().     Connection conn = connectionResource.borrowConnection().     try {         Session session = conn.createSession(isTransacted(), isTransacted() ? Session.SESSION_TRANSACTED : Session.AUTO_ACKNOWLEDGE).         MessageConsumer messageConsumer = getEndpoint().getJmsObjectFactory().createMessageConsumer(session, getEndpoint()).         MessageListener handler = createMessageHandler(session).         messageConsumer.setMessageListener(handler).         answer = new MessageConsumerResources(session, messageConsumer).     } catch (Exception e) {         log.error("Unable to create the MessageConsumer", e).         throw e.     } finally {         connectionResource.returnConnection(conn).     }     return answer. }
true;protected;1;42;/**  * Helper factory method used to create a MessageListener based on the MEP  *  * @param session a session is only required if we are a transacted consumer  * @return the listener  */ ;/**  * Helper factory method used to create a MessageListener based on the MEP  *  * @param session a session is only required if we are a transacted consumer  * @return the listener  */ protected MessageListener createMessageHandler(Session session) {     TransactionCommitStrategy commitStrategy.     if (getTransactionCommitStrategy() != null) {         commitStrategy = getTransactionCommitStrategy().     } else if (getTransactionBatchCount() > 0) {         commitStrategy = new BatchTransactionCommitStrategy(getTransactionBatchCount()).     } else {         commitStrategy = new DefaultTransactionCommitStrategy().     }     Synchronization synchronization.     if (commitStrategy instanceof BatchTransactionCommitStrategy) {         TimedTaskManager timedTaskManager = getEndpoint().getComponent().getTimedTaskManager().         synchronization = new SessionBatchTransactionSynchronization(timedTaskManager, session, commitStrategy, getTransactionBatchTimeout()).     } else {         synchronization = new SessionTransactionSynchronization(session, commitStrategy).     }     AbstractMessageHandler messageHandler.     if (getEndpoint().getExchangePattern().equals(ExchangePattern.InOnly)) {         if (isTransacted() || isSynchronous()) {             messageHandler = new InOnlyMessageHandler(getEndpoint(), executor, synchronization).         } else {             messageHandler = new InOnlyMessageHandler(getEndpoint(), executor).         }     } else {         if (isTransacted() || isSynchronous()) {             messageHandler = new InOutMessageHandler(getEndpoint(), executor, synchronization).         } else {             messageHandler = new InOutMessageHandler(getEndpoint(), executor).         }     }     messageHandler.setSession(session).     messageHandler.setProcessor(getAsyncProcessor()).     messageHandler.setSynchronous(isSynchronous()).     messageHandler.setTransacted(isTransacted()).     messageHandler.setSharedJMSSession(isSharedJMSSession()).     messageHandler.setTopic(isTopic()).     return messageHandler. }
true;protected;0;4;/**  * @deprecated use {@link #getOrCreateConnectionResource()}  */ ;/**  * @deprecated use {@link #getOrCreateConnectionResource()}  */ @Deprecated protected ConnectionResource getConnectionResource() {     return getEndpoint().getConnectionResource(). }
false;protected;0;7;;protected ConnectionResource getOrCreateConnectionResource() {     ConnectionResource answer = getEndpoint().getConnectionResource().     if (answer == null) {         answer = getEndpoint().createConnectionResource(this).     }     return answer. }
false;public;0;3;;public int getAcknowledgementMode() {     return getEndpoint().getAcknowledgementMode().intValue(). }
true;public;0;3;/**  * Use to determine if transactions are enabled or disabled.  *  * @return true if transacted, otherwise false  */ ;/**  * Use to determine if transactions are enabled or disabled.  *  * @return true if transacted, otherwise false  */ public boolean isTransacted() {     return getEndpoint().isTransacted(). }
true;public;0;3;/**  * Use to determine if JMS session should be propagated to share with other SJMS endpoints.  *  * @return true if shared, otherwise false  */ ;/**  * Use to determine if JMS session should be propagated to share with other SJMS endpoints.  *  * @return true if shared, otherwise false  */ public boolean isSharedJMSSession() {     return getEndpoint().isSharedJMSSession(). }
true;public;0;3;/**  * Use to determine whether or not to process exchanges synchronously.  *  * @return true if synchronous  */ ;/**  * Use to determine whether or not to process exchanges synchronously.  *  * @return true if synchronous  */ public boolean isSynchronous() {     return getEndpoint().isSynchronous(). }
true;public;0;3;/**  * The destination name for this consumer.  *  * @return String  */ ;/**  * The destination name for this consumer.  *  * @return String  */ public String getDestinationName() {     return getEndpoint().getDestinationName(). }
true;public;0;3;/**  * Returns the number of consumer listeners.  *  * @return the consumerCount  */ ;/**  * Returns the number of consumer listeners.  *  * @return the consumerCount  */ public int getConsumerCount() {     return getEndpoint().getConsumerCount(). }
true;public;0;3;/**  * Flag set by the endpoint used by consumers and producers to determine if  * the consumer is a JMS Topic.  *  * @return the topic true if consumer is a JMS Topic, default is false  */ ;/**  * Flag set by the endpoint used by consumers and producers to determine if  * the consumer is a JMS Topic.  *  * @return the topic true if consumer is a JMS Topic, default is false  */ public boolean isTopic() {     return getEndpoint().isTopic(). }
true;public;0;3;/**  * Gets the JMS Message selector syntax.  */ ;/**  * Gets the JMS Message selector syntax.  */ public String getMessageSelector() {     return getEndpoint().getMessageSelector(). }
true;public;0;3;/**  * Gets the durable subscription Id.  *  * @return the durableSubscriptionId  */ ;/**  * Gets the durable subscription Id.  *  * @return the durableSubscriptionId  */ public String getDurableSubscriptionId() {     return getEndpoint().getDurableSubscriptionId(). }
true;public;0;3;/**  * Gets the commit strategy.  *  * @return the transactionCommitStrategy  */ ;/**  * Gets the commit strategy.  *  * @return the transactionCommitStrategy  */ public TransactionCommitStrategy getTransactionCommitStrategy() {     return getEndpoint().getTransactionCommitStrategy(). }
true;public;0;3;/**  * If transacted, returns the nubmer of messages to be processed before  * committing the transaction.  *  * @return the transactionBatchCount  */ ;/**  * If transacted, returns the nubmer of messages to be processed before  * committing the transaction.  *  * @return the transactionBatchCount  */ public int getTransactionBatchCount() {     return getEndpoint().getTransactionBatchCount(). }
true;public;0;3;/**  * Returns the timeout value for batch transactions.  *  * @return long  */ ;/**  * Returns the timeout value for batch transactions.  *  * @return long  */ public long getTransactionBatchTimeout() {     return getEndpoint().getTransactionBatchTimeout(). }
