commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;15;;@Override protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {     ConnectionFactory cf = resolveAndRemoveReferenceParameter(parameters, "connectionFactory", ConnectionFactory.class).     if (cf != null) {         setConnectionFactory(cf).     }     ObjectHelper.notNull(connectionFactory, "connectionFactory").     SjmsBatchEndpoint answer = new SjmsBatchEndpoint(uri, this, remaining).     answer.setAsyncStartListener(isAsyncStartListener()).     answer.setRecoveryInterval(getRecoveryInterval()).     setProperties(answer, parameters).     return answer. }
false;public;0;3;;public ConnectionFactory getConnectionFactory() {     return connectionFactory. }
true;public;1;3;/**  * A ConnectionFactory is required to enable the SjmsBatchComponent.  */ ;/**  * A ConnectionFactory is required to enable the SjmsBatchComponent.  */ public void setConnectionFactory(ConnectionFactory connectionFactory) {     this.connectionFactory = connectionFactory. }
false;public;0;3;;public boolean isAsyncStartListener() {     return asyncStartListener. }
true;public;1;3;/**  * Whether to startup the consumer message listener asynchronously, when starting a route.  * For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying  * and/or failover. This will cause Camel to block while starting routes. By setting this option to true,  * you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread  * in asynchronous mode. If this option is used, then beware that if the connection could not be established,  * then an exception is logged at WARN level, and the consumer will not be able to receive messages.  * You can then restart the route to retry.  */ ;/**  * Whether to startup the consumer message listener asynchronously, when starting a route.  * For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying  * and/or failover. This will cause Camel to block while starting routes. By setting this option to true,  * you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread  * in asynchronous mode. If this option is used, then beware that if the connection could not be established,  * then an exception is logged at WARN level, and the consumer will not be able to receive messages.  * You can then restart the route to retry.  */ public void setAsyncStartListener(boolean asyncStartListener) {     this.asyncStartListener = asyncStartListener. }
false;public;0;3;;public int getRecoveryInterval() {     return recoveryInterval. }
true;public;1;3;/**  * Specifies the interval between recovery attempts, i.e. when a connection is being refreshed, in milliseconds.  * The default is 5000 ms, that is, 5 seconds.  */ ;/**  * Specifies the interval between recovery attempts, i.e. when a connection is being refreshed, in milliseconds.  * The default is 5000 ms, that is, 5 seconds.  */ public void setRecoveryInterval(int recoveryInterval) {     this.recoveryInterval = recoveryInterval. }
false;protected;0;8;;@Override protected void doShutdown() throws Exception {     if (asyncStartStopExecutorService != null) {         getCamelContext().getExecutorServiceManager().shutdownNow(asyncStartStopExecutorService).         asyncStartStopExecutorService = null.     }     super.doShutdown(). }
false;protected,synchronized;0;8;;protected synchronized ExecutorService getAsyncStartStopExecutorService() {     if (asyncStartStopExecutorService == null) {         // use a cached thread pool for async start tasks as they can run for a while, and we need a dedicated thread         // for each task, and the thread pool will shrink when no more tasks running         asyncStartStopExecutorService = getCamelContext().getExecutorServiceManager().newCachedThreadPool(this, "AsyncStartStopListener").     }     return asyncStartStopExecutorService. }
