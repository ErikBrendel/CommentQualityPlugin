commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public SjmsComponent getComponent() {     return (SjmsComponent) super.getComponent(). }
false;protected;0;17;;@Override protected void doStart() throws Exception {     super.doStart().     if (!isAsyncStartListener()) {         // if we are not async starting then create connection eager         if (getConnectionResource() == null) {             if (getConnectionFactory() != null) {                 connectionResource = createConnectionResource(this).                 // we created the resource so we should close it when stopping                 closeConnectionResource = true.             }         } else if (getConnectionResource() instanceof ConnectionFactoryResource) {             ((ConnectionFactoryResource) getConnectionResource()).fillPool().         }     } }
false;protected;0;11;;@Override protected void doStop() throws Exception {     if (closeConnectionResource) {         if (connectionResource instanceof ConnectionFactoryResource) {             ((ConnectionFactoryResource) getConnectionResource()).drainPool().         }         closeConnectionResource = false.         connectionResource = null.     }     super.doStop(). }
false;public;0;10;;@Override public Producer createProducer() throws Exception {     SjmsProducer producer.     if (getExchangePattern().equals(ExchangePattern.InOnly)) {         producer = new InOnlyProducer(this).     } else {         producer = new InOutProducer(this).     }     return producer. }
false;public;1;6;;@Override public Consumer createConsumer(Processor processor) throws Exception {     SjmsConsumer answer = new SjmsConsumer(this, processor).     configureConsumer(answer).     return answer. }
false;public;0;4;;@Override public boolean isMultipleConsumersSupported() {     return true. }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;protected;1;24;;protected ConnectionResource createConnectionResource(Object source) {     if (getConnectionFactory() == null) {         throw new IllegalArgumentException(String.format("ConnectionResource or ConnectionFactory must be configured for %s", this)).     }     try {         logger.debug("Creating ConnectionResource with connectionCount: {} using ConnectionFactory", getConnectionCount(), getConnectionFactory()).         // We always use a connection pool, even for a pool of 1         ConnectionFactoryResource connections = new ConnectionFactoryResource(getConnectionCount(), getConnectionFactory(), getComponent().getConnectionUsername(), getComponent().getConnectionPassword(), getComponent().getConnectionClientId(), getComponent().getConnectionMaxWait(), getComponent().isConnectionTestOnBorrow()).         if (exceptionListener != null) {             connections.setExceptionListener(exceptionListener).         } else {             // add a exception listener that logs so we can see any errors that happens             ExceptionListener listener = new SjmsLoggingExceptionListener(new LoggingExceptionHandler(getCamelContext(), source.getClass()), isErrorHandlerLogStackTrace()).             connections.setExceptionListener(listener).         }         connections.fillPool().         return connections.     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;public;2;5;;public Exchange createExchange(Message message, Session session) {     Exchange exchange = createExchange(getExchangePattern()).     exchange.setIn(new SjmsMessage(exchange, message, session, getBinding())).     return exchange. }
false;public;0;6;;public JmsBinding getBinding() {     if (binding == null) {         binding = createBinding().     }     return binding. }
true;protected;0;3;/**  * Creates the {@link org.apache.camel.component.sjms.jms.JmsBinding} to use.  */ ;/**  * Creates the {@link org.apache.camel.component.sjms.jms.JmsBinding} to use.  */ protected JmsBinding createBinding() {     return new JmsBinding(isMapJmsMessage(), isAllowNullBody(), getHeaderFilterStrategy(), getJmsKeyFormatStrategy(), getMessageCreatedStrategy()). }
true;public;1;3;/**  * Sets the binding used to convert from a Camel message to and from a JMS  * message  */ ;/**  * Sets the binding used to convert from a Camel message to and from a JMS  * message  */ public void setBinding(JmsBinding binding) {     this.binding = binding. }
true;public;1;3;/**  * DestinationName is a JMS queue or topic name. By default, the destinationName is interpreted as a queue name.  */ ;/**  * DestinationName is a JMS queue or topic name. By default, the destinationName is interpreted as a queue name.  */ public void setDestinationName(String destinationName) {     this.destinationName = destinationName. }
false;public;0;3;;public String getDestinationName() {     return destinationName. }
false;public;0;6;;public HeaderFilterStrategy getHeaderFilterStrategy() {     if (headerFilterStrategy == null) {         headerFilterStrategy = new SjmsHeaderFilterStrategy(isIncludeAllJMSXProperties()).     }     return headerFilterStrategy. }
true;public;1;3;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ ;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ public void setHeaderFilterStrategy(HeaderFilterStrategy strategy) {     this.headerFilterStrategy = strategy. }
false;public;0;3;;public boolean isIncludeAllJMSXProperties() {     return includeAllJMSXProperties. }
true;public;1;3;/**  * Whether to include all JMSXxxx properties when mapping from JMS to Camel Message.  * Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc.  * Note: If you are using a custom headerFilterStrategy then this option does not apply.  */ ;/**  * Whether to include all JMSXxxx properties when mapping from JMS to Camel Message.  * Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc.  * Note: If you are using a custom headerFilterStrategy then this option does not apply.  */ public void setIncludeAllJMSXProperties(boolean includeAllJMSXProperties) {     this.includeAllJMSXProperties = includeAllJMSXProperties. }
false;public;0;10;;public ConnectionResource getConnectionResource() {     ConnectionResource answer = null.     if (connectionResource != null) {         answer = connectionResource.     }     if (answer == null) {         answer = getComponent().getConnectionResource().     }     return answer. }
true;public;1;3;/**  * Initializes the connectionResource for the endpoint, which takes precedence over the component's connectionResource, if any  */ ;/**  * Initializes the connectionResource for the endpoint, which takes precedence over the component's connectionResource, if any  */ public void setConnectionResource(String connectionResource) {     this.connectionResource = EndpointHelper.resolveReferenceParameter(getCamelContext(), connectionResource, ConnectionResource.class). }
false;public;0;3;;public boolean isSynchronous() {     return synchronous. }
true;public;1;3;/**  * Sets whether synchronous processing should be strictly used or Camel is allowed to use asynchronous processing (if supported).  */ ;/**  * Sets whether synchronous processing should be strictly used or Camel is allowed to use asynchronous processing (if supported).  */ public void setSynchronous(boolean synchronous) {     this.synchronous = synchronous. }
false;public;0;3;;public SessionAcknowledgementType getAcknowledgementMode() {     return acknowledgementMode. }
true;public;1;3;/**  * The JMS acknowledgement name, which is one of: SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE  */ ;/**  * The JMS acknowledgement name, which is one of: SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE  */ public void setAcknowledgementMode(SessionAcknowledgementType acknowledgementMode) {     this.acknowledgementMode = acknowledgementMode. }
true;public;0;3;/**  * Flag set by the endpoint used by consumers and producers to determine if  * the endpoint is a JMS Topic.  */ ;/**  * Flag set by the endpoint used by consumers and producers to determine if  * the endpoint is a JMS Topic.  */ public boolean isTopic() {     return topic. }
true;public;0;4;/**  * Returns the number of Session instances expected on this endpoint.  */ ;/**  * Returns the number of Session instances expected on this endpoint.  */ @Deprecated public int getSessionCount() {     return sessionCount. }
true;public;1;4;/**  * Sets the number of Session instances used for this endpoint. Value is  * ignored for endpoints that require a dedicated session such as a  * transacted or InOut endpoint.  *  * @param sessionCount the number of Session instances, default is 1  */ ;/**  * Sets the number of Session instances used for this endpoint. Value is  * ignored for endpoints that require a dedicated session such as a  * transacted or InOut endpoint.  *  * @param sessionCount the number of Session instances, default is 1  */ @Deprecated public void setSessionCount(int sessionCount) {     this.sessionCount = sessionCount. }
false;public;0;3;;public int getProducerCount() {     return producerCount. }
true;public;1;3;/**  * Sets the number of producers used for this endpoint.  */ ;/**  * Sets the number of producers used for this endpoint.  */ public void setProducerCount(int producerCount) {     this.producerCount = producerCount. }
false;public;0;3;;public int getConsumerCount() {     return consumerCount. }
true;public;1;3;/**  * Sets the number of consumer listeners used for this endpoint.  */ ;/**  * Sets the number of consumer listeners used for this endpoint.  */ public void setConsumerCount(int consumerCount) {     this.consumerCount = consumerCount. }
false;public;0;3;;public long getTtl() {     return ttl. }
true;public;1;3;/**  * Flag used to adjust the Time To Live value of produced messages.  */ ;/**  * Flag used to adjust the Time To Live value of produced messages.  */ public void setTtl(long ttl) {     this.ttl = ttl. }
false;public;0;3;;public boolean isPersistent() {     return persistent. }
true;public;1;3;/**  * Flag used to enable/disable message persistence.  */ ;/**  * Flag used to enable/disable message persistence.  */ public void setPersistent(boolean persistent) {     this.persistent = persistent. }
false;public;0;3;;public String getDurableSubscriptionId() {     return durableSubscriptionId. }
true;public;1;3;/**  * Sets the durable subscription Id required for durable topics.  */ ;/**  * Sets the durable subscription Id required for durable topics.  */ public void setDurableSubscriptionId(String durableSubscriptionId) {     this.durableSubscriptionId = durableSubscriptionId. }
false;public;0;3;;public long getResponseTimeOut() {     return responseTimeOut. }
true;public;1;3;/**  * Sets the amount of time we should wait before timing out a InOut response.  */ ;/**  * Sets the amount of time we should wait before timing out a InOut response.  */ public void setResponseTimeOut(long responseTimeOut) {     this.responseTimeOut = responseTimeOut. }
false;public;0;3;;public String getMessageSelector() {     return messageSelector. }
true;public;1;3;/**  * Sets the JMS Message selector syntax.  */ ;/**  * Sets the JMS Message selector syntax.  */ public void setMessageSelector(String messageSelector) {     this.messageSelector = messageSelector. }
false;public;0;3;;public int getTransactionBatchCount() {     return transactionBatchCount. }
true;public;1;3;/**  * If transacted sets the number of messages to process before committing a transaction.  */ ;/**  * If transacted sets the number of messages to process before committing a transaction.  */ public void setTransactionBatchCount(int transactionBatchCount) {     this.transactionBatchCount = transactionBatchCount. }
false;public;0;3;;public long getTransactionBatchTimeout() {     return transactionBatchTimeout. }
true;public;1;5;/**  * Sets timeout (in millis) for batch transactions, the value should be 1000 or higher.  */ ;/**  * Sets timeout (in millis) for batch transactions, the value should be 1000 or higher.  */ public void setTransactionBatchTimeout(long transactionBatchTimeout) {     if (transactionBatchTimeout >= 1000) {         this.transactionBatchTimeout = transactionBatchTimeout.     } }
false;public;0;3;;public TransactionCommitStrategy getTransactionCommitStrategy() {     return transactionCommitStrategy. }
true;public;1;3;/**  * Sets the commit strategy.  */ ;/**  * Sets the commit strategy.  */ public void setTransactionCommitStrategy(TransactionCommitStrategy transactionCommitStrategy) {     this.transactionCommitStrategy = transactionCommitStrategy. }
false;public;0;3;;public boolean isTransacted() {     return transacted. }
true;public;1;6;/**  * Specifies whether to use transacted mode  */ ;/**  * Specifies whether to use transacted mode  */ public void setTransacted(boolean transacted) {     if (transacted) {         setAcknowledgementMode(SessionAcknowledgementType.SESSION_TRANSACTED).     }     this.transacted = transacted. }
false;public;0;3;;public boolean isSharedJMSSession() {     return sharedJMSSession. }
true;public;1;3;/**  * Specifies whether to share JMS session with other SJMS endpoints.  * Turn this off if your route is accessing to multiple JMS providers.  * If you need transaction against multiple JMS providers, use jms  * component to leverage XA transaction.  */ ;/**  * Specifies whether to share JMS session with other SJMS endpoints.  * Turn this off if your route is accessing to multiple JMS providers.  * If you need transaction against multiple JMS providers, use jms  * component to leverage XA transaction.  */ public void setSharedJMSSession(boolean share) {     this.sharedJMSSession = share. }
false;public;0;3;;public String getNamedReplyTo() {     return namedReplyTo. }
true;public;1;4;/**  * Sets the reply to destination name used for InOut producer endpoints.  * The type of the reply to destination can be determined by the starting  * prefix (topic: or queue:) in its name.  */ ;/**  * Sets the reply to destination name used for InOut producer endpoints.  * The type of the reply to destination can be determined by the starting  * prefix (topic: or queue:) in its name.  */ public void setNamedReplyTo(String namedReplyTo) {     this.namedReplyTo = namedReplyTo.     this.setExchangePattern(ExchangePattern.InOut). }
true;public;1;3;/**  * Whether to startup the consumer message listener asynchronously, when starting a route.  * For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying  * and/or failover. This will cause Camel to block while starting routes. By setting this option to true,  * you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread  * in asynchronous mode. If this option is used, then beware that if the connection could not be established,  * then an exception is logged at WARN level, and the consumer will not be able to receive messages.  * You can then restart the route to retry.  */ ;/**  * Whether to startup the consumer message listener asynchronously, when starting a route.  * For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying  * and/or failover. This will cause Camel to block while starting routes. By setting this option to true,  * you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread  * in asynchronous mode. If this option is used, then beware that if the connection could not be established,  * then an exception is logged at WARN level, and the consumer will not be able to receive messages.  * You can then restart the route to retry.  */ public void setAsyncStartListener(boolean asyncStartListener) {     this.asyncStartListener = asyncStartListener. }
true;public;1;3;/**  * Whether to stop the consumer message listener asynchronously, when stopping a route.  */ ;/**  * Whether to stop the consumer message listener asynchronously, when stopping a route.  */ public void setAsyncStopListener(boolean asyncStopListener) {     this.asyncStopListener = asyncStopListener. }
false;public;0;3;;public boolean isAsyncStartListener() {     return asyncStartListener. }
false;public;0;3;;public boolean isAsyncStopListener() {     return asyncStopListener. }
false;public;0;3;;public boolean isPrefillPool() {     return prefillPool. }
true;public;1;3;/**  * Whether to prefill the producer connection pool on startup, or create connections lazy when needed.  */ ;/**  * Whether to prefill the producer connection pool on startup, or create connections lazy when needed.  */ public void setPrefillPool(boolean prefillPool) {     this.prefillPool = prefillPool. }
false;public;0;3;;public DestinationCreationStrategy getDestinationCreationStrategy() {     return destinationCreationStrategy. }
true;public;1;3;/**  * To use a custom DestinationCreationStrategy.  */ ;/**  * To use a custom DestinationCreationStrategy.  */ public void setDestinationCreationStrategy(DestinationCreationStrategy destinationCreationStrategy) {     this.destinationCreationStrategy = destinationCreationStrategy. }
false;public;0;3;;public boolean isAllowNullBody() {     return allowNullBody. }
true;public;1;3;/**  * Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.  */ ;/**  * Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.  */ public void setAllowNullBody(boolean allowNullBody) {     this.allowNullBody = allowNullBody. }
false;public;0;3;;public boolean isMapJmsMessage() {     return mapJmsMessage. }
true;public;1;3;/**  * Specifies whether Camel should auto map the received JMS message to a suited payload type, such as javax.jms.TextMessage to a String etc.  * See section about how mapping works below for more details.  */ ;/**  * Specifies whether Camel should auto map the received JMS message to a suited payload type, such as javax.jms.TextMessage to a String etc.  * See section about how mapping works below for more details.  */ public void setMapJmsMessage(boolean mapJmsMessage) {     this.mapJmsMessage = mapJmsMessage. }
false;public;0;3;;public MessageCreatedStrategy getMessageCreatedStrategy() {     return messageCreatedStrategy. }
true;public;1;3;/**  * To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of <tt>javax.jms.Message</tt>  * objects when Camel is sending a JMS message.  */ ;/**  * To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of <tt>javax.jms.Message</tt>  * objects when Camel is sending a JMS message.  */ public void setMessageCreatedStrategy(MessageCreatedStrategy messageCreatedStrategy) {     this.messageCreatedStrategy = messageCreatedStrategy. }
false;public;0;6;;public JmsKeyFormatStrategy getJmsKeyFormatStrategy() {     if (jmsKeyFormatStrategy == null) {         jmsKeyFormatStrategy = new DefaultJmsKeyFormatStrategy().     }     return jmsKeyFormatStrategy. }
true;public;1;3;/**  * Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification.  * Camel provides two implementations out of the box: default and passthrough.  * The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is.  * Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters.  * You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy  * and refer to it using the # notation.  */ ;/**  * Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification.  * Camel provides two implementations out of the box: default and passthrough.  * The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is.  * Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters.  * You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy  * and refer to it using the # notation.  */ public void setJmsKeyFormatStrategy(JmsKeyFormatStrategy jmsKeyFormatStrategy) {     this.jmsKeyFormatStrategy = jmsKeyFormatStrategy. }
true;public;1;4;/**  * Initializes the connectionFactory for the endpoint, which takes precedence over the component's connectionFactory, if any  */ ;/**  * Initializes the connectionFactory for the endpoint, which takes precedence over the component's connectionFactory, if any  */ public void setConnectionFactory(String connectionFactory) {     this.connectionFactory = EndpointHelper.resolveReferenceParameter(getCamelContext(), connectionFactory, ConnectionFactory.class). }
false;public;0;6;;public ConnectionFactory getConnectionFactory() {     if (connectionFactory != null) {         return connectionFactory.     }     return getComponent().getConnectionFactory(). }
false;public;0;6;;public int getConnectionCount() {     if (connectionCount != null) {         return connectionCount.     }     return getComponent().getConnectionCount(). }
true;public;1;3;/**  * The maximum number of connections available to this endpoint  */ ;/**  * The maximum number of connections available to this endpoint  */ public void setConnectionCount(Integer connectionCount) {     this.connectionCount = connectionCount. }
false;public;0;3;;public ExceptionListener getExceptionListener() {     return exceptionListener. }
true;public;1;3;/**  * Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions.  */ ;/**  * Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions.  */ public void setExceptionListener(ExceptionListener exceptionListener) {     this.exceptionListener = exceptionListener. }
false;public;0;3;;public LoggingLevel getErrorHandlerLoggingLevel() {     return errorHandlerLoggingLevel. }
true;public;1;3;/**  * Allows to configure the default errorHandler logging level for logging uncaught exceptions.  */ ;/**  * Allows to configure the default errorHandler logging level for logging uncaught exceptions.  */ public void setErrorHandlerLoggingLevel(LoggingLevel errorHandlerLoggingLevel) {     this.errorHandlerLoggingLevel = errorHandlerLoggingLevel. }
false;public;0;3;;public boolean isErrorHandlerLogStackTrace() {     return errorHandlerLogStackTrace. }
true;public;1;3;/**  * Allows to control whether stacktraces should be logged or not, by the default errorHandler.  */ ;/**  * Allows to control whether stacktraces should be logged or not, by the default errorHandler.  */ public void setErrorHandlerLogStackTrace(boolean errorHandlerLogStackTrace) {     this.errorHandlerLogStackTrace = errorHandlerLogStackTrace. }
false;public;0;3;;public JmsObjectFactory getJmsObjectFactory() {     return jmsObjectFactory. }
true;public;1;3;/**  * To use a custom Jms Object factory  */ ;/**  * To use a custom Jms Object factory  */ public void setJmsObjectFactory(JmsObjectFactory jmsObjectFactory) {     this.jmsObjectFactory = jmsObjectFactory. }
