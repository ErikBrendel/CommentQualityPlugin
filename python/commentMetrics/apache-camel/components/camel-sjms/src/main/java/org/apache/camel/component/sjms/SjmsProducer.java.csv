commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public MessageProducerResources makeObject() throws Exception {     return doCreateProducerModel(createSession()). }
false;public;1;21;;@Override public void destroyObject(MessageProducerResources model) throws Exception {     if (model.getMessageProducer() != null) {         model.getMessageProducer().close().     }     if (model.getSession() != null) {         try {             if (model.getSession().getTransacted()) {                 try {                     model.getSession().rollback().                 } catch (Exception e) {                 // Do nothing. Just make sure we are cleaned up                 }             }             model.getSession().close().         } catch (Exception e) {         // TODO why is the session closed already?         }     } }
false;public;0;8;;@Override public void run() {     try {         fillProducersPool().     } catch (Throwable e) {         log.warn("Error filling producer pool for destination: " + getDestinationName() + ". This exception will be ignored.", e).     } }
false;public;0;4;;@Override public String toString() {     return "AsyncStartListenerTask[" + getDestinationName() + "]". }
false;protected;0;33;;@Override protected void doStart() throws Exception {     super.doStart().     this.executor = getEndpoint().getCamelContext().getExecutorServiceManager().newDefaultThreadPool(this, "SjmsProducer").     if (getProducers() == null) {         setProducers(new GenericObjectPool<>(new MessageProducerResourcesFactory())).         getProducers().setMaxActive(getProducerCount()).         getProducers().setMaxIdle(getProducerCount()).         getProducers().setLifo(false).         if (getEndpoint().isPrefillPool()) {             if (getEndpoint().isAsyncStartListener()) {                 asyncStart = getEndpoint().getComponent().getAsyncStartStopExecutorService().submit(new Runnable() {                      @Override                     public void run() {                         try {                             fillProducersPool().                         } catch (Throwable e) {                             log.warn("Error filling producer pool for destination: " + getDestinationName() + ". This exception will be ignored.", e).                         }                     }                      @Override                     public String toString() {                         return "AsyncStartListenerTask[" + getDestinationName() + "]".                     }                 }).             } else {                 fillProducersPool().             }         }     } }
false;private;0;5;;private void fillProducersPool() throws Exception {     while (producers.getNumIdle() < producers.getMaxIdle()) {         producers.addObject().     } }
false;public;0;9;;@Override public void run() {     try {         getProducers().close().         setProducers(null).     } catch (Throwable e) {         log.warn("Error closing producers on destination: " + getDestinationName() + ". This exception will be ignored.", e).     } }
false;public;0;4;;@Override public String toString() {     return "AsyncStopListenerTask[" + getDestinationName() + "]". }
false;protected;0;33;;@Override protected void doStop() throws Exception {     super.doStop().     if (asyncStart != null && !asyncStart.isDone()) {         asyncStart.cancel(true).     }     if (getProducers() != null) {         if (getEndpoint().isAsyncStopListener()) {             getEndpoint().getComponent().getAsyncStartStopExecutorService().submit(new Runnable() {                  @Override                 public void run() {                     try {                         getProducers().close().                         setProducers(null).                     } catch (Throwable e) {                         log.warn("Error closing producers on destination: " + getDestinationName() + ". This exception will be ignored.", e).                     }                 }                  @Override                 public String toString() {                     return "AsyncStopListenerTask[" + getDestinationName() + "]".                 }             }).         } else {             getProducers().close().             setProducers(null).         }     }     if (this.executor != null) {         getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(this.executor).     } }
false;public;0;4;;@Override public SjmsEndpoint getEndpoint() {     return (SjmsEndpoint) super.getEndpoint(). }
false;protected;1;13;;protected MessageProducerResources doCreateProducerModel(Session session) throws Exception {     MessageProducerResources answer.     try {         MessageProducer messageProducer = getEndpoint().getJmsObjectFactory().createMessageProducer(session, getEndpoint()).         answer = new MessageProducerResources(session, messageProducer, getCommitStrategy()).     } catch (Exception e) {         log.error("Unable to create the MessageProducer", e).         throw e.     }     return answer. }
false;protected;0;12;;protected Session createSession() throws Exception {     ConnectionResource connectionResource = getOrCreateConnectionResource().     Connection conn = connectionResource.borrowConnection().     try {         return conn.createSession(isEndpointTransacted(), getAcknowledgeMode()).     } catch (Exception e) {         log.error("Unable to create the Session", e).         throw e.     } finally {         connectionResource.returnConnection(conn).     } }
false;;1;1;;void release(MessageProducerResources producer) throws Exception.
false;public;1;3;;public void release(MessageProducerResources producer) throws Exception {     producer.getMessageProducer().close(). }
false;public;1;3;;public void release(MessageProducerResources producer) throws Exception {     getProducers().returnObject(producer). }
false;public,abstract;4;1;;public abstract void sendMessage(Exchange exchange, AsyncCallback callback, MessageProducerResources producer, ReleaseProducerCallback releaseProducerCallback) throws Exception.
false;public;0;8;;@Override public void run() {     try {         sendMessage(exchange, callback, producer, releaseProducerCallback).     } catch (Exception e) {         RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;public;2;68;;@Override public boolean process(final Exchange exchange, final AsyncCallback callback) {     if (log.isDebugEnabled()) {         log.debug("Processing Exchange.id:{}", exchange.getExchangeId()).     }     try {         final MessageProducerResources producer.         final ReleaseProducerCallback releaseProducerCallback.         if (isEndpointTransacted() && isSharedJMSSession()) {             Session session = exchange.getIn().getHeader(SjmsConstants.JMS_SESSION, Session.class).             if (session != null && session.getTransacted()) {                 // Join existing transacted session - Synchronization must have been added                 // by the session initiator                 producer = doCreateProducerModel(session).                 releaseProducerCallback = new CloseProducerCallback().             } else {                 // Propagate JMS session and register Synchronization as an initiator                 producer = getProducers().borrowObject().                 releaseProducerCallback = new ReturnProducerCallback().                 exchange.getIn().setHeader(SjmsConstants.JMS_SESSION, producer.getSession()).                 exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), producer.getCommitStrategy())).             }         } else {             producer = getProducers().borrowObject().             releaseProducerCallback = new ReturnProducerCallback().             if (isEndpointTransacted()) {                 exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), producer.getCommitStrategy())).             }         }         if (producer == null) {             exchange.setException(new Exception("Unable to send message: connection not available")).         } else {             if (!isSynchronous()) {                 if (log.isDebugEnabled()) {                     log.debug("  Sending message asynchronously: {}", exchange.getIn().getBody()).                 }                 getExecutor().execute(new Runnable() {                      @Override                     public void run() {                         try {                             sendMessage(exchange, callback, producer, releaseProducerCallback).                         } catch (Exception e) {                             RuntimeCamelException.wrapRuntimeCamelException(e).                         }                     }                 }).             } else {                 if (log.isDebugEnabled()) {                     log.debug("  Sending message synchronously: {}", exchange.getIn().getBody()).                 }                 sendMessage(exchange, callback, producer, releaseProducerCallback).             }         }     } catch (Exception e) {         if (log.isDebugEnabled()) {             log.debug("Processing Exchange.id:{}", exchange.getExchangeId() + " - FAILED").         }         if (log.isDebugEnabled()) {             log.trace("Exception: {}", e.getLocalizedMessage(), e).         }         exchange.setException(e).     }     log.debug("Processing Exchange.id:{}", exchange.getExchangeId() + " - SUCCESS").     return isSynchronous(). }
true;protected;0;4;/**  * @deprecated use {@link #getOrCreateConnectionResource()}  */ ;/**  * @deprecated use {@link #getOrCreateConnectionResource()}  */ @Deprecated protected ConnectionResource getConnectionResource() {     return getEndpoint().getConnectionResource(). }
false;protected;0;7;;protected ConnectionResource getOrCreateConnectionResource() {     ConnectionResource answer = getEndpoint().getConnectionResource().     if (answer == null) {         answer = getEndpoint().createConnectionResource(this).     }     return answer. }
true;public;0;3;/**  * Gets the acknowledgment mode for this instance of DestinationProducer.  *  * @return int  */ ;/**  * Gets the acknowledgment mode for this instance of DestinationProducer.  *  * @return int  */ public int getAcknowledgeMode() {     return getEndpoint().getAcknowledgementMode().intValue(). }
true;public;0;3;/**  * Gets the synchronous value for this instance of DestinationProducer.  *  * @return true if synchronous, otherwise false  */ ;/**  * Gets the synchronous value for this instance of DestinationProducer.  *  * @return true if synchronous, otherwise false  */ public boolean isSynchronous() {     return getEndpoint().isSynchronous(). }
true;public;0;3;/**  * Gets the replyTo for this instance of DestinationProducer.  *  * @return String  */ ;/**  * Gets the replyTo for this instance of DestinationProducer.  *  * @return String  */ public String getReplyTo() {     return getEndpoint().getNamedReplyTo(). }
true;public;0;3;/**  * Gets the destinationName for this instance of DestinationProducer.  *  * @return String  */ ;/**  * Gets the destinationName for this instance of DestinationProducer.  *  * @return String  */ public String getDestinationName() {     return getEndpoint().getDestinationName(). }
true;public;1;3;/**  * Sets the producer pool for this instance of SjmsProducer.  *  * @param producers A MessageProducerPool  */ ;/**  * Sets the producer pool for this instance of SjmsProducer.  *  * @param producers A MessageProducerPool  */ public void setProducers(GenericObjectPool<MessageProducerResources> producers) {     this.producers = producers. }
true;public;0;3;/**  * Gets the MessageProducerPool value of producers for this instance of  * SjmsProducer.  *  * @return the producers  */ ;/**  * Gets the MessageProducerPool value of producers for this instance of  * SjmsProducer.  *  * @return the producers  */ public GenericObjectPool<MessageProducerResources> getProducers() {     return producers. }
true;public;0;3;/**  * Test to verify if this endpoint is a JMS Topic or Queue.  *  * @return true if it is a Topic, otherwise it is a Queue  */ ;/**  * Test to verify if this endpoint is a JMS Topic or Queue.  *  * @return true if it is a Topic, otherwise it is a Queue  */ public boolean isTopic() {     return getEndpoint().isTopic(). }
true;public;0;3;/**  * Test to determine if this endpoint should use a JMS Transaction.  *  * @return true if transacted, otherwise false  */ ;/**  * Test to determine if this endpoint should use a JMS Transaction.  *  * @return true if transacted, otherwise false  */ public boolean isEndpointTransacted() {     return getEndpoint().isTransacted(). }
true;public;0;3;/**  * Test to determine if this endpoint should share a JMS Session with other SJMS endpoints.  *  * @return true if shared, otherwise false  */ ;/**  * Test to determine if this endpoint should share a JMS Session with other SJMS endpoints.  *  * @return true if shared, otherwise false  */ public boolean isSharedJMSSession() {     return getEndpoint().isSharedJMSSession(). }
true;public;0;3;/**  * Returns the named reply to value for this producer  *  * @return true if it is a Topic, otherwise it is a Queue  */ ;/**  * Returns the named reply to value for this producer  *  * @return true if it is a Topic, otherwise it is a Queue  */ public String getNamedReplyTo() {     return getEndpoint().getNamedReplyTo(). }
true;public;0;3;/**  * Gets the producerCount for this instance of SjmsProducer.  *  * @return int  */ ;/**  * Gets the producerCount for this instance of SjmsProducer.  *  * @return int  */ public int getProducerCount() {     return getEndpoint().getProducerCount(). }
true;public;0;3;/**  * Gets consumerCount for this instance of SjmsProducer.  *  * @return int  */ ;/**  * Gets consumerCount for this instance of SjmsProducer.  *  * @return int  */ public int getConsumerCount() {     return getEndpoint().getConsumerCount(). }
true;public;0;3;/**  * Gets the executor for this instance of SjmsProducer.  *  * @return ExecutorService  */ ;/**  * Gets the executor for this instance of SjmsProducer.  *  * @return ExecutorService  */ public ExecutorService getExecutor() {     return executor. }
true;public;0;3;/**  * Gets the ttl for this instance of SjmsProducer.  *  * @return long  */ ;/**  * Gets the ttl for this instance of SjmsProducer.  *  * @return long  */ public long getTtl() {     return getEndpoint().getTtl(). }
true;public;0;3;/**  * Gets the boolean value of persistent for this instance of SjmsProducer.  *  * @return true if persistent, otherwise false  */ ;/**  * Gets the boolean value of persistent for this instance of SjmsProducer.  *  * @return true if persistent, otherwise false  */ public boolean isPersistent() {     return getEndpoint().isPersistent(). }
true;public;0;3;/**  * Gets responseTimeOut for this instance of SjmsProducer.  *  * @return long  */ ;/**  * Gets responseTimeOut for this instance of SjmsProducer.  *  * @return long  */ public long getResponseTimeOut() {     return getEndpoint().getResponseTimeOut(). }
true;protected;0;6;/**  * Gets commitStrategy for this instance of SjmsProducer.  *  * @return TransactionCommitStrategy  */ ;/**  * Gets commitStrategy for this instance of SjmsProducer.  *  * @return TransactionCommitStrategy  */ protected TransactionCommitStrategy getCommitStrategy() {     if (isEndpointTransacted()) {         return getEndpoint().getTransactionCommitStrategy().     }     return null. }
