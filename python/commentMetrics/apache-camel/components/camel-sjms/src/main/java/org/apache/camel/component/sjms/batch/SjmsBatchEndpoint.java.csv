commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;public;0;4;;@Override public SjmsBatchComponent getComponent() {     return (SjmsBatchComponent) super.getComponent(). }
false;public;0;4;;@Override public Producer createProducer() throws Exception {     throw new UnsupportedOperationException("Producer not supported"). }
false;public;1;7;;@Override public Consumer createConsumer(Processor processor) throws Exception {     SjmsBatchConsumer consumer = new SjmsBatchConsumer(this, processor).     consumer.setTimeoutCheckerExecutorService(timeoutCheckerExecutorService).     configureConsumer(consumer).     return consumer. }
false;public;2;5;;public Exchange createExchange(Message message, Session session) {     Exchange exchange = createExchange(getExchangePattern()).     exchange.setIn(new SjmsMessage(exchange, message, session, getBinding())).     return exchange. }
false;public;0;6;;public JmsBinding getBinding() {     if (binding == null) {         binding = createBinding().     }     return binding. }
true;protected;0;3;/**  * Creates the {@link org.apache.camel.component.sjms.jms.JmsBinding} to use.  */ ;/**  * Creates the {@link org.apache.camel.component.sjms.jms.JmsBinding} to use.  */ protected JmsBinding createBinding() {     return new JmsBinding(isMapJmsMessage(), isAllowNullBody(), getHeaderFilterStrategy(), getJmsKeyFormatStrategy(), getMessageCreatedStrategy()). }
true;public;1;3;/**  * Sets the binding used to convert from a Camel message to and from a JMS  * message  */ ;/**  * Sets the binding used to convert from a Camel message to and from a JMS  * message  */ public void setBinding(JmsBinding binding) {     this.binding = binding. }
false;public;0;3;;public AggregationStrategy getAggregationStrategy() {     return aggregationStrategy. }
true;public;1;3;/**  * The aggregation strategy to use, which merges all the batched messages into a single message  */ ;/**  * The aggregation strategy to use, which merges all the batched messages into a single message  */ public void setAggregationStrategy(AggregationStrategy aggregationStrategy) {     this.aggregationStrategy = aggregationStrategy. }
true;public;0;3;/**  * The destination name. Only queues are supported, names may be prefixed by 'queue:'.  */ ;/**  * The destination name. Only queues are supported, names may be prefixed by 'queue:'.  */ public String getDestinationName() {     return destinationName. }
false;public;0;3;;public int getConsumerCount() {     return consumerCount. }
true;public;1;3;/**  * The number of JMS sessions to consume from  */ ;/**  * The number of JMS sessions to consume from  */ public void setConsumerCount(int consumerCount) {     this.consumerCount = consumerCount. }
false;public;0;3;;public int getCompletionSize() {     return completionSize. }
true;public;1;3;/**  * The number of messages consumed at which the batch will be completed  */ ;/**  * The number of messages consumed at which the batch will be completed  */ public void setCompletionSize(int completionSize) {     this.completionSize = completionSize. }
false;public;0;3;;public int getCompletionTimeout() {     return completionTimeout. }
true;public;1;3;/**  * The timeout in millis from receipt of the first first message when the batch will be completed.  * The batch may be empty if the timeout triggered and there was no messages in the batch.  * <br/>  * Notice you cannot use both completion timeout and completion interval at the same time, only one can be configured.  */ ;/**  * The timeout in millis from receipt of the first first message when the batch will be completed.  * The batch may be empty if the timeout triggered and there was no messages in the batch.  * <br/>  * Notice you cannot use both completion timeout and completion interval at the same time, only one can be configured.  */ public void setCompletionTimeout(int completionTimeout) {     this.completionTimeout = completionTimeout. }
false;public;0;3;;public int getCompletionInterval() {     return completionInterval. }
true;public;1;3;/**  * The completion interval in millis, which causes batches to be completed in a scheduled fixed rate every interval.  * The batch may be empty if the timeout triggered and there was no messages in the batch.  * <br/>  * Notice you cannot use both completion timeout and completion interval at the same time, only one can be configured.  */ ;/**  * The completion interval in millis, which causes batches to be completed in a scheduled fixed rate every interval.  * The batch may be empty if the timeout triggered and there was no messages in the batch.  * <br/>  * Notice you cannot use both completion timeout and completion interval at the same time, only one can be configured.  */ public void setCompletionInterval(int completionInterval) {     this.completionInterval = completionInterval. }
false;public;0;3;;public Predicate getCompletionPredicate() {     return completionPredicate. }
true;public;1;3;/**  * The completion predicate, which causes batches to be completed when the predicate evaluates as true.  * <p/>  * The predicate can also be configured using the simple language using the string syntax.  * You may want to set the option eagerCheckCompletion to true to let the predicate match the incoming message,  * as otherwise it matches the aggregated message.  */ ;/**  * The completion predicate, which causes batches to be completed when the predicate evaluates as true.  * <p/>  * The predicate can also be configured using the simple language using the string syntax.  * You may want to set the option eagerCheckCompletion to true to let the predicate match the incoming message,  * as otherwise it matches the aggregated message.  */ public void setCompletionPredicate(Predicate completionPredicate) {     this.completionPredicate = completionPredicate. }
false;public;1;4;;public void setCompletionPredicate(String predicate) {     // uses simple language     this.completionPredicate = getCamelContext().resolveLanguage("simple").createPredicate(predicate). }
false;public;0;3;;public boolean isEagerCheckCompletion() {     return eagerCheckCompletion. }
true;public;1;3;/**  * Use eager completion checking which means that the completionPredicate will use the incoming Exchange.  * As opposed to without eager completion checking the completionPredicate will use the aggregated Exchange.  */ ;/**  * Use eager completion checking which means that the completionPredicate will use the incoming Exchange.  * As opposed to without eager completion checking the completionPredicate will use the aggregated Exchange.  */ public void setEagerCheckCompletion(boolean eagerCheckCompletion) {     this.eagerCheckCompletion = eagerCheckCompletion. }
false;public;0;3;;public boolean isSendEmptyMessageWhenIdle() {     return sendEmptyMessageWhenIdle. }
true;public;1;3;/**  * If using completion timeout or interval, then the batch may be empty if the timeout triggered and there was no messages in the batch.  * If this option is <tt>true</tt> and the batch is empty then an empty message is added to the batch so an empty message is routed.  */ ;/**  * If using completion timeout or interval, then the batch may be empty if the timeout triggered and there was no messages in the batch.  * If this option is <tt>true</tt> and the batch is empty then an empty message is added to the batch so an empty message is routed.  */ public void setSendEmptyMessageWhenIdle(boolean sendEmptyMessageWhenIdle) {     this.sendEmptyMessageWhenIdle = sendEmptyMessageWhenIdle. }
false;public;0;3;;public int getPollDuration() {     return pollDuration. }
true;public;1;3;/**  * The duration in milliseconds of each poll for messages.  * completionTimeOut will be used if it is shorter and a batch has started.  */ ;/**  * The duration in milliseconds of each poll for messages.  * completionTimeOut will be used if it is shorter and a batch has started.  */ public void setPollDuration(int pollDuration) {     this.pollDuration = pollDuration. }
false;public;0;3;;public boolean isAllowNullBody() {     return allowNullBody. }
true;public;1;3;/**  * Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.  */ ;/**  * Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.  */ public void setAllowNullBody(boolean allowNullBody) {     this.allowNullBody = allowNullBody. }
false;public;0;3;;public boolean isMapJmsMessage() {     return mapJmsMessage. }
true;public;1;3;/**  * Specifies whether Camel should auto map the received JMS message to a suited payload type, such as javax.jms.TextMessage to a String etc.  * See section about how mapping works below for more details.  */ ;/**  * Specifies whether Camel should auto map the received JMS message to a suited payload type, such as javax.jms.TextMessage to a String etc.  * See section about how mapping works below for more details.  */ public void setMapJmsMessage(boolean mapJmsMessage) {     this.mapJmsMessage = mapJmsMessage. }
false;public;0;3;;public MessageCreatedStrategy getMessageCreatedStrategy() {     return messageCreatedStrategy. }
true;public;1;3;/**  * To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of <tt>javax.jms.Message</tt>  * objects when Camel is sending a JMS message.  */ ;/**  * To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of <tt>javax.jms.Message</tt>  * objects when Camel is sending a JMS message.  */ public void setMessageCreatedStrategy(MessageCreatedStrategy messageCreatedStrategy) {     this.messageCreatedStrategy = messageCreatedStrategy. }
false;public;0;6;;public JmsKeyFormatStrategy getJmsKeyFormatStrategy() {     if (jmsKeyFormatStrategy == null) {         jmsKeyFormatStrategy = new DefaultJmsKeyFormatStrategy().     }     return jmsKeyFormatStrategy. }
true;public;1;3;/**  * Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification.  * Camel provides two implementations out of the box: default and passthrough.  * The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is.  * Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters.  * You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy  * and refer to it using the # notation.  */ ;/**  * Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification.  * Camel provides two implementations out of the box: default and passthrough.  * The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is.  * Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters.  * You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy  * and refer to it using the # notation.  */ public void setJmsKeyFormatStrategy(JmsKeyFormatStrategy jmsKeyFormatStrategy) {     this.jmsKeyFormatStrategy = jmsKeyFormatStrategy. }
false;public;0;6;;public HeaderFilterStrategy getHeaderFilterStrategy() {     if (headerFilterStrategy == null) {         headerFilterStrategy = new SjmsHeaderFilterStrategy(isIncludeAllJMSXProperties()).     }     return headerFilterStrategy. }
true;public;1;3;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ ;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ public void setHeaderFilterStrategy(HeaderFilterStrategy strategy) {     this.headerFilterStrategy = strategy. }
false;public;0;3;;public boolean isIncludeAllJMSXProperties() {     return includeAllJMSXProperties. }
true;public;1;3;/**  * Whether to include all JMSXxxx properties when mapping from JMS to Camel Message.  * Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc.  * Note: If you are using a custom headerFilterStrategy then this option does not apply.  */ ;/**  * Whether to include all JMSXxxx properties when mapping from JMS to Camel Message.  * Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc.  * Note: If you are using a custom headerFilterStrategy then this option does not apply.  */ public void setIncludeAllJMSXProperties(boolean includeAllJMSXProperties) {     this.includeAllJMSXProperties = includeAllJMSXProperties. }
false;public;0;3;;public ScheduledExecutorService getTimeoutCheckerExecutorService() {     return timeoutCheckerExecutorService. }
true;public;1;3;/**  * If using the completionInterval option a background thread is created to trigger the completion interval.  * Set this option to provide a custom thread pool to be used rather than creating a new thread for every consumer.  */ ;/**  * If using the completionInterval option a background thread is created to trigger the completion interval.  * Set this option to provide a custom thread pool to be used rather than creating a new thread for every consumer.  */ public void setTimeoutCheckerExecutorService(ScheduledExecutorService timeoutCheckerExecutorService) {     this.timeoutCheckerExecutorService = timeoutCheckerExecutorService. }
false;public;0;3;;public boolean isAsyncStartListener() {     return asyncStartListener. }
true;public;1;3;/**  * Whether to startup the consumer message listener asynchronously, when starting a route.  * For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying  * and/or failover. This will cause Camel to block while starting routes. By setting this option to true,  * you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread  * in asynchronous mode. If this option is used, then beware that if the connection could not be established,  * then an exception is logged at WARN level, and the consumer will not be able to receive messages.  * You can then restart the route to retry.  */ ;/**  * Whether to startup the consumer message listener asynchronously, when starting a route.  * For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying  * and/or failover. This will cause Camel to block while starting routes. By setting this option to true,  * you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread  * in asynchronous mode. If this option is used, then beware that if the connection could not be established,  * then an exception is logged at WARN level, and the consumer will not be able to receive messages.  * You can then restart the route to retry.  */ public void setAsyncStartListener(boolean asyncStartListener) {     this.asyncStartListener = asyncStartListener. }
false;public;0;3;;public int getRecoveryInterval() {     return recoveryInterval. }
true;public;1;3;/**  * Specifies the interval between recovery attempts, i.e. when a connection is being refreshed, in milliseconds.  * The default is 5000 ms, that is, 5 seconds.  */ ;/**  * Specifies the interval between recovery attempts, i.e. when a connection is being refreshed, in milliseconds.  * The default is 5000 ms, that is, 5 seconds.  */ public void setRecoveryInterval(int recoveryInterval) {     this.recoveryInterval = recoveryInterval. }
true;public;1;3;/**  * The delay in millis between attempts to re-establish a valid session.  * If this is a positive value the SjmsBatchConsumer will attempt to create a new session if it sees an IllegalStateException  * during message consumption. This delay value allows you to pause between attempts to prevent spamming the logs.  * If this is a negative value (default is -1) then the SjmsBatchConsumer will behave as it always has before - that is  * it will bail out and the route will shut down if it sees an IllegalStateException.  */ ;/**  * The delay in millis between attempts to re-establish a valid session.  * If this is a positive value the SjmsBatchConsumer will attempt to create a new session if it sees an IllegalStateException  * during message consumption. This delay value allows you to pause between attempts to prevent spamming the logs.  * If this is a negative value (default is -1) then the SjmsBatchConsumer will behave as it always has before - that is  * it will bail out and the route will shut down if it sees an IllegalStateException.  */ public void setKeepAliveDelay(int keepAliveDelay) {     this.keepAliveDelay = keepAliveDelay. }
false;public;0;3;;public int getKeepAliveDelay() {     return keepAliveDelay. }
