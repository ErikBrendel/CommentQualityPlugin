commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;22;;@Override protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {     validateMepAndReplyTo(parameters).     SjmsEndpoint endpoint = createSjmsEndpoint(uri, remaining).     setProperties(endpoint, parameters).     if (endpoint.isTransacted()) {         endpoint.setSynchronous(true).     }     if (transactionCommitStrategy != null) {         endpoint.setTransactionCommitStrategy(transactionCommitStrategy).     }     if (destinationCreationStrategy != null) {         endpoint.setDestinationCreationStrategy(destinationCreationStrategy).     }     if (getHeaderFilterStrategy() != null) {         endpoint.setHeaderFilterStrategy(getHeaderFilterStrategy()).     }     if (messageCreatedStrategy != null) {         endpoint.setMessageCreatedStrategy(messageCreatedStrategy).     }     return endpoint. }
false;protected;2;3;;protected SjmsEndpoint createSjmsEndpoint(String uri, String remaining) {     return new SjmsEndpoint(uri, this, remaining). }
true;private,static;1;11;/**  * Helper method used to verify that when there is a namedReplyTo value we  * are using the InOut MEP. If namedReplyTo is defined and the MEP is InOnly  * the endpoint won't be expecting a reply so throw an error to alert the  * user.  *  * @param parameters {@link Endpoint} parameters  * @throws Exception throws a {@link CamelException} when MEP equals InOnly  *                   and namedReplyTo is defined.  */ ;/**  * Helper method used to verify that when there is a namedReplyTo value we  * are using the InOut MEP. If namedReplyTo is defined and the MEP is InOnly  * the endpoint won't be expecting a reply so throw an error to alert the  * user.  *  * @param parameters {@link Endpoint} parameters  * @throws Exception throws a {@link CamelException} when MEP equals InOnly  *                   and namedReplyTo is defined.  */ private static void validateMepAndReplyTo(Map<String, Object> parameters) throws Exception {     boolean namedReplyToSet = parameters.containsKey("namedReplyTo").     boolean mepSet = parameters.containsKey("exchangePattern").     if (namedReplyToSet && mepSet) {         if (!parameters.get("exchangePattern").equals(ExchangePattern.InOut.toString())) {             String namedReplyTo = (String) parameters.get("namedReplyTo").             ExchangePattern mep = ExchangePattern.valueOf((String) parameters.get("exchangePattern")).             throw new CamelException("Setting parameter namedReplyTo=" + namedReplyTo + " requires a MEP of type InOut. Parameter exchangePattern is set to " + mep).         }     } }
false;protected;0;5;;@Override protected void doStart() throws Exception {     super.doStart().     timedTaskManager = new TimedTaskManager(). }
false;protected;0;8;;@Override protected void doStop() throws Exception {     if (timedTaskManager != null) {         timedTaskManager.cancelTasks().         timedTaskManager = null.     }     super.doStop(). }
false;protected;0;8;;@Override protected void doShutdown() throws Exception {     if (asyncStartStopExecutorService != null) {         getCamelContext().getExecutorServiceManager().shutdownNow(asyncStartStopExecutorService).         asyncStartStopExecutorService = null.     }     super.doShutdown(). }
false;protected,synchronized;0;8;;protected synchronized ExecutorService getAsyncStartStopExecutorService() {     if (asyncStartStopExecutorService == null) {         // use a cached thread pool for async start tasks as they can run for a while, and we need a dedicated thread         // for each task, and the thread pool will shrink when no more tasks running         asyncStartStopExecutorService = getCamelContext().getExecutorServiceManager().newCachedThreadPool(this, "AsyncStartStopListener").     }     return asyncStartStopExecutorService. }
true;public;1;3;/**  * A ConnectionFactory is required to enable the SjmsComponent.  * It can be set directly or set set as part of a ConnectionResource.  */ ;/**  * A ConnectionFactory is required to enable the SjmsComponent.  * It can be set directly or set set as part of a ConnectionResource.  */ public void setConnectionFactory(ConnectionFactory connectionFactory) {     this.connectionFactory = connectionFactory. }
false;public;0;3;;public ConnectionFactory getConnectionFactory() {     return connectionFactory. }
true;public;1;3;/**  * A ConnectionResource is an interface that allows for customization and container control of the ConnectionFactory.  * See Plugable Connection Resource Management for further details.  */ ;/**  * A ConnectionResource is an interface that allows for customization and container control of the ConnectionFactory.  * See Plugable Connection Resource Management for further details.  */ public void setConnectionResource(ConnectionResource connectionResource) {     this.connectionResource = connectionResource. }
false;public;0;3;;public ConnectionResource getConnectionResource() {     return connectionResource. }
true;public;1;3;/**  * The maximum number of connections available to endpoints started under this component  */ ;/**  * The maximum number of connections available to endpoints started under this component  */ public void setConnectionCount(Integer maxConnections) {     this.connectionCount = maxConnections. }
false;public;0;3;;public Integer getConnectionCount() {     return connectionCount. }
true;public;1;3;/**  * Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification.  * Camel provides one implementation out of the box: default.  * The default strategy will safely marshal dots and hyphens (. and -).  * Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters.  * You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy  * and refer to it using the # notation.  */ ;/**  * Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification.  * Camel provides one implementation out of the box: default.  * The default strategy will safely marshal dots and hyphens (. and -).  * Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters.  * You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy  * and refer to it using the # notation.  */ public void setJmsKeyFormatStrategy(JmsKeyFormatStrategy jmsKeyFormatStrategy) {     this.jmsKeyFormatStrategy = jmsKeyFormatStrategy. }
false;public;0;3;;public JmsKeyFormatStrategy getJmsKeyFormatStrategy() {     return jmsKeyFormatStrategy. }
false;public;0;3;;public TransactionCommitStrategy getTransactionCommitStrategy() {     return transactionCommitStrategy. }
true;public;1;3;/**  * To configure which kind of commit strategy to use. Camel provides two implementations out  * of the box, default and batch.  */ ;/**  * To configure which kind of commit strategy to use. Camel provides two implementations out  * of the box, default and batch.  */ public void setTransactionCommitStrategy(TransactionCommitStrategy commitStrategy) {     this.transactionCommitStrategy = commitStrategy. }
false;public;0;3;;public DestinationCreationStrategy getDestinationCreationStrategy() {     return destinationCreationStrategy. }
true;public;1;3;/**  * To use a custom DestinationCreationStrategy.  */ ;/**  * To use a custom DestinationCreationStrategy.  */ public void setDestinationCreationStrategy(DestinationCreationStrategy destinationCreationStrategy) {     this.destinationCreationStrategy = destinationCreationStrategy. }
false;public;0;3;;public TimedTaskManager getTimedTaskManager() {     return timedTaskManager. }
true;public;1;3;/**  * To use a custom TimedTaskManager  */ ;/**  * To use a custom TimedTaskManager  */ public void setTimedTaskManager(TimedTaskManager timedTaskManager) {     this.timedTaskManager = timedTaskManager. }
false;public;0;3;;public MessageCreatedStrategy getMessageCreatedStrategy() {     return messageCreatedStrategy. }
true;public;1;3;/**  * To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of <tt>javax.jms.Message</tt>  * objects when Camel is sending a JMS message.  */ ;/**  * To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of <tt>javax.jms.Message</tt>  * objects when Camel is sending a JMS message.  */ public void setMessageCreatedStrategy(MessageCreatedStrategy messageCreatedStrategy) {     this.messageCreatedStrategy = messageCreatedStrategy. }
false;public;0;3;;public boolean isConnectionTestOnBorrow() {     return connectionTestOnBorrow. }
true;public;1;3;/**  * When using the default {@link org.apache.camel.component.sjms.jms.ConnectionFactoryResource} then should each {@link javax.jms.Connection}  * be tested (calling start) before returned from the pool.  */ ;/**  * When using the default {@link org.apache.camel.component.sjms.jms.ConnectionFactoryResource} then should each {@link javax.jms.Connection}  * be tested (calling start) before returned from the pool.  */ public void setConnectionTestOnBorrow(boolean connectionTestOnBorrow) {     this.connectionTestOnBorrow = connectionTestOnBorrow. }
false;public;0;3;;public String getConnectionUsername() {     return connectionUsername. }
true;public;1;3;/**  * The username to use when creating {@link javax.jms.Connection} when using the default {@link org.apache.camel.component.sjms.jms.ConnectionFactoryResource}.  */ ;/**  * The username to use when creating {@link javax.jms.Connection} when using the default {@link org.apache.camel.component.sjms.jms.ConnectionFactoryResource}.  */ public void setConnectionUsername(String connectionUsername) {     this.connectionUsername = connectionUsername. }
false;public;0;3;;public String getConnectionPassword() {     return connectionPassword. }
true;public;1;3;/**  * The password to use when creating {@link javax.jms.Connection} when using the default {@link org.apache.camel.component.sjms.jms.ConnectionFactoryResource}.  */ ;/**  * The password to use when creating {@link javax.jms.Connection} when using the default {@link org.apache.camel.component.sjms.jms.ConnectionFactoryResource}.  */ public void setConnectionPassword(String connectionPassword) {     this.connectionPassword = connectionPassword. }
false;public;0;3;;public String getConnectionClientId() {     return connectionClientId. }
true;public;1;3;/**  * The client ID to use when creating {@link javax.jms.Connection} when using the default {@link org.apache.camel.component.sjms.jms.ConnectionFactoryResource}.  */ ;/**  * The client ID to use when creating {@link javax.jms.Connection} when using the default {@link org.apache.camel.component.sjms.jms.ConnectionFactoryResource}.  */ public void setConnectionClientId(String connectionClientId) {     this.connectionClientId = connectionClientId. }
false;public;0;3;;public long getConnectionMaxWait() {     return connectionMaxWait. }
true;public;1;3;/**  * The max wait time in millis to block and wait on free connection when the pool is exhausted  * when using the default {@link org.apache.camel.component.sjms.jms.ConnectionFactoryResource}.  */ ;/**  * The max wait time in millis to block and wait on free connection when the pool is exhausted  * when using the default {@link org.apache.camel.component.sjms.jms.ConnectionFactoryResource}.  */ public void setConnectionMaxWait(long connectionMaxWait) {     this.connectionMaxWait = connectionMaxWait. }
