# id;timestamp;commentText;codeText;commentWords;codeWords
InOutProducer -> InOutResponseContainer -> public InOutResponseContainer(Exchange exchange, AsyncCallback callback);1343905000;@param exchange_@param callback;public InOutResponseContainer(Exchange exchange, AsyncCallback callback) {_            super()__            this.exchange = exchange__            this.callback = callback__        };param,exchange,param,callback;public,in,out,response,container,exchange,exchange,async,callback,callback,super,this,exchange,exchange,this,callback,callback
InOutProducer -> InOutResponseContainer -> public InOutResponseContainer(Exchange exchange, AsyncCallback callback);1344346492;@param exchange_@param callback;public InOutResponseContainer(Exchange exchange, AsyncCallback callback) {_            super()__            this.exchange = exchange__            this.callback = callback__        };param,exchange,param,callback;public,in,out,response,container,exchange,exchange,async,callback,callback,super,this,exchange,exchange,this,callback,callback
InOutProducer -> InOutResponseContainer -> public InOutResponseContainer(Exchange exchange, AsyncCallback callback);1344999539;@param exchange_@param callback;public InOutResponseContainer(Exchange exchange, AsyncCallback callback) {_            this.exchange = exchange__            this.callback = callback__        };param,exchange,param,callback;public,in,out,response,container,exchange,exchange,async,callback,callback,this,exchange,exchange,this,callback,callback
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception;1415211488;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception {_        if (isEndpointTransacted()) {_            exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy()))__        }__        Message request = SjmsExchangeMessageHelper.createMessage(exchange, producer.getSession(), getSjmsEndpoint().getJmsKeyFormatStrategy())___        _        _        String correlationId = null__        if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) {_            correlationId = UUID.randomUUID().toString().replace("-", "")__        } else {_            correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class)__        }_        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<Object>()__        SjmsExchangeMessageHelper.setCorrelationId(request, correlationId)__        try {_            lock.writeLock().lock()__            exchangerMap.put(correlationId, messageExchanger)__        } finally {_            lock.writeLock().unlock()__        }__        MessageConsumerResources consumer = consumers.borrowObject()__        SjmsExchangeMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            getProducers().returnObject(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)___            try {_                lock.writeLock().lock()__                exchangerMap.remove(correlationId)__            } finally {_                lock.writeLock().unlock()__            }_        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message response = (Message) responseObject__                SjmsExchangeMessageHelper.populateExchange(response, exchange, true, getEndpoint().getJmsKeyFormatStrategy())__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,throws,exception,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,get,commit,strategy,message,request,sjms,exchange,message,helper,create,message,exchange,producer,get,session,get,sjms,endpoint,get,jms,key,format,strategy,string,correlation,id,null,if,exchange,get,in,get,header,jmscorrelation,id,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jmscorrelation,id,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,sjms,exchange,message,helper,set,correlation,id,request,correlation,id,try,lock,write,lock,lock,exchanger,map,put,correlation,id,message,exchanger,finally,lock,write,lock,unlock,message,consumer,resources,consumer,consumers,borrow,object,sjms,exchange,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,try,lock,write,lock,lock,exchanger,map,remove,correlation,id,finally,lock,write,lock,unlock,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,sjms,exchange,message,helper,populate,exchange,response,exchange,true,get,endpoint,get,jms,key,format,strategy,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception;1415327622;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception {_        if (isEndpointTransacted()) {_            exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy()))__        }__        Message request = SjmsExchangeMessageHelper.createMessage(exchange, producer.getSession(), getSjmsEndpoint().getJmsKeyFormatStrategy())___        _        _        String correlationId = null__        if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) {_            correlationId = UUID.randomUUID().toString().replace("-", "")__        } else {_            correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class)__        }_        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<Object>()__        SjmsExchangeMessageHelper.setCorrelationId(request, correlationId)__        lock.writeLock().lock()__        try {_            exchangerMap.put(correlationId, messageExchanger)__        } finally {_            lock.writeLock().unlock()__        }__        MessageConsumerResources consumer = consumers.borrowObject()__        SjmsExchangeMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            getProducers().returnObject(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)___            lock.writeLock().lock()__            try {_                exchangerMap.remove(correlationId)__            } finally {_                lock.writeLock().unlock()__            }_        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message response = (Message) responseObject__                SjmsExchangeMessageHelper.populateExchange(response, exchange, true, getEndpoint().getJmsKeyFormatStrategy())__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,throws,exception,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,get,commit,strategy,message,request,sjms,exchange,message,helper,create,message,exchange,producer,get,session,get,sjms,endpoint,get,jms,key,format,strategy,string,correlation,id,null,if,exchange,get,in,get,header,jmscorrelation,id,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jmscorrelation,id,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,sjms,exchange,message,helper,set,correlation,id,request,correlation,id,lock,write,lock,lock,try,exchanger,map,put,correlation,id,message,exchanger,finally,lock,write,lock,unlock,message,consumer,resources,consumer,consumers,borrow,object,sjms,exchange,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,lock,write,lock,lock,try,exchanger,map,remove,correlation,id,finally,lock,write,lock,unlock,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,sjms,exchange,message,helper,populate,exchange,response,exchange,true,get,endpoint,get,jms,key,format,strategy,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception;1415517372;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception {_        if (isEndpointTransacted()) {_            exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy()))__        }__        Message request = SjmsExchangeMessageHelper.createMessage(exchange, producer.getSession(), getSjmsEndpoint().getJmsKeyFormatStrategy(), getSjmsEndpoint().getCamelContext().getTypeConverter())___        _        _        String correlationId = null__        if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) {_            correlationId = UUID.randomUUID().toString().replace("-", "")__        } else {_            correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class)__        }_        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<Object>()__        SjmsExchangeMessageHelper.setCorrelationId(request, correlationId)__        lock.writeLock().lock()__        try {_            exchangerMap.put(correlationId, messageExchanger)__        } finally {_            lock.writeLock().unlock()__        }__        MessageConsumerResources consumer = consumers.borrowObject()__        SjmsExchangeMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            getProducers().returnObject(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)___            lock.writeLock().lock()__            try {_                exchangerMap.remove(correlationId)__            } finally {_                lock.writeLock().unlock()__            }_        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message response = (Message) responseObject__                SjmsExchangeMessageHelper.populateExchange(response, exchange, true, getEndpoint().getJmsKeyFormatStrategy())__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,throws,exception,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,get,commit,strategy,message,request,sjms,exchange,message,helper,create,message,exchange,producer,get,session,get,sjms,endpoint,get,jms,key,format,strategy,get,sjms,endpoint,get,camel,context,get,type,converter,string,correlation,id,null,if,exchange,get,in,get,header,jmscorrelation,id,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jmscorrelation,id,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,sjms,exchange,message,helper,set,correlation,id,request,correlation,id,lock,write,lock,lock,try,exchanger,map,put,correlation,id,message,exchanger,finally,lock,write,lock,unlock,message,consumer,resources,consumer,consumers,borrow,object,sjms,exchange,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,lock,write,lock,lock,try,exchanger,map,remove,correlation,id,finally,lock,write,lock,unlock,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,sjms,exchange,message,helper,populate,exchange,response,exchange,true,get,endpoint,get,jms,key,format,strategy,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception;1417253476;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception {_        if (isEndpointTransacted()) {_            exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy()))__        }__        Message request = JmsMessageHelper.createMessage(exchange, producer.getSession(), getEndpoint())___        _        _        String correlationId__        if (exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class) == null) {_            correlationId = UUID.randomUUID().toString().replace("-", "")__        } else {_            correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)__        }_        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<>()__        JmsMessageHelper.setCorrelationId(request, correlationId)__        EXCHANGERS.put(correlationId, messageExchanger)___        MessageConsumerResources consumer = consumers.borrowObject()__        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            getProducers().returnObject(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)__            EXCHANGERS.remove(correlationId)__        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message response = (Message) responseObject__                JmsMessageHelper.populateExchange(response, exchange, true, getEndpoint().getJmsKeyFormatStrategy())__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,throws,exception,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,get,commit,strategy,message,request,jms,message,helper,create,message,exchange,producer,get,session,get,endpoint,string,correlation,id,if,exchange,get,in,get,header,jms,constants,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jms,constants,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,jms,message,helper,set,correlation,id,request,correlation,id,exchangers,put,correlation,id,message,exchanger,message,consumer,resources,consumer,consumers,borrow,object,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,exchangers,remove,correlation,id,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,jms,message,helper,populate,exchange,response,exchange,true,get,endpoint,get,jms,key,format,strategy,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception;1417254093;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception {_        if (isEndpointTransacted()) {_            exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy()))__        }__        Message request = JmsMessageHelper.createMessage(exchange, producer.getSession(), getEndpoint())___        _        _        String correlationId__        if (exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class) == null) {_            correlationId = UUID.randomUUID().toString().replace("-", "")__        } else {_            correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)__        }_        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<Object>()__        JmsMessageHelper.setCorrelationId(request, correlationId)__        EXCHANGERS.put(correlationId, messageExchanger)___        MessageConsumerResources consumer = consumers.borrowObject()__        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            getProducers().returnObject(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)__            EXCHANGERS.remove(correlationId)__        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message response = (Message) responseObject__                JmsMessageHelper.populateExchange(response, exchange, true, getEndpoint().getJmsKeyFormatStrategy())__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,throws,exception,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,get,commit,strategy,message,request,jms,message,helper,create,message,exchange,producer,get,session,get,endpoint,string,correlation,id,if,exchange,get,in,get,header,jms,constants,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jms,constants,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,helper,set,correlation,id,request,correlation,id,exchangers,put,correlation,id,message,exchanger,message,consumer,resources,consumer,consumers,borrow,object,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,exchangers,remove,correlation,id,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,jms,message,helper,populate,exchange,response,exchange,true,get,endpoint,get,jms,key,format,strategy,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception;1417517136;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception {_        if (isEndpointTransacted()) {_            exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy()))__        }__        Message request = JmsMessageHelper.createMessage(exchange, producer.getSession(), getEndpoint())___        _        _        String correlationId__        if (exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class) == null) {_            correlationId = UUID.randomUUID().toString().replace("-", "")__        } else {_            correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)__        }_        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<Object>()__        JmsMessageHelper.setCorrelationId(request, correlationId)__        EXCHANGERS.put(correlationId, messageExchanger)___        MessageConsumerResources consumer = consumers.borrowObject()__        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            getProducers().returnObject(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)__            EXCHANGERS.remove(correlationId)__        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message response = (Message) responseObject__                JmsMessageHelper.populateExchange(response, exchange, true, getEndpoint().getJmsKeyFormatStrategy())__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,throws,exception,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,get,commit,strategy,message,request,jms,message,helper,create,message,exchange,producer,get,session,get,endpoint,string,correlation,id,if,exchange,get,in,get,header,jms,constants,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jms,constants,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,helper,set,correlation,id,request,correlation,id,exchangers,put,correlation,id,message,exchanger,message,consumer,resources,consumer,consumers,borrow,object,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,exchangers,remove,correlation,id,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,jms,message,helper,populate,exchange,response,exchange,true,get,endpoint,get,jms,key,format,strategy,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception;1441617001;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception {_        if (isEndpointTransacted()) {_            exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy()))__        }__        Message request = getEndpoint().getBinding().makeJmsMessage(exchange, producer.getSession())___        String correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)__        if (correlationId == null) {_            _            correlationId = GENERATED_CORRELATION_ID_PREFIX + getUuidGenerator().generateUuid()__        }__        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<Object>()__        JmsMessageHelper.setCorrelationId(request, correlationId)__        EXCHANGERS.put(correlationId, messageExchanger)___        MessageConsumerResources consumer = consumers.borrowObject()__        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            getProducers().returnObject(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)__            EXCHANGERS.remove(correlationId)__        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message message = (Message) responseObject___                SjmsMessage response = new SjmsMessage(message, consumer.getSession(), getEndpoint().getBinding())__                _                _                _                exchange.setOut(response)__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,throws,exception,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,get,commit,strategy,message,request,get,endpoint,get,binding,make,jms,message,exchange,producer,get,session,string,correlation,id,exchange,get,in,get,header,jms,constants,string,class,if,correlation,id,null,correlation,id,get,uuid,generator,generate,uuid,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,helper,set,correlation,id,request,correlation,id,exchangers,put,correlation,id,message,exchanger,message,consumer,resources,consumer,consumers,borrow,object,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,exchangers,remove,correlation,id,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,message,message,response,object,sjms,message,response,new,sjms,message,message,consumer,get,session,get,endpoint,get,binding,exchange,set,out,response,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception;1441617894;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer) throws Exception {_        if (isEndpointTransacted()) {_            exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy()))__        }__        Message request = getEndpoint().getBinding().makeJmsMessage(exchange, producer.getSession())___        String correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)__        if (correlationId == null) {_            _            correlationId = GENERATED_CORRELATION_ID_PREFIX + getUuidGenerator().generateUuid()__        }__        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<Object>()__        JmsMessageHelper.setCorrelationId(request, correlationId)__        EXCHANGERS.put(correlationId, messageExchanger)___        MessageConsumerResources consumer = consumers.borrowObject()__        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            getProducers().returnObject(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)__            EXCHANGERS.remove(correlationId)__        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message message = (Message) responseObject___                SjmsMessage response = new SjmsMessage(message, consumer.getSession(), getEndpoint().getBinding())__                _                _                _                exchange.setOut(response)__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,throws,exception,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,get,commit,strategy,message,request,get,endpoint,get,binding,make,jms,message,exchange,producer,get,session,string,correlation,id,exchange,get,in,get,header,jms,constants,string,class,if,correlation,id,null,correlation,id,get,uuid,generator,generate,uuid,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,helper,set,correlation,id,request,correlation,id,exchangers,put,correlation,id,message,exchanger,message,consumer,resources,consumer,consumers,borrow,object,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,exchangers,remove,correlation,id,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,message,message,response,object,sjms,message,response,new,sjms,message,message,consumer,get,session,get,endpoint,get,binding,exchange,set,out,response,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> MessageConsumerResource -> public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination);1343905000;TODO Add Constructor Javadoc__@param session_@param messageConsumer;public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination) {_            super()__            this.session = session__            this.messageConsumer = messageConsumer__            this.replyToDestination = replyToDestination__        };todo,add,constructor,javadoc,param,session,param,message,consumer;public,message,consumer,resource,session,session,message,consumer,message,consumer,destination,reply,to,destination,super,this,session,session,this,message,consumer,message,consumer,this,reply,to,destination,reply,to,destination
InOutProducer -> MessageConsumerResource -> public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination);1344346492;TODO Add Constructor Javadoc__@param session_@param messageConsumer;public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination) {_            super()__            this.session = session__            this.messageConsumer = messageConsumer__            this.replyToDestination = replyToDestination__        };todo,add,constructor,javadoc,param,session,param,message,consumer;public,message,consumer,resource,session,session,message,consumer,message,consumer,destination,reply,to,destination,super,this,session,session,this,message,consumer,message,consumer,this,reply,to,destination,reply,to,destination
InOutProducer -> MessageConsumerResource -> public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination);1344999539;TODO Add Constructor Javadoc__@param session_@param messageConsumer;public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination) {_            this.session = session__            this.messageConsumer = messageConsumer__            this.replyToDestination = replyToDestination__        };todo,add,constructor,javadoc,param,session,param,message,consumer;public,message,consumer,resource,session,session,message,consumer,message,consumer,destination,reply,to,destination,this,session,session,this,message,consumer,message,consumer,this,reply,to,destination,reply,to,destination
InOutProducer -> MessageConsumerResource -> public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination);1346298132;TODO Add Constructor Javadoc__@param session_@param messageConsumer;public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination) {_            super()__            this.session = session__            this.messageConsumer = messageConsumer__            this.replyToDestination = replyToDestination__        };todo,add,constructor,javadoc,param,session,param,message,consumer;public,message,consumer,resource,session,session,message,consumer,message,consumer,destination,reply,to,destination,super,this,session,session,this,message,consumer,message,consumer,this,reply,to,destination,reply,to,destination
InOutProducer -> MessageConsumerResource -> public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination);1348685513;TODO Add Constructor Javadoc__@param session_@param messageConsumer;public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination) {_            super()__            this.session = session__            this.messageConsumer = messageConsumer__            this.replyToDestination = replyToDestination__        };todo,add,constructor,javadoc,param,session,param,message,consumer;public,message,consumer,resource,session,session,message,consumer,message,consumer,destination,reply,to,destination,super,this,session,session,this,message,consumer,message,consumer,this,reply,to,destination,reply,to,destination
InOutProducer -> MessageConsumerResource -> public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination);1349113955;TODO Add Constructor Javadoc__@param session_@param messageConsumer;public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination) {_            super()__            this.session = session__            this.messageConsumer = messageConsumer__            this.replyToDestination = replyToDestination__        };todo,add,constructor,javadoc,param,session,param,message,consumer;public,message,consumer,resource,session,session,message,consumer,message,consumer,destination,reply,to,destination,super,this,session,session,this,message,consumer,message,consumer,this,reply,to,destination,reply,to,destination
InOutProducer -> MessageConsumerResource -> public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination);1349476580;TODO Add Constructor Javadoc__@param session_@param messageConsumer;public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination) {_            super()__            this.session = session__            this.messageConsumer = messageConsumer__            this.replyToDestination = replyToDestination__        };todo,add,constructor,javadoc,param,session,param,message,consumer;public,message,consumer,resource,session,session,message,consumer,message,consumer,destination,reply,to,destination,super,this,session,session,this,message,consumer,message,consumer,this,reply,to,destination,reply,to,destination
InOutProducer -> MessageConsumerResource -> public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination);1351626413;TODO Add Constructor Javadoc__@param session_@param messageConsumer;public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination) {_            super()__            this.session = session__            this.messageConsumer = messageConsumer__            this.replyToDestination = replyToDestination__        };todo,add,constructor,javadoc,param,session,param,message,consumer;public,message,consumer,resource,session,session,message,consumer,message,consumer,destination,reply,to,destination,super,this,session,session,this,message,consumer,message,consumer,this,reply,to,destination,reply,to,destination
InOutProducer -> MessageConsumerResource -> public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination);1354318669;TODO Add Constructor Javadoc__@param session_@param messageConsumer;public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination) {_            this.session = session__            this.messageConsumer = messageConsumer__            this.replyToDestination = replyToDestination__        };todo,add,constructor,javadoc,param,session,param,message,consumer;public,message,consumer,resource,session,session,message,consumer,message,consumer,destination,reply,to,destination,this,session,session,this,message,consumer,message,consumer,this,reply,to,destination,reply,to,destination
InOutProducer -> MessageConsumerResource -> public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination);1383063455;TODO Add Constructor Javadoc__@param session_@param messageConsumer;public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination) {_            this.session = session__            this.messageConsumer = messageConsumer__            this.replyToDestination = replyToDestination__        };todo,add,constructor,javadoc,param,session,param,message,consumer;public,message,consumer,resource,session,session,message,consumer,message,consumer,destination,reply,to,destination,this,session,session,this,message,consumer,message,consumer,this,reply,to,destination,reply,to,destination
InOutProducer -> MessageConsumerResource -> public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination);1392936452;TODO Add Constructor Javadoc__@param session_@param messageConsumer;public MessageConsumerResource(Session session, MessageConsumer messageConsumer, Destination replyToDestination) {_            this.session = session__            this.messageConsumer = messageConsumer__            this.replyToDestination = replyToDestination__        };todo,add,constructor,javadoc,param,session,param,message,consumer;public,message,consumer,resource,session,session,message,consumer,message,consumer,destination,reply,to,destination,this,session,session,this,message,consumer,message,consumer,this,reply,to,destination,reply,to,destination
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception;1343905000;TODO Add override javadoc_TODO time out is actually double as it waits for the producer and then waits for the response.  Use an atomiclong to manage the countdown__@see org.apache.camel.component.sjms.SjmsProducer#sendMessage(org.apache.camel.Exchange, org.apache.camel.AsyncCallback)__@param exchange_@param callback_@throws Exception;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception {_        if (getProducers() != null) {_            MessageProducerResources producer = null__            try {_                producer = getProducers().borrowObject(getResponseTimeOut())__                _            } catch (Exception e1) {_                log.warn("The producer pool is exhausted.  Consider setting producerCount to a higher value or disable the fixed size of the pool by setting fixedResourcePool=false.")__                exchange.setException(new Exception("Producer Resource Pool is exhausted"))__            }_            if (producer != null) {__                if (isEndpointTransacted()) {_                    exchange.getUnitOfWork()_                        .addSynchronization(new SessionTransactionSynchronization(producer.getSession()))__                }__                Message request = JmsMessageHelper.createMessage(exchange, producer.getSession())__                _                _                String correlationId = null__                if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) {_                    correlationId = UUID.randomUUID().toString().replace("-", "")__                } else {_                    correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class)__                }_                Object responseObject = null__                Exchanger<Object> messageExchanger = new Exchanger<Object>()__                JmsMessageHelper.setCorrelationId(request, correlationId)__                try {_                    lock.writeLock().lock()__                    exchangerMap.put(correlationId, messageExchanger)__                } finally {_                    lock.writeLock().unlock()__                }__                MessageConsumerResource consumer = consumers.borrowObject(getResponseTimeOut())__                JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__                consumers.returnObject(consumer)__                producer.getMessageProducer().send(request)___                try {_                    getProducers().returnObject(producer)__                } catch (Exception exception) {_                    _                }__                try {_                    responseObject = messageExchanger.exchange(null, getResponseTimeOut(),_                                                               TimeUnit.MILLISECONDS)___                    try {_                        lock.writeLock().lock()__                        exchangerMap.remove(correlationId)__                    } finally {_                        lock.writeLock().unlock()__                    }_                } catch (InterruptedException e) {_                    log.debug("Exchanger was interrupted while waiting on response", e)__                    exchange.setException(e)__                } catch (TimeoutException e) {_                    log.debug("Exchanger timed out while waiting on response", e)__                    exchange.setException(e)__                }__                if (exchange.getException() == null) {_                    if (responseObject instanceof Throwable) {_                        exchange.setException((Throwable)responseObject)__                    } else if (responseObject instanceof Message) {_                        Message response = (Message)responseObject__                        JmsMessageHelper.populateExchange(response, exchange, true)__                    } else {_                        exchange.setException(new CamelException("Unknown response type: " + responseObject))__                    }_                }_            }__            callback.done(isSynchronous())__        }_    };todo,add,override,javadoc,todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomiclong,to,manage,the,countdown,see,org,apache,camel,component,sjms,sjms,producer,send,message,org,apache,camel,exchange,org,apache,camel,async,callback,param,exchange,param,callback,throws,exception;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,throws,exception,if,get,producers,null,message,producer,resources,producer,null,try,producer,get,producers,borrow,object,get,response,time,out,catch,exception,e1,log,warn,the,producer,pool,is,exhausted,consider,setting,producer,count,to,a,higher,value,or,disable,the,fixed,size,of,the,pool,by,setting,fixed,resource,pool,false,exchange,set,exception,new,exception,producer,resource,pool,is,exhausted,if,producer,null,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,message,request,jms,message,helper,create,message,exchange,producer,get,session,string,correlation,id,null,if,exchange,get,in,get,header,jmscorrelation,id,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jmscorrelation,id,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,helper,set,correlation,id,request,correlation,id,try,lock,write,lock,lock,exchanger,map,put,correlation,id,message,exchanger,finally,lock,write,lock,unlock,message,consumer,resource,consumer,consumers,borrow,object,get,response,time,out,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,try,lock,write,lock,lock,exchanger,map,remove,correlation,id,finally,lock,write,lock,unlock,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,jms,message,helper,populate,exchange,response,exchange,true,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception;1344346492;TODO Add override javadoc_TODO time out is actually double as it waits for the producer and then waits for the response.  Use an atomiclong to manage the countdown__@see org.apache.camel.component.sjms.SjmsProducer#sendMessage(org.apache.camel.Exchange, org.apache.camel.AsyncCallback)__@param exchange_@param callback_@throws Exception;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception {_        if (getProducers() != null) {_            MessageProducerResources producer = null__            try {_                producer = getProducers().borrowObject(getResponseTimeOut())__                _            } catch (Exception e1) {_                log.warn("The producer pool is exhausted.  Consider setting producerCount to a higher value or disable the fixed size of the pool by setting fixedResourcePool=false.")__                exchange.setException(new Exception("Producer Resource Pool is exhausted"))__            }_            if (producer != null) {__                if (isEndpointTransacted()) {_                    exchange.getUnitOfWork()_                        .addSynchronization(new SessionTransactionSynchronization(producer.getSession()))__                }__                Message request = JmsMessageHelper.createMessage(exchange, producer.getSession())__                _                _                String correlationId = null__                if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) {_                    correlationId = UUID.randomUUID().toString().replace("-", "")__                } else {_                    correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class)__                }_                Object responseObject = null__                Exchanger<Object> messageExchanger = new Exchanger<Object>()__                JmsMessageHelper.setCorrelationId(request, correlationId)__                try {_                    lock.writeLock().lock()__                    exchangerMap.put(correlationId, messageExchanger)__                } finally {_                    lock.writeLock().unlock()__                }__                MessageConsumerResource consumer = consumers.borrowObject(getResponseTimeOut())__                JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__                consumers.returnObject(consumer)__                producer.getMessageProducer().send(request)___                try {_                    getProducers().returnObject(producer)__                } catch (Exception exception) {_                    _                }__                try {_                    responseObject = messageExchanger.exchange(null, getResponseTimeOut(),_                                                               TimeUnit.MILLISECONDS)___                    try {_                        lock.writeLock().lock()__                        exchangerMap.remove(correlationId)__                    } finally {_                        lock.writeLock().unlock()__                    }_                } catch (InterruptedException e) {_                    log.debug("Exchanger was interrupted while waiting on response", e)__                    exchange.setException(e)__                } catch (TimeoutException e) {_                    log.debug("Exchanger timed out while waiting on response", e)__                    exchange.setException(e)__                }__                if (exchange.getException() == null) {_                    if (responseObject instanceof Throwable) {_                        exchange.setException((Throwable)responseObject)__                    } else if (responseObject instanceof Message) {_                        Message response = (Message)responseObject__                        JmsMessageHelper.populateExchange(response, exchange, true)__                    } else {_                        exchange.setException(new CamelException("Unknown response type: " + responseObject))__                    }_                }_            }__            callback.done(isSynchronous())__        }_    };todo,add,override,javadoc,todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomiclong,to,manage,the,countdown,see,org,apache,camel,component,sjms,sjms,producer,send,message,org,apache,camel,exchange,org,apache,camel,async,callback,param,exchange,param,callback,throws,exception;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,throws,exception,if,get,producers,null,message,producer,resources,producer,null,try,producer,get,producers,borrow,object,get,response,time,out,catch,exception,e1,log,warn,the,producer,pool,is,exhausted,consider,setting,producer,count,to,a,higher,value,or,disable,the,fixed,size,of,the,pool,by,setting,fixed,resource,pool,false,exchange,set,exception,new,exception,producer,resource,pool,is,exhausted,if,producer,null,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,message,request,jms,message,helper,create,message,exchange,producer,get,session,string,correlation,id,null,if,exchange,get,in,get,header,jmscorrelation,id,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jmscorrelation,id,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,helper,set,correlation,id,request,correlation,id,try,lock,write,lock,lock,exchanger,map,put,correlation,id,message,exchanger,finally,lock,write,lock,unlock,message,consumer,resource,consumer,consumers,borrow,object,get,response,time,out,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,try,lock,write,lock,lock,exchanger,map,remove,correlation,id,finally,lock,write,lock,unlock,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,jms,message,helper,populate,exchange,response,exchange,true,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception;1344999539;TODO Add override javadoc_TODO time out is actually double as it waits for the producer and then waits for the response.  Use an atomiclong to manage the countdown__@see org.apache.camel.component.sjms.SjmsProducer#sendMessage(org.apache.camel.Exchange, org.apache.camel.AsyncCallback)__@param exchange_@param callback_@throws Exception;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception {_        if (getProducers() != null) {_            MessageProducerResources producer = null__            try {_                producer = getProducers().borrowObject(getResponseTimeOut())__                _            } catch (Exception e1) {_                log.warn("The producer pool is exhausted.  Consider setting producerCount to a higher value or disable the fixed size of the pool by setting fixedResourcePool=false.")__                exchange.setException(new Exception("Producer Resource Pool is exhausted"))__            }_            if (producer != null) {__                if (isEndpointTransacted()) {_                    exchange.getUnitOfWork()_                        .addSynchronization(new SessionTransactionSynchronization(producer.getSession()))__                }__                Message request = JmsMessageHelper.createMessage(exchange, producer.getSession())__                _                _                String correlationId = null__                if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) {_                    correlationId = UUID.randomUUID().toString().replace("-", "")__                } else {_                    correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class)__                }_                Object responseObject = null__                Exchanger<Object> messageExchanger = new Exchanger<Object>()__                JmsMessageHelper.setCorrelationId(request, correlationId)__                try {_                    lock.writeLock().lock()__                    exchangerMap.put(correlationId, messageExchanger)__                } finally {_                    lock.writeLock().unlock()__                }__                MessageConsumerResource consumer = consumers.borrowObject(getResponseTimeOut())__                JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__                consumers.returnObject(consumer)__                producer.getMessageProducer().send(request)___                try {_                    getProducers().returnObject(producer)__                } catch (Exception exception) {_                    _                }__                try {_                    responseObject = messageExchanger.exchange(null, getResponseTimeOut(),_                                                               TimeUnit.MILLISECONDS)___                    try {_                        lock.writeLock().lock()__                        exchangerMap.remove(correlationId)__                    } finally {_                        lock.writeLock().unlock()__                    }_                } catch (InterruptedException e) {_                    log.debug("Exchanger was interrupted while waiting on response", e)__                    exchange.setException(e)__                } catch (TimeoutException e) {_                    log.debug("Exchanger timed out while waiting on response", e)__                    exchange.setException(e)__                }__                if (exchange.getException() == null) {_                    if (responseObject instanceof Throwable) {_                        exchange.setException((Throwable)responseObject)__                    } else if (responseObject instanceof Message) {_                        Message response = (Message)responseObject__                        JmsMessageHelper.populateExchange(response, exchange, true)__                    } else {_                        exchange.setException(new CamelException("Unknown response type: " + responseObject))__                    }_                }_            }__            callback.done(isSynchronous())__        }_    };todo,add,override,javadoc,todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomiclong,to,manage,the,countdown,see,org,apache,camel,component,sjms,sjms,producer,send,message,org,apache,camel,exchange,org,apache,camel,async,callback,param,exchange,param,callback,throws,exception;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,throws,exception,if,get,producers,null,message,producer,resources,producer,null,try,producer,get,producers,borrow,object,get,response,time,out,catch,exception,e1,log,warn,the,producer,pool,is,exhausted,consider,setting,producer,count,to,a,higher,value,or,disable,the,fixed,size,of,the,pool,by,setting,fixed,resource,pool,false,exchange,set,exception,new,exception,producer,resource,pool,is,exhausted,if,producer,null,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,message,request,jms,message,helper,create,message,exchange,producer,get,session,string,correlation,id,null,if,exchange,get,in,get,header,jmscorrelation,id,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jmscorrelation,id,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,helper,set,correlation,id,request,correlation,id,try,lock,write,lock,lock,exchanger,map,put,correlation,id,message,exchanger,finally,lock,write,lock,unlock,message,consumer,resource,consumer,consumers,borrow,object,get,response,time,out,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,try,lock,write,lock,lock,exchanger,map,remove,correlation,id,finally,lock,write,lock,unlock,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,jms,message,helper,populate,exchange,response,exchange,true,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception;1346298132;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown__@see org.apache.camel.component.sjms.SjmsProducer#sendMessage(org.apache.camel.Exchange,_org.apache.camel.AsyncCallback)_@param exchange_@param callback_@throws Exception;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception {_        if (getProducers() != null) {_            MessageProducerResources producer = null__            try {_                producer = getProducers().borrowObject(getResponseTimeOut())__            } catch (Exception e1) {_                log.warn("The producer pool is exhausted.  Consider setting producerCount to a higher value or disable the fixed size of the pool by setting fixedResourcePool=false.")__                exchange.setException(new Exception("Producer Resource Pool is exhausted"))__            }_            if (producer != null) {__                if (isEndpointTransacted()) {_                    exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy()))__                }__                Message request = JmsMessageExchangeHelper.createMessage(exchange, producer.getSession())__                _                _                _                String correlationId = null__                if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) {_                    correlationId = UUID.randomUUID().toString().replace("-", "")__                } else {_                    correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class)__                }_                Object responseObject = null__                Exchanger<Object> messageExchanger = new Exchanger<Object>()__                JmsMessageExchangeHelper.setCorrelationId(request, correlationId)__                try {_                    lock.writeLock().lock()__                    exchangerMap.put(correlationId, messageExchanger)__                } finally {_                    lock.writeLock().unlock()__                }__                MessageConsumerResource consumer = consumers.borrowObject(getResponseTimeOut())__                JmsMessageExchangeHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__                consumers.returnObject(consumer)__                producer.getMessageProducer().send(request)___                try {_                    getProducers().returnObject(producer)__                } catch (Exception exception) {_                    _                }__                try {_                    responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)___                    try {_                        lock.writeLock().lock()__                        exchangerMap.remove(correlationId)__                    } finally {_                        lock.writeLock().unlock()__                    }_                } catch (InterruptedException e) {_                    log.debug("Exchanger was interrupted while waiting on response", e)__                    exchange.setException(e)__                } catch (TimeoutException e) {_                    log.debug("Exchanger timed out while waiting on response", e)__                    exchange.setException(e)__                }__                if (exchange.getException() == null) {_                    if (responseObject instanceof Throwable) {_                        exchange.setException((Throwable)responseObject)__                    } else if (responseObject instanceof Message) {_                        Message response = (Message)responseObject__                        JmsMessageExchangeHelper.populateExchange(response, exchange, true)__                    } else {_                        exchange.setException(new CamelException("Unknown response type: " + responseObject))__                    }_                }_            }__            callback.done(isSynchronous())__        }_    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown,see,org,apache,camel,component,sjms,sjms,producer,send,message,org,apache,camel,exchange,org,apache,camel,async,callback,param,exchange,param,callback,throws,exception;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,throws,exception,if,get,producers,null,message,producer,resources,producer,null,try,producer,get,producers,borrow,object,get,response,time,out,catch,exception,e1,log,warn,the,producer,pool,is,exhausted,consider,setting,producer,count,to,a,higher,value,or,disable,the,fixed,size,of,the,pool,by,setting,fixed,resource,pool,false,exchange,set,exception,new,exception,producer,resource,pool,is,exhausted,if,producer,null,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,get,commit,strategy,message,request,jms,message,exchange,helper,create,message,exchange,producer,get,session,string,correlation,id,null,if,exchange,get,in,get,header,jmscorrelation,id,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jmscorrelation,id,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,exchange,helper,set,correlation,id,request,correlation,id,try,lock,write,lock,lock,exchanger,map,put,correlation,id,message,exchanger,finally,lock,write,lock,unlock,message,consumer,resource,consumer,consumers,borrow,object,get,response,time,out,jms,message,exchange,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,try,lock,write,lock,lock,exchanger,map,remove,correlation,id,finally,lock,write,lock,unlock,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,jms,message,exchange,helper,populate,exchange,response,exchange,true,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception;1348685513;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown__@see org.apache.camel.component.sjms.SjmsProducer#sendMessage(org.apache.camel.Exchange,_org.apache.camel.AsyncCallback)_@param exchange_@param callback_@throws Exception;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception {_        if (getProducers() != null) {_            MessageProducerResources producer = null__            try {_                producer = getProducers().borrowObject(getResponseTimeOut())__            } catch (Exception e1) {_                log.warn("The producer pool is exhausted.  Consider setting producerCount to a higher value or disable the fixed size of the pool by setting fixedResourcePool=false.")__                exchange.setException(new Exception("Producer Resource Pool is exhausted"))__            }_            if (producer != null) {__                if (isEndpointTransacted()) {_                    exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy()))__                }__                Message request = JmsMessageExchangeHelper.createMessage(exchange, producer.getSession())__                _                _                _                String correlationId = null__                if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) {_                    correlationId = UUID.randomUUID().toString().replace("-", "")__                } else {_                    correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class)__                }_                Object responseObject = null__                Exchanger<Object> messageExchanger = new Exchanger<Object>()__                JmsMessageExchangeHelper.setCorrelationId(request, correlationId)__                try {_                    lock.writeLock().lock()__                    exchangerMap.put(correlationId, messageExchanger)__                } finally {_                    lock.writeLock().unlock()__                }__                MessageConsumerResource consumer = consumers.borrowObject(getResponseTimeOut())__                JmsMessageExchangeHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__                consumers.returnObject(consumer)__                producer.getMessageProducer().send(request)___                try {_                    getProducers().returnObject(producer)__                } catch (Exception exception) {_                    _                }__                try {_                    responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)___                    try {_                        lock.writeLock().lock()__                        exchangerMap.remove(correlationId)__                    } finally {_                        lock.writeLock().unlock()__                    }_                } catch (InterruptedException e) {_                    log.debug("Exchanger was interrupted while waiting on response", e)__                    exchange.setException(e)__                } catch (TimeoutException e) {_                    log.debug("Exchanger timed out while waiting on response", e)__                    exchange.setException(e)__                }__                if (exchange.getException() == null) {_                    if (responseObject instanceof Throwable) {_                        exchange.setException((Throwable)responseObject)__                    } else if (responseObject instanceof Message) {_                        Message response = (Message)responseObject__                        JmsMessageExchangeHelper.populateExchange(response, exchange, true)__                    } else {_                        exchange.setException(new CamelException("Unknown response type: " + responseObject))__                    }_                }_            }__            callback.done(isSynchronous())__        }_    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown,see,org,apache,camel,component,sjms,sjms,producer,send,message,org,apache,camel,exchange,org,apache,camel,async,callback,param,exchange,param,callback,throws,exception;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,throws,exception,if,get,producers,null,message,producer,resources,producer,null,try,producer,get,producers,borrow,object,get,response,time,out,catch,exception,e1,log,warn,the,producer,pool,is,exhausted,consider,setting,producer,count,to,a,higher,value,or,disable,the,fixed,size,of,the,pool,by,setting,fixed,resource,pool,false,exchange,set,exception,new,exception,producer,resource,pool,is,exhausted,if,producer,null,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,get,commit,strategy,message,request,jms,message,exchange,helper,create,message,exchange,producer,get,session,string,correlation,id,null,if,exchange,get,in,get,header,jmscorrelation,id,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jmscorrelation,id,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,exchange,helper,set,correlation,id,request,correlation,id,try,lock,write,lock,lock,exchanger,map,put,correlation,id,message,exchanger,finally,lock,write,lock,unlock,message,consumer,resource,consumer,consumers,borrow,object,get,response,time,out,jms,message,exchange,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,try,lock,write,lock,lock,exchanger,map,remove,correlation,id,finally,lock,write,lock,unlock,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,jms,message,exchange,helper,populate,exchange,response,exchange,true,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception;1349113955;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown__@see org.apache.camel.component.sjms.SjmsProducer#sendMessage(org.apache.camel.Exchange,_org.apache.camel.AsyncCallback)_@param exchange_@param callback_@throws Exception;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception {_        if (getProducers() != null) {_            MessageProducerResources producer = null__            try {_                producer = getProducers().borrowObject(getResponseTimeOut())__            } catch (Exception e1) {_                log.warn("The producer pool is exhausted.  Consider setting producerCount to a higher value or disable the fixed size of the pool by setting fixedResourcePool=false.")__                exchange.setException(new Exception("Producer Resource Pool is exhausted"))__            }_            if (producer != null) {__                if (isEndpointTransacted()) {_                    exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy()))__                }__                Message request = JmsMessageExchangeHelper.createMessage(exchange, producer.getSession())__                _                _                _                String correlationId = null__                if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) {_                    correlationId = UUID.randomUUID().toString().replace("-", "")__                } else {_                    correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class)__                }_                Object responseObject = null__                Exchanger<Object> messageExchanger = new Exchanger<Object>()__                JmsMessageExchangeHelper.setCorrelationId(request, correlationId)__                try {_                    lock.writeLock().lock()__                    exchangerMap.put(correlationId, messageExchanger)__                } finally {_                    lock.writeLock().unlock()__                }__                MessageConsumerResource consumer = consumers.borrowObject(getResponseTimeOut())__                JmsMessageExchangeHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__                consumers.returnObject(consumer)__                producer.getMessageProducer().send(request)___                _                _                try {_                    getProducers().returnObject(producer)__                } catch (Exception exception) {_                    _                }__                try {_                    responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)___                    try {_                        lock.writeLock().lock()__                        exchangerMap.remove(correlationId)__                    } finally {_                        lock.writeLock().unlock()__                    }_                } catch (InterruptedException e) {_                    log.debug("Exchanger was interrupted while waiting on response", e)__                    exchange.setException(e)__                } catch (TimeoutException e) {_                    log.debug("Exchanger timed out while waiting on response", e)__                    exchange.setException(e)__                }__                if (exchange.getException() == null) {_                    if (responseObject instanceof Throwable) {_                        exchange.setException((Throwable)responseObject)__                    } else if (responseObject instanceof Message) {_                        Message response = (Message)responseObject__                        JmsMessageExchangeHelper.populateExchange(response, exchange, true)__                    } else {_                        exchange.setException(new CamelException("Unknown response type: " + responseObject))__                    }_                }_            }__            callback.done(isSynchronous())__        }_    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown,see,org,apache,camel,component,sjms,sjms,producer,send,message,org,apache,camel,exchange,org,apache,camel,async,callback,param,exchange,param,callback,throws,exception;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,throws,exception,if,get,producers,null,message,producer,resources,producer,null,try,producer,get,producers,borrow,object,get,response,time,out,catch,exception,e1,log,warn,the,producer,pool,is,exhausted,consider,setting,producer,count,to,a,higher,value,or,disable,the,fixed,size,of,the,pool,by,setting,fixed,resource,pool,false,exchange,set,exception,new,exception,producer,resource,pool,is,exhausted,if,producer,null,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,get,commit,strategy,message,request,jms,message,exchange,helper,create,message,exchange,producer,get,session,string,correlation,id,null,if,exchange,get,in,get,header,jmscorrelation,id,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jmscorrelation,id,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,exchange,helper,set,correlation,id,request,correlation,id,try,lock,write,lock,lock,exchanger,map,put,correlation,id,message,exchanger,finally,lock,write,lock,unlock,message,consumer,resource,consumer,consumers,borrow,object,get,response,time,out,jms,message,exchange,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,try,lock,write,lock,lock,exchanger,map,remove,correlation,id,finally,lock,write,lock,unlock,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,jms,message,exchange,helper,populate,exchange,response,exchange,true,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception;1349476580;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown__@see org.apache.camel.component.sjms.SjmsProducer#sendMessage(org.apache.camel.Exchange,_org.apache.camel.AsyncCallback)_@param exchange_@param callback_@throws Exception;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception {_        if (getProducers() != null) {_            MessageProducerResources producer = null__            try {_                producer = getProducers().borrowObject(getResponseTimeOut())__            } catch (Exception e1) {_                log.warn("The producer pool is exhausted.  Consider setting producerCount to a higher value or disable the fixed size of the pool by setting fixedResourcePool=false.")__                exchange.setException(new Exception("Producer Resource Pool is exhausted"))__            }_            if (producer != null) {__                if (isEndpointTransacted()) {_                    exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy()))__                }__                Message request = SjmsExchangeMessageHelper.createMessage(exchange, producer.getSession())__                _                _                _                String correlationId = null__                if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) {_                    correlationId = UUID.randomUUID().toString().replace("-", "")__                } else {_                    correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class)__                }_                Object responseObject = null__                Exchanger<Object> messageExchanger = new Exchanger<Object>()__                SjmsExchangeMessageHelper.setCorrelationId(request, correlationId)__                try {_                    lock.writeLock().lock()__                    exchangerMap.put(correlationId, messageExchanger)__                } finally {_                    lock.writeLock().unlock()__                }__                MessageConsumerResource consumer = consumers.borrowObject(getResponseTimeOut())__                SjmsExchangeMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__                consumers.returnObject(consumer)__                producer.getMessageProducer().send(request)___                _                _                try {_                    getProducers().returnObject(producer)__                } catch (Exception exception) {_                    _                }__                try {_                    responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)___                    try {_                        lock.writeLock().lock()__                        exchangerMap.remove(correlationId)__                    } finally {_                        lock.writeLock().unlock()__                    }_                } catch (InterruptedException e) {_                    log.debug("Exchanger was interrupted while waiting on response", e)__                    exchange.setException(e)__                } catch (TimeoutException e) {_                    log.debug("Exchanger timed out while waiting on response", e)__                    exchange.setException(e)__                }__                if (exchange.getException() == null) {_                    if (responseObject instanceof Throwable) {_                        exchange.setException((Throwable)responseObject)__                    } else if (responseObject instanceof Message) {_                        Message response = (Message)responseObject__                        SjmsExchangeMessageHelper.populateExchange(response, exchange, true)__                    } else {_                        exchange.setException(new CamelException("Unknown response type: " + responseObject))__                    }_                }_            }__            callback.done(isSynchronous())__        }_    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown,see,org,apache,camel,component,sjms,sjms,producer,send,message,org,apache,camel,exchange,org,apache,camel,async,callback,param,exchange,param,callback,throws,exception;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,throws,exception,if,get,producers,null,message,producer,resources,producer,null,try,producer,get,producers,borrow,object,get,response,time,out,catch,exception,e1,log,warn,the,producer,pool,is,exhausted,consider,setting,producer,count,to,a,higher,value,or,disable,the,fixed,size,of,the,pool,by,setting,fixed,resource,pool,false,exchange,set,exception,new,exception,producer,resource,pool,is,exhausted,if,producer,null,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,get,commit,strategy,message,request,sjms,exchange,message,helper,create,message,exchange,producer,get,session,string,correlation,id,null,if,exchange,get,in,get,header,jmscorrelation,id,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jmscorrelation,id,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,sjms,exchange,message,helper,set,correlation,id,request,correlation,id,try,lock,write,lock,lock,exchanger,map,put,correlation,id,message,exchanger,finally,lock,write,lock,unlock,message,consumer,resource,consumer,consumers,borrow,object,get,response,time,out,sjms,exchange,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,try,lock,write,lock,lock,exchanger,map,remove,correlation,id,finally,lock,write,lock,unlock,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,sjms,exchange,message,helper,populate,exchange,response,exchange,true,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception;1351626413;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown__@see org.apache.camel.component.sjms.SjmsProducer#sendMessage(org.apache.camel.Exchange,_org.apache.camel.AsyncCallback)_@param exchange_@param callback_@throws Exception;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception {_        if (getProducers() != null) {_            MessageProducerResources producer = null__            try {_                producer = getProducers().borrowObject(getResponseTimeOut())__            } catch (Exception e1) {_                log.warn("The producer pool is exhausted.  Consider setting producerCount to a higher value or disable the fixed size of the pool by setting fixedResourcePool=false.")__                exchange.setException(new Exception("Producer Resource Pool is exhausted"))__            }_            if (producer != null) {__                if (isEndpointTransacted()) {_                    exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy()))__                }_                _                Message request = SjmsExchangeMessageHelper.createMessage(exchange, producer.getSession(), getSjmsEndpoint().getJmsKeyFormatStrategy())__                _                _                _                String correlationId = null__                if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) {_                    correlationId = UUID.randomUUID().toString().replace("-", "")__                } else {_                    correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class)__                }_                Object responseObject = null__                Exchanger<Object> messageExchanger = new Exchanger<Object>()__                SjmsExchangeMessageHelper.setCorrelationId(request, correlationId)__                try {_                    lock.writeLock().lock()__                    exchangerMap.put(correlationId, messageExchanger)__                } finally {_                    lock.writeLock().unlock()__                }__                MessageConsumerResource consumer = consumers.borrowObject(getResponseTimeOut())__                SjmsExchangeMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__                consumers.returnObject(consumer)__                producer.getMessageProducer().send(request)___                _                _                try {_                    getProducers().returnObject(producer)__                } catch (Exception exception) {_                    _                }__                try {_                    responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)___                    try {_                        lock.writeLock().lock()__                        exchangerMap.remove(correlationId)__                    } finally {_                        lock.writeLock().unlock()__                    }_                } catch (InterruptedException e) {_                    log.debug("Exchanger was interrupted while waiting on response", e)__                    exchange.setException(e)__                } catch (TimeoutException e) {_                    log.debug("Exchanger timed out while waiting on response", e)__                    exchange.setException(e)__                }__                if (exchange.getException() == null) {_                    if (responseObject instanceof Throwable) {_                        exchange.setException((Throwable)responseObject)__                    } else if (responseObject instanceof Message) {_                        Message response = (Message)responseObject__                        SjmsExchangeMessageHelper.populateExchange(response, exchange, true)__                    } else {_                        exchange.setException(new CamelException("Unknown response type: " + responseObject))__                    }_                }_            }__            callback.done(isSynchronous())__        }_    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown,see,org,apache,camel,component,sjms,sjms,producer,send,message,org,apache,camel,exchange,org,apache,camel,async,callback,param,exchange,param,callback,throws,exception;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,throws,exception,if,get,producers,null,message,producer,resources,producer,null,try,producer,get,producers,borrow,object,get,response,time,out,catch,exception,e1,log,warn,the,producer,pool,is,exhausted,consider,setting,producer,count,to,a,higher,value,or,disable,the,fixed,size,of,the,pool,by,setting,fixed,resource,pool,false,exchange,set,exception,new,exception,producer,resource,pool,is,exhausted,if,producer,null,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,get,commit,strategy,message,request,sjms,exchange,message,helper,create,message,exchange,producer,get,session,get,sjms,endpoint,get,jms,key,format,strategy,string,correlation,id,null,if,exchange,get,in,get,header,jmscorrelation,id,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jmscorrelation,id,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,sjms,exchange,message,helper,set,correlation,id,request,correlation,id,try,lock,write,lock,lock,exchanger,map,put,correlation,id,message,exchanger,finally,lock,write,lock,unlock,message,consumer,resource,consumer,consumers,borrow,object,get,response,time,out,sjms,exchange,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,try,lock,write,lock,lock,exchanger,map,remove,correlation,id,finally,lock,write,lock,unlock,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,sjms,exchange,message,helper,populate,exchange,response,exchange,true,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception;1354318669;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown__@see org.apache.camel.component.sjms.SjmsProducer#sendMessage(org.apache.camel.Exchange,_org.apache.camel.AsyncCallback)_@param exchange_@param callback_@throws Exception;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception {_        if (getProducers() != null) {_            MessageProducerResources producer = null__            try {_                producer = getProducers().borrowObject(getResponseTimeOut())__            } catch (Exception e1) {_                log.warn("The producer pool is exhausted.  Consider setting producerCount to a higher value or disable the fixed size of the pool by setting fixedResourcePool=false.")__                exchange.setException(new Exception("Producer Resource Pool is exhausted"))__            }_            if (producer != null) {__                if (isEndpointTransacted()) {_                    exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy()))__                }_                _                Message request = SjmsExchangeMessageHelper.createMessage(exchange, producer.getSession(), getSjmsEndpoint().getJmsKeyFormatStrategy())__                _                _                _                String correlationId = null__                if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) {_                    correlationId = UUID.randomUUID().toString().replace("-", "")__                } else {_                    correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class)__                }_                Object responseObject = null__                Exchanger<Object> messageExchanger = new Exchanger<Object>()__                SjmsExchangeMessageHelper.setCorrelationId(request, correlationId)__                try {_                    lock.writeLock().lock()__                    exchangerMap.put(correlationId, messageExchanger)__                } finally {_                    lock.writeLock().unlock()__                }__                MessageConsumerResource consumer = consumers.borrowObject(getResponseTimeOut())__                SjmsExchangeMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__                consumers.returnObject(consumer)__                producer.getMessageProducer().send(request)___                _                _                try {_                    getProducers().returnObject(producer)__                } catch (Exception exception) {_                    _                }__                try {_                    responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)___                    try {_                        lock.writeLock().lock()__                        exchangerMap.remove(correlationId)__                    } finally {_                        lock.writeLock().unlock()__                    }_                } catch (InterruptedException e) {_                    log.debug("Exchanger was interrupted while waiting on response", e)__                    exchange.setException(e)__                } catch (TimeoutException e) {_                    log.debug("Exchanger timed out while waiting on response", e)__                    exchange.setException(e)__                }__                if (exchange.getException() == null) {_                    if (responseObject instanceof Throwable) {_                        exchange.setException((Throwable)responseObject)__                    } else if (responseObject instanceof Message) {_                        Message response = (Message)responseObject__                        SjmsExchangeMessageHelper.populateExchange(response, exchange, true)__                    } else {_                        exchange.setException(new CamelException("Unknown response type: " + responseObject))__                    }_                }_            }__            callback.done(isSynchronous())__        }_    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown,see,org,apache,camel,component,sjms,sjms,producer,send,message,org,apache,camel,exchange,org,apache,camel,async,callback,param,exchange,param,callback,throws,exception;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,throws,exception,if,get,producers,null,message,producer,resources,producer,null,try,producer,get,producers,borrow,object,get,response,time,out,catch,exception,e1,log,warn,the,producer,pool,is,exhausted,consider,setting,producer,count,to,a,higher,value,or,disable,the,fixed,size,of,the,pool,by,setting,fixed,resource,pool,false,exchange,set,exception,new,exception,producer,resource,pool,is,exhausted,if,producer,null,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,get,commit,strategy,message,request,sjms,exchange,message,helper,create,message,exchange,producer,get,session,get,sjms,endpoint,get,jms,key,format,strategy,string,correlation,id,null,if,exchange,get,in,get,header,jmscorrelation,id,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jmscorrelation,id,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,sjms,exchange,message,helper,set,correlation,id,request,correlation,id,try,lock,write,lock,lock,exchanger,map,put,correlation,id,message,exchanger,finally,lock,write,lock,unlock,message,consumer,resource,consumer,consumers,borrow,object,get,response,time,out,sjms,exchange,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,try,lock,write,lock,lock,exchanger,map,remove,correlation,id,finally,lock,write,lock,unlock,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,sjms,exchange,message,helper,populate,exchange,response,exchange,true,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception;1383063455;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown__@see org.apache.camel.component.sjms.SjmsProducer#sendMessage(org.apache.camel.Exchange,_org.apache.camel.AsyncCallback)_@param exchange_@param callback_@throws Exception;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception {_        if (getProducers() != null) {_            MessageProducerResources producer = null__            try {_                producer = getProducers().borrowObject(getResponseTimeOut())__            } catch (Exception e1) {_                log.warn("The producer pool is exhausted.  Consider setting producerCount to a higher value or disable the fixed size of the pool by setting fixedResourcePool=false.")__                exchange.setException(new Exception("Producer Resource Pool is exhausted"))__            }_            if (producer != null) {__                if (isEndpointTransacted()) {_                    exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy()))__                }__                Message request = SjmsExchangeMessageHelper.createMessage(exchange, producer.getSession(), getSjmsEndpoint().getJmsKeyFormatStrategy())___                _                _                String correlationId = null__                if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) {_                    correlationId = UUID.randomUUID().toString().replace("-", "")__                } else {_                    correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class)__                }_                Object responseObject = null__                Exchanger<Object> messageExchanger = new Exchanger<Object>()__                SjmsExchangeMessageHelper.setCorrelationId(request, correlationId)__                try {_                    lock.writeLock().lock()__                    exchangerMap.put(correlationId, messageExchanger)__                } finally {_                    lock.writeLock().unlock()__                }__                MessageConsumerResource consumer = consumers.borrowObject(getResponseTimeOut())__                SjmsExchangeMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__                consumers.returnObject(consumer)__                producer.getMessageProducer().send(request)___                _                _                _                try {_                    getProducers().returnObject(producer)__                } catch (Exception exception) {_                    _                }__                try {_                    responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)___                    try {_                        lock.writeLock().lock()__                        exchangerMap.remove(correlationId)__                    } finally {_                        lock.writeLock().unlock()__                    }_                } catch (InterruptedException e) {_                    log.debug("Exchanger was interrupted while waiting on response", e)__                    exchange.setException(e)__                } catch (TimeoutException e) {_                    log.debug("Exchanger timed out while waiting on response", e)__                    exchange.setException(e)__                }__                if (exchange.getException() == null) {_                    if (responseObject instanceof Throwable) {_                        exchange.setException((Throwable)responseObject)__                    } else if (responseObject instanceof Message) {_                        Message response = (Message)responseObject__                        SjmsExchangeMessageHelper.populateExchange(response, exchange, true)__                    } else {_                        exchange.setException(new CamelException("Unknown response type: " + responseObject))__                    }_                }_            }__            callback.done(isSynchronous())__        }_    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown,see,org,apache,camel,component,sjms,sjms,producer,send,message,org,apache,camel,exchange,org,apache,camel,async,callback,param,exchange,param,callback,throws,exception;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,throws,exception,if,get,producers,null,message,producer,resources,producer,null,try,producer,get,producers,borrow,object,get,response,time,out,catch,exception,e1,log,warn,the,producer,pool,is,exhausted,consider,setting,producer,count,to,a,higher,value,or,disable,the,fixed,size,of,the,pool,by,setting,fixed,resource,pool,false,exchange,set,exception,new,exception,producer,resource,pool,is,exhausted,if,producer,null,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,get,commit,strategy,message,request,sjms,exchange,message,helper,create,message,exchange,producer,get,session,get,sjms,endpoint,get,jms,key,format,strategy,string,correlation,id,null,if,exchange,get,in,get,header,jmscorrelation,id,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jmscorrelation,id,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,sjms,exchange,message,helper,set,correlation,id,request,correlation,id,try,lock,write,lock,lock,exchanger,map,put,correlation,id,message,exchanger,finally,lock,write,lock,unlock,message,consumer,resource,consumer,consumers,borrow,object,get,response,time,out,sjms,exchange,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,try,lock,write,lock,lock,exchanger,map,remove,correlation,id,finally,lock,write,lock,unlock,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,sjms,exchange,message,helper,populate,exchange,response,exchange,true,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception;1392936452;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown__@see org.apache.camel.component.sjms.SjmsProducer#sendMessage(org.apache.camel.Exchange,_org.apache.camel.AsyncCallback)_@param exchange_@param callback_@throws Exception;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback) throws Exception {_        if (getProducers() != null) {_            MessageProducerResources producer = null__            try {_                producer = getProducers().borrowObject(getResponseTimeOut())__            } catch (Exception e1) {_                log.warn("The producer pool is exhausted.  Consider setting producerCount to a higher value or disable the fixed size of the pool by setting fixedResourcePool=false.")__                exchange.setException(new Exception("Producer Resource Pool is exhausted"))__            }_            if (producer != null) {__                if (isEndpointTransacted()) {_                    exchange.getUnitOfWork().addSynchronization(new SessionTransactionSynchronization(producer.getSession(), getCommitStrategy()))__                }__                Message request = SjmsExchangeMessageHelper.createMessage(exchange, producer.getSession(), getSjmsEndpoint().getJmsKeyFormatStrategy())___                _                _                String correlationId = null__                if (exchange.getIn().getHeader("JMSCorrelationID", String.class) == null) {_                    correlationId = UUID.randomUUID().toString().replace("-", "")__                } else {_                    correlationId = exchange.getIn().getHeader("JMSCorrelationID", String.class)__                }_                Object responseObject = null__                Exchanger<Object> messageExchanger = new Exchanger<Object>()__                SjmsExchangeMessageHelper.setCorrelationId(request, correlationId)__                try {_                    lock.writeLock().lock()__                    exchangerMap.put(correlationId, messageExchanger)__                } finally {_                    lock.writeLock().unlock()__                }__                MessageConsumerResource consumer = consumers.borrowObject(getResponseTimeOut())__                SjmsExchangeMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__                consumers.returnObject(consumer)__                producer.getMessageProducer().send(request)___                _                _                _                try {_                    getProducers().returnObject(producer)__                } catch (Exception exception) {_                    _                }__                try {_                    responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)___                    try {_                        lock.writeLock().lock()__                        exchangerMap.remove(correlationId)__                    } finally {_                        lock.writeLock().unlock()__                    }_                } catch (InterruptedException e) {_                    log.debug("Exchanger was interrupted while waiting on response", e)__                    exchange.setException(e)__                } catch (TimeoutException e) {_                    log.debug("Exchanger timed out while waiting on response", e)__                    exchange.setException(e)__                }__                if (exchange.getException() == null) {_                    if (responseObject instanceof Throwable) {_                        exchange.setException((Throwable)responseObject)__                    } else if (responseObject instanceof Message) {_                        Message response = (Message)responseObject__                        SjmsExchangeMessageHelper.populateExchange(response, exchange, true)__                    } else {_                        exchange.setException(new CamelException("Unknown response type: " + responseObject))__                    }_                }_            }__            callback.done(isSynchronous())__        }_    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown,see,org,apache,camel,component,sjms,sjms,producer,send,message,org,apache,camel,exchange,org,apache,camel,async,callback,param,exchange,param,callback,throws,exception;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,throws,exception,if,get,producers,null,message,producer,resources,producer,null,try,producer,get,producers,borrow,object,get,response,time,out,catch,exception,e1,log,warn,the,producer,pool,is,exhausted,consider,setting,producer,count,to,a,higher,value,or,disable,the,fixed,size,of,the,pool,by,setting,fixed,resource,pool,false,exchange,set,exception,new,exception,producer,resource,pool,is,exhausted,if,producer,null,if,is,endpoint,transacted,exchange,get,unit,of,work,add,synchronization,new,session,transaction,synchronization,producer,get,session,get,commit,strategy,message,request,sjms,exchange,message,helper,create,message,exchange,producer,get,session,get,sjms,endpoint,get,jms,key,format,strategy,string,correlation,id,null,if,exchange,get,in,get,header,jmscorrelation,id,string,class,null,correlation,id,uuid,random,uuid,to,string,replace,else,correlation,id,exchange,get,in,get,header,jmscorrelation,id,string,class,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,sjms,exchange,message,helper,set,correlation,id,request,correlation,id,try,lock,write,lock,lock,exchanger,map,put,correlation,id,message,exchanger,finally,lock,write,lock,unlock,message,consumer,resource,consumer,consumers,borrow,object,get,response,time,out,sjms,exchange,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,get,producers,return,object,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,try,lock,write,lock,lock,exchanger,map,remove,correlation,id,finally,lock,write,lock,unlock,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,response,message,response,object,sjms,exchange,message,helper,populate,exchange,response,exchange,true,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> MessageConsumerPool -> public MessageConsumerPool(int poolSize);1343905000;TODO Add Constructor Javadoc__@param poolSize;public MessageConsumerPool(int poolSize) {_            super(poolSize)__        };todo,add,constructor,javadoc,param,pool,size;public,message,consumer,pool,int,pool,size,super,pool,size
InOutProducer -> MessageConsumerPool -> public MessageConsumerPool(int poolSize);1344346492;TODO Add Constructor Javadoc__@param poolSize;public MessageConsumerPool(int poolSize) {_            super(poolSize)__        };todo,add,constructor,javadoc,param,pool,size;public,message,consumer,pool,int,pool,size,super,pool,size
InOutProducer -> MessageConsumerPool -> public MessageConsumerPool(int poolSize);1344999539;TODO Add Constructor Javadoc__@param poolSize;public MessageConsumerPool(int poolSize) {_            super(poolSize)__        };todo,add,constructor,javadoc,param,pool,size;public,message,consumer,pool,int,pool,size,super,pool,size
InOutProducer -> MessageConsumerPool -> public MessageConsumerPool(int poolSize);1346298132;TODO Add Constructor Javadoc__@param poolSize;public MessageConsumerPool(int poolSize) {_            super(poolSize)__        };todo,add,constructor,javadoc,param,pool,size;public,message,consumer,pool,int,pool,size,super,pool,size
InOutProducer -> MessageConsumerPool -> public MessageConsumerPool(int poolSize);1348685513;TODO Add Constructor Javadoc__@param poolSize;public MessageConsumerPool(int poolSize) {_            super(poolSize)__        };todo,add,constructor,javadoc,param,pool,size;public,message,consumer,pool,int,pool,size,super,pool,size
InOutProducer -> MessageConsumerPool -> public MessageConsumerPool(int poolSize);1349113955;TODO Add Constructor Javadoc__@param poolSize;public MessageConsumerPool(int poolSize) {_            super(poolSize)__        };todo,add,constructor,javadoc,param,pool,size;public,message,consumer,pool,int,pool,size,super,pool,size
InOutProducer -> MessageConsumerPool -> public MessageConsumerPool(int poolSize);1349476580;TODO Add Constructor Javadoc__@param poolSize;public MessageConsumerPool(int poolSize) {_            super(poolSize)__        };todo,add,constructor,javadoc,param,pool,size;public,message,consumer,pool,int,pool,size,super,pool,size
InOutProducer -> MessageConsumerPool -> public MessageConsumerPool(int poolSize);1351626413;TODO Add Constructor Javadoc__@param poolSize;public MessageConsumerPool(int poolSize) {_            super(poolSize)__        };todo,add,constructor,javadoc,param,pool,size;public,message,consumer,pool,int,pool,size,super,pool,size
InOutProducer -> MessageConsumerPool -> public MessageConsumerPool(int poolSize);1354318669;TODO Add Constructor Javadoc__@param poolSize;public MessageConsumerPool(int poolSize) {_            super(poolSize)__        };todo,add,constructor,javadoc,param,pool,size;public,message,consumer,pool,int,pool,size,super,pool,size
InOutProducer -> MessageConsumerPool -> public MessageConsumerPool(int poolSize);1383063455;TODO Add Constructor Javadoc__@param poolSize;public MessageConsumerPool(int poolSize) {_            super(poolSize)__        };todo,add,constructor,javadoc,param,pool,size;public,message,consumer,pool,int,pool,size,super,pool,size
InOutProducer -> MessageConsumerPool -> public MessageConsumerPool(int poolSize);1392936452;TODO Add Constructor Javadoc__@param poolSize;public MessageConsumerPool(int poolSize) {_            super(poolSize)__        };todo,add,constructor,javadoc,param,pool,size;public,message,consumer,pool,int,pool,size,super,pool,size
InOutProducer -> InternalTempDestinationListener -> public InternalTempDestinationListener(Exchanger<Object> exchanger);1343905000;TODO Add Constructor Javadoc__@param exchanger;public InternalTempDestinationListener(Exchanger<Object> exchanger) {_            super()__            this.exchanger = exchanger__        };todo,add,constructor,javadoc,param,exchanger;public,internal,temp,destination,listener,exchanger,object,exchanger,super,this,exchanger,exchanger
InOutProducer -> InternalTempDestinationListener -> public InternalTempDestinationListener(Exchanger<Object> exchanger);1344346492;TODO Add Constructor Javadoc__@param exchanger;public InternalTempDestinationListener(Exchanger<Object> exchanger) {_            super()__            this.exchanger = exchanger__        };todo,add,constructor,javadoc,param,exchanger;public,internal,temp,destination,listener,exchanger,object,exchanger,super,this,exchanger,exchanger
InOutProducer -> InternalTempDestinationListener -> public InternalTempDestinationListener(Exchanger<Object> exchanger);1344999539;TODO Add Constructor Javadoc__@param exchanger;public InternalTempDestinationListener(Exchanger<Object> exchanger) {_            this.exchanger = exchanger__        };todo,add,constructor,javadoc,param,exchanger;public,internal,temp,destination,listener,exchanger,object,exchanger,this,exchanger,exchanger
InOutProducer -> InternalTempDestinationListener -> public InternalTempDestinationListener(Exchanger<Object> exchanger);1346298132;TODO Add Constructor Javadoc__@param exchanger;public InternalTempDestinationListener(Exchanger<Object> exchanger) {_            super()__            this.exchanger = exchanger__        };todo,add,constructor,javadoc,param,exchanger;public,internal,temp,destination,listener,exchanger,object,exchanger,super,this,exchanger,exchanger
InOutProducer -> InternalTempDestinationListener -> public InternalTempDestinationListener(Exchanger<Object> exchanger);1348685513;TODO Add Constructor Javadoc__@param exchanger;public InternalTempDestinationListener(Exchanger<Object> exchanger) {_            super()__            this.exchanger = exchanger__        };todo,add,constructor,javadoc,param,exchanger;public,internal,temp,destination,listener,exchanger,object,exchanger,super,this,exchanger,exchanger
InOutProducer -> InternalTempDestinationListener -> public InternalTempDestinationListener(Exchanger<Object> exchanger);1349113955;TODO Add Constructor Javadoc__@param exchanger;public InternalTempDestinationListener(Exchanger<Object> exchanger) {_            super()__            this.exchanger = exchanger__        };todo,add,constructor,javadoc,param,exchanger;public,internal,temp,destination,listener,exchanger,object,exchanger,super,this,exchanger,exchanger
InOutProducer -> InternalTempDestinationListener -> public InternalTempDestinationListener(Exchanger<Object> exchanger);1349476580;TODO Add Constructor Javadoc__@param exchanger;public InternalTempDestinationListener(Exchanger<Object> exchanger) {_            super()__            this.exchanger = exchanger__        };todo,add,constructor,javadoc,param,exchanger;public,internal,temp,destination,listener,exchanger,object,exchanger,super,this,exchanger,exchanger
InOutProducer -> InternalTempDestinationListener -> public InternalTempDestinationListener(Exchanger<Object> exchanger);1351626413;TODO Add Constructor Javadoc__@param exchanger;public InternalTempDestinationListener(Exchanger<Object> exchanger) {_            super()__            this.exchanger = exchanger__        };todo,add,constructor,javadoc,param,exchanger;public,internal,temp,destination,listener,exchanger,object,exchanger,super,this,exchanger,exchanger
InOutProducer -> InternalTempDestinationListener -> public InternalTempDestinationListener(Exchanger<Object> exchanger);1354318669;TODO Add Constructor Javadoc__@param exchanger;public InternalTempDestinationListener(Exchanger<Object> exchanger) {_            this.exchanger = exchanger__        };todo,add,constructor,javadoc,param,exchanger;public,internal,temp,destination,listener,exchanger,object,exchanger,this,exchanger,exchanger
InOutProducer -> InternalTempDestinationListener -> public InternalTempDestinationListener(Exchanger<Object> exchanger);1383063455;TODO Add Constructor Javadoc__@param exchanger;public InternalTempDestinationListener(Exchanger<Object> exchanger) {_            this.exchanger = exchanger__        };todo,add,constructor,javadoc,param,exchanger;public,internal,temp,destination,listener,exchanger,object,exchanger,this,exchanger,exchanger
InOutProducer -> InternalTempDestinationListener -> public InternalTempDestinationListener(Exchanger<Object> exchanger);1392936452;TODO Add Constructor Javadoc__@param exchanger;public InternalTempDestinationListener(Exchanger<Object> exchanger) {_            this.exchanger = exchanger__        };todo,add,constructor,javadoc,param,exchanger;public,internal,temp,destination,listener,exchanger,object,exchanger,this,exchanger,exchanger
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception;1476797752;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception {_        Message request = getEndpoint().getBinding().makeJmsMessage(exchange, producer.getSession())___        String correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)__        if (correlationId == null) {_            _            correlationId = GENERATED_CORRELATION_ID_PREFIX + getUuidGenerator().generateUuid()__        }__        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<Object>()__        JmsMessageHelper.setCorrelationId(request, correlationId)__        EXCHANGERS.put(correlationId, messageExchanger)___        MessageConsumerResources consumer = consumers.borrowObject()__        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            releaseProducerCallback.release(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)__            EXCHANGERS.remove(correlationId)__        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message message = (Message) responseObject___                SjmsMessage response = new SjmsMessage(message, consumer.getSession(), getEndpoint().getBinding())__                _                _                _                exchange.setOut(response)__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,final,release,producer,callback,release,producer,callback,throws,exception,message,request,get,endpoint,get,binding,make,jms,message,exchange,producer,get,session,string,correlation,id,exchange,get,in,get,header,jms,constants,string,class,if,correlation,id,null,correlation,id,get,uuid,generator,generate,uuid,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,helper,set,correlation,id,request,correlation,id,exchangers,put,correlation,id,message,exchanger,message,consumer,resources,consumer,consumers,borrow,object,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,release,producer,callback,release,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,exchangers,remove,correlation,id,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,message,message,response,object,sjms,message,response,new,sjms,message,message,consumer,get,session,get,endpoint,get,binding,exchange,set,out,response,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception;1476863151;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception {_        Message request = getEndpoint().getBinding().makeJmsMessage(exchange, producer.getSession())___        String correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)__        if (correlationId == null) {_            _            correlationId = GENERATED_CORRELATION_ID_PREFIX + getUuidGenerator().generateUuid()__        }__        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<Object>()__        JmsMessageHelper.setCorrelationId(request, correlationId)__        EXCHANGERS.put(correlationId, messageExchanger)___        MessageConsumerResources consumer = consumers.borrowObject()__        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            releaseProducerCallback.release(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)__            EXCHANGERS.remove(correlationId)__        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message message = (Message) responseObject___                SjmsMessage response = new SjmsMessage(message, consumer.getSession(), getEndpoint().getBinding())__                _                _                _                exchange.setOut(response)__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,final,release,producer,callback,release,producer,callback,throws,exception,message,request,get,endpoint,get,binding,make,jms,message,exchange,producer,get,session,string,correlation,id,exchange,get,in,get,header,jms,constants,string,class,if,correlation,id,null,correlation,id,get,uuid,generator,generate,uuid,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,helper,set,correlation,id,request,correlation,id,exchangers,put,correlation,id,message,exchanger,message,consumer,resources,consumer,consumers,borrow,object,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,release,producer,callback,release,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,exchangers,remove,correlation,id,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,message,message,response,object,sjms,message,response,new,sjms,message,message,consumer,get,session,get,endpoint,get,binding,exchange,set,out,response,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception;1476863370;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception {_        Message request = getEndpoint().getBinding().makeJmsMessage(exchange, producer.getSession())___        String correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)__        if (correlationId == null) {_            _            correlationId = GENERATED_CORRELATION_ID_PREFIX + getUuidGenerator().generateUuid()__        }__        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<Object>()__        JmsMessageHelper.setCorrelationId(request, correlationId)__        EXCHANGERS.put(correlationId, messageExchanger)___        MessageConsumerResources consumer = consumers.borrowObject()__        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            releaseProducerCallback.release(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)__            EXCHANGERS.remove(correlationId)__        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message message = (Message) responseObject___                SjmsMessage response = new SjmsMessage(message, consumer.getSession(), getEndpoint().getBinding())__                _                _                _                exchange.setOut(response)__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,final,release,producer,callback,release,producer,callback,throws,exception,message,request,get,endpoint,get,binding,make,jms,message,exchange,producer,get,session,string,correlation,id,exchange,get,in,get,header,jms,constants,string,class,if,correlation,id,null,correlation,id,get,uuid,generator,generate,uuid,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,helper,set,correlation,id,request,correlation,id,exchangers,put,correlation,id,message,exchanger,message,consumer,resources,consumer,consumers,borrow,object,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,release,producer,callback,release,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,exchangers,remove,correlation,id,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,message,message,response,object,sjms,message,response,new,sjms,message,message,consumer,get,session,get,endpoint,get,binding,exchange,set,out,response,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception;1479916234;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception {_        Message request = getEndpoint().getBinding().makeJmsMessage(exchange, producer.getSession())___        String correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)__        if (correlationId == null) {_            _            correlationId = GENERATED_CORRELATION_ID_PREFIX + getUuidGenerator().generateUuid()__        }__        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<Object>()__        JmsMessageHelper.setCorrelationId(request, correlationId)__        EXCHANGERS.put(correlationId, messageExchanger)___        MessageConsumerResources consumer = consumers.borrowObject()__        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            releaseProducerCallback.release(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)__            EXCHANGERS.remove(correlationId)__        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message message = (Message) responseObject___                SjmsMessage response = new SjmsMessage(message, consumer.getSession(), getEndpoint().getBinding())__                _                _                _                exchange.setOut(response)__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,final,release,producer,callback,release,producer,callback,throws,exception,message,request,get,endpoint,get,binding,make,jms,message,exchange,producer,get,session,string,correlation,id,exchange,get,in,get,header,jms,constants,string,class,if,correlation,id,null,correlation,id,get,uuid,generator,generate,uuid,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,helper,set,correlation,id,request,correlation,id,exchangers,put,correlation,id,message,exchanger,message,consumer,resources,consumer,consumers,borrow,object,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,release,producer,callback,release,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,exchangers,remove,correlation,id,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,message,message,response,object,sjms,message,response,new,sjms,message,message,consumer,get,session,get,endpoint,get,binding,exchange,set,out,response,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception;1482171448;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception {_        Message request = getEndpoint().getBinding().makeJmsMessage(exchange, producer.getSession())___        String correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)__        if (correlationId == null) {_            _            correlationId = GENERATED_CORRELATION_ID_PREFIX + getUuidGenerator().generateUuid()__        }__        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<Object>()__        JmsMessageHelper.setCorrelationId(request, correlationId)__        EXCHANGERS.put(correlationId, messageExchanger)___        MessageConsumerResources consumer = consumers.borrowObject()__        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            releaseProducerCallback.release(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)__            EXCHANGERS.remove(correlationId)__        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message message = (Message) responseObject___                SjmsMessage response = new SjmsMessage(message, consumer.getSession(), getEndpoint().getBinding())__                _                _                _                exchange.setOut(response)__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,final,release,producer,callback,release,producer,callback,throws,exception,message,request,get,endpoint,get,binding,make,jms,message,exchange,producer,get,session,string,correlation,id,exchange,get,in,get,header,jms,constants,string,class,if,correlation,id,null,correlation,id,get,uuid,generator,generate,uuid,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,helper,set,correlation,id,request,correlation,id,exchangers,put,correlation,id,message,exchanger,message,consumer,resources,consumer,consumers,borrow,object,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,release,producer,callback,release,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,exchangers,remove,correlation,id,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,message,message,response,object,sjms,message,response,new,sjms,message,message,consumer,get,session,get,endpoint,get,binding,exchange,set,out,response,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception;1489430295;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception {_        Message request = getEndpoint().getBinding().makeJmsMessage(exchange, producer.getSession())___        String correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)__        if (correlationId == null) {_            _            correlationId = GENERATED_CORRELATION_ID_PREFIX + getUuidGenerator().generateUuid()__        }__        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<Object>()__        JmsMessageHelper.setCorrelationId(request, correlationId)__        EXCHANGERS.put(correlationId, messageExchanger)___        MessageConsumerResources consumer = consumers.borrowObject()__        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            releaseProducerCallback.release(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)__            EXCHANGERS.remove(correlationId)__        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message message = (Message) responseObject___                SjmsMessage response = new SjmsMessage(message, consumer.getSession(), getEndpoint().getBinding())__                _                _                _                exchange.setOut(response)__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,final,release,producer,callback,release,producer,callback,throws,exception,message,request,get,endpoint,get,binding,make,jms,message,exchange,producer,get,session,string,correlation,id,exchange,get,in,get,header,jms,constants,string,class,if,correlation,id,null,correlation,id,get,uuid,generator,generate,uuid,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,helper,set,correlation,id,request,correlation,id,exchangers,put,correlation,id,message,exchanger,message,consumer,resources,consumer,consumers,borrow,object,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,release,producer,callback,release,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,exchangers,remove,correlation,id,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,message,message,response,object,sjms,message,response,new,sjms,message,message,consumer,get,session,get,endpoint,get,binding,exchange,set,out,response,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception;1520496305;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception {_        Message request = getEndpoint().getBinding().makeJmsMessage(exchange, producer.getSession())___        String correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)__        if (correlationId == null) {_            _            correlationId = GENERATED_CORRELATION_ID_PREFIX + getUuidGenerator().generateUuid()__        }__        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<Object>()__        JmsMessageHelper.setCorrelationId(request, correlationId)__        EXCHANGERS.put(correlationId, messageExchanger)___        MessageConsumerResources consumer = consumers.borrowObject()__        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            releaseProducerCallback.release(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)__            EXCHANGERS.remove(correlationId)__        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message message = (Message) responseObject___                SjmsMessage response = new SjmsMessage(message, consumer.getSession(), getEndpoint().getBinding())__                _                _                _                exchange.setOut(response)__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,final,release,producer,callback,release,producer,callback,throws,exception,message,request,get,endpoint,get,binding,make,jms,message,exchange,producer,get,session,string,correlation,id,exchange,get,in,get,header,jms,constants,string,class,if,correlation,id,null,correlation,id,get,uuid,generator,generate,uuid,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,object,jms,message,helper,set,correlation,id,request,correlation,id,exchangers,put,correlation,id,message,exchanger,message,consumer,resources,consumer,consumers,borrow,object,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,release,producer,callback,release,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,exchangers,remove,correlation,id,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,message,message,response,object,sjms,message,response,new,sjms,message,message,consumer,get,session,get,endpoint,get,binding,exchange,set,out,response,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception;1524063178;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception {_        Message request = getEndpoint().getBinding().makeJmsMessage(exchange, producer.getSession())___        String correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)__        if (correlationId == null) {_            _            correlationId = GENERATED_CORRELATION_ID_PREFIX + getUuidGenerator().generateUuid()__        }__        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<>()__        JmsMessageHelper.setCorrelationId(request, correlationId)__        EXCHANGERS.put(correlationId, messageExchanger)___        MessageConsumerResources consumer = consumers.borrowObject()__        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            releaseProducerCallback.release(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)__            EXCHANGERS.remove(correlationId)__        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message message = (Message) responseObject___                SjmsMessage response = new SjmsMessage(message, consumer.getSession(), getEndpoint().getBinding())__                _                _                _                exchange.setOut(response)__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,final,release,producer,callback,release,producer,callback,throws,exception,message,request,get,endpoint,get,binding,make,jms,message,exchange,producer,get,session,string,correlation,id,exchange,get,in,get,header,jms,constants,string,class,if,correlation,id,null,correlation,id,get,uuid,generator,generate,uuid,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,jms,message,helper,set,correlation,id,request,correlation,id,exchangers,put,correlation,id,message,exchanger,message,consumer,resources,consumer,consumers,borrow,object,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,release,producer,callback,release,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,exchangers,remove,correlation,id,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,message,message,response,object,sjms,message,response,new,sjms,message,message,consumer,get,session,get,endpoint,get,binding,exchange,set,out,response,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception;1536687142;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception {_        Message request = getEndpoint().getBinding().makeJmsMessage(exchange, producer.getSession())___        String correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)__        if (correlationId == null) {_            _            correlationId = GENERATED_CORRELATION_ID_PREFIX + getUuidGenerator().generateUuid()__        }__        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<>()__        JmsMessageHelper.setCorrelationId(request, correlationId)__        EXCHANGERS.put(correlationId, messageExchanger)___        MessageConsumerResources consumer = consumers.borrowObject()__        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            releaseProducerCallback.release(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)__            EXCHANGERS.remove(correlationId)__        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message message = (Message) responseObject___                SjmsMessage response = new SjmsMessage(message, consumer.getSession(), getEndpoint().getBinding())__                _                _                _                exchange.setOut(response)__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,final,release,producer,callback,release,producer,callback,throws,exception,message,request,get,endpoint,get,binding,make,jms,message,exchange,producer,get,session,string,correlation,id,exchange,get,in,get,header,jms,constants,string,class,if,correlation,id,null,correlation,id,get,uuid,generator,generate,uuid,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,jms,message,helper,set,correlation,id,request,correlation,id,exchangers,put,correlation,id,message,exchanger,message,consumer,resources,consumer,consumers,borrow,object,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,release,producer,callback,release,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,exchangers,remove,correlation,id,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,message,message,response,object,sjms,message,response,new,sjms,message,message,consumer,get,session,get,endpoint,get,binding,exchange,set,out,response,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception;1540108158;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception {_        Message request = getEndpoint().getBinding().makeJmsMessage(exchange, producer.getSession())___        String correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)__        if (correlationId == null) {_            _            correlationId = GENERATED_CORRELATION_ID_PREFIX + getUuidGenerator().generateUuid()__        }__        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<>()__        JmsMessageHelper.setCorrelationId(request, correlationId)__        EXCHANGERS.put(correlationId, messageExchanger)___        MessageConsumerResources consumer = consumers.borrowObject()__        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            releaseProducerCallback.release(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)__            EXCHANGERS.remove(correlationId)__        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message message = (Message) responseObject___                SjmsMessage response = new SjmsMessage(exchange, message, consumer.getSession(), getEndpoint().getBinding())__                _                _                _                exchange.setOut(response)__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,final,release,producer,callback,release,producer,callback,throws,exception,message,request,get,endpoint,get,binding,make,jms,message,exchange,producer,get,session,string,correlation,id,exchange,get,in,get,header,jms,constants,string,class,if,correlation,id,null,correlation,id,get,uuid,generator,generate,uuid,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,jms,message,helper,set,correlation,id,request,correlation,id,exchangers,put,correlation,id,message,exchanger,message,consumer,resources,consumer,consumers,borrow,object,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,release,producer,callback,release,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,exchangers,remove,correlation,id,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,message,message,response,object,sjms,message,response,new,sjms,message,exchange,message,consumer,get,session,get,endpoint,get,binding,exchange,set,out,response,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
InOutProducer -> @Override     public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception;1543929598;TODO time out is actually double as it waits for the producer and then_waits for the response. Use an atomic long to manage the countdown;@Override_    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception {_        Message request = getEndpoint().getBinding().makeJmsMessage(exchange, producer.getSession())___        String correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)__        if (correlationId == null) {_            _            correlationId = GENERATED_CORRELATION_ID_PREFIX + getUuidGenerator().generateUuid()__        }__        Object responseObject = null__        Exchanger<Object> messageExchanger = new Exchanger<>()__        JmsMessageHelper.setCorrelationId(request, correlationId)__        EXCHANGERS.put(correlationId, messageExchanger)___        MessageConsumerResources consumer = consumers.borrowObject()__        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination())__        consumers.returnObject(consumer)__        producer.getMessageProducer().send(request)___        _        _        _        try {_            releaseProducerCallback.release(producer)__        } catch (Exception exception) {_            _        }__        try {_            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS)__            EXCHANGERS.remove(correlationId)__        } catch (InterruptedException e) {_            log.debug("Exchanger was interrupted while waiting on response", e)__            exchange.setException(e)__        } catch (TimeoutException e) {_            log.debug("Exchanger timed out while waiting on response", e)__            exchange.setException(e)__        }__        if (exchange.getException() == null) {_            if (responseObject instanceof Throwable) {_                exchange.setException((Throwable) responseObject)__            } else if (responseObject instanceof Message) {_                Message message = (Message) responseObject___                SjmsMessage response = new SjmsMessage(exchange, message, consumer.getSession(), getEndpoint().getBinding())__                _                _                _                exchange.setOut(response)__            } else {_                exchange.setException(new CamelException("Unknown response type: " + responseObject))__            }_        }__        callback.done(isSynchronous())__    };todo,time,out,is,actually,double,as,it,waits,for,the,producer,and,then,waits,for,the,response,use,an,atomic,long,to,manage,the,countdown;override,public,void,send,message,final,exchange,exchange,final,async,callback,callback,final,message,producer,resources,producer,final,release,producer,callback,release,producer,callback,throws,exception,message,request,get,endpoint,get,binding,make,jms,message,exchange,producer,get,session,string,correlation,id,exchange,get,in,get,header,jms,constants,string,class,if,correlation,id,null,correlation,id,get,uuid,generator,generate,uuid,object,response,object,null,exchanger,object,message,exchanger,new,exchanger,jms,message,helper,set,correlation,id,request,correlation,id,exchangers,put,correlation,id,message,exchanger,message,consumer,resources,consumer,consumers,borrow,object,jms,message,helper,set,jmsreply,to,request,consumer,get,reply,to,destination,consumers,return,object,consumer,producer,get,message,producer,send,request,try,release,producer,callback,release,producer,catch,exception,exception,try,response,object,message,exchanger,exchange,null,get,response,time,out,time,unit,milliseconds,exchangers,remove,correlation,id,catch,interrupted,exception,e,log,debug,exchanger,was,interrupted,while,waiting,on,response,e,exchange,set,exception,e,catch,timeout,exception,e,log,debug,exchanger,timed,out,while,waiting,on,response,e,exchange,set,exception,e,if,exchange,get,exception,null,if,response,object,instanceof,throwable,exchange,set,exception,throwable,response,object,else,if,response,object,instanceof,message,message,message,message,response,object,sjms,message,response,new,sjms,message,exchange,message,consumer,get,session,get,endpoint,get,binding,exchange,set,out,response,else,exchange,set,exception,new,camel,exception,unknown,response,type,response,object,callback,done,is,synchronous
