commented;modifiers;parameterAmount;loc;comment;code
false;public;1;18;;@Override public void onFailure(Exchange exchange) {     try {         lock.readLock().lock().         if (commitStrategy.rollback(exchange)) {             if (LOG.isDebugEnabled()) {                 LOG.debug("Processing failure of Exchange id:{}", exchange.getExchangeId()).             }             if (session != null && session.getTransacted()) {                 session.rollback().             }         }     } catch (Exception e) {         LOG.warn("Failed to rollback the session: " + e.getMessage() + ". This exception will be ignored.", e).     } finally {         lock.readLock().unlock().     } }
false;public;1;20;;@Override public void onComplete(Exchange exchange) {     try {         lock.readLock().lock().         if (commitStrategy.commit(exchange)) {             if (LOG.isDebugEnabled()) {                 LOG.debug("Processing completion of Exchange id:{}", exchange.getExchangeId()).             }             if (session != null && session.getTransacted()) {                 session.commit().             }         }     } catch (Exception e) {         LOG.warn("Failed to commit the session: " + e.getMessage() + ". This exception will be ignored.", e).         exchange.setException(e).     } finally {         lock.readLock().unlock().     }     resetTask(). }
false;private;0;8;;private void createTask() {     try {         lock.writeLock().lock().         currentTask = new TimeoutTask().     } finally {         lock.writeLock().unlock().     } }
false;private;0;10;;private void resetTask() {     try {         lock.writeLock().lock().         currentTask.cancel().         currentTask = new TimeoutTask().     } finally {         lock.writeLock().unlock().     }     timedTaskManager.addTask(currentTask, batchTransactionTimeout). }
true;public;0;17;/**  * When the timer executes, either commits or rolls back the session  * transaction.  */ ;/**  * When the timer executes, either commits or rolls back the session  * transaction.  */ public void run() {     LOG.debug("Batch Transaction Timer expired").     try {         lock.writeLock().lock().         LOG.trace("Committing the current transactions").         try {             if (session != null && session.getTransacted()) {                 session.commit().             }             ((BatchTransactionCommitStrategy) commitStrategy).reset().         } catch (Exception e) {             LOG.warn("Failed to commit the session during timeout: " + e.getMessage() + ". This exception will be ignored.", e).         }     } finally {         lock.writeLock().unlock().     } }
false;public;0;5;;@Override public boolean cancel() {     LOG.trace("Cancelling the TimeoutTask").     return super.cancel(). }
