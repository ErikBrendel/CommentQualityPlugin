commented;modifiers;parameterAmount;loc;comment;code
false;public;1;65;;@Override public void handleMessage(final Exchange exchange) {     try {         MessageProducer messageProducer = null.         Object obj = exchange.getIn().getHeader(JmsConstants.JMS_REPLY_TO).         if (obj != null) {             Destination replyTo.             if (isDestination(obj)) {                 replyTo = (Destination) obj.             } else if (obj instanceof String) {                 replyTo = getEndpoint().getDestinationCreationStrategy().createDestination(getSession(), (String) obj, isTopic()).             } else {                 throw new Exception("The value of JMSReplyTo must be a valid Destination or String.  Value provided: " + obj).             }             String destinationName = getDestinationName(replyTo).             try {                 lock.readLock().lock().                 if (producerCache.containsKey(destinationName)) {                     messageProducer = producerCache.get(destinationName).                 }             } finally {                 lock.readLock().unlock().             }             if (messageProducer == null) {                 try {                     lock.writeLock().lock().                     messageProducer = getSession().createProducer(replyTo).                     producerCache.put(destinationName, messageProducer).                 } finally {                     lock.writeLock().unlock().                 }             }         }         MessageHandlerAsyncCallback callback = new MessageHandlerAsyncCallback(exchange, messageProducer).         if (exchange.isFailed()) {             return.         } else {             if (isTransacted() || isSynchronous()) {                 // must process synchronous if transacted or configured to do so                 log.debug("Synchronous processing: Message[{}], Destination[{}] ", exchange.getIn().getBody(), getEndpoint().getEndpointUri()).                 try {                     getProcessor().process(exchange).                 } catch (Exception e) {                     exchange.setException(e).                 } finally {                     callback.done(true).                 }             } else {                 // process asynchronous using the async routing engine                 if (log.isDebugEnabled()) {                     log.debug("Asynchronous processing: Message[{}], Destination[{}] ", exchange.getIn().getBody(), getEndpoint().getEndpointUri()).                 }                 getProcessor().process(exchange, callback).             }         }     } catch (Exception e) {         exchange.setException(e).     }     if (log.isDebugEnabled()) {         log.debug("SjmsMessageConsumer invoked for Exchange id:{}", exchange.getExchangeId()).     } }
false;public;0;11;;@Override public void close() {     for (final Map.Entry<String, MessageProducer> entry : producerCache.entrySet()) {         try {             entry.getValue().close().         } catch (JMSException e) {             log.debug("Cached MessageProducer with key: " + entry.getKey() + " threw an unexpected exception. This exception is ignored.", e).         }     }     producerCache.clear(). }
false;private;1;3;;private boolean isDestination(Object object) {     return object instanceof Destination. }
false;private;1;10;;private String getDestinationName(Destination destination) throws Exception {     String answer = null.     if (destination instanceof Queue) {         answer = ((Queue) destination).getQueueName().     } else if (destination instanceof Topic) {         answer = ((Topic) destination).getTopicName().     }     return answer. }
false;public;1;12;;@Override public void done(boolean sync) {     try {         // the response can either be in OUT or IN         org.apache.camel.Message msg = exchange.hasOut() ? exchange.getOut() : exchange.getIn().         Message response = getEndpoint().getBinding().makeJmsMessage(exchange, msg.getBody(), msg.getHeaders(), getSession(), null).         response.setJMSCorrelationID(exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class)).         localProducer.send(response).     } catch (Exception e) {         exchange.setException(e).     } }
