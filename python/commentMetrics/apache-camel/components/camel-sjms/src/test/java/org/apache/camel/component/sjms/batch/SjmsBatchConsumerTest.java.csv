commented;modifiers;parameterAmount;loc;comment;code
false;public;0;20;;@Override public CamelContext createCamelContext() throws Exception {     SimpleRegistry registry = new SimpleRegistry().     registry.put("testStrategy", new ListAggregationStrategy()).     // the only thing special about this MockConnectionFactor is it allows us to call returnBadSessionNTimes(int)     // which will cause the MockSession to throw an IllegalStateException <int> times before returning a valid one.     // This gives us the ability to test bad sessions     ConnectionFactory connectionFactory = new MockConnectionFactory(broker.getTcpConnectorUri()).     SjmsComponent sjmsComponent = new SjmsComponent().     sjmsComponent.setConnectionFactory(connectionFactory).     SjmsBatchComponent sjmsBatchComponent = new SjmsBatchComponent().     sjmsBatchComponent.setConnectionFactory(connectionFactory).     CamelContext context = new DefaultCamelContext(registry).     context.addComponent("sjms", sjmsComponent).     context.addComponent("sjms-batch", sjmsBatchComponent).     return context. }
false;public;0;8;;@Override public void configure() throws Exception {     from("direct:in").routeId("harness").startupOrder(20).split(body()).toF("sjms:queue:%s?transacted=true", queueName).to("mock:before").end(). }
false;public;0;4;;@Override public boolean isUseAdviceWith() {     return true. }
false;public;0;11;;public void configure() throws Exception {     int completionTimeout = 1000.     int completionSize = 200.     fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&consumerCount=%s&aggregationStrategy=#testStrategy", queueName, completionTimeout, completionSize, consumerCount).routeId("batchConsumer").startupOrder(10).autoStartup(false).split(body()).to("mock:split"). }
false;public;0;41;;@Test public void testConsumption() throws Exception {     final int messageCount = 10000.     final int consumerCount = 5.     final String queueName = getQueueName().     context.addRoutes(new TransactedSendHarness(queueName)).     context.addRoutes(new RouteBuilder() {          public void configure() throws Exception {             int completionTimeout = 1000.             int completionSize = 200.             fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&consumerCount=%s&aggregationStrategy=#testStrategy", queueName, completionTimeout, completionSize, consumerCount).routeId("batchConsumer").startupOrder(10).autoStartup(false).split(body()).to("mock:split").         }     }).     context.start().     MockEndpoint mockBefore = getMockEndpoint("mock:before").     mockBefore.setExpectedMessageCount(messageCount).     MockEndpoint mockSplit = getMockEndpoint("mock:split").     mockSplit.setExpectedMessageCount(messageCount).     LOG.info("Sending messages").     template.sendBody("direct:in", generateStrings(messageCount)).     LOG.info("Send complete").     StopWatch stopWatch = new StopWatch().     context.getRouteController().startRoute("batchConsumer").     assertMockEndpointsSatisfied().     long time = stopWatch.taken().     LOG.info("Processed {} messages in {} ms", messageCount, time).     LOG.info("Average throughput {} msg/s", (long) (messageCount / (time / 1000d))). }
false;public;0;6;;public void configure() throws Exception {     fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&aggregationStrategy=#testStrategy", queueName, completionTimeout, completionSize).routeId("batchConsumer").startupOrder(10).log(LoggingLevel.DEBUG, "${body.size}").to("mock:batches"). }
false;public;0;24;;@Test public void testConsumptionCompletionSize() throws Exception {     final int completionSize = 5.     // size-based only     final int completionTimeout = -1.     final String queueName = getQueueName().     context.addRoutes(new TransactedSendHarness(queueName)).     context.addRoutes(new RouteBuilder() {          public void configure() throws Exception {             fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&aggregationStrategy=#testStrategy", queueName, completionTimeout, completionSize).routeId("batchConsumer").startupOrder(10).log(LoggingLevel.DEBUG, "${body.size}").to("mock:batches").         }     }).     context.start().     int messageCount = 100.     MockEndpoint mockBatches = getMockEndpoint("mock:batches").     mockBatches.expectedMessageCount(messageCount / completionSize).     template.sendBody("direct:in", generateStrings(messageCount)).     mockBatches.assertIsSatisfied(). }
false;public;0;6;;public void configure() throws Exception {     fromF("sjms-batch:%s?completionTimeout=%s&completionPredicate=%s&aggregationStrategy=#testStrategy&eagerCheckCompletion=true", queueName, completionTimeout, completionPredicate).routeId("batchConsumer").startupOrder(10).log(LoggingLevel.DEBUG, "${body.size}").to("mock:batches"). }
false;public;0;26;;@Test public void testConsumptionCompletionPredicate() throws Exception {     final String completionPredicate = "${body} contains 'done'".     // predicate-based only     final int completionTimeout = -1.     final String queueName = getQueueName().     context.addRoutes(new TransactedSendHarness(queueName)).     context.addRoutes(new RouteBuilder() {          public void configure() throws Exception {             fromF("sjms-batch:%s?completionTimeout=%s&completionPredicate=%s&aggregationStrategy=#testStrategy&eagerCheckCompletion=true", queueName, completionTimeout, completionPredicate).routeId("batchConsumer").startupOrder(10).log(LoggingLevel.DEBUG, "${body.size}").to("mock:batches").         }     }).     context.start().     MockEndpoint mockBatches = getMockEndpoint("mock:batches").     mockBatches.expectedMessageCount(2).     template.sendBody("direct:in", generateStrings(50)).     template.sendBody("direct:in", "Message done").     template.sendBody("direct:in", generateStrings(50)).     template.sendBody("direct:in", "Message done").     mockBatches.assertIsSatisfied(). }
false;public;0;5;;public void configure() throws Exception {     fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&aggregationStrategy=#testStrategy", queueName, completionTimeout, completionSize).routeId("batchConsumer").startupOrder(10).to("mock:batches"). }
false;public;0;25;;@Test public void testConsumptionCompletionTimeout() throws Exception {     final int completionTimeout = 2000.     // timeout-based only     final int completionSize = -1.     final String queueName = getQueueName().     context.addRoutes(new TransactedSendHarness(queueName)).     context.addRoutes(new RouteBuilder() {          public void configure() throws Exception {             fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&aggregationStrategy=#testStrategy", queueName, completionTimeout, completionSize).routeId("batchConsumer").startupOrder(10).to("mock:batches").         }     }).     context.start().     int messageCount = 50.     assertTrue(messageCount < SjmsBatchEndpoint.DEFAULT_COMPLETION_SIZE).     MockEndpoint mockBatches = getMockEndpoint("mock:batches").     // everything batched together     mockBatches.expectedMessageCount(1).     template.sendBody("direct:in", generateStrings(messageCount)).     mockBatches.assertIsSatisfied().     assertFirstMessageBodyOfLength(mockBatches, messageCount). }
false;public;0;5;;public void configure() throws Exception {     fromF("sjms-batch:%s?completionInterval=%s&completionSize=%s&aggregationStrategy=#testStrategy", queueName, completionInterval, completionSize).routeId("batchConsumer").startupOrder(10).to("mock:batches"). }
false;public;0;26;;@Test public void testConsumptionCompletionInterval() throws Exception {     final int completionInterval = 2000.     // timeout-based only     final int completionSize = -1.     final String queueName = getQueueName().     context.addRoutes(new TransactedSendHarness(queueName)).     context.addRoutes(new RouteBuilder() {          public void configure() throws Exception {             fromF("sjms-batch:%s?completionInterval=%s&completionSize=%s&aggregationStrategy=#testStrategy", queueName, completionInterval, completionSize).routeId("batchConsumer").startupOrder(10).to("mock:batches").         }     }).     context.start().     int messageCount = 50.     assertTrue(messageCount < SjmsBatchEndpoint.DEFAULT_COMPLETION_SIZE).     MockEndpoint mockBatches = getMockEndpoint("mock:batches").     // everything ought to be batched together but the interval may trigger in between and we get 2 etc     mockBatches.expectedMinimumMessageCount(1).     template.sendBody("direct:in", generateStrings(messageCount)).     mockBatches.assertIsSatisfied(). }
false;public;0;5;;public void configure() throws Exception {     fromF("sjms-batch:%s?completionInterval=%s&completionSize=%s&sendEmptyMessageWhenIdle=true&aggregationStrategy=#testStrategy", queueName, completionInterval, completionSize).routeId("batchConsumer").startupOrder(10).to("mock:batches"). }
false;public;0;27;;@Test public void testConsumptionSendEmptyMessageWhenIdle() throws Exception {     final int completionInterval = 2000.     // timeout-based only     final int completionSize = -1.     final String queueName = getQueueName().     context.addRoutes(new TransactedSendHarness(queueName)).     context.addRoutes(new RouteBuilder() {          public void configure() throws Exception {             fromF("sjms-batch:%s?completionInterval=%s&completionSize=%s&sendEmptyMessageWhenIdle=true&aggregationStrategy=#testStrategy", queueName, completionInterval, completionSize).routeId("batchConsumer").startupOrder(10).to("mock:batches").         }     }).     context.start().     int messageCount = 50.     assertTrue(messageCount < SjmsBatchEndpoint.DEFAULT_COMPLETION_SIZE).     MockEndpoint mockBatches = getMockEndpoint("mock:batches").     // trigger a couple of empty messages     mockBatches.expectedMinimumMessageCount(3).     template.sendBody("direct:in", generateStrings(messageCount)).     mockBatches.assertIsSatisfied(). }
false;public;0;18;;public void configure() throws Exception {     from("direct:in").split().body().multicast().toF("sjms:%s", queueName + "A").toF("sjms:%s", queueName + "B").end().     fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&aggregationStrategy=#testStrategy", queueName + "A", completionTimeout, completionSize).routeId("batchConsumerA").to("mock:outA").     fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&aggregationStrategy=#testStrategy", queueName + "B", completionTimeout, completionSize).routeId("batchConsumerB").to("mock:outB"). }
true;public;0;42;/**  * Checks whether multiple consumer endpoints can operate in parallel.  */ ;/**  * Checks whether multiple consumer endpoints can operate in parallel.  */ @Test public void testConsumptionMultipleConsumerEndpoints() throws Exception {     final int completionTimeout = 2000.     final int completionSize = 5.     final String queueName = getQueueName().     context.addRoutes(new RouteBuilder() {          public void configure() throws Exception {             from("direct:in").split().body().multicast().toF("sjms:%s", queueName + "A").toF("sjms:%s", queueName + "B").end().             fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&aggregationStrategy=#testStrategy", queueName + "A", completionTimeout, completionSize).routeId("batchConsumerA").to("mock:outA").             fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&aggregationStrategy=#testStrategy", queueName + "B", completionTimeout, completionSize).routeId("batchConsumerB").to("mock:outB").         }     }).     context.start().     int messageCount = 5.     assertTrue(messageCount < SjmsBatchEndpoint.DEFAULT_COMPLETION_SIZE).     MockEndpoint mockOutA = getMockEndpoint("mock:outA").     // everything batched together     mockOutA.expectedMessageCount(1).     MockEndpoint mockOutB = getMockEndpoint("mock:outB").     // everything batched together     mockOutB.expectedMessageCount(1).     template.sendBody("direct:in", generateStrings(messageCount)).     assertMockEndpointsSatisfied().     assertFirstMessageBodyOfLength(mockOutA, messageCount).     assertFirstMessageBodyOfLength(mockOutB, messageCount). }
false;public;0;5;;public void configure() throws Exception {     fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&aggregationStrategy=#testStrategy", queueName, completionTimeout, completionSize).routeId("batchConsumer").startupOrder(10).to("mock:batches"). }
false;public;1;4;;@Override public void process(Exchange exchange) throws Exception {     throw new RuntimeException("Boom!"). }
false;public;0;32;;@Test public void testConsumptionRollback() throws Exception {     final int completionTimeout = 2000.     final int completionSize = 5.     final String queueName = getQueueName().     context.addRoutes(new TransactedSendHarness(queueName)).     context.addRoutes(new RouteBuilder() {          public void configure() throws Exception {             fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&aggregationStrategy=#testStrategy", queueName, completionTimeout, completionSize).routeId("batchConsumer").startupOrder(10).to("mock:batches").         }     }).     context.start().     int messageCount = 5.     MockEndpoint mockBatches = getMockEndpoint("mock:batches").     // the first time around, the batch should throw an exception     mockBatches.whenExchangeReceived(1, new Processor() {          @Override         public void process(Exchange exchange) throws Exception {             throw new RuntimeException("Boom!").         }     }).     // so the batch should be processed twice due to redelivery     mockBatches.expectedMessageCount(2).     template.sendBody("direct:in", generateStrings(messageCount)).     mockBatches.assertIsSatisfied(). }
false;public;0;12;;public void configure() throws Exception {     int completionTimeout = 1000.     int completionSize = 200.     // keepAliveDelay=300 is the key... it's a 300 millis delay between attempts to create a new session.     fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&consumerCount=%s&aggregationStrategy=#testStrategy&keepAliveDelay=300", queueName, completionTimeout, completionSize, consumerCount).routeId("batchConsumer").startupOrder(10).autoStartup(false).split(body()).to("mock:split"). }
false;public;0;44;;@Test public void testConsumptionBadSession() throws Exception {     final int messageCount = 5.     final int consumerCount = 1.     SjmsBatchComponent sb = (SjmsBatchComponent) context.getComponent("sjms-batch").     MockConnectionFactory cf = (MockConnectionFactory) sb.getConnectionFactory().     cf.returnBadSessionNTimes(2).     final String queueName = getQueueName().     context.addRoutes(new TransactedSendHarness(queueName)).     context.addRoutes(new RouteBuilder() {          public void configure() throws Exception {             int completionTimeout = 1000.             int completionSize = 200.             // keepAliveDelay=300 is the key... it's a 300 millis delay between attempts to create a new session.             fromF("sjms-batch:%s?completionTimeout=%s&completionSize=%s&consumerCount=%s&aggregationStrategy=#testStrategy&keepAliveDelay=300", queueName, completionTimeout, completionSize, consumerCount).routeId("batchConsumer").startupOrder(10).autoStartup(false).split(body()).to("mock:split").         }     }).     context.start().     MockEndpoint mockBefore = getMockEndpoint("mock:before").     mockBefore.setExpectedMessageCount(messageCount).     MockEndpoint mockSplit = getMockEndpoint("mock:split").     mockSplit.setExpectedMessageCount(messageCount).     LOG.info("Sending messages").     template.sendBody("direct:in", generateStrings(messageCount)).     LOG.info("Send complete").     StopWatch stopWatch = new StopWatch().     context.getRouteController().startRoute("batchConsumer").     assertMockEndpointsSatisfied().     stopWatch.taken(). }
false;private;2;4;;private void assertFirstMessageBodyOfLength(MockEndpoint mockEndpoint, int expectedLength) {     Exchange exchange = mockEndpoint.getExchanges().get(0).     assertEquals(expectedLength, exchange.getIn().getBody(List.class).size()). }
false;private;0;4;;private String getQueueName() {     SimpleDateFormat sdf = new SimpleDateFormat("yyMMddhhmmss").     return "sjms-batch-" + sdf.format(new Date()). }
false;private;1;7;;private String[] generateStrings(int messageCount) {     String[] strings = new String[messageCount].     for (int i = 0. i < messageCount. i++) {         strings[i] = "message:" + i.     }     return strings. }
