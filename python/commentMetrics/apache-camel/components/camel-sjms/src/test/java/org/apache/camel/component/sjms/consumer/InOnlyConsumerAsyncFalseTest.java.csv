commented;modifiers;parameterAmount;loc;comment;code
false;public;0;16;;@Test public void testInOnlyConsumerAsyncTrue() throws Exception {     getMockEndpoint(MOCK_RESULT).expectedBodiesReceived("Hello Camel", "Hello World").     template.sendBody(SJMS_QUEUE_NAME, "Hello Camel").     template.sendBody(SJMS_QUEUE_NAME, "Hello World").     // Hello World is received first despite its send last     // the reason is that the first message is processed asynchronously     // and it takes 2 sec to complete, so in between we have time to     // process the 2nd message on the queue     Thread.sleep(3000).     assertMockEndpointsSatisfied().     assertTrue(beforeThreadName.equals(afterThreadName)). }
false;public;1;3;;public void process(Exchange exchange) throws Exception {     afterThreadName = Thread.currentThread().getName(). }
false;public;1;6;;public void process(Exchange exchange) throws Exception {     beforeThreadName = Thread.currentThread().getName().     if (exchange.getIn().getBody(String.class).equals("Hello Camel")) {         Thread.sleep(2000).     } }
false;public;0;15;;@Override public void configure() throws Exception {     from(SJMS_QUEUE_NAME).to("log:before").process(new Processor() {          public void process(Exchange exchange) throws Exception {             beforeThreadName = Thread.currentThread().getName().             if (exchange.getIn().getBody(String.class).equals("Hello Camel")) {                 Thread.sleep(2000).             }         }     }).process(new Processor() {          public void process(Exchange exchange) throws Exception {             afterThreadName = Thread.currentThread().getName().         }     }).to("log:after").to(MOCK_RESULT). }
false;protected;0;20;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             from(SJMS_QUEUE_NAME).to("log:before").process(new Processor() {                  public void process(Exchange exchange) throws Exception {                     beforeThreadName = Thread.currentThread().getName().                     if (exchange.getIn().getBody(String.class).equals("Hello Camel")) {                         Thread.sleep(2000).                     }                 }             }).process(new Processor() {                  public void process(Exchange exchange) throws Exception {                     afterThreadName = Thread.currentThread().getName().                 }             }).to("log:after").to(MOCK_RESULT).         }     }. }
