commented;modifiers;parameterAmount;loc;comment;code
false;public,abstract;0;1;;public abstract String getBrokerUri().
false;protected;4;38;;protected void runTest(String destinationName, int consumerRouteCount, int messageCount, int totalAttempts) throws Exception {     // The CountDownLatch is used to make our final assertions await     // unit all the messages have been processed. It is also     // set to time out on the await. Our values are multiplied     // by the number of routes we have.     CountDownLatch latch = new CountDownLatch(totalAttempts + (messageCount * consumerRouteCount)).     addRoute(destinationName, consumerRouteCount, latch).     // We should see the BatchMessage once in the prebatch and once in the     // redelivery. Then we should see 30 messages arrive in the postbatch.     getMockEndpoint("mock:test.producer").expectedMessageCount(totalAttempts).     for (int i = 1. i <= consumerRouteCount. i++) {         getMockEndpoint("mock:test.consumer." + i).expectedMessageCount(messageCount).     }     List<BatchMessage<String>> messages = new ArrayList<>().     for (int i = 1. i <= messageCount. i++) {         String body = "Hello World " + i.         BatchMessage<String> message = new BatchMessage<>(body, null).         messages.add(message).     }     // First we send the batch to capture the failure.     try {         log.info("Send Messages").         template.sendBody("direct:start", messages).     } catch (Exception e) {         log.info("Send Again").         template.sendBody("direct:start", messages).     }     // Await on our countdown for 10 seconds at most     // then move on     latch.await(10, TimeUnit.SECONDS).     assertMockEndpointsSatisfied(10, TimeUnit.SECONDS). }
false;protected;0;11;;@Override protected CamelContext createCamelContext() throws Exception {     CamelContext camelContext = super.createCamelContext().     ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(getBrokerUri()).     SjmsComponent component = new SjmsComponent().     component.setConnectionFactory(connectionFactory).     camelContext.addComponent("sjms", component).     return camelContext. }
false;public;1;12;;@Override public void process(Exchange exchange) throws Exception {     // Otherwise allow it to proceed.     if (counter.getAndIncrement() == 0) {         log.info("BatchMessage received without redelivery. Rolling back.").         exchange.setException(new Exception()).     }     // Countdown the latch     latch.countDown(). }
false;public;1;6;;@Override public void process(Exchange exchange) throws Exception {     // Countdown the latch     latch.countDown(). }
false;public;0;40;;@Override public void configure() {     from("direct:start").id("producer.route").log("Producer Route Body: ${body}").to("mock:test.producer").to(destinationName + "?transacted=true").process(new Processor() {          private final AtomicInteger counter = new AtomicInteger(0).          @Override         public void process(Exchange exchange) throws Exception {             // Otherwise allow it to proceed.             if (counter.getAndIncrement() == 0) {                 log.info("BatchMessage received without redelivery. Rolling back.").                 exchange.setException(new Exception()).             }             // Countdown the latch             latch.countDown().         }     }).     for (int i = 1. i <= consumerRouteCount. i++) {         from(destinationName).id("consumer.route." + i).log("Consumer Route " + i + " Body: ${body}").to("mock:test.consumer." + i).process(new Processor() {              @Override             public void process(Exchange exchange) throws Exception {                 // Countdown the latch                 latch.countDown().             }         }).     } }
false;protected;3;44;;protected void addRoute(final String destinationName, final int consumerRouteCount, final CountDownLatch latch) throws Exception {     context.addRoutes(new RouteBuilder() {          @Override         public void configure() {             from("direct:start").id("producer.route").log("Producer Route Body: ${body}").to("mock:test.producer").to(destinationName + "?transacted=true").process(new Processor() {                  private final AtomicInteger counter = new AtomicInteger(0).                  @Override                 public void process(Exchange exchange) throws Exception {                     // Otherwise allow it to proceed.                     if (counter.getAndIncrement() == 0) {                         log.info("BatchMessage received without redelivery. Rolling back.").                         exchange.setException(new Exception()).                     }                     // Countdown the latch                     latch.countDown().                 }             }).             for (int i = 1. i <= consumerRouteCount. i++) {                 from(destinationName).id("consumer.route." + i).log("Consumer Route " + i + " Body: ${body}").to("mock:test.consumer." + i).process(new Processor() {                      @Override                     public void process(Exchange exchange) throws Exception {                         // Countdown the latch                         latch.countDown().                     }                 }).             }         }     }). }
