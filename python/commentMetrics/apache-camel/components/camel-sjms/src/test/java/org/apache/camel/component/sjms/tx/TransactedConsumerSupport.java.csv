commented;modifiers;parameterAmount;loc;comment;code
false;public,abstract;0;1;;public abstract String getBrokerUri().
false;protected;8;31;;protected void runTest(String destinationName, int routeCount, int messageCount, int totalRedeliverdFalse, int totalRedeliveredTrue, int batchCount, int consumerCount, int maxAttemptsCount) throws Exception {     // The CountDownLatch is used to make our final assertions await     // unit all the messages have been processed. It is also     // set to time out on the await. Our values are multiplied     // by the number of routes we have.     CountDownLatch latch = new CountDownLatch((totalRedeliverdFalse * routeCount) + (totalRedeliveredTrue * routeCount)).     for (int i = 1. i <= routeCount. i++) {         // We add a route here so we can pass our latch into it.         addRoute(destinationName, i, batchCount, consumerCount, maxAttemptsCount, latch).         // Create mock endpoints for the before and after         getMockEndpoint("mock:test.before." + i).expectedMessageCount(totalRedeliverdFalse).         getMockEndpoint("mock:test.after." + i).expectedMessageCount(totalRedeliveredTrue).     }     // We should never see a message here or something is     // wrong with the JMS provider.     getMockEndpoint("mock:test.after").expectedMessageCount(0).     // Send only 10 messages     for (int i = 1. i <= messageCount. i++) {         String message = "Hello World " + i.         template.sendBody("direct:start", message).         log.trace("Sending message: {}", message).     }     // Await on our countdown for 30 seconds at most then move on     latch.await(30, TimeUnit.SECONDS).     assertMockEndpointsSatisfied(30, TimeUnit.SECONDS). }
false;protected;0;17;;@Override protected CamelContext createCamelContext() throws Exception {     CamelContext camelContext = super.createCamelContext().     ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(getBrokerUri()).     // use low redelivery delay to speed     connectionFactory.getRedeliveryPolicy().setInitialRedeliveryDelay(100).     connectionFactory.getRedeliveryPolicy().setRedeliveryDelay(100).     connectionFactory.getRedeliveryPolicy().setUseCollisionAvoidance(false).     connectionFactory.getRedeliveryPolicy().setUseExponentialBackOff(false).     SjmsComponent component = new SjmsComponent().     component.setConnectionFactory(connectionFactory).     camelContext.addComponent("sjms", component).     return camelContext. }
false;public;1;6;;@Override public void process(Exchange exchange) throws Exception {     // Countdown the latch     latch.countDown(). }
false;public;1;10;;@Override public void process(Exchange exchange) throws Exception {     if (counter.incrementAndGet() == maxAttemptsCount) {         log.info("{} Messages have been processed. Failing the exchange to force a rollback of the transaction.", maxAttemptsCount).         exchange.getOut().setFault(true).     }     // Countdown the latch     latch.countDown(). }
false;public;0;46;;@Override public void configure() {     if (context.getRoute("direct.route") == null) {         from("direct:start").id("direct.route").to(destinationName).     }     // Our test consumer route     from(destinationName + "?transacted=true&transactionBatchCount=" + batchCount + "&consumerCount=" + consumerCount).id("consumer.route." + routeNumber).choice().when(header("JMSRedelivered").isEqualTo("false")).log("Route " + routeNumber + " 1st attempt Body: ${body} | Redeliverd: ${header.JMSRedelivered}").to("mock:test.before." + routeNumber).process(new Processor() {          private final AtomicInteger counter = new AtomicInteger(0).          @Override         public void process(Exchange exchange) throws Exception {             if (counter.incrementAndGet() == maxAttemptsCount) {                 log.info("{} Messages have been processed. Failing the exchange to force a rollback of the transaction.", maxAttemptsCount).                 exchange.getOut().setFault(true).             }             // Countdown the latch             latch.countDown().         }     }).when(header("JMSRedelivered").isEqualTo("true")).log("Route " + routeNumber + " 2nd attempt Body: ${body} | Redeliverd: ${header.JMSRedelivered}").to("mock:test.after." + routeNumber).process(new Processor() {          @Override         public void process(Exchange exchange) throws Exception {             // Countdown the latch             latch.countDown().         }     }).otherwise().to("mock:test.after"). }
false;protected;6;51;;protected void addRoute(final String destinationName, final int routeNumber, final int batchCount, final int consumerCount, final int maxAttemptsCount, final CountDownLatch latch) throws Exception {     context.addRoutes(new RouteBuilder() {          @Override         public void configure() {             if (context.getRoute("direct.route") == null) {                 from("direct:start").id("direct.route").to(destinationName).             }             // Our test consumer route             from(destinationName + "?transacted=true&transactionBatchCount=" + batchCount + "&consumerCount=" + consumerCount).id("consumer.route." + routeNumber).choice().when(header("JMSRedelivered").isEqualTo("false")).log("Route " + routeNumber + " 1st attempt Body: ${body} | Redeliverd: ${header.JMSRedelivered}").to("mock:test.before." + routeNumber).process(new Processor() {                  private final AtomicInteger counter = new AtomicInteger(0).                  @Override                 public void process(Exchange exchange) throws Exception {                     if (counter.incrementAndGet() == maxAttemptsCount) {                         log.info("{} Messages have been processed. Failing the exchange to force a rollback of the transaction.", maxAttemptsCount).                         exchange.getOut().setFault(true).                     }                     // Countdown the latch                     latch.countDown().                 }             }).when(header("JMSRedelivered").isEqualTo("true")).log("Route " + routeNumber + " 2nd attempt Body: ${body} | Redeliverd: ${header.JMSRedelivered}").to("mock:test.after." + routeNumber).process(new Processor() {                  @Override                 public void process(Exchange exchange) throws Exception {                     // Countdown the latch                     latch.countDown().                 }             }).otherwise().to("mock:test.after").         }     }). }
