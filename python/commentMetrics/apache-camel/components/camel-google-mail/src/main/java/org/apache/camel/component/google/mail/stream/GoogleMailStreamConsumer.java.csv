commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;3;;protected GoogleMailStreamConfiguration getConfiguration() {     return getEndpoint().getConfiguration(). }
false;protected;0;3;;protected Gmail getClient() {     return getEndpoint().getClient(). }
false;public;0;4;;@Override public GoogleMailStreamEndpoint getEndpoint() {     return (GoogleMailStreamEndpoint) super.getEndpoint(). }
false;protected;0;26;;@Override protected int poll() throws Exception {     com.google.api.services.gmail.Gmail.Users.Messages.List request = getClient().users().messages().list("me").     if (ObjectHelper.isNotEmpty(getConfiguration().getQuery())) {         request.setQ(getConfiguration().getQuery()).     }     if (ObjectHelper.isNotEmpty(getConfiguration().getMaxResults())) {         request.setMaxResults(getConfiguration().getMaxResults()).     }     if (ObjectHelper.isNotEmpty(labelsIds)) {         request.setLabelIds(labelsIds).     }     Queue<Exchange> answer = new LinkedList<>().     ListMessagesResponse c = request.execute().     if (c.getMessages() != null) {         for (Message message : c.getMessages()) {             Message mess = getClient().users().messages().get("me", message.getId()).setFormat("FULL").execute().             Exchange exchange = getEndpoint().createExchange(getEndpoint().getExchangePattern(), mess).             answer.add(exchange).         }     }     return processBatch(CastUtils.cast(answer)). }
false;public;1;3;;public void onComplete(Exchange exchange) {     processCommit(exchange, unreadLabelId). }
false;public;1;3;;public void onFailure(Exchange exchange) {     processRollback(exchange, unreadLabelId). }
false;public;0;4;;@Override public String toString() {     return "GoogleMailStreamConsumerOnCompletion". }
false;public;1;4;;@Override public void done(boolean doneSync) {     LOG.trace("Processing exchange done"). }
false;public;1;41;;@Override public int processBatch(Queue<Object> exchanges) throws Exception {     int total = exchanges.size().     for (int index = 0. index < total && isBatchAllowed(). index++) {         // only loop if we are started (allowed to run)         final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll()).         // add current index and total as properties         exchange.setProperty(Exchange.BATCH_INDEX, index).         exchange.setProperty(Exchange.BATCH_SIZE, total).         exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1).         // update pending number of exchanges         pendingExchanges = total - index - 1.         // add on completion to handle after work when the exchange is done         exchange.addOnCompletion(new Synchronization() {              public void onComplete(Exchange exchange) {                 processCommit(exchange, unreadLabelId).             }              public void onFailure(Exchange exchange) {                 processRollback(exchange, unreadLabelId).             }              @Override             public String toString() {                 return "GoogleMailStreamConsumerOnCompletion".             }         }).         getAsyncProcessor().process(exchange, new AsyncCallback() {              @Override             public void done(boolean doneSync) {                 LOG.trace("Processing exchange done").             }         }).     }     return total. }
true;protected;2;19;/**  * Strategy to delete the message after being processed.  *  * @param exchange the exchange  * @throws IOException  */ ;/**  * Strategy to delete the message after being processed.  *  * @param exchange the exchange  * @throws IOException  */ protected void processCommit(Exchange exchange, String unreadLabelId) {     try {         if (getConfiguration().isMarkAsRead()) {             String id = exchange.getIn().getHeader(GoogleMailStreamConstants.MAIL_ID, String.class).             LOG.trace("Marking email {} as read", id).             List<String> remove = new ArrayList<>().             remove.add(unreadLabelId).             ModifyMessageRequest mods = new ModifyMessageRequest().setRemoveLabelIds(remove).             getClient().users().messages().modify("me", exchange.getIn().getHeader(GoogleMailStreamConstants.MAIL_ID, String.class), mods).execute().             LOG.trace("Marked email {} as read", id).         }     } catch (Exception e) {         getExceptionHandler().handleException("Error occurred mark as read mail. This exception is ignored.", exchange, e).     } }
true;protected;2;12;/**  * Strategy when processing the exchange failed.  *  * @param exchange the exchange  * @throws IOException  */ ;/**  * Strategy when processing the exchange failed.  *  * @param exchange the exchange  * @throws IOException  */ protected void processRollback(Exchange exchange, String unreadLabelId) {     try {         LOG.warn("Exchange failed, so rolling back mail {} to un {}", exchange).         List<String> add = new ArrayList<>().         add.add(unreadLabelId).         ModifyMessageRequest mods = new ModifyMessageRequest().setAddLabelIds(add).         getClient().users().messages().modify("me", exchange.getIn().getHeader(GoogleMailStreamConstants.MAIL_ID, String.class), mods).execute().     } catch (Exception e) {         getExceptionHandler().handleException("Error occurred mark as read mail. This exception is ignored.", exchange, e).     } }
