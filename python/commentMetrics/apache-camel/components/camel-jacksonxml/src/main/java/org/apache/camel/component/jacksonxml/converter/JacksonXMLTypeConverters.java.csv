commented;modifiers;parameterAmount;loc;comment;code
false;public;4;30;;@FallbackConverter public <T> T convertTo(Class<T> type, Exchange exchange, Object value, TypeConverterRegistry registry) {     // only do this if enabled     if (!init && exchange != null) {         // init to see if this is enabled         String text = exchange.getContext().getGlobalOptions().get(JacksonXMLConstants.ENABLE_XML_TYPE_CONVERTER).         enabled = "true".equalsIgnoreCase(text).         init = true.     }     if (enabled == null || !enabled) {         return null.     }     if (isNotPojoType(type)) {         return null.     }     if (exchange != null && value instanceof Map) {         ObjectMapper mapper = resolveObjectMapper(exchange.getContext().getRegistry()).         if (mapper.canSerialize(type)) {             return mapper.convertValue(value, type).         }     }     // Just return null to let other fallback converter to do the job     return null. }
false;private,static;1;8;;private static boolean isNotPojoType(Class<?> type) {     boolean isString = String.class.isAssignableFrom(type).     boolean isNumber = Number.class.isAssignableFrom(type) || int.class.isAssignableFrom(type) || long.class.isAssignableFrom(type) || short.class.isAssignableFrom(type) || char.class.isAssignableFrom(type) || float.class.isAssignableFrom(type) || double.class.isAssignableFrom(type).     return isString || isNumber. }
false;private;1;7;;private ObjectMapper resolveObjectMapper(Registry registry) {     Set<XmlMapper> mappers = registry.findByType(XmlMapper.class).     if (mappers.size() == 1) {         return mappers.iterator().next().     }     return defaultMapper. }
