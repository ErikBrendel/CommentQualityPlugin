commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;3;;public static BundleContext getBundleContext() {     return context. }
false;public;1;8;;public void start(BundleContext context) throws Exception {     Activator.context = context.     LOG.info("Camel-Script activator starting").     tracker = new BundleTracker(context, Bundle.ACTIVE, this).     tracker.open().     context.addServiceListener(this, "(&(resolver=default)(objectClass=org.apache.camel.spi.LanguageResolver))").     LOG.info("Camel-Script activator started"). }
false;public;1;10;;public void stop(BundleContext context) throws Exception {     LOG.info("Camel-Script activator stopping").     tracker.close().     context.removeServiceListener(this).     if (registration != null) {         registration.unregister().     }     LOG.info("Camel-Script activator stopped").     Activator.context = null. }
false;public;2;13;;public Object addingBundle(Bundle bundle, BundleEvent event) {     List<BundleScriptEngineResolver> r = new ArrayList<>().     registerScriptEngines(bundle, r).     for (BundleScriptEngineResolver service : r) {         service.register().     }     resolvers.put(bundle.getBundleId(), r).     // Only update the script language engine when the resolver is changed     if (r.size() > 0) {         updateAvailableScriptLanguages().     }     return bundle. }
false;public;3;2;;public void modifiedBundle(Bundle bundle, BundleEvent event, Object object) { }
false;public;3;10;;public void removedBundle(Bundle bundle, BundleEvent event, Object object) {     LOG.debug("Bundle stopped: {}", bundle.getSymbolicName()).     List<BundleScriptEngineResolver> r = resolvers.remove(bundle.getBundleId()).     if (r != null) {         updateAvailableScriptLanguages().         for (BundleScriptEngineResolver service : r) {             service.unregister().         }     } }
false;private;0;10;;private String[] getAvailableScriptNames() {     // use a set to avoid duplicate names     Set<String> names = new TreeSet<>(String.CASE_INSENSITIVE_ORDER).     for (List<BundleScriptEngineResolver> list : resolvers.values()) {         for (BundleScriptEngineResolver r : list) {             names.addAll(r.getScriptNames()).         }     }     return names.toArray(new String[] {}). }
false;private;0;25;;private void updateAvailableScriptLanguages() {     ServiceReference<LanguageResolver> ref = null.     try {         Collection<ServiceReference<LanguageResolver>> references = context.getServiceReferences(LanguageResolver.class, "(resolver=default)").         if (references.size() == 1) {             // Unregistry the old language resolver first             if (registration != null) {                 registration.unregister().                 registration = null.             }             ref = references.iterator().next().             LanguageResolver resolver = context.getService(ref).             Dictionary props = new Hashtable().             // Just publish the language resolve with the language we found             props.put("language", getAvailableScriptNames()).             registration = context.registerService(LanguageResolver.class, resolver, props).         }     } catch (InvalidSyntaxException e) {         LOG.error("Invalid syntax for LanguageResolver service reference filter.").     } finally {         if (ref != null) {             context.ungetService(ref).         }     } }
false;public,static;1;20;;public static ScriptEngine resolveScriptEngine(String scriptEngineName) throws InvalidSyntaxException {     ServiceReference<?>[] refs = context.getServiceReferences(ScriptEngineResolver.class.getName(), null).     if (refs == null) {         LOG.info("No OSGi script engine resolvers available!").         return null.     }     LOG.debug("Found {} OSGi ScriptEngineResolver services", refs.length).     for (ServiceReference<?> ref : refs) {         ScriptEngineResolver resolver = (ScriptEngineResolver) context.getService(ref).         ScriptEngine engine = resolver.resolveScriptEngine(scriptEngineName).         context.ungetService(ref).         LOG.debug("OSGi resolver " + resolver + " produced " + scriptEngineName + " engine " + engine).         if (engine != null) {             return engine.         }     }     return null. }
false;protected;2;11;;protected void registerScriptEngines(Bundle bundle, List<BundleScriptEngineResolver> resolvers) {     try {         for (Enumeration<?> e = bundle.adapt(BundleWiring.class).getClassLoader().getResources(META_INF_SERVICES_DIR + "/" + SCRIPT_ENGINE_SERVICE_FILE). e != null && e.hasMoreElements(). ) {             URL configURL = (URL) e.nextElement().             LOG.info("Found ScriptEngineFactory in bundle: {}", bundle.getSymbolicName()).             resolvers.add(new BundleScriptEngineResolver(bundle, configURL)).         }     } catch (IOException e) {         LOG.info("Error loading script engine factory", e).     } }
false;public;1;4;;@Override public void serviceChanged(ServiceEvent event) {     updateAvailableScriptLanguages(). }
false;;1;1;;ScriptEngine resolveScriptEngine(String name).
false;public;0;3;;public void register() {     reg = bundle.getBundleContext().registerService(ScriptEngineResolver.class.getName(), this, null). }
false;public;0;3;;public void unregister() {     reg.unregister(). }
false;private;0;3;;private List<String> getScriptNames() {     return getScriptNames(getFactory()). }
false;private;1;11;;@SuppressWarnings("unchecked") private List<String> getScriptNames(ScriptEngineFactory factory) {     List<String> names.     if (factory != null) {         names = factory.getNames().     } else {         // return an empty script name list         names = Collections.EMPTY_LIST.     }     return names. }
false;private;0;27;;private ScriptEngineFactory getFactory() {     try {         BufferedReader in = IOHelper.buffered(new InputStreamReader(configFile.openStream())).         String className.         while ((className = in.readLine()) != null) {             if ("".equals(className.trim()) || className.trim().startsWith("#")) {                 continue.             } else if (className.contains("#")) {                 className = className.substring(0, className.indexOf('#')).trim().                 break.             } else {                 className = className.trim().                 break.             }         }         in.close().         Class<?> cls = bundle.loadClass(className).         // OSGi classloading trouble (with jruby)         if (!ScriptEngineFactory.class.isAssignableFrom(cls)) {             return null.         }         return (ScriptEngineFactory) cls.newInstance().     } catch (Exception e) {         LOG.warn("Cannot create the ScriptEngineFactory: {}", e.getClass().getName(), e).         return null.     } }
false;public;1;30;;public ScriptEngine resolveScriptEngine(String name) {     try {         ScriptEngineFactory factory = getFactory().         if (factory != null) {             List<String> names = getScriptNames(factory).             for (String test : names) {                 if (test.equals(name)) {                     ClassLoader old = Thread.currentThread().getContextClassLoader().                     ScriptEngine engine.                     try {                         // JRuby seems to require the correct TCCL to call getScriptEngine                         Thread.currentThread().setContextClassLoader(factory.getClass().getClassLoader()).                         engine = factory.getScriptEngine().                     } finally {                         Thread.currentThread().setContextClassLoader(old).                     }                     LOG.trace("Resolved ScriptEngineFactory: {} for expected name: {}", engine, name).                     return engine.                 }             }             LOG.debug("ScriptEngineFactory: {} does not match expected name: {}", factory.getEngineName(), name).             return null.         }     } catch (Exception e) {         LOG.warn("Cannot create ScriptEngineFactory: {}", e.getClass().getName(), e).         return null.     }     return null. }
false;public;0;4;;@Override public String toString() {     return "OSGi script engine resolver for " + bundle.getSymbolicName(). }
