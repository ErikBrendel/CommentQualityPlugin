commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return getScriptDescription(). }
false;public;1;3;;public Object evaluate(Exchange exchange) {     return evaluateScript(exchange). }
false;public;2;4;;public <T> T evaluate(Exchange exchange, Class<T> type) {     Object result = evaluate(exchange).     return exchange.getContext().getTypeConverter().convertTo(type, result). }
false;public;1;4;;public boolean matches(Exchange exchange) {     Object scriptValue = evaluateScript(exchange).     return matches(exchange, scriptValue). }
false;public;2;6;;public void assertMatches(String text, Exchange exchange) throws AssertionError {     Object scriptValue = evaluateScript(exchange).     if (!matches(exchange, scriptValue)) {         throw new AssertionError(this + " failed on " + exchange + " as script returned <" + scriptValue + ">").     } }
false;public;1;3;;public void process(Exchange exchange) {     evaluateScript(exchange). }
true;public;2;7;/**  * Sets the attribute on the context so that it is available to the script  * as a variable in the {@link ScriptContext#ENGINE_SCOPE}  *  * @param name the name of the attribute  * @param value the attribute value  * @return this builder  */ ;// Builder API // ------------------------------------------------------------------------- /**  * Sets the attribute on the context so that it is available to the script  * as a variable in the {@link ScriptContext#ENGINE_SCOPE}  *  * @param name the name of the attribute  * @param value the attribute value  * @return this builder  */ public ScriptBuilder attribute(String name, Object value) {     if (attributes == null) {         attributes = new HashMap<>().     }     attributes.put(name, value).     return this. }
true;public,static;2;3;/**  * Creates a script builder for the named language and script contents  *  * @param language the language to use for the script  * @param scriptText the script text to be evaluated, or a reference to a script resource  * @return the builder  */ ;/**  * Creates a script builder for the named language and script contents  *  * @param language the language to use for the script  * @param scriptText the script text to be evaluated, or a reference to a script resource  * @return the builder  */ public static ScriptBuilder script(String language, String scriptText) {     return new ScriptBuilder(language, scriptText). }
true;public,static;1;3;/**  * Creates a script builder for the groovy script contents  *  * @param scriptText the script text to be evaluated, or a reference to a script resource  * @return the builder  */ ;/**  * Creates a script builder for the groovy script contents  *  * @param scriptText the script text to be evaluated, or a reference to a script resource  * @return the builder  */ public static ScriptBuilder groovy(String scriptText) {     return new ScriptBuilder("groovy", scriptText). }
true;public,static;1;3;/**  * Creates a script builder for the JavaScript/ECMAScript script contents  *  * @param scriptText the script text to be evaluated, or a reference to a script resource  * @return the builder  */ ;/**  * Creates a script builder for the JavaScript/ECMAScript script contents  *  * @param scriptText the script text to be evaluated, or a reference to a script resource  * @return the builder  */ public static ScriptBuilder javaScript(String scriptText) {     return new ScriptBuilder("js", scriptText). }
true;public,static;1;3;/**  * Creates a script builder for the PHP script contents  *  * @param scriptText the script text to be evaluated, or a reference to a script resource  * @return the builder  */ ;/**  * Creates a script builder for the PHP script contents  *  * @param scriptText the script text to be evaluated, or a reference to a script resource  * @return the builder  */ public static ScriptBuilder php(String scriptText) {     return new ScriptBuilder("php", scriptText). }
true;public,static;1;3;/**  * Creates a script builder for the Python script contents  *  * @param scriptText the script text to be evaluated, or a reference to a script resource  * @return the builder  */ ;/**  * Creates a script builder for the Python script contents  *  * @param scriptText the script text to be evaluated, or a reference to a script resource  * @return the builder  */ public static ScriptBuilder python(String scriptText) {     return new ScriptBuilder("python", scriptText). }
true;public,static;1;3;/**  * Creates a script builder for the Ruby/JRuby script contents  *  * @param scriptText the script text to be evaluated, or a reference to a script resource  * @return the builder  */ ;/**  * Creates a script builder for the Ruby/JRuby script contents  *  * @param scriptText the script text to be evaluated, or a reference to a script resource  * @return the builder  */ public static ScriptBuilder ruby(String scriptText) {     return new ScriptBuilder("jruby", scriptText). }
true;public,static;1;3;/**  * Whether the given language is a language that is supported by a scripting engine.  */ ;/**  * Whether the given language is a language that is supported by a scripting engine.  */ public static boolean supportScriptLanguage(String language) {     return createScriptEngine(language, true) != null. }
false;public;0;3;;// Properties // ------------------------------------------------------------------------- public CompiledScript getCompiledScript() {     return compiledScript. }
false;public;0;3;;public String getScriptLanguage() {     return scriptLanguage. }
true;public;0;9;/**  * Returns a description of the script  *  * @return the script description  */ ;/**  * Returns a description of the script  *  * @return the script description  */ public String getScriptDescription() {     if (scriptText != null) {         return scriptLanguage + ": " + scriptText.     } else if (scriptResource != null) {         return scriptLanguage + ": " + scriptResource.     } else {         return scriptLanguage + ": null script".     } }
false;protected;2;3;;// Implementation methods // ------------------------------------------------------------------------- protected boolean matches(Exchange exchange, Object scriptValue) {     return exchange.getContext().getTypeConverter().convertTo(boolean.class, scriptValue). }
false;private,static;1;10;;private static String[] getScriptNames(String name) {     if (name.equals("js")) {         return new String[] { "js", "javaScript", "ECMAScript" }.     } else if (name.equals("javaScript")) {         return new String[] { "javaScript", "js", "ECMAScript" }.     } else if (name.equals("ECMAScript")) {         return new String[] { "ECMAScript", "javaScript", "js" }.     }     return new String[] { name }. }
false;protected,static;1;19;;protected static ScriptEngineFactory lookupScriptEngineFactory(String language) {     ScriptEngineManager manager = new ScriptEngineManager().     for (ScriptEngineFactory factory : manager.getEngineFactories()) {         // some script names has alias         String[] names = getScriptNames(language).         for (String name : names) {             if (factory.getLanguageName().equals(name)) {                 return factory.             }         }     }     // fallback to get engine by name     ScriptEngine engine = createScriptEngine(language, true).     if (engine != null) {         return engine.getFactory().     }     return null. }
false;protected,static;2;10;;protected static ScriptEngine createScriptEngine(String language, boolean allowNull) {     ScriptEngine engine = tryCreateScriptEngine(language, ScriptBuilder.class.getClassLoader()).     if (engine == null) {         engine = tryCreateScriptEngine(language, Thread.currentThread().getContextClassLoader()).     }     if (engine == null && !allowNull) {         throw new IllegalArgumentException("No script engine could be created for: " + language).     }     return engine. }
true;private,static;2;27;/**  * Attemps to create the script engine for the given langauge using the classloader  *  * @return the engine, or <tt>null</tt> if not able to create  */ ;/**  * Attemps to create the script engine for the given langauge using the classloader  *  * @return the engine, or <tt>null</tt> if not able to create  */ private static ScriptEngine tryCreateScriptEngine(String language, ClassLoader classLoader) {     ScriptEngineManager manager = new ScriptEngineManager(classLoader).     ScriptEngine engine = null.     // some script names has alias     String[] names = getScriptNames(language).     for (String name : names) {         try {             engine = manager.getEngineByName(name).             if (engine != null) {                 break.             }         } catch (NoClassDefFoundError ex) {             LOG.warn("Cannot load ScriptEngine for {}. Please ensure correct JARs is provided on classpath (stacktrace in DEBUG logging).", name).             // include stacktrace in debug logging             LOG.debug("Cannot load ScriptEngine for " + name + ". Please ensure correct JARs is provided on classpath.", ex).         }     }     if (engine == null) {         engine = checkForOSGiEngine(language).     }     if (engine != null && isPython(language)) {         ScriptContext context = engine.getContext().         context.setAttribute("com.sun.script.jython.comp.mode", "eval", ScriptContext.ENGINE_SCOPE).     }     return engine. }
false;private,static;1;17;;private static ScriptEngine checkForOSGiEngine(String language) {     LOG.debug("No script engine found for {} using standard javax.script auto-registration. Checking OSGi registry.", language).     try {         // Test the OSGi environment with the Activator         Class<?> c = Class.forName("org.apache.camel.script.osgi.Activator").         Method mth = c.getDeclaredMethod("getBundleContext").         Object ctx = mth.invoke(null).         LOG.debug("Found OSGi BundleContext: {}", ctx).         if (ctx != null) {             Method resolveScriptEngine = c.getDeclaredMethod("resolveScriptEngine", String.class).             return (ScriptEngine) resolveScriptEngine.invoke(null, language).         }     } catch (Throwable t) {         LOG.debug("Unable to detect OSGi. ScriptEngine for " + language + " cannot be resolved.", t).     }     return null. }
false;protected;1;27;;protected Object evaluateScript(Exchange exchange) {     try {         if (reuseScriptEngine(exchange)) {             // It's not safe to do the evaluation with a single scriptEngine             synchronized (this) {                 LOG.debug("Calling doEvaluateScript without creating a new scriptEngine").                 return doEvaluateScript(exchange, scriptEngine).             }         } else {             LOG.debug("Calling doEvaluateScript with a new scriptEngine").             // get a new engine which we must for each exchange             ScriptEngine engine = scriptEngineFactory.getScriptEngine().             return doEvaluateScript(exchange, engine).         }     } catch (ScriptException e) {         if (LOG.isDebugEnabled()) {             LOG.debug("Script evaluation failed: {}", e.getMessage(), e).         }         if (e.getCause() != null) {             throw createScriptEvaluationException(e.getCause()).         } else {             throw createScriptEvaluationException(e).         }     } catch (IOException e) {         throw createScriptEvaluationException(e).     } }
false;protected;2;7;;protected Object doEvaluateScript(Exchange exchange, ScriptEngine scriptEngine) throws ScriptException, IOException {     ScriptContext context = populateBindings(scriptEngine, exchange, attributes).     addScriptEngineArguments(scriptEngine, exchange).     Object result = runScript(scriptEngine, exchange, context).     LOG.debug("The script evaluation result is: {}", result).     return result. }
true;private;1;9;// To check the camel context property to decide if we need to reuse the ScriptEngine ;// To check the camel context property to decide if we need to reuse the ScriptEngine private boolean reuseScriptEngine(Exchange exchange) {     CamelContext camelContext = exchange.getContext().     if (camelContext != null) {         return getCamelContextProperty(camelContext, Exchange.REUSE_SCRIPT_ENGINE).     } else {         // default value is false         return false.     } }
false;private;1;7;;private boolean compileScripte(CamelContext camelContext) {     if (camelContext != null) {         return getCamelContextProperty(camelContext, Exchange.COMPILE_SCRIPT).     } else {         return false.     } }
false;private;2;8;;private boolean getCamelContextProperty(CamelContext camelContext, String propertyKey) {     String propertyValue = camelContext.getGlobalOption(propertyKey).     if (propertyValue != null) {         return camelContext.getTypeConverter().convertTo(boolean.class, propertyValue).     } else {         return false.     } }
false;protected;3;25;;protected Object runScript(ScriptEngine engine, Exchange exchange, ScriptContext context) throws ScriptException, IOException {     Object result = null.     if (compiledScript != null) {         LOG.trace("Evaluate using compiled script for context: {} on exchange: {}", context, exchange).         result = compiledScript.eval(context).     } else {         if (scriptText != null) {             LOG.trace("Evaluate script for context: {} on exchange: {}", context, exchange).             result = engine.eval(scriptText, context).         } else if (scriptResource != null) {             Reader reader = createScriptReader(exchange.getContext(), scriptResource).             try {                 LOG.trace("Evaluate script for context: {} on exchange: {}", context, exchange).                 result = engine.eval(reader, context).             } finally {                 IOHelper.close(reader).             }         }     }     // As the script could have multiple statement, we need to look up the result from the engine value set     if (result == null) {         result = engine.get("result").     }     return result. }
false;protected;3;25;;protected ScriptContext populateBindings(ScriptEngine engine, Exchange exchange, Map<String, Object> attributes) {     ScriptContext context = engine.getContext().     int scope = ScriptContext.ENGINE_SCOPE.     context.setAttribute("context", exchange.getContext(), scope).     context.setAttribute("camelContext", exchange.getContext(), scope).     context.setAttribute("exchange", exchange, scope).     Message in = exchange.getIn().     context.setAttribute("request", in, scope).     context.setAttribute("headers", in.getHeaders(), scope).     context.setAttribute("body", in.getBody(), scope).     if (exchange.hasOut()) {         Message out = exchange.getOut().         context.setAttribute("out", out, scope).         context.setAttribute("response", out, scope).     }     // to make using properties component easier     context.setAttribute("properties", new ScriptPropertiesFunction(exchange.getContext()), scope).     // any additional attributes     if (attributes != null) {         for (Map.Entry<String, Object> entry : attributes.entrySet()) {             context.setAttribute(entry.getKey(), entry.getValue(), scope).         }     }     return context. }
false;protected;2;18;;@SuppressWarnings("unchecked") protected void addScriptEngineArguments(ScriptEngine engine, Exchange exchange) {     if (!exchange.getIn().hasHeaders()) {         return.     }     Map<Object, Object> args = exchange.getIn().getHeader(ARGUMENTS, Map.class).     if (args != null) {         for (Map.Entry<Object, Object> entry : args.entrySet()) {             String key = exchange.getContext().getTypeConverter().convertTo(String.class, entry.getKey()).             Object value = entry.getValue().             if (!ObjectHelper.isEmpty(key) && value != null) {                 LOG.trace("Putting {} -> {} on ScriptEngine", key, value).                 engine.put(key, value).             }         }     } }
false;protected,static;2;4;;protected static InputStreamReader createScriptReader(CamelContext camelContext, String resource) throws IOException {     InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(camelContext, resource).     return new InputStreamReader(is). }
false;protected;1;12;;protected ScriptEvaluationException createScriptEvaluationException(Throwable e) {     if (e.getClass().getName().equals("org.jruby.exceptions.RaiseException")) {         // Only the nested exception has the specific problem         try {             Object ex = e.getClass().getMethod("getException").invoke(e).             return new ScriptEvaluationException("Failed to evaluate: " + getScriptDescription() + ".  Error: " + ex + ". Cause: " + e, e).         } catch (Exception e1) {         // do nothing here         }     }     return new ScriptEvaluationException("Failed to evaluate: " + getScriptDescription() + ". Cause: " + e, e). }
false;private,static;1;3;;private static boolean isPython(String language) {     return "python".equals(language) || "jython".equals(language). }
false;private,static;1;3;;private static boolean isBeanShell(String language) {     return "beanshell".equals(language) || "bsh".equals(language). }
