commented;modifiers;parameterAmount;loc;comment;code
true;private,static;7;12;/**  * Create a new message with the specified data  */ ;/**  * Create a new message with the specified data  */ private static Message createMessage(String to, String cc, String from, Date received, Date sent, int size, String subject) throws MessagingException {     final Message msg = Mockito.mock(Message.class).     when(msg.getFrom()).thenReturn(new Address[] { new InternetAddress(from) }).     when(msg.getRecipients(Message.RecipientType.TO)).thenReturn(new Address[] { new InternetAddress(to) }).     when(msg.getRecipients(Message.RecipientType.CC)).thenReturn(new Address[] { new InternetAddress(cc) }).     when(msg.getSentDate()).thenReturn(sent).     when(msg.getReceivedDate()).thenReturn(received).     when(msg.getSize()).thenReturn(size).     when(msg.getSubject()).thenReturn(subject).     return msg. }
false;public;0;15;;@Test public void testSortMessages() throws Exception {     Message[] expected = new Message[] { MESSAGES[0], MESSAGES[1], MESSAGES[2] }.     // Sort using all the terms. Message order should be the same no matter what term is used     for (SortTerm term : POSSIBLE_TERMS) {         Message[] actual = MESSAGES.clone().         MailSorter.sortMessages(actual, new SortTerm[] { term }).         try {             assertArrayEquals(actual, expected).         } catch (Exception ex) {             throw new Exception("Term: " + term.toString(), ex).         }     } }
false;public;0;15;;@Test public void testSortMessagesReverse() throws Exception {     Message[] expected = new Message[] { MESSAGES[2], MESSAGES[1], MESSAGES[0] }.     // Sort using all the terms. Message order should be the same no matter what term is used     for (SortTerm term : POSSIBLE_TERMS) {         Message[] actual = MESSAGES.clone().         MailSorter.sortMessages(actual, new SortTerm[] { SortTerm.REVERSE, term }).         try {             assertArrayEquals(actual, expected).         } catch (AssertionError ex) {             throw new AssertionError("Term: " + term.toString(), ex).         }     } }
false;public;0;19;;@Test public void testSortMessagesMulti() throws Exception {     Message[] expected = new Message[] { MESSAGES[0], MESSAGES[1], MESSAGES[2] }.     // should be ignored since it is already the decider.     for (SortTerm term1 : POSSIBLE_TERMS) {         for (SortTerm term2 : POSSIBLE_TERMS) {             Message[] actual = MESSAGES.clone().             MailSorter.sortMessages(actual, new SortTerm[] { term1, SortTerm.REVERSE, term2 }).             try {                 assertArrayEquals(actual, expected).             } catch (AssertionError ex) {                 throw new AssertionError(String.format("Terms: %s, %s", term1.toString(), term2.toString()), ex).             }         }     } }
false;public;0;19;;@Test public void testSortMessagesWithTie() throws Exception {     Message[] given = new Message[] { MESSAGES[2], TIE_BREAKER }.     // Sort according to the whole list. Only the last element breaks the tie     Message[] actual1 = given.clone().     MailSorter.sortMessages(actual1, POSSIBLE_TERMS).     assertArrayEquals(actual1, new Message[] { TIE_BREAKER, MESSAGES[2] }).     // now reverse the last element (the tie breaker)     SortTerm[] reversed = new SortTerm[POSSIBLE_TERMS.length + 1].     System.arraycopy(POSSIBLE_TERMS, 0, reversed, 0, POSSIBLE_TERMS.length - 1).     reversed[reversed.length - 2] = SortTerm.REVERSE.     reversed[reversed.length - 1] = POSSIBLE_TERMS[POSSIBLE_TERMS.length - 1].     // And check again     Message[] actual2 = given.clone().     MailSorter.sortMessages(actual2, reversed).     assertArrayEquals(actual2, new Message[] { MESSAGES[2], TIE_BREAKER }). }
