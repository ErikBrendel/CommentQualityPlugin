commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected void doStart() throws Exception {     super.doStart(). }
false;protected;0;11;;@Override protected void doStop() throws Exception {     if (folder != null && folder.isOpen()) {         folder.close(true).     }     if (store != null && store.isConnected()) {         store.close().     }     super.doStop(). }
false;protected;0;85;;protected int poll() throws Exception {     // must reset for each poll     shutdownRunningTask = null.     pendingExchanges = 0.     int polledMessages = 0.     ensureIsConnected().     if (store == null || folder == null) {         throw new IllegalStateException("MailConsumer did not connect properly to the MailStore: " + getEndpoint().getConfiguration().getMailStoreLogInformation()).     }     if (log.isDebugEnabled()) {         log.debug("Polling mailbox folder: {}", getEndpoint().getConfiguration().getMailStoreLogInformation()).     }     if (getEndpoint().getConfiguration().getFetchSize() == 0) {         log.warn("Fetch size is 0 meaning the configuration is set to poll no new messages at all. Camel will skip this poll.").         return 0.     }     // ensure folder is open     if (!folder.isOpen()) {         folder.open(Folder.READ_WRITE).     }     try {         int count = folder.getMessageCount().         if (count > 0) {             List<KeyValueHolder<String, Message>> messages = retrieveMessages().             // we process the message and rollback due an exception             if (getEndpoint().getConfiguration().isPeek()) {                 for (KeyValueHolder<String, Message> entry : messages) {                     Message message = entry.getValue().                     peekMessage(message).                 }             }             polledMessages = processBatch(CastUtils.cast(createExchanges(messages))).             final MailBoxPostProcessAction postProcessor = getEndpoint().getPostProcessAction().             if (postProcessor != null) {                 postProcessor.process(folder).             }         } else if (count == -1) {             throw new MessagingException("Folder: " + folder.getFullName() + " is closed").         }     } catch (Exception e) {         handleException(e).     } finally {         // need to ensure we release resources, but only if closeFolder or disconnect = true         if (getEndpoint().getConfiguration().isCloseFolder() || getEndpoint().getConfiguration().isDisconnect()) {             if (log.isDebugEnabled()) {                 log.debug("Close mailbox folder {} from {}", folder.getName(), getEndpoint().getConfiguration().getMailStoreLogInformation()).             }             try {                 if (folder.isOpen()) {                     folder.close(true).                 }             } catch (Exception e) {                 // some mail servers will lock the folder so we ignore in this case (CAMEL-1263)                 log.debug("Could not close mailbox folder: " + folder.getName() + ". This exception is ignored.", e).             }         }     }     // should we disconnect, the header can override the configuration     boolean disconnect = getEndpoint().getConfiguration().isDisconnect().     if (disconnect) {         if (log.isDebugEnabled()) {             log.debug("Disconnecting from {}", getEndpoint().getConfiguration().getMailStoreLogInformation()).         }         try {             store.close().         } catch (Exception e) {             log.debug("Could not disconnect from {}. This exception is ignored.", getEndpoint().getConfiguration().getMailStoreLogInformation(), e).         }         store = null.         folder = null.     }     return polledMessages. }
false;public;1;3;;public void onComplete(Exchange exchange) {     processCommit(mail, exchange). }
false;public;1;3;;public void onFailure(Exchange exchange) {     processRollback(mail, exchange). }
false;public;0;6;;@Override public boolean allowHandover() {     // on the same session that polled the messages     return false. }
false;public;0;4;;@Override public String toString() {     return "MailConsumerOnCompletion". }
false;public;1;52;;public int processBatch(Queue<Object> exchanges) throws Exception {     int total = exchanges.size().     // limit if needed     if (maxMessagesPerPoll > 0 && total > maxMessagesPerPoll) {         log.debug("Limiting to maximum messages to poll {} as there were {} messages in this poll.", maxMessagesPerPoll, total).         total = maxMessagesPerPoll.     }     for (int index = 0. index < total && isBatchAllowed(). index++) {         // only loop if we are started (allowed to run)         Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll()).         // add current index and total as properties         exchange.setProperty(Exchange.BATCH_INDEX, index).         exchange.setProperty(Exchange.BATCH_SIZE, total).         exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1).         // update pending number of exchanges         pendingExchanges = total - index - 1.         // must use the original message in case we need to workaround a charset issue when extracting mail content         final Message mail = exchange.getIn(MailMessage.class).getOriginalMessage().         // add on completion to handle after work when the exchange is done         exchange.addOnCompletion(new SynchronizationAdapter() {              public void onComplete(Exchange exchange) {                 processCommit(mail, exchange).             }              public void onFailure(Exchange exchange) {                 processRollback(mail, exchange).             }              @Override             public boolean allowHandover() {                 // on the same session that polled the messages                 return false.             }              @Override             public String toString() {                 return "MailConsumerOnCompletion".             }         }).         // process the exchange         processExchange(exchange).     }     return total. }
false;private;1;12;;private void peekMessage(Message mail) {     // this only applies to IMAP messages which has a setPeek method     if (mail.getClass().getSimpleName().startsWith("IMAP")) {         try {             log.trace("Calling setPeek(true) on mail message {}", mail).             IntrospectionSupport.setProperty(mail, "peek", true).         } catch (Throwable e) {             // ignore             log.trace("Error setting peak property to true on: " + mail + ". This exception is ignored.", e).         }     } }
true;private;0;36;/**  * @return Messages from input folder according to the search and sort criteria stored in the endpoint  * @throws MessagingException If message retrieval fails  */ ;/**  * @return Messages from input folder according to the search and sort criteria stored in the endpoint  * @throws MessagingException If message retrieval fails  */ private List<KeyValueHolder<String, Message>> retrieveMessages() throws MessagingException {     List<KeyValueHolder<String, Message>> answer = new ArrayList<>().     Message[] messages.     final SortTerm[] sortTerm = getEndpoint().getSortTerm().     final SearchTerm searchTerm = computeSearchTerm().     if (sortTerm != null && serverCanSort) {         final IMAPFolder imapFolder = (IMAPFolder) folder.         if (searchTerm != null) {             // Sort and search using server capability             messages = imapFolder.getSortedMessages(sortTerm, searchTerm).         } else {             // Only sort using server capability             messages = imapFolder.getSortedMessages(sortTerm).         }     } else {         if (searchTerm != null) {             messages = folder.search(searchTerm, retrieveAllMessages()).         } else {             messages = retrieveAllMessages().         }         // Now we can sort (emulate email sort but restrict sort terms)         if (sortTerm != null) {             MailSorter.sortMessages(messages, sortTerm).         }     }     for (Message message : messages) {         String key = getEndpoint().getMailUidGenerator().generateUuid(getEndpoint(), message).         if (isValidMessage(key, message)) {             answer.add(new KeyValueHolder<>(key, message)).         }     }     return answer. }
false;private;0;21;;private Message[] retrieveAllMessages() throws MessagingException {     int total = folder.getMessageCount().     List<Message> msgs = new ArrayList<>().     // Note that message * numbers start at 1, not 0     for (int i = 1. i <= total. i++) {         try {             Message msg = folder.getMessage(i).             msgs.add(msg).         } catch (Exception e) {             if (skipFailedMessage) {                 log.debug("Skipping failed message at index " + i + " due " + e.getMessage(), e).             } else if (handleFailedMessage) {                 handleException(e).             } else {                 throw e.             }         }     }     return msgs.toArray(new Message[msgs.size()]). }
false;private;2;13;;private boolean isValidMessage(String key, Message msg) {     boolean answer = true.     if (getEndpoint().getIdempotentRepository() != null) {         if (!getEndpoint().getIdempotentRepository().add(key)) {             log.trace("This consumer is idempotent and the mail message has been consumed before matching idempotentKey: {}. Will skip this message: {}", key, msg).             answer = false.         }     }     log.debug("Message: {} with key: {} is valid: {}", msg, key, answer).     return answer. }
true;private;0;8;/**  * @return Search term from endpoint (including "seen" check) or null if there is no search term  */ ;/**  * @return Search term from endpoint (including "seen" check) or null if there is no search term  */ private SearchTerm computeSearchTerm() {     if (getEndpoint().getSearchTerm() != null) {         return getEndpoint().getSearchTerm().     } else if (getEndpoint().getConfiguration().isUnseen()) {         return new SearchTermBuilder().unseen().build().     }     return null. }
false;protected;1;54;;protected Queue<Exchange> createExchanges(List<KeyValueHolder<String, Message>> messages) throws MessagingException {     Queue<Exchange> answer = new LinkedList<>().     int fetchSize = getEndpoint().getConfiguration().getFetchSize().     int count = fetchSize == -1 ? messages.size() : Math.min(fetchSize, messages.size()).     if (log.isDebugEnabled()) {         log.debug("Fetching {} messages. Total {} messages.", count, messages.size()).     }     for (int i = 0. i < count. i++) {         try {             KeyValueHolder<String, Message> holder = messages.get(i).             String key = holder.getKey().             Message message = holder.getValue().             if (log.isTraceEnabled()) {                 log.trace("Mail #{} is of type: {} - {}", i, ObjectHelper.classCanonicalName(message), message).             }             if (!message.getFlags().contains(Flags.Flag.DELETED)) {                 Exchange exchange = getEndpoint().createExchange(message).                 if (getEndpoint().getConfiguration().isMapMailMessage()) {                     // ensure the mail message is mapped, which can be ensured by touching the body/header/attachment                     log.trace("Mapping #{} from javax.mail.Message to Camel MailMessage", i).                     exchange.getIn().getBody().                     exchange.getIn().getHeaders().                     exchange.getIn().getAttachments().                 }                 // If the protocol is POP3 we need to remember the uid on the exchange                 // so we can find the mail message again later to be able to delete it                 // we also need to remember the UUID for idempotent repository                 exchange.setProperty(MAIL_MESSAGE_UID, key).                 answer.add(exchange).             } else {                 if (log.isDebugEnabled()) {                     log.debug("Skipping message as it was flagged as deleted: {}", MailUtils.dumpMessage(message)).                 }             }         } catch (Exception e) {             if (skipFailedMessage) {                 log.debug("Skipping failed message at index " + i + " due " + e.getMessage(), e).             } else if (handleFailedMessage) {                 handleException(e).             } else {                 throw e.             }         }     }     return answer. }
true;protected;1;7;/**  * Strategy to process the mail message.  */ ;/**  * Strategy to process the mail message.  */ protected void processExchange(Exchange exchange) throws Exception {     if (log.isDebugEnabled()) {         MailMessage msg = (MailMessage) exchange.getIn().         log.debug("Processing message: {}", MailUtils.dumpMessage(msg.getMessage())).     }     getProcessor().process(exchange). }
true;protected;2;72;/**  * Strategy to flag the message after being processed.  *  * @param mail     the mail message  * @param exchange the exchange  */ ;/**  * Strategy to flag the message after being processed.  *  * @param mail     the mail message  * @param exchange the exchange  */ protected void processCommit(Message mail, Exchange exchange) {     try {         // ensure folder is open         if (!folder.isOpen()) {             folder.open(Folder.READ_WRITE).         }         String uid = (String) exchange.removeProperty(MAIL_MESSAGE_UID).         // Otherwise setting the DELETE/SEEN flag won't delete the message.         if (getEndpoint().getConfiguration().getProtocol().startsWith("pop3")) {             int count = folder.getMessageCount().             Message found = null.             log.trace("Looking for POP3Message with UID {} from folder with {} mails", uid, count).             for (int i = 1. i <= count. ++i) {                 Message msg = folder.getMessage(i).                 if (uid.equals(getEndpoint().getMailUidGenerator().generateUuid(getEndpoint(), msg))) {                     log.debug("Found POP3Message with UID {} from folder with {} mails", uid, count).                     found = msg.                     break.                 }             }             if (found == null) {                 boolean delete = getEndpoint().getConfiguration().isDelete().                 log.warn("POP3message not found in folder. Message cannot be marked as " + (delete ? "DELETED" : "SEEN")).             } else {                 mail = found.             }         }         org.apache.camel.Message in = exchange.getIn().         MailConfiguration config = getEndpoint().getConfiguration().         // header values override configuration values         String copyTo = in.getHeader("copyTo", config.getCopyTo(), String.class).         boolean delete = in.getHeader("delete", config.isDelete(), boolean.class).         // Copy message into different imap folder if asked         if (config.getProtocol().equals(MailUtils.PROTOCOL_IMAP) || config.getProtocol().equals(MailUtils.PROTOCOL_IMAPS)) {             if (copyTo != null) {                 log.trace("IMAP message needs to be copied to {}", copyTo).                 Folder destFolder = store.getFolder(copyTo).                 if (!destFolder.exists()) {                     destFolder.create(Folder.HOLDS_MESSAGES).                 }                 folder.copyMessages(new Message[] { mail }, destFolder).                 log.trace("IMAP message {} copied to {}", mail, copyTo).             }         }         if (delete) {             log.trace("Exchange processed, so flagging message as DELETED").             mail.setFlag(Flags.Flag.DELETED, true).         } else {             log.trace("Exchange processed, so flagging message as SEEN").             mail.setFlag(Flags.Flag.SEEN, true).         }         // need to confirm or remove on commit at last         if (getEndpoint().getIdempotentRepository() != null) {             if (getEndpoint().isIdempotentRepositoryRemoveOnCommit()) {                 getEndpoint().getIdempotentRepository().remove(uid).             } else {                 getEndpoint().getIdempotentRepository().confirm(uid).             }         }     } catch (MessagingException e) {         getExceptionHandler().handleException("Error occurred during committing mail message: " + mail, exchange, e).     } }
true;protected;2;16;/**  * Strategy when processing the exchange failed.  *  * @param mail     the mail message  * @param exchange the exchange  */ ;/**  * Strategy when processing the exchange failed.  *  * @param mail     the mail message  * @param exchange the exchange  */ protected void processRollback(Message mail, Exchange exchange) {     String uid = (String) exchange.removeProperty(MAIL_MESSAGE_UID).     // need to remove on rollback     if (getEndpoint().getIdempotentRepository() != null) {         getEndpoint().getIdempotentRepository().remove(uid).     }     Exception cause = exchange.getException().     if (cause != null) {         log.warn("Exchange failed, so rolling back message status: {}", exchange, cause).     } else {         log.warn("Exchange failed, so rolling back message status: {}", exchange).     } }
false;private;0;38;;private void ensureIsConnected() throws MessagingException {     MailConfiguration config = getEndpoint().getConfiguration().     boolean connected = false.     try {         if (store != null && store.isConnected()) {             connected = true.         }     } catch (Exception e) {         log.debug("Exception while testing for is connected to MailStore: " + getEndpoint().getConfiguration().getMailStoreLogInformation() + ". Caused by: " + e.getMessage(), e).     }     if (!connected) {         // ensure resources get recreated on reconnection         store = null.         folder = null.         if (log.isDebugEnabled()) {             log.debug("Connecting to MailStore: {}", getEndpoint().getConfiguration().getMailStoreLogInformation()).         }         store = sender.getSession().getStore(config.getProtocol()).         store.connect(config.getHost(), config.getPort(), config.getUsername(), config.getPassword()).         serverCanSort = hasSortCapability(store).     }     if (folder == null) {         if (log.isDebugEnabled()) {             log.debug("Getting folder {}", config.getFolderName()).         }         folder = store.getFolder(config.getFolderName()).         if (folder == null || !folder.exists()) {             throw new FolderNotFoundException(folder, "Folder not found or invalid: " + config.getFolderName()).         }     } }
true;private,static;1;9;/**  * Check whether the email store has the sort capability or not.  *  * @param store Email store  * @return true if the store is an IMAP store and it has the store capability  * @throws MessagingException In case capability check fails  */ ;/**  * Check whether the email store has the sort capability or not.  *  * @param store Email store  * @return true if the store is an IMAP store and it has the store capability  * @throws MessagingException In case capability check fails  */ private static boolean hasSortCapability(Store store) throws MessagingException {     if (store instanceof IMAPStore) {         IMAPStore imapStore = (IMAPStore) store.         if (imapStore.hasCapability("SORT*")) {             return true.         }     }     return false. }
false;public;0;4;;@Override public MailEndpoint getEndpoint() {     return (MailEndpoint) super.getEndpoint(). }
false;public;0;3;;public boolean isSkipFailedMessage() {     return skipFailedMessage. }
false;public;1;3;;public void setSkipFailedMessage(boolean skipFailedMessage) {     this.skipFailedMessage = skipFailedMessage. }
false;public;0;3;;public boolean isHandleFailedMessage() {     return handleFailedMessage. }
false;public;1;3;;public void setHandleFailedMessage(boolean handleFailedMessage) {     this.handleFailedMessage = handleFailedMessage. }
