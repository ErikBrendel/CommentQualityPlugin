commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;public Producer createProducer() throws Exception {     JavaMailSender sender = configuration.getJavaMailSender().     if (sender == null) {         // use default mail sender         sender = configuration.createJavaMailSender().     }     return createProducer(sender). }
true;public;1;3;/**  * Creates a producer using the given sender  */ ;/**  * Creates a producer using the given sender  */ public Producer createProducer(JavaMailSender sender) throws Exception {     return new MailProducer(this, sender). }
false;public;1;10;;public Consumer createConsumer(Processor processor) throws Exception {     if (configuration.getProtocol().startsWith("smtp")) {         throw new IllegalArgumentException("Protocol " + configuration.getProtocol() + " cannot be used for a MailConsumer. Please use another protocol such as pop3 or imap.").     }     // must use java mail sender impl as we need to get hold of a mail session     JavaMailSender sender = configuration.createJavaMailSender().     return createConsumer(processor, sender). }
true;public;2;8;/**  * Creates a consumer using the given processor and sender  */ ;/**  * Creates a consumer using the given processor and sender  */ public Consumer createConsumer(Processor processor, JavaMailSender sender) throws Exception {     MailConsumer answer = new MailConsumer(this, processor, sender).     answer.setHandleFailedMessage(configuration.isHandleFailedMessage()).     answer.setSkipFailedMessage(configuration.isSkipFailedMessage()).     answer.setMaxMessagesPerPoll(getMaxMessagesPerPoll()).     configureConsumer(answer).     return answer. }
false;public;0;3;;public boolean isSingleton() {     return false. }
false;public;1;6;;public Exchange createExchange(Message message) {     Exchange exchange = super.createExchange().     exchange.setProperty(Exchange.BINDING, getBinding()).     exchange.setIn(new MailMessage(exchange, message, getConfiguration().isMapMailMessage())).     return exchange. }
false;public;0;6;;// Properties // ------------------------------------------------------------------------- public MailBinding getBinding() {     if (binding == null) {         binding = new MailBinding(headerFilterStrategy, contentTypeResolver).     }     return binding. }
true;public;1;3;/**  * Sets the binding used to convert from a Camel message to and from a Mail message  */ ;/**  * Sets the binding used to convert from a Camel message to and from a Mail message  */ public void setBinding(MailBinding binding) {     this.binding = binding. }
false;public;0;3;;public MailConfiguration getConfiguration() {     return configuration. }
true;public;1;3;/**  * Sets the Mail configuration  */ ;/**  * Sets the Mail configuration  */ public void setConfiguration(MailConfiguration configuration) {     this.configuration = configuration. }
false;public;0;3;;public HeaderFilterStrategy getHeaderFilterStrategy() {     return headerFilterStrategy. }
true;public;1;3;/**  * To use a custom {@link org.apache.camel.spi.HeaderFilterStrategy} to filter headers.  */ ;/**  * To use a custom {@link org.apache.camel.spi.HeaderFilterStrategy} to filter headers.  */ public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {     this.headerFilterStrategy = headerFilterStrategy. }
false;public;0;3;;public ContentTypeResolver getContentTypeResolver() {     return contentTypeResolver. }
true;public;1;3;/**  * Resolver to determine Content-Type for file attachments.  */ ;/**  * Resolver to determine Content-Type for file attachments.  */ public void setContentTypeResolver(ContentTypeResolver contentTypeResolver) {     this.contentTypeResolver = contentTypeResolver. }
false;public;0;3;;public int getMaxMessagesPerPoll() {     return maxMessagesPerPoll. }
true;public;1;3;/**  * Specifies the maximum number of messages to gather per poll. By default, no maximum is set.  * Can be used to set a limit of e.g. 1000 to avoid downloading thousands of files when the server starts up.  * Set a value of 0 or negative to disable this option.  */ ;/**  * Specifies the maximum number of messages to gather per poll. By default, no maximum is set.  * Can be used to set a limit of e.g. 1000 to avoid downloading thousands of files when the server starts up.  * Set a value of 0 or negative to disable this option.  */ public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {     this.maxMessagesPerPoll = maxMessagesPerPoll. }
false;public;0;3;;public SearchTerm getSearchTerm() {     return searchTerm. }
true;public;1;3;/**  * Refers to a {@link javax.mail.search.SearchTerm} which allows to filter mails based on search criteria such as subject, body, from, sent after a certain date etc.  */ ;/**  * Refers to a {@link javax.mail.search.SearchTerm} which allows to filter mails based on search criteria such as subject, body, from, sent after a certain date etc.  */ public void setSearchTerm(SearchTerm searchTerm) {     this.searchTerm = searchTerm. }
false;public;0;3;;public SortTerm[] getSortTerm() {     return sortTerm == null ? null : sortTerm.clone(). }
true;public;1;3;/**  * Sorting order for messages. Only natively supported for IMAP. Emulated to some degree when using POP3  * or when IMAP server does not have the SORT capability.  */ ;/**  * Sorting order for messages. Only natively supported for IMAP. Emulated to some degree when using POP3  * or when IMAP server does not have the SORT capability.  */ public void setSortTerm(SortTerm[] sortTerm) {     this.sortTerm = sortTerm == null ? null : sortTerm.clone(). }
false;public;0;3;;public MailBoxPostProcessAction getPostProcessAction() {     return postProcessAction. }
true;public;1;3;/**  * Refers to an {@link MailBoxPostProcessAction} for doing post processing tasks on the mailbox once the normal processing ended.  */ ;/**  * Refers to an {@link MailBoxPostProcessAction} for doing post processing tasks on the mailbox once the normal processing ended.  */ public void setPostProcessAction(MailBoxPostProcessAction postProcessAction) {     this.postProcessAction = postProcessAction. }
false;public;0;3;;public IdempotentRepository getIdempotentRepository() {     return idempotentRepository. }
true;public;1;3;/**  * A pluggable repository org.apache.camel.spi.IdempotentRepository which allows to cluster  * consuming from the same mailbox, and let the repository coordinate whether a mail message  * is valid for the consumer to process.  * <p/>  * By default no repository is in use.  */ ;/**  * A pluggable repository org.apache.camel.spi.IdempotentRepository which allows to cluster  * consuming from the same mailbox, and let the repository coordinate whether a mail message  * is valid for the consumer to process.  * <p/>  * By default no repository is in use.  */ public void setIdempotentRepository(IdempotentRepository idempotentRepository) {     this.idempotentRepository = idempotentRepository. }
false;public;0;3;;public boolean isIdempotentRepositoryRemoveOnCommit() {     return idempotentRepositoryRemoveOnCommit. }
true;public;1;3;/**  * When using idempotent repository, then when the mail message has been successfully processed and  * is committed, should the message id be removed from the idempotent repository (default) or  * be kept in the repository.  * <p/>  * By default its assumed the message id is unique and has no value to be kept in the repository,  * because the mail message will be marked as seen/moved or deleted to prevent it from being  * consumed again. And therefore having the message id stored in the idempotent repository has  * little value. However this option allows to store the message id, for whatever reason you may have.  */ ;/**  * When using idempotent repository, then when the mail message has been successfully processed and  * is committed, should the message id be removed from the idempotent repository (default) or  * be kept in the repository.  * <p/>  * By default its assumed the message id is unique and has no value to be kept in the repository,  * because the mail message will be marked as seen/moved or deleted to prevent it from being  * consumed again. And therefore having the message id stored in the idempotent repository has  * little value. However this option allows to store the message id, for whatever reason you may have.  */ public void setIdempotentRepositoryRemoveOnCommit(boolean idempotentRepositoryRemoveOnCommit) {     this.idempotentRepositoryRemoveOnCommit = idempotentRepositoryRemoveOnCommit. }
false;public;0;3;;public MailUidGenerator getMailUidGenerator() {     return mailUidGenerator. }
true;public;1;3;/**  * A pluggable {@link MailUidGenerator} that allows to use custom logic to generate UUID of the mail message.  */ ;/**  * A pluggable {@link MailUidGenerator} that allows to use custom logic to generate UUID of the mail message.  */ public void setMailUidGenerator(MailUidGenerator mailUidGenerator) {     this.mailUidGenerator = mailUidGenerator. }
true;public;1;5;/**  * Milliseconds before the next poll.  */ ;/**  * Milliseconds before the next poll.  */ @Override public void setDelay(long delay) {     super.setDelay(delay).     this.delay = delay. }
