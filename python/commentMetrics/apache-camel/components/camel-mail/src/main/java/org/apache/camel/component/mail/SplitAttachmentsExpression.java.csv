commented;modifiers;parameterAmount;loc;comment;code
false;public;1;28;;@Override public Object evaluate(Exchange exchange) {     // must use getAttachments to ensure attachments is initial populated     if (exchange.getIn().getAttachments().isEmpty()) {         return null.     }     try {         List<Message> answer = new ArrayList<>().         Message inMessage = exchange.getIn().         for (Map.Entry<String, Attachment> entry : inMessage.getAttachmentObjects().entrySet()) {             Message attachmentMessage.             if (extractAttachments) {                 attachmentMessage = extractAttachment(inMessage, entry.getKey()).             } else {                 attachmentMessage = splitAttachment(inMessage, entry.getKey(), entry.getValue()).             }             if (attachmentMessage != null) {                 answer.add(attachmentMessage).             }         }         return answer.     } catch (Exception e) {         throw new RuntimeCamelException("Unable to split attachments from MimeMultipart message", e).     } }
false;private;3;8;;private Message splitAttachment(Message inMessage, String attachmentName, Attachment attachmentHandler) {     final Message copy = inMessage.copy().     Map<String, Attachment> attachments = copy.getAttachmentObjects().     attachments.clear().     attachments.put(attachmentName, attachmentHandler).     copy.setHeader(HEADER_NAME, attachmentName).     return copy. }
false;private;2;14;;private Message extractAttachment(Message inMessage, String attachmentName) throws Exception {     final Message outMessage = new DefaultMessage(inMessage.getExchange().getContext()).     outMessage.setHeader(HEADER_NAME, attachmentName).     Object attachment = inMessage.getAttachment(attachmentName).getContent().     if (attachment instanceof InputStream) {         outMessage.setBody(readMimePart((InputStream) attachment)).         return outMessage.     } else if (attachment instanceof String || attachment instanceof byte[]) {         outMessage.setBody(attachment).         return outMessage.     } else {         return null.     } }
false;private;1;7;;private byte[] readMimePart(InputStream mimePartStream) throws Exception {     // mimePartStream could be base64 encoded, or not, but we don't need to worry about it as     // Camel is smart enough to wrap it in a decoder stream (eg Base64DecoderStream) when required     ByteArrayOutputStream bos = new ByteArrayOutputStream().     IOHelper.copyAndCloseInput(mimePartStream, bos).     return bos.toByteArray(). }
false;public;0;3;;public boolean isExtractAttachments() {     return extractAttachments. }
false;public;1;3;;public void setExtractAttachments(boolean extractAttachments) {     this.extractAttachments = extractAttachments. }
