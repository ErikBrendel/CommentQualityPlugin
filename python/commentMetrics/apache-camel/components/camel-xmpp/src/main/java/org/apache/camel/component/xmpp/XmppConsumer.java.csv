commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;49;;@Override protected void doStart() throws Exception {     try {         connection = endpoint.createConnection().     } catch (SmackException e) {         if (endpoint.isTestConnectionOnStartup()) {             throw new RuntimeException("Could not connect to XMPP server.", e).         } else {             log.warn(e.getMessage()).             if (getExceptionHandler() != null) {                 getExceptionHandler().handleException(e.getMessage(), e).             }             scheduleDelayedStart().             return.         }     }     chatManager = ChatManager.getInstanceFor(connection).     chatManager.addIncomingListener(this).     OrFilter pubsubPacketFilter = new OrFilter().     if (endpoint.isPubsub()) {         // xep-0060: pubsub#notification_type can be 'headline' or 'normal'         pubsubPacketFilter.addFilter(MessageTypeFilter.HEADLINE).         pubsubPacketFilter.addFilter(MessageTypeFilter.NORMAL).         connection.addSyncStanzaListener(this, pubsubPacketFilter).     }     if (endpoint.getRoom() == null) {         privateChat = chatManager.chatWith(JidCreate.entityBareFrom(endpoint.getChatId())).     } else {         // add the presence packet listener to the connection so we only get packets that concerns us         // we must add the listener before creating the muc         final AndFilter packetFilter = new AndFilter(new StanzaTypeFilter(Presence.class)).         connection.addSyncStanzaListener(this, packetFilter).         MultiUserChatManager mucm = MultiUserChatManager.getInstanceFor(connection).         muc = mucm.getMultiUserChat(JidCreate.entityBareFrom(endpoint.resolveRoom(connection))).         muc.addMessageListener(this).         MucEnterConfiguration mucc = muc.getEnterConfigurationBuilder(Resourcepart.from(endpoint.getNickname())).requestNoHistory().build().         muc.join(mucc).         log.info("Joined room: {} as: {}", muc.getRoom(), endpoint.getNickname()).     }     this.startRobustConnectionMonitor().     super.doStart(). }
false;public;0;8;;@Override public void run() {     try {         doStart().     } catch (Exception e) {         log.warn("Ignoring an exception caught in the startup connection poller thread.", e).     } }
false;protected;0;15;;protected void scheduleDelayedStart() throws Exception {     Runnable startRunnable = new Runnable() {          @Override         public void run() {             try {                 doStart().             } catch (Exception e) {                 log.warn("Ignoring an exception caught in the startup connection poller thread.", e).             }         }     }.     log.info("Delaying XMPP consumer startup for endpoint {}. Trying again in {} seconds.", URISupport.sanitizeUri(endpoint.getEndpointUri()), endpoint.getConnectionPollDelay()).     getExecutor().schedule(startRunnable, endpoint.getConnectionPollDelay(), TimeUnit.SECONDS). }
false;public;0;8;;@Override public void run() {     try {         checkConnection().     } catch (Exception e) {         log.warn("Ignoring an exception caught in the connection poller thread.", e).     } }
false;private;0;15;;private void startRobustConnectionMonitor() throws Exception {     Runnable connectionCheckRunnable = new Runnable() {          @Override         public void run() {             try {                 checkConnection().             } catch (Exception e) {                 log.warn("Ignoring an exception caught in the connection poller thread.", e).             }         }     }.     // background thread to detect and repair lost connections     getExecutor().scheduleAtFixedRate(connectionCheckRunnable, endpoint.getConnectionPollDelay(), endpoint.getConnectionPollDelay(), TimeUnit.SECONDS). }
false;private;0;11;;private void checkConnection() throws Exception {     if (!connection.isConnected()) {         log.info("Attempting to reconnect to: {}", XmppEndpoint.getConnectionMessage(connection)).         try {             connection.connect().             log.debug("Successfully connected to XMPP server through: {}", connection).         } catch (SmackException e) {             log.warn("Connection to XMPP server failed. Will try to reconnect later again.", e).         }     } }
false;private;0;6;;private ScheduledExecutorService getExecutor() {     if (this.scheduledExecutor == null) {         scheduledExecutor = getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "connectionPoll").     }     return scheduledExecutor. }
false;protected;0;20;;@Override protected void doStop() throws Exception {     super.doStop().     // stop scheduler first     if (scheduledExecutor != null) {         getEndpoint().getCamelContext().getExecutorServiceManager().shutdownNow(scheduledExecutor).         scheduledExecutor = null.     }     if (muc != null) {         log.info("Leaving room: {}", muc.getRoom()).         muc.removeMessageListener(this).         muc.leave().         muc = null.     }     if (connection != null && connection.isConnected()) {         connection.disconnect().     } }
false;public;3;4;;@Override public void newIncomingMessage(EntityBareJid from, Message message, Chat chat) {     processMessage(message). }
false;public;1;4;;@Override public void processMessage(Message message) {     processMessage(null, message). }
false;public;1;6;;@Override public void processStanza(Stanza stanza) throws SmackException.NotConnectedException, InterruptedException {     if (stanza instanceof Message) {         processMessage((Message) stanza).     } }
false;public;2;27;;public void processMessage(Chat chat, Message message) {     if (log.isDebugEnabled()) {         log.debug("Received XMPP message for {} from {} : {}", new Object[] { endpoint.getUser(), endpoint.getParticipant(), message.getBody() }).     }     Exchange exchange = endpoint.createExchange(message).     if (endpoint.isDoc()) {         exchange.getIn().setHeader(XmppConstants.DOC_HEADER, message).     }     try {         getProcessor().process(exchange).     } catch (Exception e) {         exchange.setException(e).     } finally {         // (see http://issues.igniterealtime.org/browse/SMACK-129)         if (muc != null) {             try {                 muc.pollMessage().             } catch (MultiUserChatException.MucNotJoinedException e) {                 log.debug("Error while polling message from MultiUserChat. This exception will be ignored.", e).             }         }     } }
