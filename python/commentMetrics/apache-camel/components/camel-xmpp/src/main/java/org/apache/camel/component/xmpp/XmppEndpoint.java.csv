commented;modifiers;parameterAmount;loc;comment;code
false;public;0;16;;public Producer createProducer() throws Exception {     if (room != null) {         return createGroupChatProducer().     } else {         if (isPubsub()) {             return createPubSubProducer().         }         if (isDoc()) {             return createDirectProducer().         }         if (getParticipant() == null) {             throw new IllegalArgumentException("No room or participant configured on this endpoint: " + this).         }         return createPrivateChatProducer(getParticipant()).     } }
false;public;0;3;;public Producer createGroupChatProducer() throws Exception {     return new XmppGroupChatProducer(this). }
false;public;1;3;;public Producer createPrivateChatProducer(String participant) throws Exception {     return new XmppPrivateChatProducer(this, participant). }
false;public;0;3;;public Producer createDirectProducer() throws Exception {     return new XmppDirectProducer(this). }
false;public;0;3;;public Producer createPubSubProducer() throws Exception {     return new XmppPubSubProducer(this). }
false;public;1;5;;public Consumer createConsumer(Processor processor) throws Exception {     XmppConsumer answer = new XmppConsumer(this, processor).     configureConsumer(answer).     return answer. }
false;public;1;6;;public Exchange createExchange(Stanza packet) {     Exchange exchange = super.createExchange().     exchange.setProperty(Exchange.BINDING, getBinding()).     exchange.setIn(new XmppMessage(exchange, packet)).     return exchange. }
false;protected;0;4;;@Override protected String createEndpointUri() {     return "xmpp://" + host + ":" + port + "/" + getParticipant() + "?serviceName=" + serviceName. }
false;public;0;3;;public boolean isSingleton() {     return true. }
false;public,synchronized;0;52;;public synchronized XMPPTCPConnection createConnection() throws InterruptedException, IOException, SmackException, XMPPException {     if (connection != null && connection.isConnected()) {         // use existing working connection         return connection.     }     // prepare for creating new connection     connection = null.     log.trace("Creating new connection ...").     XMPPTCPConnection newConnection = createConnectionInternal().     newConnection.connect().     newConnection.addSyncStanzaListener(new XmppLogger("INBOUND"), stanza -> true).     newConnection.addSyncStanzaListener(new XmppLogger("OUTBOUND"), stanza -> true).     if (!newConnection.isAuthenticated()) {         if (user != null) {             if (log.isDebugEnabled()) {                 log.debug("Logging in to XMPP as user: {} on connection: {}", user, getConnectionMessage(newConnection)).             }             if (password == null) {                 log.warn("No password configured for user: {} on connection: {}", user, getConnectionMessage(newConnection)).             }             if (createAccount) {                 AccountManager accountManager = AccountManager.getInstance(newConnection).                 accountManager.createAccount(Localpart.from(user), password).             }             if (login) {                 if (resource != null) {                     newConnection.login(user, password, Resourcepart.from(resource)).                 } else {                     newConnection.login(user, password).                 }             }         } else {             if (log.isDebugEnabled()) {                 log.debug("Logging in anonymously to XMPP on connection: {}", getConnectionMessage(newConnection)).             }             newConnection.login().         }     // presence is not needed to be sent after login     }     // okay new connection was created successfully so assign it as the connection     log.debug("Created new connection successfully: {}", newConnection).     connection = newConnection.     return connection. }
false;private;0;16;;private XMPPTCPConnection createConnectionInternal() throws UnknownHostException, XmppStringprepException {     if (connectionConfig != null) {         return new XMPPTCPConnection(ObjectHelper.cast(XMPPTCPConnectionConfiguration.class, connectionConfig)).     }     if (port == 0) {         port = 5222.     }     String sName = getServiceName() == null ? host : getServiceName().     XMPPTCPConnectionConfiguration conf = XMPPTCPConnectionConfiguration.builder().setHostAddress(InetAddress.getByName(host)).setPort(port).setXmppDomain(sName).build().     return new XMPPTCPConnection(conf). }
true;public;1;16;/*      * If there is no "@" symbol in the room, find the chat service JID and      * return fully qualified JID for the room as room@conference.server.domain      */ ;/*      * If there is no "@" symbol in the room, find the chat service JID and      * return fully qualified JID for the room as room@conference.server.domain      */ public String resolveRoom(XMPPConnection connection) throws InterruptedException, SmackException, XMPPException {     StringHelper.notEmpty(room, "room").     if (room.indexOf('@', 0) != -1) {         return room.     }     MultiUserChatManager multiUserChatManager = MultiUserChatManager.getInstanceFor(connection).     List<DomainBareJid> xmppServiceDomains = multiUserChatManager.getXMPPServiceDomains().     if (xmppServiceDomains.isEmpty()) {         throw new XMPPErrorException(null, StanzaError.from(Condition.item_not_found, "Cannot find any XMPPServiceDomain by MultiUserChatManager on connection: " + getConnectionMessage(connection)).build()).     }     return room + "@" + xmppServiceDomains.iterator().next(). }
false;public;0;3;;public String getConnectionDescription() {     return host + ":" + port + "/" + serviceName. }
false;public,static;1;3;;public static String getConnectionMessage(XMPPConnection connection) {     return connection.getHost() + ":" + connection.getPort() + "/" + connection.getXMPPServiceDomain(). }
false;public;0;3;;public String getChatId() {     return "Chat:" + getParticipant() + ":" + getUser(). }
true;public;0;6;// ------------------------------------------------------------------------- ;// Properties // ------------------------------------------------------------------------- public XmppBinding getBinding() {     if (binding == null) {         binding = new XmppBinding(headerFilterStrategy).     }     return binding. }
true;public;1;3;/**  * Sets the binding used to convert from a Camel message to and from an XMPP  * message  */ ;/**  * Sets the binding used to convert from a Camel message to and from an XMPP  * message  */ public void setBinding(XmppBinding binding) {     this.binding = binding. }
false;public;0;3;;public String getHost() {     return host. }
true;public;1;3;/**  * Hostname for the chat server  */ ;/**  * Hostname for the chat server  */ public void setHost(String host) {     this.host = host. }
false;public;0;3;;public int getPort() {     return port. }
true;public;1;3;/**  * Port number for the chat server  */ ;/**  * Port number for the chat server  */ public void setPort(int port) {     this.port = port. }
false;public;0;3;;public String getUser() {     return user. }
true;public;1;3;/**  * User name (without server name). If not specified, anonymous login will be attempted.  */ ;/**  * User name (without server name). If not specified, anonymous login will be attempted.  */ public void setUser(String user) {     this.user = user. }
false;public;0;3;;public String getPassword() {     return password. }
true;public;1;3;/**  * Password for login  */ ;/**  * Password for login  */ public void setPassword(String password) {     this.password = password. }
false;public;0;3;;public String getResource() {     return resource. }
true;public;1;3;/**  * XMPP resource. The default is Camel.  */ ;/**  * XMPP resource. The default is Camel.  */ public void setResource(String resource) {     this.resource = resource. }
false;public;0;3;;public boolean isLogin() {     return login. }
true;public;1;3;/**  * Whether to login the user.  */ ;/**  * Whether to login the user.  */ public void setLogin(boolean login) {     this.login = login. }
false;public;0;3;;public boolean isCreateAccount() {     return createAccount. }
true;public;1;3;/**  * If true, an attempt to create an account will be made. Default is false.  */ ;/**  * If true, an attempt to create an account will be made. Default is false.  */ public void setCreateAccount(boolean createAccount) {     this.createAccount = createAccount. }
false;public;0;3;;public String getRoom() {     return room. }
true;public;1;3;/**  * If this option is specified, the component will connect to MUC (Multi User Chat).  * Usually, the domain name for MUC is different from the login domain.  * For example, if you are superman@jabber.org and want to join the krypton room, then the room URL is  * krypton@conference.jabber.org. Note the conference part.  * It is not a requirement to provide the full room JID. If the room parameter does not contain the @ symbol,  * the domain part will be discovered and added by Camel  */ ;/**  * If this option is specified, the component will connect to MUC (Multi User Chat).  * Usually, the domain name for MUC is different from the login domain.  * For example, if you are superman@jabber.org and want to join the krypton room, then the room URL is  * krypton@conference.jabber.org. Note the conference part.  * It is not a requirement to provide the full room JID. If the room parameter does not contain the @ symbol,  * the domain part will be discovered and added by Camel  */ public void setRoom(String room) {     this.room = room. }
false;public;0;4;;public String getParticipant() {     // participant is optional so use user if not provided     return participant != null ? participant : user. }
true;public;1;3;/**  * JID (Jabber ID) of person to receive messages. room parameter has precedence over participant.  */ ;/**  * JID (Jabber ID) of person to receive messages. room parameter has precedence over participant.  */ public void setParticipant(String participant) {     this.participant = participant. }
false;public;0;3;;public String getNickname() {     return nickname != null ? nickname : getUser(). }
true;public;1;3;/**  * Use nickname when joining room. If room is specified and nickname is not, user will be used for the nickname.  */ ;/**  * Use nickname when joining room. If room is specified and nickname is not, user will be used for the nickname.  */ public void setNickname(String nickname) {     this.nickname = nickname. }
true;public;1;3;/**  * The name of the service you are connecting to. For Google Talk, this would be gmail.com.  */ ;/**  * The name of the service you are connecting to. For Google Talk, this would be gmail.com.  */ public void setServiceName(String serviceName) {     this.serviceName = serviceName. }
false;public;0;3;;public String getServiceName() {     return serviceName. }
false;public;0;3;;public HeaderFilterStrategy getHeaderFilterStrategy() {     return headerFilterStrategy. }
true;public;1;3;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ ;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {     this.headerFilterStrategy = headerFilterStrategy. }
false;public;0;3;;public ConnectionConfiguration getConnectionConfig() {     return connectionConfig. }
true;public;1;3;/**  * To use an existing connection configuration. Currently {@link org.jivesoftware.smack.tcp.XMPPTCPConnectionConfiguration} is only supported (XMPP over TCP).  */ ;/**  * To use an existing connection configuration. Currently {@link org.jivesoftware.smack.tcp.XMPPTCPConnectionConfiguration} is only supported (XMPP over TCP).  */ public void setConnectionConfig(ConnectionConfiguration connectionConfig) {     this.connectionConfig = connectionConfig. }
false;public;0;3;;public boolean isTestConnectionOnStartup() {     return testConnectionOnStartup. }
true;public;1;3;/**  * Specifies whether to test the connection on startup. This is used to ensure that the XMPP client has a valid  * connection to the XMPP server when the route starts. Camel throws an exception on startup if a connection  * cannot be established. When this option is set to false, Camel will attempt to establish a "lazy" connection  * when needed by a producer, and will poll for a consumer connection until the connection is established. Default is true.  */ ;/**  * Specifies whether to test the connection on startup. This is used to ensure that the XMPP client has a valid  * connection to the XMPP server when the route starts. Camel throws an exception on startup if a connection  * cannot be established. When this option is set to false, Camel will attempt to establish a "lazy" connection  * when needed by a producer, and will poll for a consumer connection until the connection is established. Default is true.  */ public void setTestConnectionOnStartup(boolean testConnectionOnStartup) {     this.testConnectionOnStartup = testConnectionOnStartup. }
false;public;0;3;;public int getConnectionPollDelay() {     return connectionPollDelay. }
true;public;1;3;/**  * The amount of time in seconds between polls (in seconds) to verify the health of the XMPP connection, or between attempts  * to establish an initial consumer connection. Camel will try to re-establish a connection if it has become inactive.  * Default is 10 seconds.  */ ;/**  * The amount of time in seconds between polls (in seconds) to verify the health of the XMPP connection, or between attempts  * to establish an initial consumer connection. Camel will try to re-establish a connection if it has become inactive.  * Default is 10 seconds.  */ public void setConnectionPollDelay(int connectionPollDelay) {     this.connectionPollDelay = connectionPollDelay. }
true;public;1;6;/**  * Accept pubsub packets on input, default is false  */ ;/**  * Accept pubsub packets on input, default is false  */ public void setPubsub(boolean pubsub) {     this.pubsub = pubsub.     if (pubsub) {         setDoc(true).     } }
false;public;0;3;;public boolean isPubsub() {     return pubsub. }
true;public;1;3;/**  * Set a doc header on the IN message containing a Document form of the incoming packet.  * default is true if presence or pubsub are true, otherwise false  */ ;/**  * Set a doc header on the IN message containing a Document form of the incoming packet.  * default is true if presence or pubsub are true, otherwise false  */ public void setDoc(boolean doc) {     this.doc = doc. }
false;public;0;3;;public boolean isDoc() {     return doc. }
false;protected;0;8;;// Implementation methods // ------------------------------------------------------------------------- @Override protected void doStop() throws Exception {     if (connection != null) {         connection.disconnect().     }     connection = null.     binding = null. }
