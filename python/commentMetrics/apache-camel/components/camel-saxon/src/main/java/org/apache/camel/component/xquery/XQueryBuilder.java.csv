commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "XQuery[" + expression + "]". }
false;public;1;7;;public void process(Exchange exchange) throws Exception {     Object body = evaluate(exchange).     exchange.getOut().setBody(body).     // propagate headers     exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders()). }
false;public;2;4;;public <T> T evaluate(Exchange exchange, Class<T> type) {     Object result = evaluate(exchange).     return exchange.getContext().getTypeConverter().convertTo(type, result). }
false;public;1;34;;public Object evaluate(Exchange exchange) {     try {         LOG.debug("Evaluation: {} for exchange: {}", expression, exchange).         if (resultType != null) {             if (resultType.equals(String.class)) {                 return evaluateAsString(exchange).             } else if (resultType.isAssignableFrom(Collection.class)) {                 return evaluateAsList(exchange).             } else if (resultType.isAssignableFrom(Node.class)) {                 return evaluateAsDOM(exchange).             } else {                 throw new IllegalArgumentException("ResultType: " + resultType.getCanonicalName() + " not supported").             }         }         switch(resultsFormat) {             case Bytes:                 return evaluateAsBytes(exchange).             case BytesSource:                 return evaluateAsBytesSource(exchange).             case DOM:                 return evaluateAsDOM(exchange).             case List:                 return evaluateAsList(exchange).             case StringSource:                 return evaluateAsStringSource(exchange).             case String:             default:                 return evaluateAsString(exchange).         }     } catch (Exception e) {         throw new RuntimeExpressionException(e).     } }
false;public;1;6;;public List<?> evaluateAsList(Exchange exchange) throws Exception {     LOG.debug("evaluateAsList: {} for exchange: {}", expression, exchange).     initialize(exchange).     return getExpression().evaluate(createDynamicContext(exchange)). }
false;public;1;7;;public Object evaluateAsStringSource(Exchange exchange) throws Exception {     LOG.debug("evaluateAsString: {} for exchange: {}", expression, exchange).     initialize(exchange).     String text = evaluateAsString(exchange).     return new StringSource(text). }
false;public;1;7;;public Object evaluateAsBytesSource(Exchange exchange) throws Exception {     LOG.debug("evaluateAsBytesSource: {} for exchange: {}", expression, exchange).     initialize(exchange).     byte[] bytes = evaluateAsBytes(exchange).     return new BytesSource(bytes). }
false;public;1;10;;public Node evaluateAsDOM(Exchange exchange) throws Exception {     LOG.debug("evaluateAsDOM: {} for exchange: {}", expression, exchange).     initialize(exchange).     DOMResult result = new DOMResult().     DynamicQueryContext context = createDynamicContext(exchange).     XQueryExpression expression = getExpression().     expression.pull(context, result, properties).     return result.getNode(). }
false;public;1;12;;public byte[] evaluateAsBytes(Exchange exchange) throws Exception {     LOG.debug("evaluateAsBytes: {} for exchange: {}", expression, exchange).     initialize(exchange).     ByteArrayOutputStream buffer = new ByteArrayOutputStream().     Result result = new StreamResult(buffer).     getExpression().pull(createDynamicContext(exchange), result, properties).     byte[] answer = buffer.toByteArray().     buffer.close().     return answer. }
false;public;1;14;;public String evaluateAsString(Exchange exchange) throws Exception {     LOG.debug("evaluateAsString: {} for exchange: {}", expression, exchange).     initialize(exchange).     StringWriter buffer = new StringWriter().     SequenceIterator iter = getExpression().iterator(createDynamicContext(exchange)).     for (Item item = iter.next(). item != null. item = iter.next()) {         buffer.append(item.getStringValueCS()).     }     String answer = buffer.toString().     buffer.close().     return answer. }
false;public;1;9;;public boolean matches(Exchange exchange) {     LOG.debug("Matches: {} for exchange: {}", expression, exchange).     try {         List<?> list = evaluateAsList(exchange).         return matches(exchange, list).     } catch (Exception e) {         throw new RuntimeExpressionException(e).     } }
false;public;2;14;;@Deprecated public void assertMatches(String text, Exchange exchange) throws AssertionError {     List<?> list.     try {         list = evaluateAsList(exchange).     } catch (Exception e) {         throw new AssertionError(e).     }     if (!matches(exchange, list)) {         throw new AssertionError(this + " failed on " + exchange + " as evaluated: " + list).     } }
false;protected;1;4;;protected XQueryExpression createQueryExpression(StaticQueryContext staticQueryContext) throws XPathException {     return staticQueryContext.compileQuery(queryText). }
true;public,static;1;8;// ------------------------------------------------------------------------- ;// Static helper methods // ------------------------------------------------------------------------- public static XQueryBuilder xquery(final String queryText) {     return new XQueryBuilder() {          protected XQueryExpression createQueryExpression(StaticQueryContext staticQueryContext) throws XPathException {             return staticQueryContext.compileQuery(queryText).         }     }. }
false;protected;1;4;;protected XQueryExpression createQueryExpression(StaticQueryContext staticQueryContext) throws XPathException, IOException {     return staticQueryContext.compileQuery(reader). }
false;public,static;1;8;;public static XQueryBuilder xquery(final Reader reader) {     return new XQueryBuilder() {          protected XQueryExpression createQueryExpression(StaticQueryContext staticQueryContext) throws XPathException, IOException {             return staticQueryContext.compileQuery(reader).         }     }. }
false;protected;1;4;;protected XQueryExpression createQueryExpression(StaticQueryContext staticQueryContext) throws XPathException, IOException {     return staticQueryContext.compileQuery(in, characterSet). }
false;public,static;2;8;;public static XQueryBuilder xquery(final InputStream in, final String characterSet) {     return new XQueryBuilder() {          protected XQueryExpression createQueryExpression(StaticQueryContext staticQueryContext) throws XPathException, IOException {             return staticQueryContext.compileQuery(in, characterSet).         }     }. }
false;public,static;2;3;;public static XQueryBuilder xquery(File file, String characterSet) throws IOException {     return xquery(IOConverter.toInputStream(file), characterSet). }
false;public,static;2;3;;public static XQueryBuilder xquery(URL url, String characterSet) throws IOException {     return xquery(IOConverter.toInputStream(url), characterSet). }
false;public,static;1;3;;public static XQueryBuilder xquery(File file) throws IOException {     return xquery(IOConverter.toInputStream(file), ObjectHelper.getDefaultCharacterSet()). }
false;public,static;1;3;;public static XQueryBuilder xquery(URL url) throws IOException {     return xquery(IOConverter.toInputStream(url), ObjectHelper.getDefaultCharacterSet()). }
true;public;2;4;// ------------------------------------------------------------------------- ;// Fluent API // ------------------------------------------------------------------------- public XQueryBuilder parameter(String name, Object value) {     parameters.put(name, value).     return this. }
false;public;2;6;;public XQueryBuilder namespace(String prefix, String uri) {     namespacePrefixes.put(prefix, uri).     // more namespace, we must re initialize     initialized.set(false).     return this. }
false;public;1;4;;public XQueryBuilder resultType(Class<?> resultType) {     setResultType(resultType).     return this. }
false;public;0;4;;public XQueryBuilder asBytes() {     setResultsFormat(ResultFormat.Bytes).     return this. }
false;public;0;4;;public XQueryBuilder asBytesSource() {     setResultsFormat(ResultFormat.BytesSource).     return this. }
false;public;0;4;;public XQueryBuilder asDOM() {     setResultsFormat(ResultFormat.DOM).     return this. }
false;public;0;4;;public XQueryBuilder asDOMSource() {     setResultsFormat(ResultFormat.DOMSource).     return this. }
false;public;0;4;;public XQueryBuilder asList() {     setResultsFormat(ResultFormat.List).     return this. }
false;public;0;4;;public XQueryBuilder asString() {     setResultsFormat(ResultFormat.String).     return this. }
false;public;0;4;;public XQueryBuilder asStringSource() {     setResultsFormat(ResultFormat.StringSource).     return this. }
false;public;0;4;;public XQueryBuilder stripsAllWhiteSpace() {     setStripsAllWhiteSpace(true).     return this. }
false;public;0;4;;public XQueryBuilder stripsIgnorableWhiteSpace() {     setStripsAllWhiteSpace(false).     return this. }
true;public;0;4;/**  * Enables to allow using StAX.  * <p/>  * When enabled StAX is preferred as the first choice as {@link Source}.  */ ;/**  * Enables to allow using StAX.  * <p/>  * When enabled StAX is preferred as the first choice as {@link Source}.  */ public XQueryBuilder allowStAX() {     setAllowStAX(true).     return this. }
true;public;1;5;/**  * Configures the namespace context from the given DOM element  */ ;// Properties // ------------------------------------------------------------------------- /**  * Configures the namespace context from the given DOM element  */ public void setNamespaces(Map<String, String> namespaces) {     namespacePrefixes.putAll(namespaces).     // more namespace, we must re initialize     initialized.set(false). }
false;public;0;3;;public Map<String, String> getNamespaces() {     return namespacePrefixes. }
false;public;0;3;;public XQueryExpression getExpression() throws IOException, XPathException {     return expression. }
false;public;0;3;;public Configuration getConfiguration() {     return configuration. }
false;public;1;5;;public void setConfiguration(Configuration configuration) {     this.configuration = configuration.     // change configuration, we must re initialize     initialized.set(false). }
false;public;0;3;;public Map<String, Object> getConfigurationProperties() {     return configurationProperties. }
false;public;1;5;;public void setConfigurationProperties(Map<String, Object> configurationProperties) {     this.configurationProperties = Collections.unmodifiableMap(new HashMap<>(configurationProperties)).     // change configuration, we must re initialize     initialized.set(false). }
false;public;0;3;;public StaticQueryContext getStaticQueryContext() {     return staticQueryContext. }
false;public;1;5;;public void setStaticQueryContext(StaticQueryContext staticQueryContext) {     this.staticQueryContext = staticQueryContext.     // change context, we must re initialize     initialized.set(false). }
false;public;0;3;;public Map<String, Object> getParameters() {     return parameters. }
false;public;1;3;;public void setParameters(Map<String, Object> parameters) {     this.parameters = parameters. }
false;public;0;3;;public Properties getProperties() {     return properties. }
false;public;1;3;;public void setProperties(Properties properties) {     this.properties = properties. }
false;public;0;3;;public ResultFormat getResultsFormat() {     return resultsFormat. }
false;public;1;3;;public void setResultsFormat(ResultFormat resultsFormat) {     this.resultsFormat = resultsFormat. }
false;public;0;3;;public Class<?> getResultType() {     return resultType. }
false;public;1;3;;public void setResultType(Class<?> resultType) {     this.resultType = resultType. }
false;public;0;3;;public ModuleURIResolver getModuleURIResolver() {     return moduleURIResolver. }
false;public;1;3;;public void setModuleURIResolver(ModuleURIResolver moduleURIResolver) {     this.moduleURIResolver = moduleURIResolver. }
false;public;0;3;;public boolean isStripsAllWhiteSpace() {     return stripsAllWhiteSpace. }
false;public;1;3;;public void setStripsAllWhiteSpace(boolean stripsAllWhiteSpace) {     this.stripsAllWhiteSpace = stripsAllWhiteSpace. }
false;public;0;3;;public String getHeaderName() {     return headerName. }
false;public;1;3;;public void setHeaderName(String headerName) {     this.headerName = headerName. }
false;public;0;3;;public boolean isAllowStAX() {     return allowStAX. }
false;public;1;3;;public void setAllowStAX(boolean allowStAX) {     this.allowStAX = allowStAX. }
true;protected,abstract;1;2;/**  * A factory method to create the XQuery expression  */ ;// Implementation methods // ------------------------------------------------------------------------- /**  * A factory method to create the XQuery expression  */ protected abstract XQueryExpression createQueryExpression(StaticQueryContext staticQueryContext) throws XPathException, IOException.
true;protected;1;67;/**  * Creates a dynamic context for the given exchange  */ ;/**  * Creates a dynamic context for the given exchange  */ protected DynamicQueryContext createDynamicContext(Exchange exchange) throws Exception {     Configuration config = getConfiguration().     DynamicQueryContext dynamicQueryContext = new DynamicQueryContext(config).     Message in = exchange.getIn().     Item item = null.     if (ObjectHelper.isNotEmpty(getHeaderName())) {         item = in.getHeader(getHeaderName(), Item.class).     } else {         item = in.getBody(Item.class).     }     if (item != null) {         dynamicQueryContext.setContextItem(item).     } else {         Object body = null.         if (ObjectHelper.isNotEmpty(getHeaderName())) {             body = in.getHeader(getHeaderName()).         } else {             body = in.getBody().         }         // the underlying input stream, which we need to close to avoid locking files or other resources         InputStream is = null.         try {             Source source.             // only convert to input stream if really needed             if (isInputStreamNeeded(exchange)) {                 if (ObjectHelper.isNotEmpty(getHeaderName())) {                     is = exchange.getIn().getHeader(getHeaderName(), InputStream.class).                 } else {                     is = exchange.getIn().getBody(InputStream.class).                 }                 source = getSource(exchange, is).             } else {                 source = getSource(exchange, body).             }             // special for bean invocation             if (source == null) {                 if (body instanceof BeanInvocation) {                     // if its a null bean invocation then handle that                     BeanInvocation bi = exchange.getContext().getTypeConverter().convertTo(BeanInvocation.class, body).                     if (bi.getArgs() != null && bi.getArgs().length == 1 && bi.getArgs()[0] == null) {                         // its a null argument from the bean invocation so use null as answer                         source = null.                     }                 }             }             if (source == null) {                 // indicate it was not possible to convert to a Source type                 throw new NoTypeConversionAvailableException(body, Source.class).             }             DocumentInfo doc = config.buildDocument(source).             dynamicQueryContext.setContextItem(doc).         } finally {             // can deal if is is null             IOHelper.close(is).         }     }     configureQuery(dynamicQueryContext, exchange).     // call the reset if the in message body is StreamCache     MessageHelper.resetStreamCache(exchange.getIn()).     return dynamicQueryContext. }
true;protected;1;19;/**  * Checks whether we need an {@link InputStream} to access the message body.  * <p/>  * Depending on the content in the message body, we may not need to convert  * to {@link InputStream}.  *  * @param exchange the current exchange  * @return <tt>true</tt> to convert to {@link InputStream} beforehand converting to {@link Source} afterwards.  */ ;/**  * Checks whether we need an {@link InputStream} to access the message body.  * <p/>  * Depending on the content in the message body, we may not need to convert  * to {@link InputStream}.  *  * @param exchange the current exchange  * @return <tt>true</tt> to convert to {@link InputStream} beforehand converting to {@link Source} afterwards.  */ protected boolean isInputStreamNeeded(Exchange exchange) {     Object body = exchange.getIn().getBody().     if (body == null) {         return false.     }     if (body instanceof Source) {         return false.     } else if (body instanceof String) {         return false.     } else if (body instanceof byte[]) {         return false.     } else if (body instanceof Node) {         return false.     }     // yes an input stream is needed     return true. }
true;protected;2;24;/**  * Converts the inbound body to a {@link Source}, if the body is <b>not</b> already a {@link Source}.  * <p/>  * This implementation will prefer to source in the following order:  * <ul>  *   <li>StAX - Is StAX is allowed</li>  *   <li>SAX - SAX as 2nd choice</li>  *   <li>Stream - Stream as 3rd choice</li>  *   <li>DOM - DOM as 4th choice</li>  * </ul>  */ ;/**  * Converts the inbound body to a {@link Source}, if the body is <b>not</b> already a {@link Source}.  * <p/>  * This implementation will prefer to source in the following order:  * <ul>  *   <li>StAX - Is StAX is allowed</li>  *   <li>SAX - SAX as 2nd choice</li>  *   <li>Stream - Stream as 3rd choice</li>  *   <li>DOM - DOM as 4th choice</li>  * </ul>  */ protected Source getSource(Exchange exchange, Object body) {     // body may already be a source     if (body instanceof Source) {         return (Source) body.     }     Source source = null.     if (isAllowStAX()) {         source = exchange.getContext().getTypeConverter().tryConvertTo(StAXSource.class, exchange, body).     }     if (source == null) {         // then try SAX         source = exchange.getContext().getTypeConverter().tryConvertTo(SAXSource.class, exchange, body).     }     if (source == null) {         // then try stream         source = exchange.getContext().getTypeConverter().tryConvertTo(StreamSource.class, exchange, body).     }     if (source == null) {         // and fallback to DOM         source = exchange.getContext().getTypeConverter().tryConvertTo(DOMSource.class, exchange, body).     }     return source. }
true;protected;2;24;/**  * Configures the dynamic context with exchange specific parameters  */ ;/**  * Configures the dynamic context with exchange specific parameters  */ protected void configureQuery(DynamicQueryContext dynamicQueryContext, Exchange exchange) throws Exception {     addParameters(dynamicQueryContext, exchange.getProperties()).     addParameters(dynamicQueryContext, exchange.getIn().getHeaders(), "in.headers.").     dynamicQueryContext.setParameter(StructuredQName.fromClarkName("in.body"), getAsParameter(exchange.getIn().getBody())).     addParameters(dynamicQueryContext, getParameters()).     dynamicQueryContext.setParameter(StructuredQName.fromClarkName("exchange"), getAsParameter(exchange)).     if (exchange.hasOut() && exchange.getPattern().isOutCapable()) {         dynamicQueryContext.setParameter(StructuredQName.fromClarkName("out.body"), getAsParameter(exchange.getOut().getBody())).         addParameters(dynamicQueryContext, exchange.getOut().getHeaders(), "out.headers.").     } }
false;protected;2;3;;protected void addParameters(DynamicQueryContext dynamicQueryContext, Map<String, Object> map) {     addParameters(dynamicQueryContext, map, ""). }
false;protected;3;12;;protected void addParameters(DynamicQueryContext dynamicQueryContext, Map<String, Object> map, String parameterPrefix) {     Set<Map.Entry<String, Object>> propertyEntries = map.entrySet().     for (Map.Entry<String, Object> entry : propertyEntries) {         // skip headers with null values         if (entry.getValue() != null) {             dynamicQueryContext.setParameter(StructuredQName.fromClarkName(parameterPrefix + entry.getKey()), getAsParameter(entry.getValue())).         }     } }
false;protected;1;18;;@SuppressWarnings("unchecked") protected Item getAsParameter(Object value) {     if (value instanceof String) {         return new StringValue((CharSequence) value).     } else if (value instanceof Boolean) {         return BooleanValue.get((Boolean) value).     } else if (value instanceof Long) {         return Int64Value.makeIntegerValue((Long) value).     } else if (value instanceof BigInteger) {         return IntegerValue.makeIntegerValue((BigInteger) value).     } else if (value instanceof Double) {         return DoubleValue.makeDoubleValue((double) value).     } else if (value instanceof Float) {         return FloatValue.makeFloatValue((float) value).     } else {         return new ObjectValue(value).     } }
false;protected;2;3;;protected boolean matches(Exchange exchange, List<?> results) {     return ObjectHelper.matches(results). }
true;protected,synchronized;1;43;/**  * Initializes this builder - <b>Must be invoked before evaluation</b>.  */ ;/**  * Initializes this builder - <b>Must be invoked before evaluation</b>.  */ protected synchronized void initialize(Exchange exchange) throws XPathException, IOException {     // must use synchronized for concurrency issues and only let it initialize once     if (!initialized.get()) {         LOG.debug("Initializing XQueryBuilder {}", this).         if (configuration == null) {             configuration = new Configuration().             configuration.getParseOptions().setSpaceStrippingRule(isStripsAllWhiteSpace() ? AllElementsSpaceStrippingRule.getInstance() : IgnorableSpaceStrippingRule.getInstance()).             LOG.debug("Created new Configuration {}", configuration).         } else {             LOG.debug("Using existing Configuration {}", configuration).         }         if (configurationProperties != null && !configurationProperties.isEmpty()) {             for (Map.Entry<String, Object> entry : configurationProperties.entrySet()) {                 configuration.setConfigurationProperty(entry.getKey(), entry.getValue()).             }         }         staticQueryContext = getConfiguration().newStaticQueryContext().         if (moduleURIResolver != null) {             staticQueryContext.setModuleURIResolver(moduleURIResolver).         }         Set<Map.Entry<String, String>> entries = namespacePrefixes.entrySet().         for (Map.Entry<String, String> entry : entries) {             String prefix = entry.getKey().             String uri = entry.getValue().             // skip invalid prefix or uri according to XQuery spec             boolean invalid = "xml".equals(prefix) || "xmlns".equals(prefix).             if (!invalid) {                 LOG.debug("Declaring namespace [prefix: {}, uri: {}]", prefix, uri).                 staticQueryContext.declareNamespace(prefix, uri).                 staticQueryContext.setInheritNamespaces(true).             }         }         expression = createQueryExpression(staticQueryContext).         initialized.set(true).     }     // let the configuration be accessible on the exchange as its shared for this evaluation     // and can be needed by 3rd party type converters or other situations (camel-artixds)     exchange.setProperty("CamelSaxonConfiguration", configuration). }
