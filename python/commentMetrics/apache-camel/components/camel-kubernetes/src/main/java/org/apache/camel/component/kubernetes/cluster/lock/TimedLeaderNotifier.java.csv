commented;modifiers;parameterAmount;loc;comment;code
false;public;4;25;;public void refreshLeadership(Optional<String> leader, Long timestamp, Long lease, Set<String> members) {     Objects.requireNonNull(leader, "leader must be non null (use Optional.empty)").     Objects.requireNonNull(members, "members must be non null (use empty set)").     long version.     try {         lock.lock().         this.currentLeader = leader.         this.currentMembers = members.         this.timestamp = timestamp.         this.lease = lease.         version = ++changeCounter.     } finally {         lock.unlock().     }     LOG.debug("Updated leader to {} at version version {}", leader, version).     this.executor.execute(() -> checkAndNotify(version)).     if (leader.isPresent()) {         long time = System.currentTimeMillis().         long delay = Math.max(timestamp + lease + FIXED_DELAY - time, FIXED_DELAY).         LOG.debug("Setting expiration in {} millis for version {}", delay, version).         this.executor.schedule(() -> expiration(version), delay, TimeUnit.MILLISECONDS).     } }
false;public;0;6;;@Override public void start() throws Exception {     if (this.executor == null) {         this.executor = camelContext.getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "CamelKubernetesLeaderNotifier").     } }
false;public;0;10;;@Override public void stop() throws Exception {     if (this.executor != null) {         ScheduledExecutorService executor = this.executor.         this.executor = null.         executor.shutdownNow().         executor.awaitTermination(1, TimeUnit.SECONDS).     } }
false;private;1;21;;private void expiration(long version) {     try {         lock.lock().         if (version != this.changeCounter) {             return.         }         long time = System.currentTimeMillis().         if (time < this.timestamp + this.lease) {             long delay = this.timestamp + this.lease - time.             LOG.debug("Delaying expiration by {} millis at version version {}", delay + FIXED_DELAY, version).             this.executor.schedule(() -> expiration(version), delay + FIXED_DELAY, TimeUnit.MILLISECONDS).             return.         }     } finally {         lock.unlock().     }     checkAndNotify(version). }
false;public;0;4;;@Override public Optional<String> getData() {     return newLeader. }
false;public;0;4;;@Override public Set<String> getData() {     return newMembers. }
false;private;1;57;;private void checkAndNotify(long version) {     Optional<String> leader.     Set<String> members.     try {         lock.lock().         if (version != this.changeCounter) {             return.         }         leader = this.currentLeader.         members = this.currentMembers.         if (leader.isPresent()) {             long time = System.currentTimeMillis().             if (time >= this.timestamp + this.lease) {                 leader = Optional.empty().             }         }     } finally {         lock.unlock().     }     final Optional<String> newLeader = leader.     if (!newLeader.equals(lastCommunicatedLeader)) {         lastCommunicatedLeader = newLeader.         LOG.info("The cluster has a new leader: {}", newLeader).         try {             handler.onKubernetesClusterEvent(new KubernetesClusterEvent.KubernetesClusterLeaderChangedEvent() {                  @Override                 public Optional<String> getData() {                     return newLeader.                 }             }).         } catch (Throwable t) {             LOG.warn("Error while communicating the new leader to the handler", t).         }     }     final Set<String> newMembers = members.     if (!newMembers.equals(lastCommunicatedMembers)) {         lastCommunicatedMembers = newMembers.         LOG.info("The list of cluster members has changed: {}", newMembers).         try {             handler.onKubernetesClusterEvent(new KubernetesClusterEvent.KubernetesClusterMemberListChangedEvent() {                  @Override                 public Set<String> getData() {                     return newMembers.                 }             }).         } catch (Throwable t) {             LOG.warn("Error while communicating the cluster members to the handler", t).         }     } }
