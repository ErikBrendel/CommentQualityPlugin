commented;modifiers;parameterAmount;loc;comment;code
false;public;1;14;;public Object addingService(ServiceReference<TypeConverterLoader> serviceReference) {     LOG.trace("AddingService: {}, Bundle: {}", serviceReference, serviceReference.getBundle()).     TypeConverterLoader loader = bundleContext.getService(serviceReference).     try {         LOG.debug("loading type converter from bundle: {}", serviceReference.getBundle().getSymbolicName()).         if (delegate != null) {             loader.load(delegate).         }     } catch (Throwable t) {         throw new RuntimeCamelException("Error loading type converters from service: " + serviceReference + " due: " + t.getMessage(), t).     }     return loader. }
false;public;2;2;;public void modifiedService(ServiceReference<TypeConverterLoader> serviceReference, Object o) { }
false;public;2;13;;public void removedService(ServiceReference<TypeConverterLoader> serviceReference, Object o) {     LOG.trace("RemovedService: {}, Bundle: {}", serviceReference, serviceReference.getBundle()).     try {         ServiceHelper.stopService(this.delegate).     } catch (Exception e) {         // ignore         LOG.debug("Error stopping service due: " + e.getMessage() + ". This exception will be ignored.", e).     }     // It can force camel to reload the type converter again     this.delegate = null. // TODO: reloading all type converters when one service is removed is suboptimal... }
false;protected;0;4;;@Override protected void doStart() throws Exception {     this.tracker.open(). }
false;protected;0;6;;@Override protected void doStop() throws Exception {     this.tracker.close().     ServiceHelper.stopService(this.delegate).     this.delegate = null. }
false;public;0;3;;public boolean allowNull() {     return getDelegate().allowNull(). }
false;public;2;3;;public <T> T convertTo(Class<T> type, Object value) {     return getDelegate().convertTo(type, value). }
false;public;3;3;;public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {     return getDelegate().convertTo(type, exchange, value). }
false;public;2;3;;public <T> T mandatoryConvertTo(Class<T> type, Object value) throws NoTypeConversionAvailableException {     return getDelegate().mandatoryConvertTo(type, value). }
false;public;3;3;;public <T> T mandatoryConvertTo(Class<T> type, Exchange exchange, Object value) throws NoTypeConversionAvailableException {     return getDelegate().mandatoryConvertTo(type, exchange, value). }
false;public;3;3;;public <T> T tryConvertTo(Class<T> type, Exchange exchange, Object value) {     return getDelegate().tryConvertTo(type, exchange, value). }
false;public;2;3;;public <T> T tryConvertTo(Class<T> type, Object value) {     return getDelegate().tryConvertTo(type, value). }
false;public;3;3;;public void addTypeConverter(Class<?> toType, Class<?> fromType, TypeConverter typeConverter) {     getDelegate().addTypeConverter(toType, fromType, typeConverter). }
false;public;1;3;;public void addTypeConverters(TypeConverters typeConverters) {     getDelegate().addTypeConverters(typeConverters). }
false;public;2;3;;public boolean removeTypeConverter(Class<?> toType, Class<?> fromType) {     return getDelegate().removeTypeConverter(toType, fromType). }
false;public;2;3;;public void addFallbackTypeConverter(TypeConverter typeConverter, boolean canPromote) {     getDelegate().addFallbackTypeConverter(typeConverter, canPromote). }
false;public;2;3;;public TypeConverter lookup(Class<?> toType, Class<?> fromType) {     return getDelegate().lookup(toType, fromType). }
false;public;0;3;;public List<Class<?>[]> listAllTypeConvertersFromTo() {     return getDelegate().listAllTypeConvertersFromTo(). }
false;public;1;3;;public void setInjector(Injector injector) {     getDelegate().setInjector(injector). }
false;public;0;3;;public Injector getInjector() {     return getDelegate().getInjector(). }
false;public;0;3;;public Statistics getStatistics() {     return getDelegate().getStatistics(). }
false;public;0;3;;public int size() {     return getDelegate().size(). }
false;public;0;3;;public LoggingLevel getTypeConverterExistsLoggingLevel() {     return getDelegate().getTypeConverterExistsLoggingLevel(). }
false;public;1;3;;public void setTypeConverterExistsLoggingLevel(LoggingLevel loggingLevel) {     getDelegate().setTypeConverterExistsLoggingLevel(loggingLevel). }
false;public;0;3;;public TypeConverterExists getTypeConverterExists() {     return getDelegate().getTypeConverterExists(). }
false;public;1;3;;public void setTypeConverterExists(TypeConverterExists typeConverterExists) {     getDelegate().setTypeConverterExists(typeConverterExists). }
false;public,synchronized;0;6;;public synchronized DefaultTypeConverter getDelegate() {     if (delegate == null) {         delegate = createRegistry().     }     return delegate. }
false;public;0;5;;@Override public Set<ClassLoader> getClassLoaders() {     // we don't need any classloaders as we use OSGi service tracker instead     return Collections.emptySet(). }
false;protected;0;42;;protected DefaultTypeConverter createRegistry() {     // base the osgi type converter on the default type converter     DefaultTypeConverter answer = new DefaultTypeConverter(new DefaultPackageScanClassResolver() {          @Override         public Set<ClassLoader> getClassLoaders() {             // we don't need any classloaders as we use OSGi service tracker instead             return Collections.emptySet().         }     }, injector, factoryFinder, false).     // inject CamelContext     answer.setCamelContext(camelContext).     try {         // only load the core type converters, as OSGi activator will keep track on bundles         // being installed/uninstalled and load type converters as part of that process         answer.loadCoreTypeConverters().     } catch (Exception e) {         throw new RuntimeCamelException("Error loading CoreTypeConverter due: " + e.getMessage(), e).     }     // Load the type converters the tracker has been tracking     // Here we need to use the ServiceReference to check the ranking     ServiceReference<TypeConverterLoader>[] serviceReferences = this.tracker.getServiceReferences().     if (serviceReferences != null) {         ArrayList<ServiceReference<TypeConverterLoader>> servicesList = new ArrayList<>(Arrays.asList(serviceReferences)).         // Just make sure we install the high ranking fallback converter at last         Collections.sort(servicesList).         for (ServiceReference<TypeConverterLoader> sr : servicesList) {             try {                 LOG.debug("loading type converter from bundle: {}", sr.getBundle().getSymbolicName()).                 ((TypeConverterLoader) this.tracker.getService(sr)).load(answer).             } catch (Throwable t) {                 throw new RuntimeCamelException("Error loading type converters from service: " + sr + " due: " + t.getMessage(), t).             }         }     }     LOG.trace("Created TypeConverter: {}", answer).     return answer. }
