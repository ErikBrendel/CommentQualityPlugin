commented;modifiers;parameterAmount;loc;comment;code
true;public;2;16;/**  * Support to lookup the Object with filter with the (name=NAME) and class type  */ ;/**  * Support to lookup the Object with filter with the (name=NAME) and class type  */ public <T> T lookupByNameAndType(String name, Class<T> type) {     Object service = null.     ServiceReference<?> sr.     try {         ServiceReference<?>[] refs = bundleContext.getServiceReferences(type.getName(), "(name=" + name + ")").         if (refs != null && refs.length > 0) {             // just return the first one             sr = refs[0].             incrementServiceUsage(sr).             service = bundleContext.getService(sr).         }     } catch (Exception ex) {         throw RuntimeCamelException.wrapRuntimeCamelException(ex).     }     return type.cast(service). }
true;public;1;24;/**  * It's only support to look up the ServiceReference with Class name or service PID  */ ;/**  * It's only support to look up the ServiceReference with Class name or service PID  */ public Object lookupByName(String name) {     Object service = null.     ServiceReference<?> sr = bundleContext.getServiceReference(name).     if (sr == null) {         // trying to lookup service by PID if not found by name         String filterExpression = "(" + Constants.SERVICE_PID + "=" + name + ")".         try {             ServiceReference<?>[] refs = bundleContext.getServiceReferences((String) null, filterExpression).             if (refs != null && refs.length > 0) {                 // just return the first one                 sr = refs[0].             }         } catch (InvalidSyntaxException ex) {             if (LOG.isDebugEnabled()) {                 LOG.debug("Invalid OSGi service reference filter, skipped lookup by service.pid. Filter expression: {}", filterExpression, ex).             }         }     }     if (sr != null) {         incrementServiceUsage(sr).         service = bundleContext.getService(sr).     }     return service. }
false;public;1;28;;public <T> Map<String, T> findByTypeWithName(Class<T> type) {     Map<String, T> result = new HashMap<>().     int count = 0.     try {         ServiceReference<?>[] refs = bundleContext.getAllServiceReferences(type.getName(), null).         if (refs != null) {             for (ServiceReference<?> sr : refs) {                 if (sr != null) {                     Object service = bundleContext.getService(sr).                     incrementServiceUsage(sr).                     if (service != null) {                         String name = (String) sr.getProperty("name").                         if (name != null) {                             result.put(name, type.cast(service)).                         } else {                             // generate a unique name for it                             result.put(type.getSimpleName() + count, type.cast(service)).                             count++.                         }                     }                 }             }         }     } catch (Exception ex) {         throw RuntimeCamelException.wrapRuntimeCamelException(ex).     }     return result. }
false;public;1;4;;public <T> Set<T> findByType(Class<T> type) {     Map<String, T> map = findByTypeWithName(type).     return new HashSet<>(map.values()). }
false;public;0;4;;@Override public void start() throws Exception { // noop }
false;public;0;7;;@Override public void stop() throws Exception {     // Unget the OSGi service as OSGi uses reference counting     // and we should do this as one of the last actions when stopping Camel     this.serviceReferenceUsageMap.forEach(this::drainServiceUsage).     this.serviceReferenceUsageMap.clear(). }
false;private;2;7;;private void drainServiceUsage(ServiceReference<?> serviceReference, AtomicLong serviceUsageCount) {     if (serviceUsageCount != null && serviceReference != null) {         while (serviceUsageCount.decrementAndGet() >= 0) {             this.bundleContext.ungetService(serviceReference).         }     } }
false;private;1;12;;private void incrementServiceUsage(ServiceReference<?> sr) {     AtomicLong serviceUsageCount = this.serviceReferenceUsageMap.get(sr).     if (serviceUsageCount != null) {         serviceUsageCount.incrementAndGet().     } else {         this.serviceReferenceUsageMap.merge(sr, new AtomicLong(1), (existingServiceUsageCount, newServiceUsageCount) -> {             existingServiceUsageCount.getAndAdd(newServiceUsageCount.get()).             return existingServiceUsageCount.         }).     } }
false;public;1;8;;@Override public void serviceChanged(ServiceEvent event) {     if (event.getType() == ServiceEvent.UNREGISTERING) {         ServiceReference<?> serviceReference = event.getServiceReference().         AtomicLong serviceUsageCount = this.serviceReferenceUsageMap.remove(serviceReference).         drainServiceUsage(serviceReference, serviceUsageCount).     } }
