commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;public void start(BundleContext context) throws Exception {     LOG.info("Camel activator starting").     cachePackageCapabilities(context).     bundleId = context.getBundle().getBundleId().     BundleContext systemBundleContext = context.getBundle(0).getBundleContext().     tracker = new BundleTracker<>(systemBundleContext, Bundle.ACTIVE, this).     tracker.open().     LOG.info("Camel activator started"). }
false;public;1;6;;public void stop(BundleContext context) throws Exception {     LOG.info("Camel activator stopping").     tracker.close().     packageCapabilities.clear().     LOG.info("Camel activator stopped"). }
true;private;1;13;/**  * Caches the package capabilities that are needed for a set of interface classes  */ ;/**  * Caches the package capabilities that are needed for a set of interface classes  */ private void cachePackageCapabilities(BundleContext context) {     BundleWiring ourWiring = context.getBundle().adapt(BundleWiring.class).     List<BundleCapability> ourExports = ourWiring.getCapabilities(PACKAGE_NAMESPACE).     for (BundleCapability ourExport : ourExports) {         String ourPkgName = (String) ourExport.getAttributes().get(PACKAGE_NAMESPACE).         packageCapabilities.put(ourPkgName, ourExport).     }     for (BundleWire w : ourWiring.getRequiredWires(PACKAGE_NAMESPACE)) {         BundleCapability cap = w.getCapability().         String ourPkgName = (String) cap.getAttributes().get(PACKAGE_NAMESPACE).         packageCapabilities.put(ourPkgName, cap).     } }
false;public;2;16;;public Object addingBundle(Bundle bundle, BundleEvent event) {     LOG.debug("Bundle started: {}", bundle.getSymbolicName()).     if (extenderCapabilityWired(bundle)) {         List<BaseService> r = new ArrayList<>().         registerComponents(bundle, r).         registerLanguages(bundle, r).         registerDataFormats(bundle, r).         registerTypeConverterLoader(bundle, r).         for (BaseService service : r) {             service.register().         }         resolvers.put(bundle.getBundleId(), r).     }     return bundle. }
false;private;1;19;;private boolean extenderCapabilityWired(Bundle bundle) {     BundleWiring wiring = bundle.adapt(BundleWiring.class).     if (wiring == null) {         return true.     }     List<BundleWire> requiredWires = wiring.getRequiredWires(EXTENDER_NAMESPACE).     for (BundleWire requiredWire : requiredWires) {         if (CAMEL_EXTENDER.equals(requiredWire.getCapability().getAttributes().get(EXTENDER_NAMESPACE))) {             if (this.bundleId == requiredWire.getProviderWiring().getBundle().getBundleId()) {                 LOG.debug("Camel extender requirement of bundle {} correctly wired to this implementation", bundle.getBundleId()).                 return true.             } else {                 LOG.info("Not processing bundle {} as it requires a camel extender but is not wired to the this implementation", bundle.getBundleId()).                 return false.             }         }     }     return true. }
false;public;3;2;;public void modifiedBundle(Bundle bundle, BundleEvent event, Object object) { }
false;public;3;9;;public void removedBundle(Bundle bundle, BundleEvent event, Object object) {     LOG.debug("Bundle stopped: {}", bundle.getSymbolicName()).     List<BaseService> r = resolvers.remove(bundle.getBundleId()).     if (r != null) {         for (BaseService service : r) {             service.unregister().         }     } }
false;protected;2;14;;protected void registerComponents(Bundle bundle, List<BaseService> resolvers) {     if (canSee(bundle, Component.class)) {         Map<String, String> components = new HashMap<>().         for (Enumeration<?> e = bundle.getEntryPaths(META_INF_COMPONENT). e != null && e.hasMoreElements(). ) {             String path = (String) e.nextElement().             LOG.debug("Found entry: {} in bundle {}", path, bundle.getSymbolicName()).             String name = path.substring(path.lastIndexOf("/") + 1).             components.put(name, path).         }         if (!components.isEmpty()) {             resolvers.add(new BundleComponentResolver(bundle, components)).         }     } }
false;protected;2;20;;protected void registerLanguages(Bundle bundle, List<BaseService> resolvers) {     if (canSee(bundle, Language.class)) {         Map<String, String> languages = new HashMap<>().         for (Enumeration<?> e = bundle.getEntryPaths(META_INF_LANGUAGE). e != null && e.hasMoreElements(). ) {             String path = (String) e.nextElement().             LOG.debug("Found entry: {} in bundle {}", path, bundle.getSymbolicName()).             String name = path.substring(path.lastIndexOf("/") + 1).             languages.put(name, path).         }         if (!languages.isEmpty()) {             resolvers.add(new BundleLanguageResolver(bundle, languages)).         }         for (Enumeration<?> e = bundle.getEntryPaths(META_INF_LANGUAGE_RESOLVER). e != null && e.hasMoreElements(). ) {             String path = (String) e.nextElement().             LOG.debug("Found entry: {} in bundle {}", path, bundle.getSymbolicName()).             String name = path.substring(path.lastIndexOf("/") + 1).             resolvers.add(new BundleMetaLanguageResolver(bundle, name, path)).         }     } }
false;protected;2;14;;protected void registerDataFormats(Bundle bundle, List<BaseService> resolvers) {     if (canSee(bundle, DataFormat.class)) {         Map<String, String> dataformats = new HashMap<>().         for (Enumeration<?> e = bundle.getEntryPaths(META_INF_DATAFORMAT). e != null && e.hasMoreElements(). ) {             String path = (String) e.nextElement().             LOG.debug("Found entry: {} in bundle {}", path, bundle.getSymbolicName()).             String name = path.substring(path.lastIndexOf("/") + 1).             dataformats.put(name, path).         }         if (!dataformats.isEmpty()) {             resolvers.add(new BundleDataFormatResolver(bundle, dataformats)).         }     } }
false;protected;2;10;;protected void registerTypeConverterLoader(Bundle bundle, List<BaseService> resolvers) {     if (canSee(bundle, TypeConverter.class)) {         URL url1 = bundle.getEntry(META_INF_TYPE_CONVERTER).         URL url2 = bundle.getEntry(META_INF_FALLBACK_TYPE_CONVERTER).         if (url1 != null || url2 != null) {             LOG.debug("Found TypeConverter in bundle {}", bundle.getSymbolicName()).             resolvers.add(new BundleTypeConverterLoader(bundle, url2 != null)).         }     } }
true;protected;2;27;/**  * Check if bundle can see the given class  */ ;/**  * Check if bundle can see the given class  */ protected boolean canSee(Bundle bundle, Class<?> clazz) {     if (bundle.getBundleId() == bundleId) {         // Need extra handling of camel core as it does not import the api         return true.     }     BundleCapability packageCap = packageCapabilities.get(clazz.getPackage().getName()).     if (packageCap != null) {         BundleWiring wiring = bundle.adapt(BundleWiring.class).         List<BundleWire> imports = wiring.getRequiredWires(PACKAGE_NAMESPACE).         for (BundleWire importWire : imports) {             if (packageCap.equals(importWire.getCapability())) {                 return true.             }         }     }     // then we need to use a different canSee algorithm that works outside real OSGi     if (bundle.getBundleId() >= 0) {         Bundle root = bundle.getBundleContext().getBundle(0).         if (root != null && "org.apache.felix.connect".equals(root.getSymbolicName())) {             return checkCompat(bundle, clazz).         }     }     return false. }
true;protected,static;2;11;/**  * Check if bundle can see the given class used by camel-test-blueprint  */ ;/**  * Check if bundle can see the given class used by camel-test-blueprint  */ protected static boolean checkCompat(Bundle bundle, Class<?> clazz) {     // Check bundle compatibility     try {         if (bundle.loadClass(clazz.getName()) != clazz) {             return false.         }     } catch (Throwable t) {         return false.     }     return true. }
false;public;2;3;;public Component resolveComponent(String name, CamelContext context) throws Exception {     return createInstance(name, components.get(name), context). }
false;public;0;3;;public void register() {     doRegister(ComponentResolver.class, "component", components.keySet()). }
false;public;2;3;;public Language resolveLanguage(String name, CamelContext context) {     return createInstance(name, languages.get(name), context). }
false;public;0;3;;public void register() {     doRegister(LanguageResolver.class, "language", languages.keySet()). }
false;public;2;4;;public Language resolveLanguage(String name, CamelContext context) {     LanguageResolver resolver = createInstance(this.name, path, context).     return resolver.resolveLanguage(name, context). }
false;public;0;3;;public void register() {     doRegister(LanguageResolver.class, "resolver", name). }
false;public;2;9;;@Override public DataFormat resolveDataFormat(String name, CamelContext context) {     DataFormat dataFormat = createInstance(name, dataformats.get(name), context).     if (dataFormat == null) {         dataFormat = createDataFormat(name, context).     }     return dataFormat. }
false;public;2;4;;@Override public DataFormat createDataFormat(String name, CamelContext context) {     return createInstance(name, dataformats.get(name), context). }
false;public;2;3;;public DataFormatDefinition resolveDataFormatDefinition(String name, CamelContext context) {     return null. }
false;public;0;4;;@Override public void register() {     doRegister(DataFormatResolver.class, "dataformat", dataformats.keySet()). }
false;public,synchronized;1;9;;public synchronized void load(TypeConverterRegistry registry) throws TypeConverterLoaderException {     // which cause Camel apps to fails in OSGi thereafter     try {         loader.load(registry).     } catch (Exception e) {         throw new TypeConverterLoaderException("Cannot load type converters using OSGi bundle: " + bundle.getBundleId(), e).     } }
false;public;0;9;;public void register() {     if (hasFallbackTypeConverter) {         // The FallbackTypeConverter should have a higher ranking         doRegister(TypeConverterLoader.class, Constants.SERVICE_RANKING, 100).     } else {         // The default service ranking is Integer(0).         doRegister(TypeConverterLoader.class).     } }
false;public;1;76;;public void load(TypeConverterRegistry registry) throws TypeConverterLoaderException {     PackageScanFilter test = new AnnotatedWithPackageScanFilter(Converter.class, true).     Set<Class<?>> classes = new LinkedHashSet<>().     Set<String> packages = getConverterPackages(bundle.getEntry(META_INF_TYPE_CONVERTER)).     if (LOG.isTraceEnabled()) {         LOG.trace("Found {} {} packages: {}", packages.size(), META_INF_TYPE_CONVERTER, packages).     }     // META-INF/services in all the JARs.     if (packages.size() == 1 && "org.apache.camel.core".equals(packages.iterator().next())) {         LOG.debug("No additional package names found in classpath for annotated type converters.").         // no additional package names found to load type converters so break out         return.     }     // now filter out org.apache.camel.core as its not needed anymore (it was just a dummy)     packages.remove("org.apache.camel.core").     for (String pkg : packages) {         if (StringHelper.isClassName(pkg)) {             // its a FQN class name so load it directly             LOG.trace("Loading {} class", pkg).             try {                 Class<?> clazz = bundle.loadClass(pkg).                 classes.add(clazz).                 // the class could be found and loaded so continue to next                 continue.             } catch (Throwable t) {                 // Ignore                 LOG.trace("Failed to load " + pkg + " class due " + t.getMessage() + ". This exception will be ignored.", t).             }         }         // its not a FQN but a package name so scan for classes in the bundle         Enumeration<URL> e = bundle.findEntries("/" + pkg.replace('.', '/'), "*.class", true).         while (e != null && e.hasMoreElements()) {             String path = e.nextElement().getPath().             String externalName = path.substring(path.charAt(0) == '/' ? 1 : 0, path.indexOf('.')).replace('/', '.').             LOG.trace("Loading {} class", externalName).             try {                 Class<?> clazz = bundle.loadClass(externalName).                 if (test.matches(clazz)) {                     classes.add(clazz).                 }             } catch (Throwable t) {                 // Ignore                 LOG.trace("Failed to load " + externalName + " class due " + t.getMessage() + ". This exception will be ignored.", t).             }         }     }     // load the classes into type converter registry     LOG.debug("Found {} @Converter classes to load", classes.size()).     for (Class<?> type : classes) {         if (LOG.isTraceEnabled()) {             LOG.trace("Loading converter class: {}", ObjectHelper.name(type)).         }         loadConverterMethods(registry, type).     }     // register fallback converters     URL fallbackUrl = bundle.getEntry(META_INF_FALLBACK_TYPE_CONVERTER).     if (fallbackUrl != null) {         LOG.debug("Found {} to load the FallbackTypeConverter", META_INF_FALLBACK_TYPE_CONVERTER).         TypeConverter tc = createInstance("FallbackTypeConverter", fallbackUrl, registry.getInjector()).         registry.addFallbackTypeConverter(tc, false).     }     // now clear the maps so we do not hold references     visitedClasses.clear().     visitedURIs.clear(). }
false;protected;3;22;;protected T createInstance(String name, String path, CamelContext context) {     if (path == null) {         return null.     }     URL url = bundle.getEntry(path).     LOG.trace("The entry {}'s url is {}", name, url).     // Setup the TCCL with Camel context application class loader     ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader().     try {         ClassLoader newClassLoader = context.getApplicationContextClassLoader().         if (newClassLoader != null) {             Thread.currentThread().setContextClassLoader(newClassLoader).         }         T answer = createInstance(name, url, context.getInjector()).         if (answer != null) {             initBundleContext(answer).         }         return answer.     } finally {         Thread.currentThread().setContextClassLoader(oldClassLoader).     } }
false;private;1;10;;private void initBundleContext(T answer) {     try {         Method method = answer.getClass().getMethod("setBundleContext", BundleContext.class).         if (method != null) {             method.invoke(answer, bundle.getBundleContext()).         }     } catch (Exception e) {     // ignore     } }
false;protected;3;14;;@SuppressWarnings("unchecked") protected T createInstance(String name, URL url, Injector injector) {     try {         Properties properties = loadProperties(url).         String classname = (String) properties.get("class").         Class<?> type = bundle.loadClass(classname).         if (!this.type.isAssignableFrom(type)) {             throw new IllegalArgumentException("Type is not a " + this.type.getName() + " implementation. Found: " + type.getName()).         }         return injector.newInstance((Class<T>) type).     } catch (ClassNotFoundException e) {         throw new IllegalArgumentException("Invalid URI, no " + this.type.getName() + " registered for scheme : " + name, e).     } }
false;public,abstract;0;1;;public abstract void register().
false;protected;3;3;;protected void doRegister(Class<?> type, String key, Collection<String> value) {     doRegister(type, key, value.toArray(new String[value.size()])). }
false;protected;3;5;;protected void doRegister(Class<?> type, String key, Object value) {     Dictionary<String, Object> props = new Hashtable<>().     props.put(key, value).     doRegister(type, props). }
false;protected;1;3;;protected void doRegister(Class<?> type) {     doRegister(type, null). }
false;protected;2;3;;protected void doRegister(Class<?> type, Dictionary<String, ?> props) {     reg = bundle.getBundleContext().registerService(type.getName(), this, props). }
false;public;0;3;;public void unregister() {     reg.unregister(). }
false;protected,static;1;13;;protected static Properties loadProperties(URL url) {     Properties properties = new Properties().     BufferedInputStream reader = null.     try {         reader = IOHelper.buffered(url.openStream()).         properties.load(reader).     } catch (IOException e) {         throw new RuntimeException(e).     } finally {         IOHelper.close(reader, "properties", LOG).     }     return properties. }
false;protected,static;1;31;;protected static Set<String> getConverterPackages(URL resource) {     Set<String> packages = new LinkedHashSet<>().     if (resource != null) {         BufferedReader reader = null.         try {             reader = IOHelper.buffered(new InputStreamReader(resource.openStream())).             while (true) {                 String line = reader.readLine().                 if (line == null) {                     break.                 }                 line = line.trim().                 if (line.startsWith("#") || line.length() == 0) {                     continue.                 }                 StringTokenizer iter = new StringTokenizer(line, ",").                 while (iter.hasMoreTokens()) {                     String name = iter.nextToken().trim().                     if (name.length() > 0) {                         packages.add(name).                     }                 }             }         } catch (Exception ignore) {         // Do nothing here         } finally {             IOHelper.close(reader, null, LOG).         }     }     return packages. }
