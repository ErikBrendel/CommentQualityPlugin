commented;modifiers;parameterAmount;loc;comment;code
false;public;1;24;;@Override public Class<?> resolveClass(String name) {     LOG.trace("Resolve class {}", name).     name = StringHelper.normalizeClassName(name).     if (ObjectHelper.isEmpty(name)) {         return null.     }     // we need to avoid the NPE issue of loading the class     Class<?> clazz = ObjectHelper.loadSimpleType(name).     if (clazz == null) {         clazz = doLoadClass(name, bundleContext.getBundle()).         if (LOG.isTraceEnabled()) {             LOG.trace("Loading class {} using BundleContext {} -> {}", name, bundleContext.getBundle(), clazz).         }     }     if (clazz == null && camelContext != null) {         // fallback and load class using the application context classloader         clazz = super.loadClass(name, camelContext.getApplicationContextClassLoader()).         if (LOG.isTraceEnabled()) {             LOG.trace("Loading class {} using CamelContext {} -> {}", name, camelContext, clazz).         }     }     return clazz. }
false;public;2;4;;@Override public <T> Class<T> resolveClass(String name, Class<T> type) {     return CastUtils.cast(resolveClass(name)). }
false;public;1;21;;@Override public InputStream loadResourceAsStream(String uri) {     StringHelper.notEmpty(uri, "uri").     String resolvedName = resolveUriPath(uri).     URL url = loadResourceAsURL(resolvedName).     InputStream answer = null.     if (url != null) {         try {             answer = url.openStream().         } catch (IOException ex) {             throw new RuntimeException("Cannot load resource: " + uri, ex).         }     }     // fallback to default as OSGi may have issues loading resources     if (answer == null) {         answer = super.loadResourceAsStream(uri).     }     return answer. }
false;public;1;12;;@Override public URL loadResourceAsURL(String uri) {     StringHelper.notEmpty(uri, "uri").     String resolvedName = resolveUriPath(uri).     URL answer = bundleContext.getBundle().getResource(resolvedName).     // fallback to default as OSGi may have issues loading resources     if (answer == null) {         answer = super.loadResourceAsURL(uri).     }     return answer. }
false;public;1;10;;@Override public Enumeration<URL> loadResourcesAsURL(String uri) {     StringHelper.notEmpty(uri, "uri").     try {         String resolvedName = resolveUriPath(uri).         return bundleContext.getBundle().getResources(resolvedName).     } catch (IOException e) {         throw new RuntimeException("Cannot load resource: " + uri, e).     } }
false;public;1;30;;@Override public Enumeration<URL> loadAllResourcesAsURL(String uri) {     StringHelper.notEmpty(uri, "uri").     Vector<URL> answer = new Vector<>().     try {         String resolvedName = resolveUriPath(uri).         Enumeration<URL> e = bundleContext.getBundle().getResources(resolvedName).         while (e != null && e.hasMoreElements()) {             answer.add(e.nextElement()).         }         String path = FileUtil.onlyPath(uri).         String name = FileUtil.stripPath(uri).         if (path != null && name != null) {             for (Bundle bundle : bundleContext.getBundles()) {                 LOG.trace("Finding all entries in path: {} with pattern: {}", path, name).                 e = bundle.findEntries(path, name, false).                 while (e != null && e.hasMoreElements()) {                     answer.add(e.nextElement()).                 }             }         }     } catch (IOException e) {         throw new RuntimeException("Cannot load resource: " + uri, e).     }     return answer.elements(). }
false;protected;2;15;;protected Class<?> doLoadClass(String name, Bundle loader) {     StringHelper.notEmpty(name, "name").     Class<?> answer = null.     // Try to use the camel context's bundle's classloader to load the class     if (loader != null) {         try {             answer = loader.loadClass(name).         } catch (ClassNotFoundException e) {             if (LOG.isTraceEnabled()) {                 LOG.trace("Cannot load class: " + name + " using classloader: " + loader + ". This exception will be ignored.", e).             }         }     }     return answer. }
true;private,static;1;4;/**  * Helper operation used to remove relative path notation from  * resources.  Most critical for resources on the Classpath  * as resource loaders will not resolve the relative paths correctly.  *  * @param name the name of the resource to load  * @return the modified or unmodified string if there were no changes  */ ;/**  * Helper operation used to remove relative path notation from  * resources.  Most critical for resources on the Classpath  * as resource loaders will not resolve the relative paths correctly.  *  * @param name the name of the resource to load  * @return the modified or unmodified string if there were no changes  */ private static String resolveUriPath(String name) {     // compact the path and use / as separator as that's used for loading resources on the classpath     return FileUtil.compactPath(name, '/'). }
