commented;modifiers;parameterAmount;loc;comment;code
true;public;0;17;/**  * Lookup the ids of the Blueprint property placeholder services in the  * Blueprint container.  *  * @return the ids, will be an empty array if none found.  */ ;/**  * Lookup the ids of the Blueprint property placeholder services in the  * Blueprint container.  *  * @return the ids, will be an empty array if none found.  */ public String[] lookupPropertyPlaceholderIds() {     List<String> ids = new ArrayList<>().     for (Object componentId : container.getComponentIds()) {         String id = (String) componentId.         ComponentMetadata meta = container.getComponentMetadata(id).         if (meta instanceof ExtendedBeanMetadata) {             Class<?> clazz = ((ExtendedBeanMetadata) meta).getRuntimeClass().             if (clazz != null && (AbstractPropertyPlaceholder.class.isAssignableFrom(clazz) || newPlaceholderClass(clazz) != null)) {                 ids.add(id).             }         }     }     return ids.toArray(new String[ids.size()]). }
true;private;1;10;/**  * Obtains a {@link Class} instance for "org.apache.aries.blueprint.ext.AbstractPropertyPlaceholderExt"  * @param clazz  * @return  */ ;/**  * Obtains a {@link Class} instance for "org.apache.aries.blueprint.ext.AbstractPropertyPlaceholderExt"  * @param clazz  * @return  */ private Class<?> newPlaceholderClass(Class<?> clazz) {     Class<?> c = clazz.     while (c != null) {         if ("org.apache.aries.blueprint.ext.AbstractPropertyPlaceholderExt".equals(c.getName())) {             return c.         }         c = c.getSuperclass().     }     return null. }
true;public;1;40;/**  * Adds the given Blueprint property placeholder service with the given id  *  * @param id id of the Blueprint property placeholder service to add.  */ ;/**  * Adds the given Blueprint property placeholder service with the given id  *  * @param id id of the Blueprint property placeholder service to add.  */ public void addPropertyPlaceholder(String id) {     Object component = container.getComponentInstance(id).     // new API     if (component != null) {         Class<?> clazz = newPlaceholderClass(component.getClass()).         if (clazz != null) {             log.debug("Adding Blueprint PropertyPlaceholder: {}", id).             if (method == null) {                 try {                     method = clazz.getDeclaredMethod("retrieveValue", String.class).                     method.setAccessible(true).                 } catch (NoSuchMethodException e) {                     throw new IllegalStateException("Cannot add blueprint property placeholder: " + id + " as the method retrieveValue is not accessible", e).                 }             }             placeholders.add(new PropertyPlaceholderWrapper(component, method)).         }     }     // old, deprecated API     if (component instanceof AbstractPropertyPlaceholder) {         AbstractPropertyPlaceholder placeholder = (AbstractPropertyPlaceholder) component.         log.debug("Adding Blueprint PropertyPlaceholder: {}", id).         if (oldMethod == null) {             try {                 oldMethod = AbstractPropertyPlaceholder.class.getDeclaredMethod("retrieveValue", String.class).                 oldMethod.setAccessible(true).             } catch (NoSuchMethodException e) {                 throw new IllegalStateException("Cannot add blueprint property placeholder: " + id + " as the method retrieveValue is not accessible", e).             }         }         placeholders.add(new PropertyPlaceholderWrapper(placeholder, oldMethod)).     } }
false;public;3;55;;@Override public String parseProperty(String key, String value, Properties properties) {     log.trace("Parsing property key: {} with value: {}", key, value).     String answer = null.     // service to lookup otherwise     if (key != null && propertiesComponent.getOverrideProperties() != null) {         answer = (String) propertiesComponent.getOverrideProperties().get(key).     }     // lookup key in blueprint and return its value     if (answer == null && key != null) {         for (PropertyPlaceholderWrapper placeholder : placeholders) {             boolean isDefault = false.             if (placeholders.size() > 1) {                 // okay we have multiple placeholders and we want to return the answer that                 // is not the default placeholder if there is multiple keys                 Map map = placeholder.getDefaultProperties().                 isDefault = map != null && map.containsKey(key).                 log.trace("Blueprint property key: {} is part of default properties: {}", key, isDefault).             }             try {                 String candidate = placeholder.retrieveValue(key).                 if (candidate != null) {                     if (answer == null || !isDefault) {                         log.trace("Blueprint parsed candidate property key: {} as value: {}", key, answer).                         answer = candidate.                     }                 }             } catch (Exception ex) {             // Here we just catch the exception and try to use other candidate             }         }         log.debug("Blueprint parsed property key: {} as value: {}", key, answer).     }     // need to decrypt values     if (delegate != null) {         String delegateAnswer = delegate.parseProperty(key, answer != null ? answer : value, properties).         if (delegateAnswer != null) {             answer = delegateAnswer.             log.debug("Delegate property parser parsed the property key: {} as value: {}", key, answer).         }     }     log.trace("Returning parsed property key: {} as value: {}", key, answer).     return answer. }
false;public;1;4;;public String retrieveValue(String key) {     Object v = ObjectHelper.invokeMethod(method, delegate, key).     return v == null ? null : v.toString(). }
false;public;0;11;;public Map getDefaultProperties() {     if (delegate instanceof PropertyPlaceholder) {         return ((PropertyPlaceholder) delegate).getDefaultProperties().     }     try {         Method getDefaultProperties = delegate.getClass().getMethod("getDefaultProperties").         return getDefaultProperties == null ? null : (Map) getDefaultProperties.invoke(delegate).     } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {         return null.     } }
