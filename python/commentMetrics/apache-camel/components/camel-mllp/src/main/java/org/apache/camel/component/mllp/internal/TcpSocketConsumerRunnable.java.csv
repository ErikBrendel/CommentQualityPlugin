commented;modifiers;parameterAmount;loc;comment;code
true;;1;13;/**  * derive a thread name from the class name, the component URI and the connection information  * <p/>  * The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]  *  * @return the thread name  */ ;/**  * derive a thread name from the class name, the component URI and the connection information  * <p/>  * The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]  *  * @return the thread name  */ String createThreadName(Socket socket) {     // Get the URI without options     String fullEndpointKey = consumer.getEndpoint().getEndpointKey().     String endpointKey.     if (fullEndpointKey.contains("?")) {         endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?')).     } else {         endpointKey = fullEndpointKey.     }     // Now put it all together     return String.format("%s[%s] - %s", this.getClass().getSimpleName(), endpointKey, combinedAddress). }
false;public;0;91;;@Override public void run() {     running = true.     String originalThreadName = Thread.currentThread().getName().     Thread.currentThread().setName(createThreadName(clientSocket)).     MDC.put(UnitOfWork.MDC_CAMEL_CONTEXT_ID, consumer.getEndpoint().getCamelContext().getName()).     Route route = consumer.getRoute().     if (route != null) {         String routeId = route.getId().         if (routeId != null) {             MDC.put(UnitOfWork.MDC_ROUTE_ID, route.getId()).         }     }     log.debug("Starting {} for {}", this.getClass().getSimpleName(), combinedAddress).     try {         byte[] hl7MessageBytes = null.         if (mllpBuffer.hasCompleteEnvelope()) {             // If we got a complete message on the validation read, process it             hl7MessageBytes = mllpBuffer.toMllpPayload().             mllpBuffer.reset().             consumer.processMessage(hl7MessageBytes, this).         }         while (running && null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {             log.debug("Checking for data ....").             try {                 mllpBuffer.readFrom(clientSocket).                 if (mllpBuffer.hasCompleteEnvelope()) {                     hl7MessageBytes = mllpBuffer.toMllpPayload().                     if (log.isDebugEnabled()) {                         log.debug("Received {} byte message {}", hl7MessageBytes.length, Hl7Util.convertToPrintFriendlyString(hl7MessageBytes)).                     }                     if (mllpBuffer.hasLeadingOutOfBandData()) {                         // TODO:  Move the conversion utilities to the MllpSocketBuffer to avoid a byte[] copy                         log.warn("Ignoring leading out-of-band data: {}", Hl7Util.convertToPrintFriendlyString(mllpBuffer.getLeadingOutOfBandData())).                     }                     if (mllpBuffer.hasTrailingOutOfBandData()) {                         log.warn("Ignoring trailing out-of-band data: {}", Hl7Util.convertToPrintFriendlyString(mllpBuffer.getTrailingOutOfBandData())).                     }                     mllpBuffer.reset().                     consumer.processMessage(hl7MessageBytes, this).                 } else if (!mllpBuffer.hasStartOfBlock()) {                     byte[] payload = mllpBuffer.toByteArray().                     log.warn("Ignoring {} byte un-enveloped payload {}", payload.length, Hl7Util.convertToPrintFriendlyString(payload)).                     mllpBuffer.reset().                 } else if (!mllpBuffer.isEmpty()) {                     byte[] payload = mllpBuffer.toByteArray().                     log.warn("Partial {} byte payload received {}", payload.length, Hl7Util.convertToPrintFriendlyString(payload)).                 }             } catch (SocketTimeoutException timeoutEx) {                 if (mllpBuffer.isEmpty()) {                     if (consumer.getConfiguration().hasIdleTimeout()) {                         long currentTicks = System.currentTimeMillis().                         long lastReceivedMessageTicks = consumer.getConsumerRunnables().get(this).                         long idleTime = currentTicks - lastReceivedMessageTicks.                         if (idleTime >= consumer.getConfiguration().getIdleTimeout()) {                             String resetMessage = String.format("Connection idle time %d exceeded idleTimeout %d", idleTime, consumer.getConfiguration().getIdleTimeout()).                             mllpBuffer.resetSocket(clientSocket, resetMessage).                         }                     }                     log.debug("No data received - ignoring timeout").                 } else {                     mllpBuffer.resetSocket(clientSocket).                     new MllpInvalidMessageException("Timeout receiving complete message payload", mllpBuffer.toByteArrayAndReset(), timeoutEx).                     consumer.handleMessageTimeout("Timeout receiving complete message payload", mllpBuffer.toByteArrayAndReset(), timeoutEx).                 }             } catch (MllpSocketException mllpSocketEx) {                 mllpBuffer.resetSocket(clientSocket).                 if (!mllpBuffer.isEmpty()) {                     consumer.handleMessageException("Exception encountered reading payload", mllpBuffer.toByteArrayAndReset(), mllpSocketEx).                 } else {                     log.debug("Ignoring exception encountered checking for data", mllpSocketEx).                 }             }         }     } catch (Exception unexpectedEx) {         log.error("Unexpected exception encountered receiving messages", unexpectedEx).     } finally {         consumer.getConsumerRunnables().remove(this).         log.debug("{} for {} completed", this.getClass().getSimpleName(), combinedAddress).         Thread.currentThread().setName(originalThreadName).         MDC.remove(UnitOfWork.MDC_ROUTE_ID).         MDC.remove(UnitOfWork.MDC_CAMEL_CONTEXT_ID).         mllpBuffer.resetSocket(clientSocket).     } }
false;public;0;3;;public Socket getSocket() {     return clientSocket. }
false;public;0;3;;public MllpSocketBuffer getMllpBuffer() {     return mllpBuffer. }
false;public;0;3;;public void closeSocket() {     mllpBuffer.closeSocket(clientSocket). }
false;public;1;3;;public void closeSocket(String logMessage) {     mllpBuffer.closeSocket(clientSocket, logMessage). }
false;public;0;3;;public void resetSocket() {     mllpBuffer.resetSocket(clientSocket). }
false;public;1;3;;public void resetSocket(String logMessage) {     mllpBuffer.resetSocket(clientSocket, logMessage). }
false;public;0;3;;public void stop() {     running = false. }
false;public;0;3;;public boolean hasLocalAddress() {     return localAddress != null && !localAddress.isEmpty(). }
false;public;0;3;;public String getLocalAddress() {     return localAddress. }
false;public;0;3;;public boolean hasRemoteAddress() {     return remoteAddress != null && !remoteAddress.isEmpty(). }
false;public;0;3;;public String getRemoteAddress() {     return remoteAddress. }
false;public;0;3;;public boolean hasCombinedAddress() {     return combinedAddress != null && combinedAddress.isEmpty(). }
false;public;0;3;;public String getCombinedAddress() {     return combinedAddress. }
