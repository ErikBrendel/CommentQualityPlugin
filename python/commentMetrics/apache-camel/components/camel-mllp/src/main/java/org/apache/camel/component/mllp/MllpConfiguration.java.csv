commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;32;;public static void copy(MllpConfiguration source, MllpConfiguration target) {     if (source == null) {         LOG.warn("Values were not copied by MllpConfiguration.copy(MllpConfiguration source, MllpConfiguration target) - source argument is null").     } else if (target == null) {         LOG.warn("Values were not copied by MllpConfiguration.copy(MllpConfiguration source, MllpConfiguration target) - target argument is null").     } else {         target.bridgeErrorHandler = source.bridgeErrorHandler.         target.exchangePattern = source.exchangePattern.         target.synchronous = source.synchronous.         target.backlog = source.backlog.         target.bindTimeout = source.bindTimeout.         target.bindRetryInterval = source.bindRetryInterval.         target.acceptTimeout = source.acceptTimeout.         target.connectTimeout = source.connectTimeout.         target.receiveTimeout = source.receiveTimeout.         target.idleTimeout = source.idleTimeout.         target.readTimeout = source.readTimeout.         target.keepAlive = source.keepAlive.         target.tcpNoDelay = source.tcpNoDelay.         target.reuseAddress = source.reuseAddress.         target.receiveBufferSize = source.receiveBufferSize.         target.sendBufferSize = source.sendBufferSize.         target.autoAck = source.autoAck.         target.hl7Headers = source.hl7Headers.         target.bufferWrites = source.bufferWrites.         target.requireEndOfData = source.requireEndOfData.         target.stringPayload = source.stringPayload.         target.validatePayload = source.validatePayload.         target.charsetName = source.charsetName.     } }
false;public;0;7;;public MllpConfiguration copy() {     MllpConfiguration target = new MllpConfiguration().     MllpConfiguration.copy(this, target).     return target. }
false;public;1;3;;public void copy(MllpConfiguration source) {     MllpConfiguration.copy(source, this). }
false;public;0;3;;public boolean isBridgeErrorHandler() {     return bridgeErrorHandler. }
true;public;1;3;/**  * Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while  * the consumer is trying to receive incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler.  *  * If disabled, the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions by logging them at WARN or ERROR level and ignored.  *  * @param bridgeErrorHandler  */ ;/**  * Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while  * the consumer is trying to receive incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler.  *  * If disabled, the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions by logging them at WARN or ERROR level and ignored.  *  * @param bridgeErrorHandler  */ public void setBridgeErrorHandler(boolean bridgeErrorHandler) {     this.bridgeErrorHandler = bridgeErrorHandler. }
false;public;0;3;;public ExchangePattern getExchangePattern() {     return exchangePattern. }
true;public;1;3;/**  * Sets the exchange pattern when the consumer creates an exchange.  *  * @param exchangePattern  */ ;/**  * Sets the exchange pattern when the consumer creates an exchange.  *  * @param exchangePattern  */ public void setExchangePattern(ExchangePattern exchangePattern) {     this.exchangePattern = exchangePattern. }
false;public;0;3;;public boolean isSynchronous() {     return synchronous. }
true;public;1;2;/**  * Sets whether synchronous processing should be strictly used (this component only supports synchronous operations).  *  * @param synchronous  */ ;/**  * Sets whether synchronous processing should be strictly used (this component only supports synchronous operations).  *  * @param synchronous  */ public void setSynchronous(boolean synchronous) { }
false;public;0;3;;public boolean hasCharsetName() {     return charsetName != null && !charsetName.isEmpty(). }
false;public;0;16;;public String getCharsetName() {     if (hasCharsetName()) {         try {             if (Charset.isSupported(charsetName)) {                 return charsetName.             }             LOG.warn("Unsupported character set name '{}' configured for the MLLP Endpoint  - returning default charset name {}", charsetName, MllpComponent.getDefaultCharset()).         } catch (Exception charsetEx) {             LOG.warn("Ignoring exception determining character set for name '{}' configured for the MLLP Endpoint - returning default charset name {}", charsetName, MllpComponent.getDefaultCharset(), charsetEx).         }     }     return MllpComponent.getDefaultCharset().name(). }
false;public;0;15;;public Charset getCharset() {     if (hasCharsetName()) {         try {             if (Charset.isSupported(charsetName)) {                 return Charset.forName(charsetName).             }             LOG.warn("Unsupported character set name '{}' configured for the MLLP Endpoint - returning default charset {}", charsetName, MllpComponent.getDefaultCharset()).         } catch (Exception charsetEx) {             LOG.warn("Ignoring exception determining character set for name '{}' configured for the MLLP Endpoint - returning default charset {}", charsetName, MllpComponent.getDefaultCharset(), charsetEx).         }     }     return MllpComponent.getDefaultCharset(). }
false;public;1;15;;public Charset getCharset(Exchange exchange) {     String exchangeCharsetName = ExchangeHelper.getCharsetName(exchange, false).     if (exchangeCharsetName != null && !exchangeCharsetName.isEmpty()) {         try {             if (Charset.isSupported(exchangeCharsetName)) {                 return Charset.forName(exchangeCharsetName).             }             LOG.warn("Unsupported character set name '{}' specified in the Exchange - checking for configured character set", exchangeCharsetName).         } catch (Exception charsetEx) {             LOG.warn("Ignoring exception determining character set for name '{}' specified in the Exchange - checking for configured character set", exchangeCharsetName, charsetEx).         }     }     return getCharset(). }
false;public;2;43;;public Charset getCharset(Exchange exchange, byte[] hl7Bytes) {     String exchangeCharsetName = ExchangeHelper.getCharsetName(exchange, false).     if (exchangeCharsetName != null && !exchangeCharsetName.isEmpty()) {         try {             if (Charset.isSupported(exchangeCharsetName)) {                 return Charset.forName(exchangeCharsetName).             }             LOG.warn("Unsupported character set name '{}' specified in the Exchange - checking for configured character set", exchangeCharsetName).         } catch (Exception charsetEx) {             LOG.warn("Ignoring exception determining character set for name '{}' specified in the Exchange - checking for configured character set", exchangeCharsetName, charsetEx).         }     }     if (hasCharsetName()) {         try {             if (Charset.isSupported(charsetName)) {                 return Charset.forName(charsetName).             }             LOG.warn("Unsupported character set name '{}' configured for the MLLP Endpoint - checking for character set in payload", charsetName).         } catch (Exception charsetEx) {             LOG.warn("Ignoring exception determining character set for name '{}' configured for the MLLP Endpoint - checking for character set in payload", charsetName, charsetEx).         }     }     String msh18 = Hl7Util.findMsh18(hl7Bytes).     if (msh18 != null && !msh18.isEmpty()) {         if (MllpProtocolConstants.MSH18_VALUES.containsKey(msh18)) {             return MllpProtocolConstants.MSH18_VALUES.get(msh18).         }         try {             if (Charset.isSupported(msh18)) {                 return Charset.forName(msh18).             }             LOG.info("Unsupported character set name '{}' found in MSH-18 - using default character set {}", msh18, MllpComponent.getDefaultCharset()).         } catch (Exception charsetEx) {             LOG.info("Ignoring exception encountered determining character set for for name '{}' found in MSH-18 - using default character set {}", msh18, MllpComponent.getDefaultCharset(), charsetEx).         }     }     return MllpComponent.getDefaultCharset(). }
true;public;1;3;/**  * Set the CamelCharsetName property on the exchange  *  * @param charsetName the charset  */ ;/**  * Set the CamelCharsetName property on the exchange  *  * @param charsetName the charset  */ public void setCharsetName(String charsetName) {     this.charsetName = charsetName. }
false;public;0;3;;public boolean hasBacklog() {     return backlog != null && backlog > 0. }
false;public;0;3;;public Integer getBacklog() {     return backlog. }
true;public;1;3;/**  * The maximum queue length for incoming connection indications (a request to connect) is set to the backlog parameter. If a connection indication arrives when the queue is full, the connection is  * refused.  */ ;/**  * The maximum queue length for incoming connection indications (a request to connect) is set to the backlog parameter. If a connection indication arrives when the queue is full, the connection is  * refused.  */ public void setBacklog(Integer backlog) {     this.backlog = backlog. }
false;public;0;3;;public int getBindTimeout() {     return bindTimeout. }
true;public;1;3;/**  * TCP Server Only - The number of milliseconds to retry binding to a server port  */ ;/**  * TCP Server Only - The number of milliseconds to retry binding to a server port  */ public void setBindTimeout(int bindTimeout) {     this.bindTimeout = bindTimeout. }
false;public;0;3;;public int getBindRetryInterval() {     return bindRetryInterval. }
true;public;1;3;/**  * TCP Server Only - The number of milliseconds to wait between bind attempts  */ ;/**  * TCP Server Only - The number of milliseconds to wait between bind attempts  */ public void setBindRetryInterval(int bindRetryInterval) {     this.bindRetryInterval = bindRetryInterval. }
false;public;0;3;;public int getAcceptTimeout() {     return acceptTimeout. }
false;public;0;3;;public boolean isLenientBind() {     return lenientBind. }
true;public;1;3;/**  * TCP Server Only - Allow the endpoint to start before the TCP ServerSocket is bound.  *  * In some environments, it may be desirable to allow the endpoint to start before the TCP ServerSocket  * is bound.  *  * @param lenientBind if true, the ServerSocket will be bound asynchronously. otherwise the ServerSocket will be bound synchronously.  */ ;/**  * TCP Server Only - Allow the endpoint to start before the TCP ServerSocket is bound.  *  * In some environments, it may be desirable to allow the endpoint to start before the TCP ServerSocket  * is bound.  *  * @param lenientBind if true, the ServerSocket will be bound asynchronously. otherwise the ServerSocket will be bound synchronously.  */ public void setLenientBind(boolean lenientBind) {     this.lenientBind = lenientBind. }
true;public;1;3;/**  * Timeout (in milliseconds) while waiting for a TCP connection  * <p/>  * TCP Server Only  *  * @param acceptTimeout timeout in milliseconds  */ ;/**  * Timeout (in milliseconds) while waiting for a TCP connection  * <p/>  * TCP Server Only  *  * @param acceptTimeout timeout in milliseconds  */ public void setAcceptTimeout(int acceptTimeout) {     this.acceptTimeout = acceptTimeout. }
false;public;0;3;;public int getConnectTimeout() {     return connectTimeout. }
true;public;1;3;/**  * Timeout (in milliseconds) for establishing for a TCP connection  * <p/>  * TCP Client only  *  * @param connectTimeout timeout in milliseconds  */ ;/**  * Timeout (in milliseconds) for establishing for a TCP connection  * <p/>  * TCP Client only  *  * @param connectTimeout timeout in milliseconds  */ public void setConnectTimeout(int connectTimeout) {     this.connectTimeout = connectTimeout. }
false;public;0;3;;public int getReceiveTimeout() {     return receiveTimeout. }
true;public;1;3;/**  * The SO_TIMEOUT value (in milliseconds) used when waiting for the start of an MLLP frame  *  * @param receiveTimeout timeout in milliseconds  */ ;/**  * The SO_TIMEOUT value (in milliseconds) used when waiting for the start of an MLLP frame  *  * @param receiveTimeout timeout in milliseconds  */ public void setReceiveTimeout(int receiveTimeout) {     this.receiveTimeout = receiveTimeout. }
false;public;0;3;;public int getMaxConcurrentConsumers() {     return maxConcurrentConsumers. }
true;public;1;3;/**  * The maximum number of concurrent MLLP Consumer connections that will be allowed.  If a new  * connection is received and the maximum is number are already established, the new connection will be reset immediately.  *  * @param maxConcurrentConsumers the maximum number of concurrent consumer connections allowed  */ ;/**  * The maximum number of concurrent MLLP Consumer connections that will be allowed.  If a new  * connection is received and the maximum is number are already established, the new connection will be reset immediately.  *  * @param maxConcurrentConsumers the maximum number of concurrent consumer connections allowed  */ public void setMaxConcurrentConsumers(int maxConcurrentConsumers) {     this.maxConcurrentConsumers = maxConcurrentConsumers. }
true;public;0;4;/**  * Determine if the maxReceiveTimeouts URI parameter has been set  *  * @return true if the parameter has been set. false otherwise  *  * @deprecated Use the idleTimeout URI parameter  */ ;/**  * Determine if the maxReceiveTimeouts URI parameter has been set  *  * @return true if the parameter has been set. false otherwise  *  * @deprecated Use the idleTimeout URI parameter  */ @Deprecated public boolean hasMaxReceiveTimeouts() {     return maxReceiveTimeouts != null. }
true;public;0;4;/**  * Retrieve the value of the maxReceiveTimeouts URI parameter.  *  * @return the maximum number of receive timeouts before the TCP Socket is reset  *  * @deprecated Use the idleTimeout URI parameter  */ ;/**  * Retrieve the value of the maxReceiveTimeouts URI parameter.  *  * @return the maximum number of receive timeouts before the TCP Socket is reset  *  * @deprecated Use the idleTimeout URI parameter  */ @Deprecated public Integer getMaxReceiveTimeouts() {     return maxReceiveTimeouts. }
true;public;1;4;/**  * The maximum number of timeouts (specified by receiveTimeout) allowed before the TCP Connection will be reset.  *  * @param maxReceiveTimeouts maximum number of receiveTimeouts  *  * @deprecated Use the idleTimeout URI parameter.  For backward compibility, setting this parameter will result in an  * idle timeout of maxReceiveTimeouts * receiveTimeout.  If idleTimeout is also specified, this parameter will be ignored.  */ ;/**  * The maximum number of timeouts (specified by receiveTimeout) allowed before the TCP Connection will be reset.  *  * @param maxReceiveTimeouts maximum number of receiveTimeouts  *  * @deprecated Use the idleTimeout URI parameter.  For backward compibility, setting this parameter will result in an  * idle timeout of maxReceiveTimeouts * receiveTimeout.  If idleTimeout is also specified, this parameter will be ignored.  */ @Deprecated public void setMaxReceiveTimeouts(Integer maxReceiveTimeouts) {     this.maxReceiveTimeouts = maxReceiveTimeouts. }
false;public;0;3;;public boolean hasIdleTimeout() {     return idleTimeout != null && idleTimeout > 0. }
false;public;0;3;;public Integer getIdleTimeout() {     return idleTimeout. }
true;public;1;3;/**  * The approximate idle time allowed before the Client TCP Connection will be reset.  *  * A null value or a value less than or equal to zero will disable the idle timeout.  *  * @param idleTimeout timeout in milliseconds  */ ;/**  * The approximate idle time allowed before the Client TCP Connection will be reset.  *  * A null value or a value less than or equal to zero will disable the idle timeout.  *  * @param idleTimeout timeout in milliseconds  */ public void setIdleTimeout(Integer idleTimeout) {     this.idleTimeout = idleTimeout. }
false;public;0;3;;public int getReadTimeout() {     return readTimeout. }
true;public;1;3;/**  * The SO_TIMEOUT value (in milliseconds) used after the start of an MLLP frame has been received  *  * @param readTimeout timeout in milliseconds  */ ;/**  * The SO_TIMEOUT value (in milliseconds) used after the start of an MLLP frame has been received  *  * @param readTimeout timeout in milliseconds  */ public void setReadTimeout(int readTimeout) {     this.readTimeout = readTimeout. }
false;public;0;3;;public boolean hasKeepAlive() {     return keepAlive != null. }
false;public;0;3;;public Boolean getKeepAlive() {     return keepAlive. }
true;public;1;3;/**  * Enable/disable the SO_KEEPALIVE socket option.  *  * @param keepAlive enable SO_KEEPALIVE when true. disable SO_KEEPALIVE when false. use system default when null  */ ;/**  * Enable/disable the SO_KEEPALIVE socket option.  *  * @param keepAlive enable SO_KEEPALIVE when true. disable SO_KEEPALIVE when false. use system default when null  */ public void setKeepAlive(Boolean keepAlive) {     this.keepAlive = keepAlive. }
false;public;0;3;;public boolean hasTcpNoDelay() {     return tcpNoDelay != null. }
false;public;0;3;;public Boolean getTcpNoDelay() {     return tcpNoDelay. }
true;public;1;3;/**  * Enable/disable the TCP_NODELAY socket option.  *  * @param tcpNoDelay enable TCP_NODELAY when true. disable TCP_NODELAY when false. use system default when null  */ ;/**  * Enable/disable the TCP_NODELAY socket option.  *  * @param tcpNoDelay enable TCP_NODELAY when true. disable TCP_NODELAY when false. use system default when null  */ public void setTcpNoDelay(Boolean tcpNoDelay) {     this.tcpNoDelay = tcpNoDelay. }
false;public;0;3;;public boolean hasReuseAddress() {     return reuseAddress != null. }
false;public;0;3;;public Boolean getReuseAddress() {     return reuseAddress. }
true;public;1;3;/**  * Enable/disable the SO_REUSEADDR socket option.  *  * @param reuseAddress enable SO_REUSEADDR when true. disable SO_REUSEADDR when false. use system default when null  */ ;/**  * Enable/disable the SO_REUSEADDR socket option.  *  * @param reuseAddress enable SO_REUSEADDR when true. disable SO_REUSEADDR when false. use system default when null  */ public void setReuseAddress(Boolean reuseAddress) {     this.reuseAddress = reuseAddress. }
false;public;0;3;;public boolean hasReceiveBufferSize() {     return receiveBufferSize != null && receiveBufferSize > 0. }
false;public;0;3;;public int getReceiveBufferSize() {     return receiveBufferSize. }
true;public;1;3;/**  * Sets the SO_RCVBUF option to the specified value (in bytes)  *  * @param receiveBufferSize the SO_RCVBUF option value.  If null, the system default is used  */ ;/**  * Sets the SO_RCVBUF option to the specified value (in bytes)  *  * @param receiveBufferSize the SO_RCVBUF option value.  If null, the system default is used  */ public void setReceiveBufferSize(Integer receiveBufferSize) {     this.receiveBufferSize = receiveBufferSize. }
false;public;0;3;;public boolean hasSendBufferSize() {     return sendBufferSize != null && sendBufferSize > 0. }
false;public;0;3;;public int getSendBufferSize() {     return sendBufferSize. }
true;public;1;3;/**  * Sets the SO_SNDBUF option to the specified value (in bytes)  *  * @param sendBufferSize the SO_SNDBUF option value.  If null, the system default is used  */ ;/**  * Sets the SO_SNDBUF option to the specified value (in bytes)  *  * @param sendBufferSize the SO_SNDBUF option value.  If null, the system default is used  */ public void setSendBufferSize(Integer sendBufferSize) {     this.sendBufferSize = sendBufferSize. }
false;public;0;3;;public boolean isAutoAck() {     return autoAck. }
true;public;1;3;/**  * Enable/Disable the automatic generation of a MLLP Acknowledgement  *  * MLLP Consumers only  *  * @param autoAck enabled if true, otherwise disabled  */ ;/**  * Enable/Disable the automatic generation of a MLLP Acknowledgement  *  * MLLP Consumers only  *  * @param autoAck enabled if true, otherwise disabled  */ public void setAutoAck(boolean autoAck) {     this.autoAck = autoAck. }
false;public;0;3;;public boolean isHl7Headers() {     return hl7Headers. }
false;public;0;3;;public boolean getHl7Headers() {     return isHl7Headers(). }
true;public;1;3;/**  * Enable/Disable the automatic generation of message headers from the HL7 Message  *  * MLLP Consumers only  *  * @param hl7Headers enabled if true, otherwise disabled  */ ;/**  * Enable/Disable the automatic generation of message headers from the HL7 Message  *  * MLLP Consumers only  *  * @param hl7Headers enabled if true, otherwise disabled  */ public void setHl7Headers(boolean hl7Headers) {     this.hl7Headers = hl7Headers. }
false;public;0;3;;public boolean isRequireEndOfData() {     return requireEndOfData. }
true;public;1;3;/**  * Enable/Disable strict compliance to the MLLP standard.  *  * The MLLP standard specifies [START_OF_BLOCK]hl7 payload[END_OF_BLOCK][END_OF_DATA], however, some systems do not send  * the final END_OF_DATA byte.  This setting controls whether or not the final END_OF_DATA byte is required or optional.  *  * @param requireEndOfData the trailing END_OF_DATA byte is required if true. optional otherwise  */ ;/**  * Enable/Disable strict compliance to the MLLP standard.  *  * The MLLP standard specifies [START_OF_BLOCK]hl7 payload[END_OF_BLOCK][END_OF_DATA], however, some systems do not send  * the final END_OF_DATA byte.  This setting controls whether or not the final END_OF_DATA byte is required or optional.  *  * @param requireEndOfData the trailing END_OF_DATA byte is required if true. optional otherwise  */ public void setRequireEndOfData(boolean requireEndOfData) {     this.requireEndOfData = requireEndOfData. }
false;public;0;3;;public boolean isStringPayload() {     return stringPayload. }
true;public;1;3;/**  * Enable/Disable converting the payload to a String.  *  * If enabled, HL7 Payloads received from external systems will be validated converted to a String.  *  * If the charsetName property is set, that character set will be used for the conversion.  If the charsetName property is  * not set, the value of MSH-18 will be used to determine th appropriate character set.  If MSH-18 is not set, then  * the default ISO-8859-1 character set will be use.  *  * @param stringPayload enabled if true, otherwise disabled  */ ;/**  * Enable/Disable converting the payload to a String.  *  * If enabled, HL7 Payloads received from external systems will be validated converted to a String.  *  * If the charsetName property is set, that character set will be used for the conversion.  If the charsetName property is  * not set, the value of MSH-18 will be used to determine th appropriate character set.  If MSH-18 is not set, then  * the default ISO-8859-1 character set will be use.  *  * @param stringPayload enabled if true, otherwise disabled  */ public void setStringPayload(boolean stringPayload) {     this.stringPayload = stringPayload. }
false;public;0;3;;public boolean isValidatePayload() {     return validatePayload. }
true;public;1;3;/**  * Enable/Disable the validation of HL7 Payloads  *  * If enabled, HL7 Payloads received from external systems will be validated (see Hl7Util.generateInvalidPayloadExceptionMessage  * for details on the validation). If and invalid payload is detected, a MllpInvalidMessageException (for consumers) or  * a MllpInvalidAcknowledgementException will be thrown.  *  * @param validatePayload enabled if true, otherwise disabled  */ ;/**  * Enable/Disable the validation of HL7 Payloads  *  * If enabled, HL7 Payloads received from external systems will be validated (see Hl7Util.generateInvalidPayloadExceptionMessage  * for details on the validation). If and invalid payload is detected, a MllpInvalidMessageException (for consumers) or  * a MllpInvalidAcknowledgementException will be thrown.  *  * @param validatePayload enabled if true, otherwise disabled  */ public void setValidatePayload(boolean validatePayload) {     this.validatePayload = validatePayload. }
false;public;0;3;;public boolean isBufferWrites() {     return bufferWrites. }
true;public;1;4;/**  * Enable/Disable the buffering of HL7 payloads before writing to the socket.  *  * @deprecated the parameter will be ignored  *  * @param bufferWrites enabled if true, otherwise disabled  */ ;/**  * Enable/Disable the buffering of HL7 payloads before writing to the socket.  *  * @deprecated the parameter will be ignored  *  * @param bufferWrites enabled if true, otherwise disabled  */ @Deprecated public void setBufferWrites(boolean bufferWrites) {     this.bufferWrites = bufferWrites. }
false;public;0;28;;@Override public int hashCode() {     return Objects.hash(bridgeErrorHandler, exchangePattern, synchronous, backlog, bindTimeout, bindRetryInterval, acceptTimeout, connectTimeout, receiveTimeout, maxConcurrentConsumers, maxReceiveTimeouts, idleTimeout, readTimeout, keepAlive, tcpNoDelay, reuseAddress, receiveBufferSize, sendBufferSize, autoAck, hl7Headers, bufferWrites, requireEndOfData, stringPayload, validatePayload, charsetName). }
false;public;1;38;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (!(o instanceof MllpConfiguration)) {         return false.     }     MllpConfiguration rhs = (MllpConfiguration) o.     return bridgeErrorHandler == rhs.bridgeErrorHandler && exchangePattern == rhs.exchangePattern && synchronous == rhs.synchronous && bindTimeout == rhs.bindTimeout && bindRetryInterval == rhs.bindRetryInterval && acceptTimeout == rhs.acceptTimeout && connectTimeout == rhs.connectTimeout && receiveTimeout == rhs.receiveTimeout && readTimeout == rhs.readTimeout && autoAck == rhs.autoAck && hl7Headers == rhs.hl7Headers && bufferWrites == rhs.bufferWrites && requireEndOfData == rhs.requireEndOfData && stringPayload == rhs.stringPayload && validatePayload == rhs.validatePayload && Objects.equals(backlog, rhs.backlog) && Objects.equals(maxConcurrentConsumers, rhs.maxConcurrentConsumers) && Objects.equals(maxReceiveTimeouts, rhs.maxReceiveTimeouts) && Objects.equals(idleTimeout, rhs.idleTimeout) && Objects.equals(keepAlive, rhs.keepAlive) && Objects.equals(tcpNoDelay, rhs.tcpNoDelay) && Objects.equals(reuseAddress, rhs.reuseAddress) && Objects.equals(receiveBufferSize, rhs.receiveBufferSize) && Objects.equals(sendBufferSize, rhs.sendBufferSize) && Objects.equals(charsetName, rhs.charsetName). }
false;public;0;30;;@Override public String toString() {     return "MllpConfiguration{" + "bridgeErrorHandler=" + bridgeErrorHandler + ", exchangePattern=" + exchangePattern + ", synchronous=" + synchronous + ", backlog=" + backlog + ", bindTimeout=" + bindTimeout + ", bindRetryInterval=" + bindRetryInterval + ", acceptTimeout=" + acceptTimeout + ", connectTimeout=" + connectTimeout + ", receiveTimeout=" + receiveTimeout + ", maxConcurrentConsumers=" + maxConcurrentConsumers + ", maxReceiveTimeouts=" + maxReceiveTimeouts + ", idleTimeout=" + idleTimeout + ", readTimeout=" + readTimeout + ", keepAlive=" + keepAlive + ", tcpNoDelay=" + tcpNoDelay + ", reuseAddress=" + reuseAddress + ", receiveBufferSize=" + receiveBufferSize + ", sendBufferSize=" + sendBufferSize + ", autoAck=" + autoAck + ", hl7Headers=" + hl7Headers + ", bufferWrites=" + bufferWrites + ", requireEndOfData=" + requireEndOfData + ", stringPayload=" + stringPayload + ", validatePayload=" + validatePayload + ", charsetName='" + charsetName + '\'' + '}'. }
