# id;timestamp;commentText;codeText;commentWords;codeWords
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1451464990;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1451465974;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1452098879;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1452781359;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1452781359;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1453968697;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1454949920;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1457097808;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1460612302;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1461827354;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1461827354;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1473189753;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1473924202;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1479844564;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1480003968;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1481829620;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1481875493;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ClientSocketThread -> String createThreadName(Socket socket);1494247089;derive a thread name from the class name, the component URI and the connection information_<p/>_The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]__@return the thread name;String createThreadName(Socket socket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s -> %s", className, endpointKey, socket.getLocalSocketAddress(), socket.getRemoteSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,remote,socket,address,return,the,thread,name;string,create,thread,name,socket,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,s,class,name,endpoint,key,socket,get,local,socket,address,socket,get,remote,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1451464990;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            log.debug("Starting acceptor thread")___            while (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                try {_                    _                    _                    _                    Socket socket = serverSocket.accept()___                    _                    Thread.sleep(100)__                    if (socket.isConnected() && !socket.isClosed()) {_                        log.debug("Socket appears to be there - check for available data")__                        InputStream inputStream__                        try {_                            inputStream = socket.getInputStream()__                        } catch (IOException ioEx) {_                            _                            log.warn("Failed to retrieve the InputStream for socket after the initial connection was accepted")__                            MllpUtil.resetConnection(socket)__                            continue__                        }__                        if (0 < inputStream.available()) {_                            _                            ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                            clientThreads.add(clientThread)__                            clientThread.start()__                            continue__                        }__                        _                        socket.setSoTimeout(100)__                        try {_                            int tmpByte = inputStream.read()__                            socket.setSoTimeout(endpoint.responseTimeout)__                            if (-1 == tmpByte) {_                                log.debug("Socket.read() returned END_OF_STREAM - resetting connection")__                                MllpUtil.resetConnection(socket)__                            } else {_                                ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            }_                        } catch (SocketTimeoutException timeoutEx) {_                            _                            log.debug("No Data - but the socket is there.  Starting ClientSocketThread")__                            ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                            clientThreads.add(clientThread)__                            clientThread.start()__                        }_                    }_                } catch (SocketTimeoutException timeoutEx) {_                    _                    log.trace("SocketTimeoutException waiting for new connections - no new connections")___                    for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                        ClientSocketThread thread = clientThreads.get(i)__                        if (!thread.isAlive()) {_                            clientThreads.remove(i)__                        }_                    }_                } catch (InterruptedException interruptEx) {_                    log.info("accept loop interrupted - closing ServerSocket")__                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.warn("Exception encountered closing ServerSocket after InterruptedException", ex)__                    }_                } catch (Exception ex) {_                    log.error("Exception accepting new connection", ex)__                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,log,debug,starting,acceptor,thread,while,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,socket,socket,server,socket,accept,thread,sleep,100,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,check,for,available,data,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,log,warn,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,mllp,util,reset,connection,socket,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,socket,set,so,timeout,100,try,int,tmp,byte,input,stream,read,socket,set,so,timeout,endpoint,response,timeout,if,1,tmp,byte,log,debug,socket,read,returned,resetting,connection,mllp,util,reset,connection,socket,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,debug,no,data,but,the,socket,is,there,starting,client,socket,thread,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,info,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,warn,exception,encountered,closing,server,socket,after,interrupted,exception,ex,catch,exception,ex,log,error,exception,accepting,new,connection,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1451465974;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            log.debug("Starting acceptor thread")___            while (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                try {_                    _                    _                    _                    Socket socket = serverSocket.accept()___                    _                    Thread.sleep(100)__                    if (socket.isConnected() && !socket.isClosed()) {_                        log.debug("Socket appears to be there - check for available data")__                        InputStream inputStream__                        try {_                            inputStream = socket.getInputStream()__                        } catch (IOException ioEx) {_                            _                            log.warn("Failed to retrieve the InputStream for socket after the initial connection was accepted")__                            MllpUtil.resetConnection(socket)__                            continue__                        }__                        if (0 < inputStream.available()) {_                            _                            ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                            clientThreads.add(clientThread)__                            clientThread.start()__                            continue__                        }__                        _                        socket.setSoTimeout(100)__                        try {_                            int tmpByte = inputStream.read()__                            socket.setSoTimeout(endpoint.responseTimeout)__                            if (-1 == tmpByte) {_                                log.debug("Socket.read() returned END_OF_STREAM - resetting connection")__                                MllpUtil.resetConnection(socket)__                            } else {_                                ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            }_                        } catch (SocketTimeoutException timeoutEx) {_                            _                            log.debug("No Data - but the socket is there.  Starting ClientSocketThread")__                            ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                            clientThreads.add(clientThread)__                            clientThread.start()__                        }_                    }_                } catch (SocketTimeoutException timeoutEx) {_                    _                    log.trace("SocketTimeoutException waiting for new connections - no new connections")___                    for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                        ClientSocketThread thread = clientThreads.get(i)__                        if (!thread.isAlive()) {_                            clientThreads.remove(i)__                        }_                    }_                } catch (InterruptedException interruptEx) {_                    log.info("accept loop interrupted - closing ServerSocket")__                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.warn("Exception encountered closing ServerSocket after InterruptedException", ex)__                    }_                } catch (Exception ex) {_                    log.error("Exception accepting new connection", ex)__                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,log,debug,starting,acceptor,thread,while,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,socket,socket,server,socket,accept,thread,sleep,100,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,check,for,available,data,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,log,warn,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,mllp,util,reset,connection,socket,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,socket,set,so,timeout,100,try,int,tmp,byte,input,stream,read,socket,set,so,timeout,endpoint,response,timeout,if,1,tmp,byte,log,debug,socket,read,returned,resetting,connection,mllp,util,reset,connection,socket,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,debug,no,data,but,the,socket,is,there,starting,client,socket,thread,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,info,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,warn,exception,encountered,closing,server,socket,after,interrupted,exception,ex,catch,exception,ex,log,error,exception,accepting,new,connection,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1452098879;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            log.debug("Starting acceptor thread")___            while (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                try {_                    _                    _                    _                    Socket socket = serverSocket.accept()___                    _                    Thread.sleep(100)__                    if (socket.isConnected() && !socket.isClosed()) {_                        log.debug("Socket appears to be there - check for available data")__                        InputStream inputStream__                        try {_                            inputStream = socket.getInputStream()__                        } catch (IOException ioEx) {_                            _                            log.warn("Failed to retrieve the InputStream for socket after the initial connection was accepted")__                            MllpUtil.resetConnection(socket)__                            continue__                        }__                        if (0 < inputStream.available()) {_                            _                            ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                            clientThreads.add(clientThread)__                            clientThread.start()__                            continue__                        }__                        _                        socket.setSoTimeout(100)__                        try {_                            int tmpByte = inputStream.read()__                            socket.setSoTimeout(endpoint.receiveTimeout)__                            if (-1 == tmpByte) {_                                log.debug("Socket.read() returned END_OF_STREAM - resetting connection")__                                MllpUtil.resetConnection(socket)__                            } else {_                                ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            }_                        } catch (SocketTimeoutException timeoutEx) {_                            _                            log.debug("No Data - but the socket is there.  Starting ClientSocketThread")__                            ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                            clientThreads.add(clientThread)__                            clientThread.start()__                        }_                    }_                } catch (SocketTimeoutException timeoutEx) {_                    _                    log.trace("SocketTimeoutException waiting for new connections - no new connections")___                    for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                        ClientSocketThread thread = clientThreads.get(i)__                        if (!thread.isAlive()) {_                            clientThreads.remove(i)__                        }_                    }_                } catch (InterruptedException interruptEx) {_                    log.info("accept loop interrupted - closing ServerSocket")__                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.warn("Exception encountered closing ServerSocket after InterruptedException", ex)__                    }_                } catch (Exception ex) {_                    log.error("Exception accepting new connection", ex)__                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,log,debug,starting,acceptor,thread,while,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,socket,socket,server,socket,accept,thread,sleep,100,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,check,for,available,data,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,log,warn,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,mllp,util,reset,connection,socket,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,socket,set,so,timeout,100,try,int,tmp,byte,input,stream,read,socket,set,so,timeout,endpoint,receive,timeout,if,1,tmp,byte,log,debug,socket,read,returned,resetting,connection,mllp,util,reset,connection,socket,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,debug,no,data,but,the,socket,is,there,starting,client,socket,thread,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,info,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,warn,exception,encountered,closing,server,socket,after,interrupted,exception,ex,catch,exception,ex,log,error,exception,accepting,new,connection,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1452781359;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            log.debug("Starting acceptor thread")___            while (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                    _                    _                    _                Socket socket = null__                try {_                    socket = serverSocket.accept()__                } catch (SocketException socketEx) {_                    _                    if (serverSocket.isBound()) {_                        try {_                            serverSocket.close()__                        } catch (Exception ex) {_                            log.info("Exception encountered closing ServerSocket after SocketException on accept()", ex)__                        }_                    }_                } catch (IOException ioEx) {_                    log.error("Exception encountered accepting connection - closing ServerSocket", ioEx)__                    if (serverSocket.isBound()) {_                        try {_                            serverSocket.close()__                        } catch (Exception ex) {_                            log.info("Exception encountered closing ServerSocket after exception on accept()", ex)__                        }_                    }_                }__                try {_                    _                    Thread.sleep(100)__                    if (socket.isConnected() && !socket.isClosed()) {_                        log.debug("Socket appears to be there - check for available data")__                        InputStream inputStream__                        try {_                            inputStream = socket.getInputStream()__                        } catch (IOException ioEx) {_                            _                            log.warn("Failed to retrieve the InputStream for socket after the initial connection was accepted")__                            MllpUtil.resetConnection(socket)__                            continue__                        }__                        if (0 < inputStream.available()) {_                            _                            ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                            clientThreads.add(clientThread)__                            clientThread.start()__                            continue__                        }__                        _                        socket.setSoTimeout(100)__                        try {_                            int tmpByte = inputStream.read()__                            socket.setSoTimeout(endpoint.receiveTimeout)__                            if (-1 == tmpByte) {_                                log.debug("Socket.read() returned END_OF_STREAM - resetting connection")__                                MllpUtil.resetConnection(socket)__                            } else {_                                ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            }_                        } catch (SocketTimeoutException timeoutEx) {_                            _                            log.debug("No Data - but the socket is there.  Starting ClientSocketThread")__                            ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                            clientThreads.add(clientThread)__                            clientThread.start()__                        }_                    }_                } catch (SocketTimeoutException timeoutEx) {_                    _                    log.trace("SocketTimeoutException waiting for new connections - no new connections")___                    for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                        ClientSocketThread thread = clientThreads.get(i)__                        if (!thread.isAlive()) {_                            clientThreads.remove(i)__                        }_                    }_                } catch (InterruptedException interruptEx) {_                    log.info("accept loop interrupted - closing ServerSocket")__                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.warn("Exception encountered closing ServerSocket after InterruptedException", ex)__                    }_                } catch (Exception ex) {_                    log.error("Exception accepting new connection", ex)__                }_            }__            log.info("ServerSocket.accept loop finished - closing listener")__            if (null != serverSocket  &&  serverSocket.isBound()  &&  !serverSocket.isClosed()) {_                try {_                    serverSocket.close()__                } catch (Exception ex) {_                    log.warn("Exception encountered closing ServerSocket after accept loop had exited", ex)__                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,log,debug,starting,acceptor,thread,while,null,server,socket,server,socket,is,bound,server,socket,is,closed,socket,socket,null,try,socket,server,socket,accept,catch,socket,exception,socket,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,info,exception,encountered,closing,server,socket,after,socket,exception,on,accept,ex,catch,ioexception,io,ex,log,error,exception,encountered,accepting,connection,closing,server,socket,io,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,info,exception,encountered,closing,server,socket,after,exception,on,accept,ex,try,thread,sleep,100,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,check,for,available,data,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,log,warn,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,mllp,util,reset,connection,socket,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,socket,set,so,timeout,100,try,int,tmp,byte,input,stream,read,socket,set,so,timeout,endpoint,receive,timeout,if,1,tmp,byte,log,debug,socket,read,returned,resetting,connection,mllp,util,reset,connection,socket,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,debug,no,data,but,the,socket,is,there,starting,client,socket,thread,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,info,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,warn,exception,encountered,closing,server,socket,after,interrupted,exception,ex,catch,exception,ex,log,error,exception,accepting,new,connection,ex,log,info,server,socket,accept,loop,finished,closing,listener,if,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,server,socket,close,catch,exception,ex,log,warn,exception,encountered,closing,server,socket,after,accept,loop,had,exited,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1452781359;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            log.debug("Starting acceptor thread")___            try {_                while (!isInterrupted() && null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                    _                    Socket socket = null__                    try {_                        socket = serverSocket.accept()__                    } catch (SocketException socketEx) {_                        _                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after SocketException on accept() - ignoring", ex)__                            }_                        }_                        continue__                    } catch (IOException ioEx) {_                        log.error("Exception encountered accepting connection - closing ServerSocket", ioEx)__                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after exception on accept() - ignoring", ex)__                            }_                        }_                        continue__                    }__                    try {_                    _                        Thread.sleep(100)__                        if (socket.isConnected() && !socket.isClosed()) {_                            log.debug("Socket appears to be there - check for available data")__                            InputStream inputStream__                            try {_                                inputStream = socket.getInputStream()__                            } catch (IOException ioEx) {_                                _                                log.warn("Failed to retrieve the InputStream for socket after the initial connection was accepted")__                                MllpUtil.resetConnection(socket)__                                continue__                            }__                            if (0 < inputStream.available()) {_                                _                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                                continue__                            }__                            _                            socket.setSoTimeout(100)__                            try {_                                int tmpByte = inputStream.read()__                                socket.setSoTimeout(endpoint.receiveTimeout)__                                if (-1 == tmpByte) {_                                    log.debug("Socket.read() returned END_OF_STREAM - resetting connection")__                                    MllpUtil.resetConnection(socket)__                                } else {_                                    ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                    clientThreads.add(clientThread)__                                    clientThread.start()__                                }_                            } catch (SocketTimeoutException timeoutEx) {_                                _                                log.debug("No Data - but the socket is there.  Starting ClientSocketThread")__                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            }_                        }_                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.trace("SocketTimeoutException waiting for new connections - no new connections")___                        for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                            ClientSocketThread thread = clientThreads.get(i)__                            if (!thread.isAlive()) {_                                clientThreads.remove(i)__                            }_                        }_                    } catch (InterruptedException interruptEx) {_                        log.debug("accept loop interrupted - closing ServerSocket")__                        try {_                            serverSocket.close()__                        } catch (Exception ex) {_                            log.debug("Exception encountered closing ServerSocket after InterruptedException - ignoring", ex)__                        }_                    } catch (Exception ex) {_                        log.error("Exception accepting new connection - retrying", ex)__                    }_                }_            } finally {_                log.debug("ServerSocket.accept loop finished - closing listener")__                if (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.debug("Exception encountered closing ServerSocket after accept loop had exited - ignoring", ex)__                    }_                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,log,debug,starting,acceptor,thread,try,while,is,interrupted,null,server,socket,server,socket,is,bound,server,socket,is,closed,socket,socket,null,try,socket,server,socket,accept,catch,socket,exception,socket,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,socket,exception,on,accept,ignoring,ex,continue,catch,ioexception,io,ex,log,error,exception,encountered,accepting,connection,closing,server,socket,io,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,exception,on,accept,ignoring,ex,continue,try,thread,sleep,100,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,check,for,available,data,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,log,warn,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,mllp,util,reset,connection,socket,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,socket,set,so,timeout,100,try,int,tmp,byte,input,stream,read,socket,set,so,timeout,endpoint,receive,timeout,if,1,tmp,byte,log,debug,socket,read,returned,resetting,connection,mllp,util,reset,connection,socket,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,debug,no,data,but,the,socket,is,there,starting,client,socket,thread,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,debug,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,interrupted,exception,ignoring,ex,catch,exception,ex,log,error,exception,accepting,new,connection,retrying,ex,finally,log,debug,server,socket,accept,loop,finished,closing,listener,if,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,accept,loop,had,exited,ignoring,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1453968697;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            log.debug("Starting acceptor thread")___            try {_                while (!isInterrupted()  &&  null != serverSocket && serverSocket.isBound()  &&  !serverSocket.isClosed()) {_                    _                    Socket socket = null__                    try {_                        socket = serverSocket.accept()__                    } catch (SocketException socketEx) {_                        _                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after SocketException on accept() - ignoring", ex)__                            }_                        }_                        continue__                    } catch (IOException ioEx) {_                        log.error("Exception encountered accepting connection - closing ServerSocket", ioEx)__                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after exception on accept() - ignoring", ex)__                            }_                        }_                        continue__                    }__                    try {_                    _                        Thread.sleep(100)__                        if (socket.isConnected() && !socket.isClosed()) {_                            log.debug("Socket appears to be there - check for available data")__                            InputStream inputStream__                            try {_                                inputStream = socket.getInputStream()__                            } catch (IOException ioEx) {_                                _                                log.warn("Failed to retrieve the InputStream for socket after the initial connection was accepted")__                                MllpUtil.resetConnection(socket)__                                continue__                            }__                            if (0 < inputStream.available()) {_                                _                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                                continue__                            }__                            _                            socket.setSoTimeout(100)__                            try {_                                int tmpByte = inputStream.read()__                                socket.setSoTimeout(endpoint.receiveTimeout)__                                if (-1 == tmpByte) {_                                    log.debug("Socket.read() returned END_OF_STREAM - resetting connection")__                                    MllpUtil.resetConnection(socket)__                                } else {_                                    ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                    clientThreads.add(clientThread)__                                    clientThread.start()__                                }_                            } catch (SocketTimeoutException timeoutEx) {_                                _                                log.debug("No Data - but the socket is there.  Starting ClientSocketThread")__                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            }_                        }_                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.trace("SocketTimeoutException waiting for new connections - no new connections")___                        for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                            ClientSocketThread thread = clientThreads.get(i)__                            if (!thread.isAlive()) {_                                clientThreads.remove(i)__                            }_                        }_                    } catch (InterruptedException interruptEx) {_                        log.debug("accept loop interrupted - closing ServerSocket")__                        try {_                            serverSocket.close()__                        } catch (Exception ex) {_                            log.debug("Exception encountered closing ServerSocket after InterruptedException - ignoring", ex)__                        }_                    } catch (Exception ex) {_                        log.error("Exception accepting new connection - retrying", ex)__                    }_                }_            } finally {_                log.debug("ServerSocket.accept loop finished - closing listener")__                if (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.debug("Exception encountered closing ServerSocket after accept loop had exited - ignoring", ex)__                    }_                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,log,debug,starting,acceptor,thread,try,while,is,interrupted,null,server,socket,server,socket,is,bound,server,socket,is,closed,socket,socket,null,try,socket,server,socket,accept,catch,socket,exception,socket,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,socket,exception,on,accept,ignoring,ex,continue,catch,ioexception,io,ex,log,error,exception,encountered,accepting,connection,closing,server,socket,io,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,exception,on,accept,ignoring,ex,continue,try,thread,sleep,100,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,check,for,available,data,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,log,warn,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,mllp,util,reset,connection,socket,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,socket,set,so,timeout,100,try,int,tmp,byte,input,stream,read,socket,set,so,timeout,endpoint,receive,timeout,if,1,tmp,byte,log,debug,socket,read,returned,resetting,connection,mllp,util,reset,connection,socket,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,debug,no,data,but,the,socket,is,there,starting,client,socket,thread,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,debug,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,interrupted,exception,ignoring,ex,catch,exception,ex,log,error,exception,accepting,new,connection,retrying,ex,finally,log,debug,server,socket,accept,loop,finished,closing,listener,if,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,accept,loop,had,exited,ignoring,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1454949920;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            log.debug("Starting acceptor thread")___            try {_                while (!isInterrupted()  &&  null != serverSocket && serverSocket.isBound()  &&  !serverSocket.isClosed()) {_                    _                    Socket socket = null__                    try {_                        socket = serverSocket.accept()__                    } catch (SocketException socketEx) {_                        _                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after SocketException on accept() - ignoring", ex)__                            }_                        }_                        continue__                    } catch (IOException ioEx) {_                        log.error("Exception encountered accepting connection - closing ServerSocket", ioEx)__                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after exception on accept() - ignoring", ex)__                            }_                        }_                        continue__                    }__                    try {_                    _                        Thread.sleep(100)__                        if (socket.isConnected() && !socket.isClosed()) {_                            log.debug("Socket appears to be there - check for available data")__                            InputStream inputStream__                            try {_                                inputStream = socket.getInputStream()__                            } catch (IOException ioEx) {_                                _                                log.warn("Failed to retrieve the InputStream for socket after the initial connection was accepted")__                                MllpUtil.resetConnection(socket)__                                continue__                            }__                            if (0 < inputStream.available()) {_                                _                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                                continue__                            }__                            _                            socket.setSoTimeout(100)__                            try {_                                int tmpByte = inputStream.read()__                                socket.setSoTimeout(endpoint.receiveTimeout)__                                if (-1 == tmpByte) {_                                    log.debug("Socket.read() returned END_OF_STREAM - resetting connection")__                                    MllpUtil.resetConnection(socket)__                                } else {_                                    ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                    clientThreads.add(clientThread)__                                    clientThread.start()__                                }_                            } catch (SocketTimeoutException timeoutEx) {_                                _                                log.debug("No Data - but the socket is there.  Starting ClientSocketThread")__                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            }_                        }_                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.trace("SocketTimeoutException waiting for new connections - no new connections")___                        for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                            ClientSocketThread thread = clientThreads.get(i)__                            if (!thread.isAlive()) {_                                clientThreads.remove(i)__                            }_                        }_                    } catch (InterruptedException interruptEx) {_                        log.debug("accept loop interrupted - closing ServerSocket")__                        try {_                            serverSocket.close()__                        } catch (Exception ex) {_                            log.debug("Exception encountered closing ServerSocket after InterruptedException - ignoring", ex)__                        }_                    } catch (Exception ex) {_                        log.error("Exception accepting new connection - retrying", ex)__                    }_                }_            } finally {_                log.debug("ServerSocket.accept loop finished - closing listener")__                if (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.debug("Exception encountered closing ServerSocket after accept loop had exited - ignoring", ex)__                    }_                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,log,debug,starting,acceptor,thread,try,while,is,interrupted,null,server,socket,server,socket,is,bound,server,socket,is,closed,socket,socket,null,try,socket,server,socket,accept,catch,socket,exception,socket,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,socket,exception,on,accept,ignoring,ex,continue,catch,ioexception,io,ex,log,error,exception,encountered,accepting,connection,closing,server,socket,io,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,exception,on,accept,ignoring,ex,continue,try,thread,sleep,100,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,check,for,available,data,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,log,warn,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,mllp,util,reset,connection,socket,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,socket,set,so,timeout,100,try,int,tmp,byte,input,stream,read,socket,set,so,timeout,endpoint,receive,timeout,if,1,tmp,byte,log,debug,socket,read,returned,resetting,connection,mllp,util,reset,connection,socket,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,debug,no,data,but,the,socket,is,there,starting,client,socket,thread,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,debug,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,interrupted,exception,ignoring,ex,catch,exception,ex,log,error,exception,accepting,new,connection,retrying,ex,finally,log,debug,server,socket,accept,loop,finished,closing,listener,if,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,accept,loop,had,exited,ignoring,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1457097808;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            log.debug("Starting acceptor thread")___            try {_                while (!isInterrupted()  &&  null != serverSocket && serverSocket.isBound()  &&  !serverSocket.isClosed()) {_                    _                    Socket socket = null__                    try {_                        socket = serverSocket.accept()__                    } catch (SocketException socketEx) {_                        _                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after SocketException on accept() - ignoring", ex)__                            }_                        }_                        continue__                    } catch (IOException ioEx) {_                        log.error("Exception encountered accepting connection - closing ServerSocket", ioEx)__                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after exception on accept() - ignoring", ex)__                            }_                        }_                        continue__                    }__                    try {_                    _                        Thread.sleep(100)__                        if (socket.isConnected() && !socket.isClosed()) {_                            log.debug("Socket appears to be there - check for available data")__                            InputStream inputStream__                            try {_                                inputStream = socket.getInputStream()__                            } catch (IOException ioEx) {_                                _                                log.warn("Failed to retrieve the InputStream for socket after the initial connection was accepted")__                                MllpUtil.resetConnection(socket)__                                continue__                            }__                            if (0 < inputStream.available()) {_                                _                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                                continue__                            }__                            _                            socket.setSoTimeout(100)__                            try {_                                int tmpByte = inputStream.read()__                                socket.setSoTimeout(endpoint.receiveTimeout)__                                if (-1 == tmpByte) {_                                    log.debug("Socket.read() returned END_OF_STREAM - resetting connection")__                                    MllpUtil.resetConnection(socket)__                                } else {_                                    ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                    clientThreads.add(clientThread)__                                    clientThread.start()__                                }_                            } catch (SocketTimeoutException timeoutEx) {_                                _                                log.debug("No Data - but the socket is there.  Starting ClientSocketThread")__                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            }_                        }_                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.trace("SocketTimeoutException waiting for new connections - no new connections")___                        for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                            ClientSocketThread thread = clientThreads.get(i)__                            if (!thread.isAlive()) {_                                clientThreads.remove(i)__                            }_                        }_                    } catch (InterruptedException interruptEx) {_                        log.debug("accept loop interrupted - closing ServerSocket")__                        try {_                            serverSocket.close()__                        } catch (Exception ex) {_                            log.debug("Exception encountered closing ServerSocket after InterruptedException - ignoring", ex)__                        }_                    } catch (Exception ex) {_                        log.error("Exception accepting new connection - retrying", ex)__                    }_                }_            } finally {_                log.debug("ServerSocket.accept loop finished - closing listener")__                if (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.debug("Exception encountered closing ServerSocket after accept loop had exited - ignoring", ex)__                    }_                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,log,debug,starting,acceptor,thread,try,while,is,interrupted,null,server,socket,server,socket,is,bound,server,socket,is,closed,socket,socket,null,try,socket,server,socket,accept,catch,socket,exception,socket,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,socket,exception,on,accept,ignoring,ex,continue,catch,ioexception,io,ex,log,error,exception,encountered,accepting,connection,closing,server,socket,io,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,exception,on,accept,ignoring,ex,continue,try,thread,sleep,100,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,check,for,available,data,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,log,warn,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,mllp,util,reset,connection,socket,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,socket,set,so,timeout,100,try,int,tmp,byte,input,stream,read,socket,set,so,timeout,endpoint,receive,timeout,if,1,tmp,byte,log,debug,socket,read,returned,resetting,connection,mllp,util,reset,connection,socket,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,debug,no,data,but,the,socket,is,there,starting,client,socket,thread,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,debug,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,interrupted,exception,ignoring,ex,catch,exception,ex,log,error,exception,accepting,new,connection,retrying,ex,finally,log,debug,server,socket,accept,loop,finished,closing,listener,if,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,accept,loop,had,exited,ignoring,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1460612302;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            log.debug("Starting acceptor thread")___            try {_                while (!isInterrupted()  &&  null != serverSocket && serverSocket.isBound()  &&  !serverSocket.isClosed()) {_                    _                    Socket socket = null__                    try {_                        socket = serverSocket.accept()__                    } catch (SocketException socketEx) {_                        _                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after SocketException on accept() - ignoring", ex)__                            }_                        }_                        continue__                    } catch (IOException ioEx) {_                        log.error("Exception encountered accepting connection - closing ServerSocket", ioEx)__                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after exception on accept() - ignoring", ex)__                            }_                        }_                        continue__                    }__                    try {_                    _                        Thread.sleep(100)__                        if (socket.isConnected() && !socket.isClosed()) {_                            log.debug("Socket appears to be there - check for available data")__                            InputStream inputStream__                            try {_                                inputStream = socket.getInputStream()__                            } catch (IOException ioEx) {_                                _                                log.warn("Failed to retrieve the InputStream for socket after the initial connection was accepted")__                                MllpUtil.resetConnection(socket)__                                continue__                            }__                            if (0 < inputStream.available()) {_                                _                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                                continue__                            }__                            _                            socket.setSoTimeout(100)__                            try {_                                int tmpByte = inputStream.read()__                                socket.setSoTimeout(endpoint.receiveTimeout)__                                if (-1 == tmpByte) {_                                    log.debug("Socket.read() returned END_OF_STREAM - resetting connection")__                                    MllpUtil.resetConnection(socket)__                                } else {_                                    ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                    clientThreads.add(clientThread)__                                    clientThread.start()__                                }_                            } catch (SocketTimeoutException timeoutEx) {_                                _                                log.debug("No Data - but the socket is there.  Starting ClientSocketThread")__                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            }_                        }_                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.trace("SocketTimeoutException waiting for new connections - no new connections")___                        for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                            ClientSocketThread thread = clientThreads.get(i)__                            if (!thread.isAlive()) {_                                clientThreads.remove(i)__                            }_                        }_                    } catch (InterruptedException interruptEx) {_                        log.debug("accept loop interrupted - closing ServerSocket")__                        try {_                            serverSocket.close()__                        } catch (Exception ex) {_                            log.debug("Exception encountered closing ServerSocket after InterruptedException - ignoring", ex)__                        }_                    } catch (Exception ex) {_                        log.error("Exception accepting new connection - retrying", ex)__                    }_                }_            } finally {_                log.debug("ServerSocket.accept loop finished - closing listener")__                if (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.debug("Exception encountered closing ServerSocket after accept loop had exited - ignoring", ex)__                    }_                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,log,debug,starting,acceptor,thread,try,while,is,interrupted,null,server,socket,server,socket,is,bound,server,socket,is,closed,socket,socket,null,try,socket,server,socket,accept,catch,socket,exception,socket,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,socket,exception,on,accept,ignoring,ex,continue,catch,ioexception,io,ex,log,error,exception,encountered,accepting,connection,closing,server,socket,io,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,exception,on,accept,ignoring,ex,continue,try,thread,sleep,100,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,check,for,available,data,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,log,warn,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,mllp,util,reset,connection,socket,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,socket,set,so,timeout,100,try,int,tmp,byte,input,stream,read,socket,set,so,timeout,endpoint,receive,timeout,if,1,tmp,byte,log,debug,socket,read,returned,resetting,connection,mllp,util,reset,connection,socket,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,debug,no,data,but,the,socket,is,there,starting,client,socket,thread,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,debug,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,interrupted,exception,ignoring,ex,catch,exception,ex,log,error,exception,accepting,new,connection,retrying,ex,finally,log,debug,server,socket,accept,loop,finished,closing,listener,if,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,accept,loop,had,exited,ignoring,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1461827354;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            log.debug("Starting acceptor thread")___            try {_                while (!isInterrupted()  &&  null != serverSocket && serverSocket.isBound()  &&  !serverSocket.isClosed()) {_                    _                    Socket socket = null__                    try {_                        socket = serverSocket.accept()__                    } catch (SocketTimeoutException timeoutEx ) {_                        _                        log.debug( "Timeout waiting for client connection - keep listening")__                        continue__                    } catch (SocketException socketEx) {_                        _                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after SocketException on accept() - ignoring", ex)__                            }_                        }_                        continue__                    } catch (IOException ioEx) {_                        log.error("Exception encountered accepting connection - closing ServerSocket", ioEx)__                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after exception on accept() - ignoring", ex)__                            }_                        }_                        continue__                    }__                    try {_                    _                        Thread.sleep(100)__                        if (socket.isConnected() && !socket.isClosed()) {_                            log.debug("Socket appears to be there - check for available data")__                            InputStream inputStream__                            try {_                                inputStream = socket.getInputStream()__                            } catch (IOException ioEx) {_                                _                                log.warn("Failed to retrieve the InputStream for socket after the initial connection was accepted")__                                MllpUtil.resetConnection(socket)__                                continue__                            }__                            if (0 < inputStream.available()) {_                                _                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                                continue__                            }__                            _                            socket.setSoTimeout(100)__                            try {_                                int tmpByte = inputStream.read()__                                socket.setSoTimeout(endpoint.receiveTimeout)__                                if (-1 == tmpByte) {_                                    log.debug("Socket.read() returned END_OF_STREAM - resetting connection")__                                    MllpUtil.resetConnection(socket)__                                } else {_                                    ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                    clientThreads.add(clientThread)__                                    clientThread.start()__                                }_                            } catch (SocketTimeoutException timeoutEx) {_                                _                                log.debug("No Data - but the socket is there.  Starting ClientSocketThread")__                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            }_                        }_                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.trace("SocketTimeoutException waiting for new connections - no new connections")___                        for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                            ClientSocketThread thread = clientThreads.get(i)__                            if (!thread.isAlive()) {_                                clientThreads.remove(i)__                            }_                        }_                    } catch (InterruptedException interruptEx) {_                        log.debug("accept loop interrupted - closing ServerSocket")__                        try {_                            serverSocket.close()__                        } catch (Exception ex) {_                            log.debug("Exception encountered closing ServerSocket after InterruptedException - ignoring", ex)__                        }_                    } catch (Exception ex) {_                        log.error("Exception accepting new connection - retrying", ex)__                    }_                }_            } finally {_                log.debug("ServerSocket.accept loop finished - closing listener")__                if (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.debug("Exception encountered closing ServerSocket after accept loop had exited - ignoring", ex)__                    }_                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,log,debug,starting,acceptor,thread,try,while,is,interrupted,null,server,socket,server,socket,is,bound,server,socket,is,closed,socket,socket,null,try,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,log,debug,timeout,waiting,for,client,connection,keep,listening,continue,catch,socket,exception,socket,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,socket,exception,on,accept,ignoring,ex,continue,catch,ioexception,io,ex,log,error,exception,encountered,accepting,connection,closing,server,socket,io,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,exception,on,accept,ignoring,ex,continue,try,thread,sleep,100,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,check,for,available,data,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,log,warn,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,mllp,util,reset,connection,socket,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,socket,set,so,timeout,100,try,int,tmp,byte,input,stream,read,socket,set,so,timeout,endpoint,receive,timeout,if,1,tmp,byte,log,debug,socket,read,returned,resetting,connection,mllp,util,reset,connection,socket,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,debug,no,data,but,the,socket,is,there,starting,client,socket,thread,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,debug,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,interrupted,exception,ignoring,ex,catch,exception,ex,log,error,exception,accepting,new,connection,retrying,ex,finally,log,debug,server,socket,accept,loop,finished,closing,listener,if,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,accept,loop,had,exited,ignoring,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1461827354;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            log.debug("Starting acceptor thread")___            try {_                while (!isInterrupted()  &&  null != serverSocket && serverSocket.isBound()  &&  !serverSocket.isClosed()) {_                    _                    Socket socket = null__                    try {_                        socket = serverSocket.accept()__                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.debug("Timeout waiting for client connection - keep listening")__                        continue__                    } catch (SocketException socketEx) {_                        _                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after SocketException on accept() - ignoring", ex)__                            }_                        }_                        continue__                    } catch (IOException ioEx) {_                        log.error("Exception encountered accepting connection - closing ServerSocket", ioEx)__                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after exception on accept() - ignoring", ex)__                            }_                        }_                        continue__                    }__                    try {_                    _                        Thread.sleep(100)__                        if (socket.isConnected() && !socket.isClosed()) {_                            log.debug("Socket appears to be there - check for available data")__                            InputStream inputStream__                            try {_                                inputStream = socket.getInputStream()__                            } catch (IOException ioEx) {_                                _                                log.warn("Failed to retrieve the InputStream for socket after the initial connection was accepted")__                                MllpUtil.resetConnection(socket)__                                continue__                            }__                            if (0 < inputStream.available()) {_                                _                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                                continue__                            }__                            _                            socket.setSoTimeout(100)__                            try {_                                int tmpByte = inputStream.read()__                                socket.setSoTimeout(endpoint.receiveTimeout)__                                if (-1 == tmpByte) {_                                    log.debug("Socket.read() returned END_OF_STREAM - resetting connection")__                                    MllpUtil.resetConnection(socket)__                                } else {_                                    ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                    clientThreads.add(clientThread)__                                    clientThread.start()__                                }_                            } catch (SocketTimeoutException timeoutEx) {_                                _                                log.debug("No Data - but the socket is there.  Starting ClientSocketThread")__                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            }_                        }_                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.trace("SocketTimeoutException waiting for new connections - no new connections")___                        for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                            ClientSocketThread thread = clientThreads.get(i)__                            if (!thread.isAlive()) {_                                clientThreads.remove(i)__                            }_                        }_                    } catch (InterruptedException interruptEx) {_                        log.debug("accept loop interrupted - closing ServerSocket")__                        try {_                            serverSocket.close()__                        } catch (Exception ex) {_                            log.debug("Exception encountered closing ServerSocket after InterruptedException - ignoring", ex)__                        }_                    } catch (Exception ex) {_                        log.error("Exception accepting new connection - retrying", ex)__                    }_                }_            } finally {_                log.debug("ServerSocket.accept loop finished - closing listener")__                if (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.debug("Exception encountered closing ServerSocket after accept loop had exited - ignoring", ex)__                    }_                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,log,debug,starting,acceptor,thread,try,while,is,interrupted,null,server,socket,server,socket,is,bound,server,socket,is,closed,socket,socket,null,try,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,log,debug,timeout,waiting,for,client,connection,keep,listening,continue,catch,socket,exception,socket,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,socket,exception,on,accept,ignoring,ex,continue,catch,ioexception,io,ex,log,error,exception,encountered,accepting,connection,closing,server,socket,io,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,exception,on,accept,ignoring,ex,continue,try,thread,sleep,100,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,check,for,available,data,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,log,warn,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,mllp,util,reset,connection,socket,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,socket,set,so,timeout,100,try,int,tmp,byte,input,stream,read,socket,set,so,timeout,endpoint,receive,timeout,if,1,tmp,byte,log,debug,socket,read,returned,resetting,connection,mllp,util,reset,connection,socket,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,debug,no,data,but,the,socket,is,there,starting,client,socket,thread,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,debug,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,interrupted,exception,ignoring,ex,catch,exception,ex,log,error,exception,accepting,new,connection,retrying,ex,finally,log,debug,server,socket,accept,loop,finished,closing,listener,if,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,accept,loop,had,exited,ignoring,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1473189753;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            log.debug("Starting acceptor thread")___            try {_                while (!isInterrupted()  &&  null != serverSocket && serverSocket.isBound()  &&  !serverSocket.isClosed()) {_                    _                    Socket socket = null__                    try {_                        socket = serverSocket.accept()__                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.debug("Timeout waiting for client connection - keep listening")__                        continue__                    } catch (SocketException socketEx) {_                        _                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after SocketException on accept() - ignoring", ex)__                            }_                        }_                        continue__                    } catch (IOException ioEx) {_                        log.error("Exception encountered accepting connection - closing ServerSocket", ioEx)__                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after exception on accept() - ignoring", ex)__                            }_                        }_                        continue__                    }__                    try {_                    _                        Thread.sleep(100)__                        if (socket.isConnected() && !socket.isClosed()) {_                            log.debug("Socket appears to be there - check for available data")__                            InputStream inputStream__                            try {_                                inputStream = socket.getInputStream()__                            } catch (IOException ioEx) {_                                _                                log.warn("Failed to retrieve the InputStream for socket after the initial connection was accepted")__                                MllpUtil.resetConnection(socket)__                                continue__                            }__                            if (0 < inputStream.available()) {_                                _                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                                continue__                            }__                            _                            socket.setSoTimeout(100)__                            try {_                                int tmpByte = inputStream.read()__                                socket.setSoTimeout(endpoint.receiveTimeout)__                                if (-1 == tmpByte) {_                                    log.debug("Socket.read() returned END_OF_STREAM - resetting connection")__                                    MllpUtil.resetConnection(socket)__                                } else {_                                    ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                    clientThreads.add(clientThread)__                                    clientThread.start()__                                }_                            } catch (SocketTimeoutException timeoutEx) {_                                _                                log.debug("No Data - but the socket is there.  Starting ClientSocketThread")__                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            }_                        }_                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.trace("SocketTimeoutException waiting for new connections - no new connections")___                        for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                            ClientSocketThread thread = clientThreads.get(i)__                            if (!thread.isAlive()) {_                                clientThreads.remove(i)__                            }_                        }_                    } catch (InterruptedException interruptEx) {_                        log.debug("accept loop interrupted - closing ServerSocket")__                        try {_                            serverSocket.close()__                        } catch (Exception ex) {_                            log.debug("Exception encountered closing ServerSocket after InterruptedException - ignoring", ex)__                        }_                    } catch (Exception ex) {_                        log.error("Exception accepting new connection - retrying", ex)__                    }_                }_            } finally {_                log.debug("ServerSocket.accept loop finished - closing listener")__                if (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.debug("Exception encountered closing ServerSocket after accept loop had exited - ignoring", ex)__                    }_                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,log,debug,starting,acceptor,thread,try,while,is,interrupted,null,server,socket,server,socket,is,bound,server,socket,is,closed,socket,socket,null,try,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,log,debug,timeout,waiting,for,client,connection,keep,listening,continue,catch,socket,exception,socket,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,socket,exception,on,accept,ignoring,ex,continue,catch,ioexception,io,ex,log,error,exception,encountered,accepting,connection,closing,server,socket,io,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,exception,on,accept,ignoring,ex,continue,try,thread,sleep,100,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,check,for,available,data,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,log,warn,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,mllp,util,reset,connection,socket,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,socket,set,so,timeout,100,try,int,tmp,byte,input,stream,read,socket,set,so,timeout,endpoint,receive,timeout,if,1,tmp,byte,log,debug,socket,read,returned,resetting,connection,mllp,util,reset,connection,socket,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,debug,no,data,but,the,socket,is,there,starting,client,socket,thread,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,debug,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,interrupted,exception,ignoring,ex,catch,exception,ex,log,error,exception,accepting,new,connection,retrying,ex,finally,log,debug,server,socket,accept,loop,finished,closing,listener,if,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,accept,loop,had,exited,ignoring,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1473924202;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            log.debug("Starting acceptor thread")___            try {_                while (!isInterrupted()  &&  null != serverSocket && serverSocket.isBound()  &&  !serverSocket.isClosed()) {_                    _                    Socket socket = null__                    try {_                        socket = serverSocket.accept()__                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.debug("Timeout waiting for client connection - keep listening")__                        continue__                    } catch (SocketException socketEx) {_                        _                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after SocketException on accept() - ignoring", ex)__                            }_                        }_                        continue__                    } catch (IOException ioEx) {_                        log.error("Exception encountered accepting connection - closing ServerSocket", ioEx)__                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after exception on accept() - ignoring", ex)__                            }_                        }_                        continue__                    }__                    try {_                    _                        Thread.sleep(100)__                        if (socket.isConnected() && !socket.isClosed()) {_                            log.debug("Socket appears to be there - check for available data")__                            InputStream inputStream__                            try {_                                inputStream = socket.getInputStream()__                            } catch (IOException ioEx) {_                                _                                log.warn("Failed to retrieve the InputStream for socket after the initial connection was accepted")__                                MllpUtil.resetConnection(socket)__                                continue__                            }__                            if (0 < inputStream.available()) {_                                _                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                                continue__                            }__                            _                            socket.setSoTimeout(100)__                            try {_                                int tmpByte = inputStream.read()__                                socket.setSoTimeout(endpoint.receiveTimeout)__                                if (-1 == tmpByte) {_                                    log.debug("Socket.read() returned END_OF_STREAM - resetting connection")__                                    MllpUtil.resetConnection(socket)__                                } else {_                                    ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                    clientThreads.add(clientThread)__                                    clientThread.start()__                                }_                            } catch (SocketTimeoutException timeoutEx) {_                                _                                log.debug("No Data - but the socket is there.  Starting ClientSocketThread")__                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            }_                        }_                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.trace("SocketTimeoutException waiting for new connections - no new connections")___                        for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                            ClientSocketThread thread = clientThreads.get(i)__                            if (!thread.isAlive()) {_                                clientThreads.remove(i)__                            }_                        }_                    } catch (InterruptedException interruptEx) {_                        log.debug("accept loop interrupted - closing ServerSocket")__                        try {_                            serverSocket.close()__                        } catch (Exception ex) {_                            log.debug("Exception encountered closing ServerSocket after InterruptedException - ignoring", ex)__                        }_                    } catch (Exception ex) {_                        log.error("Exception accepting new connection - retrying", ex)__                    }_                }_            } finally {_                log.debug("ServerSocket.accept loop finished - closing listener")__                if (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.debug("Exception encountered closing ServerSocket after accept loop had exited - ignoring", ex)__                    }_                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,log,debug,starting,acceptor,thread,try,while,is,interrupted,null,server,socket,server,socket,is,bound,server,socket,is,closed,socket,socket,null,try,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,log,debug,timeout,waiting,for,client,connection,keep,listening,continue,catch,socket,exception,socket,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,socket,exception,on,accept,ignoring,ex,continue,catch,ioexception,io,ex,log,error,exception,encountered,accepting,connection,closing,server,socket,io,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,exception,on,accept,ignoring,ex,continue,try,thread,sleep,100,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,check,for,available,data,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,log,warn,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,mllp,util,reset,connection,socket,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,socket,set,so,timeout,100,try,int,tmp,byte,input,stream,read,socket,set,so,timeout,endpoint,receive,timeout,if,1,tmp,byte,log,debug,socket,read,returned,resetting,connection,mllp,util,reset,connection,socket,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,debug,no,data,but,the,socket,is,there,starting,client,socket,thread,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,debug,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,interrupted,exception,ignoring,ex,catch,exception,ex,log,error,exception,accepting,new,connection,retrying,ex,finally,log,debug,server,socket,accept,loop,finished,closing,listener,if,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,accept,loop,had,exited,ignoring,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1479844564;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            log.debug("Starting acceptor thread")___            try {_                while (!isInterrupted()  &&  null != serverSocket && serverSocket.isBound()  &&  !serverSocket.isClosed()) {_                    _                    Socket socket = null__                    try {_                        socket = serverSocket.accept()__                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.debug("Timeout waiting for client connection - keep listening")__                        continue__                    } catch (SocketException socketEx) {_                        _                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after SocketException on accept() - ignoring", ex)__                            }_                        }_                        continue__                    } catch (IOException ioEx) {_                        log.error("Exception encountered accepting connection - closing ServerSocket", ioEx)__                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after exception on accept() - ignoring", ex)__                            }_                        }_                        continue__                    }__                    try {_                    _                        Thread.sleep(100)__                        if (socket.isConnected() && !socket.isClosed()) {_                            log.debug("Socket appears to be there - check for available data")__                            InputStream inputStream__                            try {_                                inputStream = socket.getInputStream()__                            } catch (IOException ioEx) {_                                _                                log.warn("Failed to retrieve the InputStream for socket after the initial connection was accepted")__                                MllpUtil.resetConnection(socket)__                                continue__                            }__                            if (0 < inputStream.available()) {_                                _                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                                continue__                            }__                            _                            socket.setSoTimeout(100)__                            try {_                                int tmpByte = inputStream.read()__                                socket.setSoTimeout(endpoint.receiveTimeout)__                                if (-1 == tmpByte) {_                                    log.debug("Socket.read() returned END_OF_STREAM - resetting connection")__                                    MllpUtil.resetConnection(socket)__                                } else {_                                    ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                    clientThreads.add(clientThread)__                                    clientThread.start()__                                }_                            } catch (SocketTimeoutException timeoutEx) {_                                _                                log.debug("No Data - but the socket is there.  Starting ClientSocketThread")__                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            }_                        }_                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.trace("SocketTimeoutException waiting for new connections - no new connections")___                        for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                            ClientSocketThread thread = clientThreads.get(i)__                            if (!thread.isAlive()) {_                                clientThreads.remove(i)__                            }_                        }_                    } catch (InterruptedException interruptEx) {_                        log.debug("accept loop interrupted - closing ServerSocket")__                        try {_                            serverSocket.close()__                        } catch (Exception ex) {_                            log.debug("Exception encountered closing ServerSocket after InterruptedException - ignoring", ex)__                        }_                    } catch (Exception ex) {_                        log.error("Exception accepting new connection - retrying", ex)__                    }_                }_            } finally {_                log.debug("ServerSocket.accept loop finished - closing listener")__                if (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.debug("Exception encountered closing ServerSocket after accept loop had exited - ignoring", ex)__                    }_                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,log,debug,starting,acceptor,thread,try,while,is,interrupted,null,server,socket,server,socket,is,bound,server,socket,is,closed,socket,socket,null,try,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,log,debug,timeout,waiting,for,client,connection,keep,listening,continue,catch,socket,exception,socket,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,socket,exception,on,accept,ignoring,ex,continue,catch,ioexception,io,ex,log,error,exception,encountered,accepting,connection,closing,server,socket,io,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,exception,on,accept,ignoring,ex,continue,try,thread,sleep,100,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,check,for,available,data,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,log,warn,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,mllp,util,reset,connection,socket,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,socket,set,so,timeout,100,try,int,tmp,byte,input,stream,read,socket,set,so,timeout,endpoint,receive,timeout,if,1,tmp,byte,log,debug,socket,read,returned,resetting,connection,mllp,util,reset,connection,socket,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,debug,no,data,but,the,socket,is,there,starting,client,socket,thread,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,debug,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,interrupted,exception,ignoring,ex,catch,exception,ex,log,error,exception,accepting,new,connection,retrying,ex,finally,log,debug,server,socket,accept,loop,finished,closing,listener,if,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,accept,loop,had,exited,ignoring,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1480003968;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            log.debug("Starting acceptor thread")___            try {_                while (!isInterrupted()  &&  null != serverSocket && serverSocket.isBound()  &&  !serverSocket.isClosed()) {_                    _                    Socket socket = null__                    try {_                        socket = serverSocket.accept()__                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.debug("Timeout waiting for client connection - keep listening")__                        continue__                    } catch (SocketException socketEx) {_                        _                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after SocketException on accept() - ignoring", ex)__                            }_                        }_                        continue__                    } catch (IOException ioEx) {_                        log.error("Exception encountered accepting connection - closing ServerSocket", ioEx)__                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after exception on accept() - ignoring", ex)__                            }_                        }_                        continue__                    }__                    try {_                    _                        Thread.sleep(100)__                        if (socket.isConnected() && !socket.isClosed()) {_                            log.debug("Socket appears to be there - check for available data")__                            InputStream inputStream__                            try {_                                inputStream = socket.getInputStream()__                            } catch (IOException ioEx) {_                                _                                log.warn("Failed to retrieve the InputStream for socket after the initial connection was accepted")__                                MllpUtil.resetConnection(socket)__                                continue__                            }__                            if (0 < inputStream.available()) {_                                _                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                                continue__                            }__                            _                            socket.setSoTimeout(100)__                            try {_                                int tmpByte = inputStream.read()__                                socket.setSoTimeout(endpoint.receiveTimeout)__                                if (-1 == tmpByte) {_                                    log.debug("Socket.read() returned END_OF_STREAM - resetting connection")__                                    MllpUtil.resetConnection(socket)__                                } else {_                                    ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                    clientThreads.add(clientThread)__                                    clientThread.start()__                                }_                            } catch (SocketTimeoutException timeoutEx) {_                                _                                log.debug("No Data - but the socket is there.  Starting ClientSocketThread")__                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            }_                        }_                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.trace("SocketTimeoutException waiting for new connections - no new connections")___                        for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                            ClientSocketThread thread = clientThreads.get(i)__                            if (!thread.isAlive()) {_                                clientThreads.remove(i)__                            }_                        }_                    } catch (InterruptedException interruptEx) {_                        log.debug("accept loop interrupted - closing ServerSocket")__                        try {_                            serverSocket.close()__                        } catch (Exception ex) {_                            log.debug("Exception encountered closing ServerSocket after InterruptedException - ignoring", ex)__                        }_                    } catch (Exception ex) {_                        log.error("Exception accepting new connection - retrying", ex)__                    }_                }_            } finally {_                log.debug("ServerSocket.accept loop finished - closing listener")__                if (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.debug("Exception encountered closing ServerSocket after accept loop had exited - ignoring", ex)__                    }_                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,log,debug,starting,acceptor,thread,try,while,is,interrupted,null,server,socket,server,socket,is,bound,server,socket,is,closed,socket,socket,null,try,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,log,debug,timeout,waiting,for,client,connection,keep,listening,continue,catch,socket,exception,socket,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,socket,exception,on,accept,ignoring,ex,continue,catch,ioexception,io,ex,log,error,exception,encountered,accepting,connection,closing,server,socket,io,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,exception,on,accept,ignoring,ex,continue,try,thread,sleep,100,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,check,for,available,data,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,log,warn,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,mllp,util,reset,connection,socket,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,socket,set,so,timeout,100,try,int,tmp,byte,input,stream,read,socket,set,so,timeout,endpoint,receive,timeout,if,1,tmp,byte,log,debug,socket,read,returned,resetting,connection,mllp,util,reset,connection,socket,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,debug,no,data,but,the,socket,is,there,starting,client,socket,thread,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,debug,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,interrupted,exception,ignoring,ex,catch,exception,ex,log,error,exception,accepting,new,connection,retrying,ex,finally,log,debug,server,socket,accept,loop,finished,closing,listener,if,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,accept,loop,had,exited,ignoring,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1481829620;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            MDC.put("camel.contextId", endpoint.getCamelContext().getName())___            try {_                while (!isInterrupted()  &&  null != serverSocket && serverSocket.isBound()  &&  !serverSocket.isClosed()) {_                    Socket socket = null__                    try {_                        socket = serverSocket.accept()__                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.debug("Timeout waiting for client connection - keep listening")__                        continue__                    } catch (SocketException socketEx) {_                        _                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after SocketException on accept() - ignoring", ex)__                            }_                        }_                        continue__                    } catch (IOException ioEx) {_                        log.error("Exception encountered accepting connection - closing ServerSocket", ioEx)__                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after exception on accept() - ignoring", ex)__                            }_                        }_                        continue__                    }__                    try {_                    _                        if (socket.isConnected() && !socket.isClosed()) {_                            log.debug("Socket appears to be there - checking for available data in {} milliseconds", SOCKET_STARTUP_TEST_WAIT)__                            Thread.sleep(SOCKET_STARTUP_TEST_WAIT)___                            InputStream inputStream__                            try {_                                inputStream = socket.getInputStream()__                            } catch (IOException ioEx) {_                                MllpSocketUtil.reset(socket, log, "Failed to retrieve the InputStream for socket after the initial connection was accepted")__                                continue__                            }__                            if (0 < inputStream.available()) {_                                _                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                                continue__                            }__                            _                            MllpSocketUtil.setSoTimeout(socket, SOCKET_STARTUP_TEST_READ_TIMEOUT, log, "Preparing to check for available data on component startup")__                            try {_                                int tmpByte = inputStream.read()__                                if (-1 == tmpByte) {_                                    log.debug("Check for available data failed - Socket.read() returned END_OF_STREAM")__                                    MllpSocketUtil.close(socket, null, null)__                                } else {_                                    ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                    clientThreads.add(clientThread)__                                    clientThread.start()__                                }_                            } catch (SocketTimeoutException timeoutEx) {_                                _                                String logMessageFormat =_                                    "Check for available data failed - Socket.read() timed-out after {} milliseconds."_                                        + "  No Data - but the socket is there.  Starting ClientSocketThread"__                                log.debug(logMessageFormat, SOCKET_STARTUP_TEST_READ_TIMEOUT)__                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            } catch (IOException ioEx) {_                                log.debug("Ignoring IOException encountered when attempting to read a byte - connection was reset")__                                try {_                                    socket.close()__                                } catch (IOException closeEx) {_                                    log.debug("Ignoring IOException encountered when attempting to close the connection after the connection reset was detected", closeEx)__                                }_                            }_                        }_                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.trace("SocketTimeoutException waiting for new connections - no new connections")___                        for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                            ClientSocketThread thread = clientThreads.get(i)__                            if (!thread.isAlive()) {_                                clientThreads.remove(i)__                            }_                        }_                    } catch (InterruptedException interruptEx) {_                        log.debug("accept loop interrupted - closing ServerSocket")__                        try {_                            serverSocket.close()__                        } catch (Exception ex) {_                            log.debug("Exception encountered closing ServerSocket after InterruptedException - ignoring", ex)__                        }_                    } catch (Exception ex) {_                        log.error("Exception accepting new connection - retrying", ex)__                    }_                }_            } finally {_                log.debug("ServerSocket.accept loop finished - closing listener")__                if (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.debug("Exception encountered closing ServerSocket after accept loop had exited - ignoring", ex)__                    }_                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,mdc,put,camel,context,id,endpoint,get,camel,context,get,name,try,while,is,interrupted,null,server,socket,server,socket,is,bound,server,socket,is,closed,socket,socket,null,try,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,log,debug,timeout,waiting,for,client,connection,keep,listening,continue,catch,socket,exception,socket,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,socket,exception,on,accept,ignoring,ex,continue,catch,ioexception,io,ex,log,error,exception,encountered,accepting,connection,closing,server,socket,io,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,exception,on,accept,ignoring,ex,continue,try,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,checking,for,available,data,in,milliseconds,thread,sleep,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,mllp,socket,util,reset,socket,log,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,mllp,socket,util,set,so,timeout,socket,log,preparing,to,check,for,available,data,on,component,startup,try,int,tmp,byte,input,stream,read,if,1,tmp,byte,log,debug,check,for,available,data,failed,socket,read,returned,mllp,socket,util,close,socket,null,null,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,string,log,message,format,check,for,available,data,failed,socket,read,timed,out,after,milliseconds,no,data,but,the,socket,is,there,starting,client,socket,thread,log,debug,log,message,format,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,ioexception,io,ex,log,debug,ignoring,ioexception,encountered,when,attempting,to,read,a,byte,connection,was,reset,try,socket,close,catch,ioexception,close,ex,log,debug,ignoring,ioexception,encountered,when,attempting,to,close,the,connection,after,the,connection,reset,was,detected,close,ex,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,debug,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,interrupted,exception,ignoring,ex,catch,exception,ex,log,error,exception,accepting,new,connection,retrying,ex,finally,log,debug,server,socket,accept,loop,finished,closing,listener,if,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,accept,loop,had,exited,ignoring,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1481875493;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            MDC.put("camel.contextId", endpoint.getCamelContext().getName())___            try {_                while (!isInterrupted()  &&  null != serverSocket && serverSocket.isBound()  &&  !serverSocket.isClosed()) {_                    Socket socket = null__                    try {_                        socket = serverSocket.accept()__                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.debug("Timeout waiting for client connection - keep listening")__                        continue__                    } catch (SocketException socketEx) {_                        _                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after SocketException on accept() - ignoring", ex)__                            }_                        }_                        continue__                    } catch (IOException ioEx) {_                        log.error("Exception encountered accepting connection - closing ServerSocket", ioEx)__                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after exception on accept() - ignoring", ex)__                            }_                        }_                        continue__                    }__                    try {_                    _                        if (socket.isConnected() && !socket.isClosed()) {_                            log.debug("Socket appears to be there - checking for available data in {} milliseconds", SOCKET_STARTUP_TEST_WAIT)__                            Thread.sleep(SOCKET_STARTUP_TEST_WAIT)___                            InputStream inputStream__                            try {_                                inputStream = socket.getInputStream()__                            } catch (IOException ioEx) {_                                MllpSocketUtil.reset(socket, log, "Failed to retrieve the InputStream for socket after the initial connection was accepted")__                                continue__                            }__                            if (0 < inputStream.available()) {_                                _                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                                continue__                            }__                            _                            MllpSocketUtil.setSoTimeout(socket, SOCKET_STARTUP_TEST_READ_TIMEOUT, log, "Preparing to check for available data on component startup")__                            try {_                                int tmpByte = inputStream.read()__                                if (-1 == tmpByte) {_                                    log.debug("Check for available data failed - Socket.read() returned END_OF_STREAM")__                                    MllpSocketUtil.close(socket, null, null)__                                } else {_                                    ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                    clientThreads.add(clientThread)__                                    clientThread.start()__                                }_                            } catch (SocketTimeoutException timeoutEx) {_                                _                                String logMessageFormat =_                                    "Check for available data failed - Socket.read() timed-out after {} milliseconds."_                                        + "  No Data - but the socket is there.  Starting ClientSocketThread"__                                log.debug(logMessageFormat, SOCKET_STARTUP_TEST_READ_TIMEOUT)__                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            } catch (IOException ioEx) {_                                log.debug("Ignoring IOException encountered when attempting to read a byte - connection was reset")__                                try {_                                    socket.close()__                                } catch (IOException closeEx) {_                                    log.debug("Ignoring IOException encountered when attempting to close the connection after the connection reset was detected", closeEx)__                                }_                            }_                        }_                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.trace("SocketTimeoutException waiting for new connections - no new connections")___                        for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                            ClientSocketThread thread = clientThreads.get(i)__                            if (!thread.isAlive()) {_                                clientThreads.remove(i)__                            }_                        }_                    } catch (InterruptedException interruptEx) {_                        log.debug("accept loop interrupted - closing ServerSocket")__                        try {_                            serverSocket.close()__                        } catch (Exception ex) {_                            log.debug("Exception encountered closing ServerSocket after InterruptedException - ignoring", ex)__                        }_                    } catch (Exception ex) {_                        log.error("Exception accepting new connection - retrying", ex)__                    }_                }_            } finally {_                log.debug("ServerSocket.accept loop finished - closing listener")__                if (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.debug("Exception encountered closing ServerSocket after accept loop had exited - ignoring", ex)__                    }_                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,mdc,put,camel,context,id,endpoint,get,camel,context,get,name,try,while,is,interrupted,null,server,socket,server,socket,is,bound,server,socket,is,closed,socket,socket,null,try,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,log,debug,timeout,waiting,for,client,connection,keep,listening,continue,catch,socket,exception,socket,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,socket,exception,on,accept,ignoring,ex,continue,catch,ioexception,io,ex,log,error,exception,encountered,accepting,connection,closing,server,socket,io,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,exception,on,accept,ignoring,ex,continue,try,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,checking,for,available,data,in,milliseconds,thread,sleep,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,mllp,socket,util,reset,socket,log,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,mllp,socket,util,set,so,timeout,socket,log,preparing,to,check,for,available,data,on,component,startup,try,int,tmp,byte,input,stream,read,if,1,tmp,byte,log,debug,check,for,available,data,failed,socket,read,returned,mllp,socket,util,close,socket,null,null,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,string,log,message,format,check,for,available,data,failed,socket,read,timed,out,after,milliseconds,no,data,but,the,socket,is,there,starting,client,socket,thread,log,debug,log,message,format,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,ioexception,io,ex,log,debug,ignoring,ioexception,encountered,when,attempting,to,read,a,byte,connection,was,reset,try,socket,close,catch,ioexception,close,ex,log,debug,ignoring,ioexception,encountered,when,attempting,to,close,the,connection,after,the,connection,reset,was,detected,close,ex,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,debug,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,interrupted,exception,ignoring,ex,catch,exception,ex,log,error,exception,accepting,new,connection,retrying,ex,finally,log,debug,server,socket,accept,loop,finished,closing,listener,if,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,accept,loop,had,exited,ignoring,ex
MllpTcpServerConsumer -> ServerSocketThread -> public void run();1494247089;The main ServerSocket.accept() loop_<p/>_NOTE:  When a connection is received, the Socket is checked after a brief delay in an attempt to determine_if this is a load-balancer probe.  The test is done before the ClientSocketThread is created to avoid creating_a large number of short lived threads, which is what can occur if the load balancer polling interval is very_short.;public void run() {_            MDC.put("camel.contextId", endpoint.getCamelContext().getName())___            try {_                while (!isInterrupted()  &&  null != serverSocket && serverSocket.isBound()  &&  !serverSocket.isClosed()) {_                    Socket socket = null__                    try {_                        socket = serverSocket.accept()__                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.debug("Timeout waiting for client connection - keep listening")__                        continue__                    } catch (SocketException socketEx) {_                        _                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after SocketException on accept() - ignoring", ex)__                            }_                        }_                        continue__                    } catch (IOException ioEx) {_                        log.error("Exception encountered accepting connection - closing ServerSocket", ioEx)__                        if (serverSocket.isBound()) {_                            try {_                                serverSocket.close()__                            } catch (Exception ex) {_                                log.debug("Exception encountered closing ServerSocket after exception on accept() - ignoring", ex)__                            }_                        }_                        continue__                    }__                    try {_                    _                        if (socket.isConnected() && !socket.isClosed()) {_                            log.debug("Socket appears to be there - checking for available data in {} milliseconds", SOCKET_STARTUP_TEST_WAIT)__                            Thread.sleep(SOCKET_STARTUP_TEST_WAIT)___                            InputStream inputStream__                            try {_                                inputStream = socket.getInputStream()__                            } catch (IOException ioEx) {_                                MllpSocketUtil.reset(socket, log, "Failed to retrieve the InputStream for socket after the initial connection was accepted")__                                continue__                            }__                            if (0 < inputStream.available()) {_                                _                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                                continue__                            }__                            _                            MllpSocketUtil.setSoTimeout(socket, SOCKET_STARTUP_TEST_READ_TIMEOUT, log, "Preparing to check for available data on component startup")__                            try {_                                int tmpByte = inputStream.read()__                                if (-1 == tmpByte) {_                                    log.debug("Check for available data failed - Socket.read() returned END_OF_STREAM")__                                    MllpSocketUtil.close(socket, null, null)__                                } else {_                                    ClientSocketThread clientThread = new ClientSocketThread(socket, tmpByte)__                                    clientThreads.add(clientThread)__                                    clientThread.start()__                                }_                            } catch (SocketTimeoutException timeoutEx) {_                                _                                String logMessageFormat =_                                    "Check for available data failed - Socket.read() timed-out after {} milliseconds."_                                        + "  No Data - but the socket is there.  Starting ClientSocketThread"__                                log.debug(logMessageFormat, SOCKET_STARTUP_TEST_READ_TIMEOUT)__                                ClientSocketThread clientThread = new ClientSocketThread(socket, null)__                                clientThreads.add(clientThread)__                                clientThread.start()__                            } catch (IOException ioEx) {_                                log.debug("Ignoring IOException encountered when attempting to read a byte - connection was reset")__                                try {_                                    socket.close()__                                } catch (IOException closeEx) {_                                    log.debug("Ignoring IOException encountered when attempting to close the connection after the connection reset was detected", closeEx)__                                }_                            }_                        }_                    } catch (SocketTimeoutException timeoutEx) {_                        _                        log.trace("SocketTimeoutException waiting for new connections - no new connections")___                        for (int i = clientThreads.size() - 1_ i >= 0_ --i) {_                            ClientSocketThread thread = clientThreads.get(i)__                            if (!thread.isAlive()) {_                                clientThreads.remove(i)__                            }_                        }_                    } catch (InterruptedException interruptEx) {_                        log.debug("accept loop interrupted - closing ServerSocket")__                        try {_                            serverSocket.close()__                        } catch (Exception ex) {_                            log.debug("Exception encountered closing ServerSocket after InterruptedException - ignoring", ex)__                        }_                    } catch (Exception ex) {_                        log.error("Exception accepting new connection - retrying", ex)__                    }_                }_            } finally {_                log.debug("ServerSocket.accept loop finished - closing listener")__                if (null != serverSocket && serverSocket.isBound() && !serverSocket.isClosed()) {_                    try {_                        serverSocket.close()__                    } catch (Exception ex) {_                        log.debug("Exception encountered closing ServerSocket after accept loop had exited - ignoring", ex)__                    }_                }_            }_        };the,main,server,socket,accept,loop,p,note,when,a,connection,is,received,the,socket,is,checked,after,a,brief,delay,in,an,attempt,to,determine,if,this,is,a,load,balancer,probe,the,test,is,done,before,the,client,socket,thread,is,created,to,avoid,creating,a,large,number,of,short,lived,threads,which,is,what,can,occur,if,the,load,balancer,polling,interval,is,very,short;public,void,run,mdc,put,camel,context,id,endpoint,get,camel,context,get,name,try,while,is,interrupted,null,server,socket,server,socket,is,bound,server,socket,is,closed,socket,socket,null,try,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,log,debug,timeout,waiting,for,client,connection,keep,listening,continue,catch,socket,exception,socket,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,socket,exception,on,accept,ignoring,ex,continue,catch,ioexception,io,ex,log,error,exception,encountered,accepting,connection,closing,server,socket,io,ex,if,server,socket,is,bound,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,exception,on,accept,ignoring,ex,continue,try,if,socket,is,connected,socket,is,closed,log,debug,socket,appears,to,be,there,checking,for,available,data,in,milliseconds,thread,sleep,input,stream,input,stream,try,input,stream,socket,get,input,stream,catch,ioexception,io,ex,mllp,socket,util,reset,socket,log,failed,to,retrieve,the,input,stream,for,socket,after,the,initial,connection,was,accepted,continue,if,0,input,stream,available,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,continue,mllp,socket,util,set,so,timeout,socket,log,preparing,to,check,for,available,data,on,component,startup,try,int,tmp,byte,input,stream,read,if,1,tmp,byte,log,debug,check,for,available,data,failed,socket,read,returned,mllp,socket,util,close,socket,null,null,else,client,socket,thread,client,thread,new,client,socket,thread,socket,tmp,byte,client,threads,add,client,thread,client,thread,start,catch,socket,timeout,exception,timeout,ex,string,log,message,format,check,for,available,data,failed,socket,read,timed,out,after,milliseconds,no,data,but,the,socket,is,there,starting,client,socket,thread,log,debug,log,message,format,client,socket,thread,client,thread,new,client,socket,thread,socket,null,client,threads,add,client,thread,client,thread,start,catch,ioexception,io,ex,log,debug,ignoring,ioexception,encountered,when,attempting,to,read,a,byte,connection,was,reset,try,socket,close,catch,ioexception,close,ex,log,debug,ignoring,ioexception,encountered,when,attempting,to,close,the,connection,after,the,connection,reset,was,detected,close,ex,catch,socket,timeout,exception,timeout,ex,log,trace,socket,timeout,exception,waiting,for,new,connections,no,new,connections,for,int,i,client,threads,size,1,i,0,i,client,socket,thread,thread,client,threads,get,i,if,thread,is,alive,client,threads,remove,i,catch,interrupted,exception,interrupt,ex,log,debug,accept,loop,interrupted,closing,server,socket,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,interrupted,exception,ignoring,ex,catch,exception,ex,log,error,exception,accepting,new,connection,retrying,ex,finally,log,debug,server,socket,accept,loop,finished,closing,listener,if,null,server,socket,server,socket,is,bound,server,socket,is,closed,try,server,socket,close,catch,exception,ex,log,debug,exception,encountered,closing,server,socket,after,accept,loop,had,exited,ignoring,ex
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1451464990;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1451465974;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1452098879;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1452781359;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1452781359;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1453968697;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1454949920;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1457097808;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1460612302;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1461827354;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1461827354;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1473189753;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1473924202;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1479844564;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1480003968;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1481829620;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1481875493;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
MllpTcpServerConsumer -> ServerSocketThread -> String createThreadName(ServerSocket serverSocket);1494247089;Derive a thread name from the class name, the component URI and the connection information._<p/>_The String will in the format <class name>[endpoint key] - [local socket address]__@return String for thread name;String createThreadName(ServerSocket serverSocket) {_            _            String fullClassName = this.getClass().getName()__            String className = fullClassName.substring(fullClassName.lastIndexOf('.') + 1)___            _            String fullEndpointKey = endpoint.getEndpointKey()__            String endpointKey__            if (fullEndpointKey.contains("?")) {_                endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?'))__            } else {_                endpointKey = fullEndpointKey__            }__            _            return String.format("%s[%s] - %s", className, endpointKey, serverSocket.getLocalSocketAddress())__        };derive,a,thread,name,from,the,class,name,the,component,uri,and,the,connection,information,p,the,string,will,in,the,format,class,name,endpoint,key,local,socket,address,return,string,for,thread,name;string,create,thread,name,server,socket,server,socket,string,full,class,name,this,get,class,get,name,string,class,name,full,class,name,substring,full,class,name,last,index,of,1,string,full,endpoint,key,endpoint,get,endpoint,key,string,endpoint,key,if,full,endpoint,key,contains,endpoint,key,full,endpoint,key,substring,0,full,endpoint,key,index,of,else,endpoint,key,full,endpoint,key,return,string,format,s,s,s,class,name,endpoint,key,server,socket,get,local,socket,address
