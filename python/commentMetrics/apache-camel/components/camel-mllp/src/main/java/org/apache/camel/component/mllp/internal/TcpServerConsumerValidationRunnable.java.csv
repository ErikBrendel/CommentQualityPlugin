commented;modifiers;parameterAmount;loc;comment;code
true;;1;13;/**  * derive a thread name from the class name, the component URI and the connection information  * <p/>  * The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]  *  * @return the thread name  */ ;/**  * derive a thread name from the class name, the component URI and the connection information  * <p/>  * The String will in the format <class name>[endpoint key] - [local socket address] -> [remote socket address]  *  * @return the thread name  */ String createThreadName(Socket socket) {     // Get the URI without options     String fullEndpointKey = consumer.getEndpoint().getEndpointKey().     String endpointKey.     if (fullEndpointKey.contains("?")) {         endpointKey = fullEndpointKey.substring(0, fullEndpointKey.indexOf('?')).     } else {         endpointKey = fullEndpointKey.     }     // Now put it all together     return String.format("%s[%s] - %s", this.getClass().getSimpleName(), endpointKey, combinedAddress). }
true;public;0;43;/**  * Do the initial read on the Socket and try to determine if it has HL7 data, junk, or nothing.  */ ;/**  * Do the initial read on the Socket and try to determine if it has HL7 data, junk, or nothing.  */ @Override public void run() {     String originalThreadName = Thread.currentThread().getName().     Thread.currentThread().setName(createThreadName(clientSocket)).     MDC.put(UnitOfWork.MDC_CAMEL_CONTEXT_ID, consumer.getEndpoint().getCamelContext().getName()).     Route route = consumer.getRoute().     if (route != null) {         String routeId = route.getId().         if (routeId != null) {             MDC.put(UnitOfWork.MDC_ROUTE_ID, route.getId()).         }     }     log.debug("Checking {} for data", combinedAddress).     try {         mllpBuffer.readFrom(clientSocket, Math.min(500, consumer.getConfiguration().getReceiveTimeout()), consumer.getConfiguration().getReadTimeout()).         if (mllpBuffer.hasCompleteEnvelope() || mllpBuffer.hasStartOfBlock()) {             consumer.startConsumer(clientSocket, mllpBuffer).         } else if (!mllpBuffer.isEmpty()) {             // We have some leading out-of-band data but no START_OF_BLOCK             log.info("Ignoring out-of-band data on initial read [{} bytes]: {}", mllpBuffer.size(), mllpBuffer.toPrintFriendlyStringAndReset()).             mllpBuffer.resetSocket(clientSocket).         }     } catch (MllpSocketException socketEx) {         // TODO:  The socket is invalid for some reason         if (!mllpBuffer.isEmpty()) {             log.warn("Exception encountered receiving complete initial message [{} bytes]: {}", mllpBuffer.size(), mllpBuffer.toPrintFriendlyStringAndReset()).         }         mllpBuffer.resetSocket(clientSocket).     } catch (SocketTimeoutException timeoutEx) {         if (mllpBuffer.isEmpty()) {             log.debug("Initial read timed-out but no data was read - starting consumer").             consumer.startConsumer(clientSocket, mllpBuffer).         } else {             log.warn("Timeout receiving complete initial message on read [{} bytes]: {}", mllpBuffer.size(), mllpBuffer.toPrintFriendlyStringAndReset()).             mllpBuffer.resetSocket(clientSocket).         }     } finally {         Thread.currentThread().setName(originalThreadName).     } }
false;public;0;3;;public void closeSocket() {     mllpBuffer.closeSocket(clientSocket). }
false;public;1;3;;public void closeSocket(String logMessage) {     mllpBuffer.closeSocket(clientSocket, logMessage). }
false;public;0;3;;public void resetSocket() {     mllpBuffer.resetSocket(clientSocket). }
false;public;1;3;;public void resetSocket(String logMessage) {     mllpBuffer.resetSocket(clientSocket, logMessage). }
false;public;0;3;;public String getLocalAddress() {     return localAddress. }
false;public;0;3;;public String getRemoteAddress() {     return remoteAddress. }
false;public;0;3;;public String getCombinedAddress() {     return combinedAddress. }
