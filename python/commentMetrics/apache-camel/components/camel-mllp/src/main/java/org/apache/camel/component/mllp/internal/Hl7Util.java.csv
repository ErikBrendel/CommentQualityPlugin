# id;timestamp;commentText;codeText;commentWords;codeWords
Hl7Util -> public static String convertToPrintFriendlyString(byte[] phiBytes, int startPosition, int endPosition);1515779403;Convert a PHI byte[] to a String, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes      the PHI byte[] to log_@param startPosition the starting position/index of the data_@param endPosition   the ending position/index of the data - will not be included in String__@return a String representation of the byte[];public static String convertToPrintFriendlyString(byte[] phiBytes, int startPosition, int endPosition) {_        return bytesToPrintFriendlyStringBuilder(phiBytes, startPosition, endPosition).toString()__    };convert,a,phi,byte,to,a,string,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,param,start,position,the,starting,position,index,of,the,data,param,end,position,the,ending,position,index,of,the,data,will,not,be,included,in,string,return,a,string,representation,of,the,byte;public,static,string,convert,to,print,friendly,string,byte,phi,bytes,int,start,position,int,end,position,return,bytes,to,print,friendly,string,builder,phi,bytes,start,position,end,position,to,string
Hl7Util -> public static String convertToPrintFriendlyString(byte[] phiBytes, int startPosition, int endPosition);1517245483;Convert a PHI byte[] to a String, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes      the PHI byte[] to log_@param startPosition the starting position/index of the data_@param endPosition   the ending position/index of the data - will not be included in String__@return a String representation of the byte[];public static String convertToPrintFriendlyString(byte[] phiBytes, int startPosition, int endPosition) {_        return bytesToPrintFriendlyStringBuilder(phiBytes, startPosition, endPosition).toString()__    };convert,a,phi,byte,to,a,string,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,param,start,position,the,starting,position,index,of,the,data,param,end,position,the,ending,position,index,of,the,data,will,not,be,included,in,string,return,a,string,representation,of,the,byte;public,static,string,convert,to,print,friendly,string,byte,phi,bytes,int,start,position,int,end,position,return,bytes,to,print,friendly,string,builder,phi,bytes,start,position,end,position,to,string
Hl7Util -> public static String convertToPrintFriendlyString(byte[] phiBytes, int startPosition, int endPosition);1518733370;Convert a PHI byte[] to a String, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes      the PHI byte[] to log_@param startPosition the starting position/index of the data_@param endPosition   the ending position/index of the data - will not be included in String__@return a String representation of the byte[];public static String convertToPrintFriendlyString(byte[] phiBytes, int startPosition, int endPosition) {_        return bytesToPrintFriendlyStringBuilder(phiBytes, startPosition, endPosition).toString()__    };convert,a,phi,byte,to,a,string,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,param,start,position,the,starting,position,index,of,the,data,param,end,position,the,ending,position,index,of,the,data,will,not,be,included,in,string,return,a,string,representation,of,the,byte;public,static,string,convert,to,print,friendly,string,byte,phi,bytes,int,start,position,int,end,position,return,bytes,to,print,friendly,string,builder,phi,bytes,start,position,end,position,to,string
Hl7Util -> public static String convertToPrintFriendlyString(byte[] phiBytes, int startPosition, int endPosition);1520095706;Convert a PHI byte[] to a String, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes      the PHI byte[] to log_@param startPosition the starting position/index of the data_@param endPosition   the ending position/index of the data - will not be included in String__@return a String representation of the byte[];public static String convertToPrintFriendlyString(byte[] phiBytes, int startPosition, int endPosition) {_        return bytesToPrintFriendlyStringBuilder(phiBytes, startPosition, endPosition).toString()__    };convert,a,phi,byte,to,a,string,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,param,start,position,the,starting,position,index,of,the,data,param,end,position,the,ending,position,index,of,the,data,will,not,be,included,in,string,return,a,string,representation,of,the,byte;public,static,string,convert,to,print,friendly,string,byte,phi,bytes,int,start,position,int,end,position,return,bytes,to,print,friendly,string,builder,phi,bytes,start,position,end,position,to,string
Hl7Util -> public static String convertToPrintFriendlyString(byte[] phiBytes, int startPosition, int endPosition);1524063106;Convert a PHI byte[] to a String, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes      the PHI byte[] to log_@param startPosition the starting position/index of the data_@param endPosition   the ending position/index of the data - will not be included in String__@return a String representation of the byte[];public static String convertToPrintFriendlyString(byte[] phiBytes, int startPosition, int endPosition) {_        return bytesToPrintFriendlyStringBuilder(phiBytes, startPosition, endPosition).toString()__    };convert,a,phi,byte,to,a,string,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,param,start,position,the,starting,position,index,of,the,data,param,end,position,the,ending,position,index,of,the,data,will,not,be,included,in,string,return,a,string,representation,of,the,byte;public,static,string,convert,to,print,friendly,string,byte,phi,bytes,int,start,position,int,end,position,return,bytes,to,print,friendly,string,builder,phi,bytes,start,position,end,position,to,string
Hl7Util -> public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes);1515779403;Convert a PHI byte[] to a StringBuilder, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes the PHI byte[] to log__@return;public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes) {_        return bytesToPrintFriendlyStringBuilder(phiBytes, 0, phiBytes != null ? phiBytes.length : -1)__    };convert,a,phi,byte,to,a,string,builder,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,return;public,static,string,builder,bytes,to,print,friendly,string,builder,byte,phi,bytes,return,bytes,to,print,friendly,string,builder,phi,bytes,0,phi,bytes,null,phi,bytes,length,1
Hl7Util -> public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes);1517245483;Convert a PHI byte[] to a StringBuilder, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes the PHI byte[] to log__@return;public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes) {_        return bytesToPrintFriendlyStringBuilder(phiBytes, 0, phiBytes != null ? phiBytes.length : -1)__    };convert,a,phi,byte,to,a,string,builder,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,return;public,static,string,builder,bytes,to,print,friendly,string,builder,byte,phi,bytes,return,bytes,to,print,friendly,string,builder,phi,bytes,0,phi,bytes,null,phi,bytes,length,1
Hl7Util -> public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes);1518733370;Convert a PHI byte[] to a StringBuilder, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes the PHI byte[] to log__@return;public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes) {_        return bytesToPrintFriendlyStringBuilder(phiBytes, 0, phiBytes != null ? phiBytes.length : -1)__    };convert,a,phi,byte,to,a,string,builder,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,return;public,static,string,builder,bytes,to,print,friendly,string,builder,byte,phi,bytes,return,bytes,to,print,friendly,string,builder,phi,bytes,0,phi,bytes,null,phi,bytes,length,1
Hl7Util -> public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes);1520095706;Convert a PHI byte[] to a StringBuilder, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes the PHI byte[] to log__@return;public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes) {_        return bytesToPrintFriendlyStringBuilder(phiBytes, 0, phiBytes != null ? phiBytes.length : -1)__    };convert,a,phi,byte,to,a,string,builder,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,return;public,static,string,builder,bytes,to,print,friendly,string,builder,byte,phi,bytes,return,bytes,to,print,friendly,string,builder,phi,bytes,0,phi,bytes,null,phi,bytes,length,1
Hl7Util -> public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes);1524063106;Convert a PHI byte[] to a StringBuilder, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes the PHI byte[] to log__@return;public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes) {_        return bytesToPrintFriendlyStringBuilder(phiBytes, 0, phiBytes != null ? phiBytes.length : -1)__    };convert,a,phi,byte,to,a,string,builder,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,return;public,static,string,builder,bytes,to,print,friendly,string,builder,byte,phi,bytes,return,bytes,to,print,friendly,string,builder,phi,bytes,0,phi,bytes,null,phi,bytes,length,1
Hl7Util -> public static List<Integer> findFieldSeparatorIndicesInSegment(byte[] hl7MessageBytes, int startingIndex);1517245483;Find the field separator indices in the Segment.__NOTE:  The last element of the list will be the index of the end of the segment.__@param hl7MessageBytes the HL7 binary message_@param startingIndex index of the beginning of the HL7 Segment__@return List of the field separator indices, which may be empty.;public static List<Integer> findFieldSeparatorIndicesInSegment(byte[] hl7MessageBytes, int startingIndex) {_        List<Integer> fieldSeparatorIndices = new LinkedList<>()___        if (hl7MessageBytes != null && hl7MessageBytes.length > startingIndex && hl7MessageBytes.length > 3) {_            final byte fieldSeparator = hl7MessageBytes[3]___            for (int i = startingIndex_ i < hl7MessageBytes.length_ ++i) {_                if (fieldSeparator == hl7MessageBytes[i]) {_                    fieldSeparatorIndices.add(i)__                } else if (MllpProtocolConstants.SEGMENT_DELIMITER == hl7MessageBytes[i]) {_                    fieldSeparatorIndices.add(i)__                    break__                }_            }_        }__        return fieldSeparatorIndices__    };find,the,field,separator,indices,in,the,segment,note,the,last,element,of,the,list,will,be,the,index,of,the,end,of,the,segment,param,hl7message,bytes,the,hl7,binary,message,param,starting,index,index,of,the,beginning,of,the,hl7,segment,return,list,of,the,field,separator,indices,which,may,be,empty;public,static,list,integer,find,field,separator,indices,in,segment,byte,hl7message,bytes,int,starting,index,list,integer,field,separator,indices,new,linked,list,if,hl7message,bytes,null,hl7message,bytes,length,starting,index,hl7message,bytes,length,3,final,byte,field,separator,hl7message,bytes,3,for,int,i,starting,index,i,hl7message,bytes,length,i,if,field,separator,hl7message,bytes,i,field,separator,indices,add,i,else,if,mllp,protocol,constants,hl7message,bytes,i,field,separator,indices,add,i,break,return,field,separator,indices
Hl7Util -> public static List<Integer> findFieldSeparatorIndicesInSegment(byte[] hl7MessageBytes, int startingIndex);1518733370;Find the field separator indices in the Segment.__NOTE:  The last element of the list will be the index of the end of the segment.__@param hl7MessageBytes the HL7 binary message_@param startingIndex index of the beginning of the HL7 Segment__@return List of the field separator indices, which may be empty.;public static List<Integer> findFieldSeparatorIndicesInSegment(byte[] hl7MessageBytes, int startingIndex) {_        List<Integer> fieldSeparatorIndices = new LinkedList<>()___        if (hl7MessageBytes != null && hl7MessageBytes.length > startingIndex && hl7MessageBytes.length > 3) {_            final byte fieldSeparator = hl7MessageBytes[3]___            for (int i = startingIndex_ i < hl7MessageBytes.length_ ++i) {_                if (fieldSeparator == hl7MessageBytes[i]) {_                    fieldSeparatorIndices.add(i)__                } else if (MllpProtocolConstants.SEGMENT_DELIMITER == hl7MessageBytes[i]) {_                    fieldSeparatorIndices.add(i)__                    break__                }_            }_        }__        return fieldSeparatorIndices__    };find,the,field,separator,indices,in,the,segment,note,the,last,element,of,the,list,will,be,the,index,of,the,end,of,the,segment,param,hl7message,bytes,the,hl7,binary,message,param,starting,index,index,of,the,beginning,of,the,hl7,segment,return,list,of,the,field,separator,indices,which,may,be,empty;public,static,list,integer,find,field,separator,indices,in,segment,byte,hl7message,bytes,int,starting,index,list,integer,field,separator,indices,new,linked,list,if,hl7message,bytes,null,hl7message,bytes,length,starting,index,hl7message,bytes,length,3,final,byte,field,separator,hl7message,bytes,3,for,int,i,starting,index,i,hl7message,bytes,length,i,if,field,separator,hl7message,bytes,i,field,separator,indices,add,i,else,if,mllp,protocol,constants,hl7message,bytes,i,field,separator,indices,add,i,break,return,field,separator,indices
Hl7Util -> public static List<Integer> findFieldSeparatorIndicesInSegment(byte[] hl7MessageBytes, int startingIndex);1520095706;Find the field separator indices in the Segment.__NOTE:  The last element of the list will be the index of the end of the segment.__@param hl7MessageBytes the HL7 binary message_@param startingIndex index of the beginning of the HL7 Segment__@return List of the field separator indices, which may be empty.;public static List<Integer> findFieldSeparatorIndicesInSegment(byte[] hl7MessageBytes, int startingIndex) {_        List<Integer> fieldSeparatorIndices = new LinkedList<>()___        if (hl7MessageBytes != null && hl7MessageBytes.length > startingIndex && hl7MessageBytes.length > 3) {_            final byte fieldSeparator = hl7MessageBytes[3]___            for (int i = startingIndex_ i < hl7MessageBytes.length_ ++i) {_                if (fieldSeparator == hl7MessageBytes[i]) {_                    fieldSeparatorIndices.add(i)__                } else if (MllpProtocolConstants.SEGMENT_DELIMITER == hl7MessageBytes[i]) {_                    fieldSeparatorIndices.add(i)__                    break__                }_            }_        }__        return fieldSeparatorIndices__    };find,the,field,separator,indices,in,the,segment,note,the,last,element,of,the,list,will,be,the,index,of,the,end,of,the,segment,param,hl7message,bytes,the,hl7,binary,message,param,starting,index,index,of,the,beginning,of,the,hl7,segment,return,list,of,the,field,separator,indices,which,may,be,empty;public,static,list,integer,find,field,separator,indices,in,segment,byte,hl7message,bytes,int,starting,index,list,integer,field,separator,indices,new,linked,list,if,hl7message,bytes,null,hl7message,bytes,length,starting,index,hl7message,bytes,length,3,final,byte,field,separator,hl7message,bytes,3,for,int,i,starting,index,i,hl7message,bytes,length,i,if,field,separator,hl7message,bytes,i,field,separator,indices,add,i,else,if,mllp,protocol,constants,hl7message,bytes,i,field,separator,indices,add,i,break,return,field,separator,indices
Hl7Util -> public static List<Integer> findFieldSeparatorIndicesInSegment(byte[] hl7MessageBytes, int startingIndex);1524063106;Find the field separator indices in the Segment.__NOTE:  The last element of the list will be the index of the end of the segment.__@param hl7MessageBytes the HL7 binary message_@param startingIndex index of the beginning of the HL7 Segment__@return List of the field separator indices, which may be empty.;public static List<Integer> findFieldSeparatorIndicesInSegment(byte[] hl7MessageBytes, int startingIndex) {_        List<Integer> fieldSeparatorIndices = new LinkedList<>()___        if (hl7MessageBytes != null && hl7MessageBytes.length > startingIndex && hl7MessageBytes.length > 3) {_            final byte fieldSeparator = hl7MessageBytes[3]___            for (int i = startingIndex_ i < hl7MessageBytes.length_ ++i) {_                if (fieldSeparator == hl7MessageBytes[i]) {_                    fieldSeparatorIndices.add(i)__                } else if (MllpProtocolConstants.SEGMENT_DELIMITER == hl7MessageBytes[i]) {_                    fieldSeparatorIndices.add(i)__                    break__                }_            }_        }__        return fieldSeparatorIndices__    };find,the,field,separator,indices,in,the,segment,note,the,last,element,of,the,list,will,be,the,index,of,the,end,of,the,segment,param,hl7message,bytes,the,hl7,binary,message,param,starting,index,index,of,the,beginning,of,the,hl7,segment,return,list,of,the,field,separator,indices,which,may,be,empty;public,static,list,integer,find,field,separator,indices,in,segment,byte,hl7message,bytes,int,starting,index,list,integer,field,separator,indices,new,linked,list,if,hl7message,bytes,null,hl7message,bytes,length,starting,index,hl7message,bytes,length,3,final,byte,field,separator,hl7message,bytes,3,for,int,i,starting,index,i,hl7message,bytes,length,i,if,field,separator,hl7message,bytes,i,field,separator,indices,add,i,else,if,mllp,protocol,constants,hl7message,bytes,i,field,separator,indices,add,i,break,return,field,separator,indices
Hl7Util -> private static void writeFieldToBuffer(int fieldNumber, MllpSocketBuffer mllpSocketBuffer, byte[] hl7MessageBytes, List<Integer> fieldSeparatorIndexes);1517245483;Copy a field from the HL7 Message Bytes to the supplied MllpSocketBuffer.__NOTE:  Internal function - no error checking__@param mllpSocketBuffer the destination for the field_@param hl7MessageBytes the HL7 message bytes_@param fieldSeparatorIndexes the list of the indices of the field separators;private static void writeFieldToBuffer(int fieldNumber, MllpSocketBuffer mllpSocketBuffer, byte[] hl7MessageBytes, List<Integer> fieldSeparatorIndexes) {_        mllpSocketBuffer.write(hl7MessageBytes, fieldSeparatorIndexes.get(fieldNumber), fieldSeparatorIndexes.get(fieldNumber + 1) - fieldSeparatorIndexes.get(fieldNumber))__    };copy,a,field,from,the,hl7,message,bytes,to,the,supplied,mllp,socket,buffer,note,internal,function,no,error,checking,param,mllp,socket,buffer,the,destination,for,the,field,param,hl7message,bytes,the,hl7,message,bytes,param,field,separator,indexes,the,list,of,the,indices,of,the,field,separators;private,static,void,write,field,to,buffer,int,field,number,mllp,socket,buffer,mllp,socket,buffer,byte,hl7message,bytes,list,integer,field,separator,indexes,mllp,socket,buffer,write,hl7message,bytes,field,separator,indexes,get,field,number,field,separator,indexes,get,field,number,1,field,separator,indexes,get,field,number
Hl7Util -> private static void writeFieldToBuffer(int fieldNumber, MllpSocketBuffer mllpSocketBuffer, byte[] hl7MessageBytes, List<Integer> fieldSeparatorIndexes);1518733370;Copy a field from the HL7 Message Bytes to the supplied MllpSocketBuffer.__NOTE:  Internal function - no error checking__@param mllpSocketBuffer the destination for the field_@param hl7MessageBytes the HL7 message bytes_@param fieldSeparatorIndexes the list of the indices of the field separators;private static void writeFieldToBuffer(int fieldNumber, MllpSocketBuffer mllpSocketBuffer, byte[] hl7MessageBytes, List<Integer> fieldSeparatorIndexes) {_        mllpSocketBuffer.write(hl7MessageBytes, fieldSeparatorIndexes.get(fieldNumber), fieldSeparatorIndexes.get(fieldNumber + 1) - fieldSeparatorIndexes.get(fieldNumber))__    };copy,a,field,from,the,hl7,message,bytes,to,the,supplied,mllp,socket,buffer,note,internal,function,no,error,checking,param,mllp,socket,buffer,the,destination,for,the,field,param,hl7message,bytes,the,hl7,message,bytes,param,field,separator,indexes,the,list,of,the,indices,of,the,field,separators;private,static,void,write,field,to,buffer,int,field,number,mllp,socket,buffer,mllp,socket,buffer,byte,hl7message,bytes,list,integer,field,separator,indexes,mllp,socket,buffer,write,hl7message,bytes,field,separator,indexes,get,field,number,field,separator,indexes,get,field,number,1,field,separator,indexes,get,field,number
Hl7Util -> private static void writeFieldToBuffer(int fieldNumber, MllpSocketBuffer mllpSocketBuffer, byte[] hl7MessageBytes, List<Integer> fieldSeparatorIndexes);1520095706;Copy a field from the HL7 Message Bytes to the supplied MllpSocketBuffer.__NOTE:  Internal function - no error checking__@param mllpSocketBuffer the destination for the field_@param hl7MessageBytes the HL7 message bytes_@param fieldSeparatorIndexes the list of the indices of the field separators;private static void writeFieldToBuffer(int fieldNumber, MllpSocketBuffer mllpSocketBuffer, byte[] hl7MessageBytes, List<Integer> fieldSeparatorIndexes) {_        mllpSocketBuffer.write(hl7MessageBytes, fieldSeparatorIndexes.get(fieldNumber), fieldSeparatorIndexes.get(fieldNumber + 1) - fieldSeparatorIndexes.get(fieldNumber))__    };copy,a,field,from,the,hl7,message,bytes,to,the,supplied,mllp,socket,buffer,note,internal,function,no,error,checking,param,mllp,socket,buffer,the,destination,for,the,field,param,hl7message,bytes,the,hl7,message,bytes,param,field,separator,indexes,the,list,of,the,indices,of,the,field,separators;private,static,void,write,field,to,buffer,int,field,number,mllp,socket,buffer,mllp,socket,buffer,byte,hl7message,bytes,list,integer,field,separator,indexes,mllp,socket,buffer,write,hl7message,bytes,field,separator,indexes,get,field,number,field,separator,indexes,get,field,number,1,field,separator,indexes,get,field,number
Hl7Util -> private static void writeFieldToBuffer(int fieldNumber, MllpSocketBuffer mllpSocketBuffer, byte[] hl7MessageBytes, List<Integer> fieldSeparatorIndexes);1524063106;Copy a field from the HL7 Message Bytes to the supplied MllpSocketBuffer.__NOTE:  Internal function - no error checking__@param mllpSocketBuffer the destination for the field_@param hl7MessageBytes the HL7 message bytes_@param fieldSeparatorIndexes the list of the indices of the field separators;private static void writeFieldToBuffer(int fieldNumber, MllpSocketBuffer mllpSocketBuffer, byte[] hl7MessageBytes, List<Integer> fieldSeparatorIndexes) {_        mllpSocketBuffer.write(hl7MessageBytes, fieldSeparatorIndexes.get(fieldNumber), fieldSeparatorIndexes.get(fieldNumber + 1) - fieldSeparatorIndexes.get(fieldNumber))__    };copy,a,field,from,the,hl7,message,bytes,to,the,supplied,mllp,socket,buffer,note,internal,function,no,error,checking,param,mllp,socket,buffer,the,destination,for,the,field,param,hl7message,bytes,the,hl7,message,bytes,param,field,separator,indexes,the,list,of,the,indices,of,the,field,separators;private,static,void,write,field,to,buffer,int,field,number,mllp,socket,buffer,mllp,socket,buffer,byte,hl7message,bytes,list,integer,field,separator,indexes,mllp,socket,buffer,write,hl7message,bytes,field,separator,indexes,get,field,number,field,separator,indexes,get,field,number,1,field,separator,indexes,get,field,number
Hl7Util -> public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes, int startPosition, int endPosition);1515779403;Convert a PHI byte[] to a StringBuilder, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes      the PHI byte[] to log_@param startPosition the starting position/index of the data_@param endPosition   the ending position/index of the data - will not be included in StringBuilder__@return a String representation of the byte[];public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes, int startPosition, int endPosition) {_        StringBuilder answer = new StringBuilder()___        appendBytesAsPrintFriendlyString(answer, phiBytes, startPosition, endPosition)___        return answer__    };convert,a,phi,byte,to,a,string,builder,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,param,start,position,the,starting,position,index,of,the,data,param,end,position,the,ending,position,index,of,the,data,will,not,be,included,in,string,builder,return,a,string,representation,of,the,byte;public,static,string,builder,bytes,to,print,friendly,string,builder,byte,phi,bytes,int,start,position,int,end,position,string,builder,answer,new,string,builder,append,bytes,as,print,friendly,string,answer,phi,bytes,start,position,end,position,return,answer
Hl7Util -> public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes, int startPosition, int endPosition);1517245483;Convert a PHI byte[] to a StringBuilder, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes      the PHI byte[] to log_@param startPosition the starting position/index of the data_@param endPosition   the ending position/index of the data - will not be included in StringBuilder__@return a String representation of the byte[];public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes, int startPosition, int endPosition) {_        StringBuilder answer = new StringBuilder()___        appendBytesAsPrintFriendlyString(answer, phiBytes, startPosition, endPosition)___        return answer__    };convert,a,phi,byte,to,a,string,builder,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,param,start,position,the,starting,position,index,of,the,data,param,end,position,the,ending,position,index,of,the,data,will,not,be,included,in,string,builder,return,a,string,representation,of,the,byte;public,static,string,builder,bytes,to,print,friendly,string,builder,byte,phi,bytes,int,start,position,int,end,position,string,builder,answer,new,string,builder,append,bytes,as,print,friendly,string,answer,phi,bytes,start,position,end,position,return,answer
Hl7Util -> public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes, int startPosition, int endPosition);1518733370;Convert a PHI byte[] to a StringBuilder, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes      the PHI byte[] to log_@param startPosition the starting position/index of the data_@param endPosition   the ending position/index of the data - will not be included in StringBuilder__@return a String representation of the byte[];public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes, int startPosition, int endPosition) {_        StringBuilder answer = new StringBuilder()___        appendBytesAsPrintFriendlyString(answer, phiBytes, startPosition, endPosition)___        return answer__    };convert,a,phi,byte,to,a,string,builder,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,param,start,position,the,starting,position,index,of,the,data,param,end,position,the,ending,position,index,of,the,data,will,not,be,included,in,string,builder,return,a,string,representation,of,the,byte;public,static,string,builder,bytes,to,print,friendly,string,builder,byte,phi,bytes,int,start,position,int,end,position,string,builder,answer,new,string,builder,append,bytes,as,print,friendly,string,answer,phi,bytes,start,position,end,position,return,answer
Hl7Util -> public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes, int startPosition, int endPosition);1520095706;Convert a PHI byte[] to a StringBuilder, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes      the PHI byte[] to log_@param startPosition the starting position/index of the data_@param endPosition   the ending position/index of the data - will not be included in StringBuilder__@return a String representation of the byte[];public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes, int startPosition, int endPosition) {_        StringBuilder answer = new StringBuilder()___        appendBytesAsPrintFriendlyString(answer, phiBytes, startPosition, endPosition)___        return answer__    };convert,a,phi,byte,to,a,string,builder,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,param,start,position,the,starting,position,index,of,the,data,param,end,position,the,ending,position,index,of,the,data,will,not,be,included,in,string,builder,return,a,string,representation,of,the,byte;public,static,string,builder,bytes,to,print,friendly,string,builder,byte,phi,bytes,int,start,position,int,end,position,string,builder,answer,new,string,builder,append,bytes,as,print,friendly,string,answer,phi,bytes,start,position,end,position,return,answer
Hl7Util -> public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes, int startPosition, int endPosition);1524063106;Convert a PHI byte[] to a StringBuilder, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes      the PHI byte[] to log_@param startPosition the starting position/index of the data_@param endPosition   the ending position/index of the data - will not be included in StringBuilder__@return a String representation of the byte[];public static StringBuilder bytesToPrintFriendlyStringBuilder(byte[] phiBytes, int startPosition, int endPosition) {_        StringBuilder answer = new StringBuilder()___        appendBytesAsPrintFriendlyString(answer, phiBytes, startPosition, endPosition)___        return answer__    };convert,a,phi,byte,to,a,string,builder,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,param,start,position,the,starting,position,index,of,the,data,param,end,position,the,ending,position,index,of,the,data,will,not,be,included,in,string,builder,return,a,string,representation,of,the,byte;public,static,string,builder,bytes,to,print,friendly,string,builder,byte,phi,bytes,int,start,position,int,end,position,string,builder,answer,new,string,builder,append,bytes,as,print,friendly,string,answer,phi,bytes,start,position,end,position,return,answer
Hl7Util -> public static void appendBytesAsPrintFriendlyString(StringBuilder builder, byte[] phiBytes, int startPosition, int endPosition);1515779403;Append a PHI byte[] to a StringBuilder, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes      the PHI byte[] to log_@param startPosition the starting position/index of the data_@param endPosition   the ending position/index of the data - will not be included in String;public static void appendBytesAsPrintFriendlyString(StringBuilder builder, byte[] phiBytes, int startPosition, int endPosition) {_        if (builder == null) {_            throw new IllegalArgumentException("StringBuilder cannot be null")__        }__        if (null == phiBytes) {_            builder.append(NULL_REPLACEMENT_VALUE)__        } else if (phiBytes.length == 0) {_            builder.append(EMPTY_REPLACEMENT_VALUE)__        } else if (startPosition <= endPosition) {_            if (startPosition < 0) {_                startPosition = 0__            }__            if (startPosition < phiBytes.length) {_                if (endPosition >= -1) {_                    if (endPosition == -1 || endPosition >= phiBytes.length) {_                        endPosition = phiBytes.length__                    }__                    int length = endPosition - startPosition__                    if (length > 0) {_                        int logPhiMaxBytes = MllpComponent.getLogPhiMaxBytes()__                        int conversionLength = (logPhiMaxBytes > 0) ? Integer.min(length, logPhiMaxBytes) : length__                        if (builder.capacity() - builder.length() < conversionLength + STRING_BUFFER_PAD_SIZE) {_                            builder.ensureCapacity(builder.length() + conversionLength + STRING_BUFFER_PAD_SIZE)__                        }_                        for (int i = 0_ i < conversionLength_ ++i) {_                            appendCharacterAsPrintFriendlyString(builder, (char) phiBytes[startPosition + i])__                        }_                    }_                }_            }_        }_    };append,a,phi,byte,to,a,string,builder,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,param,start,position,the,starting,position,index,of,the,data,param,end,position,the,ending,position,index,of,the,data,will,not,be,included,in,string;public,static,void,append,bytes,as,print,friendly,string,string,builder,builder,byte,phi,bytes,int,start,position,int,end,position,if,builder,null,throw,new,illegal,argument,exception,string,builder,cannot,be,null,if,null,phi,bytes,builder,append,else,if,phi,bytes,length,0,builder,append,else,if,start,position,end,position,if,start,position,0,start,position,0,if,start,position,phi,bytes,length,if,end,position,1,if,end,position,1,end,position,phi,bytes,length,end,position,phi,bytes,length,int,length,end,position,start,position,if,length,0,int,log,phi,max,bytes,mllp,component,get,log,phi,max,bytes,int,conversion,length,log,phi,max,bytes,0,integer,min,length,log,phi,max,bytes,length,if,builder,capacity,builder,length,conversion,length,builder,ensure,capacity,builder,length,conversion,length,for,int,i,0,i,conversion,length,i,append,character,as,print,friendly,string,builder,char,phi,bytes,start,position,i
Hl7Util -> public static void appendBytesAsPrintFriendlyString(StringBuilder builder, byte[] phiBytes, int startPosition, int endPosition);1517245483;Append a PHI byte[] to a StringBuilder, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes      the PHI byte[] to log_@param startPosition the starting position/index of the data_@param endPosition   the ending position/index of the data - will not be included in String;public static void appendBytesAsPrintFriendlyString(StringBuilder builder, byte[] phiBytes, int startPosition, int endPosition) {_        if (builder == null) {_            throw new IllegalArgumentException("StringBuilder cannot be null")__        }__        if (null == phiBytes) {_            builder.append(NULL_REPLACEMENT_VALUE)__        } else if (phiBytes.length == 0) {_            builder.append(EMPTY_REPLACEMENT_VALUE)__        } else if (startPosition <= endPosition) {_            if (startPosition < 0) {_                startPosition = 0__            }__            if (startPosition < phiBytes.length) {_                if (endPosition >= -1) {_                    if (endPosition == -1 || endPosition >= phiBytes.length) {_                        endPosition = phiBytes.length__                    }__                    int length = endPosition - startPosition__                    if (length > 0) {_                        int logPhiMaxBytes = MllpComponent.getLogPhiMaxBytes()__                        int conversionLength = (logPhiMaxBytes > 0) ? Integer.min(length, logPhiMaxBytes) : length__                        if (builder.capacity() - builder.length() < conversionLength + STRING_BUFFER_PAD_SIZE) {_                            builder.ensureCapacity(builder.length() + conversionLength + STRING_BUFFER_PAD_SIZE)__                        }_                        for (int i = 0_ i < conversionLength_ ++i) {_                            appendCharacterAsPrintFriendlyString(builder, (char) phiBytes[startPosition + i])__                        }_                    }_                }_            }_        }_    };append,a,phi,byte,to,a,string,builder,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,param,start,position,the,starting,position,index,of,the,data,param,end,position,the,ending,position,index,of,the,data,will,not,be,included,in,string;public,static,void,append,bytes,as,print,friendly,string,string,builder,builder,byte,phi,bytes,int,start,position,int,end,position,if,builder,null,throw,new,illegal,argument,exception,string,builder,cannot,be,null,if,null,phi,bytes,builder,append,else,if,phi,bytes,length,0,builder,append,else,if,start,position,end,position,if,start,position,0,start,position,0,if,start,position,phi,bytes,length,if,end,position,1,if,end,position,1,end,position,phi,bytes,length,end,position,phi,bytes,length,int,length,end,position,start,position,if,length,0,int,log,phi,max,bytes,mllp,component,get,log,phi,max,bytes,int,conversion,length,log,phi,max,bytes,0,integer,min,length,log,phi,max,bytes,length,if,builder,capacity,builder,length,conversion,length,builder,ensure,capacity,builder,length,conversion,length,for,int,i,0,i,conversion,length,i,append,character,as,print,friendly,string,builder,char,phi,bytes,start,position,i
Hl7Util -> public static void appendBytesAsPrintFriendlyString(StringBuilder builder, byte[] phiBytes, int startPosition, int endPosition);1518733370;Append a PHI byte[] to a StringBuilder, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes      the PHI byte[] to log_@param startPosition the starting position/index of the data_@param endPosition   the ending position/index of the data - will not be included in String;public static void appendBytesAsPrintFriendlyString(StringBuilder builder, byte[] phiBytes, int startPosition, int endPosition) {_        if (builder == null) {_            throw new IllegalArgumentException("StringBuilder cannot be null")__        }__        if (null == phiBytes) {_            builder.append(NULL_REPLACEMENT_VALUE)__        } else if (phiBytes.length == 0) {_            builder.append(EMPTY_REPLACEMENT_VALUE)__        } else if (startPosition <= endPosition) {_            if (startPosition < 0) {_                startPosition = 0__            }__            if (startPosition < phiBytes.length) {_                if (endPosition >= -1) {_                    if (endPosition == -1 || endPosition >= phiBytes.length) {_                        endPosition = phiBytes.length__                    }__                    int length = endPosition - startPosition__                    if (length > 0) {_                        int logPhiMaxBytes = MllpComponent.getLogPhiMaxBytes()__                        int conversionLength = (logPhiMaxBytes > 0) ? Integer.min(length, logPhiMaxBytes) : length__                        if (builder.capacity() - builder.length() < conversionLength + STRING_BUFFER_PAD_SIZE) {_                            builder.ensureCapacity(builder.length() + conversionLength + STRING_BUFFER_PAD_SIZE)__                        }_                        for (int i = 0_ i < conversionLength_ ++i) {_                            appendCharacterAsPrintFriendlyString(builder, (char) phiBytes[startPosition + i])__                        }_                    }_                }_            }_        }_    };append,a,phi,byte,to,a,string,builder,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,param,start,position,the,starting,position,index,of,the,data,param,end,position,the,ending,position,index,of,the,data,will,not,be,included,in,string;public,static,void,append,bytes,as,print,friendly,string,string,builder,builder,byte,phi,bytes,int,start,position,int,end,position,if,builder,null,throw,new,illegal,argument,exception,string,builder,cannot,be,null,if,null,phi,bytes,builder,append,else,if,phi,bytes,length,0,builder,append,else,if,start,position,end,position,if,start,position,0,start,position,0,if,start,position,phi,bytes,length,if,end,position,1,if,end,position,1,end,position,phi,bytes,length,end,position,phi,bytes,length,int,length,end,position,start,position,if,length,0,int,log,phi,max,bytes,mllp,component,get,log,phi,max,bytes,int,conversion,length,log,phi,max,bytes,0,integer,min,length,log,phi,max,bytes,length,if,builder,capacity,builder,length,conversion,length,builder,ensure,capacity,builder,length,conversion,length,for,int,i,0,i,conversion,length,i,append,character,as,print,friendly,string,builder,char,phi,bytes,start,position,i
Hl7Util -> public static void appendBytesAsPrintFriendlyString(StringBuilder builder, byte[] phiBytes, int startPosition, int endPosition);1520095706;Append a PHI byte[] to a StringBuilder, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes      the PHI byte[] to log_@param startPosition the starting position/index of the data_@param endPosition   the ending position/index of the data - will not be included in String;public static void appendBytesAsPrintFriendlyString(StringBuilder builder, byte[] phiBytes, int startPosition, int endPosition) {_        if (builder == null) {_            throw new IllegalArgumentException("StringBuilder cannot be null")__        }__        if (null == phiBytes) {_            builder.append(NULL_REPLACEMENT_VALUE)__        } else if (phiBytes.length == 0) {_            builder.append(EMPTY_REPLACEMENT_VALUE)__        } else if (startPosition <= endPosition) {_            if (startPosition < 0) {_                startPosition = 0__            }__            if (startPosition < phiBytes.length) {_                if (endPosition >= -1) {_                    if (endPosition == -1 || endPosition >= phiBytes.length) {_                        endPosition = phiBytes.length__                    }__                    int length = endPosition - startPosition__                    if (length > 0) {_                        int logPhiMaxBytes = MllpComponent.getLogPhiMaxBytes()__                        int conversionLength = (logPhiMaxBytes > 0) ? Integer.min(length, logPhiMaxBytes) : length__                        if (builder.capacity() - builder.length() < conversionLength + STRING_BUFFER_PAD_SIZE) {_                            builder.ensureCapacity(builder.length() + conversionLength + STRING_BUFFER_PAD_SIZE)__                        }_                        for (int i = 0_ i < conversionLength_ ++i) {_                            appendCharacterAsPrintFriendlyString(builder, (char) phiBytes[startPosition + i])__                        }_                    }_                }_            }_        }_    };append,a,phi,byte,to,a,string,builder,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,param,start,position,the,starting,position,index,of,the,data,param,end,position,the,ending,position,index,of,the,data,will,not,be,included,in,string;public,static,void,append,bytes,as,print,friendly,string,string,builder,builder,byte,phi,bytes,int,start,position,int,end,position,if,builder,null,throw,new,illegal,argument,exception,string,builder,cannot,be,null,if,null,phi,bytes,builder,append,else,if,phi,bytes,length,0,builder,append,else,if,start,position,end,position,if,start,position,0,start,position,0,if,start,position,phi,bytes,length,if,end,position,1,if,end,position,1,end,position,phi,bytes,length,end,position,phi,bytes,length,int,length,end,position,start,position,if,length,0,int,log,phi,max,bytes,mllp,component,get,log,phi,max,bytes,int,conversion,length,log,phi,max,bytes,0,integer,min,length,log,phi,max,bytes,length,if,builder,capacity,builder,length,conversion,length,builder,ensure,capacity,builder,length,conversion,length,for,int,i,0,i,conversion,length,i,append,character,as,print,friendly,string,builder,char,phi,bytes,start,position,i
Hl7Util -> public static void appendBytesAsPrintFriendlyString(StringBuilder builder, byte[] phiBytes, int startPosition, int endPosition);1524063106;Append a PHI byte[] to a StringBuilder, replacing specific non-printable characters with readable strings.__NOTE: this conversion uses the default character set, so not all characters my convert correctly.__@param phiBytes      the PHI byte[] to log_@param startPosition the starting position/index of the data_@param endPosition   the ending position/index of the data - will not be included in String;public static void appendBytesAsPrintFriendlyString(StringBuilder builder, byte[] phiBytes, int startPosition, int endPosition) {_        if (builder == null) {_            throw new IllegalArgumentException("StringBuilder cannot be null")__        }__        if (null == phiBytes) {_            builder.append(NULL_REPLACEMENT_VALUE)__        } else if (phiBytes.length == 0) {_            builder.append(EMPTY_REPLACEMENT_VALUE)__        } else if (startPosition <= endPosition) {_            if (startPosition < 0) {_                startPosition = 0__            }__            if (startPosition < phiBytes.length) {_                if (endPosition >= -1) {_                    if (endPosition == -1 || endPosition >= phiBytes.length) {_                        endPosition = phiBytes.length__                    }__                    int length = endPosition - startPosition__                    if (length > 0) {_                        int logPhiMaxBytes = MllpComponent.getLogPhiMaxBytes()__                        int conversionLength = (logPhiMaxBytes > 0) ? Integer.min(length, logPhiMaxBytes) : length__                        if (builder.capacity() - builder.length() < conversionLength + STRING_BUFFER_PAD_SIZE) {_                            builder.ensureCapacity(builder.length() + conversionLength + STRING_BUFFER_PAD_SIZE)__                        }_                        for (int i = 0_ i < conversionLength_ ++i) {_                            appendCharacterAsPrintFriendlyString(builder, (char) phiBytes[startPosition + i])__                        }_                    }_                }_            }_        }_    };append,a,phi,byte,to,a,string,builder,replacing,specific,non,printable,characters,with,readable,strings,note,this,conversion,uses,the,default,character,set,so,not,all,characters,my,convert,correctly,param,phi,bytes,the,phi,byte,to,log,param,start,position,the,starting,position,index,of,the,data,param,end,position,the,ending,position,index,of,the,data,will,not,be,included,in,string;public,static,void,append,bytes,as,print,friendly,string,string,builder,builder,byte,phi,bytes,int,start,position,int,end,position,if,builder,null,throw,new,illegal,argument,exception,string,builder,cannot,be,null,if,null,phi,bytes,builder,append,else,if,phi,bytes,length,0,builder,append,else,if,start,position,end,position,if,start,position,0,start,position,0,if,start,position,phi,bytes,length,if,end,position,1,if,end,position,1,end,position,phi,bytes,length,end,position,phi,bytes,length,int,length,end,position,start,position,if,length,0,int,log,phi,max,bytes,mllp,component,get,log,phi,max,bytes,int,conversion,length,log,phi,max,bytes,0,integer,min,length,log,phi,max,bytes,length,if,builder,capacity,builder,length,conversion,length,builder,ensure,capacity,builder,length,conversion,length,for,int,i,0,i,conversion,length,i,append,character,as,print,friendly,string,builder,char,phi,bytes,start,position,i
Hl7Util -> public static String generateInvalidPayloadExceptionMessage(final byte[] hl7Bytes, final int length);1515779403;Verifies that the HL7 payload array <p> The MLLP protocol does not allow embedded START_OF_BLOCK or END_OF_BLOCK characters.  The END_OF_DATA character is allowed (and expected) because it is_also the segment delimiter for an HL7 message__@param hl7Bytes the HL7 payload to validate__@return If the payload is invalid, an error message suitable for inclusion in an exception is returned.  If the payload is valid, null is returned_;public static String generateInvalidPayloadExceptionMessage(final byte[] hl7Bytes, final int length) {_        if (hl7Bytes == null) {_            return "HL7 payload is null"__        }__        if (hl7Bytes.length <= 0) {_            return "HL7 payload is empty"__        }__        if (length > hl7Bytes.length) {_            LOG.warn("The length specified for the HL7 payload array <{}> is greater than the actual length of the array <{}> - only validating {} bytes", length, hl7Bytes.length, hl7Bytes.length)__        }__        if (hl7Bytes.length < 3 || hl7Bytes[0] != 'M' || hl7Bytes[1] != 'S' || hl7Bytes[2] != 'H') {_            return String.format("The first segment of the HL7 payload {%s} is not an MSH segment", new String(hl7Bytes, 0, Math.min(3, hl7Bytes.length)))__        }__        int validationLength = Math.min(length, hl7Bytes.length)___        if (hl7Bytes[validationLength - 2] != MllpProtocolConstants.SEGMENT_DELIMITER || hl7Bytes[validationLength - 1] != MllpProtocolConstants.MESSAGE_TERMINATOR) {_            String format = "The HL7 payload terminating bytes [%#x, %#x] are incorrect - expected [%#x, %#x]  {ASCII [<CR>, <LF>]}"__            return String.format(format, hl7Bytes[validationLength - 2], hl7Bytes[validationLength - 1],_                (byte) MllpProtocolConstants.SEGMENT_DELIMITER, (byte) MllpProtocolConstants.MESSAGE_TERMINATOR)__        }__        for (int i = 0_ i < validationLength_ ++i) {_            switch (hl7Bytes[i]) {_            case MllpProtocolConstants.START_OF_BLOCK:_                return String.format("HL7 payload contains an embedded START_OF_BLOCK {%#x, ASCII <VT>} at index %d", hl7Bytes[i], i)__            case MllpProtocolConstants.END_OF_BLOCK:_                return String.format("HL7 payload contains an embedded END_OF_BLOCK {%#x, ASCII <FS>} at index %d", hl7Bytes[i], i)__            default:_                _            }_        }__        return null__    };verifies,that,the,hl7,payload,array,p,the,mllp,protocol,does,not,allow,embedded,or,characters,the,character,is,allowed,and,expected,because,it,is,also,the,segment,delimiter,for,an,hl7,message,param,hl7bytes,the,hl7,payload,to,validate,return,if,the,payload,is,invalid,an,error,message,suitable,for,inclusion,in,an,exception,is,returned,if,the,payload,is,valid,null,is,returned;public,static,string,generate,invalid,payload,exception,message,final,byte,hl7bytes,final,int,length,if,hl7bytes,null,return,hl7,payload,is,null,if,hl7bytes,length,0,return,hl7,payload,is,empty,if,length,hl7bytes,length,log,warn,the,length,specified,for,the,hl7,payload,array,is,greater,than,the,actual,length,of,the,array,only,validating,bytes,length,hl7bytes,length,hl7bytes,length,if,hl7bytes,length,3,hl7bytes,0,m,hl7bytes,1,s,hl7bytes,2,h,return,string,format,the,first,segment,of,the,hl7,payload,s,is,not,an,msh,segment,new,string,hl7bytes,0,math,min,3,hl7bytes,length,int,validation,length,math,min,length,hl7bytes,length,if,hl7bytes,validation,length,2,mllp,protocol,constants,hl7bytes,validation,length,1,mllp,protocol,constants,string,format,the,hl7,payload,terminating,bytes,x,x,are,incorrect,expected,x,x,ascii,cr,lf,return,string,format,format,hl7bytes,validation,length,2,hl7bytes,validation,length,1,byte,mllp,protocol,constants,byte,mllp,protocol,constants,for,int,i,0,i,validation,length,i,switch,hl7bytes,i,case,mllp,protocol,constants,return,string,format,hl7,payload,contains,an,embedded,x,ascii,vt,at,index,d,hl7bytes,i,i,case,mllp,protocol,constants,return,string,format,hl7,payload,contains,an,embedded,x,ascii,fs,at,index,d,hl7bytes,i,i,default,return,null
Hl7Util -> public static String generateInvalidPayloadExceptionMessage(final byte[] hl7Bytes, final int length);1517245483;Verifies that the HL7 payload array <p> The MLLP protocol does not allow embedded START_OF_BLOCK or END_OF_BLOCK characters.  The END_OF_DATA character is allowed (and expected) because it is_also the segment delimiter for an HL7 message__@param hl7Bytes the HL7 payload to validate__@return If the payload is invalid, an error message suitable for inclusion in an exception is returned.  If the payload is valid, null is returned_;public static String generateInvalidPayloadExceptionMessage(final byte[] hl7Bytes, final int length) {_        if (hl7Bytes == null) {_            return "HL7 payload is null"__        }__        if (hl7Bytes.length <= 0) {_            return "HL7 payload is empty"__        }__        if (length > hl7Bytes.length) {_            LOG.warn("The length specified for the HL7 payload array <{}> is greater than the actual length of the array <{}> - only validating {} bytes", length, hl7Bytes.length, hl7Bytes.length)__        }__        if (hl7Bytes.length < 3 || hl7Bytes[0] != 'M' || hl7Bytes[1] != 'S' || hl7Bytes[2] != 'H') {_            return String.format("The first segment of the HL7 payload {%s} is not an MSH segment", new String(hl7Bytes, 0, Math.min(3, hl7Bytes.length)))__        }__        int validationLength = Math.min(length, hl7Bytes.length)___        if (hl7Bytes[validationLength - 1] != MllpProtocolConstants.SEGMENT_DELIMITER  && hl7Bytes[validationLength - 1] != MllpProtocolConstants.MESSAGE_TERMINATOR) {_            String format = "The HL7 payload terminating byte [%#x] is incorrect - expected [%#x]  {ASCII [<CR>]}"__            return String.format(format, hl7Bytes[validationLength - 2], (byte) MllpProtocolConstants.SEGMENT_DELIMITER)__        }__        for (int i = 0_ i < validationLength_ ++i) {_            switch (hl7Bytes[i]) {_            case MllpProtocolConstants.START_OF_BLOCK:_                return String.format("HL7 payload contains an embedded START_OF_BLOCK {%#x, ASCII <VT>} at index %d", hl7Bytes[i], i)__            case MllpProtocolConstants.END_OF_BLOCK:_                return String.format("HL7 payload contains an embedded END_OF_BLOCK {%#x, ASCII <FS>} at index %d", hl7Bytes[i], i)__            default:_                _            }_        }__        return null__    };verifies,that,the,hl7,payload,array,p,the,mllp,protocol,does,not,allow,embedded,or,characters,the,character,is,allowed,and,expected,because,it,is,also,the,segment,delimiter,for,an,hl7,message,param,hl7bytes,the,hl7,payload,to,validate,return,if,the,payload,is,invalid,an,error,message,suitable,for,inclusion,in,an,exception,is,returned,if,the,payload,is,valid,null,is,returned;public,static,string,generate,invalid,payload,exception,message,final,byte,hl7bytes,final,int,length,if,hl7bytes,null,return,hl7,payload,is,null,if,hl7bytes,length,0,return,hl7,payload,is,empty,if,length,hl7bytes,length,log,warn,the,length,specified,for,the,hl7,payload,array,is,greater,than,the,actual,length,of,the,array,only,validating,bytes,length,hl7bytes,length,hl7bytes,length,if,hl7bytes,length,3,hl7bytes,0,m,hl7bytes,1,s,hl7bytes,2,h,return,string,format,the,first,segment,of,the,hl7,payload,s,is,not,an,msh,segment,new,string,hl7bytes,0,math,min,3,hl7bytes,length,int,validation,length,math,min,length,hl7bytes,length,if,hl7bytes,validation,length,1,mllp,protocol,constants,hl7bytes,validation,length,1,mllp,protocol,constants,string,format,the,hl7,payload,terminating,byte,x,is,incorrect,expected,x,ascii,cr,return,string,format,format,hl7bytes,validation,length,2,byte,mllp,protocol,constants,for,int,i,0,i,validation,length,i,switch,hl7bytes,i,case,mllp,protocol,constants,return,string,format,hl7,payload,contains,an,embedded,x,ascii,vt,at,index,d,hl7bytes,i,i,case,mllp,protocol,constants,return,string,format,hl7,payload,contains,an,embedded,x,ascii,fs,at,index,d,hl7bytes,i,i,default,return,null
Hl7Util -> public static String generateInvalidPayloadExceptionMessage(final byte[] hl7Bytes, final int length);1518733370;Verifies that the HL7 payload array <p> The MLLP protocol does not allow embedded START_OF_BLOCK or END_OF_BLOCK characters.  The END_OF_DATA character is allowed (and expected) because it is_also the segment delimiter for an HL7 message__@param hl7Bytes the HL7 payload to validate__@return If the payload is invalid, an error message suitable for inclusion in an exception is returned.  If the payload is valid, null is returned_;public static String generateInvalidPayloadExceptionMessage(final byte[] hl7Bytes, final int length) {_        if (hl7Bytes == null) {_            return "HL7 payload is null"__        }__        if (hl7Bytes.length <= 0) {_            return "HL7 payload is empty"__        }__        if (length > hl7Bytes.length) {_            LOG.warn("The length specified for the HL7 payload array <{}> is greater than the actual length of the array <{}> - only validating {} bytes", length, hl7Bytes.length, hl7Bytes.length)__        }__        if (hl7Bytes.length < 3 || hl7Bytes[0] != 'M' || hl7Bytes[1] != 'S' || hl7Bytes[2] != 'H') {_            return String.format("The first segment of the HL7 payload {%s} is not an MSH segment", new String(hl7Bytes, 0, Math.min(3, hl7Bytes.length)))__        }__        int validationLength = Math.min(length, hl7Bytes.length)___        if (hl7Bytes[validationLength - 1] != MllpProtocolConstants.SEGMENT_DELIMITER  && hl7Bytes[validationLength - 1] != MllpProtocolConstants.MESSAGE_TERMINATOR) {_            String format = "The HL7 payload terminating byte [%#x] is incorrect - expected [%#x]  {ASCII [<CR>]}"__            return String.format(format, hl7Bytes[validationLength - 2], (byte) MllpProtocolConstants.SEGMENT_DELIMITER)__        }__        for (int i = 0_ i < validationLength_ ++i) {_            switch (hl7Bytes[i]) {_            case MllpProtocolConstants.START_OF_BLOCK:_                return String.format("HL7 payload contains an embedded START_OF_BLOCK {%#x, ASCII <VT>} at index %d", hl7Bytes[i], i)__            case MllpProtocolConstants.END_OF_BLOCK:_                return String.format("HL7 payload contains an embedded END_OF_BLOCK {%#x, ASCII <FS>} at index %d", hl7Bytes[i], i)__            default:_                _            }_        }__        return null__    };verifies,that,the,hl7,payload,array,p,the,mllp,protocol,does,not,allow,embedded,or,characters,the,character,is,allowed,and,expected,because,it,is,also,the,segment,delimiter,for,an,hl7,message,param,hl7bytes,the,hl7,payload,to,validate,return,if,the,payload,is,invalid,an,error,message,suitable,for,inclusion,in,an,exception,is,returned,if,the,payload,is,valid,null,is,returned;public,static,string,generate,invalid,payload,exception,message,final,byte,hl7bytes,final,int,length,if,hl7bytes,null,return,hl7,payload,is,null,if,hl7bytes,length,0,return,hl7,payload,is,empty,if,length,hl7bytes,length,log,warn,the,length,specified,for,the,hl7,payload,array,is,greater,than,the,actual,length,of,the,array,only,validating,bytes,length,hl7bytes,length,hl7bytes,length,if,hl7bytes,length,3,hl7bytes,0,m,hl7bytes,1,s,hl7bytes,2,h,return,string,format,the,first,segment,of,the,hl7,payload,s,is,not,an,msh,segment,new,string,hl7bytes,0,math,min,3,hl7bytes,length,int,validation,length,math,min,length,hl7bytes,length,if,hl7bytes,validation,length,1,mllp,protocol,constants,hl7bytes,validation,length,1,mllp,protocol,constants,string,format,the,hl7,payload,terminating,byte,x,is,incorrect,expected,x,ascii,cr,return,string,format,format,hl7bytes,validation,length,2,byte,mllp,protocol,constants,for,int,i,0,i,validation,length,i,switch,hl7bytes,i,case,mllp,protocol,constants,return,string,format,hl7,payload,contains,an,embedded,x,ascii,vt,at,index,d,hl7bytes,i,i,case,mllp,protocol,constants,return,string,format,hl7,payload,contains,an,embedded,x,ascii,fs,at,index,d,hl7bytes,i,i,default,return,null
Hl7Util -> public static String generateInvalidPayloadExceptionMessage(final byte[] hl7Bytes, final int length);1520095706;Verifies that the HL7 payload array <p> The MLLP protocol does not allow embedded START_OF_BLOCK or END_OF_BLOCK characters.  The END_OF_DATA character is allowed (and expected) because it is_also the segment delimiter for an HL7 message__@param hl7Bytes the HL7 payload to validate__@return If the payload is invalid, an error message suitable for inclusion in an exception is returned.  If the payload is valid, null is returned_;public static String generateInvalidPayloadExceptionMessage(final byte[] hl7Bytes, final int length) {_        if (hl7Bytes == null) {_            return "HL7 payload is null"__        }__        if (hl7Bytes.length <= 0) {_            return "HL7 payload is empty"__        }__        if (length > hl7Bytes.length) {_            LOG.warn("The length specified for the HL7 payload array <{}> is greater than the actual length of the array <{}> - only validating {} bytes", length, hl7Bytes.length, hl7Bytes.length)__        }__        if (hl7Bytes.length < 3 || hl7Bytes[0] != 'M' || hl7Bytes[1] != 'S' || hl7Bytes[2] != 'H') {_            return String.format("The first segment of the HL7 payload {%s} is not an MSH segment", new String(hl7Bytes, 0, Math.min(3, hl7Bytes.length)))__        }__        int validationLength = Math.min(length, hl7Bytes.length)___        if (hl7Bytes[validationLength - 1] != MllpProtocolConstants.SEGMENT_DELIMITER  && hl7Bytes[validationLength - 1] != MllpProtocolConstants.MESSAGE_TERMINATOR) {_            String format = "The HL7 payload terminating byte [%#x] is incorrect - expected [%#x]  {ASCII [<CR>]}"__            return String.format(format, hl7Bytes[validationLength - 2], (byte) MllpProtocolConstants.SEGMENT_DELIMITER)__        }__        for (int i = 0_ i < validationLength_ ++i) {_            switch (hl7Bytes[i]) {_            case MllpProtocolConstants.START_OF_BLOCK:_                return String.format("HL7 payload contains an embedded START_OF_BLOCK {%#x, ASCII <VT>} at index %d", hl7Bytes[i], i)__            case MllpProtocolConstants.END_OF_BLOCK:_                return String.format("HL7 payload contains an embedded END_OF_BLOCK {%#x, ASCII <FS>} at index %d", hl7Bytes[i], i)__            default:_                _            }_        }__        return null__    };verifies,that,the,hl7,payload,array,p,the,mllp,protocol,does,not,allow,embedded,or,characters,the,character,is,allowed,and,expected,because,it,is,also,the,segment,delimiter,for,an,hl7,message,param,hl7bytes,the,hl7,payload,to,validate,return,if,the,payload,is,invalid,an,error,message,suitable,for,inclusion,in,an,exception,is,returned,if,the,payload,is,valid,null,is,returned;public,static,string,generate,invalid,payload,exception,message,final,byte,hl7bytes,final,int,length,if,hl7bytes,null,return,hl7,payload,is,null,if,hl7bytes,length,0,return,hl7,payload,is,empty,if,length,hl7bytes,length,log,warn,the,length,specified,for,the,hl7,payload,array,is,greater,than,the,actual,length,of,the,array,only,validating,bytes,length,hl7bytes,length,hl7bytes,length,if,hl7bytes,length,3,hl7bytes,0,m,hl7bytes,1,s,hl7bytes,2,h,return,string,format,the,first,segment,of,the,hl7,payload,s,is,not,an,msh,segment,new,string,hl7bytes,0,math,min,3,hl7bytes,length,int,validation,length,math,min,length,hl7bytes,length,if,hl7bytes,validation,length,1,mllp,protocol,constants,hl7bytes,validation,length,1,mllp,protocol,constants,string,format,the,hl7,payload,terminating,byte,x,is,incorrect,expected,x,ascii,cr,return,string,format,format,hl7bytes,validation,length,2,byte,mllp,protocol,constants,for,int,i,0,i,validation,length,i,switch,hl7bytes,i,case,mllp,protocol,constants,return,string,format,hl7,payload,contains,an,embedded,x,ascii,vt,at,index,d,hl7bytes,i,i,case,mllp,protocol,constants,return,string,format,hl7,payload,contains,an,embedded,x,ascii,fs,at,index,d,hl7bytes,i,i,default,return,null
Hl7Util -> public static String generateInvalidPayloadExceptionMessage(final byte[] hl7Bytes, final int length);1524063106;Verifies that the HL7 payload array <p> The MLLP protocol does not allow embedded START_OF_BLOCK or END_OF_BLOCK characters.  The END_OF_DATA character is allowed (and expected) because it is_also the segment delimiter for an HL7 message__@param hl7Bytes the HL7 payload to validate__@return If the payload is invalid, an error message suitable for inclusion in an exception is returned.  If the payload is valid, null is returned_;public static String generateInvalidPayloadExceptionMessage(final byte[] hl7Bytes, final int length) {_        if (hl7Bytes == null) {_            return "HL7 payload is null"__        }__        if (hl7Bytes.length <= 0) {_            return "HL7 payload is empty"__        }__        if (length > hl7Bytes.length) {_            LOG.warn("The length specified for the HL7 payload array <{}> is greater than the actual length of the array <{}> - only validating {} bytes", length, hl7Bytes.length, hl7Bytes.length)__        }__        if (hl7Bytes.length < 3 || hl7Bytes[0] != 'M' || hl7Bytes[1] != 'S' || hl7Bytes[2] != 'H') {_            return String.format("The first segment of the HL7 payload {%s} is not an MSH segment", new String(hl7Bytes, 0, Math.min(3, hl7Bytes.length)))__        }__        int validationLength = Math.min(length, hl7Bytes.length)___        if (hl7Bytes[validationLength - 1] != MllpProtocolConstants.SEGMENT_DELIMITER  && hl7Bytes[validationLength - 1] != MllpProtocolConstants.MESSAGE_TERMINATOR) {_            String format = "The HL7 payload terminating byte [%#x] is incorrect - expected [%#x]  {ASCII [<CR>]}"__            return String.format(format, hl7Bytes[validationLength - 2], (byte) MllpProtocolConstants.SEGMENT_DELIMITER)__        }__        for (int i = 0_ i < validationLength_ ++i) {_            switch (hl7Bytes[i]) {_            case MllpProtocolConstants.START_OF_BLOCK:_                return String.format("HL7 payload contains an embedded START_OF_BLOCK {%#x, ASCII <VT>} at index %d", hl7Bytes[i], i)__            case MllpProtocolConstants.END_OF_BLOCK:_                return String.format("HL7 payload contains an embedded END_OF_BLOCK {%#x, ASCII <FS>} at index %d", hl7Bytes[i], i)__            default:_                _            }_        }__        return null__    };verifies,that,the,hl7,payload,array,p,the,mllp,protocol,does,not,allow,embedded,or,characters,the,character,is,allowed,and,expected,because,it,is,also,the,segment,delimiter,for,an,hl7,message,param,hl7bytes,the,hl7,payload,to,validate,return,if,the,payload,is,invalid,an,error,message,suitable,for,inclusion,in,an,exception,is,returned,if,the,payload,is,valid,null,is,returned;public,static,string,generate,invalid,payload,exception,message,final,byte,hl7bytes,final,int,length,if,hl7bytes,null,return,hl7,payload,is,null,if,hl7bytes,length,0,return,hl7,payload,is,empty,if,length,hl7bytes,length,log,warn,the,length,specified,for,the,hl7,payload,array,is,greater,than,the,actual,length,of,the,array,only,validating,bytes,length,hl7bytes,length,hl7bytes,length,if,hl7bytes,length,3,hl7bytes,0,m,hl7bytes,1,s,hl7bytes,2,h,return,string,format,the,first,segment,of,the,hl7,payload,s,is,not,an,msh,segment,new,string,hl7bytes,0,math,min,3,hl7bytes,length,int,validation,length,math,min,length,hl7bytes,length,if,hl7bytes,validation,length,1,mllp,protocol,constants,hl7bytes,validation,length,1,mllp,protocol,constants,string,format,the,hl7,payload,terminating,byte,x,is,incorrect,expected,x,ascii,cr,return,string,format,format,hl7bytes,validation,length,2,byte,mllp,protocol,constants,for,int,i,0,i,validation,length,i,switch,hl7bytes,i,case,mllp,protocol,constants,return,string,format,hl7,payload,contains,an,embedded,x,ascii,vt,at,index,d,hl7bytes,i,i,case,mllp,protocol,constants,return,string,format,hl7,payload,contains,an,embedded,x,ascii,fs,at,index,d,hl7bytes,i,i,default,return,null
Hl7Util -> public static String findMsh18(byte[] hl7Message);1517245483;Find the String value of MSH-19 (Character set).__@param hl7Message the HL7 binary data to search__@return the String value of MSH-19, or an empty String if not found.;public static String findMsh18(byte[] hl7Message) {_        String answer = ""___        if (hl7Message != null && hl7Message.length > 0) {__            List<Integer> fieldSeparatorIndexes = findFieldSeparatorIndicesInSegment(hl7Message, 0)___            if (fieldSeparatorIndexes.size() > 18) {_                int startOfMsh19 = fieldSeparatorIndexes.get(17) + 1__                int length = fieldSeparatorIndexes.get(18) - fieldSeparatorIndexes.get(17) - 1___                if (length > 0) {_                    answer = new String(hl7Message, startOfMsh19, length, StandardCharsets.US_ASCII)__                }_            }_        }__        return answer__    };find,the,string,value,of,msh,19,character,set,param,hl7message,the,hl7,binary,data,to,search,return,the,string,value,of,msh,19,or,an,empty,string,if,not,found;public,static,string,find,msh18,byte,hl7message,string,answer,if,hl7message,null,hl7message,length,0,list,integer,field,separator,indexes,find,field,separator,indices,in,segment,hl7message,0,if,field,separator,indexes,size,18,int,start,of,msh19,field,separator,indexes,get,17,1,int,length,field,separator,indexes,get,18,field,separator,indexes,get,17,1,if,length,0,answer,new,string,hl7message,start,of,msh19,length,standard,charsets,return,answer
Hl7Util -> public static String findMsh18(byte[] hl7Message);1518733370;Find the String value of MSH-18 (Character set).__@param hl7Message the HL7 binary data to search__@return the String value of MSH-18, or an empty String if not found.;public static String findMsh18(byte[] hl7Message) {_        String answer = ""___        if (hl7Message != null && hl7Message.length > 0) {__            List<Integer> fieldSeparatorIndexes = findFieldSeparatorIndicesInSegment(hl7Message, 0)___            if (fieldSeparatorIndexes.size() > 17) {_                int startOfMsh19 = fieldSeparatorIndexes.get(16) + 1__                int length = fieldSeparatorIndexes.get(17) - fieldSeparatorIndexes.get(16) - 1___                if (length > 0) {_                    answer = new String(hl7Message, startOfMsh19, length, MllpComponent.getDefaultCharset())__                }_            }_        }__        return answer__    };find,the,string,value,of,msh,18,character,set,param,hl7message,the,hl7,binary,data,to,search,return,the,string,value,of,msh,18,or,an,empty,string,if,not,found;public,static,string,find,msh18,byte,hl7message,string,answer,if,hl7message,null,hl7message,length,0,list,integer,field,separator,indexes,find,field,separator,indices,in,segment,hl7message,0,if,field,separator,indexes,size,17,int,start,of,msh19,field,separator,indexes,get,16,1,int,length,field,separator,indexes,get,17,field,separator,indexes,get,16,1,if,length,0,answer,new,string,hl7message,start,of,msh19,length,mllp,component,get,default,charset,return,answer
Hl7Util -> public static String findMsh18(byte[] hl7Message);1520095706;Find the String value of MSH-18 (Character set).__@param hl7Message the HL7 binary data to search__@return the String value of MSH-18, or an empty String if not found.;public static String findMsh18(byte[] hl7Message) {_        String answer = ""___        if (hl7Message != null && hl7Message.length > 0) {__            List<Integer> fieldSeparatorIndexes = findFieldSeparatorIndicesInSegment(hl7Message, 0)___            if (fieldSeparatorIndexes.size() > 17) {_                int startOfMsh19 = fieldSeparatorIndexes.get(16) + 1__                int length = fieldSeparatorIndexes.get(17) - fieldSeparatorIndexes.get(16) - 1___                if (length > 0) {_                    answer = new String(hl7Message, startOfMsh19, length, MllpComponent.getDefaultCharset())__                }_            }_        }__        return answer__    };find,the,string,value,of,msh,18,character,set,param,hl7message,the,hl7,binary,data,to,search,return,the,string,value,of,msh,18,or,an,empty,string,if,not,found;public,static,string,find,msh18,byte,hl7message,string,answer,if,hl7message,null,hl7message,length,0,list,integer,field,separator,indexes,find,field,separator,indices,in,segment,hl7message,0,if,field,separator,indexes,size,17,int,start,of,msh19,field,separator,indexes,get,16,1,int,length,field,separator,indexes,get,17,field,separator,indexes,get,16,1,if,length,0,answer,new,string,hl7message,start,of,msh19,length,mllp,component,get,default,charset,return,answer
Hl7Util -> public static String findMsh18(byte[] hl7Message);1524063106;Find the String value of MSH-18 (Character set).__@param hl7Message the HL7 binary data to search__@return the String value of MSH-18, or an empty String if not found.;public static String findMsh18(byte[] hl7Message) {_        String answer = ""___        if (hl7Message != null && hl7Message.length > 0) {__            List<Integer> fieldSeparatorIndexes = findFieldSeparatorIndicesInSegment(hl7Message, 0)___            if (fieldSeparatorIndexes.size() > 17) {_                int startOfMsh19 = fieldSeparatorIndexes.get(16) + 1__                int length = fieldSeparatorIndexes.get(17) - fieldSeparatorIndexes.get(16) - 1___                if (length > 0) {_                    answer = new String(hl7Message, startOfMsh19, length, MllpComponent.getDefaultCharset())__                }_            }_        }__        return answer__    };find,the,string,value,of,msh,18,character,set,param,hl7message,the,hl7,binary,data,to,search,return,the,string,value,of,msh,18,or,an,empty,string,if,not,found;public,static,string,find,msh18,byte,hl7message,string,answer,if,hl7message,null,hl7message,length,0,list,integer,field,separator,indexes,find,field,separator,indices,in,segment,hl7message,0,if,field,separator,indexes,size,17,int,start,of,msh19,field,separator,indexes,get,16,1,int,length,field,separator,indexes,get,17,field,separator,indexes,get,16,1,if,length,0,answer,new,string,hl7message,start,of,msh19,length,mllp,component,get,default,charset,return,answer
