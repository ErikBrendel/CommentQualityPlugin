commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public Exchange createExchange(ExchangePattern exchangePattern) {     Exchange mllpExchange = super.createExchange(exchangePattern).     setExchangeProperties(mllpExchange).     return mllpExchange. }
false;public;1;5;;@Override public void setExchangePattern(ExchangePattern exchangePattern) {     configuration.setExchangePattern(exchangePattern).     super.setExchangePattern(configuration.getExchangePattern()). }
false;public;1;5;;@Override public void setSynchronous(boolean synchronous) {     configuration.setSynchronous(synchronous).     super.setSynchronous(configuration.isSynchronous()). }
false;public;1;5;;@Override public void setBridgeErrorHandler(boolean bridgeErrorHandler) {     configuration.setBridgeErrorHandler(bridgeErrorHandler).     super.setBridgeErrorHandler(configuration.isBridgeErrorHandler()). }
false;private;1;5;;private void setExchangeProperties(Exchange mllpExchange) {     if (configuration.hasCharsetName()) {         mllpExchange.setProperty(Exchange.CHARSET_NAME, configuration.getCharsetName()).     } }
false;public;0;4;;public Producer createProducer() throws Exception {     log.trace("({}).createProducer()", this.getEndpointKey()).     return new MllpTcpClientProducer(this). }
false;public;1;6;;public Consumer createConsumer(Processor processor) throws Exception {     log.trace("({}).createConsumer(Processor)", this.getEndpointKey()).     Consumer consumer = new MllpTcpServerConsumer(this, processor).     configureConsumer(consumer).     return consumer. }
false;public;0;3;;public boolean isSingleton() {     return true. }
false;public;0;8;;@ManagedAttribute(description = "Last activity time") public Date getLastConnectionActivityTime() {     if (lastConnectionActivityTicks != null) {         return new Date(lastConnectionActivityTicks).     }     return null. }
false;public;0;8;;@ManagedAttribute(description = "Last connection established time") public Date getLastConnectionEstablishedTime() {     if (lastConnectionEstablishedTicks != null) {         return new Date(lastConnectionEstablishedTicks).     }     return null. }
false;public;0;4;;@ManagedAttribute(description = "Last connection terminated time") public Date getLastConnectionTerminatedTime() {     return lastConnectionTerminatedTicks != null ? new Date(lastConnectionTerminatedTicks) : null. }
false;public;0;3;;public boolean hasLastConnectionActivityTicks() {     return lastConnectionActivityTicks != null && lastConnectionActivityTicks > 0. }
false;public;0;3;;public Long getLastConnectionActivityTicks() {     return lastConnectionActivityTicks. }
false;public;0;3;;public void updateLastConnectionActivityTicks() {     updateLastConnectionActivityTicks(System.currentTimeMillis()). }
false;public;1;3;;public void updateLastConnectionActivityTicks(long epochTicks) {     lastConnectionActivityTicks = epochTicks. }
false;public;0;3;;public void updateLastConnectionEstablishedTicks() {     lastConnectionEstablishedTicks = System.currentTimeMillis(). }
false;public;0;3;;public void updateLastConnectionTerminatedTicks() {     lastConnectionTerminatedTicks = System.currentTimeMillis(). }
false;public;0;3;;public String getHostname() {     return hostname. }
true;public;1;3;/**  * Hostname or IP for connection for the TCP connection.  *  * The default value is null, which means any local IP address  *  * @param hostname Hostname or IP  */ ;/**  * Hostname or IP for connection for the TCP connection.  *  * The default value is null, which means any local IP address  *  * @param hostname Hostname or IP  */ public void setHostname(String hostname) {     this.hostname = hostname. }
false;public;0;3;;public int getPort() {     return port. }
true;public;1;3;/**  * Port number for the TCP connection  *  * @param port TCP port  */ ;/**  * Port number for the TCP connection  *  * @param port TCP port  */ public void setPort(int port) {     this.port = port. }
false;public;0;3;;public boolean hasConfiguration() {     return configuration != null. }
false;public;0;3;;public MllpConfiguration getConfiguration() {     return configuration. }
false;public;1;7;;public void setConfiguration(MllpConfiguration configuration) {     if (hasConfiguration()) {         this.configuration.copy(configuration).     } else {         this.configuration = configuration.copy().     } }
true;public;1;3;// Pass-through configuration methods ;// Pass-through configuration methods public void setBacklog(Integer backlog) {     configuration.setBacklog(backlog). }
false;public;1;3;;public void setBindTimeout(int bindTimeout) {     configuration.setBindTimeout(bindTimeout). }
false;public;1;3;;public void setBindRetryInterval(int bindRetryInterval) {     configuration.setBindRetryInterval(bindRetryInterval). }
false;public;1;3;;public void setLenientBind(boolean lenientBind) {     configuration.setLenientBind(lenientBind). }
false;public;1;3;;public void setAcceptTimeout(int acceptTimeout) {     configuration.setAcceptTimeout(acceptTimeout). }
false;public;1;3;;public void setConnectTimeout(int connectTimeout) {     configuration.setConnectTimeout(connectTimeout). }
false;public;1;3;;public void setReceiveTimeout(int receiveTimeout) {     configuration.setReceiveTimeout(receiveTimeout). }
false;public;1;3;;public void setIdleTimeout(Integer idleTimeout) {     configuration.setIdleTimeout(idleTimeout). }
false;public;1;3;;public void setReadTimeout(int readTimeout) {     configuration.setReadTimeout(readTimeout). }
false;public;1;3;;public void setKeepAlive(Boolean keepAlive) {     configuration.setKeepAlive(keepAlive). }
false;public;1;3;;public void setTcpNoDelay(Boolean tcpNoDelay) {     configuration.setTcpNoDelay(tcpNoDelay). }
false;public;1;3;;public void setReuseAddress(Boolean reuseAddress) {     configuration.setReuseAddress(reuseAddress). }
false;public;1;3;;public void setReceiveBufferSize(Integer receiveBufferSize) {     configuration.setReceiveBufferSize(receiveBufferSize). }
false;public;1;3;;public void setSendBufferSize(Integer sendBufferSize) {     configuration.setSendBufferSize(sendBufferSize). }
false;public;1;3;;public void setAutoAck(Boolean autoAck) {     configuration.setAutoAck(autoAck). }
false;public;1;3;;public void setHl7Headers(Boolean hl7Headers) {     configuration.setHl7Headers(hl7Headers). }
true;public;1;4;/**  * @deprecated this parameter will be ignored.  *  * @param bufferWrites  */ ;/**  * @deprecated this parameter will be ignored.  *  * @param bufferWrites  */ @Deprecated public void setBufferWrites(Boolean bufferWrites) {     configuration.setBufferWrites(bufferWrites). }
false;public;1;3;;public void setRequireEndOfData(Boolean requireEndOfData) {     configuration.setRequireEndOfData(requireEndOfData). }
false;public;1;3;;public void setStringPayload(Boolean stringPayload) {     configuration.setStringPayload(stringPayload). }
false;public;1;3;;public void setValidatePayload(Boolean validatePayload) {     configuration.setValidatePayload(validatePayload). }
false;public;1;3;;public void setCharsetName(String charsetName) {     configuration.setCharsetName(charsetName). }
false;public;3;16;;// Utility methods for producers and consumers public boolean checkBeforeSendProperties(Exchange exchange, Socket socket, Logger log) {     final String logMessageFormat = "Exchange property {} = {} - {} connection".     boolean answer = true.     if (exchange.getProperty(MllpConstants.MLLP_RESET_CONNECTION_BEFORE_SEND, boolean.class)) {         log.warn(logMessageFormat, MllpConstants.MLLP_RESET_CONNECTION_BEFORE_SEND, exchange.getProperty(MllpConstants.MLLP_RESET_CONNECTION_BEFORE_SEND), "resetting").         doConnectionClose(socket, true, null).         answer = false.     } else if (exchange.getProperty(MllpConstants.MLLP_CLOSE_CONNECTION_BEFORE_SEND, boolean.class)) {         log.warn(logMessageFormat, MllpConstants.MLLP_CLOSE_CONNECTION_BEFORE_SEND, exchange.getProperty(MllpConstants.MLLP_CLOSE_CONNECTION_BEFORE_SEND), "closing").         doConnectionClose(socket, false, null).         answer = false.     }     return answer. }
false;public;3;16;;public boolean checkAfterSendProperties(Exchange exchange, Socket socket, Logger log) {     final String logMessageFormat = "Exchange property {} = {} - {} connection".     boolean answer = true.     if (exchange.getProperty(MllpConstants.MLLP_RESET_CONNECTION_AFTER_SEND, boolean.class)) {         log.warn(logMessageFormat, MllpConstants.MLLP_RESET_CONNECTION_AFTER_SEND, exchange.getProperty(MllpConstants.MLLP_RESET_CONNECTION_AFTER_SEND), "resetting").         doConnectionClose(socket, true, log).         answer = false.     } else if (exchange.getProperty(MllpConstants.MLLP_CLOSE_CONNECTION_AFTER_SEND, boolean.class)) {         log.warn(logMessageFormat, MllpConstants.MLLP_CLOSE_CONNECTION_AFTER_SEND, exchange.getProperty(MllpConstants.MLLP_CLOSE_CONNECTION_AFTER_SEND), "closing").         doConnectionClose(socket, false, log).         answer = false.     }     return answer. }
false;public;3;80;;public void doConnectionClose(Socket socket, boolean reset, Logger log) {     String ignoringCallLogFormat = "Ignoring {} Connection request because - {}: localAddress={} remoteAddress={}".     if (socket == null) {         if (log != null) {             log.debug(ignoringCallLogFormat, reset ? "Reset" : "Close", "Socket is null", "null", "null").         }     } else {         SocketAddress localSocketAddress = socket.getLocalSocketAddress().         SocketAddress remoteSocketAddress = socket.getRemoteSocketAddress().         if (!socket.isConnected()) {             if (log != null) {                 log.debug(ignoringCallLogFormat, reset ? "Reset" : "Close", "Socket is not connected", localSocketAddress, remoteSocketAddress).             }         } else if (socket.isClosed()) {             if (log != null) {                 log.debug(ignoringCallLogFormat, reset ? "Reset" : "Close", "Socket is already closed", localSocketAddress, remoteSocketAddress).             }         } else {             this.updateLastConnectionTerminatedTicks().             final String ignoringExceptionStringFormat = "Ignoring %s encountered calling %s on Socket: localAddress=%s remoteAddress=%s".             if (!socket.isInputShutdown()) {                 if (log != null) {                     log.trace("Shutting down input on Socket: localAddress={} remoteAddress={}", localSocketAddress, remoteSocketAddress).                 }                 try {                     socket.shutdownInput().                 } catch (Exception ioEx) {                     if (log != null && log.isDebugEnabled()) {                         String logMessage = String.format(ignoringExceptionStringFormat, ioEx.getClass().getSimpleName(), "shutdownInput()", localSocketAddress, remoteSocketAddress).                         log.debug(logMessage, ioEx).                     }                 }             }             if (!socket.isOutputShutdown()) {                 if (log != null) {                     log.trace("Shutting down output on Socket: localAddress={} remoteAddress={}", localSocketAddress, remoteSocketAddress).                 }                 try {                     socket.shutdownOutput().                 } catch (IOException ioEx) {                     if (log != null && log.isDebugEnabled()) {                         String logMessage = String.format(ignoringExceptionStringFormat, ioEx.getClass().getSimpleName(), "shutdownOutput()", localSocketAddress, remoteSocketAddress).                         log.debug(logMessage, ioEx).                     }                 }             }             if (reset) {                 final boolean on = true.                 final int linger = 0.                 if (log != null) {                     log.trace("Setting SO_LINGER to {} on Socket: localAddress={} remoteAddress={}", localSocketAddress, remoteSocketAddress).                 }                 try {                     socket.setSoLinger(on, linger).                 } catch (IOException ioEx) {                     if (log.isDebugEnabled()) {                         String methodString = String.format("setSoLinger(%b, %d)", on, linger).                         String logMessage = String.format(ignoringExceptionStringFormat, ioEx.getClass().getSimpleName(), methodString, localSocketAddress, remoteSocketAddress).                         log.debug(logMessage, ioEx).                     }                 }             }             try {                 if (log != null) {                     log.trace("Resetting Socket: localAddress={} remoteAddress={}", localSocketAddress, remoteSocketAddress).                 }                 socket.close().             } catch (IOException ioEx) {                 if (log.isDebugEnabled()) {                     String warningMessage = String.format(ignoringExceptionStringFormat, ioEx.getClass().getSimpleName(), "close()", localSocketAddress, remoteSocketAddress).                     log.debug(warningMessage, ioEx).                 }             }         }     } }
