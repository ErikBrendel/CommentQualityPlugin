# id;timestamp;commentText;codeText;commentWords;codeWords
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message);1451464990;Generates a HL7 Application Accept Acknowledgement__@param hl7Message HL7 message that is being acknowledged_@return a HL7 Application Accept Acknowlegdement;private String generateAcknowledgementMessage(String hl7Message) {_            return generateAcknowledgementMessage(hl7Message, "AA")__        };generates,a,hl7,application,accept,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,return,a,hl7,application,accept,acknowlegdement;private,string,generate,acknowledgement,message,string,hl7message,return,generate,acknowledgement,message,hl7message,aa
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message);1453968697;Generates a HL7 Application Accept Acknowledgement__@param hl7Message HL7 message that is being acknowledged_@return a HL7 Application Accept Acknowlegdement;private String generateAcknowledgementMessage(String hl7Message) {_            return generateAcknowledgementMessage(hl7Message, "AA")__        };generates,a,hl7,application,accept,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,return,a,hl7,application,accept,acknowlegdement;private,string,generate,acknowledgement,message,string,hl7message,return,generate,acknowledgement,message,hl7message,aa
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message);1453968697;Generates a HL7 Application Accept Acknowledgement__@param hl7Message HL7 message that is being acknowledged_@return a HL7 Application Accept Acknowlegdement;private String generateAcknowledgementMessage(String hl7Message) {_            return generateAcknowledgementMessage(hl7Message, "AA")__        };generates,a,hl7,application,accept,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,return,a,hl7,application,accept,acknowlegdement;private,string,generate,acknowledgement,message,string,hl7message,return,generate,acknowledgement,message,hl7message,aa
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message);1457097808;Generates a HL7 Application Accept Acknowledgement__@param hl7Message HL7 message that is being acknowledged_@return a HL7 Application Accept Acknowlegdement;private String generateAcknowledgementMessage(String hl7Message) {_            return generateAcknowledgementMessage(hl7Message, "AA")__        };generates,a,hl7,application,accept,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,return,a,hl7,application,accept,acknowlegdement;private,string,generate,acknowledgement,message,string,hl7message,return,generate,acknowledgement,message,hl7message,aa
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message);1461916938;Generates a HL7 Application Accept Acknowledgement__@param hl7Message HL7 message that is being acknowledged_@return a HL7 Application Accept Acknowlegdement;private String generateAcknowledgementMessage(String hl7Message) {_            return generateAcknowledgementMessage(hl7Message, "AA")__        };generates,a,hl7,application,accept,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,return,a,hl7,application,accept,acknowlegdement;private,string,generate,acknowledgement,message,string,hl7message,return,generate,acknowledgement,message,hl7message,aa
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message);1480882601;Generates a HL7 Application Accept Acknowledgement__@param hl7Message HL7 message that is being acknowledged_@return a HL7 Application Accept Acknowlegdement;private String generateAcknowledgementMessage(String hl7Message) {_            return generateAcknowledgementMessage(hl7Message, "AA")__        };generates,a,hl7,application,accept,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,return,a,hl7,application,accept,acknowlegdement;private,string,generate,acknowledgement,message,string,hl7message,return,generate,acknowledgement,message,hl7message,aa
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message);1481829620;Generates a HL7 Application Accept Acknowledgement__@param hl7Message HL7 message that is being acknowledged_@return a HL7 Application Accept Acknowlegdement;private String generateAcknowledgementMessage(String hl7Message) {_            return generateAcknowledgementMessage(hl7Message, "AA")__        };generates,a,hl7,application,accept,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,return,a,hl7,application,accept,acknowlegdement;private,string,generate,acknowledgement,message,string,hl7message,return,generate,acknowledgement,message,hl7message,aa
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message);1515779403;Generates a HL7 Application Accept Acknowledgement__@param hl7Message HL7 message that is being acknowledged__@return a HL7 Application Accept Acknowlegdement;private String generateAcknowledgementMessage(String hl7Message) {_            return generateAcknowledgementMessage(hl7Message, "AA")__        };generates,a,hl7,application,accept,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,return,a,hl7,application,accept,acknowlegdement;private,string,generate,acknowledgement,message,string,hl7message,return,generate,acknowledgement,message,hl7message,aa
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message);1524063106;Generates a HL7 Application Accept Acknowledgement__@param hl7Message HL7 message that is being acknowledged__@return a HL7 Application Accept Acknowlegdement;private String generateAcknowledgementMessage(String hl7Message) {_            return generateAcknowledgementMessage(hl7Message, "AA")__        };generates,a,hl7,application,accept,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,return,a,hl7,application,accept,acknowlegdement;private,string,generate,acknowledgement,message,string,hl7message,return,generate,acknowledgement,message,hl7message,aa
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message);1536605520;Generates a HL7 Application Accept Acknowledgement__@param hl7Message HL7 message that is being acknowledged__@return a HL7 Application Accept Acknowlegdement;private String generateAcknowledgementMessage(String hl7Message) {_            return generateAcknowledgementMessage(hl7Message, "AA")__        };generates,a,hl7,application,accept,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,return,a,hl7,application,accept,acknowlegdement;private,string,generate,acknowledgement,message,string,hl7message,return,generate,acknowledgement,message,hl7message,aa
MllpServerResource -> ServerSocketThread -> private void bind() throws IOException;1451464990;Open the TCP Listener__@throws IOException;private void bind() throws IOException {_            this.setDaemon(true)__            serverSocket = new ServerSocket()___            _            serverSocket.setSoTimeout(acceptTimeout)__            serverSocket.setReuseAddress(false)___            if (0 >= listenPort) {_                serverSocket.bind(null, backlog)__            } else {_                serverSocket.bind(new InetSocketAddress(this.listenHost, this.listenPort), backlog)__            }__            if (0 >= this.listenPort) {_                this.listenPort = serverSocket.getLocalPort()__            }___            log.info("Opened TCP Listener on port {}", serverSocket.getLocalPort())__        };open,the,tcp,listener,throws,ioexception;private,void,bind,throws,ioexception,this,set,daemon,true,server,socket,new,server,socket,server,socket,set,so,timeout,accept,timeout,server,socket,set,reuse,address,false,if,0,listen,port,server,socket,bind,null,backlog,else,server,socket,bind,new,inet,socket,address,this,listen,host,this,listen,port,backlog,if,0,this,listen,port,this,listen,port,server,socket,get,local,port,log,info,opened,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> ServerSocketThread -> private void bind() throws IOException;1453968697;Open the TCP Listener__@throws IOException;private void bind() throws IOException {_            this.setDaemon(true)__            serverSocket = new ServerSocket()___            _            serverSocket.setSoTimeout(acceptTimeout)__            serverSocket.setReuseAddress(false)___            if (0 >= listenPort) {_                serverSocket.bind(null, backlog)__            } else {_                serverSocket.bind(new InetSocketAddress(this.listenHost, this.listenPort), backlog)__            }__            if (0 >= this.listenPort) {_                this.listenPort = serverSocket.getLocalPort()__            }___            log.info("Opened TCP Listener on port {}", serverSocket.getLocalPort())__        };open,the,tcp,listener,throws,ioexception;private,void,bind,throws,ioexception,this,set,daemon,true,server,socket,new,server,socket,server,socket,set,so,timeout,accept,timeout,server,socket,set,reuse,address,false,if,0,listen,port,server,socket,bind,null,backlog,else,server,socket,bind,new,inet,socket,address,this,listen,host,this,listen,port,backlog,if,0,this,listen,port,this,listen,port,server,socket,get,local,port,log,info,opened,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> ServerSocketThread -> private void bind() throws IOException;1453968697;Open the TCP Listener__@throws IOException;private void bind() throws IOException {_            this.setDaemon(true)__            serverSocket = new ServerSocket()___            _            serverSocket.setSoTimeout(acceptTimeout)__            serverSocket.setReuseAddress(true)___            InetSocketAddress listenAddress__            if ( null != this.listenHost ) {_                listenAddress = new InetSocketAddress(this.listenHost, this.listenPort)__            } else {_                listenAddress = new InetSocketAddress( this.listenPort )__            }__            long startTicks = System.currentTimeMillis()__            while (!serverSocket.isBound()) {_                try {_                    serverSocket.bind(listenAddress, backlog)__                } catch ( BindException bindEx ) {_                    if ( System.currentTimeMillis() < startTicks + bindTimeout) {_                        log.warn( "Unable to bind to {} - retrying in {} milliseconds", listenAddress.toString(), bindRetryDelay)__                        try {_                            Thread.sleep(bindRetryDelay)__                        } catch (InterruptedException interruptedEx) {_                            log.error( "Wait for bind retry was interrupted - rethrowing BindException")__                            throw bindEx__                        }_                    }_                }_            }__            if (0 >= this.listenPort) {_                this.listenPort = serverSocket.getLocalPort()__            }___            log.info("Opened TCP Listener on port {}", serverSocket.getLocalPort())__        };open,the,tcp,listener,throws,ioexception;private,void,bind,throws,ioexception,this,set,daemon,true,server,socket,new,server,socket,server,socket,set,so,timeout,accept,timeout,server,socket,set,reuse,address,true,inet,socket,address,listen,address,if,null,this,listen,host,listen,address,new,inet,socket,address,this,listen,host,this,listen,port,else,listen,address,new,inet,socket,address,this,listen,port,long,start,ticks,system,current,time,millis,while,server,socket,is,bound,try,server,socket,bind,listen,address,backlog,catch,bind,exception,bind,ex,if,system,current,time,millis,start,ticks,bind,timeout,log,warn,unable,to,bind,to,retrying,in,milliseconds,listen,address,to,string,bind,retry,delay,try,thread,sleep,bind,retry,delay,catch,interrupted,exception,interrupted,ex,log,error,wait,for,bind,retry,was,interrupted,rethrowing,bind,exception,throw,bind,ex,if,0,this,listen,port,this,listen,port,server,socket,get,local,port,log,info,opened,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> ServerSocketThread -> private void bind() throws IOException;1457097808;Open the TCP Listener__@throws IOException;private void bind() throws IOException {_            this.setDaemon(true)__            serverSocket = new ServerSocket()___            _            serverSocket.setSoTimeout(acceptTimeout)__            serverSocket.setReuseAddress(true)___            InetSocketAddress listenAddress__            if (null != this.listenHost) {_                listenAddress = new InetSocketAddress(this.listenHost, this.listenPort)__            } else {_                listenAddress = new InetSocketAddress(this.listenPort)__            }__            long startTicks = System.currentTimeMillis()__            while (!serverSocket.isBound()) {_                try {_                    serverSocket.bind(listenAddress, backlog)__                } catch (BindException bindEx) {_                    if (System.currentTimeMillis() < startTicks + bindTimeout) {_                        log.warn("Unable to bind to {} - retrying in {} milliseconds", listenAddress.toString(), bindRetryDelay)__                        try {_                            Thread.sleep(bindRetryDelay)__                        } catch (InterruptedException interruptedEx) {_                            log.error("Wait for bind retry was interrupted - rethrowing BindException")__                            throw bindEx__                        }_                    }_                }_            }__            if (0 >= this.listenPort) {_                this.listenPort = serverSocket.getLocalPort()__            }___            log.info("Opened TCP Listener on port {}", serverSocket.getLocalPort())__        };open,the,tcp,listener,throws,ioexception;private,void,bind,throws,ioexception,this,set,daemon,true,server,socket,new,server,socket,server,socket,set,so,timeout,accept,timeout,server,socket,set,reuse,address,true,inet,socket,address,listen,address,if,null,this,listen,host,listen,address,new,inet,socket,address,this,listen,host,this,listen,port,else,listen,address,new,inet,socket,address,this,listen,port,long,start,ticks,system,current,time,millis,while,server,socket,is,bound,try,server,socket,bind,listen,address,backlog,catch,bind,exception,bind,ex,if,system,current,time,millis,start,ticks,bind,timeout,log,warn,unable,to,bind,to,retrying,in,milliseconds,listen,address,to,string,bind,retry,delay,try,thread,sleep,bind,retry,delay,catch,interrupted,exception,interrupted,ex,log,error,wait,for,bind,retry,was,interrupted,rethrowing,bind,exception,throw,bind,ex,if,0,this,listen,port,this,listen,port,server,socket,get,local,port,log,info,opened,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> ServerSocketThread -> private void bind() throws IOException;1461916938;Open the TCP Listener__@throws IOException;private void bind() throws IOException {_            this.setDaemon(true)__            serverSocket = new ServerSocket()___            _            serverSocket.setSoTimeout(acceptTimeout)__            serverSocket.setReuseAddress(true)___            InetSocketAddress listenAddress__            if (null != this.listenHost) {_                listenAddress = new InetSocketAddress(this.listenHost, this.listenPort)__            } else {_                listenAddress = new InetSocketAddress(this.listenPort)__            }__            long startTicks = System.currentTimeMillis()__            while (!serverSocket.isBound()) {_                try {_                    serverSocket.bind(listenAddress, backlog)__                } catch (BindException bindEx) {_                    if (System.currentTimeMillis() < startTicks + bindTimeout) {_                        log.warn("Unable to bind to {} - retrying in {} milliseconds", listenAddress.toString(), bindRetryDelay)__                        try {_                            Thread.sleep(bindRetryDelay)__                        } catch (InterruptedException interruptedEx) {_                            log.error("Wait for bind retry was interrupted - rethrowing BindException")__                            throw bindEx__                        }_                    }_                }_            }__            if (0 >= this.listenPort) {_                this.listenPort = serverSocket.getLocalPort()__            }___            log.info("Opened TCP Listener on port {}", serverSocket.getLocalPort())__        };open,the,tcp,listener,throws,ioexception;private,void,bind,throws,ioexception,this,set,daemon,true,server,socket,new,server,socket,server,socket,set,so,timeout,accept,timeout,server,socket,set,reuse,address,true,inet,socket,address,listen,address,if,null,this,listen,host,listen,address,new,inet,socket,address,this,listen,host,this,listen,port,else,listen,address,new,inet,socket,address,this,listen,port,long,start,ticks,system,current,time,millis,while,server,socket,is,bound,try,server,socket,bind,listen,address,backlog,catch,bind,exception,bind,ex,if,system,current,time,millis,start,ticks,bind,timeout,log,warn,unable,to,bind,to,retrying,in,milliseconds,listen,address,to,string,bind,retry,delay,try,thread,sleep,bind,retry,delay,catch,interrupted,exception,interrupted,ex,log,error,wait,for,bind,retry,was,interrupted,rethrowing,bind,exception,throw,bind,ex,if,0,this,listen,port,this,listen,port,server,socket,get,local,port,log,info,opened,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> ServerSocketThread -> private void bind() throws IOException;1480882601;Open the TCP Listener__@throws IOException;private void bind() throws IOException {_            this.setDaemon(true)__            serverSocket = new ServerSocket()___            _            serverSocket.setSoTimeout(acceptTimeout)__            serverSocket.setReuseAddress(true)___            InetSocketAddress listenAddress__            if (null != this.listenHost) {_                listenAddress = new InetSocketAddress(this.listenHost, this.listenPort)__            } else {_                listenAddress = new InetSocketAddress(this.listenPort)__            }__            long startTicks = System.currentTimeMillis()__            while (!serverSocket.isBound()) {_                try {_                    serverSocket.bind(listenAddress, backlog)__                } catch (BindException bindEx) {_                    if (System.currentTimeMillis() < startTicks + bindTimeout) {_                        log.warn("Unable to bind to {} - retrying in {} milliseconds", listenAddress.toString(), bindRetryDelay)__                        try {_                            Thread.sleep(bindRetryDelay)__                        } catch (InterruptedException interruptedEx) {_                            log.error("Wait for bind retry was interrupted - rethrowing BindException")__                            throw bindEx__                        }_                    }_                }_            }__            if (0 >= this.listenPort) {_                this.listenPort = serverSocket.getLocalPort()__            }___            log.info("Opened TCP Listener on port {}", serverSocket.getLocalPort())__        };open,the,tcp,listener,throws,ioexception;private,void,bind,throws,ioexception,this,set,daemon,true,server,socket,new,server,socket,server,socket,set,so,timeout,accept,timeout,server,socket,set,reuse,address,true,inet,socket,address,listen,address,if,null,this,listen,host,listen,address,new,inet,socket,address,this,listen,host,this,listen,port,else,listen,address,new,inet,socket,address,this,listen,port,long,start,ticks,system,current,time,millis,while,server,socket,is,bound,try,server,socket,bind,listen,address,backlog,catch,bind,exception,bind,ex,if,system,current,time,millis,start,ticks,bind,timeout,log,warn,unable,to,bind,to,retrying,in,milliseconds,listen,address,to,string,bind,retry,delay,try,thread,sleep,bind,retry,delay,catch,interrupted,exception,interrupted,ex,log,error,wait,for,bind,retry,was,interrupted,rethrowing,bind,exception,throw,bind,ex,if,0,this,listen,port,this,listen,port,server,socket,get,local,port,log,info,opened,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> ServerSocketThread -> private void bind() throws IOException;1481829620;Open the TCP Listener__@throws IOException;private void bind() throws IOException {_            this.setDaemon(true)__            serverSocket = new ServerSocket()___            _            serverSocket.setSoTimeout(acceptTimeout)__            serverSocket.setReuseAddress(true)___            InetSocketAddress listenAddress__            if (null != this.listenHost) {_                listenAddress = new InetSocketAddress(this.listenHost, this.listenPort)__            } else {_                listenAddress = new InetSocketAddress(this.listenPort)__            }__            long startTicks = System.currentTimeMillis()__            while (!serverSocket.isBound()) {_                try {_                    serverSocket.bind(listenAddress, backlog)__                } catch (BindException bindEx) {_                    if (System.currentTimeMillis() < startTicks + bindTimeout) {_                        log.warn("Unable to bind to {} - retrying in {} milliseconds", listenAddress.toString(), bindRetryDelay)__                        try {_                            Thread.sleep(bindRetryDelay)__                        } catch (InterruptedException interruptedEx) {_                            log.error("Wait for bind retry was interrupted - rethrowing BindException")__                            throw bindEx__                        }_                    }_                }_            }__            if (0 >= this.listenPort) {_                this.listenPort = serverSocket.getLocalPort()__            }___            log.info("Opened TCP Listener on port {}", serverSocket.getLocalPort())__        };open,the,tcp,listener,throws,ioexception;private,void,bind,throws,ioexception,this,set,daemon,true,server,socket,new,server,socket,server,socket,set,so,timeout,accept,timeout,server,socket,set,reuse,address,true,inet,socket,address,listen,address,if,null,this,listen,host,listen,address,new,inet,socket,address,this,listen,host,this,listen,port,else,listen,address,new,inet,socket,address,this,listen,port,long,start,ticks,system,current,time,millis,while,server,socket,is,bound,try,server,socket,bind,listen,address,backlog,catch,bind,exception,bind,ex,if,system,current,time,millis,start,ticks,bind,timeout,log,warn,unable,to,bind,to,retrying,in,milliseconds,listen,address,to,string,bind,retry,delay,try,thread,sleep,bind,retry,delay,catch,interrupted,exception,interrupted,ex,log,error,wait,for,bind,retry,was,interrupted,rethrowing,bind,exception,throw,bind,ex,if,0,this,listen,port,this,listen,port,server,socket,get,local,port,log,info,opened,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> ClientSocketThread -> public String getMessage(InputStream anInputStream) throws IOException;1451464990;Read a MLLP-Framed message__@param anInputStream source input stream_@return the MLLP payload_@throws IOException when the underlying Java Socket calls raise these exceptions;public String getMessage(InputStream anInputStream) throws IOException {_            try {_                _                boolean waitingForStartOfBlock = true__                while (waitingForStartOfBlock) {_                    int potentialStartCharacter = anInputStream.read()__                    switch (potentialStartCharacter) {_                    case END_OF_STREAM:_                        return null__                    case START_OF_BLOCK:_                        waitingForStartOfBlock = false__                        break__                    default:_                        log.warn("START_OF_BLOCK character has not been received.  Out-of-band character received: {}", potentialStartCharacter)__                    }_                }_            } catch (SocketException socketEx) {_                log.error("Unable to read from socket stream when expected bMLLP_ENVELOPE_START_OF_BLOCK - resetting connection ", socketEx)__                resetConnection(clientSocket)__                return null__            }__            boolean endOfMessage = false__            StringBuilder parsedMessage = new StringBuilder(anInputStream.available() + 10)__            while (!endOfMessage) {_                int characterReceived = anInputStream.read()___                switch (characterReceived) {_                case START_OF_BLOCK:_                    log.error("Received START_OF_BLOCK before END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case END_OF_STREAM:_                    log.error("Received END_OF_STREAM without END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case END_OF_BLOCK:_                    characterReceived = anInputStream.read()__                    if (characterReceived != END_OF_DATA) {_                        log.error("Received {} when expecting END_OF_DATA after END_OF_BLOCK.  Discarding Hl7MessageGenerator: {}",_                                characterReceived, parsedMessage.toString())__                        return null__                    }_                    endOfMessage = true__                    break__                default:_                    parsedMessage.append((char) characterReceived)__                }__            }__            return parsedMessage.toString()__        };read,a,mllp,framed,message,param,an,input,stream,source,input,stream,return,the,mllp,payload,throws,ioexception,when,the,underlying,java,socket,calls,raise,these,exceptions;public,string,get,message,input,stream,an,input,stream,throws,ioexception,try,boolean,waiting,for,start,of,block,true,while,waiting,for,start,of,block,int,potential,start,character,an,input,stream,read,switch,potential,start,character,case,return,null,case,waiting,for,start,of,block,false,break,default,log,warn,character,has,not,been,received,out,of,band,character,received,potential,start,character,catch,socket,exception,socket,ex,log,error,unable,to,read,from,socket,stream,when,expected,resetting,connection,socket,ex,reset,connection,client,socket,return,null,boolean,end,of,message,false,string,builder,parsed,message,new,string,builder,an,input,stream,available,10,while,end,of,message,int,character,received,an,input,stream,read,switch,character,received,case,log,error,received,before,discarding,data,parsed,message,to,string,return,null,case,log,error,received,without,discarding,data,parsed,message,to,string,return,null,case,character,received,an,input,stream,read,if,character,received,log,error,received,when,expecting,after,discarding,hl7message,generator,character,received,parsed,message,to,string,return,null,end,of,message,true,break,default,parsed,message,append,char,character,received,return,parsed,message,to,string
MllpServerResource -> ClientSocketThread -> public String getMessage(InputStream anInputStream) throws IOException;1453968697;Read a MLLP-Framed message__@param anInputStream source input stream_@return the MLLP payload_@throws IOException when the underlying Java Socket calls raise these exceptions;public String getMessage(InputStream anInputStream) throws IOException {_            try {_                _                boolean waitingForStartOfBlock = true__                while (waitingForStartOfBlock) {_                    int potentialStartCharacter = anInputStream.read()__                    switch (potentialStartCharacter) {_                    case END_OF_STREAM:_                        return null__                    case START_OF_BLOCK:_                        waitingForStartOfBlock = false__                        break__                    default:_                        log.warn("START_OF_BLOCK character has not been received.  Out-of-band character received: {}", potentialStartCharacter)__                    }_                }_            } catch (SocketException socketEx) {_                if (clientSocket.isClosed()) {_                    log.info("Client socket closed while waiting for MLLP_ENVELOPE_START_OF_BLOCK")__                } else if ( clientSocket.isConnected() ) {_                    log.info( "SocketException encountered while waiting for MLLP_ENVELOPE_START_OF_BLOCK")__                    resetConnection(clientSocket)__                } else {_                    log.error("Unable to read from socket stream when expected bMLLP_ENVELOPE_START_OF_BLOCK - resetting connection ", socketEx)__                    resetConnection(clientSocket)__                }_                return null__            }__            boolean endOfMessage = false__            StringBuilder parsedMessage = new StringBuilder(anInputStream.available() + 10)__            while (!endOfMessage) {_                int characterReceived = anInputStream.read()___                switch (characterReceived) {_                case START_OF_BLOCK:_                    log.error("Received START_OF_BLOCK before END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case END_OF_STREAM:_                    log.error("Received END_OF_STREAM without END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case END_OF_BLOCK:_                    characterReceived = anInputStream.read()__                    if (characterReceived != END_OF_DATA) {_                        log.error("Received {} when expecting END_OF_DATA after END_OF_BLOCK.  Discarding Hl7MessageGenerator: {}",_                                characterReceived, parsedMessage.toString())__                        return null__                    }_                    endOfMessage = true__                    break__                default:_                    parsedMessage.append((char) characterReceived)__                }__            }__            return parsedMessage.toString()__        };read,a,mllp,framed,message,param,an,input,stream,source,input,stream,return,the,mllp,payload,throws,ioexception,when,the,underlying,java,socket,calls,raise,these,exceptions;public,string,get,message,input,stream,an,input,stream,throws,ioexception,try,boolean,waiting,for,start,of,block,true,while,waiting,for,start,of,block,int,potential,start,character,an,input,stream,read,switch,potential,start,character,case,return,null,case,waiting,for,start,of,block,false,break,default,log,warn,character,has,not,been,received,out,of,band,character,received,potential,start,character,catch,socket,exception,socket,ex,if,client,socket,is,closed,log,info,client,socket,closed,while,waiting,for,else,if,client,socket,is,connected,log,info,socket,exception,encountered,while,waiting,for,reset,connection,client,socket,else,log,error,unable,to,read,from,socket,stream,when,expected,resetting,connection,socket,ex,reset,connection,client,socket,return,null,boolean,end,of,message,false,string,builder,parsed,message,new,string,builder,an,input,stream,available,10,while,end,of,message,int,character,received,an,input,stream,read,switch,character,received,case,log,error,received,before,discarding,data,parsed,message,to,string,return,null,case,log,error,received,without,discarding,data,parsed,message,to,string,return,null,case,character,received,an,input,stream,read,if,character,received,log,error,received,when,expecting,after,discarding,hl7message,generator,character,received,parsed,message,to,string,return,null,end,of,message,true,break,default,parsed,message,append,char,character,received,return,parsed,message,to,string
MllpServerResource -> ClientSocketThread -> public String getMessage(InputStream anInputStream) throws IOException;1453968697;Read a MLLP-Framed message__@param anInputStream source input stream_@return the MLLP payload_@throws IOException when the underlying Java Socket calls raise these exceptions;public String getMessage(InputStream anInputStream) throws IOException {_            try {_                _                boolean waitingForStartOfBlock = true__                while (waitingForStartOfBlock) {_                    int potentialStartCharacter = anInputStream.read()__                    switch (potentialStartCharacter) {_                    case END_OF_STREAM:_                        return null__                    case START_OF_BLOCK:_                        waitingForStartOfBlock = false__                        break__                    default:_                        log.warn("START_OF_BLOCK character has not been received.  Out-of-band character received: {}", potentialStartCharacter)__                    }_                }_            } catch (SocketException socketEx) {_                if (clientSocket.isClosed()) {_                    log.info("Client socket closed while waiting for MLLP_ENVELOPE_START_OF_BLOCK")__                } else if ( clientSocket.isConnected() ) {_                    log.info( "SocketException encountered while waiting for MLLP_ENVELOPE_START_OF_BLOCK")__                    resetConnection(clientSocket)__                } else {_                    log.error("Unable to read from socket stream when expected bMLLP_ENVELOPE_START_OF_BLOCK - resetting connection ", socketEx)__                    resetConnection(clientSocket)__                }_                return null__            }__            boolean endOfMessage = false__            StringBuilder parsedMessage = new StringBuilder(anInputStream.available() + 10)__            while (!endOfMessage) {_                int characterReceived = anInputStream.read()___                switch (characterReceived) {_                case START_OF_BLOCK:_                    log.error("Received START_OF_BLOCK before END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case END_OF_STREAM:_                    log.error("Received END_OF_STREAM without END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case END_OF_BLOCK:_                    characterReceived = anInputStream.read()__                    if (characterReceived != END_OF_DATA) {_                        log.error("Received {} when expecting END_OF_DATA after END_OF_BLOCK.  Discarding Hl7MessageGenerator: {}",_                                characterReceived, parsedMessage.toString())__                        return null__                    }_                    endOfMessage = true__                    break__                default:_                    parsedMessage.append((char) characterReceived)__                }__            }__            return parsedMessage.toString()__        };read,a,mllp,framed,message,param,an,input,stream,source,input,stream,return,the,mllp,payload,throws,ioexception,when,the,underlying,java,socket,calls,raise,these,exceptions;public,string,get,message,input,stream,an,input,stream,throws,ioexception,try,boolean,waiting,for,start,of,block,true,while,waiting,for,start,of,block,int,potential,start,character,an,input,stream,read,switch,potential,start,character,case,return,null,case,waiting,for,start,of,block,false,break,default,log,warn,character,has,not,been,received,out,of,band,character,received,potential,start,character,catch,socket,exception,socket,ex,if,client,socket,is,closed,log,info,client,socket,closed,while,waiting,for,else,if,client,socket,is,connected,log,info,socket,exception,encountered,while,waiting,for,reset,connection,client,socket,else,log,error,unable,to,read,from,socket,stream,when,expected,resetting,connection,socket,ex,reset,connection,client,socket,return,null,boolean,end,of,message,false,string,builder,parsed,message,new,string,builder,an,input,stream,available,10,while,end,of,message,int,character,received,an,input,stream,read,switch,character,received,case,log,error,received,before,discarding,data,parsed,message,to,string,return,null,case,log,error,received,without,discarding,data,parsed,message,to,string,return,null,case,character,received,an,input,stream,read,if,character,received,log,error,received,when,expecting,after,discarding,hl7message,generator,character,received,parsed,message,to,string,return,null,end,of,message,true,break,default,parsed,message,append,char,character,received,return,parsed,message,to,string
MllpServerResource -> ClientSocketThread -> public String getMessage(InputStream anInputStream) throws IOException;1457097808;Read a MLLP-Framed message__@param anInputStream source input stream_@return the MLLP payload_@throws IOException when the underlying Java Socket calls raise these exceptions;public String getMessage(InputStream anInputStream) throws IOException {_            try {_                _                boolean waitingForStartOfBlock = true__                while (waitingForStartOfBlock) {_                    int potentialStartCharacter = anInputStream.read()__                    switch (potentialStartCharacter) {_                    case END_OF_STREAM:_                        return null__                    case START_OF_BLOCK:_                        waitingForStartOfBlock = false__                        break__                    default:_                        log.warn("START_OF_BLOCK character has not been received.  Out-of-band character received: {}", potentialStartCharacter)__                    }_                }_            } catch (SocketException socketEx) {_                if (clientSocket.isClosed()) {_                    log.info("Client socket closed while waiting for MLLP_ENVELOPE_START_OF_BLOCK")__                } else if (clientSocket.isConnected()) {_                    log.info("SocketException encountered while waiting for MLLP_ENVELOPE_START_OF_BLOCK")__                    resetConnection(clientSocket)__                } else {_                    log.error("Unable to read from socket stream when expected bMLLP_ENVELOPE_START_OF_BLOCK - resetting connection ", socketEx)__                    resetConnection(clientSocket)__                }_                return null__            }__            boolean endOfMessage = false__            StringBuilder parsedMessage = new StringBuilder(anInputStream.available() + 10)__            while (!endOfMessage) {_                int characterReceived = anInputStream.read()___                switch (characterReceived) {_                case START_OF_BLOCK:_                    log.error("Received START_OF_BLOCK before END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case END_OF_STREAM:_                    log.error("Received END_OF_STREAM without END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case END_OF_BLOCK:_                    characterReceived = anInputStream.read()__                    if (characterReceived != END_OF_DATA) {_                        log.error("Received {} when expecting END_OF_DATA after END_OF_BLOCK.  Discarding Hl7MessageGenerator: {}",_                                characterReceived, parsedMessage.toString())__                        return null__                    }_                    endOfMessage = true__                    break__                default:_                    parsedMessage.append((char) characterReceived)__                }__            }__            return parsedMessage.toString()__        };read,a,mllp,framed,message,param,an,input,stream,source,input,stream,return,the,mllp,payload,throws,ioexception,when,the,underlying,java,socket,calls,raise,these,exceptions;public,string,get,message,input,stream,an,input,stream,throws,ioexception,try,boolean,waiting,for,start,of,block,true,while,waiting,for,start,of,block,int,potential,start,character,an,input,stream,read,switch,potential,start,character,case,return,null,case,waiting,for,start,of,block,false,break,default,log,warn,character,has,not,been,received,out,of,band,character,received,potential,start,character,catch,socket,exception,socket,ex,if,client,socket,is,closed,log,info,client,socket,closed,while,waiting,for,else,if,client,socket,is,connected,log,info,socket,exception,encountered,while,waiting,for,reset,connection,client,socket,else,log,error,unable,to,read,from,socket,stream,when,expected,resetting,connection,socket,ex,reset,connection,client,socket,return,null,boolean,end,of,message,false,string,builder,parsed,message,new,string,builder,an,input,stream,available,10,while,end,of,message,int,character,received,an,input,stream,read,switch,character,received,case,log,error,received,before,discarding,data,parsed,message,to,string,return,null,case,log,error,received,without,discarding,data,parsed,message,to,string,return,null,case,character,received,an,input,stream,read,if,character,received,log,error,received,when,expecting,after,discarding,hl7message,generator,character,received,parsed,message,to,string,return,null,end,of,message,true,break,default,parsed,message,append,char,character,received,return,parsed,message,to,string
MllpServerResource -> ClientSocketThread -> public String getMessage(InputStream anInputStream) throws IOException;1461916938;Read a MLLP-Framed message__@param anInputStream source input stream_@return the MLLP payload_@throws IOException when the underlying Java Socket calls raise these exceptions;public String getMessage(InputStream anInputStream) throws IOException {_            try {_                _                boolean waitingForStartOfBlock = true__                while (waitingForStartOfBlock) {_                    int potentialStartCharacter = anInputStream.read()__                    switch (potentialStartCharacter) {_                    case END_OF_STREAM:_                        return null__                    case START_OF_BLOCK:_                        waitingForStartOfBlock = false__                        break__                    default:_                        log.warn("START_OF_BLOCK character has not been received.  Out-of-band character received: {}", potentialStartCharacter)__                    }_                }_            } catch (SocketException socketEx) {_                if (clientSocket.isClosed()) {_                    log.info("Client socket closed while waiting for MLLP_ENVELOPE_START_OF_BLOCK")__                } else if (clientSocket.isConnected()) {_                    log.info("SocketException encountered while waiting for MLLP_ENVELOPE_START_OF_BLOCK")__                    resetConnection(clientSocket)__                } else {_                    log.error("Unable to read from socket stream when expected bMLLP_ENVELOPE_START_OF_BLOCK - resetting connection ", socketEx)__                    resetConnection(clientSocket)__                }_                return null__            }__            boolean endOfMessage = false__            StringBuilder parsedMessage = new StringBuilder(anInputStream.available() + 10)__            while (!endOfMessage) {_                int characterReceived = anInputStream.read()___                switch (characterReceived) {_                case START_OF_BLOCK:_                    log.error("Received START_OF_BLOCK before END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case END_OF_STREAM:_                    log.error("Received END_OF_STREAM without END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case END_OF_BLOCK:_                    characterReceived = anInputStream.read()__                    if (characterReceived != END_OF_DATA) {_                        log.error("Received {} when expecting END_OF_DATA after END_OF_BLOCK.  Discarding Hl7MessageGenerator: {}",_                                characterReceived, parsedMessage.toString())__                        return null__                    }_                    endOfMessage = true__                    break__                default:_                    parsedMessage.append((char) characterReceived)__                }__            }__            return parsedMessage.toString()__        };read,a,mllp,framed,message,param,an,input,stream,source,input,stream,return,the,mllp,payload,throws,ioexception,when,the,underlying,java,socket,calls,raise,these,exceptions;public,string,get,message,input,stream,an,input,stream,throws,ioexception,try,boolean,waiting,for,start,of,block,true,while,waiting,for,start,of,block,int,potential,start,character,an,input,stream,read,switch,potential,start,character,case,return,null,case,waiting,for,start,of,block,false,break,default,log,warn,character,has,not,been,received,out,of,band,character,received,potential,start,character,catch,socket,exception,socket,ex,if,client,socket,is,closed,log,info,client,socket,closed,while,waiting,for,else,if,client,socket,is,connected,log,info,socket,exception,encountered,while,waiting,for,reset,connection,client,socket,else,log,error,unable,to,read,from,socket,stream,when,expected,resetting,connection,socket,ex,reset,connection,client,socket,return,null,boolean,end,of,message,false,string,builder,parsed,message,new,string,builder,an,input,stream,available,10,while,end,of,message,int,character,received,an,input,stream,read,switch,character,received,case,log,error,received,before,discarding,data,parsed,message,to,string,return,null,case,log,error,received,without,discarding,data,parsed,message,to,string,return,null,case,character,received,an,input,stream,read,if,character,received,log,error,received,when,expecting,after,discarding,hl7message,generator,character,received,parsed,message,to,string,return,null,end,of,message,true,break,default,parsed,message,append,char,character,received,return,parsed,message,to,string
MllpServerResource -> ClientSocketThread -> public String getMessage(InputStream anInputStream) throws IOException;1480882601;Read a MLLP-Framed message__@param anInputStream source input stream_@return the MLLP payload_@throws IOException when the underlying Java Socket calls raise these exceptions;public String getMessage(InputStream anInputStream) throws IOException {_            try {_                _                boolean waitingForStartOfBlock = true__                while (waitingForStartOfBlock) {_                    int potentialStartCharacter = anInputStream.read()__                    switch (potentialStartCharacter) {_                    case END_OF_STREAM:_                        return null__                    case START_OF_BLOCK:_                        waitingForStartOfBlock = false__                        break__                    default:_                        log.warn("START_OF_BLOCK character has not been received.  Out-of-band character received: {}", potentialStartCharacter)__                    }_                }_            } catch (SocketException socketEx) {_                if (clientSocket.isClosed()) {_                    log.info("Client socket closed while waiting for MLLP_ENVELOPE_START_OF_BLOCK")__                } else if (clientSocket.isConnected()) {_                    log.info("SocketException encountered while waiting for MLLP_ENVELOPE_START_OF_BLOCK")__                    resetConnection(clientSocket)__                } else {_                    log.error("Unable to read from socket stream when expected bMLLP_ENVELOPE_START_OF_BLOCK - resetting connection ", socketEx)__                    resetConnection(clientSocket)__                }_                return null__            }__            boolean endOfMessage = false__            StringBuilder parsedMessage = new StringBuilder(anInputStream.available() + 10)__            while (!endOfMessage) {_                int characterReceived = anInputStream.read()___                switch (characterReceived) {_                case START_OF_BLOCK:_                    log.error("Received START_OF_BLOCK before END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case END_OF_STREAM:_                    log.error("Received END_OF_STREAM without END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case END_OF_BLOCK:_                    characterReceived = anInputStream.read()__                    if (characterReceived != END_OF_DATA) {_                        log.error("Received {} when expecting END_OF_DATA after END_OF_BLOCK.  Discarding Hl7MessageGenerator: {}",_                                characterReceived, parsedMessage.toString())__                        return null__                    }_                    endOfMessage = true__                    break__                default:_                    parsedMessage.append((char) characterReceived)__                }__            }__            return parsedMessage.toString()__        };read,a,mllp,framed,message,param,an,input,stream,source,input,stream,return,the,mllp,payload,throws,ioexception,when,the,underlying,java,socket,calls,raise,these,exceptions;public,string,get,message,input,stream,an,input,stream,throws,ioexception,try,boolean,waiting,for,start,of,block,true,while,waiting,for,start,of,block,int,potential,start,character,an,input,stream,read,switch,potential,start,character,case,return,null,case,waiting,for,start,of,block,false,break,default,log,warn,character,has,not,been,received,out,of,band,character,received,potential,start,character,catch,socket,exception,socket,ex,if,client,socket,is,closed,log,info,client,socket,closed,while,waiting,for,else,if,client,socket,is,connected,log,info,socket,exception,encountered,while,waiting,for,reset,connection,client,socket,else,log,error,unable,to,read,from,socket,stream,when,expected,resetting,connection,socket,ex,reset,connection,client,socket,return,null,boolean,end,of,message,false,string,builder,parsed,message,new,string,builder,an,input,stream,available,10,while,end,of,message,int,character,received,an,input,stream,read,switch,character,received,case,log,error,received,before,discarding,data,parsed,message,to,string,return,null,case,log,error,received,without,discarding,data,parsed,message,to,string,return,null,case,character,received,an,input,stream,read,if,character,received,log,error,received,when,expecting,after,discarding,hl7message,generator,character,received,parsed,message,to,string,return,null,end,of,message,true,break,default,parsed,message,append,char,character,received,return,parsed,message,to,string
MllpServerResource -> ClientSocketThread -> public String getMessage(InputStream anInputStream) throws IOException;1481829620;Read a MLLP-Framed message__@param anInputStream source input stream_@return the MLLP payload_@throws IOException when the underlying Java Socket calls raise these exceptions;public String getMessage(InputStream anInputStream) throws IOException {_            try {_                boolean waitingForStartOfBlock = true__                while (waitingForStartOfBlock) {_                    int potentialStartCharacter = anInputStream.read()__                    switch (potentialStartCharacter) {_                    case END_OF_STREAM:_                        return null__                    case START_OF_BLOCK:_                        waitingForStartOfBlock = false__                        break__                    default:_                        log.warn("START_OF_BLOCK character has not been received.  Out-of-band character received: {}", potentialStartCharacter)__                    }_                }_            } catch (SocketException socketEx) {_                if (clientSocket != null) {_                    if (clientSocket.isClosed()) {_                        log.info("Client socket closed while waiting for MLLP_ENVELOPE_START_OF_BLOCK")__                    } else if (clientSocket.isConnected()) {_                        log.info("SocketException encountered while waiting for MLLP_ENVELOPE_START_OF_BLOCK")__                        resetConnection()__                    } else {_                        log.error("Unable to read from socket stream when expected bMLLP_ENVELOPE_START_OF_BLOCK - resetting connection ", socketEx)__                        resetConnection()__                    }_                }_                return null__            }__            boolean endOfMessage = false__            StringBuilder parsedMessage = new StringBuilder(anInputStream.available() + 10)__            while (!endOfMessage) {_                int characterReceived = anInputStream.read()___                switch (characterReceived) {_                case START_OF_BLOCK:_                    log.error("Received START_OF_BLOCK before END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case END_OF_STREAM:_                    log.error("Received END_OF_STREAM without END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case END_OF_BLOCK:_                    characterReceived = anInputStream.read()__                    if (characterReceived != END_OF_DATA) {_                        log.error("Received {} when expecting END_OF_DATA after END_OF_BLOCK.  Discarding Hl7MessageGenerator: {}",_                                characterReceived, parsedMessage.toString())__                        return null__                    }_                    endOfMessage = true__                    break__                default:_                    parsedMessage.append((char) characterReceived)__                }__            }__            return parsedMessage.toString()__        };read,a,mllp,framed,message,param,an,input,stream,source,input,stream,return,the,mllp,payload,throws,ioexception,when,the,underlying,java,socket,calls,raise,these,exceptions;public,string,get,message,input,stream,an,input,stream,throws,ioexception,try,boolean,waiting,for,start,of,block,true,while,waiting,for,start,of,block,int,potential,start,character,an,input,stream,read,switch,potential,start,character,case,return,null,case,waiting,for,start,of,block,false,break,default,log,warn,character,has,not,been,received,out,of,band,character,received,potential,start,character,catch,socket,exception,socket,ex,if,client,socket,null,if,client,socket,is,closed,log,info,client,socket,closed,while,waiting,for,else,if,client,socket,is,connected,log,info,socket,exception,encountered,while,waiting,for,reset,connection,else,log,error,unable,to,read,from,socket,stream,when,expected,resetting,connection,socket,ex,reset,connection,return,null,boolean,end,of,message,false,string,builder,parsed,message,new,string,builder,an,input,stream,available,10,while,end,of,message,int,character,received,an,input,stream,read,switch,character,received,case,log,error,received,before,discarding,data,parsed,message,to,string,return,null,case,log,error,received,without,discarding,data,parsed,message,to,string,return,null,case,character,received,an,input,stream,read,if,character,received,log,error,received,when,expecting,after,discarding,hl7message,generator,character,received,parsed,message,to,string,return,null,end,of,message,true,break,default,parsed,message,append,char,character,received,return,parsed,message,to,string
MllpServerResource -> ClientSocketThread -> public String getMessage(InputStream anInputStream) throws IOException;1515779403;Read a MLLP-Framed message__@param anInputStream source input stream__@return the MLLP payload__@throws IOException when the underlying Java Socket calls raise these exceptions;public String getMessage(InputStream anInputStream) throws IOException {_            try {_                boolean waitingForStartOfBlock = true__                while (waitingForStartOfBlock) {_                    int potentialStartCharacter = anInputStream.read()__                    switch (potentialStartCharacter) {_                    case MllpProtocolConstants.END_OF_STREAM:_                        return null__                    case MllpProtocolConstants.START_OF_BLOCK:_                        waitingForStartOfBlock = false__                        break__                    default:_                        log.warn("START_OF_BLOCK character has not been received.  Out-of-band character received: {}", potentialStartCharacter)__                    }_                }_            } catch (SocketException socketEx) {_                if (clientSocket != null) {_                    if (clientSocket.isClosed()) {_                        log.info("Client socket closed while waiting for START_OF_BLOCK")__                    } else if (clientSocket.isConnected()) {_                        log.info("SocketException encountered while waiting for START_OF_BLOCK")__                        resetConnection()__                    } else {_                        log.error("Unable to read from socket stream when expected START_OF_BLOCK - resetting connection ", socketEx)__                        resetConnection()__                    }_                }_                return null__            }__            boolean endOfMessage = false__            StringBuilder parsedMessage = new StringBuilder(anInputStream.available() + 10)__            while (!endOfMessage) {_                int characterReceived = anInputStream.read()___                switch (characterReceived) {_                case MllpProtocolConstants.START_OF_BLOCK:_                    log.error("Received START_OF_BLOCK before END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case MllpProtocolConstants.END_OF_STREAM:_                    log.error("Received END_OF_STREAM without END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case MllpProtocolConstants.END_OF_BLOCK:_                    characterReceived = anInputStream.read()__                    if (characterReceived != MllpProtocolConstants.END_OF_DATA) {_                        log.error("Received {} when expecting END_OF_DATA after END_OF_BLOCK.  Discarding Hl7TestMessageGenerator: {}",_                            characterReceived, parsedMessage.toString())__                        return null__                    }_                    endOfMessage = true__                    break__                default:_                    parsedMessage.append((char) characterReceived)__                }__            }__            return parsedMessage.toString()__        };read,a,mllp,framed,message,param,an,input,stream,source,input,stream,return,the,mllp,payload,throws,ioexception,when,the,underlying,java,socket,calls,raise,these,exceptions;public,string,get,message,input,stream,an,input,stream,throws,ioexception,try,boolean,waiting,for,start,of,block,true,while,waiting,for,start,of,block,int,potential,start,character,an,input,stream,read,switch,potential,start,character,case,mllp,protocol,constants,return,null,case,mllp,protocol,constants,waiting,for,start,of,block,false,break,default,log,warn,character,has,not,been,received,out,of,band,character,received,potential,start,character,catch,socket,exception,socket,ex,if,client,socket,null,if,client,socket,is,closed,log,info,client,socket,closed,while,waiting,for,else,if,client,socket,is,connected,log,info,socket,exception,encountered,while,waiting,for,reset,connection,else,log,error,unable,to,read,from,socket,stream,when,expected,resetting,connection,socket,ex,reset,connection,return,null,boolean,end,of,message,false,string,builder,parsed,message,new,string,builder,an,input,stream,available,10,while,end,of,message,int,character,received,an,input,stream,read,switch,character,received,case,mllp,protocol,constants,log,error,received,before,discarding,data,parsed,message,to,string,return,null,case,mllp,protocol,constants,log,error,received,without,discarding,data,parsed,message,to,string,return,null,case,mllp,protocol,constants,character,received,an,input,stream,read,if,character,received,mllp,protocol,constants,log,error,received,when,expecting,after,discarding,hl7test,message,generator,character,received,parsed,message,to,string,return,null,end,of,message,true,break,default,parsed,message,append,char,character,received,return,parsed,message,to,string
MllpServerResource -> ClientSocketThread -> public String getMessage(InputStream anInputStream) throws IOException;1524063106;Read a MLLP-Framed message__@param anInputStream source input stream__@return the MLLP payload__@throws IOException when the underlying Java Socket calls raise these exceptions;public String getMessage(InputStream anInputStream) throws IOException {_            try {_                boolean waitingForStartOfBlock = true__                while (waitingForStartOfBlock) {_                    int potentialStartCharacter = anInputStream.read()__                    switch (potentialStartCharacter) {_                    case MllpProtocolConstants.END_OF_STREAM:_                        return null__                    case MllpProtocolConstants.START_OF_BLOCK:_                        waitingForStartOfBlock = false__                        break__                    default:_                        log.warn("START_OF_BLOCK character has not been received.  Out-of-band character received: {}", potentialStartCharacter)__                    }_                }_            } catch (SocketException socketEx) {_                if (clientSocket != null) {_                    if (clientSocket.isClosed()) {_                        log.info("Client socket closed while waiting for START_OF_BLOCK")__                    } else if (clientSocket.isConnected()) {_                        log.info("SocketException encountered while waiting for START_OF_BLOCK")__                        resetConnection()__                    } else {_                        log.error("Unable to read from socket stream when expected START_OF_BLOCK - resetting connection ", socketEx)__                        resetConnection()__                    }_                }_                return null__            }__            boolean endOfMessage = false__            StringBuilder parsedMessage = new StringBuilder(anInputStream.available() + 10)__            while (!endOfMessage) {_                int characterReceived = anInputStream.read()___                switch (characterReceived) {_                case MllpProtocolConstants.START_OF_BLOCK:_                    log.error("Received START_OF_BLOCK before END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case MllpProtocolConstants.END_OF_STREAM:_                    log.error("Received END_OF_STREAM without END_OF_DATA.  Discarding data: {}", parsedMessage.toString())__                    return null__                case MllpProtocolConstants.END_OF_BLOCK:_                    characterReceived = anInputStream.read()__                    if (characterReceived != MllpProtocolConstants.END_OF_DATA) {_                        log.error("Received {} when expecting END_OF_DATA after END_OF_BLOCK.  Discarding Hl7TestMessageGenerator: {}",_                            characterReceived, parsedMessage.toString())__                        return null__                    }_                    endOfMessage = true__                    break__                default:_                    parsedMessage.append((char) characterReceived)__                }__            }__            return parsedMessage.toString()__        };read,a,mllp,framed,message,param,an,input,stream,source,input,stream,return,the,mllp,payload,throws,ioexception,when,the,underlying,java,socket,calls,raise,these,exceptions;public,string,get,message,input,stream,an,input,stream,throws,ioexception,try,boolean,waiting,for,start,of,block,true,while,waiting,for,start,of,block,int,potential,start,character,an,input,stream,read,switch,potential,start,character,case,mllp,protocol,constants,return,null,case,mllp,protocol,constants,waiting,for,start,of,block,false,break,default,log,warn,character,has,not,been,received,out,of,band,character,received,potential,start,character,catch,socket,exception,socket,ex,if,client,socket,null,if,client,socket,is,closed,log,info,client,socket,closed,while,waiting,for,else,if,client,socket,is,connected,log,info,socket,exception,encountered,while,waiting,for,reset,connection,else,log,error,unable,to,read,from,socket,stream,when,expected,resetting,connection,socket,ex,reset,connection,return,null,boolean,end,of,message,false,string,builder,parsed,message,new,string,builder,an,input,stream,available,10,while,end,of,message,int,character,received,an,input,stream,read,switch,character,received,case,mllp,protocol,constants,log,error,received,before,discarding,data,parsed,message,to,string,return,null,case,mllp,protocol,constants,log,error,received,without,discarding,data,parsed,message,to,string,return,null,case,mllp,protocol,constants,character,received,an,input,stream,read,if,character,received,mllp,protocol,constants,log,error,received,when,expecting,after,discarding,hl7test,message,generator,character,received,parsed,message,to,string,return,null,end,of,message,true,break,default,parsed,message,append,char,character,received,return,parsed,message,to,string
MllpServerResource -> ClientSocketThread -> public String getMessage(InputStream anInputStream) throws IOException;1536605520;Read a MLLP-Framed message__@param anInputStream source input stream__@return the MLLP payload__@throws IOException when the underlying Java Socket calls raise these exceptions;public String getMessage(InputStream anInputStream) throws IOException {_            try {_                boolean waitingForStartOfBlock = true__                while (waitingForStartOfBlock) {_                    int potentialStartCharacter = anInputStream.read()__                    switch (potentialStartCharacter) {_                    case MllpProtocolConstants.END_OF_STREAM:_                        return null__                    case MllpProtocolConstants.START_OF_BLOCK:_                        waitingForStartOfBlock = false__                        break__                    default:_                        log.warn("START_OF_BLOCK character has not been received.  Out-of-band character received: {}", potentialStartCharacter)__                    }_                }_            } catch (SocketException socketEx) {_                if (clientSocket != null) {_                    if (clientSocket.isClosed()) {_                        log.info("Client socket closed while waiting for START_OF_BLOCK")__                    } else if (clientSocket.isConnected()) {_                        log.info("SocketException encountered while waiting for START_OF_BLOCK")__                        resetConnection()__                    } else {_                        log.error("Unable to read from socket stream when expected START_OF_BLOCK - resetting connection ", socketEx)__                        resetConnection()__                    }_                }_                return null__            }__            boolean endOfMessage = false__            StringBuilder parsedMessage = new StringBuilder(anInputStream.available() + 10)__            while (!endOfMessage) {_                int characterReceived = anInputStream.read()___                switch (characterReceived) {_                case MllpProtocolConstants.START_OF_BLOCK:_                    log.error("Received START_OF_BLOCK before END_OF_DATA.  Discarding data: {}", parsedMessage)__                    return null__                case MllpProtocolConstants.END_OF_STREAM:_                    log.error("Received END_OF_STREAM without END_OF_DATA.  Discarding data: {}", parsedMessage)__                    return null__                case MllpProtocolConstants.END_OF_BLOCK:_                    characterReceived = anInputStream.read()__                    if (characterReceived != MllpProtocolConstants.END_OF_DATA) {_                        log.error("Received {} when expecting END_OF_DATA after END_OF_BLOCK.  Discarding Hl7TestMessageGenerator: {}",_                            characterReceived, parsedMessage.toString())__                        return null__                    }_                    endOfMessage = true__                    break__                default:_                    parsedMessage.append((char) characterReceived)__                }__            }__            return parsedMessage.toString()__        };read,a,mllp,framed,message,param,an,input,stream,source,input,stream,return,the,mllp,payload,throws,ioexception,when,the,underlying,java,socket,calls,raise,these,exceptions;public,string,get,message,input,stream,an,input,stream,throws,ioexception,try,boolean,waiting,for,start,of,block,true,while,waiting,for,start,of,block,int,potential,start,character,an,input,stream,read,switch,potential,start,character,case,mllp,protocol,constants,return,null,case,mllp,protocol,constants,waiting,for,start,of,block,false,break,default,log,warn,character,has,not,been,received,out,of,band,character,received,potential,start,character,catch,socket,exception,socket,ex,if,client,socket,null,if,client,socket,is,closed,log,info,client,socket,closed,while,waiting,for,else,if,client,socket,is,connected,log,info,socket,exception,encountered,while,waiting,for,reset,connection,else,log,error,unable,to,read,from,socket,stream,when,expected,resetting,connection,socket,ex,reset,connection,return,null,boolean,end,of,message,false,string,builder,parsed,message,new,string,builder,an,input,stream,available,10,while,end,of,message,int,character,received,an,input,stream,read,switch,character,received,case,mllp,protocol,constants,log,error,received,before,discarding,data,parsed,message,return,null,case,mllp,protocol,constants,log,error,received,without,discarding,data,parsed,message,return,null,case,mllp,protocol,constants,character,received,an,input,stream,read,if,character,received,mllp,protocol,constants,log,error,received,when,expecting,after,discarding,hl7test,message,generator,character,received,parsed,message,to,string,return,null,end,of,message,true,break,default,parsed,message,append,char,character,received,return,parsed,message,to,string
MllpServerResource -> ServerSocketThread -> public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout);1451464990;Enable/Disable the generation of MllpJUnitResourceTimeoutException if the ServerSocket.accept()_call raises a SocketTimeoutException.__@param raiseExceptionOnAcceptTimeout true enables exceptions on an accept timeout;public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout) {_            this.raiseExceptionOnAcceptTimeout = raiseExceptionOnAcceptTimeout__        };enable,disable,the,generation,of,mllp,junit,resource,timeout,exception,if,the,server,socket,accept,call,raises,a,socket,timeout,exception,param,raise,exception,on,accept,timeout,true,enables,exceptions,on,an,accept,timeout;public,void,set,raise,exception,on,accept,timeout,boolean,raise,exception,on,accept,timeout,this,raise,exception,on,accept,timeout,raise,exception,on,accept,timeout
MllpServerResource -> ServerSocketThread -> public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout);1453968697;Enable/Disable the generation of MllpJUnitResourceTimeoutException if the ServerSocket.accept()_call raises a SocketTimeoutException.__@param raiseExceptionOnAcceptTimeout true enables exceptions on an accept timeout;public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout) {_            this.raiseExceptionOnAcceptTimeout = raiseExceptionOnAcceptTimeout__        };enable,disable,the,generation,of,mllp,junit,resource,timeout,exception,if,the,server,socket,accept,call,raises,a,socket,timeout,exception,param,raise,exception,on,accept,timeout,true,enables,exceptions,on,an,accept,timeout;public,void,set,raise,exception,on,accept,timeout,boolean,raise,exception,on,accept,timeout,this,raise,exception,on,accept,timeout,raise,exception,on,accept,timeout
MllpServerResource -> ServerSocketThread -> public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout);1453968697;Enable/Disable the generation of MllpJUnitResourceTimeoutException if the ServerSocket.accept()_call raises a SocketTimeoutException.__@param raiseExceptionOnAcceptTimeout true enables exceptions on an accept timeout;public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout) {_            this.raiseExceptionOnAcceptTimeout = raiseExceptionOnAcceptTimeout__        };enable,disable,the,generation,of,mllp,junit,resource,timeout,exception,if,the,server,socket,accept,call,raises,a,socket,timeout,exception,param,raise,exception,on,accept,timeout,true,enables,exceptions,on,an,accept,timeout;public,void,set,raise,exception,on,accept,timeout,boolean,raise,exception,on,accept,timeout,this,raise,exception,on,accept,timeout,raise,exception,on,accept,timeout
MllpServerResource -> ServerSocketThread -> public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout);1457097808;Enable/Disable the generation of MllpJUnitResourceTimeoutException if the ServerSocket.accept()_call raises a SocketTimeoutException.__@param raiseExceptionOnAcceptTimeout true enables exceptions on an accept timeout;public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout) {_            this.raiseExceptionOnAcceptTimeout = raiseExceptionOnAcceptTimeout__        };enable,disable,the,generation,of,mllp,junit,resource,timeout,exception,if,the,server,socket,accept,call,raises,a,socket,timeout,exception,param,raise,exception,on,accept,timeout,true,enables,exceptions,on,an,accept,timeout;public,void,set,raise,exception,on,accept,timeout,boolean,raise,exception,on,accept,timeout,this,raise,exception,on,accept,timeout,raise,exception,on,accept,timeout
MllpServerResource -> ServerSocketThread -> public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout);1461916938;Enable/Disable the generation of MllpJUnitResourceTimeoutException if the ServerSocket.accept()_call raises a SocketTimeoutException.__@param raiseExceptionOnAcceptTimeout true enables exceptions on an accept timeout;public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout) {_            this.raiseExceptionOnAcceptTimeout = raiseExceptionOnAcceptTimeout__        };enable,disable,the,generation,of,mllp,junit,resource,timeout,exception,if,the,server,socket,accept,call,raises,a,socket,timeout,exception,param,raise,exception,on,accept,timeout,true,enables,exceptions,on,an,accept,timeout;public,void,set,raise,exception,on,accept,timeout,boolean,raise,exception,on,accept,timeout,this,raise,exception,on,accept,timeout,raise,exception,on,accept,timeout
MllpServerResource -> ServerSocketThread -> public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout);1480882601;Enable/Disable the generation of MllpJUnitResourceTimeoutException if the ServerSocket.accept()_call raises a SocketTimeoutException.__@param raiseExceptionOnAcceptTimeout true enables exceptions on an accept timeout;public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout) {_            this.raiseExceptionOnAcceptTimeout = raiseExceptionOnAcceptTimeout__        };enable,disable,the,generation,of,mllp,junit,resource,timeout,exception,if,the,server,socket,accept,call,raises,a,socket,timeout,exception,param,raise,exception,on,accept,timeout,true,enables,exceptions,on,an,accept,timeout;public,void,set,raise,exception,on,accept,timeout,boolean,raise,exception,on,accept,timeout,this,raise,exception,on,accept,timeout,raise,exception,on,accept,timeout
MllpServerResource -> ServerSocketThread -> public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout);1481829620;Enable/Disable the generation of MllpJUnitResourceTimeoutException if the ServerSocket.accept()_call raises a SocketTimeoutException.__@param raiseExceptionOnAcceptTimeout true enables exceptions on an accept timeout;public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout) {_            this.raiseExceptionOnAcceptTimeout = raiseExceptionOnAcceptTimeout__        };enable,disable,the,generation,of,mllp,junit,resource,timeout,exception,if,the,server,socket,accept,call,raises,a,socket,timeout,exception,param,raise,exception,on,accept,timeout,true,enables,exceptions,on,an,accept,timeout;public,void,set,raise,exception,on,accept,timeout,boolean,raise,exception,on,accept,timeout,this,raise,exception,on,accept,timeout,raise,exception,on,accept,timeout
MllpServerResource -> ServerSocketThread -> public void run();1451464990;Accept TCP connections and create ClientSocketThreads for them;public void run() {_            log.info("Accepting connections on port {}", serverSocket.getLocalPort())__            this.setName("MllpServerResource$ServerSocketThread - " + serverSocket.getLocalSocketAddress().toString())__            while (isActive() && serverSocket.isBound()) {_                Socket clientSocket = null__                try {_                    clientSocket = serverSocket.accept()__                    clientSocket.setKeepAlive(true)__                    clientSocket.setTcpNoDelay(false)__                    clientSocket.setSoLinger(false, -1)__                    clientSocket.setSoTimeout(5000)__                    ClientSocketThread clientSocketThread = new ClientSocketThread(clientSocket)__                    clientSocketThread.setDaemon(true)__                    clientSocketThread.start()__                } catch (SocketTimeoutException timeoutEx) {_                    if (raiseExceptionOnAcceptTimeout) {_                        throw new MllpJUnitResourceTimeoutException("Timeout Accepting client connection", timeoutEx)__                    }_                    continue__                } catch (IOException e) {_                    log.warn("IOException creating Client Socket")__                    try {_                        clientSocket.close()__                    } catch (IOException e1) {_                        log.warn("Exceptiong encountered closing client socket after attempting to accept connection")__                    }_                    throw new MllpJUnitResourceException("IOException creating Socket", e)__                }_            }_            log.info("No longer accepting connections - closing TCP Listener on port {}", serverSocket.getLocalPort())__            try {_                serverSocket.close()__            } catch (IOException e) {_                e.printStackTrace()__            }_            log.info("Closed TCP Listener on port {}", serverSocket.getLocalPort())__        };accept,tcp,connections,and,create,client,socket,threads,for,them;public,void,run,log,info,accepting,connections,on,port,server,socket,get,local,port,this,set,name,mllp,server,resource,server,socket,thread,server,socket,get,local,socket,address,to,string,while,is,active,server,socket,is,bound,socket,client,socket,null,try,client,socket,server,socket,accept,client,socket,set,keep,alive,true,client,socket,set,tcp,no,delay,false,client,socket,set,so,linger,false,1,client,socket,set,so,timeout,5000,client,socket,thread,client,socket,thread,new,client,socket,thread,client,socket,client,socket,thread,set,daemon,true,client,socket,thread,start,catch,socket,timeout,exception,timeout,ex,if,raise,exception,on,accept,timeout,throw,new,mllp,junit,resource,timeout,exception,timeout,accepting,client,connection,timeout,ex,continue,catch,ioexception,e,log,warn,ioexception,creating,client,socket,try,client,socket,close,catch,ioexception,e1,log,warn,exceptiong,encountered,closing,client,socket,after,attempting,to,accept,connection,throw,new,mllp,junit,resource,exception,ioexception,creating,socket,e,log,info,no,longer,accepting,connections,closing,tcp,listener,on,port,server,socket,get,local,port,try,server,socket,close,catch,ioexception,e,e,print,stack,trace,log,info,closed,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> ServerSocketThread -> public void run();1453968697;Accept TCP connections and create ClientSocketThreads for them;public void run() {_            log.info("Accepting connections on port {}", serverSocket.getLocalPort())__            this.setName("MllpServerResource$ServerSocketThread - " + serverSocket.getLocalSocketAddress().toString())__            while (!isInterrupted()  &&  serverSocket.isBound()  && !serverSocket.isClosed()) {_                Socket clientSocket = null__                try {_                    clientSocket = serverSocket.accept()__                } catch (SocketTimeoutException timeoutEx) {_                    if (raiseExceptionOnAcceptTimeout) {_                        throw new MllpJUnitResourceTimeoutException("Timeout Accepting client connection", timeoutEx)__                    }_                    log.warn("Timeout waiting for client connection")__                } catch (SocketException socketEx) {_                    log.debug("SocketException encountered accepting client connection - ignoring", socketEx)__                    if (null == clientSocket) {_                        continue__                    } else if (!clientSocket.isClosed()) {_                        resetConnection(clientSocket)__                        continue__                    } else {_                        throw new MllpJUnitResourceException("Unexpected SocketException encountered accepting client connection", socketEx)__                    }_                } catch (Exception ex) {_                    throw new MllpJUnitResourceException("Unexpected exception encountered accepting client connection", ex)__                }_                if (null != clientSocket) {_                    try {_                        clientSocket.setKeepAlive(true)__                        clientSocket.setTcpNoDelay(false)__                        clientSocket.setSoLinger(false, -1)__                        clientSocket.setSoTimeout(5000)__                        ClientSocketThread clientSocketThread = new ClientSocketThread(clientSocket)__                        clientSocketThread.setDaemon(true)__                        clientSocketThread.start()__                        clientSocketThreads.add(clientSocketThread)__                    } catch (Exception unexpectedEx) {_                        log.warn("Unexpected exception encountered configuring client socket")__                            try {_                                clientSocket.close()__                            } catch (IOException ingoreEx) {_                                log.warn("Exceptiong encountered closing client socket after attempting to accept connection", ingoreEx)__                            }_                        throw new MllpJUnitResourceException("Unexpected exception encountered configuring client socket", unexpectedEx)__                    }_                }_            }_            log.info("No longer accepting connections - closing TCP Listener on port {}", serverSocket.getLocalPort())__            try {_                serverSocket.close()__            } catch (IOException e) {_                e.printStackTrace()__            }_            log.info("Closed TCP Listener on port {}", serverSocket.getLocalPort())__        };accept,tcp,connections,and,create,client,socket,threads,for,them;public,void,run,log,info,accepting,connections,on,port,server,socket,get,local,port,this,set,name,mllp,server,resource,server,socket,thread,server,socket,get,local,socket,address,to,string,while,is,interrupted,server,socket,is,bound,server,socket,is,closed,socket,client,socket,null,try,client,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,if,raise,exception,on,accept,timeout,throw,new,mllp,junit,resource,timeout,exception,timeout,accepting,client,connection,timeout,ex,log,warn,timeout,waiting,for,client,connection,catch,socket,exception,socket,ex,log,debug,socket,exception,encountered,accepting,client,connection,ignoring,socket,ex,if,null,client,socket,continue,else,if,client,socket,is,closed,reset,connection,client,socket,continue,else,throw,new,mllp,junit,resource,exception,unexpected,socket,exception,encountered,accepting,client,connection,socket,ex,catch,exception,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,accepting,client,connection,ex,if,null,client,socket,try,client,socket,set,keep,alive,true,client,socket,set,tcp,no,delay,false,client,socket,set,so,linger,false,1,client,socket,set,so,timeout,5000,client,socket,thread,client,socket,thread,new,client,socket,thread,client,socket,client,socket,thread,set,daemon,true,client,socket,thread,start,client,socket,threads,add,client,socket,thread,catch,exception,unexpected,ex,log,warn,unexpected,exception,encountered,configuring,client,socket,try,client,socket,close,catch,ioexception,ingore,ex,log,warn,exceptiong,encountered,closing,client,socket,after,attempting,to,accept,connection,ingore,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,configuring,client,socket,unexpected,ex,log,info,no,longer,accepting,connections,closing,tcp,listener,on,port,server,socket,get,local,port,try,server,socket,close,catch,ioexception,e,e,print,stack,trace,log,info,closed,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> ServerSocketThread -> public void run();1453968697;Accept TCP connections and create ClientSocketThreads for them;public void run() {_            log.info("Accepting connections on port {}", serverSocket.getLocalPort())__            this.setName("MllpServerResource$ServerSocketThread - " + serverSocket.getLocalSocketAddress().toString())__            while (!isInterrupted()  &&  serverSocket.isBound()  && !serverSocket.isClosed()) {_                Socket clientSocket = null__                try {_                    clientSocket = serverSocket.accept()__                } catch (SocketTimeoutException timeoutEx) {_                    if (raiseExceptionOnAcceptTimeout) {_                        throw new MllpJUnitResourceTimeoutException("Timeout Accepting client connection", timeoutEx)__                    }_                    log.warn("Timeout waiting for client connection")__                } catch (SocketException socketEx) {_                    log.debug("SocketException encountered accepting client connection - ignoring", socketEx)__                    if (null == clientSocket) {_                        continue__                    } else if (!clientSocket.isClosed()) {_                        resetConnection(clientSocket)__                        continue__                    } else {_                        throw new MllpJUnitResourceException("Unexpected SocketException encountered accepting client connection", socketEx)__                    }_                } catch (Exception ex) {_                    throw new MllpJUnitResourceException("Unexpected exception encountered accepting client connection", ex)__                }_                if (null != clientSocket) {_                    try {_                        clientSocket.setKeepAlive(true)__                        clientSocket.setTcpNoDelay(false)__                        clientSocket.setSoLinger(false, -1)__                        clientSocket.setSoTimeout(5000)__                        ClientSocketThread clientSocketThread = new ClientSocketThread(clientSocket)__                        clientSocketThread.setDaemon(true)__                        clientSocketThread.start()__                        clientSocketThreads.add(clientSocketThread)__                    } catch (Exception unexpectedEx) {_                        log.warn("Unexpected exception encountered configuring client socket")__                            try {_                                clientSocket.close()__                            } catch (IOException ingoreEx) {_                                log.warn("Exceptiong encountered closing client socket after attempting to accept connection", ingoreEx)__                            }_                        throw new MllpJUnitResourceException("Unexpected exception encountered configuring client socket", unexpectedEx)__                    }_                }_            }_            log.info("No longer accepting connections - closing TCP Listener on port {}", serverSocket.getLocalPort())__            try {_                serverSocket.close()__            } catch (IOException e) {_                e.printStackTrace()__            }_            log.info("Closed TCP Listener on port {}", serverSocket.getLocalPort())__        };accept,tcp,connections,and,create,client,socket,threads,for,them;public,void,run,log,info,accepting,connections,on,port,server,socket,get,local,port,this,set,name,mllp,server,resource,server,socket,thread,server,socket,get,local,socket,address,to,string,while,is,interrupted,server,socket,is,bound,server,socket,is,closed,socket,client,socket,null,try,client,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,if,raise,exception,on,accept,timeout,throw,new,mllp,junit,resource,timeout,exception,timeout,accepting,client,connection,timeout,ex,log,warn,timeout,waiting,for,client,connection,catch,socket,exception,socket,ex,log,debug,socket,exception,encountered,accepting,client,connection,ignoring,socket,ex,if,null,client,socket,continue,else,if,client,socket,is,closed,reset,connection,client,socket,continue,else,throw,new,mllp,junit,resource,exception,unexpected,socket,exception,encountered,accepting,client,connection,socket,ex,catch,exception,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,accepting,client,connection,ex,if,null,client,socket,try,client,socket,set,keep,alive,true,client,socket,set,tcp,no,delay,false,client,socket,set,so,linger,false,1,client,socket,set,so,timeout,5000,client,socket,thread,client,socket,thread,new,client,socket,thread,client,socket,client,socket,thread,set,daemon,true,client,socket,thread,start,client,socket,threads,add,client,socket,thread,catch,exception,unexpected,ex,log,warn,unexpected,exception,encountered,configuring,client,socket,try,client,socket,close,catch,ioexception,ingore,ex,log,warn,exceptiong,encountered,closing,client,socket,after,attempting,to,accept,connection,ingore,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,configuring,client,socket,unexpected,ex,log,info,no,longer,accepting,connections,closing,tcp,listener,on,port,server,socket,get,local,port,try,server,socket,close,catch,ioexception,e,e,print,stack,trace,log,info,closed,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> ServerSocketThread -> public void run();1457097808;Accept TCP connections and create ClientSocketThreads for them;public void run() {_            log.info("Accepting connections on port {}", serverSocket.getLocalPort())__            this.setName("MllpServerResource$ServerSocketThread - " + serverSocket.getLocalSocketAddress().toString())__            while (!isInterrupted() && serverSocket.isBound() && !serverSocket.isClosed()) {_                Socket clientSocket = null__                try {_                    clientSocket = serverSocket.accept()__                } catch (SocketTimeoutException timeoutEx) {_                    if (raiseExceptionOnAcceptTimeout) {_                        throw new MllpJUnitResourceTimeoutException("Timeout Accepting client connection", timeoutEx)__                    }_                    log.warn("Timeout waiting for client connection")__                } catch (SocketException socketEx) {_                    log.debug("SocketException encountered accepting client connection - ignoring", socketEx)__                    if (null == clientSocket) {_                        continue__                    } else if (!clientSocket.isClosed()) {_                        resetConnection(clientSocket)__                        continue__                    } else {_                        throw new MllpJUnitResourceException("Unexpected SocketException encountered accepting client connection", socketEx)__                    }_                } catch (Exception ex) {_                    throw new MllpJUnitResourceException("Unexpected exception encountered accepting client connection", ex)__                }_                if (null != clientSocket) {_                    try {_                        clientSocket.setKeepAlive(true)__                        clientSocket.setTcpNoDelay(false)__                        clientSocket.setSoLinger(false, -1)__                        clientSocket.setSoTimeout(5000)__                        ClientSocketThread clientSocketThread = new ClientSocketThread(clientSocket)__                        clientSocketThread.setDaemon(true)__                        clientSocketThread.start()__                        clientSocketThreads.add(clientSocketThread)__                    } catch (Exception unexpectedEx) {_                        log.warn("Unexpected exception encountered configuring client socket")__                        try {_                            clientSocket.close()__                        } catch (IOException ingoreEx) {_                            log.warn("Exceptiong encountered closing client socket after attempting to accept connection", ingoreEx)__                        }_                        throw new MllpJUnitResourceException("Unexpected exception encountered configuring client socket", unexpectedEx)__                    }_                }_            }_            log.info("No longer accepting connections - closing TCP Listener on port {}", serverSocket.getLocalPort())__            try {_                serverSocket.close()__            } catch (IOException e) {_                e.printStackTrace()__            }_            log.info("Closed TCP Listener on port {}", serverSocket.getLocalPort())__        };accept,tcp,connections,and,create,client,socket,threads,for,them;public,void,run,log,info,accepting,connections,on,port,server,socket,get,local,port,this,set,name,mllp,server,resource,server,socket,thread,server,socket,get,local,socket,address,to,string,while,is,interrupted,server,socket,is,bound,server,socket,is,closed,socket,client,socket,null,try,client,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,if,raise,exception,on,accept,timeout,throw,new,mllp,junit,resource,timeout,exception,timeout,accepting,client,connection,timeout,ex,log,warn,timeout,waiting,for,client,connection,catch,socket,exception,socket,ex,log,debug,socket,exception,encountered,accepting,client,connection,ignoring,socket,ex,if,null,client,socket,continue,else,if,client,socket,is,closed,reset,connection,client,socket,continue,else,throw,new,mllp,junit,resource,exception,unexpected,socket,exception,encountered,accepting,client,connection,socket,ex,catch,exception,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,accepting,client,connection,ex,if,null,client,socket,try,client,socket,set,keep,alive,true,client,socket,set,tcp,no,delay,false,client,socket,set,so,linger,false,1,client,socket,set,so,timeout,5000,client,socket,thread,client,socket,thread,new,client,socket,thread,client,socket,client,socket,thread,set,daemon,true,client,socket,thread,start,client,socket,threads,add,client,socket,thread,catch,exception,unexpected,ex,log,warn,unexpected,exception,encountered,configuring,client,socket,try,client,socket,close,catch,ioexception,ingore,ex,log,warn,exceptiong,encountered,closing,client,socket,after,attempting,to,accept,connection,ingore,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,configuring,client,socket,unexpected,ex,log,info,no,longer,accepting,connections,closing,tcp,listener,on,port,server,socket,get,local,port,try,server,socket,close,catch,ioexception,e,e,print,stack,trace,log,info,closed,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> ServerSocketThread -> public void run();1461916938;Accept TCP connections and create ClientSocketThreads for them;public void run() {_            log.info("Accepting connections on port {}", serverSocket.getLocalPort())__            this.setName("MllpServerResource$ServerSocketThread - " + serverSocket.getLocalSocketAddress().toString())__            while (!isInterrupted() && serverSocket.isBound() && !serverSocket.isClosed()) {_                Socket clientSocket = null__                try {_                    clientSocket = serverSocket.accept()__                } catch (SocketTimeoutException timeoutEx) {_                    if (raiseExceptionOnAcceptTimeout) {_                        throw new MllpJUnitResourceTimeoutException("Timeout Accepting client connection", timeoutEx)__                    }_                    log.warn("Timeout waiting for client connection")__                } catch (SocketException socketEx) {_                    log.debug("SocketException encountered accepting client connection - ignoring", socketEx)__                    if (null == clientSocket) {_                        continue__                    } else if (!clientSocket.isClosed()) {_                        resetConnection(clientSocket)__                        continue__                    } else {_                        throw new MllpJUnitResourceException("Unexpected SocketException encountered accepting client connection", socketEx)__                    }_                } catch (Exception ex) {_                    throw new MllpJUnitResourceException("Unexpected exception encountered accepting client connection", ex)__                }_                if (null != clientSocket) {_                    try {_                        clientSocket.setKeepAlive(true)__                        clientSocket.setTcpNoDelay(false)__                        clientSocket.setSoLinger(false, -1)__                        clientSocket.setSoTimeout(5000)__                        ClientSocketThread clientSocketThread = new ClientSocketThread(clientSocket)__                        clientSocketThread.setDaemon(true)__                        clientSocketThread.start()__                        clientSocketThreads.add(clientSocketThread)__                    } catch (Exception unexpectedEx) {_                        log.warn("Unexpected exception encountered configuring client socket")__                        try {_                            clientSocket.close()__                        } catch (IOException ingoreEx) {_                            log.warn("Exceptiong encountered closing client socket after attempting to accept connection", ingoreEx)__                        }_                        throw new MllpJUnitResourceException("Unexpected exception encountered configuring client socket", unexpectedEx)__                    }_                }_            }_            log.info("No longer accepting connections - closing TCP Listener on port {}", serverSocket.getLocalPort())__            try {_                serverSocket.close()__            } catch (IOException e) {_                e.printStackTrace()__            }_            log.info("Closed TCP Listener on port {}", serverSocket.getLocalPort())__        };accept,tcp,connections,and,create,client,socket,threads,for,them;public,void,run,log,info,accepting,connections,on,port,server,socket,get,local,port,this,set,name,mllp,server,resource,server,socket,thread,server,socket,get,local,socket,address,to,string,while,is,interrupted,server,socket,is,bound,server,socket,is,closed,socket,client,socket,null,try,client,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,if,raise,exception,on,accept,timeout,throw,new,mllp,junit,resource,timeout,exception,timeout,accepting,client,connection,timeout,ex,log,warn,timeout,waiting,for,client,connection,catch,socket,exception,socket,ex,log,debug,socket,exception,encountered,accepting,client,connection,ignoring,socket,ex,if,null,client,socket,continue,else,if,client,socket,is,closed,reset,connection,client,socket,continue,else,throw,new,mllp,junit,resource,exception,unexpected,socket,exception,encountered,accepting,client,connection,socket,ex,catch,exception,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,accepting,client,connection,ex,if,null,client,socket,try,client,socket,set,keep,alive,true,client,socket,set,tcp,no,delay,false,client,socket,set,so,linger,false,1,client,socket,set,so,timeout,5000,client,socket,thread,client,socket,thread,new,client,socket,thread,client,socket,client,socket,thread,set,daemon,true,client,socket,thread,start,client,socket,threads,add,client,socket,thread,catch,exception,unexpected,ex,log,warn,unexpected,exception,encountered,configuring,client,socket,try,client,socket,close,catch,ioexception,ingore,ex,log,warn,exceptiong,encountered,closing,client,socket,after,attempting,to,accept,connection,ingore,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,configuring,client,socket,unexpected,ex,log,info,no,longer,accepting,connections,closing,tcp,listener,on,port,server,socket,get,local,port,try,server,socket,close,catch,ioexception,e,e,print,stack,trace,log,info,closed,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> ServerSocketThread -> public void run();1480882601;Accept TCP connections and create ClientSocketThreads for them;public void run() {_            log.info("Accepting connections on port {}", serverSocket.getLocalPort())__            this.setName("MllpServerResource$ServerSocketThread - " + serverSocket.getLocalSocketAddress().toString())__            while (!isInterrupted() && serverSocket.isBound() && !serverSocket.isClosed()) {_                Socket clientSocket = null__                try {_                    clientSocket = serverSocket.accept()__                } catch (SocketTimeoutException timeoutEx) {_                    if (raiseExceptionOnAcceptTimeout) {_                        throw new MllpJUnitResourceTimeoutException("Timeout Accepting client connection", timeoutEx)__                    }_                    log.warn("Timeout waiting for client connection")__                } catch (SocketException socketEx) {_                    log.debug("SocketException encountered accepting client connection - ignoring", socketEx)__                    if (null == clientSocket) {_                        continue__                    } else if (!clientSocket.isClosed()) {_                        resetConnection(clientSocket)__                        continue__                    } else {_                        throw new MllpJUnitResourceException("Unexpected SocketException encountered accepting client connection", socketEx)__                    }_                } catch (Exception ex) {_                    throw new MllpJUnitResourceException("Unexpected exception encountered accepting client connection", ex)__                }_                if (null != clientSocket) {_                    try {_                        clientSocket.setKeepAlive(true)__                        clientSocket.setTcpNoDelay(false)__                        clientSocket.setSoLinger(false, -1)__                        clientSocket.setSoTimeout(5000)__                        ClientSocketThread clientSocketThread = new ClientSocketThread(clientSocket)__                        clientSocketThread.setDaemon(true)__                        clientSocketThread.start()__                        clientSocketThreads.add(clientSocketThread)__                    } catch (Exception unexpectedEx) {_                        log.warn("Unexpected exception encountered configuring client socket")__                        try {_                            clientSocket.close()__                        } catch (IOException ingoreEx) {_                            log.warn("Exceptiong encountered closing client socket after attempting to accept connection", ingoreEx)__                        }_                        throw new MllpJUnitResourceException("Unexpected exception encountered configuring client socket", unexpectedEx)__                    }_                }_            }_            log.info("No longer accepting connections - closing TCP Listener on port {}", serverSocket.getLocalPort())__            try {_                serverSocket.close()__            } catch (IOException e) {_                e.printStackTrace()__            }_            log.info("Closed TCP Listener on port {}", serverSocket.getLocalPort())__        };accept,tcp,connections,and,create,client,socket,threads,for,them;public,void,run,log,info,accepting,connections,on,port,server,socket,get,local,port,this,set,name,mllp,server,resource,server,socket,thread,server,socket,get,local,socket,address,to,string,while,is,interrupted,server,socket,is,bound,server,socket,is,closed,socket,client,socket,null,try,client,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,if,raise,exception,on,accept,timeout,throw,new,mllp,junit,resource,timeout,exception,timeout,accepting,client,connection,timeout,ex,log,warn,timeout,waiting,for,client,connection,catch,socket,exception,socket,ex,log,debug,socket,exception,encountered,accepting,client,connection,ignoring,socket,ex,if,null,client,socket,continue,else,if,client,socket,is,closed,reset,connection,client,socket,continue,else,throw,new,mllp,junit,resource,exception,unexpected,socket,exception,encountered,accepting,client,connection,socket,ex,catch,exception,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,accepting,client,connection,ex,if,null,client,socket,try,client,socket,set,keep,alive,true,client,socket,set,tcp,no,delay,false,client,socket,set,so,linger,false,1,client,socket,set,so,timeout,5000,client,socket,thread,client,socket,thread,new,client,socket,thread,client,socket,client,socket,thread,set,daemon,true,client,socket,thread,start,client,socket,threads,add,client,socket,thread,catch,exception,unexpected,ex,log,warn,unexpected,exception,encountered,configuring,client,socket,try,client,socket,close,catch,ioexception,ingore,ex,log,warn,exceptiong,encountered,closing,client,socket,after,attempting,to,accept,connection,ingore,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,configuring,client,socket,unexpected,ex,log,info,no,longer,accepting,connections,closing,tcp,listener,on,port,server,socket,get,local,port,try,server,socket,close,catch,ioexception,e,e,print,stack,trace,log,info,closed,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> ServerSocketThread -> public void run();1481829620;Accept TCP connections and create ClientSocketThreads for them;public void run() {_            log.info("Accepting connections on port {}", serverSocket.getLocalPort())__            this.setName("MllpServerResource$ServerSocketThread - " + serverSocket.getLocalSocketAddress().toString())__            while (!isInterrupted() && serverSocket.isBound() && !serverSocket.isClosed()) {_                Socket clientSocket = null__                try {_                    clientSocket = serverSocket.accept()__                } catch (SocketTimeoutException timeoutEx) {_                    if (raiseExceptionOnAcceptTimeout) {_                        throw new MllpJUnitResourceTimeoutException("Timeout Accepting client connection", timeoutEx)__                    }_                    log.warn("Timeout waiting for client connection")__                } catch (SocketException socketEx) {_                    log.debug("SocketException encountered accepting client connection - ignoring", socketEx)__                    if (null == clientSocket) {_                        continue__                    } else if (!clientSocket.isClosed()) {_                        try {_                            clientSocket.setSoLinger(true, 0)__                        } catch (SocketException soLingerEx) {_                            log.warn("Ignoring SocketException encountered when setting SO_LINGER in preparation of resetting client Socket", soLingerEx)__                        }_                        try {_                            clientSocket.close()__                        } catch (IOException ioEx) {_                            log.warn("Ignoring IOException encountered when resetting client Socket", ioEx)__                        }_                        continue__                    } else {_                        throw new MllpJUnitResourceException("Unexpected SocketException encountered accepting client connection", socketEx)__                    }_                } catch (Exception ex) {_                    throw new MllpJUnitResourceException("Unexpected exception encountered accepting client connection", ex)__                }_                if (null != clientSocket) {_                    try {_                        clientSocket.setKeepAlive(true)__                        clientSocket.setTcpNoDelay(false)__                        clientSocket.setSoLinger(false, -1)__                        clientSocket.setSoTimeout(5000)__                        ClientSocketThread clientSocketThread = new ClientSocketThread(clientSocket)__                        clientSocketThread.setDaemon(true)__                        clientSocketThread.start()__                        clientSocketThreads.add(clientSocketThread)__                    } catch (Exception unexpectedEx) {_                        log.warn("Unexpected exception encountered configuring client socket")__                        try {_                            clientSocket.close()__                        } catch (IOException ingoreEx) {_                            log.warn("Exceptiong encountered closing client socket after attempting to accept connection", ingoreEx)__                        }_                        throw new MllpJUnitResourceException("Unexpected exception encountered configuring client socket", unexpectedEx)__                    }_                }_            }_            log.info("No longer accepting connections - closing TCP Listener on port {}", serverSocket.getLocalPort())__            try {_                serverSocket.close()__            } catch (IOException e) {_                e.printStackTrace()__            }_            log.info("Closed TCP Listener on port {}", serverSocket.getLocalPort())__        };accept,tcp,connections,and,create,client,socket,threads,for,them;public,void,run,log,info,accepting,connections,on,port,server,socket,get,local,port,this,set,name,mllp,server,resource,server,socket,thread,server,socket,get,local,socket,address,to,string,while,is,interrupted,server,socket,is,bound,server,socket,is,closed,socket,client,socket,null,try,client,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,if,raise,exception,on,accept,timeout,throw,new,mllp,junit,resource,timeout,exception,timeout,accepting,client,connection,timeout,ex,log,warn,timeout,waiting,for,client,connection,catch,socket,exception,socket,ex,log,debug,socket,exception,encountered,accepting,client,connection,ignoring,socket,ex,if,null,client,socket,continue,else,if,client,socket,is,closed,try,client,socket,set,so,linger,true,0,catch,socket,exception,so,linger,ex,log,warn,ignoring,socket,exception,encountered,when,setting,in,preparation,of,resetting,client,socket,so,linger,ex,try,client,socket,close,catch,ioexception,io,ex,log,warn,ignoring,ioexception,encountered,when,resetting,client,socket,io,ex,continue,else,throw,new,mllp,junit,resource,exception,unexpected,socket,exception,encountered,accepting,client,connection,socket,ex,catch,exception,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,accepting,client,connection,ex,if,null,client,socket,try,client,socket,set,keep,alive,true,client,socket,set,tcp,no,delay,false,client,socket,set,so,linger,false,1,client,socket,set,so,timeout,5000,client,socket,thread,client,socket,thread,new,client,socket,thread,client,socket,client,socket,thread,set,daemon,true,client,socket,thread,start,client,socket,threads,add,client,socket,thread,catch,exception,unexpected,ex,log,warn,unexpected,exception,encountered,configuring,client,socket,try,client,socket,close,catch,ioexception,ingore,ex,log,warn,exceptiong,encountered,closing,client,socket,after,attempting,to,accept,connection,ingore,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,configuring,client,socket,unexpected,ex,log,info,no,longer,accepting,connections,closing,tcp,listener,on,port,server,socket,get,local,port,try,server,socket,close,catch,ioexception,e,e,print,stack,trace,log,info,closed,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> AcceptSocketThread -> public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout);1515779403;Enable/Disable the generation of MllpJUnitResourceTimeoutException if the ServerSocket.accept() call raises a SocketTimeoutException.__@param raiseExceptionOnAcceptTimeout true enables exceptions on an accept timeout;public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout) {_            this.raiseExceptionOnAcceptTimeout = raiseExceptionOnAcceptTimeout__        };enable,disable,the,generation,of,mllp,junit,resource,timeout,exception,if,the,server,socket,accept,call,raises,a,socket,timeout,exception,param,raise,exception,on,accept,timeout,true,enables,exceptions,on,an,accept,timeout;public,void,set,raise,exception,on,accept,timeout,boolean,raise,exception,on,accept,timeout,this,raise,exception,on,accept,timeout,raise,exception,on,accept,timeout
MllpServerResource -> AcceptSocketThread -> public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout);1524063106;Enable/Disable the generation of MllpJUnitResourceTimeoutException if the ServerSocket.accept() call raises a SocketTimeoutException.__@param raiseExceptionOnAcceptTimeout true enables exceptions on an accept timeout;public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout) {_            this.raiseExceptionOnAcceptTimeout = raiseExceptionOnAcceptTimeout__        };enable,disable,the,generation,of,mllp,junit,resource,timeout,exception,if,the,server,socket,accept,call,raises,a,socket,timeout,exception,param,raise,exception,on,accept,timeout,true,enables,exceptions,on,an,accept,timeout;public,void,set,raise,exception,on,accept,timeout,boolean,raise,exception,on,accept,timeout,this,raise,exception,on,accept,timeout,raise,exception,on,accept,timeout
MllpServerResource -> AcceptSocketThread -> public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout);1536605520;Enable/Disable the generation of MllpJUnitResourceTimeoutException if the ServerSocket.accept() call raises a SocketTimeoutException.__@param raiseExceptionOnAcceptTimeout true enables exceptions on an accept timeout;public void setRaiseExceptionOnAcceptTimeout(boolean raiseExceptionOnAcceptTimeout) {_            this.raiseExceptionOnAcceptTimeout = raiseExceptionOnAcceptTimeout__        };enable,disable,the,generation,of,mllp,junit,resource,timeout,exception,if,the,server,socket,accept,call,raises,a,socket,timeout,exception,param,raise,exception,on,accept,timeout,true,enables,exceptions,on,an,accept,timeout;public,void,set,raise,exception,on,accept,timeout,boolean,raise,exception,on,accept,timeout,this,raise,exception,on,accept,timeout,raise,exception,on,accept,timeout
MllpServerResource -> ServerSocketThread -> public void setAcceptTimeout(int acceptTimeout);1451464990;Enable/disable a timeout while waiting for a TCP connection, in milliseconds. With this option set to a_non-zero timeout, the ServerSocketThread will block for only this amount of time while waiting for a tcp_connection. If the timeout expires and raiseExceptionOnAcceptTimeout is set to true, a MllpJUnitResourceTimeoutException_is raised. Otherwise, the ServerSocketThread will continue to poll for new TCP connections.__@param acceptTimeout the timeout in milliseconds - zero is interpreted as an infinite timeout;public void setAcceptTimeout(int acceptTimeout) {_            this.acceptTimeout = acceptTimeout__        };enable,disable,a,timeout,while,waiting,for,a,tcp,connection,in,milliseconds,with,this,option,set,to,a,non,zero,timeout,the,server,socket,thread,will,block,for,only,this,amount,of,time,while,waiting,for,a,tcp,connection,if,the,timeout,expires,and,raise,exception,on,accept,timeout,is,set,to,true,a,mllp,junit,resource,timeout,exception,is,raised,otherwise,the,server,socket,thread,will,continue,to,poll,for,new,tcp,connections,param,accept,timeout,the,timeout,in,milliseconds,zero,is,interpreted,as,an,infinite,timeout;public,void,set,accept,timeout,int,accept,timeout,this,accept,timeout,accept,timeout
MllpServerResource -> ServerSocketThread -> public void setAcceptTimeout(int acceptTimeout);1453968697;Enable/disable a timeout while waiting for a TCP connection, in milliseconds. With this option set to a_non-zero timeout, the ServerSocketThread will block for only this amount of time while waiting for a tcp_connection. If the timeout expires and raiseExceptionOnAcceptTimeout is set to true, a MllpJUnitResourceTimeoutException_is raised. Otherwise, the ServerSocketThread will continue to poll for new TCP connections.__@param acceptTimeout the timeout in milliseconds - zero is interpreted as an infinite timeout;public void setAcceptTimeout(int acceptTimeout) {_            this.acceptTimeout = acceptTimeout__        };enable,disable,a,timeout,while,waiting,for,a,tcp,connection,in,milliseconds,with,this,option,set,to,a,non,zero,timeout,the,server,socket,thread,will,block,for,only,this,amount,of,time,while,waiting,for,a,tcp,connection,if,the,timeout,expires,and,raise,exception,on,accept,timeout,is,set,to,true,a,mllp,junit,resource,timeout,exception,is,raised,otherwise,the,server,socket,thread,will,continue,to,poll,for,new,tcp,connections,param,accept,timeout,the,timeout,in,milliseconds,zero,is,interpreted,as,an,infinite,timeout;public,void,set,accept,timeout,int,accept,timeout,this,accept,timeout,accept,timeout
MllpServerResource -> ServerSocketThread -> public void setAcceptTimeout(int acceptTimeout);1453968697;Enable/disable a timeout while waiting for a TCP connection, in milliseconds. With this option set to a_non-zero timeout, the ServerSocketThread will block for only this amount of time while waiting for a tcp_connection. If the timeout expires and raiseExceptionOnAcceptTimeout is set to true, a MllpJUnitResourceTimeoutException_is raised. Otherwise, the ServerSocketThread will continue to poll for new TCP connections.__@param acceptTimeout the timeout in milliseconds - zero is interpreted as an infinite timeout;public void setAcceptTimeout(int acceptTimeout) {_            this.acceptTimeout = acceptTimeout__        };enable,disable,a,timeout,while,waiting,for,a,tcp,connection,in,milliseconds,with,this,option,set,to,a,non,zero,timeout,the,server,socket,thread,will,block,for,only,this,amount,of,time,while,waiting,for,a,tcp,connection,if,the,timeout,expires,and,raise,exception,on,accept,timeout,is,set,to,true,a,mllp,junit,resource,timeout,exception,is,raised,otherwise,the,server,socket,thread,will,continue,to,poll,for,new,tcp,connections,param,accept,timeout,the,timeout,in,milliseconds,zero,is,interpreted,as,an,infinite,timeout;public,void,set,accept,timeout,int,accept,timeout,this,accept,timeout,accept,timeout
MllpServerResource -> ServerSocketThread -> public void setAcceptTimeout(int acceptTimeout);1457097808;Enable/disable a timeout while waiting for a TCP connection, in milliseconds. With this option set to a_non-zero timeout, the ServerSocketThread will block for only this amount of time while waiting for a tcp_connection. If the timeout expires and raiseExceptionOnAcceptTimeout is set to true, a MllpJUnitResourceTimeoutException_is raised. Otherwise, the ServerSocketThread will continue to poll for new TCP connections.__@param acceptTimeout the timeout in milliseconds - zero is interpreted as an infinite timeout;public void setAcceptTimeout(int acceptTimeout) {_            this.acceptTimeout = acceptTimeout__        };enable,disable,a,timeout,while,waiting,for,a,tcp,connection,in,milliseconds,with,this,option,set,to,a,non,zero,timeout,the,server,socket,thread,will,block,for,only,this,amount,of,time,while,waiting,for,a,tcp,connection,if,the,timeout,expires,and,raise,exception,on,accept,timeout,is,set,to,true,a,mllp,junit,resource,timeout,exception,is,raised,otherwise,the,server,socket,thread,will,continue,to,poll,for,new,tcp,connections,param,accept,timeout,the,timeout,in,milliseconds,zero,is,interpreted,as,an,infinite,timeout;public,void,set,accept,timeout,int,accept,timeout,this,accept,timeout,accept,timeout
MllpServerResource -> ServerSocketThread -> public void setAcceptTimeout(int acceptTimeout);1461916938;Enable/disable a timeout while waiting for a TCP connection, in milliseconds. With this option set to a_non-zero timeout, the ServerSocketThread will block for only this amount of time while waiting for a tcp_connection. If the timeout expires and raiseExceptionOnAcceptTimeout is set to true, a MllpJUnitResourceTimeoutException_is raised. Otherwise, the ServerSocketThread will continue to poll for new TCP connections.__@param acceptTimeout the timeout in milliseconds - zero is interpreted as an infinite timeout;public void setAcceptTimeout(int acceptTimeout) {_            this.acceptTimeout = acceptTimeout__        };enable,disable,a,timeout,while,waiting,for,a,tcp,connection,in,milliseconds,with,this,option,set,to,a,non,zero,timeout,the,server,socket,thread,will,block,for,only,this,amount,of,time,while,waiting,for,a,tcp,connection,if,the,timeout,expires,and,raise,exception,on,accept,timeout,is,set,to,true,a,mllp,junit,resource,timeout,exception,is,raised,otherwise,the,server,socket,thread,will,continue,to,poll,for,new,tcp,connections,param,accept,timeout,the,timeout,in,milliseconds,zero,is,interpreted,as,an,infinite,timeout;public,void,set,accept,timeout,int,accept,timeout,this,accept,timeout,accept,timeout
MllpServerResource -> ServerSocketThread -> public void setAcceptTimeout(int acceptTimeout);1480882601;Enable/disable a timeout while waiting for a TCP connection, in milliseconds. With this option set to a_non-zero timeout, the ServerSocketThread will block for only this amount of time while waiting for a tcp_connection. If the timeout expires and raiseExceptionOnAcceptTimeout is set to true, a MllpJUnitResourceTimeoutException_is raised. Otherwise, the ServerSocketThread will continue to poll for new TCP connections.__@param acceptTimeout the timeout in milliseconds - zero is interpreted as an infinite timeout;public void setAcceptTimeout(int acceptTimeout) {_            this.acceptTimeout = acceptTimeout__        };enable,disable,a,timeout,while,waiting,for,a,tcp,connection,in,milliseconds,with,this,option,set,to,a,non,zero,timeout,the,server,socket,thread,will,block,for,only,this,amount,of,time,while,waiting,for,a,tcp,connection,if,the,timeout,expires,and,raise,exception,on,accept,timeout,is,set,to,true,a,mllp,junit,resource,timeout,exception,is,raised,otherwise,the,server,socket,thread,will,continue,to,poll,for,new,tcp,connections,param,accept,timeout,the,timeout,in,milliseconds,zero,is,interpreted,as,an,infinite,timeout;public,void,set,accept,timeout,int,accept,timeout,this,accept,timeout,accept,timeout
MllpServerResource -> ServerSocketThread -> public void setAcceptTimeout(int acceptTimeout);1481829620;Enable/disable a timeout while waiting for a TCP connection, in milliseconds. With this option set to a_non-zero timeout, the ServerSocketThread will block for only this amount of time while waiting for a tcp_connection. If the timeout expires and raiseExceptionOnAcceptTimeout is set to true, a MllpJUnitResourceTimeoutException_is raised. Otherwise, the ServerSocketThread will continue to poll for new TCP connections.__@param acceptTimeout the timeout in milliseconds - zero is interpreted as an infinite timeout;public void setAcceptTimeout(int acceptTimeout) {_            this.acceptTimeout = acceptTimeout__        };enable,disable,a,timeout,while,waiting,for,a,tcp,connection,in,milliseconds,with,this,option,set,to,a,non,zero,timeout,the,server,socket,thread,will,block,for,only,this,amount,of,time,while,waiting,for,a,tcp,connection,if,the,timeout,expires,and,raise,exception,on,accept,timeout,is,set,to,true,a,mllp,junit,resource,timeout,exception,is,raised,otherwise,the,server,socket,thread,will,continue,to,poll,for,new,tcp,connections,param,accept,timeout,the,timeout,in,milliseconds,zero,is,interpreted,as,an,infinite,timeout;public,void,set,accept,timeout,int,accept,timeout,this,accept,timeout,accept,timeout
MllpServerResource -> AcceptSocketThread -> private void bind() throws IOException;1515779403;Open the TCP Listener__@throws IOException;private void bind() throws IOException {_            this.setDaemon(true)__            serverSocket = new ServerSocket()___            _            serverSocket.setSoTimeout(acceptTimeout)__            serverSocket.setReuseAddress(true)___            InetSocketAddress listenAddress__            if (null != this.listenHost) {_                listenAddress = new InetSocketAddress(this.listenHost, this.listenPort)__            } else {_                listenAddress = new InetSocketAddress(this.listenPort)__            }__            long startTicks = System.currentTimeMillis()__            while (!serverSocket.isBound()) {_                try {_                    serverSocket.bind(listenAddress, backlog)__                } catch (BindException bindEx) {_                    if (System.currentTimeMillis() < startTicks + bindTimeout) {_                        log.warn("Unable to bind to {} - retrying in {} milliseconds", listenAddress.toString(), bindRetryDelay)__                        try {_                            Thread.sleep(bindRetryDelay)__                        } catch (InterruptedException interruptedEx) {_                            log.error("Wait for bind retry was interrupted - rethrowing BindException")__                            throw bindEx__                        }_                    }_                }_            }__            if (0 >= this.listenPort) {_                this.listenPort = serverSocket.getLocalPort()__            }___            log.info("Opened TCP Listener on port {}", serverSocket.getLocalPort())__        };open,the,tcp,listener,throws,ioexception;private,void,bind,throws,ioexception,this,set,daemon,true,server,socket,new,server,socket,server,socket,set,so,timeout,accept,timeout,server,socket,set,reuse,address,true,inet,socket,address,listen,address,if,null,this,listen,host,listen,address,new,inet,socket,address,this,listen,host,this,listen,port,else,listen,address,new,inet,socket,address,this,listen,port,long,start,ticks,system,current,time,millis,while,server,socket,is,bound,try,server,socket,bind,listen,address,backlog,catch,bind,exception,bind,ex,if,system,current,time,millis,start,ticks,bind,timeout,log,warn,unable,to,bind,to,retrying,in,milliseconds,listen,address,to,string,bind,retry,delay,try,thread,sleep,bind,retry,delay,catch,interrupted,exception,interrupted,ex,log,error,wait,for,bind,retry,was,interrupted,rethrowing,bind,exception,throw,bind,ex,if,0,this,listen,port,this,listen,port,server,socket,get,local,port,log,info,opened,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> AcceptSocketThread -> private void bind() throws IOException;1524063106;Open the TCP Listener__@throws IOException;private void bind() throws IOException {_            this.setDaemon(true)__            serverSocket = new ServerSocket()___            _            serverSocket.setSoTimeout(acceptTimeout)__            serverSocket.setReuseAddress(true)___            InetSocketAddress listenAddress__            if (null != this.listenHost) {_                listenAddress = new InetSocketAddress(this.listenHost, this.listenPort)__            } else {_                listenAddress = new InetSocketAddress(this.listenPort)__            }__            long startTicks = System.currentTimeMillis()__            while (!serverSocket.isBound()) {_                try {_                    serverSocket.bind(listenAddress, backlog)__                } catch (BindException bindEx) {_                    if (System.currentTimeMillis() < startTicks + bindTimeout) {_                        log.warn("Unable to bind to {} - retrying in {} milliseconds", listenAddress.toString(), bindRetryDelay)__                        try {_                            Thread.sleep(bindRetryDelay)__                        } catch (InterruptedException interruptedEx) {_                            log.error("Wait for bind retry was interrupted - rethrowing BindException")__                            throw bindEx__                        }_                    }_                }_            }__            if (0 >= this.listenPort) {_                this.listenPort = serverSocket.getLocalPort()__            }___            log.info("Opened TCP Listener on port {}", serverSocket.getLocalPort())__        };open,the,tcp,listener,throws,ioexception;private,void,bind,throws,ioexception,this,set,daemon,true,server,socket,new,server,socket,server,socket,set,so,timeout,accept,timeout,server,socket,set,reuse,address,true,inet,socket,address,listen,address,if,null,this,listen,host,listen,address,new,inet,socket,address,this,listen,host,this,listen,port,else,listen,address,new,inet,socket,address,this,listen,port,long,start,ticks,system,current,time,millis,while,server,socket,is,bound,try,server,socket,bind,listen,address,backlog,catch,bind,exception,bind,ex,if,system,current,time,millis,start,ticks,bind,timeout,log,warn,unable,to,bind,to,retrying,in,milliseconds,listen,address,to,string,bind,retry,delay,try,thread,sleep,bind,retry,delay,catch,interrupted,exception,interrupted,ex,log,error,wait,for,bind,retry,was,interrupted,rethrowing,bind,exception,throw,bind,ex,if,0,this,listen,port,this,listen,port,server,socket,get,local,port,log,info,opened,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> AcceptSocketThread -> private void bind() throws IOException;1536605520;Open the TCP Listener__@throws IOException;private void bind() throws IOException {_            this.setDaemon(true)__            serverSocket = new ServerSocket()___            _            serverSocket.setSoTimeout(acceptTimeout)__            serverSocket.setReuseAddress(true)___            InetSocketAddress listenAddress__            if (null != this.listenHost) {_                listenAddress = new InetSocketAddress(this.listenHost, this.listenPort)__            } else {_                listenAddress = new InetSocketAddress(this.listenPort)__            }__            long startTicks = System.currentTimeMillis()__            while (!serverSocket.isBound()) {_                try {_                    serverSocket.bind(listenAddress, backlog)__                } catch (BindException bindEx) {_                    if (System.currentTimeMillis() < startTicks + bindTimeout) {_                        log.warn("Unable to bind to {} - retrying in {} milliseconds", listenAddress, bindRetryDelay)__                        try {_                            Thread.sleep(bindRetryDelay)__                        } catch (InterruptedException interruptedEx) {_                            log.error("Wait for bind retry was interrupted - rethrowing BindException")__                            throw bindEx__                        }_                    }_                }_            }__            if (0 >= this.listenPort) {_                this.listenPort = serverSocket.getLocalPort()__            }___            log.info("Opened TCP Listener on port {}", serverSocket.getLocalPort())__        };open,the,tcp,listener,throws,ioexception;private,void,bind,throws,ioexception,this,set,daemon,true,server,socket,new,server,socket,server,socket,set,so,timeout,accept,timeout,server,socket,set,reuse,address,true,inet,socket,address,listen,address,if,null,this,listen,host,listen,address,new,inet,socket,address,this,listen,host,this,listen,port,else,listen,address,new,inet,socket,address,this,listen,port,long,start,ticks,system,current,time,millis,while,server,socket,is,bound,try,server,socket,bind,listen,address,backlog,catch,bind,exception,bind,ex,if,system,current,time,millis,start,ticks,bind,timeout,log,warn,unable,to,bind,to,retrying,in,milliseconds,listen,address,bind,retry,delay,try,thread,sleep,bind,retry,delay,catch,interrupted,exception,interrupted,ex,log,error,wait,for,bind,retry,was,interrupted,rethrowing,bind,exception,throw,bind,ex,if,0,this,listen,port,this,listen,port,server,socket,get,local,port,log,info,opened,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus);1451464990;Set the modulus used to determine when to include the bMLLP_ENVELOPE_START_OF_BLOCK_portion of the MLLP Envelope._<p/>_If this value is less than or equal to 0, the bMLLP_ENVELOPE_START_OF_BLOCK portion_of the MLLP Envelope will always be included._If the value is 1, the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope will_never be included._Otherwise, if the result of evaluating message count % value is greater_than 0, the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope will not be_included.  Effectively leaving the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope_out of every n-th message.__@param excludeStartOfBlockModulus exclude on every n-th message_0 => Never excluded_1 => Always excluded;public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus) {_        if (0 > excludeStartOfBlockModulus) {_            this.excludeStartOfBlockModulus = 0__        } else {_            this.excludeStartOfBlockModulus = excludeStartOfBlockModulus__        }_    };set,the,modulus,used,to,determine,when,to,include,the,portion,of,the,mllp,envelope,p,if,this,value,is,less,than,or,equal,to,0,the,portion,of,the,mllp,envelope,will,always,be,included,if,the,value,is,1,the,portion,of,the,mllp,envelope,will,never,be,included,otherwise,if,the,result,of,evaluating,message,count,value,is,greater,than,0,the,portion,of,the,mllp,envelope,will,not,be,included,effectively,leaving,the,portion,of,the,mllp,envelope,out,of,every,n,th,message,param,exclude,start,of,block,modulus,exclude,on,every,n,th,message,0,never,excluded,1,always,excluded;public,void,set,exclude,start,of,block,modulus,int,exclude,start,of,block,modulus,if,0,exclude,start,of,block,modulus,this,exclude,start,of,block,modulus,0,else,this,exclude,start,of,block,modulus,exclude,start,of,block,modulus
MllpServerResource -> public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus);1453968697;Set the modulus used to determine when to include the bMLLP_ENVELOPE_START_OF_BLOCK_portion of the MLLP Envelope._<p/>_If this value is less than or equal to 0, the bMLLP_ENVELOPE_START_OF_BLOCK portion_of the MLLP Envelope will always be included._If the value is 1, the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope will_never be included._Otherwise, if the result of evaluating message count % value is greater_than 0, the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope will not be_included.  Effectively leaving the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope_out of every n-th message.__@param excludeStartOfBlockModulus exclude on every n-th message_0 => Never excluded_1 => Always excluded;public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus) {_        if (0 > excludeStartOfBlockModulus) {_            this.excludeStartOfBlockModulus = 0__        } else {_            this.excludeStartOfBlockModulus = excludeStartOfBlockModulus__        }_    };set,the,modulus,used,to,determine,when,to,include,the,portion,of,the,mllp,envelope,p,if,this,value,is,less,than,or,equal,to,0,the,portion,of,the,mllp,envelope,will,always,be,included,if,the,value,is,1,the,portion,of,the,mllp,envelope,will,never,be,included,otherwise,if,the,result,of,evaluating,message,count,value,is,greater,than,0,the,portion,of,the,mllp,envelope,will,not,be,included,effectively,leaving,the,portion,of,the,mllp,envelope,out,of,every,n,th,message,param,exclude,start,of,block,modulus,exclude,on,every,n,th,message,0,never,excluded,1,always,excluded;public,void,set,exclude,start,of,block,modulus,int,exclude,start,of,block,modulus,if,0,exclude,start,of,block,modulus,this,exclude,start,of,block,modulus,0,else,this,exclude,start,of,block,modulus,exclude,start,of,block,modulus
MllpServerResource -> public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus);1453968697;Set the modulus used to determine when to include the bMLLP_ENVELOPE_START_OF_BLOCK_portion of the MLLP Envelope._<p/>_If this value is less than or equal to 0, the bMLLP_ENVELOPE_START_OF_BLOCK portion_of the MLLP Envelope will always be included._If the value is 1, the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope will_never be included._Otherwise, if the result of evaluating message count % value is greater_than 0, the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope will not be_included.  Effectively leaving the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope_out of every n-th message.__@param excludeStartOfBlockModulus exclude on every n-th message_0 => Never excluded_1 => Always excluded;public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus) {_        if (0 > excludeStartOfBlockModulus) {_            this.excludeStartOfBlockModulus = 0__        } else {_            this.excludeStartOfBlockModulus = excludeStartOfBlockModulus__        }_    };set,the,modulus,used,to,determine,when,to,include,the,portion,of,the,mllp,envelope,p,if,this,value,is,less,than,or,equal,to,0,the,portion,of,the,mllp,envelope,will,always,be,included,if,the,value,is,1,the,portion,of,the,mllp,envelope,will,never,be,included,otherwise,if,the,result,of,evaluating,message,count,value,is,greater,than,0,the,portion,of,the,mllp,envelope,will,not,be,included,effectively,leaving,the,portion,of,the,mllp,envelope,out,of,every,n,th,message,param,exclude,start,of,block,modulus,exclude,on,every,n,th,message,0,never,excluded,1,always,excluded;public,void,set,exclude,start,of,block,modulus,int,exclude,start,of,block,modulus,if,0,exclude,start,of,block,modulus,this,exclude,start,of,block,modulus,0,else,this,exclude,start,of,block,modulus,exclude,start,of,block,modulus
MllpServerResource -> public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus);1457097808;Set the modulus used to determine when to include the bMLLP_ENVELOPE_START_OF_BLOCK_portion of the MLLP Envelope._<p/>_If this value is less than or equal to 0, the bMLLP_ENVELOPE_START_OF_BLOCK portion_of the MLLP Envelope will always be included._If the value is 1, the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope will_never be included._Otherwise, if the result of evaluating message count % value is greater_than 0, the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope will not be_included.  Effectively leaving the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope_out of every n-th message.__@param excludeStartOfBlockModulus exclude on every n-th message_0 => Never excluded_1 => Always excluded;public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus) {_        if (0 > excludeStartOfBlockModulus) {_            this.excludeStartOfBlockModulus = 0__        } else {_            this.excludeStartOfBlockModulus = excludeStartOfBlockModulus__        }_    };set,the,modulus,used,to,determine,when,to,include,the,portion,of,the,mllp,envelope,p,if,this,value,is,less,than,or,equal,to,0,the,portion,of,the,mllp,envelope,will,always,be,included,if,the,value,is,1,the,portion,of,the,mllp,envelope,will,never,be,included,otherwise,if,the,result,of,evaluating,message,count,value,is,greater,than,0,the,portion,of,the,mllp,envelope,will,not,be,included,effectively,leaving,the,portion,of,the,mllp,envelope,out,of,every,n,th,message,param,exclude,start,of,block,modulus,exclude,on,every,n,th,message,0,never,excluded,1,always,excluded;public,void,set,exclude,start,of,block,modulus,int,exclude,start,of,block,modulus,if,0,exclude,start,of,block,modulus,this,exclude,start,of,block,modulus,0,else,this,exclude,start,of,block,modulus,exclude,start,of,block,modulus
MllpServerResource -> public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus);1461916938;Set the modulus used to determine when to include the bMLLP_ENVELOPE_START_OF_BLOCK_portion of the MLLP Envelope._<p/>_If this value is less than or equal to 0, the bMLLP_ENVELOPE_START_OF_BLOCK portion_of the MLLP Envelope will always be included._If the value is 1, the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope will_never be included._Otherwise, if the result of evaluating message count % value is greater_than 0, the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope will not be_included.  Effectively leaving the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope_out of every n-th message.__@param excludeStartOfBlockModulus exclude on every n-th message_0 => Never excluded_1 => Always excluded;public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus) {_        if (0 > excludeStartOfBlockModulus) {_            this.excludeStartOfBlockModulus = 0__        } else {_            this.excludeStartOfBlockModulus = excludeStartOfBlockModulus__        }_    };set,the,modulus,used,to,determine,when,to,include,the,portion,of,the,mllp,envelope,p,if,this,value,is,less,than,or,equal,to,0,the,portion,of,the,mllp,envelope,will,always,be,included,if,the,value,is,1,the,portion,of,the,mllp,envelope,will,never,be,included,otherwise,if,the,result,of,evaluating,message,count,value,is,greater,than,0,the,portion,of,the,mllp,envelope,will,not,be,included,effectively,leaving,the,portion,of,the,mllp,envelope,out,of,every,n,th,message,param,exclude,start,of,block,modulus,exclude,on,every,n,th,message,0,never,excluded,1,always,excluded;public,void,set,exclude,start,of,block,modulus,int,exclude,start,of,block,modulus,if,0,exclude,start,of,block,modulus,this,exclude,start,of,block,modulus,0,else,this,exclude,start,of,block,modulus,exclude,start,of,block,modulus
MllpServerResource -> public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus);1480882601;Set the modulus used to determine when to include the bMLLP_ENVELOPE_START_OF_BLOCK_portion of the MLLP Envelope._<p/>_If this value is less than or equal to 0, the bMLLP_ENVELOPE_START_OF_BLOCK portion_of the MLLP Envelope will always be included._If the value is 1, the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope will_never be included._Otherwise, if the result of evaluating message count % value is greater_than 0, the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope will not be_included.  Effectively leaving the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope_out of every n-th message.__@param excludeStartOfBlockModulus exclude on every n-th message_0 => Never excluded_1 => Always excluded;public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus) {_        if (0 > excludeStartOfBlockModulus) {_            this.excludeStartOfBlockModulus = 0__        } else {_            this.excludeStartOfBlockModulus = excludeStartOfBlockModulus__        }_    };set,the,modulus,used,to,determine,when,to,include,the,portion,of,the,mllp,envelope,p,if,this,value,is,less,than,or,equal,to,0,the,portion,of,the,mllp,envelope,will,always,be,included,if,the,value,is,1,the,portion,of,the,mllp,envelope,will,never,be,included,otherwise,if,the,result,of,evaluating,message,count,value,is,greater,than,0,the,portion,of,the,mllp,envelope,will,not,be,included,effectively,leaving,the,portion,of,the,mllp,envelope,out,of,every,n,th,message,param,exclude,start,of,block,modulus,exclude,on,every,n,th,message,0,never,excluded,1,always,excluded;public,void,set,exclude,start,of,block,modulus,int,exclude,start,of,block,modulus,if,0,exclude,start,of,block,modulus,this,exclude,start,of,block,modulus,0,else,this,exclude,start,of,block,modulus,exclude,start,of,block,modulus
MllpServerResource -> public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus);1481829620;Set the modulus used to determine when to include the bMLLP_ENVELOPE_START_OF_BLOCK_portion of the MLLP Envelope._<p/>_If this value is less than or equal to 0, the bMLLP_ENVELOPE_START_OF_BLOCK portion_of the MLLP Envelope will always be included._If the value is 1, the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope will_never be included._Otherwise, if the result of evaluating message count % value is greater_than 0, the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope will not be_included.  Effectively leaving the bMLLP_ENVELOPE_START_OF_BLOCK portion of the MLLP Envelope_out of every n-th message.__@param excludeStartOfBlockModulus exclude on every n-th message_0 => Never excluded_1 => Always excluded;public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus) {_        if (0 > excludeStartOfBlockModulus) {_            this.excludeStartOfBlockModulus = 0__        } else {_            this.excludeStartOfBlockModulus = excludeStartOfBlockModulus__        }_    };set,the,modulus,used,to,determine,when,to,include,the,portion,of,the,mllp,envelope,p,if,this,value,is,less,than,or,equal,to,0,the,portion,of,the,mllp,envelope,will,always,be,included,if,the,value,is,1,the,portion,of,the,mllp,envelope,will,never,be,included,otherwise,if,the,result,of,evaluating,message,count,value,is,greater,than,0,the,portion,of,the,mllp,envelope,will,not,be,included,effectively,leaving,the,portion,of,the,mllp,envelope,out,of,every,n,th,message,param,exclude,start,of,block,modulus,exclude,on,every,n,th,message,0,never,excluded,1,always,excluded;public,void,set,exclude,start,of,block,modulus,int,exclude,start,of,block,modulus,if,0,exclude,start,of,block,modulus,this,exclude,start,of,block,modulus,0,else,this,exclude,start,of,block,modulus,exclude,start,of,block,modulus
MllpServerResource -> public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus);1515779403;Set the modulus used to determine when to include the START_OF_BLOCK portion of the MLLP Envelope._<p/>_If this value is less than or equal to 0, the START_OF_BLOCK portion of the MLLP Envelope will always be_included. If the value is 1, the START_OF_BLOCK portion of the MLLP Envelope will never be_included. Otherwise, if the result of evaluating message availableByteCount % value is greater than 0, the_START_OF_BLOCK portion of the MLLP Envelope will not be included.  Effectively leaving the_START_OF_BLOCK portion of the MLLP Envelope out of every n-th message.__@param excludeStartOfBlockModulus exclude on every n-th message 0 => Never excluded 1 => Always excluded;public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus) {_        if (0 > excludeStartOfBlockModulus) {_            this.excludeStartOfBlockModulus = 0__        } else {_            this.excludeStartOfBlockModulus = excludeStartOfBlockModulus__        }_    };set,the,modulus,used,to,determine,when,to,include,the,portion,of,the,mllp,envelope,p,if,this,value,is,less,than,or,equal,to,0,the,portion,of,the,mllp,envelope,will,always,be,included,if,the,value,is,1,the,portion,of,the,mllp,envelope,will,never,be,included,otherwise,if,the,result,of,evaluating,message,available,byte,count,value,is,greater,than,0,the,portion,of,the,mllp,envelope,will,not,be,included,effectively,leaving,the,portion,of,the,mllp,envelope,out,of,every,n,th,message,param,exclude,start,of,block,modulus,exclude,on,every,n,th,message,0,never,excluded,1,always,excluded;public,void,set,exclude,start,of,block,modulus,int,exclude,start,of,block,modulus,if,0,exclude,start,of,block,modulus,this,exclude,start,of,block,modulus,0,else,this,exclude,start,of,block,modulus,exclude,start,of,block,modulus
MllpServerResource -> public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus);1524063106;Set the modulus used to determine when to include the START_OF_BLOCK portion of the MLLP Envelope._<p/>_If this value is less than or equal to 0, the START_OF_BLOCK portion of the MLLP Envelope will always be_included. If the value is 1, the START_OF_BLOCK portion of the MLLP Envelope will never be_included. Otherwise, if the result of evaluating message availableByteCount % value is greater than 0, the_START_OF_BLOCK portion of the MLLP Envelope will not be included.  Effectively leaving the_START_OF_BLOCK portion of the MLLP Envelope out of every n-th message.__@param excludeStartOfBlockModulus exclude on every n-th message 0 => Never excluded 1 => Always excluded;public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus) {_        if (0 > excludeStartOfBlockModulus) {_            this.excludeStartOfBlockModulus = 0__        } else {_            this.excludeStartOfBlockModulus = excludeStartOfBlockModulus__        }_    };set,the,modulus,used,to,determine,when,to,include,the,portion,of,the,mllp,envelope,p,if,this,value,is,less,than,or,equal,to,0,the,portion,of,the,mllp,envelope,will,always,be,included,if,the,value,is,1,the,portion,of,the,mllp,envelope,will,never,be,included,otherwise,if,the,result,of,evaluating,message,available,byte,count,value,is,greater,than,0,the,portion,of,the,mllp,envelope,will,not,be,included,effectively,leaving,the,portion,of,the,mllp,envelope,out,of,every,n,th,message,param,exclude,start,of,block,modulus,exclude,on,every,n,th,message,0,never,excluded,1,always,excluded;public,void,set,exclude,start,of,block,modulus,int,exclude,start,of,block,modulus,if,0,exclude,start,of,block,modulus,this,exclude,start,of,block,modulus,0,else,this,exclude,start,of,block,modulus,exclude,start,of,block,modulus
MllpServerResource -> public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus);1536605520;Set the modulus used to determine when to include the START_OF_BLOCK portion of the MLLP Envelope._<p/>_If this value is less than or equal to 0, the START_OF_BLOCK portion of the MLLP Envelope will always be_included. If the value is 1, the START_OF_BLOCK portion of the MLLP Envelope will never be_included. Otherwise, if the result of evaluating message availableByteCount % value is greater than 0, the_START_OF_BLOCK portion of the MLLP Envelope will not be included.  Effectively leaving the_START_OF_BLOCK portion of the MLLP Envelope out of every n-th message.__@param excludeStartOfBlockModulus exclude on every n-th message 0 => Never excluded 1 => Always excluded;public void setExcludeStartOfBlockModulus(int excludeStartOfBlockModulus) {_        if (0 > excludeStartOfBlockModulus) {_            this.excludeStartOfBlockModulus = 0__        } else {_            this.excludeStartOfBlockModulus = excludeStartOfBlockModulus__        }_    };set,the,modulus,used,to,determine,when,to,include,the,portion,of,the,mllp,envelope,p,if,this,value,is,less,than,or,equal,to,0,the,portion,of,the,mllp,envelope,will,always,be,included,if,the,value,is,1,the,portion,of,the,mllp,envelope,will,never,be,included,otherwise,if,the,result,of,evaluating,message,available,byte,count,value,is,greater,than,0,the,portion,of,the,mllp,envelope,will,not,be,included,effectively,leaving,the,portion,of,the,mllp,envelope,out,of,every,n,th,message,param,exclude,start,of,block,modulus,exclude,on,every,n,th,message,0,never,excluded,1,always,excluded;public,void,set,exclude,start,of,block,modulus,int,exclude,start,of,block,modulus,if,0,exclude,start,of,block,modulus,this,exclude,start,of,block,modulus,0,else,this,exclude,start,of,block,modulus,exclude,start,of,block,modulus
MllpServerResource -> ClientSocketThread -> public void run();1451464990;Receives HL7 messages and replies with HL7 Acknowledgements.__The exact behaviour of this method is very configurable, allowing simulation of varies_error conditions.;public void run() {_            String localAddress = clientSocket.getLocalAddress().toString()__            String remoteAddress = clientSocket.getRemoteSocketAddress().toString()___            log.info("Handling Connection: {} -> {}", localAddress, remoteAddress)___            try {_                while (null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {_                    InputStream instream = clientSocket.getInputStream()__                    String parsedHL7Message = getMessage(instream)___                    if (null != parsedHL7Message && parsedHL7Message.length() > 0) {_                        ++messageCounter__                        if (disconnectBeforeAcknowledgement(messageCounter)) {_                            log.warn("Disconnecting before sending acknowledgement")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }__                        String acknowledgmentMessage___                        if (sendApplicationErrorAcknowledgement(messageCounter) || sendApplicationErrorAcknowledgement(parsedHL7Message)) {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AE")__                        } else if (sendApplicationRejectAcknowledgement(messageCounter) || sendApplicationRejectAcknowledgement(parsedHL7Message)) {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AR")__                        } else {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message)___                        }_                        BufferedOutputStream outstream = new BufferedOutputStream(clientSocket.getOutputStream())___                        if (sendOutOfBandData(messageCounter)) {_                            byte[] outOfBandDataBytes = "Out Of Band Hl7MessageGenerator".getBytes()__                            outstream.write(outOfBandDataBytes, 0, outOfBandDataBytes.length)___                        }_                        if (excludeStartOfBlock(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_START_OF_BLOCK")__                        } else {_                            outstream.write(START_OF_BLOCK)__                        }__                        if (excludeAcknowledgement(messageCounter)) {_                            log.info("NOT sending Acknowledgement body")__                        } else {_                            log.debug("Buffering Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                            byte[] ackBytes = acknowledgmentMessage.getBytes()__                            outstream.write(ackBytes, 0, ackBytes.length)__                        }__                        if (excludeEndOfBlock(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_END_OF_BLOCK")__                        } else {_                            outstream.write(END_OF_BLOCK)__                        }__                        if (excludeEndOfData(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_END_OF_DATA")__                        } else {_                            outstream.write(END_OF_DATA)__                        }__                        log.debug("Writing Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                        outstream.flush()___                        if (disconnectAfterAcknowledgement(messageCounter)) {_                            log.info("Closing Client")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }_                    }_                }_            } catch (IOException e) {_                String errorMessage = "Error whiling reading and writing to clientSocket"__                log.error(errorMessage, e)__                throw new MllpJUnitResourceException(errorMessage, e)__            } finally {_                try {_                    clientSocket.close()__                } catch (IOException e) {_                    String errorMessage = "Error whiling attempting to close to client Socket"__                    log.error(errorMessage, e)__                    throw new MllpJUnitResourceException(errorMessage, e)__                }_            }__            log.info("Connection Finished: {} -> {}", localAddress, remoteAddress)__        };receives,hl7,messages,and,replies,with,hl7,acknowledgements,the,exact,behaviour,of,this,method,is,very,configurable,allowing,simulation,of,varies,error,conditions;public,void,run,string,local,address,client,socket,get,local,address,to,string,string,remote,address,client,socket,get,remote,socket,address,to,string,log,info,handling,connection,local,address,remote,address,try,while,null,client,socket,client,socket,is,connected,client,socket,is,closed,input,stream,instream,client,socket,get,input,stream,string,parsed,hl7message,get,message,instream,if,null,parsed,hl7message,parsed,hl7message,length,0,message,counter,if,disconnect,before,acknowledgement,message,counter,log,warn,disconnecting,before,sending,acknowledgement,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,string,acknowledgment,message,if,send,application,error,acknowledgement,message,counter,send,application,error,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ae,else,if,send,application,reject,acknowledgement,message,counter,send,application,reject,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ar,else,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,buffered,output,stream,outstream,new,buffered,output,stream,client,socket,get,output,stream,if,send,out,of,band,data,message,counter,byte,out,of,band,data,bytes,out,of,band,hl7message,generator,get,bytes,outstream,write,out,of,band,data,bytes,0,out,of,band,data,bytes,length,if,exclude,start,of,block,message,counter,log,warn,not,sending,else,outstream,write,if,exclude,acknowledgement,message,counter,log,info,not,sending,acknowledgement,body,else,log,debug,buffering,acknowledgement,n,t,acknowledgment,message,replace,r,n,byte,ack,bytes,acknowledgment,message,get,bytes,outstream,write,ack,bytes,0,ack,bytes,length,if,exclude,end,of,block,message,counter,log,warn,not,sending,else,outstream,write,if,exclude,end,of,data,message,counter,log,warn,not,sending,else,outstream,write,log,debug,writing,acknowledgement,n,t,acknowledgment,message,replace,r,n,outstream,flush,if,disconnect,after,acknowledgement,message,counter,log,info,closing,client,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,catch,ioexception,e,string,error,message,error,whiling,reading,and,writing,to,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,finally,try,client,socket,close,catch,ioexception,e,string,error,message,error,whiling,attempting,to,close,to,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,log,info,connection,finished,local,address,remote,address
MllpServerResource -> ClientSocketThread -> public void run();1453968697;Receives HL7 messages and replies with HL7 Acknowledgements.__The exact behaviour of this method is very configurable, allowing simulation of varies_error conditions.;public void run() {_            String localAddress = clientSocket.getLocalAddress().toString()__            String remoteAddress = clientSocket.getRemoteSocketAddress().toString()___            log.info("Handling Connection: {} -> {}", localAddress, remoteAddress)___            try {_                while (!isInterrupted()  &&  null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {_                    InputStream instream__                    try {_                        instream = clientSocket.getInputStream()__                    } catch (IOException ioEx) {_                        if (clientSocket.isClosed()) {_                            log.debug( "Client socket was closed - ignoring exception", clientSocket)__                            break__                        } else {_                            throw new MllpJUnitResourceException( "Unexpected IOException encounted getting input stream", ioEx)__                        }_                    } catch (Exception unexpectedEx) {_                        throw new MllpJUnitResourceException( "Unexpected exception encounted getting input stream", unexpectedEx)__                    }_                    String parsedHL7Message = getMessage(instream)___                    if (null != parsedHL7Message && parsedHL7Message.length() > 0) {_                        ++messageCounter__                        if (disconnectBeforeAcknowledgement(messageCounter)) {_                            log.warn("Disconnecting before sending acknowledgement")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }__                        String acknowledgmentMessage___                        if (sendApplicationErrorAcknowledgement(messageCounter) || sendApplicationErrorAcknowledgement(parsedHL7Message)) {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AE")__                        } else if (sendApplicationRejectAcknowledgement(messageCounter) || sendApplicationRejectAcknowledgement(parsedHL7Message)) {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AR")__                        } else {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message)___                        }_                        BufferedOutputStream outstream = new BufferedOutputStream(clientSocket.getOutputStream())___                        if (sendOutOfBandData(messageCounter)) {_                            byte[] outOfBandDataBytes = "Out Of Band Hl7MessageGenerator".getBytes()__                            outstream.write(outOfBandDataBytes, 0, outOfBandDataBytes.length)___                        }_                        if (excludeStartOfBlock(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_START_OF_BLOCK")__                        } else {_                            outstream.write(START_OF_BLOCK)__                        }__                        if (excludeAcknowledgement(messageCounter)) {_                            log.info("NOT sending Acknowledgement body")__                        } else {_                            log.debug("Buffering Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                            byte[] ackBytes = acknowledgmentMessage.getBytes()__                            outstream.write(ackBytes, 0, ackBytes.length)__                        }__                        if (excludeEndOfBlock(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_END_OF_BLOCK")__                        } else {_                            outstream.write(END_OF_BLOCK)__                        }__                        if (excludeEndOfData(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_END_OF_DATA")__                        } else {_                            outstream.write(END_OF_DATA)__                        }__                        log.debug("Writing Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                        outstream.flush()___                        if (disconnectAfterAcknowledgement(messageCounter)) {_                            log.info("Closing Client")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }_                    }_                }_            } catch (IOException e) {_                String errorMessage = "Error whiling reading and writing to clientSocket"__                log.error(errorMessage, e)__                throw new MllpJUnitResourceException(errorMessage, e)__            } finally {_                try {_                    clientSocket.close()__                } catch (IOException e) {_                    String errorMessage = "Error whiling attempting to close to client Socket"__                    log.error(errorMessage, e)__                    throw new MllpJUnitResourceException(errorMessage, e)__                }_            }__            log.debug("Client Connection Finished: {} -> {}", localAddress, remoteAddress)__        };receives,hl7,messages,and,replies,with,hl7,acknowledgements,the,exact,behaviour,of,this,method,is,very,configurable,allowing,simulation,of,varies,error,conditions;public,void,run,string,local,address,client,socket,get,local,address,to,string,string,remote,address,client,socket,get,remote,socket,address,to,string,log,info,handling,connection,local,address,remote,address,try,while,is,interrupted,null,client,socket,client,socket,is,connected,client,socket,is,closed,input,stream,instream,try,instream,client,socket,get,input,stream,catch,ioexception,io,ex,if,client,socket,is,closed,log,debug,client,socket,was,closed,ignoring,exception,client,socket,break,else,throw,new,mllp,junit,resource,exception,unexpected,ioexception,encounted,getting,input,stream,io,ex,catch,exception,unexpected,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encounted,getting,input,stream,unexpected,ex,string,parsed,hl7message,get,message,instream,if,null,parsed,hl7message,parsed,hl7message,length,0,message,counter,if,disconnect,before,acknowledgement,message,counter,log,warn,disconnecting,before,sending,acknowledgement,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,string,acknowledgment,message,if,send,application,error,acknowledgement,message,counter,send,application,error,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ae,else,if,send,application,reject,acknowledgement,message,counter,send,application,reject,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ar,else,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,buffered,output,stream,outstream,new,buffered,output,stream,client,socket,get,output,stream,if,send,out,of,band,data,message,counter,byte,out,of,band,data,bytes,out,of,band,hl7message,generator,get,bytes,outstream,write,out,of,band,data,bytes,0,out,of,band,data,bytes,length,if,exclude,start,of,block,message,counter,log,warn,not,sending,else,outstream,write,if,exclude,acknowledgement,message,counter,log,info,not,sending,acknowledgement,body,else,log,debug,buffering,acknowledgement,n,t,acknowledgment,message,replace,r,n,byte,ack,bytes,acknowledgment,message,get,bytes,outstream,write,ack,bytes,0,ack,bytes,length,if,exclude,end,of,block,message,counter,log,warn,not,sending,else,outstream,write,if,exclude,end,of,data,message,counter,log,warn,not,sending,else,outstream,write,log,debug,writing,acknowledgement,n,t,acknowledgment,message,replace,r,n,outstream,flush,if,disconnect,after,acknowledgement,message,counter,log,info,closing,client,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,catch,ioexception,e,string,error,message,error,whiling,reading,and,writing,to,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,finally,try,client,socket,close,catch,ioexception,e,string,error,message,error,whiling,attempting,to,close,to,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,log,debug,client,connection,finished,local,address,remote,address
MllpServerResource -> ClientSocketThread -> public void run();1453968697;Receives HL7 messages and replies with HL7 Acknowledgements.__The exact behaviour of this method is very configurable, allowing simulation of varies_error conditions.;public void run() {_            String localAddress = clientSocket.getLocalAddress().toString()__            String remoteAddress = clientSocket.getRemoteSocketAddress().toString()___            log.info("Handling Connection: {} -> {}", localAddress, remoteAddress)___            try {_                while (!isInterrupted()  &&  null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {_                    InputStream instream__                    try {_                        instream = clientSocket.getInputStream()__                    } catch (IOException ioEx) {_                        if (clientSocket.isClosed()) {_                            log.debug( "Client socket was closed - ignoring exception", clientSocket)__                            break__                        } else {_                            throw new MllpJUnitResourceException( "Unexpected IOException encounted getting input stream", ioEx)__                        }_                    } catch (Exception unexpectedEx) {_                        throw new MllpJUnitResourceException( "Unexpected exception encounted getting input stream", unexpectedEx)__                    }_                    String parsedHL7Message = getMessage(instream)___                    if (null != parsedHL7Message && parsedHL7Message.length() > 0) {_                        ++messageCounter__                        if (disconnectBeforeAcknowledgement(messageCounter)) {_                            log.warn("Disconnecting before sending acknowledgement")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }__                        String acknowledgmentMessage___                        if (sendApplicationErrorAcknowledgement(messageCounter) || sendApplicationErrorAcknowledgement(parsedHL7Message)) {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AE")__                        } else if (sendApplicationRejectAcknowledgement(messageCounter) || sendApplicationRejectAcknowledgement(parsedHL7Message)) {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AR")__                        } else {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message)___                        }_                        BufferedOutputStream outstream = new BufferedOutputStream(clientSocket.getOutputStream())___                        if (sendOutOfBandData(messageCounter)) {_                            byte[] outOfBandDataBytes = "Out Of Band Hl7MessageGenerator".getBytes()__                            outstream.write(outOfBandDataBytes, 0, outOfBandDataBytes.length)___                        }_                        if (excludeStartOfBlock(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_START_OF_BLOCK")__                        } else {_                            outstream.write(START_OF_BLOCK)__                        }__                        if (excludeAcknowledgement(messageCounter)) {_                            log.info("NOT sending Acknowledgement body")__                        } else {_                            log.debug("Buffering Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                            byte[] ackBytes = acknowledgmentMessage.getBytes()__                            outstream.write(ackBytes, 0, ackBytes.length)__                        }__                        if (excludeEndOfBlock(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_END_OF_BLOCK")__                        } else {_                            outstream.write(END_OF_BLOCK)__                        }__                        if (excludeEndOfData(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_END_OF_DATA")__                        } else {_                            outstream.write(END_OF_DATA)__                        }__                        log.debug("Writing Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                        outstream.flush()___                        if (disconnectAfterAcknowledgement(messageCounter)) {_                            log.info("Closing Client")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }_                    }_                }_            } catch (IOException e) {_                String errorMessage = "Error whiling reading and writing to clientSocket"__                log.error(errorMessage, e)__                throw new MllpJUnitResourceException(errorMessage, e)__            } finally {_                try {_                    clientSocket.close()__                } catch (IOException e) {_                    String errorMessage = "Error whiling attempting to close to client Socket"__                    log.error(errorMessage, e)__                    throw new MllpJUnitResourceException(errorMessage, e)__                }_            }__            log.debug("Client Connection Finished: {} -> {}", localAddress, remoteAddress)__        };receives,hl7,messages,and,replies,with,hl7,acknowledgements,the,exact,behaviour,of,this,method,is,very,configurable,allowing,simulation,of,varies,error,conditions;public,void,run,string,local,address,client,socket,get,local,address,to,string,string,remote,address,client,socket,get,remote,socket,address,to,string,log,info,handling,connection,local,address,remote,address,try,while,is,interrupted,null,client,socket,client,socket,is,connected,client,socket,is,closed,input,stream,instream,try,instream,client,socket,get,input,stream,catch,ioexception,io,ex,if,client,socket,is,closed,log,debug,client,socket,was,closed,ignoring,exception,client,socket,break,else,throw,new,mllp,junit,resource,exception,unexpected,ioexception,encounted,getting,input,stream,io,ex,catch,exception,unexpected,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encounted,getting,input,stream,unexpected,ex,string,parsed,hl7message,get,message,instream,if,null,parsed,hl7message,parsed,hl7message,length,0,message,counter,if,disconnect,before,acknowledgement,message,counter,log,warn,disconnecting,before,sending,acknowledgement,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,string,acknowledgment,message,if,send,application,error,acknowledgement,message,counter,send,application,error,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ae,else,if,send,application,reject,acknowledgement,message,counter,send,application,reject,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ar,else,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,buffered,output,stream,outstream,new,buffered,output,stream,client,socket,get,output,stream,if,send,out,of,band,data,message,counter,byte,out,of,band,data,bytes,out,of,band,hl7message,generator,get,bytes,outstream,write,out,of,band,data,bytes,0,out,of,band,data,bytes,length,if,exclude,start,of,block,message,counter,log,warn,not,sending,else,outstream,write,if,exclude,acknowledgement,message,counter,log,info,not,sending,acknowledgement,body,else,log,debug,buffering,acknowledgement,n,t,acknowledgment,message,replace,r,n,byte,ack,bytes,acknowledgment,message,get,bytes,outstream,write,ack,bytes,0,ack,bytes,length,if,exclude,end,of,block,message,counter,log,warn,not,sending,else,outstream,write,if,exclude,end,of,data,message,counter,log,warn,not,sending,else,outstream,write,log,debug,writing,acknowledgement,n,t,acknowledgment,message,replace,r,n,outstream,flush,if,disconnect,after,acknowledgement,message,counter,log,info,closing,client,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,catch,ioexception,e,string,error,message,error,whiling,reading,and,writing,to,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,finally,try,client,socket,close,catch,ioexception,e,string,error,message,error,whiling,attempting,to,close,to,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,log,debug,client,connection,finished,local,address,remote,address
MllpServerResource -> ClientSocketThread -> public void run();1457097808;Receives HL7 messages and replies with HL7 Acknowledgements.__The exact behaviour of this method is very configurable, allowing simulation of varies_error conditions.;public void run() {_            String localAddress = clientSocket.getLocalAddress().toString()__            String remoteAddress = clientSocket.getRemoteSocketAddress().toString()___            log.info("Handling Connection: {} -> {}", localAddress, remoteAddress)___            try {_                while (!isInterrupted() && null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {_                    InputStream instream__                    try {_                        instream = clientSocket.getInputStream()__                    } catch (IOException ioEx) {_                        if (clientSocket.isClosed()) {_                            log.debug("Client socket was closed - ignoring exception", clientSocket)__                            break__                        } else {_                            throw new MllpJUnitResourceException("Unexpected IOException encounted getting input stream", ioEx)__                        }_                    } catch (Exception unexpectedEx) {_                        throw new MllpJUnitResourceException("Unexpected exception encounted getting input stream", unexpectedEx)__                    }_                    String parsedHL7Message = getMessage(instream)___                    if (null != parsedHL7Message && parsedHL7Message.length() > 0) {_                        ++messageCounter__                        if (disconnectBeforeAcknowledgement(messageCounter)) {_                            log.warn("Disconnecting before sending acknowledgement")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }__                        String acknowledgmentMessage___                        if (sendApplicationErrorAcknowledgement(messageCounter) || sendApplicationErrorAcknowledgement(parsedHL7Message)) {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AE")__                        } else if (sendApplicationRejectAcknowledgement(messageCounter) || sendApplicationRejectAcknowledgement(parsedHL7Message)) {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AR")__                        } else {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message)___                        }_                        BufferedOutputStream outstream = new BufferedOutputStream(clientSocket.getOutputStream())___                        if (sendOutOfBandData(messageCounter)) {_                            byte[] outOfBandDataBytes = "Out Of Band Hl7MessageGenerator".getBytes()__                            outstream.write(outOfBandDataBytes, 0, outOfBandDataBytes.length)___                        }_                        if (excludeStartOfBlock(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_START_OF_BLOCK")__                        } else {_                            outstream.write(START_OF_BLOCK)__                        }__                        if (excludeAcknowledgement(messageCounter)) {_                            log.info("NOT sending Acknowledgement body")__                        } else {_                            log.debug("Buffering Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                            byte[] ackBytes = acknowledgmentMessage.getBytes()__                            outstream.write(ackBytes, 0, ackBytes.length)__                        }__                        if (excludeEndOfBlock(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_END_OF_BLOCK")__                        } else {_                            outstream.write(END_OF_BLOCK)__                        }__                        if (excludeEndOfData(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_END_OF_DATA")__                        } else {_                            outstream.write(END_OF_DATA)__                        }__                        log.debug("Writing Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                        outstream.flush()___                        if (disconnectAfterAcknowledgement(messageCounter)) {_                            log.info("Closing Client")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }_                    }_                }_            } catch (IOException e) {_                String errorMessage = "Error whiling reading and writing to clientSocket"__                log.error(errorMessage, e)__                throw new MllpJUnitResourceException(errorMessage, e)__            } finally {_                try {_                    clientSocket.close()__                } catch (IOException e) {_                    String errorMessage = "Error whiling attempting to close to client Socket"__                    log.error(errorMessage, e)__                    throw new MllpJUnitResourceException(errorMessage, e)__                }_            }__            log.debug("Client Connection Finished: {} -> {}", localAddress, remoteAddress)__        };receives,hl7,messages,and,replies,with,hl7,acknowledgements,the,exact,behaviour,of,this,method,is,very,configurable,allowing,simulation,of,varies,error,conditions;public,void,run,string,local,address,client,socket,get,local,address,to,string,string,remote,address,client,socket,get,remote,socket,address,to,string,log,info,handling,connection,local,address,remote,address,try,while,is,interrupted,null,client,socket,client,socket,is,connected,client,socket,is,closed,input,stream,instream,try,instream,client,socket,get,input,stream,catch,ioexception,io,ex,if,client,socket,is,closed,log,debug,client,socket,was,closed,ignoring,exception,client,socket,break,else,throw,new,mllp,junit,resource,exception,unexpected,ioexception,encounted,getting,input,stream,io,ex,catch,exception,unexpected,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encounted,getting,input,stream,unexpected,ex,string,parsed,hl7message,get,message,instream,if,null,parsed,hl7message,parsed,hl7message,length,0,message,counter,if,disconnect,before,acknowledgement,message,counter,log,warn,disconnecting,before,sending,acknowledgement,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,string,acknowledgment,message,if,send,application,error,acknowledgement,message,counter,send,application,error,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ae,else,if,send,application,reject,acknowledgement,message,counter,send,application,reject,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ar,else,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,buffered,output,stream,outstream,new,buffered,output,stream,client,socket,get,output,stream,if,send,out,of,band,data,message,counter,byte,out,of,band,data,bytes,out,of,band,hl7message,generator,get,bytes,outstream,write,out,of,band,data,bytes,0,out,of,band,data,bytes,length,if,exclude,start,of,block,message,counter,log,warn,not,sending,else,outstream,write,if,exclude,acknowledgement,message,counter,log,info,not,sending,acknowledgement,body,else,log,debug,buffering,acknowledgement,n,t,acknowledgment,message,replace,r,n,byte,ack,bytes,acknowledgment,message,get,bytes,outstream,write,ack,bytes,0,ack,bytes,length,if,exclude,end,of,block,message,counter,log,warn,not,sending,else,outstream,write,if,exclude,end,of,data,message,counter,log,warn,not,sending,else,outstream,write,log,debug,writing,acknowledgement,n,t,acknowledgment,message,replace,r,n,outstream,flush,if,disconnect,after,acknowledgement,message,counter,log,info,closing,client,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,catch,ioexception,e,string,error,message,error,whiling,reading,and,writing,to,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,finally,try,client,socket,close,catch,ioexception,e,string,error,message,error,whiling,attempting,to,close,to,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,log,debug,client,connection,finished,local,address,remote,address
MllpServerResource -> ClientSocketThread -> public void run();1461916938;Receives HL7 messages and replies with HL7 Acknowledgements.__The exact behaviour of this method is very configurable, allowing simulation of varies_error conditions.;public void run() {_            String localAddress = clientSocket.getLocalAddress().toString()__            String remoteAddress = clientSocket.getRemoteSocketAddress().toString()___            log.info("Handling Connection: {} -> {}", localAddress, remoteAddress)___            try {_                while (!isInterrupted() && null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {_                    InputStream instream__                    try {_                        instream = clientSocket.getInputStream()__                    } catch (IOException ioEx) {_                        if (clientSocket.isClosed()) {_                            log.debug("Client socket was closed - ignoring exception", clientSocket)__                            break__                        } else {_                            throw new MllpJUnitResourceException("Unexpected IOException encounted getting input stream", ioEx)__                        }_                    } catch (Exception unexpectedEx) {_                        throw new MllpJUnitResourceException("Unexpected exception encounted getting input stream", unexpectedEx)__                    }_                    String parsedHL7Message = getMessage(instream)___                    if (null != parsedHL7Message && parsedHL7Message.length() > 0) {_                        ++messageCounter__                        if (disconnectBeforeAcknowledgement(messageCounter)) {_                            log.warn("Disconnecting before sending acknowledgement")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }__                        String acknowledgmentMessage___                        if (sendApplicationErrorAcknowledgement(messageCounter) || sendApplicationErrorAcknowledgement(parsedHL7Message)) {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AE")__                        } else if (sendApplicationRejectAcknowledgement(messageCounter) || sendApplicationRejectAcknowledgement(parsedHL7Message)) {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AR")__                        } else {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message)___                        }_                        BufferedOutputStream outstream = new BufferedOutputStream(clientSocket.getOutputStream())___                        if (sendOutOfBandData(messageCounter)) {_                            byte[] outOfBandDataBytes = "Out Of Band Hl7MessageGenerator".getBytes()__                            outstream.write(outOfBandDataBytes, 0, outOfBandDataBytes.length)___                        }_                        if (excludeStartOfBlock(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_START_OF_BLOCK")__                        } else {_                            outstream.write(START_OF_BLOCK)__                        }__                        if (excludeAcknowledgement(messageCounter)) {_                            log.info("NOT sending Acknowledgement body")__                        } else {_                            log.debug("Buffering Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                            byte[] ackBytes = acknowledgmentMessage.getBytes()__                            outstream.write(ackBytes, 0, ackBytes.length)__                        }__                        if (excludeEndOfBlock(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_END_OF_BLOCK")__                        } else {_                            outstream.write(END_OF_BLOCK)__                        }__                        if (excludeEndOfData(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_END_OF_DATA")__                        } else {_                            outstream.write(END_OF_DATA)__                        }__                        log.debug("Writing Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                        outstream.flush()___                        if (disconnectAfterAcknowledgement(messageCounter)) {_                            log.info("Closing Client")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }_                    }_                }_            } catch (IOException e) {_                String errorMessage = "Error whiling reading and writing to clientSocket"__                log.error(errorMessage, e)__                throw new MllpJUnitResourceException(errorMessage, e)__            } finally {_                try {_                    clientSocket.close()__                } catch (IOException e) {_                    String errorMessage = "Error whiling attempting to close to client Socket"__                    log.error(errorMessage, e)__                    throw new MllpJUnitResourceException(errorMessage, e)__                }_            }__            log.debug("Client Connection Finished: {} -> {}", localAddress, remoteAddress)__        };receives,hl7,messages,and,replies,with,hl7,acknowledgements,the,exact,behaviour,of,this,method,is,very,configurable,allowing,simulation,of,varies,error,conditions;public,void,run,string,local,address,client,socket,get,local,address,to,string,string,remote,address,client,socket,get,remote,socket,address,to,string,log,info,handling,connection,local,address,remote,address,try,while,is,interrupted,null,client,socket,client,socket,is,connected,client,socket,is,closed,input,stream,instream,try,instream,client,socket,get,input,stream,catch,ioexception,io,ex,if,client,socket,is,closed,log,debug,client,socket,was,closed,ignoring,exception,client,socket,break,else,throw,new,mllp,junit,resource,exception,unexpected,ioexception,encounted,getting,input,stream,io,ex,catch,exception,unexpected,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encounted,getting,input,stream,unexpected,ex,string,parsed,hl7message,get,message,instream,if,null,parsed,hl7message,parsed,hl7message,length,0,message,counter,if,disconnect,before,acknowledgement,message,counter,log,warn,disconnecting,before,sending,acknowledgement,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,string,acknowledgment,message,if,send,application,error,acknowledgement,message,counter,send,application,error,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ae,else,if,send,application,reject,acknowledgement,message,counter,send,application,reject,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ar,else,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,buffered,output,stream,outstream,new,buffered,output,stream,client,socket,get,output,stream,if,send,out,of,band,data,message,counter,byte,out,of,band,data,bytes,out,of,band,hl7message,generator,get,bytes,outstream,write,out,of,band,data,bytes,0,out,of,band,data,bytes,length,if,exclude,start,of,block,message,counter,log,warn,not,sending,else,outstream,write,if,exclude,acknowledgement,message,counter,log,info,not,sending,acknowledgement,body,else,log,debug,buffering,acknowledgement,n,t,acknowledgment,message,replace,r,n,byte,ack,bytes,acknowledgment,message,get,bytes,outstream,write,ack,bytes,0,ack,bytes,length,if,exclude,end,of,block,message,counter,log,warn,not,sending,else,outstream,write,if,exclude,end,of,data,message,counter,log,warn,not,sending,else,outstream,write,log,debug,writing,acknowledgement,n,t,acknowledgment,message,replace,r,n,outstream,flush,if,disconnect,after,acknowledgement,message,counter,log,info,closing,client,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,catch,ioexception,e,string,error,message,error,whiling,reading,and,writing,to,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,finally,try,client,socket,close,catch,ioexception,e,string,error,message,error,whiling,attempting,to,close,to,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,log,debug,client,connection,finished,local,address,remote,address
MllpServerResource -> ClientSocketThread -> public void run();1480882601;Receives HL7 messages and replies with HL7 Acknowledgements.__The exact behaviour of this method is very configurable, allowing simulation of varies_error conditions.;public void run() {_            String localAddress = clientSocket.getLocalAddress().toString()__            String remoteAddress = clientSocket.getRemoteSocketAddress().toString()___            log.info("Handling Connection: {} -> {}", localAddress, remoteAddress)___            try {_                while (!isInterrupted() && null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {_                    InputStream instream__                    try {_                        instream = clientSocket.getInputStream()__                    } catch (IOException ioEx) {_                        if (clientSocket.isClosed()) {_                            log.debug("Client socket was closed - ignoring exception", clientSocket)__                            break__                        } else {_                            throw new MllpJUnitResourceException("Unexpected IOException encounted getting input stream", ioEx)__                        }_                    } catch (Exception unexpectedEx) {_                        throw new MllpJUnitResourceException("Unexpected exception encounted getting input stream", unexpectedEx)__                    }_                    String parsedHL7Message = getMessage(instream)___                    if (null != parsedHL7Message && parsedHL7Message.length() > 0) {_                        ++messageCounter__                        if (disconnectBeforeAcknowledgement(messageCounter)) {_                            log.warn("Disconnecting before sending acknowledgement")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }__                        String acknowledgmentMessage___                        if (sendApplicationErrorAcknowledgement(messageCounter) || sendApplicationErrorAcknowledgement(parsedHL7Message)) {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AE")__                        } else if (sendApplicationRejectAcknowledgement(messageCounter) || sendApplicationRejectAcknowledgement(parsedHL7Message)) {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AR")__                        } else {_                            acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message)___                        }_                        BufferedOutputStream outstream = new BufferedOutputStream(clientSocket.getOutputStream())___                        if (sendOutOfBandData(messageCounter)) {_                            byte[] outOfBandDataBytes = "Out Of Band Hl7MessageGenerator".getBytes()__                            outstream.write(outOfBandDataBytes, 0, outOfBandDataBytes.length)___                        }_                        if (excludeStartOfBlock(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_START_OF_BLOCK")__                        } else {_                            outstream.write(START_OF_BLOCK)__                        }__                        if (excludeAcknowledgement(messageCounter)) {_                            log.info("NOT sending Acknowledgement body")__                        } else {_                            log.debug("Buffering Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                            byte[] ackBytes = acknowledgmentMessage.getBytes()__                            outstream.write(ackBytes, 0, ackBytes.length)__                        }__                        if (excludeEndOfBlock(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_END_OF_BLOCK")__                        } else {_                            outstream.write(END_OF_BLOCK)__                        }__                        if (excludeEndOfData(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_END_OF_DATA")__                        } else {_                            outstream.write(END_OF_DATA)__                        }__                        log.debug("Writing Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                        outstream.flush()___                        if (disconnectAfterAcknowledgement(messageCounter)) {_                            log.info("Closing Client")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }_                    }_                }_            } catch (IOException e) {_                String errorMessage = "Error whiling reading and writing to clientSocket"__                log.error(errorMessage, e)__                throw new MllpJUnitResourceException(errorMessage, e)__            } finally {_                try {_                    clientSocket.close()__                } catch (IOException e) {_                    String errorMessage = "Error whiling attempting to close to client Socket"__                    log.error(errorMessage, e)__                    throw new MllpJUnitResourceException(errorMessage, e)__                }_            }__            log.debug("Client Connection Finished: {} -> {}", localAddress, remoteAddress)__        };receives,hl7,messages,and,replies,with,hl7,acknowledgements,the,exact,behaviour,of,this,method,is,very,configurable,allowing,simulation,of,varies,error,conditions;public,void,run,string,local,address,client,socket,get,local,address,to,string,string,remote,address,client,socket,get,remote,socket,address,to,string,log,info,handling,connection,local,address,remote,address,try,while,is,interrupted,null,client,socket,client,socket,is,connected,client,socket,is,closed,input,stream,instream,try,instream,client,socket,get,input,stream,catch,ioexception,io,ex,if,client,socket,is,closed,log,debug,client,socket,was,closed,ignoring,exception,client,socket,break,else,throw,new,mllp,junit,resource,exception,unexpected,ioexception,encounted,getting,input,stream,io,ex,catch,exception,unexpected,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encounted,getting,input,stream,unexpected,ex,string,parsed,hl7message,get,message,instream,if,null,parsed,hl7message,parsed,hl7message,length,0,message,counter,if,disconnect,before,acknowledgement,message,counter,log,warn,disconnecting,before,sending,acknowledgement,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,string,acknowledgment,message,if,send,application,error,acknowledgement,message,counter,send,application,error,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ae,else,if,send,application,reject,acknowledgement,message,counter,send,application,reject,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ar,else,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,buffered,output,stream,outstream,new,buffered,output,stream,client,socket,get,output,stream,if,send,out,of,band,data,message,counter,byte,out,of,band,data,bytes,out,of,band,hl7message,generator,get,bytes,outstream,write,out,of,band,data,bytes,0,out,of,band,data,bytes,length,if,exclude,start,of,block,message,counter,log,warn,not,sending,else,outstream,write,if,exclude,acknowledgement,message,counter,log,info,not,sending,acknowledgement,body,else,log,debug,buffering,acknowledgement,n,t,acknowledgment,message,replace,r,n,byte,ack,bytes,acknowledgment,message,get,bytes,outstream,write,ack,bytes,0,ack,bytes,length,if,exclude,end,of,block,message,counter,log,warn,not,sending,else,outstream,write,if,exclude,end,of,data,message,counter,log,warn,not,sending,else,outstream,write,log,debug,writing,acknowledgement,n,t,acknowledgment,message,replace,r,n,outstream,flush,if,disconnect,after,acknowledgement,message,counter,log,info,closing,client,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,catch,ioexception,e,string,error,message,error,whiling,reading,and,writing,to,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,finally,try,client,socket,close,catch,ioexception,e,string,error,message,error,whiling,attempting,to,close,to,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,log,debug,client,connection,finished,local,address,remote,address
MllpServerResource -> ClientSocketThread -> public void run();1481829620;Receives HL7 messages and replies with HL7 Acknowledgements.__The exact behaviour of this method is very configurable, allowing simulation of varies_error conditions.;public void run() {_            String localAddress = clientSocket.getLocalAddress().toString()__            String remoteAddress = clientSocket.getRemoteSocketAddress().toString()___            log.info("Handling Connection: {} -> {}", localAddress, remoteAddress)___            try {_                while (!isInterrupted() && null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {_                    InputStream instream__                    try {_                        instream = clientSocket.getInputStream()__                    } catch (IOException ioEx) {_                        if (clientSocket.isClosed()) {_                            log.debug("Client socket was closed - ignoring exception", clientSocket)__                            break__                        } else {_                            throw new MllpJUnitResourceException("Unexpected IOException encounted getting input stream", ioEx)__                        }_                    } catch (Exception unexpectedEx) {_                        throw new MllpJUnitResourceException("Unexpected exception encounted getting input stream", unexpectedEx)__                    }_                    String parsedHL7Message__                    try {_                        parsedHL7Message = getMessage(instream)__                    } catch (SocketTimeoutException timeoutEx) {_                        log.info("Waiting for message from client")__                        continue__                    }__                    if (null != parsedHL7Message && parsedHL7Message.length() > 0) {_                        ++messageCounter__                        if (closeSocketBeforeAcknowledgement(messageCounter)) {_                            log.warn("Closing socket before sending acknowledgement")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }_                        if (resetSocketBeforeAcknowledgement(messageCounter)) {_                            log.warn("Resetting socket before sending acknowledgement")__                            try {_                                clientSocket.setSoLinger(true, 0)__                            } catch (IOException ioEx) {_                                log.warn("Ignoring IOException encountered setting SO_LINGER when prepareing to reset socket", ioEx)__                            }_                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }__                        String acknowledgmentMessage___                        if (acknowledgementString == null) {_                            if (sendApplicationErrorAcknowledgement(messageCounter) || sendApplicationErrorAcknowledgement(parsedHL7Message)) {_                                acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AE")__                            } else if (sendApplicationRejectAcknowledgement(messageCounter) || sendApplicationRejectAcknowledgement(parsedHL7Message)) {_                                acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AR")__                            } else {_                                acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message)__                            }_                        } else {_                            acknowledgmentMessage = acknowledgementString__                        }__                        BufferedOutputStream outstream = new BufferedOutputStream(clientSocket.getOutputStream())___                        if (sendOutOfBandData(messageCounter)) {_                            byte[] outOfBandDataBytes = "Out Of Band Hl7MessageGenerator".getBytes()__                            outstream.write(outOfBandDataBytes, 0, outOfBandDataBytes.length)__                        }__                        if (excludeStartOfBlock(messageCounter)) {_                            log.warn("NOT sending START_OF_BLOCK")__                        } else {_                            outstream.write(START_OF_BLOCK)__                            if (delayBeforeStartOfBlock > 0) {_                                uncheckedSleep(delayBeforeStartOfBlock)__                                uncheckedFlush(outstream)__                            }_                        }__                        if (excludeAcknowledgement(messageCounter)) {_                            log.info("NOT sending Acknowledgement body")__                        } else {_                            if (delayBeforeAcknowledgement > 0) {_                                uncheckedSleep(delayBeforeAcknowledgement)__                            }_                            log.debug("Buffering Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                            byte[] ackBytes = acknowledgmentMessage.getBytes()__                            if (delayDuringAcknowledgement > 0) {_                                int firstHalf = ackBytes.length / 2__                                outstream.write(ackBytes, 0, firstHalf)__                                uncheckedFlush(outstream)__                                uncheckedSleep(delayDuringAcknowledgement)__                                outstream.write(ackBytes, firstHalf, ackBytes.length - firstHalf)__                                uncheckedFlush(outstream)__                            } else {_                                outstream.write(ackBytes, 0, ackBytes.length)__                            }_                            if (delayAfterAcknowledgement > 0) {_                                uncheckedFlush(outstream)__                                uncheckedSleep(delayAfterAcknowledgement)__                            }_                        }__                        if (excludeEndOfBlock(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_END_OF_BLOCK")__                        } else {_                            outstream.write(END_OF_BLOCK)__                            if (delayAfterEndOfBlock > 0) {_                                uncheckedFlush(outstream)__                                uncheckedSleep(delayAfterEndOfBlock)__                            }_                        }__                        if (excludeEndOfData(messageCounter)) {_                            log.warn("NOT sending bMLLP_ENVELOPE_END_OF_DATA")__                        } else {_                            outstream.write(END_OF_DATA)__                        }__                        log.debug("Writing Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                        uncheckedFlush(outstream)___                        if (closeSocketAfterAcknowledgement(messageCounter)) {_                            log.info("Closing Client")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }_                    }_                }_            } catch (IOException e) {_                String errorMessage = "Error while reading and writing from clientSocket"__                log.error(errorMessage, e)__                throw new MllpJUnitResourceException(errorMessage, e)__            } finally {_                if (clientSocket != null) {_                    try {_                        clientSocket.close()__                    } catch (IOException e) {_                        String errorMessage = "Error while attempting to close to client Socket"__                        log.error(errorMessage, e)__                        throw new MllpJUnitResourceException(errorMessage, e)__                    }_                }_            }__            log.debug("Client Connection Finished: {} -> {}", localAddress, remoteAddress)__        };receives,hl7,messages,and,replies,with,hl7,acknowledgements,the,exact,behaviour,of,this,method,is,very,configurable,allowing,simulation,of,varies,error,conditions;public,void,run,string,local,address,client,socket,get,local,address,to,string,string,remote,address,client,socket,get,remote,socket,address,to,string,log,info,handling,connection,local,address,remote,address,try,while,is,interrupted,null,client,socket,client,socket,is,connected,client,socket,is,closed,input,stream,instream,try,instream,client,socket,get,input,stream,catch,ioexception,io,ex,if,client,socket,is,closed,log,debug,client,socket,was,closed,ignoring,exception,client,socket,break,else,throw,new,mllp,junit,resource,exception,unexpected,ioexception,encounted,getting,input,stream,io,ex,catch,exception,unexpected,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encounted,getting,input,stream,unexpected,ex,string,parsed,hl7message,try,parsed,hl7message,get,message,instream,catch,socket,timeout,exception,timeout,ex,log,info,waiting,for,message,from,client,continue,if,null,parsed,hl7message,parsed,hl7message,length,0,message,counter,if,close,socket,before,acknowledgement,message,counter,log,warn,closing,socket,before,sending,acknowledgement,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,if,reset,socket,before,acknowledgement,message,counter,log,warn,resetting,socket,before,sending,acknowledgement,try,client,socket,set,so,linger,true,0,catch,ioexception,io,ex,log,warn,ignoring,ioexception,encountered,setting,when,prepareing,to,reset,socket,io,ex,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,string,acknowledgment,message,if,acknowledgement,string,null,if,send,application,error,acknowledgement,message,counter,send,application,error,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ae,else,if,send,application,reject,acknowledgement,message,counter,send,application,reject,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ar,else,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,else,acknowledgment,message,acknowledgement,string,buffered,output,stream,outstream,new,buffered,output,stream,client,socket,get,output,stream,if,send,out,of,band,data,message,counter,byte,out,of,band,data,bytes,out,of,band,hl7message,generator,get,bytes,outstream,write,out,of,band,data,bytes,0,out,of,band,data,bytes,length,if,exclude,start,of,block,message,counter,log,warn,not,sending,else,outstream,write,if,delay,before,start,of,block,0,unchecked,sleep,delay,before,start,of,block,unchecked,flush,outstream,if,exclude,acknowledgement,message,counter,log,info,not,sending,acknowledgement,body,else,if,delay,before,acknowledgement,0,unchecked,sleep,delay,before,acknowledgement,log,debug,buffering,acknowledgement,n,t,acknowledgment,message,replace,r,n,byte,ack,bytes,acknowledgment,message,get,bytes,if,delay,during,acknowledgement,0,int,first,half,ack,bytes,length,2,outstream,write,ack,bytes,0,first,half,unchecked,flush,outstream,unchecked,sleep,delay,during,acknowledgement,outstream,write,ack,bytes,first,half,ack,bytes,length,first,half,unchecked,flush,outstream,else,outstream,write,ack,bytes,0,ack,bytes,length,if,delay,after,acknowledgement,0,unchecked,flush,outstream,unchecked,sleep,delay,after,acknowledgement,if,exclude,end,of,block,message,counter,log,warn,not,sending,else,outstream,write,if,delay,after,end,of,block,0,unchecked,flush,outstream,unchecked,sleep,delay,after,end,of,block,if,exclude,end,of,data,message,counter,log,warn,not,sending,else,outstream,write,log,debug,writing,acknowledgement,n,t,acknowledgment,message,replace,r,n,unchecked,flush,outstream,if,close,socket,after,acknowledgement,message,counter,log,info,closing,client,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,catch,ioexception,e,string,error,message,error,while,reading,and,writing,from,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,finally,if,client,socket,null,try,client,socket,close,catch,ioexception,e,string,error,message,error,while,attempting,to,close,to,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,log,debug,client,connection,finished,local,address,remote,address
MllpServerResource -> ClientSocketThread -> public void run();1515779403;Receives HL7 messages and replies with HL7 Acknowledgements.__The exact behaviour of this method is very configurable, allowing simulation of varies error conditions.;public void run() {_            String localAddress = clientSocket.getLocalAddress().toString()__            String remoteAddress = clientSocket.getRemoteSocketAddress().toString()___            log.info("Handling Connection: {} -> {}", localAddress, remoteAddress)___            try {_                while (!isInterrupted() && null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {_                    InputStream instream__                    try {_                        instream = clientSocket.getInputStream()__                    } catch (IOException ioEx) {_                        if (clientSocket.isClosed()) {_                            log.debug("Client socket was closed - ignoring exception", clientSocket)__                            break__                        } else {_                            throw new MllpJUnitResourceException("Unexpected IOException encounted getting input stream", ioEx)__                        }_                    } catch (Exception unexpectedEx) {_                        throw new MllpJUnitResourceException("Unexpected exception encounted getting input stream", unexpectedEx)__                    }_                    String parsedHL7Message__                    try {_                        parsedHL7Message = getMessage(instream)__                    } catch (SocketTimeoutException timeoutEx) {_                        log.info("Waiting for message from client")__                        continue__                    }__                    if (null != parsedHL7Message && parsedHL7Message.length() > 0) {_                        ++messageCounter__                        if (closeSocketBeforeAcknowledgement(messageCounter)) {_                            log.warn("Closing socket before sending acknowledgement")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }_                        if (resetSocketBeforeAcknowledgement(messageCounter)) {_                            log.warn("Resetting socket before sending acknowledgement")__                            try {_                                clientSocket.setSoLinger(true, 0)__                            } catch (IOException ioEx) {_                                log.warn("Ignoring IOException encountered setting SO_LINGER when prepareing to reset socket", ioEx)__                            }_                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }__                        String acknowledgmentMessage___                        if (acknowledgementString == null) {_                            if (sendApplicationErrorAcknowledgement(messageCounter) || sendApplicationErrorAcknowledgement(parsedHL7Message)) {_                                acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AE")__                            } else if (sendApplicationRejectAcknowledgement(messageCounter) || sendApplicationRejectAcknowledgement(parsedHL7Message)) {_                                acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AR")__                            } else {_                                acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message)__                            }_                        } else {_                            acknowledgmentMessage = acknowledgementString__                        }__                        BufferedOutputStream outstream = new BufferedOutputStream(clientSocket.getOutputStream())___                        if (sendOutOfBandData(messageCounter)) {_                            byte[] outOfBandDataBytes = "Out Of Band Hl7TestMessageGenerator".getBytes()__                            outstream.write(outOfBandDataBytes, 0, outOfBandDataBytes.length)__                        }__                        if (excludeStartOfBlock(messageCounter)) {_                            log.warn("NOT sending START_OF_BLOCK")__                        } else {_                            outstream.write(MllpProtocolConstants.START_OF_BLOCK)__                            if (delayBeforeStartOfBlock > 0) {_                                uncheckedSleep(delayBeforeStartOfBlock)__                                uncheckedFlush(outstream)__                            }_                        }__                        if (excludeAcknowledgement(messageCounter)) {_                            log.info("NOT sending Acknowledgement body")__                        } else {_                            if (delayBeforeAcknowledgement > 0) {_                                uncheckedSleep(delayBeforeAcknowledgement)__                            }_                            log.debug("Buffering Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                            byte[] ackBytes = acknowledgmentMessage.getBytes()__                            if (delayDuringAcknowledgement > 0) {_                                int firstHalf = ackBytes.length / 2__                                outstream.write(ackBytes, 0, firstHalf)__                                uncheckedFlush(outstream)__                                uncheckedSleep(delayDuringAcknowledgement)__                                outstream.write(ackBytes, firstHalf, ackBytes.length - firstHalf)__                                uncheckedFlush(outstream)__                            } else {_                                outstream.write(ackBytes, 0, ackBytes.length)__                            }_                            if (delayAfterAcknowledgement > 0) {_                                uncheckedFlush(outstream)__                                uncheckedSleep(delayAfterAcknowledgement)__                            }_                        }__                        if (excludeEndOfBlock(messageCounter)) {_                            log.warn("NOT sending END_OF_BLOCK")__                        } else {_                            outstream.write(MllpProtocolConstants.END_OF_BLOCK)__                            if (delayAfterEndOfBlock > 0) {_                                uncheckedFlush(outstream)__                                uncheckedSleep(delayAfterEndOfBlock)__                            }_                        }__                        if (excludeEndOfData(messageCounter)) {_                            log.warn("NOT sending END_OF_DATA")__                        } else {_                            outstream.write(MllpProtocolConstants.END_OF_DATA)__                        }__                        log.debug("Writing Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                        uncheckedFlush(outstream)___                        if (closeSocketAfterAcknowledgement(messageCounter)) {_                            log.info("Closing Client")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }_                    }_                }_            } catch (IOException e) {_                String errorMessage = "Error while reading and writing from clientSocket"__                log.error(errorMessage, e)__                throw new MllpJUnitResourceException(errorMessage, e)__            } finally {_                if (clientSocket != null) {_                    try {_                        clientSocket.close()__                    } catch (IOException e) {_                        String errorMessage = "Error while attempting to close to client Socket"__                        log.error(errorMessage, e)__                        throw new MllpJUnitResourceException(errorMessage, e)__                    }_                }_            }__            log.debug("Client Connection Finished: {} -> {}", localAddress, remoteAddress)__        };receives,hl7,messages,and,replies,with,hl7,acknowledgements,the,exact,behaviour,of,this,method,is,very,configurable,allowing,simulation,of,varies,error,conditions;public,void,run,string,local,address,client,socket,get,local,address,to,string,string,remote,address,client,socket,get,remote,socket,address,to,string,log,info,handling,connection,local,address,remote,address,try,while,is,interrupted,null,client,socket,client,socket,is,connected,client,socket,is,closed,input,stream,instream,try,instream,client,socket,get,input,stream,catch,ioexception,io,ex,if,client,socket,is,closed,log,debug,client,socket,was,closed,ignoring,exception,client,socket,break,else,throw,new,mllp,junit,resource,exception,unexpected,ioexception,encounted,getting,input,stream,io,ex,catch,exception,unexpected,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encounted,getting,input,stream,unexpected,ex,string,parsed,hl7message,try,parsed,hl7message,get,message,instream,catch,socket,timeout,exception,timeout,ex,log,info,waiting,for,message,from,client,continue,if,null,parsed,hl7message,parsed,hl7message,length,0,message,counter,if,close,socket,before,acknowledgement,message,counter,log,warn,closing,socket,before,sending,acknowledgement,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,if,reset,socket,before,acknowledgement,message,counter,log,warn,resetting,socket,before,sending,acknowledgement,try,client,socket,set,so,linger,true,0,catch,ioexception,io,ex,log,warn,ignoring,ioexception,encountered,setting,when,prepareing,to,reset,socket,io,ex,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,string,acknowledgment,message,if,acknowledgement,string,null,if,send,application,error,acknowledgement,message,counter,send,application,error,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ae,else,if,send,application,reject,acknowledgement,message,counter,send,application,reject,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ar,else,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,else,acknowledgment,message,acknowledgement,string,buffered,output,stream,outstream,new,buffered,output,stream,client,socket,get,output,stream,if,send,out,of,band,data,message,counter,byte,out,of,band,data,bytes,out,of,band,hl7test,message,generator,get,bytes,outstream,write,out,of,band,data,bytes,0,out,of,band,data,bytes,length,if,exclude,start,of,block,message,counter,log,warn,not,sending,else,outstream,write,mllp,protocol,constants,if,delay,before,start,of,block,0,unchecked,sleep,delay,before,start,of,block,unchecked,flush,outstream,if,exclude,acknowledgement,message,counter,log,info,not,sending,acknowledgement,body,else,if,delay,before,acknowledgement,0,unchecked,sleep,delay,before,acknowledgement,log,debug,buffering,acknowledgement,n,t,acknowledgment,message,replace,r,n,byte,ack,bytes,acknowledgment,message,get,bytes,if,delay,during,acknowledgement,0,int,first,half,ack,bytes,length,2,outstream,write,ack,bytes,0,first,half,unchecked,flush,outstream,unchecked,sleep,delay,during,acknowledgement,outstream,write,ack,bytes,first,half,ack,bytes,length,first,half,unchecked,flush,outstream,else,outstream,write,ack,bytes,0,ack,bytes,length,if,delay,after,acknowledgement,0,unchecked,flush,outstream,unchecked,sleep,delay,after,acknowledgement,if,exclude,end,of,block,message,counter,log,warn,not,sending,else,outstream,write,mllp,protocol,constants,if,delay,after,end,of,block,0,unchecked,flush,outstream,unchecked,sleep,delay,after,end,of,block,if,exclude,end,of,data,message,counter,log,warn,not,sending,else,outstream,write,mllp,protocol,constants,log,debug,writing,acknowledgement,n,t,acknowledgment,message,replace,r,n,unchecked,flush,outstream,if,close,socket,after,acknowledgement,message,counter,log,info,closing,client,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,catch,ioexception,e,string,error,message,error,while,reading,and,writing,from,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,finally,if,client,socket,null,try,client,socket,close,catch,ioexception,e,string,error,message,error,while,attempting,to,close,to,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,log,debug,client,connection,finished,local,address,remote,address
MllpServerResource -> ClientSocketThread -> public void run();1524063106;Receives HL7 messages and replies with HL7 Acknowledgements.__The exact behaviour of this method is very configurable, allowing simulation of varies error conditions.;public void run() {_            String localAddress = clientSocket.getLocalAddress().toString()__            String remoteAddress = clientSocket.getRemoteSocketAddress().toString()___            log.info("Handling Connection: {} -> {}", localAddress, remoteAddress)___            try {_                while (!isInterrupted() && null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {_                    InputStream instream__                    try {_                        instream = clientSocket.getInputStream()__                    } catch (IOException ioEx) {_                        if (clientSocket.isClosed()) {_                            log.debug("Client socket was closed - ignoring exception", clientSocket)__                            break__                        } else {_                            throw new MllpJUnitResourceException("Unexpected IOException encounted getting input stream", ioEx)__                        }_                    } catch (Exception unexpectedEx) {_                        throw new MllpJUnitResourceException("Unexpected exception encounted getting input stream", unexpectedEx)__                    }_                    String parsedHL7Message__                    try {_                        parsedHL7Message = getMessage(instream)__                    } catch (SocketTimeoutException timeoutEx) {_                        log.info("Waiting for message from client")__                        continue__                    }__                    if (null != parsedHL7Message && parsedHL7Message.length() > 0) {_                        ++messageCounter__                        if (closeSocketBeforeAcknowledgement(messageCounter)) {_                            log.warn("Closing socket before sending acknowledgement")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }_                        if (resetSocketBeforeAcknowledgement(messageCounter)) {_                            log.warn("Resetting socket before sending acknowledgement")__                            try {_                                clientSocket.setSoLinger(true, 0)__                            } catch (IOException ioEx) {_                                log.warn("Ignoring IOException encountered setting SO_LINGER when prepareing to reset socket", ioEx)__                            }_                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }__                        String acknowledgmentMessage___                        if (acknowledgementString == null) {_                            if (sendApplicationErrorAcknowledgement(messageCounter) || sendApplicationErrorAcknowledgement(parsedHL7Message)) {_                                acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AE")__                            } else if (sendApplicationRejectAcknowledgement(messageCounter) || sendApplicationRejectAcknowledgement(parsedHL7Message)) {_                                acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AR")__                            } else {_                                acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message)__                            }_                        } else {_                            acknowledgmentMessage = acknowledgementString__                        }__                        BufferedOutputStream outstream = new BufferedOutputStream(clientSocket.getOutputStream())___                        if (sendOutOfBandData(messageCounter)) {_                            byte[] outOfBandDataBytes = "Out Of Band Hl7TestMessageGenerator".getBytes()__                            outstream.write(outOfBandDataBytes, 0, outOfBandDataBytes.length)__                        }__                        if (excludeStartOfBlock(messageCounter)) {_                            log.warn("NOT sending START_OF_BLOCK")__                        } else {_                            outstream.write(MllpProtocolConstants.START_OF_BLOCK)__                            if (delayBeforeStartOfBlock > 0) {_                                uncheckedSleep(delayBeforeStartOfBlock)__                                uncheckedFlush(outstream)__                            }_                        }__                        if (excludeAcknowledgement(messageCounter)) {_                            log.info("NOT sending Acknowledgement body")__                        } else {_                            if (delayBeforeAcknowledgement > 0) {_                                uncheckedSleep(delayBeforeAcknowledgement)__                            }_                            log.debug("Buffering Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                            byte[] ackBytes = acknowledgmentMessage.getBytes()__                            if (delayDuringAcknowledgement > 0) {_                                int firstHalf = ackBytes.length / 2__                                outstream.write(ackBytes, 0, firstHalf)__                                uncheckedFlush(outstream)__                                uncheckedSleep(delayDuringAcknowledgement)__                                outstream.write(ackBytes, firstHalf, ackBytes.length - firstHalf)__                                uncheckedFlush(outstream)__                            } else {_                                outstream.write(ackBytes, 0, ackBytes.length)__                            }_                            if (delayAfterAcknowledgement > 0) {_                                uncheckedFlush(outstream)__                                uncheckedSleep(delayAfterAcknowledgement)__                            }_                        }__                        if (excludeEndOfBlock(messageCounter)) {_                            log.warn("NOT sending END_OF_BLOCK")__                        } else {_                            outstream.write(MllpProtocolConstants.END_OF_BLOCK)__                            if (delayAfterEndOfBlock > 0) {_                                uncheckedFlush(outstream)__                                uncheckedSleep(delayAfterEndOfBlock)__                            }_                        }__                        if (excludeEndOfData(messageCounter)) {_                            log.warn("NOT sending END_OF_DATA")__                        } else {_                            outstream.write(MllpProtocolConstants.END_OF_DATA)__                        }__                        log.debug("Writing Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                        uncheckedFlush(outstream)___                        if (closeSocketAfterAcknowledgement(messageCounter)) {_                            log.info("Closing Client")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }_                    }_                }_            } catch (IOException e) {_                String errorMessage = "Error while reading and writing from clientSocket"__                log.error(errorMessage, e)__                throw new MllpJUnitResourceException(errorMessage, e)__            } finally {_                if (clientSocket != null) {_                    try {_                        clientSocket.close()__                    } catch (IOException e) {_                        String errorMessage = "Error while attempting to close to client Socket"__                        log.error(errorMessage, e)__                        throw new MllpJUnitResourceException(errorMessage, e)__                    }_                }_            }__            log.debug("Client Connection Finished: {} -> {}", localAddress, remoteAddress)__        };receives,hl7,messages,and,replies,with,hl7,acknowledgements,the,exact,behaviour,of,this,method,is,very,configurable,allowing,simulation,of,varies,error,conditions;public,void,run,string,local,address,client,socket,get,local,address,to,string,string,remote,address,client,socket,get,remote,socket,address,to,string,log,info,handling,connection,local,address,remote,address,try,while,is,interrupted,null,client,socket,client,socket,is,connected,client,socket,is,closed,input,stream,instream,try,instream,client,socket,get,input,stream,catch,ioexception,io,ex,if,client,socket,is,closed,log,debug,client,socket,was,closed,ignoring,exception,client,socket,break,else,throw,new,mllp,junit,resource,exception,unexpected,ioexception,encounted,getting,input,stream,io,ex,catch,exception,unexpected,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encounted,getting,input,stream,unexpected,ex,string,parsed,hl7message,try,parsed,hl7message,get,message,instream,catch,socket,timeout,exception,timeout,ex,log,info,waiting,for,message,from,client,continue,if,null,parsed,hl7message,parsed,hl7message,length,0,message,counter,if,close,socket,before,acknowledgement,message,counter,log,warn,closing,socket,before,sending,acknowledgement,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,if,reset,socket,before,acknowledgement,message,counter,log,warn,resetting,socket,before,sending,acknowledgement,try,client,socket,set,so,linger,true,0,catch,ioexception,io,ex,log,warn,ignoring,ioexception,encountered,setting,when,prepareing,to,reset,socket,io,ex,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,string,acknowledgment,message,if,acknowledgement,string,null,if,send,application,error,acknowledgement,message,counter,send,application,error,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ae,else,if,send,application,reject,acknowledgement,message,counter,send,application,reject,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ar,else,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,else,acknowledgment,message,acknowledgement,string,buffered,output,stream,outstream,new,buffered,output,stream,client,socket,get,output,stream,if,send,out,of,band,data,message,counter,byte,out,of,band,data,bytes,out,of,band,hl7test,message,generator,get,bytes,outstream,write,out,of,band,data,bytes,0,out,of,band,data,bytes,length,if,exclude,start,of,block,message,counter,log,warn,not,sending,else,outstream,write,mllp,protocol,constants,if,delay,before,start,of,block,0,unchecked,sleep,delay,before,start,of,block,unchecked,flush,outstream,if,exclude,acknowledgement,message,counter,log,info,not,sending,acknowledgement,body,else,if,delay,before,acknowledgement,0,unchecked,sleep,delay,before,acknowledgement,log,debug,buffering,acknowledgement,n,t,acknowledgment,message,replace,r,n,byte,ack,bytes,acknowledgment,message,get,bytes,if,delay,during,acknowledgement,0,int,first,half,ack,bytes,length,2,outstream,write,ack,bytes,0,first,half,unchecked,flush,outstream,unchecked,sleep,delay,during,acknowledgement,outstream,write,ack,bytes,first,half,ack,bytes,length,first,half,unchecked,flush,outstream,else,outstream,write,ack,bytes,0,ack,bytes,length,if,delay,after,acknowledgement,0,unchecked,flush,outstream,unchecked,sleep,delay,after,acknowledgement,if,exclude,end,of,block,message,counter,log,warn,not,sending,else,outstream,write,mllp,protocol,constants,if,delay,after,end,of,block,0,unchecked,flush,outstream,unchecked,sleep,delay,after,end,of,block,if,exclude,end,of,data,message,counter,log,warn,not,sending,else,outstream,write,mllp,protocol,constants,log,debug,writing,acknowledgement,n,t,acknowledgment,message,replace,r,n,unchecked,flush,outstream,if,close,socket,after,acknowledgement,message,counter,log,info,closing,client,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,catch,ioexception,e,string,error,message,error,while,reading,and,writing,from,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,finally,if,client,socket,null,try,client,socket,close,catch,ioexception,e,string,error,message,error,while,attempting,to,close,to,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,log,debug,client,connection,finished,local,address,remote,address
MllpServerResource -> ClientSocketThread -> public void run();1536605520;Receives HL7 messages and replies with HL7 Acknowledgements.__The exact behaviour of this method is very configurable, allowing simulation of varies error conditions.;public void run() {_            String localAddress = clientSocket.getLocalAddress().toString()__            String remoteAddress = clientSocket.getRemoteSocketAddress().toString()___            log.info("Handling Connection: {} -> {}", localAddress, remoteAddress)___            try {_                while (!isInterrupted() && null != clientSocket && clientSocket.isConnected() && !clientSocket.isClosed()) {_                    InputStream instream__                    try {_                        instream = clientSocket.getInputStream()__                    } catch (IOException ioEx) {_                        if (clientSocket.isClosed()) {_                            log.debug("Client socket was closed - ignoring exception", clientSocket)__                            break__                        } else {_                            throw new MllpJUnitResourceException("Unexpected IOException encounted getting input stream", ioEx)__                        }_                    } catch (Exception unexpectedEx) {_                        throw new MllpJUnitResourceException("Unexpected exception encounted getting input stream", unexpectedEx)__                    }_                    String parsedHL7Message__                    try {_                        parsedHL7Message = getMessage(instream)__                    } catch (SocketTimeoutException timeoutEx) {_                        log.info("Waiting for message from client")__                        continue__                    }__                    if (null != parsedHL7Message && parsedHL7Message.length() > 0) {_                        ++messageCounter__                        if (closeSocketBeforeAcknowledgement(messageCounter)) {_                            log.warn("Closing socket before sending acknowledgement")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }_                        if (resetSocketBeforeAcknowledgement(messageCounter)) {_                            log.warn("Resetting socket before sending acknowledgement")__                            try {_                                clientSocket.setSoLinger(true, 0)__                            } catch (IOException ioEx) {_                                log.warn("Ignoring IOException encountered setting SO_LINGER when prepareing to reset socket", ioEx)__                            }_                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }__                        String acknowledgmentMessage___                        if (acknowledgementString == null) {_                            if (sendApplicationErrorAcknowledgement(messageCounter) || sendApplicationErrorAcknowledgement(parsedHL7Message)) {_                                acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AE")__                            } else if (sendApplicationRejectAcknowledgement(messageCounter) || sendApplicationRejectAcknowledgement(parsedHL7Message)) {_                                acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message, "AR")__                            } else {_                                acknowledgmentMessage = generateAcknowledgementMessage(parsedHL7Message)__                            }_                        } else {_                            acknowledgmentMessage = acknowledgementString__                        }__                        BufferedOutputStream outstream = new BufferedOutputStream(clientSocket.getOutputStream())___                        if (sendOutOfBandData(messageCounter)) {_                            byte[] outOfBandDataBytes = "Out Of Band Hl7TestMessageGenerator".getBytes()__                            outstream.write(outOfBandDataBytes, 0, outOfBandDataBytes.length)__                        }__                        if (excludeStartOfBlock(messageCounter)) {_                            log.warn("NOT sending START_OF_BLOCK")__                        } else {_                            outstream.write(MllpProtocolConstants.START_OF_BLOCK)__                            if (delayBeforeStartOfBlock > 0) {_                                uncheckedSleep(delayBeforeStartOfBlock)__                                uncheckedFlush(outstream)__                            }_                        }__                        if (excludeAcknowledgement(messageCounter)) {_                            log.info("NOT sending Acknowledgement body")__                        } else {_                            if (delayBeforeAcknowledgement > 0) {_                                uncheckedSleep(delayBeforeAcknowledgement)__                            }_                            log.debug("Buffering Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                            byte[] ackBytes = acknowledgmentMessage.getBytes()__                            if (delayDuringAcknowledgement > 0) {_                                int firstHalf = ackBytes.length / 2__                                outstream.write(ackBytes, 0, firstHalf)__                                uncheckedFlush(outstream)__                                uncheckedSleep(delayDuringAcknowledgement)__                                outstream.write(ackBytes, firstHalf, ackBytes.length - firstHalf)__                                uncheckedFlush(outstream)__                            } else {_                                outstream.write(ackBytes, 0, ackBytes.length)__                            }_                            if (delayAfterAcknowledgement > 0) {_                                uncheckedFlush(outstream)__                                uncheckedSleep(delayAfterAcknowledgement)__                            }_                        }__                        if (excludeEndOfBlock(messageCounter)) {_                            log.warn("NOT sending END_OF_BLOCK")__                        } else {_                            outstream.write(MllpProtocolConstants.END_OF_BLOCK)__                            if (delayAfterEndOfBlock > 0) {_                                uncheckedFlush(outstream)__                                uncheckedSleep(delayAfterEndOfBlock)__                            }_                        }__                        if (excludeEndOfData(messageCounter)) {_                            log.warn("NOT sending END_OF_DATA")__                        } else {_                            outstream.write(MllpProtocolConstants.END_OF_DATA)__                        }__                        log.debug("Writing Acknowledgement\n\t{}", acknowledgmentMessage.replace('\r', '\n'))__                        uncheckedFlush(outstream)___                        if (closeSocketAfterAcknowledgement(messageCounter)) {_                            log.info("Closing Client")__                            clientSocket.shutdownInput()__                            clientSocket.shutdownOutput()__                            clientSocket.close()__                            break__                        }_                    }_                }_            } catch (IOException e) {_                String errorMessage = "Error while reading and writing from clientSocket"__                log.error(errorMessage, e)__                throw new MllpJUnitResourceException(errorMessage, e)__            } finally {_                if (clientSocket != null) {_                    try {_                        clientSocket.close()__                    } catch (IOException e) {_                        String errorMessage = "Error while attempting to close to client Socket"__                        log.error(errorMessage, e)__                        throw new MllpJUnitResourceException(errorMessage, e)__                    }_                }_            }__            log.debug("Client Connection Finished: {} -> {}", localAddress, remoteAddress)__        };receives,hl7,messages,and,replies,with,hl7,acknowledgements,the,exact,behaviour,of,this,method,is,very,configurable,allowing,simulation,of,varies,error,conditions;public,void,run,string,local,address,client,socket,get,local,address,to,string,string,remote,address,client,socket,get,remote,socket,address,to,string,log,info,handling,connection,local,address,remote,address,try,while,is,interrupted,null,client,socket,client,socket,is,connected,client,socket,is,closed,input,stream,instream,try,instream,client,socket,get,input,stream,catch,ioexception,io,ex,if,client,socket,is,closed,log,debug,client,socket,was,closed,ignoring,exception,client,socket,break,else,throw,new,mllp,junit,resource,exception,unexpected,ioexception,encounted,getting,input,stream,io,ex,catch,exception,unexpected,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encounted,getting,input,stream,unexpected,ex,string,parsed,hl7message,try,parsed,hl7message,get,message,instream,catch,socket,timeout,exception,timeout,ex,log,info,waiting,for,message,from,client,continue,if,null,parsed,hl7message,parsed,hl7message,length,0,message,counter,if,close,socket,before,acknowledgement,message,counter,log,warn,closing,socket,before,sending,acknowledgement,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,if,reset,socket,before,acknowledgement,message,counter,log,warn,resetting,socket,before,sending,acknowledgement,try,client,socket,set,so,linger,true,0,catch,ioexception,io,ex,log,warn,ignoring,ioexception,encountered,setting,when,prepareing,to,reset,socket,io,ex,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,string,acknowledgment,message,if,acknowledgement,string,null,if,send,application,error,acknowledgement,message,counter,send,application,error,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ae,else,if,send,application,reject,acknowledgement,message,counter,send,application,reject,acknowledgement,parsed,hl7message,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,ar,else,acknowledgment,message,generate,acknowledgement,message,parsed,hl7message,else,acknowledgment,message,acknowledgement,string,buffered,output,stream,outstream,new,buffered,output,stream,client,socket,get,output,stream,if,send,out,of,band,data,message,counter,byte,out,of,band,data,bytes,out,of,band,hl7test,message,generator,get,bytes,outstream,write,out,of,band,data,bytes,0,out,of,band,data,bytes,length,if,exclude,start,of,block,message,counter,log,warn,not,sending,else,outstream,write,mllp,protocol,constants,if,delay,before,start,of,block,0,unchecked,sleep,delay,before,start,of,block,unchecked,flush,outstream,if,exclude,acknowledgement,message,counter,log,info,not,sending,acknowledgement,body,else,if,delay,before,acknowledgement,0,unchecked,sleep,delay,before,acknowledgement,log,debug,buffering,acknowledgement,n,t,acknowledgment,message,replace,r,n,byte,ack,bytes,acknowledgment,message,get,bytes,if,delay,during,acknowledgement,0,int,first,half,ack,bytes,length,2,outstream,write,ack,bytes,0,first,half,unchecked,flush,outstream,unchecked,sleep,delay,during,acknowledgement,outstream,write,ack,bytes,first,half,ack,bytes,length,first,half,unchecked,flush,outstream,else,outstream,write,ack,bytes,0,ack,bytes,length,if,delay,after,acknowledgement,0,unchecked,flush,outstream,unchecked,sleep,delay,after,acknowledgement,if,exclude,end,of,block,message,counter,log,warn,not,sending,else,outstream,write,mllp,protocol,constants,if,delay,after,end,of,block,0,unchecked,flush,outstream,unchecked,sleep,delay,after,end,of,block,if,exclude,end,of,data,message,counter,log,warn,not,sending,else,outstream,write,mllp,protocol,constants,log,debug,writing,acknowledgement,n,t,acknowledgment,message,replace,r,n,unchecked,flush,outstream,if,close,socket,after,acknowledgement,message,counter,log,info,closing,client,client,socket,shutdown,input,client,socket,shutdown,output,client,socket,close,break,catch,ioexception,e,string,error,message,error,while,reading,and,writing,from,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,finally,if,client,socket,null,try,client,socket,close,catch,ioexception,e,string,error,message,error,while,attempting,to,close,to,client,socket,log,error,error,message,e,throw,new,mllp,junit,resource,exception,error,message,e,log,debug,client,connection,finished,local,address,remote,address
MllpServerResource -> AcceptSocketThread -> public void setAcceptTimeout(int acceptTimeout);1515779403;Enable/disable a timeout while waiting for a TCP connection, in milliseconds. With this option set to a_non-zero timeout, the AcceptSocketThread will block for only this amount of time while_waiting for a tcp connection. If the timeout expires and raiseExceptionOnAcceptTimeout is set_to true, a MllpJUnitResourceTimeoutException is raised. Otherwise, the AcceptSocketThread will_continue to poll for new TCP connections.__@param acceptTimeout the timeout in milliseconds - zero is interpreted as an infinite timeout;public void setAcceptTimeout(int acceptTimeout) {_            this.acceptTimeout = acceptTimeout__        };enable,disable,a,timeout,while,waiting,for,a,tcp,connection,in,milliseconds,with,this,option,set,to,a,non,zero,timeout,the,accept,socket,thread,will,block,for,only,this,amount,of,time,while,waiting,for,a,tcp,connection,if,the,timeout,expires,and,raise,exception,on,accept,timeout,is,set,to,true,a,mllp,junit,resource,timeout,exception,is,raised,otherwise,the,accept,socket,thread,will,continue,to,poll,for,new,tcp,connections,param,accept,timeout,the,timeout,in,milliseconds,zero,is,interpreted,as,an,infinite,timeout;public,void,set,accept,timeout,int,accept,timeout,this,accept,timeout,accept,timeout
MllpServerResource -> AcceptSocketThread -> public void setAcceptTimeout(int acceptTimeout);1524063106;Enable/disable a timeout while waiting for a TCP connection, in milliseconds. With this option set to a_non-zero timeout, the AcceptSocketThread will block for only this amount of time while_waiting for a tcp connection. If the timeout expires and raiseExceptionOnAcceptTimeout is set_to true, a MllpJUnitResourceTimeoutException is raised. Otherwise, the AcceptSocketThread will_continue to poll for new TCP connections.__@param acceptTimeout the timeout in milliseconds - zero is interpreted as an infinite timeout;public void setAcceptTimeout(int acceptTimeout) {_            this.acceptTimeout = acceptTimeout__        };enable,disable,a,timeout,while,waiting,for,a,tcp,connection,in,milliseconds,with,this,option,set,to,a,non,zero,timeout,the,accept,socket,thread,will,block,for,only,this,amount,of,time,while,waiting,for,a,tcp,connection,if,the,timeout,expires,and,raise,exception,on,accept,timeout,is,set,to,true,a,mllp,junit,resource,timeout,exception,is,raised,otherwise,the,accept,socket,thread,will,continue,to,poll,for,new,tcp,connections,param,accept,timeout,the,timeout,in,milliseconds,zero,is,interpreted,as,an,infinite,timeout;public,void,set,accept,timeout,int,accept,timeout,this,accept,timeout,accept,timeout
MllpServerResource -> AcceptSocketThread -> public void setAcceptTimeout(int acceptTimeout);1536605520;Enable/disable a timeout while waiting for a TCP connection, in milliseconds. With this option set to a_non-zero timeout, the AcceptSocketThread will block for only this amount of time while_waiting for a tcp connection. If the timeout expires and raiseExceptionOnAcceptTimeout is set_to true, a MllpJUnitResourceTimeoutException is raised. Otherwise, the AcceptSocketThread will_continue to poll for new TCP connections.__@param acceptTimeout the timeout in milliseconds - zero is interpreted as an infinite timeout;public void setAcceptTimeout(int acceptTimeout) {_            this.acceptTimeout = acceptTimeout__        };enable,disable,a,timeout,while,waiting,for,a,tcp,connection,in,milliseconds,with,this,option,set,to,a,non,zero,timeout,the,accept,socket,thread,will,block,for,only,this,amount,of,time,while,waiting,for,a,tcp,connection,if,the,timeout,expires,and,raise,exception,on,accept,timeout,is,set,to,true,a,mllp,junit,resource,timeout,exception,is,raised,otherwise,the,accept,socket,thread,will,continue,to,poll,for,new,tcp,connections,param,accept,timeout,the,timeout,in,milliseconds,zero,is,interpreted,as,an,infinite,timeout;public,void,set,accept,timeout,int,accept,timeout,this,accept,timeout,accept,timeout
MllpServerResource -> protected String generateAcknowledgement(String hl7Message, String acknowledgementCode);1481829620;Generates a HL7 Application Acknowledgement__@param hl7Message          HL7 message that is being acknowledged_@param acknowledgementCode AA, AE or AR_@return a HL7 Application Acknowledgement;protected String generateAcknowledgement(String hl7Message, String acknowledgementCode) {_        final String defaulNackMessage =_                "MSH|^~\\&|||||||NACK||P|2.2" + SEGMENT_DELIMITER_                        + "MSA|AR|" + SEGMENT_DELIMITER_                        + MESSAGE_TERMINATOR___        if (hl7Message == null) {_            log.error("Invalid HL7 message for parsing operation. Please check your inputs")__            return defaulNackMessage__        }__        if (!("AA".equals(acknowledgementCode) || "AE".equals(acknowledgementCode) || "AR".equals(acknowledgementCode))) {_            throw new IllegalArgumentException("Acknowledgemnt Code must be AA, AE or AR: " + acknowledgementCode)__        }__        String messageControlId___        int endOfMshSegment = hl7Message.indexOf(SEGMENT_DELIMITER)__        if (-1 != endOfMshSegment) {_            String mshSegment = hl7Message.substring(0, endOfMshSegment)__            char fieldSeparator = mshSegment.charAt(3)__            String fieldSeparatorPattern = Pattern.quote("" + fieldSeparator)__            String[] mshFields = mshSegment.split(fieldSeparatorPattern)__            if (mshFields.length == 0) {_                log.error("Failed to split MSH Segment into fields")__            } else {_                StringBuilder ackBuilder = new StringBuilder(mshSegment.length() + 25)__                _                ackBuilder_                        .append(mshFields[0]).append(fieldSeparator)_                        .append(mshFields[1]).append(fieldSeparator)_                        .append(mshFields[4]).append(fieldSeparator)_                        .append(mshFields[5]).append(fieldSeparator)_                        .append(mshFields[2]).append(fieldSeparator)_                        .append(mshFields[3]).append(fieldSeparator)_                        .append(mshFields[6]).append(fieldSeparator)_                        .append(mshFields[7]).append(fieldSeparator)_                        .append("ACK")_                        .append(mshFields[8].substring(3))__                for (int i = 9_ i < mshFields.length_ ++i) {_                    ackBuilder.append(fieldSeparator).append(mshFields[i])__                }_                _                int emptyFieldIndex = mshSegment.length() - 1__                if (fieldSeparator == mshSegment.charAt(mshSegment.length() - 1)) {_                    ackBuilder.append(fieldSeparator)__                    while (emptyFieldIndex >= 1 && mshSegment.charAt(emptyFieldIndex) == mshSegment.charAt(emptyFieldIndex - 1)) {_                        ackBuilder.append(fieldSeparator)__                        --emptyFieldIndex__                    }_                }_                ackBuilder.append(SEGMENT_DELIMITER)___                _                ackBuilder_                        .append("MSA").append(fieldSeparator)_                        .append(acknowledgementCode).append(fieldSeparator)_                        .append(mshFields[9]).append(fieldSeparator)_                        .append(SEGMENT_DELIMITER)___                _                ackBuilder.append(MESSAGE_TERMINATOR)___                return ackBuilder.toString()__            }_        } else {_            log.error("Failed to find the end of the  MSH Segment")__        }__        return null__    };generates,a,hl7,application,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,param,acknowledgement,code,aa,ae,or,ar,return,a,hl7,application,acknowledgement;protected,string,generate,acknowledgement,string,hl7message,string,acknowledgement,code,final,string,defaul,nack,message,msh,nack,p,2,2,msa,ar,if,hl7message,null,log,error,invalid,hl7,message,for,parsing,operation,please,check,your,inputs,return,defaul,nack,message,if,aa,equals,acknowledgement,code,ae,equals,acknowledgement,code,ar,equals,acknowledgement,code,throw,new,illegal,argument,exception,acknowledgemnt,code,must,be,aa,ae,or,ar,acknowledgement,code,string,message,control,id,int,end,of,msh,segment,hl7message,index,of,if,1,end,of,msh,segment,string,msh,segment,hl7message,substring,0,end,of,msh,segment,char,field,separator,msh,segment,char,at,3,string,field,separator,pattern,pattern,quote,field,separator,string,msh,fields,msh,segment,split,field,separator,pattern,if,msh,fields,length,0,log,error,failed,to,split,msh,segment,into,fields,else,string,builder,ack,builder,new,string,builder,msh,segment,length,25,ack,builder,append,msh,fields,0,append,field,separator,append,msh,fields,1,append,field,separator,append,msh,fields,4,append,field,separator,append,msh,fields,5,append,field,separator,append,msh,fields,2,append,field,separator,append,msh,fields,3,append,field,separator,append,msh,fields,6,append,field,separator,append,msh,fields,7,append,field,separator,append,ack,append,msh,fields,8,substring,3,for,int,i,9,i,msh,fields,length,i,ack,builder,append,field,separator,append,msh,fields,i,int,empty,field,index,msh,segment,length,1,if,field,separator,msh,segment,char,at,msh,segment,length,1,ack,builder,append,field,separator,while,empty,field,index,1,msh,segment,char,at,empty,field,index,msh,segment,char,at,empty,field,index,1,ack,builder,append,field,separator,empty,field,index,ack,builder,append,ack,builder,append,msa,append,field,separator,append,acknowledgement,code,append,field,separator,append,msh,fields,9,append,field,separator,append,ack,builder,append,return,ack,builder,to,string,else,log,error,failed,to,find,the,end,of,the,msh,segment,return,null
MllpServerResource -> protected String generateAcknowledgement(String hl7Message, String acknowledgementCode);1515779403;Generates a HL7 Application Acknowledgement__@param hl7Message          HL7 message that is being acknowledged_@param acknowledgementCode AA, AE or AR__@return a HL7 Application Acknowledgement;protected String generateAcknowledgement(String hl7Message, String acknowledgementCode) {_        final String defaulNackMessage =_            "MSH|^~\\&|||||||NACK||P|2.2" + MllpProtocolConstants.SEGMENT_DELIMITER_                + "MSA|AR|" + MllpProtocolConstants.SEGMENT_DELIMITER_                + MllpProtocolConstants.MESSAGE_TERMINATOR___        if (hl7Message == null) {_            log.error("Invalid HL7 message for parsing operation. Please check your inputs")__            return defaulNackMessage__        }__        if (!("AA".equals(acknowledgementCode) || "AE".equals(acknowledgementCode) || "AR".equals(acknowledgementCode))) {_            throw new IllegalArgumentException("Acknowledgemnt Code must be AA, AE or AR: " + acknowledgementCode)__        }__        String messageControlId___        int endOfMshSegment = hl7Message.indexOf(MllpProtocolConstants.SEGMENT_DELIMITER)__        if (-1 != endOfMshSegment) {_            String mshSegment = hl7Message.substring(0, endOfMshSegment)__            char fieldSeparator = mshSegment.charAt(3)__            String fieldSeparatorPattern = Pattern.quote("" + fieldSeparator)__            String[] mshFields = mshSegment.split(fieldSeparatorPattern)__            if (mshFields.length == 0) {_                log.error("Failed to split MSH Segment into fields")__            } else {_                StringBuilder ackBuilder = new StringBuilder(mshSegment.length() + 25)__                _                ackBuilder_                    .append(mshFields[0]).append(fieldSeparator)_                    .append(mshFields[1]).append(fieldSeparator)_                    .append(mshFields[4]).append(fieldSeparator)_                    .append(mshFields[5]).append(fieldSeparator)_                    .append(mshFields[2]).append(fieldSeparator)_                    .append(mshFields[3]).append(fieldSeparator)_                    .append(mshFields[6]).append(fieldSeparator)_                    .append(mshFields[7]).append(fieldSeparator)_                    .append("ACK")_                    .append(mshFields[8].substring(3))__                for (int i = 9_ i < mshFields.length_ ++i) {_                    ackBuilder.append(fieldSeparator).append(mshFields[i])__                }_                _                int emptyFieldIndex = mshSegment.length() - 1__                if (fieldSeparator == mshSegment.charAt(mshSegment.length() - 1)) {_                    ackBuilder.append(fieldSeparator)__                    while (emptyFieldIndex >= 1 && mshSegment.charAt(emptyFieldIndex) == mshSegment.charAt(emptyFieldIndex - 1)) {_                        ackBuilder.append(fieldSeparator)__                        --emptyFieldIndex__                    }_                }_                ackBuilder.append(MllpProtocolConstants.SEGMENT_DELIMITER)___                _                ackBuilder_                    .append("MSA").append(fieldSeparator)_                    .append(acknowledgementCode).append(fieldSeparator)_                    .append(mshFields[9]).append(fieldSeparator)_                    .append(MllpProtocolConstants.SEGMENT_DELIMITER)___                _                ackBuilder.append(MllpProtocolConstants.MESSAGE_TERMINATOR)___                return ackBuilder.toString()__            }_        } else {_            log.error("Failed to find the end of the  MSH Segment")__        }__        return null__    };generates,a,hl7,application,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,param,acknowledgement,code,aa,ae,or,ar,return,a,hl7,application,acknowledgement;protected,string,generate,acknowledgement,string,hl7message,string,acknowledgement,code,final,string,defaul,nack,message,msh,nack,p,2,2,mllp,protocol,constants,msa,ar,mllp,protocol,constants,mllp,protocol,constants,if,hl7message,null,log,error,invalid,hl7,message,for,parsing,operation,please,check,your,inputs,return,defaul,nack,message,if,aa,equals,acknowledgement,code,ae,equals,acknowledgement,code,ar,equals,acknowledgement,code,throw,new,illegal,argument,exception,acknowledgemnt,code,must,be,aa,ae,or,ar,acknowledgement,code,string,message,control,id,int,end,of,msh,segment,hl7message,index,of,mllp,protocol,constants,if,1,end,of,msh,segment,string,msh,segment,hl7message,substring,0,end,of,msh,segment,char,field,separator,msh,segment,char,at,3,string,field,separator,pattern,pattern,quote,field,separator,string,msh,fields,msh,segment,split,field,separator,pattern,if,msh,fields,length,0,log,error,failed,to,split,msh,segment,into,fields,else,string,builder,ack,builder,new,string,builder,msh,segment,length,25,ack,builder,append,msh,fields,0,append,field,separator,append,msh,fields,1,append,field,separator,append,msh,fields,4,append,field,separator,append,msh,fields,5,append,field,separator,append,msh,fields,2,append,field,separator,append,msh,fields,3,append,field,separator,append,msh,fields,6,append,field,separator,append,msh,fields,7,append,field,separator,append,ack,append,msh,fields,8,substring,3,for,int,i,9,i,msh,fields,length,i,ack,builder,append,field,separator,append,msh,fields,i,int,empty,field,index,msh,segment,length,1,if,field,separator,msh,segment,char,at,msh,segment,length,1,ack,builder,append,field,separator,while,empty,field,index,1,msh,segment,char,at,empty,field,index,msh,segment,char,at,empty,field,index,1,ack,builder,append,field,separator,empty,field,index,ack,builder,append,mllp,protocol,constants,ack,builder,append,msa,append,field,separator,append,acknowledgement,code,append,field,separator,append,msh,fields,9,append,field,separator,append,mllp,protocol,constants,ack,builder,append,mllp,protocol,constants,return,ack,builder,to,string,else,log,error,failed,to,find,the,end,of,the,msh,segment,return,null
MllpServerResource -> protected String generateAcknowledgement(String hl7Message, String acknowledgementCode);1524063106;Generates a HL7 Application Acknowledgement__@param hl7Message          HL7 message that is being acknowledged_@param acknowledgementCode AA, AE or AR__@return a HL7 Application Acknowledgement;protected String generateAcknowledgement(String hl7Message, String acknowledgementCode) {_        final String defaulNackMessage =_            "MSH|^~\\&|||||||NACK||P|2.2" + MllpProtocolConstants.SEGMENT_DELIMITER_                + "MSA|AR|" + MllpProtocolConstants.SEGMENT_DELIMITER_                + MllpProtocolConstants.MESSAGE_TERMINATOR___        if (hl7Message == null) {_            log.error("Invalid HL7 message for parsing operation. Please check your inputs")__            return defaulNackMessage__        }__        if (!("AA".equals(acknowledgementCode) || "AE".equals(acknowledgementCode) || "AR".equals(acknowledgementCode))) {_            throw new IllegalArgumentException("Acknowledgemnt Code must be AA, AE or AR: " + acknowledgementCode)__        }__        int endOfMshSegment = hl7Message.indexOf(MllpProtocolConstants.SEGMENT_DELIMITER)__        if (-1 != endOfMshSegment) {_            String mshSegment = hl7Message.substring(0, endOfMshSegment)__            char fieldSeparator = mshSegment.charAt(3)__            String fieldSeparatorPattern = Pattern.quote("" + fieldSeparator)__            String[] mshFields = mshSegment.split(fieldSeparatorPattern)__            if (mshFields.length == 0) {_                log.error("Failed to split MSH Segment into fields")__            } else {_                StringBuilder ackBuilder = new StringBuilder(mshSegment.length() + 25)__                _                ackBuilder_                    .append(mshFields[0]).append(fieldSeparator)_                    .append(mshFields[1]).append(fieldSeparator)_                    .append(mshFields[4]).append(fieldSeparator)_                    .append(mshFields[5]).append(fieldSeparator)_                    .append(mshFields[2]).append(fieldSeparator)_                    .append(mshFields[3]).append(fieldSeparator)_                    .append(mshFields[6]).append(fieldSeparator)_                    .append(mshFields[7]).append(fieldSeparator)_                    .append("ACK")_                    .append(mshFields[8].substring(3))__                for (int i = 9_ i < mshFields.length_ ++i) {_                    ackBuilder.append(fieldSeparator).append(mshFields[i])__                }_                _                int emptyFieldIndex = mshSegment.length() - 1__                if (fieldSeparator == mshSegment.charAt(mshSegment.length() - 1)) {_                    ackBuilder.append(fieldSeparator)__                    while (emptyFieldIndex >= 1 && mshSegment.charAt(emptyFieldIndex) == mshSegment.charAt(emptyFieldIndex - 1)) {_                        ackBuilder.append(fieldSeparator)__                        --emptyFieldIndex__                    }_                }_                ackBuilder.append(MllpProtocolConstants.SEGMENT_DELIMITER)___                _                ackBuilder_                    .append("MSA").append(fieldSeparator)_                    .append(acknowledgementCode).append(fieldSeparator)_                    .append(mshFields[9]).append(fieldSeparator)_                    .append(MllpProtocolConstants.SEGMENT_DELIMITER)___                _                ackBuilder.append(MllpProtocolConstants.MESSAGE_TERMINATOR)___                return ackBuilder.toString()__            }_        } else {_            log.error("Failed to find the end of the  MSH Segment")__        }__        return null__    };generates,a,hl7,application,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,param,acknowledgement,code,aa,ae,or,ar,return,a,hl7,application,acknowledgement;protected,string,generate,acknowledgement,string,hl7message,string,acknowledgement,code,final,string,defaul,nack,message,msh,nack,p,2,2,mllp,protocol,constants,msa,ar,mllp,protocol,constants,mllp,protocol,constants,if,hl7message,null,log,error,invalid,hl7,message,for,parsing,operation,please,check,your,inputs,return,defaul,nack,message,if,aa,equals,acknowledgement,code,ae,equals,acknowledgement,code,ar,equals,acknowledgement,code,throw,new,illegal,argument,exception,acknowledgemnt,code,must,be,aa,ae,or,ar,acknowledgement,code,int,end,of,msh,segment,hl7message,index,of,mllp,protocol,constants,if,1,end,of,msh,segment,string,msh,segment,hl7message,substring,0,end,of,msh,segment,char,field,separator,msh,segment,char,at,3,string,field,separator,pattern,pattern,quote,field,separator,string,msh,fields,msh,segment,split,field,separator,pattern,if,msh,fields,length,0,log,error,failed,to,split,msh,segment,into,fields,else,string,builder,ack,builder,new,string,builder,msh,segment,length,25,ack,builder,append,msh,fields,0,append,field,separator,append,msh,fields,1,append,field,separator,append,msh,fields,4,append,field,separator,append,msh,fields,5,append,field,separator,append,msh,fields,2,append,field,separator,append,msh,fields,3,append,field,separator,append,msh,fields,6,append,field,separator,append,msh,fields,7,append,field,separator,append,ack,append,msh,fields,8,substring,3,for,int,i,9,i,msh,fields,length,i,ack,builder,append,field,separator,append,msh,fields,i,int,empty,field,index,msh,segment,length,1,if,field,separator,msh,segment,char,at,msh,segment,length,1,ack,builder,append,field,separator,while,empty,field,index,1,msh,segment,char,at,empty,field,index,msh,segment,char,at,empty,field,index,1,ack,builder,append,field,separator,empty,field,index,ack,builder,append,mllp,protocol,constants,ack,builder,append,msa,append,field,separator,append,acknowledgement,code,append,field,separator,append,msh,fields,9,append,field,separator,append,mllp,protocol,constants,ack,builder,append,mllp,protocol,constants,return,ack,builder,to,string,else,log,error,failed,to,find,the,end,of,the,msh,segment,return,null
MllpServerResource -> protected String generateAcknowledgement(String hl7Message, String acknowledgementCode);1536605520;Generates a HL7 Application Acknowledgement__@param hl7Message          HL7 message that is being acknowledged_@param acknowledgementCode AA, AE or AR__@return a HL7 Application Acknowledgement;protected String generateAcknowledgement(String hl7Message, String acknowledgementCode) {_        final String defaulNackMessage =_            "MSH|^~\\&|||||||NACK||P|2.2" + MllpProtocolConstants.SEGMENT_DELIMITER_                + "MSA|AR|" + MllpProtocolConstants.SEGMENT_DELIMITER_                + MllpProtocolConstants.MESSAGE_TERMINATOR___        if (hl7Message == null) {_            log.error("Invalid HL7 message for parsing operation. Please check your inputs")__            return defaulNackMessage__        }__        if (!("AA".equals(acknowledgementCode) || "AE".equals(acknowledgementCode) || "AR".equals(acknowledgementCode))) {_            throw new IllegalArgumentException("Acknowledgemnt Code must be AA, AE or AR: " + acknowledgementCode)__        }__        int endOfMshSegment = hl7Message.indexOf(MllpProtocolConstants.SEGMENT_DELIMITER)__        if (-1 != endOfMshSegment) {_            String mshSegment = hl7Message.substring(0, endOfMshSegment)__            char fieldSeparator = mshSegment.charAt(3)__            String fieldSeparatorPattern = Pattern.quote("" + fieldSeparator)__            String[] mshFields = mshSegment.split(fieldSeparatorPattern)__            if (mshFields.length == 0) {_                log.error("Failed to split MSH Segment into fields")__            } else {_                StringBuilder ackBuilder = new StringBuilder(mshSegment.length() + 25)__                _                ackBuilder_                    .append(mshFields[0]).append(fieldSeparator)_                    .append(mshFields[1]).append(fieldSeparator)_                    .append(mshFields[4]).append(fieldSeparator)_                    .append(mshFields[5]).append(fieldSeparator)_                    .append(mshFields[2]).append(fieldSeparator)_                    .append(mshFields[3]).append(fieldSeparator)_                    .append(mshFields[6]).append(fieldSeparator)_                    .append(mshFields[7]).append(fieldSeparator)_                    .append("ACK")_                    .append(mshFields[8].substring(3))__                for (int i = 9_ i < mshFields.length_ ++i) {_                    ackBuilder.append(fieldSeparator).append(mshFields[i])__                }_                _                int emptyFieldIndex = mshSegment.length() - 1__                if (fieldSeparator == mshSegment.charAt(mshSegment.length() - 1)) {_                    ackBuilder.append(fieldSeparator)__                    while (emptyFieldIndex >= 1 && mshSegment.charAt(emptyFieldIndex) == mshSegment.charAt(emptyFieldIndex - 1)) {_                        ackBuilder.append(fieldSeparator)__                        --emptyFieldIndex__                    }_                }_                ackBuilder.append(MllpProtocolConstants.SEGMENT_DELIMITER)___                _                ackBuilder_                    .append("MSA").append(fieldSeparator)_                    .append(acknowledgementCode).append(fieldSeparator)_                    .append(mshFields[9]).append(fieldSeparator)_                    .append(MllpProtocolConstants.SEGMENT_DELIMITER)___                _                ackBuilder.append(MllpProtocolConstants.MESSAGE_TERMINATOR)___                return ackBuilder.toString()__            }_        } else {_            log.error("Failed to find the end of the  MSH Segment")__        }__        return null__    };generates,a,hl7,application,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,param,acknowledgement,code,aa,ae,or,ar,return,a,hl7,application,acknowledgement;protected,string,generate,acknowledgement,string,hl7message,string,acknowledgement,code,final,string,defaul,nack,message,msh,nack,p,2,2,mllp,protocol,constants,msa,ar,mllp,protocol,constants,mllp,protocol,constants,if,hl7message,null,log,error,invalid,hl7,message,for,parsing,operation,please,check,your,inputs,return,defaul,nack,message,if,aa,equals,acknowledgement,code,ae,equals,acknowledgement,code,ar,equals,acknowledgement,code,throw,new,illegal,argument,exception,acknowledgemnt,code,must,be,aa,ae,or,ar,acknowledgement,code,int,end,of,msh,segment,hl7message,index,of,mllp,protocol,constants,if,1,end,of,msh,segment,string,msh,segment,hl7message,substring,0,end,of,msh,segment,char,field,separator,msh,segment,char,at,3,string,field,separator,pattern,pattern,quote,field,separator,string,msh,fields,msh,segment,split,field,separator,pattern,if,msh,fields,length,0,log,error,failed,to,split,msh,segment,into,fields,else,string,builder,ack,builder,new,string,builder,msh,segment,length,25,ack,builder,append,msh,fields,0,append,field,separator,append,msh,fields,1,append,field,separator,append,msh,fields,4,append,field,separator,append,msh,fields,5,append,field,separator,append,msh,fields,2,append,field,separator,append,msh,fields,3,append,field,separator,append,msh,fields,6,append,field,separator,append,msh,fields,7,append,field,separator,append,ack,append,msh,fields,8,substring,3,for,int,i,9,i,msh,fields,length,i,ack,builder,append,field,separator,append,msh,fields,i,int,empty,field,index,msh,segment,length,1,if,field,separator,msh,segment,char,at,msh,segment,length,1,ack,builder,append,field,separator,while,empty,field,index,1,msh,segment,char,at,empty,field,index,msh,segment,char,at,empty,field,index,1,ack,builder,append,field,separator,empty,field,index,ack,builder,append,mllp,protocol,constants,ack,builder,append,msa,append,field,separator,append,acknowledgement,code,append,field,separator,append,msh,fields,9,append,field,separator,append,mllp,protocol,constants,ack,builder,append,mllp,protocol,constants,return,ack,builder,to,string,else,log,error,failed,to,find,the,end,of,the,msh,segment,return,null
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode);1451464990;Generates a HL7 Application Acknowledgement__@param hl7Message          HL7 message that is being acknowledged_@param acknowledgementCode AA, AE or AR_@return a HL7 Application Acknowledgement;private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode) {_            final String defaulNackMessage =_                    "MSH|^~\\&|||||||NACK||P|2.2" + SEGMENT_DELIMITER_                            + "MSA|AR|" + SEGMENT_DELIMITER_                            + MESSAGE_TERMINATOR___            if (hl7Message == null) {_                log.error("Invalid HL7 message for parsing operation. Please check your inputs")__                return defaulNackMessage__            }__            if (!("AA".equals(acknowledgementCode) || "AE".equals(acknowledgementCode) || "AR".equals(acknowledgementCode))) {_                throw new IllegalArgumentException("Acknowledgemnt Code must be AA, AE or AR: " + acknowledgementCode)__            }__            String messageControlId___            int endOfMshSegment = hl7Message.indexOf(SEGMENT_DELIMITER)__            if (-1 != endOfMshSegment) {_                String mshSegment = hl7Message.substring(0, endOfMshSegment)__                char fieldSeparator = mshSegment.charAt(3)__                String fieldSeparatorPattern = Pattern.quote("" + fieldSeparator)__                String[] mshFields = mshSegment.split(fieldSeparatorPattern)__                if (null == mshFields || 0 == mshFields.length) {_                    log.error("Failed to split MSH Segment into fields")__                } else {_                    StringBuilder ackBuilder = new StringBuilder(mshSegment.length() + 25)__                    _                    ackBuilder_                            .append(mshFields[0]).append(fieldSeparator)_                            .append(mshFields[1]).append(fieldSeparator)_                            .append(mshFields[4]).append(fieldSeparator)_                            .append(mshFields[5]).append(fieldSeparator)_                            .append(mshFields[2]).append(fieldSeparator)_                            .append(mshFields[3]).append(fieldSeparator)_                            .append(mshFields[6]).append(fieldSeparator)_                            .append(mshFields[7]).append(fieldSeparator)_                            .append("ACK")_                            .append(mshFields[8].substring(3))__                    for (int i = 9_ i < mshFields.length_ ++i) {_                        ackBuilder.append(fieldSeparator).append(mshFields[i])__                    }_                    _                    int emptyFieldIndex = mshSegment.length() - 1__                    if (fieldSeparator == mshSegment.charAt(mshSegment.length() - 1)) {_                        ackBuilder.append(fieldSeparator)__                        while (emptyFieldIndex >= 1 && mshSegment.charAt(emptyFieldIndex) == mshSegment.charAt(emptyFieldIndex - 1)) {_                            ackBuilder.append(fieldSeparator)__                            --emptyFieldIndex__                        }_                    }_                    ackBuilder.append(SEGMENT_DELIMITER)___                    _                    ackBuilder_                            .append("MSA").append(fieldSeparator)_                            .append(acknowledgementCode).append(fieldSeparator)_                            .append(mshFields[9]).append(fieldSeparator)_                            .append(SEGMENT_DELIMITER)___                    _                    ackBuilder.append(MESSAGE_TERMINATOR)___                    return ackBuilder.toString()__                }_            } else {_                log.error("Failed to find the end of the  MSH Segment")__            }__            return null__        };generates,a,hl7,application,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,param,acknowledgement,code,aa,ae,or,ar,return,a,hl7,application,acknowledgement;private,string,generate,acknowledgement,message,string,hl7message,string,acknowledgement,code,final,string,defaul,nack,message,msh,nack,p,2,2,msa,ar,if,hl7message,null,log,error,invalid,hl7,message,for,parsing,operation,please,check,your,inputs,return,defaul,nack,message,if,aa,equals,acknowledgement,code,ae,equals,acknowledgement,code,ar,equals,acknowledgement,code,throw,new,illegal,argument,exception,acknowledgemnt,code,must,be,aa,ae,or,ar,acknowledgement,code,string,message,control,id,int,end,of,msh,segment,hl7message,index,of,if,1,end,of,msh,segment,string,msh,segment,hl7message,substring,0,end,of,msh,segment,char,field,separator,msh,segment,char,at,3,string,field,separator,pattern,pattern,quote,field,separator,string,msh,fields,msh,segment,split,field,separator,pattern,if,null,msh,fields,0,msh,fields,length,log,error,failed,to,split,msh,segment,into,fields,else,string,builder,ack,builder,new,string,builder,msh,segment,length,25,ack,builder,append,msh,fields,0,append,field,separator,append,msh,fields,1,append,field,separator,append,msh,fields,4,append,field,separator,append,msh,fields,5,append,field,separator,append,msh,fields,2,append,field,separator,append,msh,fields,3,append,field,separator,append,msh,fields,6,append,field,separator,append,msh,fields,7,append,field,separator,append,ack,append,msh,fields,8,substring,3,for,int,i,9,i,msh,fields,length,i,ack,builder,append,field,separator,append,msh,fields,i,int,empty,field,index,msh,segment,length,1,if,field,separator,msh,segment,char,at,msh,segment,length,1,ack,builder,append,field,separator,while,empty,field,index,1,msh,segment,char,at,empty,field,index,msh,segment,char,at,empty,field,index,1,ack,builder,append,field,separator,empty,field,index,ack,builder,append,ack,builder,append,msa,append,field,separator,append,acknowledgement,code,append,field,separator,append,msh,fields,9,append,field,separator,append,ack,builder,append,return,ack,builder,to,string,else,log,error,failed,to,find,the,end,of,the,msh,segment,return,null
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode);1453968697;Generates a HL7 Application Acknowledgement__@param hl7Message          HL7 message that is being acknowledged_@param acknowledgementCode AA, AE or AR_@return a HL7 Application Acknowledgement;private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode) {_            final String defaulNackMessage =_                    "MSH|^~\\&|||||||NACK||P|2.2" + SEGMENT_DELIMITER_                            + "MSA|AR|" + SEGMENT_DELIMITER_                            + MESSAGE_TERMINATOR___            if (hl7Message == null) {_                log.error("Invalid HL7 message for parsing operation. Please check your inputs")__                return defaulNackMessage__            }__            if (!("AA".equals(acknowledgementCode) || "AE".equals(acknowledgementCode) || "AR".equals(acknowledgementCode))) {_                throw new IllegalArgumentException("Acknowledgemnt Code must be AA, AE or AR: " + acknowledgementCode)__            }__            String messageControlId___            int endOfMshSegment = hl7Message.indexOf(SEGMENT_DELIMITER)__            if (-1 != endOfMshSegment) {_                String mshSegment = hl7Message.substring(0, endOfMshSegment)__                char fieldSeparator = mshSegment.charAt(3)__                String fieldSeparatorPattern = Pattern.quote("" + fieldSeparator)__                String[] mshFields = mshSegment.split(fieldSeparatorPattern)__                if (null == mshFields || 0 == mshFields.length) {_                    log.error("Failed to split MSH Segment into fields")__                } else {_                    StringBuilder ackBuilder = new StringBuilder(mshSegment.length() + 25)__                    _                    ackBuilder_                            .append(mshFields[0]).append(fieldSeparator)_                            .append(mshFields[1]).append(fieldSeparator)_                            .append(mshFields[4]).append(fieldSeparator)_                            .append(mshFields[5]).append(fieldSeparator)_                            .append(mshFields[2]).append(fieldSeparator)_                            .append(mshFields[3]).append(fieldSeparator)_                            .append(mshFields[6]).append(fieldSeparator)_                            .append(mshFields[7]).append(fieldSeparator)_                            .append("ACK")_                            .append(mshFields[8].substring(3))__                    for (int i = 9_ i < mshFields.length_ ++i) {_                        ackBuilder.append(fieldSeparator).append(mshFields[i])__                    }_                    _                    int emptyFieldIndex = mshSegment.length() - 1__                    if (fieldSeparator == mshSegment.charAt(mshSegment.length() - 1)) {_                        ackBuilder.append(fieldSeparator)__                        while (emptyFieldIndex >= 1 && mshSegment.charAt(emptyFieldIndex) == mshSegment.charAt(emptyFieldIndex - 1)) {_                            ackBuilder.append(fieldSeparator)__                            --emptyFieldIndex__                        }_                    }_                    ackBuilder.append(SEGMENT_DELIMITER)___                    _                    ackBuilder_                            .append("MSA").append(fieldSeparator)_                            .append(acknowledgementCode).append(fieldSeparator)_                            .append(mshFields[9]).append(fieldSeparator)_                            .append(SEGMENT_DELIMITER)___                    _                    ackBuilder.append(MESSAGE_TERMINATOR)___                    return ackBuilder.toString()__                }_            } else {_                log.error("Failed to find the end of the  MSH Segment")__            }__            return null__        };generates,a,hl7,application,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,param,acknowledgement,code,aa,ae,or,ar,return,a,hl7,application,acknowledgement;private,string,generate,acknowledgement,message,string,hl7message,string,acknowledgement,code,final,string,defaul,nack,message,msh,nack,p,2,2,msa,ar,if,hl7message,null,log,error,invalid,hl7,message,for,parsing,operation,please,check,your,inputs,return,defaul,nack,message,if,aa,equals,acknowledgement,code,ae,equals,acknowledgement,code,ar,equals,acknowledgement,code,throw,new,illegal,argument,exception,acknowledgemnt,code,must,be,aa,ae,or,ar,acknowledgement,code,string,message,control,id,int,end,of,msh,segment,hl7message,index,of,if,1,end,of,msh,segment,string,msh,segment,hl7message,substring,0,end,of,msh,segment,char,field,separator,msh,segment,char,at,3,string,field,separator,pattern,pattern,quote,field,separator,string,msh,fields,msh,segment,split,field,separator,pattern,if,null,msh,fields,0,msh,fields,length,log,error,failed,to,split,msh,segment,into,fields,else,string,builder,ack,builder,new,string,builder,msh,segment,length,25,ack,builder,append,msh,fields,0,append,field,separator,append,msh,fields,1,append,field,separator,append,msh,fields,4,append,field,separator,append,msh,fields,5,append,field,separator,append,msh,fields,2,append,field,separator,append,msh,fields,3,append,field,separator,append,msh,fields,6,append,field,separator,append,msh,fields,7,append,field,separator,append,ack,append,msh,fields,8,substring,3,for,int,i,9,i,msh,fields,length,i,ack,builder,append,field,separator,append,msh,fields,i,int,empty,field,index,msh,segment,length,1,if,field,separator,msh,segment,char,at,msh,segment,length,1,ack,builder,append,field,separator,while,empty,field,index,1,msh,segment,char,at,empty,field,index,msh,segment,char,at,empty,field,index,1,ack,builder,append,field,separator,empty,field,index,ack,builder,append,ack,builder,append,msa,append,field,separator,append,acknowledgement,code,append,field,separator,append,msh,fields,9,append,field,separator,append,ack,builder,append,return,ack,builder,to,string,else,log,error,failed,to,find,the,end,of,the,msh,segment,return,null
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode);1453968697;Generates a HL7 Application Acknowledgement__@param hl7Message          HL7 message that is being acknowledged_@param acknowledgementCode AA, AE or AR_@return a HL7 Application Acknowledgement;private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode) {_            final String defaulNackMessage =_                    "MSH|^~\\&|||||||NACK||P|2.2" + SEGMENT_DELIMITER_                            + "MSA|AR|" + SEGMENT_DELIMITER_                            + MESSAGE_TERMINATOR___            if (hl7Message == null) {_                log.error("Invalid HL7 message for parsing operation. Please check your inputs")__                return defaulNackMessage__            }__            if (!("AA".equals(acknowledgementCode) || "AE".equals(acknowledgementCode) || "AR".equals(acknowledgementCode))) {_                throw new IllegalArgumentException("Acknowledgemnt Code must be AA, AE or AR: " + acknowledgementCode)__            }__            String messageControlId___            int endOfMshSegment = hl7Message.indexOf(SEGMENT_DELIMITER)__            if (-1 != endOfMshSegment) {_                String mshSegment = hl7Message.substring(0, endOfMshSegment)__                char fieldSeparator = mshSegment.charAt(3)__                String fieldSeparatorPattern = Pattern.quote("" + fieldSeparator)__                String[] mshFields = mshSegment.split(fieldSeparatorPattern)__                if (null == mshFields || 0 == mshFields.length) {_                    log.error("Failed to split MSH Segment into fields")__                } else {_                    StringBuilder ackBuilder = new StringBuilder(mshSegment.length() + 25)__                    _                    ackBuilder_                            .append(mshFields[0]).append(fieldSeparator)_                            .append(mshFields[1]).append(fieldSeparator)_                            .append(mshFields[4]).append(fieldSeparator)_                            .append(mshFields[5]).append(fieldSeparator)_                            .append(mshFields[2]).append(fieldSeparator)_                            .append(mshFields[3]).append(fieldSeparator)_                            .append(mshFields[6]).append(fieldSeparator)_                            .append(mshFields[7]).append(fieldSeparator)_                            .append("ACK")_                            .append(mshFields[8].substring(3))__                    for (int i = 9_ i < mshFields.length_ ++i) {_                        ackBuilder.append(fieldSeparator).append(mshFields[i])__                    }_                    _                    int emptyFieldIndex = mshSegment.length() - 1__                    if (fieldSeparator == mshSegment.charAt(mshSegment.length() - 1)) {_                        ackBuilder.append(fieldSeparator)__                        while (emptyFieldIndex >= 1 && mshSegment.charAt(emptyFieldIndex) == mshSegment.charAt(emptyFieldIndex - 1)) {_                            ackBuilder.append(fieldSeparator)__                            --emptyFieldIndex__                        }_                    }_                    ackBuilder.append(SEGMENT_DELIMITER)___                    _                    ackBuilder_                            .append("MSA").append(fieldSeparator)_                            .append(acknowledgementCode).append(fieldSeparator)_                            .append(mshFields[9]).append(fieldSeparator)_                            .append(SEGMENT_DELIMITER)___                    _                    ackBuilder.append(MESSAGE_TERMINATOR)___                    return ackBuilder.toString()__                }_            } else {_                log.error("Failed to find the end of the  MSH Segment")__            }__            return null__        };generates,a,hl7,application,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,param,acknowledgement,code,aa,ae,or,ar,return,a,hl7,application,acknowledgement;private,string,generate,acknowledgement,message,string,hl7message,string,acknowledgement,code,final,string,defaul,nack,message,msh,nack,p,2,2,msa,ar,if,hl7message,null,log,error,invalid,hl7,message,for,parsing,operation,please,check,your,inputs,return,defaul,nack,message,if,aa,equals,acknowledgement,code,ae,equals,acknowledgement,code,ar,equals,acknowledgement,code,throw,new,illegal,argument,exception,acknowledgemnt,code,must,be,aa,ae,or,ar,acknowledgement,code,string,message,control,id,int,end,of,msh,segment,hl7message,index,of,if,1,end,of,msh,segment,string,msh,segment,hl7message,substring,0,end,of,msh,segment,char,field,separator,msh,segment,char,at,3,string,field,separator,pattern,pattern,quote,field,separator,string,msh,fields,msh,segment,split,field,separator,pattern,if,null,msh,fields,0,msh,fields,length,log,error,failed,to,split,msh,segment,into,fields,else,string,builder,ack,builder,new,string,builder,msh,segment,length,25,ack,builder,append,msh,fields,0,append,field,separator,append,msh,fields,1,append,field,separator,append,msh,fields,4,append,field,separator,append,msh,fields,5,append,field,separator,append,msh,fields,2,append,field,separator,append,msh,fields,3,append,field,separator,append,msh,fields,6,append,field,separator,append,msh,fields,7,append,field,separator,append,ack,append,msh,fields,8,substring,3,for,int,i,9,i,msh,fields,length,i,ack,builder,append,field,separator,append,msh,fields,i,int,empty,field,index,msh,segment,length,1,if,field,separator,msh,segment,char,at,msh,segment,length,1,ack,builder,append,field,separator,while,empty,field,index,1,msh,segment,char,at,empty,field,index,msh,segment,char,at,empty,field,index,1,ack,builder,append,field,separator,empty,field,index,ack,builder,append,ack,builder,append,msa,append,field,separator,append,acknowledgement,code,append,field,separator,append,msh,fields,9,append,field,separator,append,ack,builder,append,return,ack,builder,to,string,else,log,error,failed,to,find,the,end,of,the,msh,segment,return,null
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode);1457097808;Generates a HL7 Application Acknowledgement__@param hl7Message          HL7 message that is being acknowledged_@param acknowledgementCode AA, AE or AR_@return a HL7 Application Acknowledgement;private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode) {_            final String defaulNackMessage =_                    "MSH|^~\\&|||||||NACK||P|2.2" + SEGMENT_DELIMITER_                            + "MSA|AR|" + SEGMENT_DELIMITER_                            + MESSAGE_TERMINATOR___            if (hl7Message == null) {_                log.error("Invalid HL7 message for parsing operation. Please check your inputs")__                return defaulNackMessage__            }__            if (!("AA".equals(acknowledgementCode) || "AE".equals(acknowledgementCode) || "AR".equals(acknowledgementCode))) {_                throw new IllegalArgumentException("Acknowledgemnt Code must be AA, AE or AR: " + acknowledgementCode)__            }__            String messageControlId___            int endOfMshSegment = hl7Message.indexOf(SEGMENT_DELIMITER)__            if (-1 != endOfMshSegment) {_                String mshSegment = hl7Message.substring(0, endOfMshSegment)__                char fieldSeparator = mshSegment.charAt(3)__                String fieldSeparatorPattern = Pattern.quote("" + fieldSeparator)__                String[] mshFields = mshSegment.split(fieldSeparatorPattern)__                if (mshFields.length == 0) {_                    log.error("Failed to split MSH Segment into fields")__                } else {_                    StringBuilder ackBuilder = new StringBuilder(mshSegment.length() + 25)__                    _                    ackBuilder_                            .append(mshFields[0]).append(fieldSeparator)_                            .append(mshFields[1]).append(fieldSeparator)_                            .append(mshFields[4]).append(fieldSeparator)_                            .append(mshFields[5]).append(fieldSeparator)_                            .append(mshFields[2]).append(fieldSeparator)_                            .append(mshFields[3]).append(fieldSeparator)_                            .append(mshFields[6]).append(fieldSeparator)_                            .append(mshFields[7]).append(fieldSeparator)_                            .append("ACK")_                            .append(mshFields[8].substring(3))__                    for (int i = 9_ i < mshFields.length_ ++i) {_                        ackBuilder.append(fieldSeparator).append(mshFields[i])__                    }_                    _                    int emptyFieldIndex = mshSegment.length() - 1__                    if (fieldSeparator == mshSegment.charAt(mshSegment.length() - 1)) {_                        ackBuilder.append(fieldSeparator)__                        while (emptyFieldIndex >= 1 && mshSegment.charAt(emptyFieldIndex) == mshSegment.charAt(emptyFieldIndex - 1)) {_                            ackBuilder.append(fieldSeparator)__                            --emptyFieldIndex__                        }_                    }_                    ackBuilder.append(SEGMENT_DELIMITER)___                    _                    ackBuilder_                            .append("MSA").append(fieldSeparator)_                            .append(acknowledgementCode).append(fieldSeparator)_                            .append(mshFields[9]).append(fieldSeparator)_                            .append(SEGMENT_DELIMITER)___                    _                    ackBuilder.append(MESSAGE_TERMINATOR)___                    return ackBuilder.toString()__                }_            } else {_                log.error("Failed to find the end of the  MSH Segment")__            }__            return null__        };generates,a,hl7,application,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,param,acknowledgement,code,aa,ae,or,ar,return,a,hl7,application,acknowledgement;private,string,generate,acknowledgement,message,string,hl7message,string,acknowledgement,code,final,string,defaul,nack,message,msh,nack,p,2,2,msa,ar,if,hl7message,null,log,error,invalid,hl7,message,for,parsing,operation,please,check,your,inputs,return,defaul,nack,message,if,aa,equals,acknowledgement,code,ae,equals,acknowledgement,code,ar,equals,acknowledgement,code,throw,new,illegal,argument,exception,acknowledgemnt,code,must,be,aa,ae,or,ar,acknowledgement,code,string,message,control,id,int,end,of,msh,segment,hl7message,index,of,if,1,end,of,msh,segment,string,msh,segment,hl7message,substring,0,end,of,msh,segment,char,field,separator,msh,segment,char,at,3,string,field,separator,pattern,pattern,quote,field,separator,string,msh,fields,msh,segment,split,field,separator,pattern,if,msh,fields,length,0,log,error,failed,to,split,msh,segment,into,fields,else,string,builder,ack,builder,new,string,builder,msh,segment,length,25,ack,builder,append,msh,fields,0,append,field,separator,append,msh,fields,1,append,field,separator,append,msh,fields,4,append,field,separator,append,msh,fields,5,append,field,separator,append,msh,fields,2,append,field,separator,append,msh,fields,3,append,field,separator,append,msh,fields,6,append,field,separator,append,msh,fields,7,append,field,separator,append,ack,append,msh,fields,8,substring,3,for,int,i,9,i,msh,fields,length,i,ack,builder,append,field,separator,append,msh,fields,i,int,empty,field,index,msh,segment,length,1,if,field,separator,msh,segment,char,at,msh,segment,length,1,ack,builder,append,field,separator,while,empty,field,index,1,msh,segment,char,at,empty,field,index,msh,segment,char,at,empty,field,index,1,ack,builder,append,field,separator,empty,field,index,ack,builder,append,ack,builder,append,msa,append,field,separator,append,acknowledgement,code,append,field,separator,append,msh,fields,9,append,field,separator,append,ack,builder,append,return,ack,builder,to,string,else,log,error,failed,to,find,the,end,of,the,msh,segment,return,null
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode);1461916938;Generates a HL7 Application Acknowledgement__@param hl7Message          HL7 message that is being acknowledged_@param acknowledgementCode AA, AE or AR_@return a HL7 Application Acknowledgement;private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode) {_            final String defaulNackMessage =_                    "MSH|^~\\&|||||||NACK||P|2.2" + SEGMENT_DELIMITER_                            + "MSA|AR|" + SEGMENT_DELIMITER_                            + MESSAGE_TERMINATOR___            if (hl7Message == null) {_                log.error("Invalid HL7 message for parsing operation. Please check your inputs")__                return defaulNackMessage__            }__            if (!("AA".equals(acknowledgementCode) || "AE".equals(acknowledgementCode) || "AR".equals(acknowledgementCode))) {_                throw new IllegalArgumentException("Acknowledgemnt Code must be AA, AE or AR: " + acknowledgementCode)__            }__            String messageControlId___            int endOfMshSegment = hl7Message.indexOf(SEGMENT_DELIMITER)__            if (-1 != endOfMshSegment) {_                String mshSegment = hl7Message.substring(0, endOfMshSegment)__                char fieldSeparator = mshSegment.charAt(3)__                String fieldSeparatorPattern = Pattern.quote("" + fieldSeparator)__                String[] mshFields = mshSegment.split(fieldSeparatorPattern)__                if (mshFields.length == 0) {_                    log.error("Failed to split MSH Segment into fields")__                } else {_                    StringBuilder ackBuilder = new StringBuilder(mshSegment.length() + 25)__                    _                    ackBuilder_                            .append(mshFields[0]).append(fieldSeparator)_                            .append(mshFields[1]).append(fieldSeparator)_                            .append(mshFields[4]).append(fieldSeparator)_                            .append(mshFields[5]).append(fieldSeparator)_                            .append(mshFields[2]).append(fieldSeparator)_                            .append(mshFields[3]).append(fieldSeparator)_                            .append(mshFields[6]).append(fieldSeparator)_                            .append(mshFields[7]).append(fieldSeparator)_                            .append("ACK")_                            .append(mshFields[8].substring(3))__                    for (int i = 9_ i < mshFields.length_ ++i) {_                        ackBuilder.append(fieldSeparator).append(mshFields[i])__                    }_                    _                    int emptyFieldIndex = mshSegment.length() - 1__                    if (fieldSeparator == mshSegment.charAt(mshSegment.length() - 1)) {_                        ackBuilder.append(fieldSeparator)__                        while (emptyFieldIndex >= 1 && mshSegment.charAt(emptyFieldIndex) == mshSegment.charAt(emptyFieldIndex - 1)) {_                            ackBuilder.append(fieldSeparator)__                            --emptyFieldIndex__                        }_                    }_                    ackBuilder.append(SEGMENT_DELIMITER)___                    _                    ackBuilder_                            .append("MSA").append(fieldSeparator)_                            .append(acknowledgementCode).append(fieldSeparator)_                            .append(mshFields[9]).append(fieldSeparator)_                            .append(SEGMENT_DELIMITER)___                    _                    ackBuilder.append(MESSAGE_TERMINATOR)___                    return ackBuilder.toString()__                }_            } else {_                log.error("Failed to find the end of the  MSH Segment")__            }__            return null__        };generates,a,hl7,application,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,param,acknowledgement,code,aa,ae,or,ar,return,a,hl7,application,acknowledgement;private,string,generate,acknowledgement,message,string,hl7message,string,acknowledgement,code,final,string,defaul,nack,message,msh,nack,p,2,2,msa,ar,if,hl7message,null,log,error,invalid,hl7,message,for,parsing,operation,please,check,your,inputs,return,defaul,nack,message,if,aa,equals,acknowledgement,code,ae,equals,acknowledgement,code,ar,equals,acknowledgement,code,throw,new,illegal,argument,exception,acknowledgemnt,code,must,be,aa,ae,or,ar,acknowledgement,code,string,message,control,id,int,end,of,msh,segment,hl7message,index,of,if,1,end,of,msh,segment,string,msh,segment,hl7message,substring,0,end,of,msh,segment,char,field,separator,msh,segment,char,at,3,string,field,separator,pattern,pattern,quote,field,separator,string,msh,fields,msh,segment,split,field,separator,pattern,if,msh,fields,length,0,log,error,failed,to,split,msh,segment,into,fields,else,string,builder,ack,builder,new,string,builder,msh,segment,length,25,ack,builder,append,msh,fields,0,append,field,separator,append,msh,fields,1,append,field,separator,append,msh,fields,4,append,field,separator,append,msh,fields,5,append,field,separator,append,msh,fields,2,append,field,separator,append,msh,fields,3,append,field,separator,append,msh,fields,6,append,field,separator,append,msh,fields,7,append,field,separator,append,ack,append,msh,fields,8,substring,3,for,int,i,9,i,msh,fields,length,i,ack,builder,append,field,separator,append,msh,fields,i,int,empty,field,index,msh,segment,length,1,if,field,separator,msh,segment,char,at,msh,segment,length,1,ack,builder,append,field,separator,while,empty,field,index,1,msh,segment,char,at,empty,field,index,msh,segment,char,at,empty,field,index,1,ack,builder,append,field,separator,empty,field,index,ack,builder,append,ack,builder,append,msa,append,field,separator,append,acknowledgement,code,append,field,separator,append,msh,fields,9,append,field,separator,append,ack,builder,append,return,ack,builder,to,string,else,log,error,failed,to,find,the,end,of,the,msh,segment,return,null
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode);1480882601;Generates a HL7 Application Acknowledgement__@param hl7Message          HL7 message that is being acknowledged_@param acknowledgementCode AA, AE or AR_@return a HL7 Application Acknowledgement;private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode) {_            final String defaulNackMessage =_                    "MSH|^~\\&|||||||NACK||P|2.2" + SEGMENT_DELIMITER_                            + "MSA|AR|" + SEGMENT_DELIMITER_                            + MESSAGE_TERMINATOR___            if (hl7Message == null) {_                log.error("Invalid HL7 message for parsing operation. Please check your inputs")__                return defaulNackMessage__            }__            if (!("AA".equals(acknowledgementCode) || "AE".equals(acknowledgementCode) || "AR".equals(acknowledgementCode))) {_                throw new IllegalArgumentException("Acknowledgemnt Code must be AA, AE or AR: " + acknowledgementCode)__            }__            String messageControlId___            int endOfMshSegment = hl7Message.indexOf(SEGMENT_DELIMITER)__            if (-1 != endOfMshSegment) {_                String mshSegment = hl7Message.substring(0, endOfMshSegment)__                char fieldSeparator = mshSegment.charAt(3)__                String fieldSeparatorPattern = Pattern.quote("" + fieldSeparator)__                String[] mshFields = mshSegment.split(fieldSeparatorPattern)__                if (mshFields.length == 0) {_                    log.error("Failed to split MSH Segment into fields")__                } else {_                    StringBuilder ackBuilder = new StringBuilder(mshSegment.length() + 25)__                    _                    ackBuilder_                            .append(mshFields[0]).append(fieldSeparator)_                            .append(mshFields[1]).append(fieldSeparator)_                            .append(mshFields[4]).append(fieldSeparator)_                            .append(mshFields[5]).append(fieldSeparator)_                            .append(mshFields[2]).append(fieldSeparator)_                            .append(mshFields[3]).append(fieldSeparator)_                            .append(mshFields[6]).append(fieldSeparator)_                            .append(mshFields[7]).append(fieldSeparator)_                            .append("ACK")_                            .append(mshFields[8].substring(3))__                    for (int i = 9_ i < mshFields.length_ ++i) {_                        ackBuilder.append(fieldSeparator).append(mshFields[i])__                    }_                    _                    int emptyFieldIndex = mshSegment.length() - 1__                    if (fieldSeparator == mshSegment.charAt(mshSegment.length() - 1)) {_                        ackBuilder.append(fieldSeparator)__                        while (emptyFieldIndex >= 1 && mshSegment.charAt(emptyFieldIndex) == mshSegment.charAt(emptyFieldIndex - 1)) {_                            ackBuilder.append(fieldSeparator)__                            --emptyFieldIndex__                        }_                    }_                    ackBuilder.append(SEGMENT_DELIMITER)___                    _                    ackBuilder_                            .append("MSA").append(fieldSeparator)_                            .append(acknowledgementCode).append(fieldSeparator)_                            .append(mshFields[9]).append(fieldSeparator)_                            .append(SEGMENT_DELIMITER)___                    _                    ackBuilder.append(MESSAGE_TERMINATOR)___                    return ackBuilder.toString()__                }_            } else {_                log.error("Failed to find the end of the  MSH Segment")__            }__            return null__        };generates,a,hl7,application,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,param,acknowledgement,code,aa,ae,or,ar,return,a,hl7,application,acknowledgement;private,string,generate,acknowledgement,message,string,hl7message,string,acknowledgement,code,final,string,defaul,nack,message,msh,nack,p,2,2,msa,ar,if,hl7message,null,log,error,invalid,hl7,message,for,parsing,operation,please,check,your,inputs,return,defaul,nack,message,if,aa,equals,acknowledgement,code,ae,equals,acknowledgement,code,ar,equals,acknowledgement,code,throw,new,illegal,argument,exception,acknowledgemnt,code,must,be,aa,ae,or,ar,acknowledgement,code,string,message,control,id,int,end,of,msh,segment,hl7message,index,of,if,1,end,of,msh,segment,string,msh,segment,hl7message,substring,0,end,of,msh,segment,char,field,separator,msh,segment,char,at,3,string,field,separator,pattern,pattern,quote,field,separator,string,msh,fields,msh,segment,split,field,separator,pattern,if,msh,fields,length,0,log,error,failed,to,split,msh,segment,into,fields,else,string,builder,ack,builder,new,string,builder,msh,segment,length,25,ack,builder,append,msh,fields,0,append,field,separator,append,msh,fields,1,append,field,separator,append,msh,fields,4,append,field,separator,append,msh,fields,5,append,field,separator,append,msh,fields,2,append,field,separator,append,msh,fields,3,append,field,separator,append,msh,fields,6,append,field,separator,append,msh,fields,7,append,field,separator,append,ack,append,msh,fields,8,substring,3,for,int,i,9,i,msh,fields,length,i,ack,builder,append,field,separator,append,msh,fields,i,int,empty,field,index,msh,segment,length,1,if,field,separator,msh,segment,char,at,msh,segment,length,1,ack,builder,append,field,separator,while,empty,field,index,1,msh,segment,char,at,empty,field,index,msh,segment,char,at,empty,field,index,1,ack,builder,append,field,separator,empty,field,index,ack,builder,append,ack,builder,append,msa,append,field,separator,append,acknowledgement,code,append,field,separator,append,msh,fields,9,append,field,separator,append,ack,builder,append,return,ack,builder,to,string,else,log,error,failed,to,find,the,end,of,the,msh,segment,return,null
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode);1481829620;Generates a HL7 Application Acknowledgement__@param hl7Message          HL7 message that is being acknowledged_@param acknowledgementCode AA, AE or AR_@return a HL7 Application Acknowledgement;private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode) {_            return generateAcknowledgement(hl7Message, acknowledgementCode)__        };generates,a,hl7,application,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,param,acknowledgement,code,aa,ae,or,ar,return,a,hl7,application,acknowledgement;private,string,generate,acknowledgement,message,string,hl7message,string,acknowledgement,code,return,generate,acknowledgement,hl7message,acknowledgement,code
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode);1515779403;Generates a HL7 Application Acknowledgement__@param hl7Message          HL7 message that is being acknowledged_@param acknowledgementCode AA, AE or AR__@return a HL7 Application Acknowledgement;private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode) {_            return generateAcknowledgement(hl7Message, acknowledgementCode)__        };generates,a,hl7,application,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,param,acknowledgement,code,aa,ae,or,ar,return,a,hl7,application,acknowledgement;private,string,generate,acknowledgement,message,string,hl7message,string,acknowledgement,code,return,generate,acknowledgement,hl7message,acknowledgement,code
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode);1524063106;Generates a HL7 Application Acknowledgement__@param hl7Message          HL7 message that is being acknowledged_@param acknowledgementCode AA, AE or AR__@return a HL7 Application Acknowledgement;private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode) {_            return generateAcknowledgement(hl7Message, acknowledgementCode)__        };generates,a,hl7,application,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,param,acknowledgement,code,aa,ae,or,ar,return,a,hl7,application,acknowledgement;private,string,generate,acknowledgement,message,string,hl7message,string,acknowledgement,code,return,generate,acknowledgement,hl7message,acknowledgement,code
MllpServerResource -> ClientSocketThread -> private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode);1536605520;Generates a HL7 Application Acknowledgement__@param hl7Message          HL7 message that is being acknowledged_@param acknowledgementCode AA, AE or AR__@return a HL7 Application Acknowledgement;private String generateAcknowledgementMessage(String hl7Message, String acknowledgementCode) {_            return generateAcknowledgement(hl7Message, acknowledgementCode)__        };generates,a,hl7,application,acknowledgement,param,hl7message,hl7,message,that,is,being,acknowledged,param,acknowledgement,code,aa,ae,or,ar,return,a,hl7,application,acknowledgement;private,string,generate,acknowledgement,message,string,hl7message,string,acknowledgement,code,return,generate,acknowledgement,hl7message,acknowledgement,code
MllpServerResource -> AcceptSocketThread -> public void run();1515779403;Accept TCP connections and create ClientSocketThreads for them;public void run() {_            log.info("Accepting connections on port {}", serverSocket.getLocalPort())__            this.setName("MllpServerResource$AcceptSocketThread - " + serverSocket.getLocalSocketAddress().toString())__            while (!isInterrupted() && serverSocket.isBound() && !serverSocket.isClosed()) {_                Socket clientSocket = null__                try {_                    clientSocket = serverSocket.accept()__                } catch (SocketTimeoutException timeoutEx) {_                    if (raiseExceptionOnAcceptTimeout) {_                        throw new MllpJUnitResourceTimeoutException("Timeout Accepting client connection", timeoutEx)__                    }_                    log.warn("Timeout waiting for client connection")__                } catch (SocketException socketEx) {_                    log.debug("SocketException encountered accepting client connection - ignoring", socketEx)__                    if (null == clientSocket) {_                        continue__                    } else if (!clientSocket.isClosed()) {_                        try {_                            clientSocket.setSoLinger(true, 0)__                        } catch (SocketException soLingerEx) {_                            log.warn("Ignoring SocketException encountered when setting SO_LINGER in preparation of resetting client Socket", soLingerEx)__                        }_                        try {_                            clientSocket.close()__                        } catch (IOException ioEx) {_                            log.warn("Ignoring IOException encountered when resetting client Socket", ioEx)__                        }_                        continue__                    } else {_                        throw new MllpJUnitResourceException("Unexpected SocketException encountered accepting client connection", socketEx)__                    }_                } catch (Exception ex) {_                    throw new MllpJUnitResourceException("Unexpected exception encountered accepting client connection", ex)__                }_                if (null != clientSocket) {_                    try {_                        clientSocket.setKeepAlive(true)__                        clientSocket.setTcpNoDelay(false)__                        clientSocket.setSoLinger(false, -1)__                        clientSocket.setSoTimeout(5000)__                        ClientSocketThread clientSocketThread = new ClientSocketThread(clientSocket)__                        clientSocketThread.setDaemon(true)__                        clientSocketThread.start()__                        clientSocketThreads.add(clientSocketThread)__                    } catch (Exception unexpectedEx) {_                        log.warn("Unexpected exception encountered configuring client socket")__                        try {_                            clientSocket.close()__                        } catch (IOException ingoreEx) {_                            log.warn("Exceptiong encountered closing client socket after attempting to accept connection", ingoreEx)__                        }_                        throw new MllpJUnitResourceException("Unexpected exception encountered configuring client socket", unexpectedEx)__                    }_                }_            }_            log.info("No longer accepting connections - closing TCP Listener on port {}", serverSocket.getLocalPort())__            try {_                serverSocket.close()__            } catch (IOException e) {_                e.printStackTrace()__            }_            log.info("Closed TCP Listener on port {}", serverSocket.getLocalPort())__        };accept,tcp,connections,and,create,client,socket,threads,for,them;public,void,run,log,info,accepting,connections,on,port,server,socket,get,local,port,this,set,name,mllp,server,resource,accept,socket,thread,server,socket,get,local,socket,address,to,string,while,is,interrupted,server,socket,is,bound,server,socket,is,closed,socket,client,socket,null,try,client,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,if,raise,exception,on,accept,timeout,throw,new,mllp,junit,resource,timeout,exception,timeout,accepting,client,connection,timeout,ex,log,warn,timeout,waiting,for,client,connection,catch,socket,exception,socket,ex,log,debug,socket,exception,encountered,accepting,client,connection,ignoring,socket,ex,if,null,client,socket,continue,else,if,client,socket,is,closed,try,client,socket,set,so,linger,true,0,catch,socket,exception,so,linger,ex,log,warn,ignoring,socket,exception,encountered,when,setting,in,preparation,of,resetting,client,socket,so,linger,ex,try,client,socket,close,catch,ioexception,io,ex,log,warn,ignoring,ioexception,encountered,when,resetting,client,socket,io,ex,continue,else,throw,new,mllp,junit,resource,exception,unexpected,socket,exception,encountered,accepting,client,connection,socket,ex,catch,exception,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,accepting,client,connection,ex,if,null,client,socket,try,client,socket,set,keep,alive,true,client,socket,set,tcp,no,delay,false,client,socket,set,so,linger,false,1,client,socket,set,so,timeout,5000,client,socket,thread,client,socket,thread,new,client,socket,thread,client,socket,client,socket,thread,set,daemon,true,client,socket,thread,start,client,socket,threads,add,client,socket,thread,catch,exception,unexpected,ex,log,warn,unexpected,exception,encountered,configuring,client,socket,try,client,socket,close,catch,ioexception,ingore,ex,log,warn,exceptiong,encountered,closing,client,socket,after,attempting,to,accept,connection,ingore,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,configuring,client,socket,unexpected,ex,log,info,no,longer,accepting,connections,closing,tcp,listener,on,port,server,socket,get,local,port,try,server,socket,close,catch,ioexception,e,e,print,stack,trace,log,info,closed,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> AcceptSocketThread -> public void run();1524063106;Accept TCP connections and create ClientSocketThreads for them;public void run() {_            log.info("Accepting connections on port {}", serverSocket.getLocalPort())__            this.setName("MllpServerResource$AcceptSocketThread - " + serverSocket.getLocalSocketAddress().toString())__            while (!isInterrupted() && serverSocket.isBound() && !serverSocket.isClosed()) {_                Socket clientSocket = null__                try {_                    clientSocket = serverSocket.accept()__                } catch (SocketTimeoutException timeoutEx) {_                    if (raiseExceptionOnAcceptTimeout) {_                        throw new MllpJUnitResourceTimeoutException("Timeout Accepting client connection", timeoutEx)__                    }_                    log.warn("Timeout waiting for client connection")__                } catch (SocketException socketEx) {_                    log.debug("SocketException encountered accepting client connection - ignoring", socketEx)__                    if (null == clientSocket) {_                        continue__                    } else if (!clientSocket.isClosed()) {_                        try {_                            clientSocket.setSoLinger(true, 0)__                        } catch (SocketException soLingerEx) {_                            log.warn("Ignoring SocketException encountered when setting SO_LINGER in preparation of resetting client Socket", soLingerEx)__                        }_                        try {_                            clientSocket.close()__                        } catch (IOException ioEx) {_                            log.warn("Ignoring IOException encountered when resetting client Socket", ioEx)__                        }_                        continue__                    } else {_                        throw new MllpJUnitResourceException("Unexpected SocketException encountered accepting client connection", socketEx)__                    }_                } catch (Exception ex) {_                    throw new MllpJUnitResourceException("Unexpected exception encountered accepting client connection", ex)__                }_                if (null != clientSocket) {_                    try {_                        clientSocket.setKeepAlive(true)__                        clientSocket.setTcpNoDelay(false)__                        clientSocket.setSoLinger(false, -1)__                        clientSocket.setSoTimeout(5000)__                        ClientSocketThread clientSocketThread = new ClientSocketThread(clientSocket)__                        clientSocketThread.setDaemon(true)__                        clientSocketThread.start()__                        clientSocketThreads.add(clientSocketThread)__                    } catch (Exception unexpectedEx) {_                        log.warn("Unexpected exception encountered configuring client socket")__                        try {_                            clientSocket.close()__                        } catch (IOException ingoreEx) {_                            log.warn("Exceptiong encountered closing client socket after attempting to accept connection", ingoreEx)__                        }_                        throw new MllpJUnitResourceException("Unexpected exception encountered configuring client socket", unexpectedEx)__                    }_                }_            }_            log.info("No longer accepting connections - closing TCP Listener on port {}", serverSocket.getLocalPort())__            try {_                serverSocket.close()__            } catch (IOException e) {_                e.printStackTrace()__            }_            log.info("Closed TCP Listener on port {}", serverSocket.getLocalPort())__        };accept,tcp,connections,and,create,client,socket,threads,for,them;public,void,run,log,info,accepting,connections,on,port,server,socket,get,local,port,this,set,name,mllp,server,resource,accept,socket,thread,server,socket,get,local,socket,address,to,string,while,is,interrupted,server,socket,is,bound,server,socket,is,closed,socket,client,socket,null,try,client,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,if,raise,exception,on,accept,timeout,throw,new,mllp,junit,resource,timeout,exception,timeout,accepting,client,connection,timeout,ex,log,warn,timeout,waiting,for,client,connection,catch,socket,exception,socket,ex,log,debug,socket,exception,encountered,accepting,client,connection,ignoring,socket,ex,if,null,client,socket,continue,else,if,client,socket,is,closed,try,client,socket,set,so,linger,true,0,catch,socket,exception,so,linger,ex,log,warn,ignoring,socket,exception,encountered,when,setting,in,preparation,of,resetting,client,socket,so,linger,ex,try,client,socket,close,catch,ioexception,io,ex,log,warn,ignoring,ioexception,encountered,when,resetting,client,socket,io,ex,continue,else,throw,new,mllp,junit,resource,exception,unexpected,socket,exception,encountered,accepting,client,connection,socket,ex,catch,exception,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,accepting,client,connection,ex,if,null,client,socket,try,client,socket,set,keep,alive,true,client,socket,set,tcp,no,delay,false,client,socket,set,so,linger,false,1,client,socket,set,so,timeout,5000,client,socket,thread,client,socket,thread,new,client,socket,thread,client,socket,client,socket,thread,set,daemon,true,client,socket,thread,start,client,socket,threads,add,client,socket,thread,catch,exception,unexpected,ex,log,warn,unexpected,exception,encountered,configuring,client,socket,try,client,socket,close,catch,ioexception,ingore,ex,log,warn,exceptiong,encountered,closing,client,socket,after,attempting,to,accept,connection,ingore,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,configuring,client,socket,unexpected,ex,log,info,no,longer,accepting,connections,closing,tcp,listener,on,port,server,socket,get,local,port,try,server,socket,close,catch,ioexception,e,e,print,stack,trace,log,info,closed,tcp,listener,on,port,server,socket,get,local,port
MllpServerResource -> AcceptSocketThread -> public void run();1536605520;Accept TCP connections and create ClientSocketThreads for them;public void run() {_            log.info("Accepting connections on port {}", serverSocket.getLocalPort())__            this.setName("MllpServerResource$AcceptSocketThread - " + serverSocket.getLocalSocketAddress().toString())__            while (!isInterrupted() && serverSocket.isBound() && !serverSocket.isClosed()) {_                Socket clientSocket = null__                try {_                    clientSocket = serverSocket.accept()__                } catch (SocketTimeoutException timeoutEx) {_                    if (raiseExceptionOnAcceptTimeout) {_                        throw new MllpJUnitResourceTimeoutException("Timeout Accepting client connection", timeoutEx)__                    }_                    log.warn("Timeout waiting for client connection")__                } catch (SocketException socketEx) {_                    log.debug("SocketException encountered accepting client connection - ignoring", socketEx)__                    if (null == clientSocket) {_                        continue__                    } else if (!clientSocket.isClosed()) {_                        try {_                            clientSocket.setSoLinger(true, 0)__                        } catch (SocketException soLingerEx) {_                            log.warn("Ignoring SocketException encountered when setting SO_LINGER in preparation of resetting client Socket", soLingerEx)__                        }_                        try {_                            clientSocket.close()__                        } catch (IOException ioEx) {_                            log.warn("Ignoring IOException encountered when resetting client Socket", ioEx)__                        }_                        continue__                    } else {_                        throw new MllpJUnitResourceException("Unexpected SocketException encountered accepting client connection", socketEx)__                    }_                } catch (Exception ex) {_                    throw new MllpJUnitResourceException("Unexpected exception encountered accepting client connection", ex)__                }_                if (null != clientSocket) {_                    try {_                        clientSocket.setKeepAlive(true)__                        clientSocket.setTcpNoDelay(false)__                        clientSocket.setSoLinger(false, -1)__                        clientSocket.setSoTimeout(5000)__                        ClientSocketThread clientSocketThread = new ClientSocketThread(clientSocket)__                        clientSocketThread.setDaemon(true)__                        clientSocketThread.start()__                        clientSocketThreads.add(clientSocketThread)__                    } catch (Exception unexpectedEx) {_                        log.warn("Unexpected exception encountered configuring client socket")__                        try {_                            clientSocket.close()__                        } catch (IOException ingoreEx) {_                            log.warn("Exceptiong encountered closing client socket after attempting to accept connection", ingoreEx)__                        }_                        throw new MllpJUnitResourceException("Unexpected exception encountered configuring client socket", unexpectedEx)__                    }_                }_            }_            log.info("No longer accepting connections - closing TCP Listener on port {}", serverSocket.getLocalPort())__            try {_                serverSocket.close()__            } catch (IOException e) {_                e.printStackTrace()__            }_            log.info("Closed TCP Listener on port {}", serverSocket.getLocalPort())__        };accept,tcp,connections,and,create,client,socket,threads,for,them;public,void,run,log,info,accepting,connections,on,port,server,socket,get,local,port,this,set,name,mllp,server,resource,accept,socket,thread,server,socket,get,local,socket,address,to,string,while,is,interrupted,server,socket,is,bound,server,socket,is,closed,socket,client,socket,null,try,client,socket,server,socket,accept,catch,socket,timeout,exception,timeout,ex,if,raise,exception,on,accept,timeout,throw,new,mllp,junit,resource,timeout,exception,timeout,accepting,client,connection,timeout,ex,log,warn,timeout,waiting,for,client,connection,catch,socket,exception,socket,ex,log,debug,socket,exception,encountered,accepting,client,connection,ignoring,socket,ex,if,null,client,socket,continue,else,if,client,socket,is,closed,try,client,socket,set,so,linger,true,0,catch,socket,exception,so,linger,ex,log,warn,ignoring,socket,exception,encountered,when,setting,in,preparation,of,resetting,client,socket,so,linger,ex,try,client,socket,close,catch,ioexception,io,ex,log,warn,ignoring,ioexception,encountered,when,resetting,client,socket,io,ex,continue,else,throw,new,mllp,junit,resource,exception,unexpected,socket,exception,encountered,accepting,client,connection,socket,ex,catch,exception,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,accepting,client,connection,ex,if,null,client,socket,try,client,socket,set,keep,alive,true,client,socket,set,tcp,no,delay,false,client,socket,set,so,linger,false,1,client,socket,set,so,timeout,5000,client,socket,thread,client,socket,thread,new,client,socket,thread,client,socket,client,socket,thread,set,daemon,true,client,socket,thread,start,client,socket,threads,add,client,socket,thread,catch,exception,unexpected,ex,log,warn,unexpected,exception,encountered,configuring,client,socket,try,client,socket,close,catch,ioexception,ingore,ex,log,warn,exceptiong,encountered,closing,client,socket,after,attempting,to,accept,connection,ingore,ex,throw,new,mllp,junit,resource,exception,unexpected,exception,encountered,configuring,client,socket,unexpected,ex,log,info,no,longer,accepting,connections,closing,tcp,listener,on,port,server,socket,get,local,port,try,server,socket,close,catch,ioexception,e,e,print,stack,trace,log,info,closed,tcp,listener,on,port,server,socket,get,local,port
