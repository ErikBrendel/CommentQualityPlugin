commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;10;;@Override protected void doPostSetup() throws Exception {     super.doPostSetup().     result.expectedMessageCount(0).     complete.expectedMessageCount(0).     failure.expectedMessageCount(0).     invalidAckEx.expectedMessageCount(0).     ackGenerationEx.expectedMessageCount(0). }
false;protected;0;9;;@Override protected CamelContext createCamelContext() throws Exception {     DefaultCamelContext context = (DefaultCamelContext) super.createCamelContext().     context.setUseMDCLogging(true).     context.setName(this.getClass().getSimpleName()).     return context. }
false;public;0;27;;@Override public void configure() throws Exception {     String routeId = "mllp-test-receiver-route".     onException(MllpInvalidAcknowledgementException.class).handled(false).to("mock://invalid-ack-ex").     onException(MllpAcknowledgementGenerationException.class).handled(false).to("mock://ack-generation-ex").     onCompletion().onCompleteOnly().log(LoggingLevel.INFO, routeId, "Test route complete").to("mock://on-complete-only").     onCompletion().onFailureOnly().log(LoggingLevel.INFO, routeId, "Test route complete").to("mock://on-failure-only").     fromF("mllp://%s:%d?bridgeErrorHandler=%b&autoAck=%b&connectTimeout=%d&receiveTimeout=%d", mllpClient.getMllpHost(), mllpClient.getMllpPort(), isBridgeErrorHandler(), isAutoAck(), connectTimeout, responseTimeout).routeId(routeId).to(result). }
false;protected;0;38;;@Override protected RouteBuilder createRouteBuilder() {     mllpClient.setMllpHost("localhost").     mllpClient.setMllpPort(AvailablePortFinder.getNextAvailable()).     return new RouteBuilder() {          int connectTimeout = 500.          int responseTimeout = 5000.          @Override         public void configure() throws Exception {             String routeId = "mllp-test-receiver-route".             onException(MllpInvalidAcknowledgementException.class).handled(false).to("mock://invalid-ack-ex").             onException(MllpAcknowledgementGenerationException.class).handled(false).to("mock://ack-generation-ex").             onCompletion().onCompleteOnly().log(LoggingLevel.INFO, routeId, "Test route complete").to("mock://on-complete-only").             onCompletion().onFailureOnly().log(LoggingLevel.INFO, routeId, "Test route complete").to("mock://on-failure-only").             fromF("mllp://%s:%d?bridgeErrorHandler=%b&autoAck=%b&connectTimeout=%d&receiveTimeout=%d", mllpClient.getMllpHost(), mllpClient.getMllpPort(), isBridgeErrorHandler(), isAutoAck(), connectTimeout, responseTimeout).routeId(routeId).to(result).         }     }. }
false;protected,abstract;0;1;;protected abstract boolean isBridgeErrorHandler().
false;protected,abstract;0;1;;protected abstract boolean isAutoAck().
false;public;0;11;;public void receiveSingleMessage() throws Exception {     NotifyBuilder done = new NotifyBuilder(context).whenDone(1).create().     mllpClient.connect().     mllpClient.sendFramedData(TEST_MESSAGE).     assertTrue("Exchange should have completed", done.matches(10, TimeUnit.SECONDS)).     assertMockEndpointsSatisfied(). }
false;public;0;9;;public void acknowledgementDeliveryFailure() throws Exception {     boolean disconnectAfterSend = true.     mllpClient.setDisconnectMethod(MllpClientResource.DisconnectMethod.RESET).     mllpClient.connect().     mllpClient.sendFramedData(TEST_MESSAGE, disconnectAfterSend).     assertMockEndpointsSatisfied(10, TimeUnit.SECONDS). }
false;public;1;9;;public void unparsableMessage(String testMessage) throws Exception {     NotifyBuilder done = new NotifyBuilder(context).whenDone(1).create().     mllpClient.connect().     mllpClient.sendFramedData(testMessage).     assertTrue("One exchange should have complete", done.matches(5, TimeUnit.SECONDS)).     assertMockEndpointsSatisfied(). }
