commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void configureEventsResending(final boolean enableEventsResending) {     this.enableEventsResending = enableEventsResending. }
false;public;1;17;;public void configureFramework(ServletConfig config) throws ServletException {     initializer.configureFramework(config, false, false, AtmosphereFramework.class).     this.framework = initializer.framework().     this.framework.setUseNativeImplementation(false).     this.framework.addInitParameter(ApplicationConfig.ANALYTICS, "false").     this.framework.addInitParameter(ApplicationConfig.WEBSOCKET_SUPPORT, "true").     this.framework.addInitParameter(ApplicationConfig.WEBSOCKET_PROTOCOL, getEndpoint().isUseStreaming() ? WebsocketStreamHandler.class.getName() : WebsocketHandler.class.getName()).     this.framework.init(config).     WebSocketProtocol wsp = this.framework.getWebSocketProtocol().     if (wsp instanceof WebsocketHandler) {         ((WebsocketHandler) wsp).setConsumer(this).     } else {         throw new IllegalArgumentException("Unexpected WebSocketHandler: " + wsp).     } }
false;public;0;4;;@Override public WebsocketEndpoint getEndpoint() {     return (WebsocketEndpoint) super.getEndpoint(). }
false;;2;4;;void service(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {     this.queryMap = getQueryMap(request.getQueryString()).     framework.doCometSupport(AtmosphereRequestImpl.wrap(request), AtmosphereResponseImpl.wrap(response)). }
false;public;1;5;;public void done(boolean doneSync) {     if (exchange.getException() != null) {         getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException()).     } }
false;public;2;16;;public void sendMessage(final String connectionKey, Object message) {     final Exchange exchange = getEndpoint().createExchange().     // set header and body     exchange.getIn().setHeader(WebsocketConstants.CONNECTION_KEY, connectionKey).     exchange.getIn().setBody(message).     // send exchange using the async routing engine     getAsyncProcessor().process(exchange, new AsyncCallback() {          public void done(boolean doneSync) {             if (exchange.getException() != null) {                 getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException()).             }         }     }). }
false;public;1;5;;public void done(boolean doneSync) {     if (exchange.getException() != null) {         getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException()).     } }
false;public;2;20;;public void sendEventNotification(String connectionKey, int eventType) {     final Exchange exchange = getEndpoint().createExchange().     // set header     exchange.getIn().setHeader(WebsocketConstants.CONNECTION_KEY, connectionKey).     exchange.getIn().setHeader(WebsocketConstants.EVENT_TYPE, eventType).     for (Map.Entry<String, String> param : queryMap.entrySet()) {         exchange.getIn().setHeader(param.getKey(), param.getValue()).     }     // send exchange using the async routing engine     getAsyncProcessor().process(exchange, new AsyncCallback() {          public void done(boolean doneSync) {             if (exchange.getException() != null) {                 getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException()).             }         }     }). }
false;public;1;5;;public void done(boolean doneSync) {     if (exchange.getException() != null) {         getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException()).     } }
false;public;2;17;;public void sendNotDeliveredMessage(List<String> failedConnectionKeys, Object message) {     final Exchange exchange = getEndpoint().createExchange().     // set header and body     exchange.getIn().setHeader(WebsocketConstants.CONNECTION_KEY_LIST, failedConnectionKeys).     exchange.getIn().setHeader(WebsocketConstants.ERROR_TYPE, WebsocketConstants.MESSAGE_NOT_SENT_ERROR_TYPE).     exchange.getIn().setBody(message).     // send exchange using the async routing engine     getAsyncProcessor().process(exchange, new AsyncCallback() {          public void done(boolean doneSync) {             if (exchange.getException() != null) {                 getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException()).             }         }     }). }
false;public;0;3;;public boolean isEnableEventsResending() {     return enableEventsResending. }
false;private;1;11;;private Map<String, String> getQueryMap(String query) {     Map<String, String> map = new HashMap<>().     if (query != null) {         String[] params = query.split("&").         for (String param : params) {             String[] nameval = param.split("=").             map.put(nameval[0], nameval[1]).         }     }     return map. }
