commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public WebsocketEndpoint getEndpoint() {     return (WebsocketEndpoint) super.getEndpoint(). }
false;public;1;42;;@Override public void process(Exchange exchange) throws Exception {     Message in = exchange.getIn().     // TODO support binary data     Object message = in.getBody().     if (message == null) {         LOG.debug("Ignoring a null message").         return.     }     if (!(message instanceof String || message instanceof byte[] || message instanceof Reader || message instanceof InputStream)) {         // fallback to use String         if (LOG.isInfoEnabled()) {             LOG.info("Using String for unexpected message type {}", message.getClass()).         }         message = in.getBody(String.class).     }     // special conversion for Reader and InputStream for now     if (message instanceof Reader) {         message = in.getBody(String.class).     } else if (message instanceof InputStream) {         message = in.getBody(byte[].class).     }     log.debug("Sending to {}", message).     if (getEndpoint().isSendToAll()) {         log.debug("Sending to all -> {}", message).         // TODO consider using atmosphere's broadcast or a more configurable async send         for (final WebSocket websocket : getEndpoint().getWebSocketStore().getAllWebSockets()) {             sendMessage(websocket, message).         }     } else if (in.getHeader(WebsocketConstants.CONNECTION_KEY_LIST) != null) {         List<String> connectionKeyList = in.getHeader(WebsocketConstants.CONNECTION_KEY_LIST, List.class).         messageDistributor(connectionKeyList, message).     } else {         String connectionKey = in.getHeader(WebsocketConstants.CONNECTION_KEY, String.class).         messageDistributor(Arrays.asList(connectionKey), message).     } }
false;private;2;17;;private void messageDistributor(final List<String> connectionKeyList, final Object message) {     if (connectionKeyList == null) {         throw new IllegalArgumentException("Failed to send message to multiple connections. connetion key list is not set.").     }     List<String> notValidConnectionKeys = new ArrayList<>().     for (final String connectionKey : connectionKeyList) {         log.debug("Sending to connection key {} -> {}", connectionKey, message).         sendMessage(getWebSocket(connectionKey, notValidConnectionKeys), message).     }     if (!notValidConnectionKeys.isEmpty()) {         log.debug("Some connections have not received the message {}", message).         getEndpoint().getWebsocketConsumer().sendNotDeliveredMessage(notValidConnectionKeys, message).     } }
false;public;0;15;;@Override public void run() {     try {         if (message instanceof String) {             websocket.write((String) message).         } else if (message instanceof byte[]) {             websocket.write((byte[]) message, 0, ((byte[]) message).length).         } else {             // this should not happen unless one of the supported types is missing above.             LOG.warn("unexpected message type {}", message.getClass()).         }     } catch (Exception e) {         LOG.error("Error when writing to websocket", e).     } }
false;private;2;21;;private void sendMessage(final WebSocket websocket, final Object message) {     if (websocket != null && message != null) {         executor.execute(new Runnable() {              @Override             public void run() {                 try {                     if (message instanceof String) {                         websocket.write((String) message).                     } else if (message instanceof byte[]) {                         websocket.write((byte[]) message, 0, ((byte[]) message).length).                     } else {                         // this should not happen unless one of the supported types is missing above.                         LOG.warn("unexpected message type {}", message.getClass()).                     }                 } catch (Exception e) {                     LOG.error("Error when writing to websocket", e).                 }             }         }).     } }
false;private;2;14;;private WebSocket getWebSocket(final String connectionKey, final List<String> notValidConnectionKeys) {     WebSocket websocket.     if (connectionKey == null) {         throw new IllegalArgumentException("Failed to send message to single connection. connection key is not set.").     } else {         websocket = getEndpoint().getWebSocketStore().getWebSocket(connectionKey).         if (websocket == null) {             // collect for call back to handle not sent message(s) to guaranty delivery             notValidConnectionKeys.add(connectionKey).             log.debug("Failed to send message to single connection. connetion key is not valid. {}", connectionKey).         }     }     return websocket. }
