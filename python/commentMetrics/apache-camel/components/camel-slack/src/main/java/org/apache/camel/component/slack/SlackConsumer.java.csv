commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;24;;@Override protected int poll() throws Exception {     Queue<Exchange> exchanges.     HttpClient client = HttpClientBuilder.create().useSystemProperties().build().     HttpPost httpPost = new HttpPost(slackEndpoint.getServerUrl() + "/api/channels.history").     List<BasicNameValuePair> params = new ArrayList<BasicNameValuePair>().     params.add(new BasicNameValuePair("channel", channelId)).     if (ObjectHelper.isNotEmpty(timestamp)) {         params.add(new BasicNameValuePair("oldest", timestamp)).     }     params.add(new BasicNameValuePair("count", slackEndpoint.getMaxResults())).     params.add(new BasicNameValuePair("token", slackEndpoint.getToken())).     httpPost.setEntity(new UrlEncodedFormEntity(params)).     HttpResponse response = client.execute(httpPost).     String jsonString = readResponse(response).     JsonObject c = (JsonObject) Jsoner.deserialize(jsonString).     JsonArray list = c.getCollection("messages").     exchanges = createExchanges(list).     return processBatch(CastUtils.cast(exchanges)). }
false;private;1;18;;private Queue<Exchange> createExchanges(List<Object> list) {     Queue<Exchange> answer = new LinkedList<>().     if (ObjectHelper.isNotEmpty(list)) {         Iterator it = list.iterator().         int i = 0.         while (it.hasNext()) {             Object object = it.next().             JsonObject singleMess = (JsonObject) object.             if (i == 0) {                 timestamp = (String) singleMess.get("ts").             }             i++.             Exchange exchange = slackEndpoint.createExchange(singleMess).             answer.add(exchange).         }     }     return answer. }
false;public;1;4;;@Override public void done(boolean doneSync) {     log.trace("Processing exchange done"). }
false;public;1;25;;@Override public int processBatch(Queue<Object> exchanges) throws Exception {     int total = exchanges.size().     for (int index = 0. index < total && isBatchAllowed(). index++) {         // only loop if we are started (allowed to run)         final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll()).         // add current index and total as properties         exchange.setProperty(Exchange.BATCH_INDEX, index).         exchange.setProperty(Exchange.BATCH_SIZE, total).         exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1).         // update pending number of exchanges         pendingExchanges = total - index - 1.         getAsyncProcessor().process(exchange, new AsyncCallback() {              @Override             public void done(boolean doneSync) {                 log.trace("Processing exchange done").             }         }).     }     return total. }
false;private;1;25;;private String getChannelId(String channel) throws IOException, DeserializationException {     HttpClient client = HttpClientBuilder.create().useSystemProperties().build().     HttpPost httpPost = new HttpPost(slackEndpoint.getServerUrl() + "/api/channels.list").     List<BasicNameValuePair> params = new ArrayList<BasicNameValuePair>().     params.add(new BasicNameValuePair("token", slackEndpoint.getToken())).     httpPost.setEntity(new UrlEncodedFormEntity(params)).     HttpResponse response = client.execute(httpPost).     String jsonString = readResponse(response).     JsonObject c = (JsonObject) Jsoner.deserialize(jsonString).     JsonArray list = (JsonArray) c.getCollection("channels").     for (JsonObject singleChannel : (List<JsonObject>) (List) list) {         if (singleChannel.get("name") != null) {             if (singleChannel.get("name").equals(channel)) {                 if (singleChannel.get("id") != null) {                     return (String) singleChannel.get("id").                 }             }         }     }     return jsonString. }
