commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;@Override protected void before() throws Throwable {     LOG.info("Starting up Mock-AWS daemon").     executorService.submit(socketListener). }
false;protected;0;17;;@Override protected void after() {     LOG.info("Shutting down Mock-AWS daemon").     socketListener.close().     executorService.shutdown().     try {         if (!executorService.awaitTermination(10, TimeUnit.SECONDS)) {             executorService.shutdownNow().             if (!executorService.awaitTermination(10, TimeUnit.SECONDS)) {                 LOG.error("Could not terminate UDP server").             }         }     } catch (InterruptedException iEx) {         executorService.shutdownNow().         Thread.currentThread().interrupt().     } }
false;;0;4;;Map<String, TestTrace> getReceivedData() {     LOG.trace("List of received data packages requested: {}", receivedTraces.size()).     return receivedTraces. }
false;public;0;63;;@Override public void run() {     try {         LOG.info("Starting UDP socket listening on port 2000").         serverSocket = new DatagramSocket(2000).         StringBuilder sb = new StringBuilder().         while (!done) {             byte[] receiveData = new byte[2048].             DatagramPacket receivedPacket = new DatagramPacket(receiveData, receiveData.length).             serverSocket.receive(receivedPacket).             LOG.debug("Receiving UDP data").             sb.append(new String(receivedPacket.getData())).             String locSegment = null.             try {                 String raw = sb.toString().trim().                 String[] segments = raw.split("\\n").                 for (String segment : segments) {                     locSegment = segment.                     LOG.trace("Processing received segment: {}", segment).                     if (!"".equals(segment)) {                         if (!segment.endsWith("}") || StringUtils.countMatches(segment, "{") != StringUtils.countMatches(segment, "}") || StringUtils.countMatches(segment, "[") != StringUtils.countMatches(segment, "]")) {                             LOG.trace("Skipping incomplete content: {}", segment).                             continue.                         }                         if (segment.contains("format") && segment.contains("version")) {                             LOG.trace("Skipping format and version JSON").                         } else {                             LOG.trace("Converting segment {} to a Java object", segment).                             // clean the JSON string received                             LOG.trace("Original JSON content: {}", segment).                             locSegment = segment.                             JsonObject json = (JsonObject) JsonParser.parse(segment).                             String traceId = json.getString("trace_id").                             TestTrace testTrace = receivedTraces.get(traceId).                             if (null == testTrace) {                                 testTrace = new TestTrace().                             }                             testTrace.withSegment(convertData(json)).                             receivedTraces.put(traceId, testTrace).                         }                         sb.delete(0, segment.length()).                         if (sb.length() > 1 && sb.charAt(0) == '\n') {                             sb.deleteCharAt(0).                         }                     }                 }                 LOG.trace("Item {} received. JSON content: {}, Raw: {}", receivedTraces.size(), receivedTraces, raw).             } catch (Exception jsonEx) {                 LOG.warn("Could not convert segment " + locSegment + " to a Java object", jsonEx).             }         }     } catch (SocketException sex) {         LOG.info("UDP socket closed").     } catch (Exception ex) {         LOG.warn("UDP socket failed due to " + ex.getLocalizedMessage(), ex).     } }
false;private;1;15;;private TestSegment convertData(JsonObject json) {     String name = json.getString("name").     double startTime = json.getDouble("start_time").     TestSegment segment = new TestSegment(name, startTime).     if (json.has("subsegments")) {         JsonArray jsonSubsegments = (JsonArray) json.get("subsegments").         List<TestSubsegment> subsegments = convertSubsegments(jsonSubsegments).         for (TestSubsegment subsegment : subsegments) {             segment.withSubsegment(subsegment).         }     }     addAnnotationsIfAvailable(segment, json).     addMetadataIfAvailable(segment, json).     return segment. }
false;private;1;8;;private List<TestSubsegment> convertSubsegments(JsonArray jsonSubsegments) {     List<TestSubsegment> subsegments = new ArrayList<>(jsonSubsegments.size()).     for (int i = 0. i < jsonSubsegments.size(). i++) {         JsonObject jsonSubsegment = jsonSubsegments.toArray(new JsonObject[jsonSubsegments.size()])[i].         subsegments.add(convertSubsegment(jsonSubsegment)).     }     return subsegments. }
false;private;1;12;;private TestSubsegment convertSubsegment(JsonObject json) {     TestSubsegment subsegment = new TestSubsegment((String) json.get("name")).     if (json.has("subsegments")) {         List<TestSubsegment> subsegments = convertSubsegments((JsonArray) json.get("subsegments")).         for (TestSubsegment tss : subsegments) {             subsegment.withSubsegment(tss).         }     }     addAnnotationsIfAvailable(subsegment, json).     addMetadataIfAvailable(subsegment, json).     return subsegment. }
false;private;2;8;;private void addAnnotationsIfAvailable(TestEntity<?> entity, JsonObject json) {     if (json.has("annotations")) {         JsonObject annotations = (JsonObject) json.get("annotations").         for (String key : annotations.getKeys()) {             entity.withAnnotation(key, annotations.get(key)).         }     } }
false;private;2;11;;private void addMetadataIfAvailable(TestEntity<?> entity, JsonObject json) {     if (json.has("metadata")) {         JsonObject rawMetadata = (JsonObject) json.get("metadata").         Map<String, Map<String, Object>> metadata = parseMetadata(rawMetadata).         for (String namespace : metadata.keySet()) {             for (String key : metadata.get(namespace).keySet()) {                 entity.withMetadata(namespace, key, metadata.get(namespace).get(key)).             }         }     } }
false;private;1;23;;private Map<String, Map<String, Object>> parseMetadata(JsonObject json) {     /*              "metadata" : {                 "default" : {                     "meta1" : "meta1"                 },                 "customNamespace" : {                     "meta2" : "meta2"                 }              }              */     Map<String, Map<String, Object>> metadata = new LinkedHashMap<>(json.getKeys().size()).     for (String namespace : json.getKeys()) {         JsonObject namespaceData = (JsonObject) json.get(namespace).         if (!metadata.containsKey(namespace)) {             metadata.put(namespace, new LinkedHashMap<>(namespaceData.getKeys().size())).         }         for (String key : namespaceData.getKeys()) {             metadata.get(namespace).put(key, namespaceData.get(key)).         }     }     return metadata. }
false;private;0;7;;private void close() {     done = true.     if (null != serverSocket) {         LOG.info("Shutting down UDP socket").         serverSocket.close().     } }
