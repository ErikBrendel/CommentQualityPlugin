commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;0;4;;@Override public CamelContext getCamelContext() {     return this.camelContext. }
false;public;3;5;;@Override public RoutePolicy createRoutePolicy(CamelContext camelContext, String routeId, NamedNode route) {     init(camelContext).     return new XRayRoutePolicy(routeId). }
false;protected;0;18;;@Override protected void doStart() throws Exception {     ObjectHelper.notNull(camelContext, "CamelContext", this).     camelContext.getManagementStrategy().addEventNotifier(eventNotifier).     if (!camelContext.getRoutePolicyFactories().contains(this)) {         camelContext.addRoutePolicyFactory(this).     }     if (null == tracingStrategy) {         log.info("No tracing strategy available. Defaulting to no-op strategy").         tracingStrategy = new NoopTracingStrategy().     }     camelContext.addInterceptStrategy(tracingStrategy).     log.debug("Starting XRay tracer"). }
false;protected;0;9;;@Override protected void doStop() throws Exception {     // stop event notifier     camelContext.getManagementStrategy().removeEventNotifier(eventNotifier).     ServiceHelper.stopAndShutdownService(eventNotifier).     camelContext.getRoutePolicyFactories().remove(this).     log.debug("XRay tracer stopped"). }
true;public;1;11;/**  * Initializes this AWS XRay tracer implementation as service within the Camel environment.  *  * @param camelContext The context to register this tracer as service with  */ ;/**  * Initializes this AWS XRay tracer implementation as service within the Camel environment.  *  * @param camelContext The context to register this tracer as service with  */ public void init(CamelContext camelContext) {     if (!camelContext.hasService(this)) {         try {             log.debug("Initializing XRay tracer").             // start this service eager so we init before Camel is starting up             camelContext.addService(this, true, true).         } catch (Exception e) {             throw RuntimeCamelException.wrapRuntimeCamelException(e).         }     } }
true;public;0;3;/**  * Returns the currently used tracing strategy which is responsible for tracking invoked EIP or  * beans.  *  * @return The currently used tracing strategy  */ ;/**  * Returns the currently used tracing strategy which is responsible for tracking invoked EIP or  * beans.  *  * @return The currently used tracing strategy  */ public InterceptStrategy getTracingStrategy() {     return tracingStrategy. }
true;public;1;3;/**  * Specifies the instance responsible for tracking invoked EIP and beans with AWS XRay.  *  * @param tracingStrategy The instance which tracks invoked EIP and beans  */ ;/**  * Specifies the instance responsible for tracking invoked EIP and beans with AWS XRay.  *  * @param tracingStrategy The instance which tracks invoked EIP and beans  */ public void setTracingStrategy(InterceptStrategy tracingStrategy) {     this.tracingStrategy = tracingStrategy. }
true;public;0;3;/**  * Returns the set of currently excluded routes. Any route ID specified in the returned set will  * not be monitored by this AWS XRay tracer implementation.  *  * @return The IDs of the currently excluded routes for which no tracking will be performed  */ ;/**  * Returns the set of currently excluded routes. Any route ID specified in the returned set will  * not be monitored by this AWS XRay tracer implementation.  *  * @return The IDs of the currently excluded routes for which no tracking will be performed  */ public Set<String> getExcludePatterns() {     return this.excludePatterns. }
true;public;1;3;/**  * Excludes all of the routes matching any of the contained routeIds within the given argument  * from tracking by this tracer implementation. Excluded routes will not appear within the AWS  * XRay monitoring.  *  * @param excludePatterns A set of routeIds which should not be tracked by this tracer  */ ;/**  * Excludes all of the routes matching any of the contained routeIds within the given argument  * from tracking by this tracer implementation. Excluded routes will not appear within the AWS  * XRay monitoring.  *  * @param excludePatterns A set of routeIds which should not be tracked by this tracer  */ public void setExcludePatterns(Set<String> excludePatterns) {     this.excludePatterns = excludePatterns. }
true;public;1;3;/**  * Adds an exclude pattern that will disable tracing for Camel messages that matches the pattern.  *  * @param pattern The pattern such as route id, endpoint url  */ ;/**  * Adds an exclude pattern that will disable tracing for Camel messages that matches the pattern.  *  * @param pattern The pattern such as route id, endpoint url  */ public void addExcludePattern(String pattern) {     excludePatterns.add(pattern). }
false;private;1;12;;private boolean isExcluded(String routeId) {     // check for a defined routeId     if (!excludePatterns.isEmpty()) {         for (String pattern : excludePatterns) {             if (pattern.equals(routeId)) {                 log.debug("Ignoring route with ID {}", routeId).                 return true.             }         }     }     return false. }
false;protected;1;7;;protected SegmentDecorator getSegmentDecorator(Endpoint endpoint) {     SegmentDecorator sd = decorators.get(URI.create(endpoint.getEndpointUri()).getScheme()).     if (null == sd) {         return SegmentDecorator.DEFAULT.     }     return sd. }
false;protected;1;7;;protected Entity getTraceEntityFromExchange(Exchange exchange) {     Entity entity = exchange.getIn().getHeader(XRAY_TRACE_ENTITY, Entity.class).     if (entity == null) {         entity = (Entity) exchange.getProperty(CURRENT_SEGMENT).     }     return entity. }
false;public;1;65;;@Override public void notify(CamelEvent event) throws Exception {     if (event instanceof ExchangeSendingEvent) {         ExchangeSendingEvent ese = (ExchangeSendingEvent) event.         log.trace("-> {} - target: {} (routeId: {})", event.getClass().getSimpleName(), ese.getEndpoint(), ese.getExchange().getFromRouteId()).         SegmentDecorator sd = getSegmentDecorator(ese.getEndpoint()).         if (!sd.newSegment()) {             return.         }         Entity entity = getTraceEntityFromExchange(ese.getExchange()).         if (entity != null) {             AWSXRay.setTraceEntity(entity).             // AWS XRay does only allow a certain set of characters to appear within a name             // Allowed characters: a-z, A-Z, 0-9, _, ., :, /, %, &, #, =, +, \, -, @             String name = sd.getOperationName(ese.getExchange(), ese.getEndpoint()).             if (sd.getComponent() != null) {                 name = sd.getComponent() + ":" + name.             }             name = sanitizeName(name).             try {                 Subsegment subsegment = AWSXRay.beginSubsegment(name).                 sd.pre(subsegment, ese.getExchange(), ese.getEndpoint()).                 log.trace("Creating new subsegment with ID {} and name {} (parent {}, references: {})", subsegment.getId(), subsegment.getName(), subsegment.getParentSegment().getId(), subsegment.getParentSegment().getReferenceCount()).                 ese.getExchange().setProperty(CURRENT_SEGMENT, subsegment).             } catch (AlreadyEmittedException aeEx) {                 log.warn("Ignoring starting of subsegment " + name + " as its parent segment" + " was already emitted to AWS.").             }         } else {             log.trace("Ignoring creation of XRay subsegment as no segment exists in the current thread").         }     } else if (event instanceof ExchangeSentEvent) {         ExchangeSentEvent ese = (ExchangeSentEvent) event.         log.trace("-> {} - target: {} (routeId: {})", event.getClass().getSimpleName(), ese.getEndpoint(), ese.getExchange().getFromRouteId()).         Entity entity = getTraceEntityFromExchange(ese.getExchange()).         if (entity instanceof Subsegment) {             AWSXRay.setTraceEntity(entity).             SegmentDecorator sd = getSegmentDecorator(ese.getEndpoint()).             try {                 Subsegment subsegment = (Subsegment) entity.                 sd.post(subsegment, ese.getExchange(), ese.getEndpoint()).                 subsegment.close().                 log.trace("Closing down subsegment with ID {} and name {}", subsegment.getId(), subsegment.getName()).                 log.trace("Setting trace entity for exchange {} to {}", ese.getExchange(), subsegment.getParent()).                 ese.getExchange().setProperty(CURRENT_SEGMENT, subsegment.getParent()).             } catch (AlreadyEmittedException aeEx) {                 log.warn("Ignoring close of subsegment " + entity.getName() + " as its parent segment was already emitted to AWS").             }         }     } else {         log.trace("Received event {} from source {}", event, event.getSource()).     } }
false;public;1;6;;@Override public boolean isEnabled(CamelEvent event) {     // listen for either when an exchange invoked an other endpoint     return event instanceof ExchangeSendingEvent || event instanceof ExchangeSentEvent. }
false;public;0;4;;@Override public String toString() {     return "XRayEventNotifier". }
false;public;2;45;;@Override public void onExchangeBegin(Route route, Exchange exchange) {     // kicks in after a seda-thread was created. The new thread has the control     if (isExcluded(route.getId())) {         return.     }     log.trace("=> RoutePolicy-Begin: Route: {} - RouteId: {}", routeId, route.getId()).     Entity entity = getTraceEntityFromExchange(exchange).     boolean createSegment = entity == null || !Objects.equals(entity.getName(), routeId).     TraceID traceID.     if (exchange.getIn().getHeaders().containsKey(XRAY_TRACE_ID)) {         traceID = TraceID.fromString(exchange.getIn().getHeader(XRAY_TRACE_ID, String.class)).     } else {         traceID = new TraceID().         exchange.getIn().setHeader(XRAY_TRACE_ID, traceID.toString()).     }     AWSXRay.setTraceEntity(entity).     SegmentDecorator sd = getSegmentDecorator(route.getEndpoint()).     if (createSegment) {         Segment segment = AWSXRay.beginSegment(sanitizeName(route.getId())).         segment.setParent(entity).         segment.setTraceId(traceID).         sd.pre(segment, exchange, route.getEndpoint()).         log.trace("Created new XRay segment {} with name {}", segment.getId(), segment.getName()).         exchange.setProperty(CURRENT_SEGMENT, segment).     } else {         String segmentName = entity.getId().         try {             Subsegment subsegment = AWSXRay.beginSubsegment(route.getId()).             sd.pre(subsegment, exchange, route.getEndpoint()).             log.trace("Creating new subsegment with ID {} and name {} (parent {}, references: {})", subsegment.getId(), subsegment.getName(), subsegment.getParentSegment().getId(), subsegment.getParentSegment().getReferenceCount()).             exchange.setProperty(CURRENT_SEGMENT, subsegment).         } catch (AlreadyEmittedException aeEx) {             log.warn("Ignoring opening of subsegment " + route.getId() + " as its parent segment " + segmentName + " was already emitted before.").         }     } }
false;public;2;27;;@Override public void onExchangeDone(Route route, Exchange exchange) {     // kicks in before the seda-thread is terminated. Control is still in the seda-thread     if (isExcluded(route.getId())) {         return.     }     log.trace("=> RoutePolicy-Done: Route: {} - RouteId: {}", routeId, route.getId()).     Entity entity = getTraceEntityFromExchange(exchange).     AWSXRay.setTraceEntity(entity).     try {         SegmentDecorator sd = getSegmentDecorator(route.getEndpoint()).         sd.post(entity, exchange, route.getEndpoint()).         entity.close().         log.trace("Closing down (sub)segment {} with name {} (parent {}, references: {})", entity.getId(), entity.getName(), entity.getParentSegment().getId(), entity.getParentSegment().getReferenceCount()).         exchange.setProperty(CURRENT_SEGMENT, entity.getParent()).     } catch (AlreadyEmittedException aeEx) {         log.warn("Ignoring closing of (sub)segment {} as the segment was already emitted.", route.getId()).     } catch (Exception e) {         log.warn("Error closing entity").     } finally {         AWSXRay.setTraceEntity(null).     } }
false;public;0;4;;@Override public String toString() {     return "XRayRoutePolicy". }
true;public,static;1;5;/**  * Removes invalid characters from AWS XRay (sub-)segment names and replaces the invalid characters with an  * underscore character.  *  * @param name The name to assign to an AWS XRay (sub-)segment  * @return The sanitized name of the (sub-)segment  */ ;/**  * Removes invalid characters from AWS XRay (sub-)segment names and replaces the invalid characters with an  * underscore character.  *  * @param name The name to assign to an AWS XRay (sub-)segment  * @return The sanitized name of the (sub-)segment  */ public static String sanitizeName(String name) {     // \w = a-zA-Z0-9_     return name.replaceAll("[^\\w.:/%&#=+\\-@]", "_"). }
