commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public VertxFactory getVertxFactory() {     return vertxFactory. }
true;public;1;3;/**  * To use a custom VertxFactory implementation  */ ;/**  * To use a custom VertxFactory implementation  */ public void setVertxFactory(VertxFactory vertxFactory) {     this.vertxFactory = vertxFactory. }
false;public;0;3;;public String getHost() {     return host. }
true;public;1;3;/**  * Hostname for creating an embedded clustered EventBus  */ ;/**  * Hostname for creating an embedded clustered EventBus  */ public void setHost(String host) {     this.host = host. }
false;public;0;3;;public int getPort() {     return port. }
true;public;1;3;/**  * Port for creating an embedded clustered EventBus  */ ;/**  * Port for creating an embedded clustered EventBus  */ public void setPort(int port) {     this.port = port. }
false;public;0;3;;public VertxOptions getVertxOptions() {     return vertxOptions. }
true;public;1;3;/**  * Options to use for creating vertx  */ ;/**  * Options to use for creating vertx  */ public void setVertxOptions(VertxOptions vertxOptions) {     this.vertxOptions = vertxOptions. }
false;public;0;3;;public Vertx getVertx() {     return vertx. }
true;public;1;3;/**  * To use the given vertx EventBus instead of creating a new embedded EventBus  */ ;/**  * To use the given vertx EventBus instead of creating a new embedded EventBus  */ public void setVertx(Vertx vertx) {     this.vertx = vertx. }
false;public;0;3;;public int getTimeout() {     return timeout. }
true;public;1;3;/**  * Timeout in seconds to wait for clustered Vertx EventBus to be ready.  * <p/>  * The default value is 60.  */ ;/**  * Timeout in seconds to wait for clustered Vertx EventBus to be ready.  * <p/>  * The default value is 60.  */ public void setTimeout(int timeout) {     this.timeout = timeout. }
false;protected;3;5;;protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {     VertxEndpoint endpoint = new VertxEndpoint(uri, this, remaining).     setProperties(endpoint, parameters).     return endpoint. }
false;public;1;11;;@Override public void handle(AsyncResult<Vertx> event) {     if (event.cause() != null) {         log.warn("Error creating Clustered Vertx " + host + ":" + port + " due " + event.cause().getMessage(), event.cause()).     } else if (event.succeeded()) {         vertx = event.result().         log.info("EventBus is ready: {}", vertx).     }     latch.countDown(). }
false;protected;0;59;;@Override protected void doStart() throws Exception {     super.doStart().     if (vertx == null) {         if (vertxFactory == null) {             vertxFactory = new VertxFactoryImpl().         }         if (vertxOptions == null) {             vertxOptions = new VertxOptions().             if (ObjectHelper.isNotEmpty(host)) {                 vertxOptions.setClusterHost(host).                 vertxOptions.setClustered(true).             }             if (port > 0) {                 vertxOptions.setClusterPort(port).                 vertxOptions.setClustered(true).             }         }         // we are creating vertx so we should handle its lifecycle         createdVertx = true.         final CountDownLatch latch = new CountDownLatch(1).         // lets using a host / port if a host name is specified         if (vertxOptions.isClustered()) {             log.info("Creating Clustered Vertx {}:{}", vertxOptions.getClusterHost(), vertxOptions.getClusterPort()).             // use the async api as we want to wait for the eventbus to be ready before we are in started state             vertxFactory.clusteredVertx(vertxOptions, new Handler<AsyncResult<Vertx>>() {                  @Override                 public void handle(AsyncResult<Vertx> event) {                     if (event.cause() != null) {                         log.warn("Error creating Clustered Vertx " + host + ":" + port + " due " + event.cause().getMessage(), event.cause()).                     } else if (event.succeeded()) {                         vertx = event.result().                         log.info("EventBus is ready: {}", vertx).                     }                     latch.countDown().                 }             }).         } else {             log.info("Creating Non-Clustered Vertx").             vertx = vertxFactory.vertx().             log.info("EventBus is ready: {}", vertx).             latch.countDown().         }         if (latch.getCount() > 0) {             log.info("Waiting for EventBus to be ready using {} sec as timeout", timeout).             latch.await(timeout, TimeUnit.SECONDS).         }     } else {         log.debug("Using Vert.x instance set on the component level.").     } }
false;protected;0;9;;@Override protected void doStop() throws Exception {     super.doStop().     if (createdVertx && vertx != null) {         log.info("Stopping Vertx {}", vertx).         vertx.close().     } }
