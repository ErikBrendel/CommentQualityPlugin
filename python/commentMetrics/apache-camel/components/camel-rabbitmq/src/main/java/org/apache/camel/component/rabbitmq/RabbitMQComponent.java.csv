commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;118;;@Override protected RabbitMQEndpoint createEndpoint(String uri, String remaining, Map<String, Object> params) throws Exception {     String host = getHostname().     int port = getPortNumber().     String exchangeName = remaining.     if (remaining.contains(":") || remaining.contains("/")) {         log.warn("The old syntax rabbitmq://hostname:port/exchangeName is deprecated. You should configure the hostname on the component or ConnectionFactory").         try {             URI u = new URI("http://" + remaining).             host = u.getHost().             port = u.getPort().             if (u.getPath().trim().length() > 1) {                 exchangeName = u.getPath().substring(1).             } else {                 exchangeName = "".             }         } catch (Throwable e) {         // ignore         }     }     // ConnectionFactory reference     ConnectionFactory connectionFactory = resolveAndRemoveReferenceParameter(params, "connectionFactory", ConnectionFactory.class, getConnectionFactory()).     // try to lookup if there is a single instance in the registry of the ConnectionFactory     if (connectionFactory == null && isAutoDetectConnectionFactory()) {         Map<String, ConnectionFactory> map = getCamelContext().getRegistry().findByTypeWithName(ConnectionFactory.class).         if (map != null && map.size() == 1) {             Map.Entry<String, ConnectionFactory> entry = map.entrySet().iterator().next().             connectionFactory = entry.getValue().             String name = entry.getKey().             if (name == null) {                 name = "anonymous".             }             log.info("Auto-detected single instance: {} of type ConnectionFactory in Registry to be used as ConnectionFactory when creating endpoint: {}", name, uri).         }     }     @SuppressWarnings("unchecked")     Map<String, Object> clientProperties = resolveAndRemoveReferenceParameter(params, "clientProperties", Map.class, getClientProperties()).     TrustManager trustManager = resolveAndRemoveReferenceParameter(params, "trustManager", TrustManager.class, getTrustManager()).     RabbitMQEndpoint endpoint.     if (connectionFactory == null) {         endpoint = new RabbitMQEndpoint(uri, this).     } else {         endpoint = new RabbitMQEndpoint(uri, this, connectionFactory).     }     endpoint.setHostname(host).     endpoint.setPortNumber(port).     endpoint.setUsername(getUsername()).     endpoint.setPassword(getPassword()).     endpoint.setVhost(getVhost()).     endpoint.setAddresses(getAddresses()).     endpoint.setThreadPoolSize(getThreadPoolSize()).     endpoint.setExchangeName(exchangeName).     endpoint.setClientProperties(clientProperties).     endpoint.setSslProtocol(getSslProtocol()).     endpoint.setTrustManager(trustManager).     endpoint.setConnectionTimeout(getConnectionTimeout()).     endpoint.setRequestedChannelMax(getRequestedChannelMax()).     endpoint.setRequestedFrameMax(getRequestedFrameMax()).     endpoint.setRequestedHeartbeat(getRequestedHeartbeat()).     endpoint.setAutomaticRecoveryEnabled(getAutomaticRecoveryEnabled()).     endpoint.setNetworkRecoveryInterval(getNetworkRecoveryInterval()).     endpoint.setTopologyRecoveryEnabled(getTopologyRecoveryEnabled()).     endpoint.setPrefetchEnabled(isPrefetchEnabled()).     endpoint.setPrefetchSize(getPrefetchSize()).     endpoint.setPrefetchCount(getPrefetchCount()).     endpoint.setPrefetchGlobal(isPrefetchGlobal()).     endpoint.setChannelPoolMaxSize(getChannelPoolMaxSize()).     endpoint.setChannelPoolMaxWait(getChannelPoolMaxWait()).     endpoint.setRequestTimeout(getRequestTimeout()).     endpoint.setRequestTimeoutCheckerInterval(getRequestTimeoutCheckerInterval()).     endpoint.setTransferException(isTransferException()).     endpoint.setPublisherAcknowledgements(isPublisherAcknowledgements()).     endpoint.setPublisherAcknowledgementsTimeout(getPublisherAcknowledgementsTimeout()).     endpoint.setGuaranteedDeliveries(isGuaranteedDeliveries()).     endpoint.setMandatory(isMandatory()).     endpoint.setImmediate(isImmediate()).     endpoint.setAutoAck(isAutoAck()).     endpoint.setAutoDelete(isAutoDelete()).     endpoint.setDurable(isDurable()).     endpoint.setExclusive(isExclusive()).     endpoint.setExclusiveConsumer(isExclusiveConsumer()).     endpoint.setPassive(isPassive()).     endpoint.setSkipExchangeDeclare(isSkipExchangeDeclare()).     endpoint.setSkipQueueBind(isSkipQueueBind()).     endpoint.setSkipQueueDeclare(isSkipQueueDeclare()).     endpoint.setDeclare(isDeclare()).     endpoint.setDeadLetterExchange(getDeadLetterExchange()).     endpoint.setDeadLetterExchangeType(getDeadLetterExchangeType()).     endpoint.setDeadLetterQueue(getDeadLetterQueue()).     endpoint.setDeadLetterRoutingKey(getDeadLetterRoutingKey()).     endpoint.setAllowNullHeaders(isAllowNullHeaders()).     setProperties(endpoint, params).     if (log.isDebugEnabled()) {         log.debug("Creating RabbitMQEndpoint with host {}:{} and exchangeName: {}", new Object[] { endpoint.getHostname(), endpoint.getPortNumber(), endpoint.getExchangeName() }).     }     Map<String, Object> localArgs = new HashMap<>().     if (getArgs() != null) {         // copy over the component configured args         localArgs.putAll(getArgs()).     }     localArgs.putAll(IntrospectionSupport.extractProperties(params, ARG_PREFIX)).     endpoint.setArgs(localArgs).     // Change null headers processing for message converter     endpoint.getMessageConverter().setAllowNullHeaders(endpoint.isAllowNullHeaders()).     return endpoint. }
false;public;0;3;;public String getHostname() {     return hostname. }
true;public;1;3;/**  * The hostname of the running RabbitMQ instance or cluster.  */ ;/**  * The hostname of the running RabbitMQ instance or cluster.  */ public void setHostname(String hostname) {     this.hostname = hostname. }
false;public;0;3;;public int getPortNumber() {     return portNumber. }
true;public;1;3;/**  * Port number for the host with the running rabbitmq instance or cluster.  */ ;/**  * Port number for the host with the running rabbitmq instance or cluster.  */ public void setPortNumber(int portNumber) {     this.portNumber = portNumber. }
false;public;0;3;;public String getUsername() {     return username. }
true;public;1;3;/**  * Username in case of authenticated access  */ ;/**  * Username in case of authenticated access  */ public void setUsername(String username) {     this.username = username. }
false;public;0;3;;public String getPassword() {     return password. }
true;public;1;3;/**  * Password for authenticated access  */ ;/**  * Password for authenticated access  */ public void setPassword(String password) {     this.password = password. }
false;public;0;3;;public String getVhost() {     return vhost. }
true;public;1;3;/**  * The vhost for the channel  */ ;/**  * The vhost for the channel  */ public void setVhost(String vhost) {     this.vhost = vhost. }
true;public;1;6;/**  * If this option is set, camel-rabbitmq will try to create connection based  * on the setting of option addresses. The addresses value is a string which  * looks like "server1:12345, server2:12345"  */ ;/**  * If this option is set, camel-rabbitmq will try to create connection based  * on the setting of option addresses. The addresses value is a string which  * looks like "server1:12345, server2:12345"  */ public void setAddresses(String addresses) {     Address[] addressArray = Address.parseAddresses(addresses).     if (addressArray.length > 0) {         this.addresses = addressArray.     } }
true;public;1;3;/**  * If this option is set, camel-rabbitmq will try to create connection based  * on the setting of option addresses. The addresses value is a string which  * looks like "server1:12345, server2:12345"  */ ;/**  * If this option is set, camel-rabbitmq will try to create connection based  * on the setting of option addresses. The addresses value is a string which  * looks like "server1:12345, server2:12345"  */ public void setAddresses(Address[] addresses) {     this.addresses = addresses. }
false;public;0;3;;public Address[] getAddresses() {     return addresses. }
false;public;0;3;;public ConnectionFactory getConnectionFactory() {     return connectionFactory. }
true;public;1;3;/**  * To use a custom RabbitMQ connection factory. When this option is set, all  * connection options (connectionTimeout, requestedChannelMax...) set on URI  * are not used  */ ;/**  * To use a custom RabbitMQ connection factory. When this option is set, all  * connection options (connectionTimeout, requestedChannelMax...) set on URI  * are not used  */ public void setConnectionFactory(ConnectionFactory connectionFactory) {     this.connectionFactory = connectionFactory. }
false;public;0;3;;public int getThreadPoolSize() {     return threadPoolSize. }
true;public;1;3;/**  * The consumer uses a Thread Pool Executor with a fixed number of threads.  * This setting allows you to set that number of threads.  */ ;/**  * The consumer uses a Thread Pool Executor with a fixed number of threads.  * This setting allows you to set that number of threads.  */ public void setThreadPoolSize(int threadPoolSize) {     this.threadPoolSize = threadPoolSize. }
false;public;0;3;;public boolean isAutoDetectConnectionFactory() {     return autoDetectConnectionFactory. }
true;public;1;3;/**  * Whether to auto-detect looking up RabbitMQ connection factory from the registry.  * When enabled and a single instance of the connection factory is found then it will be used.  * An explicit connection factory can be configured on the component or endpoint level which takes precedence.  */ ;/**  * Whether to auto-detect looking up RabbitMQ connection factory from the registry.  * When enabled and a single instance of the connection factory is found then it will be used.  * An explicit connection factory can be configured on the component or endpoint level which takes precedence.  */ public void setAutoDetectConnectionFactory(boolean autoDetectConnectionFactory) {     this.autoDetectConnectionFactory = autoDetectConnectionFactory. }
false;public;0;3;;public int getConnectionTimeout() {     return connectionTimeout. }
true;public;1;3;/**  * Connection timeout  */ ;/**  * Connection timeout  */ public void setConnectionTimeout(int connectionTimeout) {     this.connectionTimeout = connectionTimeout. }
false;public;0;3;;public int getRequestedChannelMax() {     return requestedChannelMax. }
true;public;1;3;/**  * Connection requested channel max (max number of channels offered)  */ ;/**  * Connection requested channel max (max number of channels offered)  */ public void setRequestedChannelMax(int requestedChannelMax) {     this.requestedChannelMax = requestedChannelMax. }
false;public;0;3;;public int getRequestedFrameMax() {     return requestedFrameMax. }
true;public;1;3;/**  * Connection requested frame max (max size of frame offered)  */ ;/**  * Connection requested frame max (max size of frame offered)  */ public void setRequestedFrameMax(int requestedFrameMax) {     this.requestedFrameMax = requestedFrameMax. }
false;public;0;3;;public int getRequestedHeartbeat() {     return requestedHeartbeat. }
true;public;1;3;/**  * Connection requested heartbeat (heart-beat in seconds offered)  */ ;/**  * Connection requested heartbeat (heart-beat in seconds offered)  */ public void setRequestedHeartbeat(int requestedHeartbeat) {     this.requestedHeartbeat = requestedHeartbeat. }
false;public;0;3;;public Boolean getAutomaticRecoveryEnabled() {     return automaticRecoveryEnabled. }
true;public;1;3;/**  * Enables connection automatic recovery (uses connection implementation  * that performs automatic recovery when connection shutdown is not  * initiated by the application)  */ ;/**  * Enables connection automatic recovery (uses connection implementation  * that performs automatic recovery when connection shutdown is not  * initiated by the application)  */ public void setAutomaticRecoveryEnabled(Boolean automaticRecoveryEnabled) {     this.automaticRecoveryEnabled = automaticRecoveryEnabled. }
false;public;0;3;;public Integer getNetworkRecoveryInterval() {     return networkRecoveryInterval. }
true;public;1;3;/**  * Network recovery interval in milliseconds (interval used when recovering  * from network failure)  */ ;/**  * Network recovery interval in milliseconds (interval used when recovering  * from network failure)  */ public void setNetworkRecoveryInterval(Integer networkRecoveryInterval) {     this.networkRecoveryInterval = networkRecoveryInterval. }
false;public;0;3;;public Boolean getTopologyRecoveryEnabled() {     return topologyRecoveryEnabled. }
true;public;1;3;/**  * Enables connection topology recovery (should topology recovery be  * performed?)  */ ;/**  * Enables connection topology recovery (should topology recovery be  * performed?)  */ public void setTopologyRecoveryEnabled(Boolean topologyRecoveryEnabled) {     this.topologyRecoveryEnabled = topologyRecoveryEnabled. }
false;public;0;3;;public boolean isPrefetchEnabled() {     return prefetchEnabled. }
true;public;1;3;/**  * Enables the quality of service on the RabbitMQConsumer side. You need to  * specify the option of prefetchSize, prefetchCount, prefetchGlobal at the  * same time  */ ;/**  * Enables the quality of service on the RabbitMQConsumer side. You need to  * specify the option of prefetchSize, prefetchCount, prefetchGlobal at the  * same time  */ public void setPrefetchEnabled(boolean prefetchEnabled) {     this.prefetchEnabled = prefetchEnabled. }
true;public;1;3;/**  * The maximum amount of content (measured in octets) that the server will  * deliver, 0 if unlimited. You need to specify the option of prefetchSize,  * prefetchCount, prefetchGlobal at the same time  */ ;/**  * The maximum amount of content (measured in octets) that the server will  * deliver, 0 if unlimited. You need to specify the option of prefetchSize,  * prefetchCount, prefetchGlobal at the same time  */ public void setPrefetchSize(int prefetchSize) {     this.prefetchSize = prefetchSize. }
false;public;0;3;;public int getPrefetchSize() {     return prefetchSize. }
true;public;1;3;/**  * The maximum number of messages that the server will deliver, 0 if  * unlimited. You need to specify the option of prefetchSize, prefetchCount,  * prefetchGlobal at the same time  */ ;/**  * The maximum number of messages that the server will deliver, 0 if  * unlimited. You need to specify the option of prefetchSize, prefetchCount,  * prefetchGlobal at the same time  */ public void setPrefetchCount(int prefetchCount) {     this.prefetchCount = prefetchCount. }
false;public;0;3;;public int getPrefetchCount() {     return prefetchCount. }
true;public;1;3;/**  * If the settings should be applied to the entire channel rather than each  * consumer You need to specify the option of prefetchSize, prefetchCount,  * prefetchGlobal at the same time  */ ;/**  * If the settings should be applied to the entire channel rather than each  * consumer You need to specify the option of prefetchSize, prefetchCount,  * prefetchGlobal at the same time  */ public void setPrefetchGlobal(boolean prefetchGlobal) {     this.prefetchGlobal = prefetchGlobal. }
false;public;0;3;;public boolean isPrefetchGlobal() {     return prefetchGlobal. }
true;public;0;3;/**  * Get maximum number of opened channel in pool  */ ;/**  * Get maximum number of opened channel in pool  */ public int getChannelPoolMaxSize() {     return channelPoolMaxSize. }
false;public;1;3;;public void setChannelPoolMaxSize(int channelPoolMaxSize) {     this.channelPoolMaxSize = channelPoolMaxSize. }
false;public;0;3;;public long getChannelPoolMaxWait() {     return channelPoolMaxWait. }
true;public;1;3;/**  * Set the maximum number of milliseconds to wait for a channel from the  * pool  */ ;/**  * Set the maximum number of milliseconds to wait for a channel from the  * pool  */ public void setChannelPoolMaxWait(long channelPoolMaxWait) {     this.channelPoolMaxWait = channelPoolMaxWait. }
true;public;1;3;/**  * Set timeout for waiting for a reply when using the InOut Exchange Pattern  * (in milliseconds)  */ ;/**  * Set timeout for waiting for a reply when using the InOut Exchange Pattern  * (in milliseconds)  */ public void setRequestTimeout(long requestTimeout) {     this.requestTimeout = requestTimeout. }
false;public;0;3;;public long getRequestTimeout() {     return requestTimeout. }
true;public;1;3;/**  * Set requestTimeoutCheckerInterval for inOut exchange  */ ;/**  * Set requestTimeoutCheckerInterval for inOut exchange  */ public void setRequestTimeoutCheckerInterval(long requestTimeoutCheckerInterval) {     this.requestTimeoutCheckerInterval = requestTimeoutCheckerInterval. }
false;public;0;3;;public long getRequestTimeoutCheckerInterval() {     return requestTimeoutCheckerInterval. }
true;public;1;3;/**  * When true and an inOut Exchange failed on the consumer side send the  * caused Exception back in the response  */ ;/**  * When true and an inOut Exchange failed on the consumer side send the  * caused Exception back in the response  */ public void setTransferException(boolean transferException) {     this.transferException = transferException. }
false;public;0;3;;public boolean isTransferException() {     return transferException. }
true;public;0;3;/**  * When true, the message will be published with  * <a href="https://www.rabbitmq.com/confirms.html">publisher acknowledgements</a> turned on  */ ;/**  * When true, the message will be published with  * <a href="https://www.rabbitmq.com/confirms.html">publisher acknowledgements</a> turned on  */ public boolean isPublisherAcknowledgements() {     return publisherAcknowledgements. }
false;public;1;3;;public void setPublisherAcknowledgements(final boolean publisherAcknowledgements) {     this.publisherAcknowledgements = publisherAcknowledgements. }
true;public;0;3;/**  * The amount of time in milliseconds to wait for a basic.ack response from  * RabbitMQ server  */ ;/**  * The amount of time in milliseconds to wait for a basic.ack response from  * RabbitMQ server  */ public long getPublisherAcknowledgementsTimeout() {     return publisherAcknowledgementsTimeout. }
false;public;1;3;;public void setPublisherAcknowledgementsTimeout(final long publisherAcknowledgementsTimeout) {     this.publisherAcknowledgementsTimeout = publisherAcknowledgementsTimeout. }
true;public;0;3;/**  * When true, an exception will be thrown when the message cannot be  * delivered (basic.return) and the message is marked as mandatory.  * PublisherAcknowledgement will also be activated in this case.  * See also <a href=https://www.rabbitmq.com/confirms.html">publisher acknowledgements</a>  * - When will messages be confirmed.  */ ;/**  * When true, an exception will be thrown when the message cannot be  * delivered (basic.return) and the message is marked as mandatory.  * PublisherAcknowledgement will also be activated in this case.  * See also <a href=https://www.rabbitmq.com/confirms.html">publisher acknowledgements</a>  * - When will messages be confirmed.  */ public boolean isGuaranteedDeliveries() {     return guaranteedDeliveries. }
false;public;1;3;;public void setGuaranteedDeliveries(boolean guaranteedDeliveries) {     this.guaranteedDeliveries = guaranteedDeliveries. }
false;public;0;3;;public boolean isMandatory() {     return mandatory. }
true;public;1;3;/**  * This flag tells the server how to react if the message cannot be routed  * to a queue. If this flag is set, the server will return an unroutable  * message with a Return method. If this flag is zero, the server silently  * drops the message.  * <p/>  * If the header is present rabbitmq.MANDATORY it will override this option.  */ ;/**  * This flag tells the server how to react if the message cannot be routed  * to a queue. If this flag is set, the server will return an unroutable  * message with a Return method. If this flag is zero, the server silently  * drops the message.  * <p/>  * If the header is present rabbitmq.MANDATORY it will override this option.  */ public void setMandatory(boolean mandatory) {     this.mandatory = mandatory. }
false;public;0;3;;public boolean isImmediate() {     return immediate. }
true;public;1;3;/**  * This flag tells the server how to react if the message cannot be routed  * to a queue consumer immediately. If this flag is set, the server will  * return an undeliverable message with a Return method. If this flag is  * zero, the server will queue the message, but with no guarantee that it  * will ever be consumed.  * <p/>  * If the header is present rabbitmq.IMMEDIATE it will override this option.  */ ;/**  * This flag tells the server how to react if the message cannot be routed  * to a queue consumer immediately. If this flag is set, the server will  * return an undeliverable message with a Return method. If this flag is  * zero, the server will queue the message, but with no guarantee that it  * will ever be consumed.  * <p/>  * If the header is present rabbitmq.IMMEDIATE it will override this option.  */ public void setImmediate(boolean immediate) {     this.immediate = immediate. }
true;public;1;3;/**  * Specify arguments for configuring the different RabbitMQ concepts, a  * different prefix is required for each:  * <ul>  * <li>Exchange: arg.exchange.</li>  * <li>Queue: arg.queue.</li>  * <li>Binding: arg.binding.</li>  * </ul>  * For example to declare a queue with message ttl argument:  * http://localhost:5672/exchange/queue?args=arg.queue.x-message-ttl=60000  */ ;/**  * Specify arguments for configuring the different RabbitMQ concepts, a  * different prefix is required for each:  * <ul>  * <li>Exchange: arg.exchange.</li>  * <li>Queue: arg.queue.</li>  * <li>Binding: arg.binding.</li>  * </ul>  * For example to declare a queue with message ttl argument:  * http://localhost:5672/exchange/queue?args=arg.queue.x-message-ttl=60000  */ public void setArgs(Map<String, Object> args) {     this.args = args. }
false;public;0;3;;public Map<String, Object> getArgs() {     return args. }
false;public;0;3;;public Map<String, Object> getClientProperties() {     return clientProperties. }
true;public;1;3;/**  * Connection client properties (client info used in negotiating with the server)  */ ;/**  * Connection client properties (client info used in negotiating with the server)  */ public void setClientProperties(Map<String, Object> clientProperties) {     this.clientProperties = clientProperties. }
false;public;0;3;;public String getSslProtocol() {     return sslProtocol. }
true;public;1;3;/**  * Enables SSL on connection, accepted value are `true`, `TLS` and 'SSLv3`  */ ;/**  * Enables SSL on connection, accepted value are `true`, `TLS` and 'SSLv3`  */ public void setSslProtocol(String sslProtocol) {     this.sslProtocol = sslProtocol. }
false;public;0;3;;public TrustManager getTrustManager() {     return trustManager. }
true;public;1;3;/**  * Configure SSL trust manager, SSL should be enabled for this option to be effective  */ ;/**  * Configure SSL trust manager, SSL should be enabled for this option to be effective  */ public void setTrustManager(TrustManager trustManager) {     this.trustManager = trustManager. }
false;public;0;3;;public boolean isAutoAck() {     return autoAck. }
true;public;1;3;/**  * If messages should be auto acknowledged  */ ;/**  * If messages should be auto acknowledged  */ public void setAutoAck(boolean autoAck) {     this.autoAck = autoAck. }
false;public;0;3;;public boolean isAutoDelete() {     return autoDelete. }
true;public;1;3;/**  * If it is true, the exchange will be deleted when it is no longer in use  */ ;/**  * If it is true, the exchange will be deleted when it is no longer in use  */ public void setAutoDelete(boolean autoDelete) {     this.autoDelete = autoDelete. }
false;public;0;3;;public boolean isDurable() {     return durable. }
true;public;1;3;/**  * If we are declaring a durable exchange (the exchange will survive a  * server restart)  */ ;/**  * If we are declaring a durable exchange (the exchange will survive a  * server restart)  */ public void setDurable(boolean durable) {     this.durable = durable. }
false;public;0;3;;public boolean isExclusive() {     return exclusive. }
true;public;1;3;/**  * Exclusive queues may only be accessed by the current connection, and are  * deleted when that connection closes.  */ ;/**  * Exclusive queues may only be accessed by the current connection, and are  * deleted when that connection closes.  */ public void setExclusive(boolean exclusive) {     this.exclusive = exclusive. }
false;public;0;3;;public boolean isExclusiveConsumer() {     return exclusiveConsumer. }
true;public;1;3;/**  * Request exclusive access to the queue (meaning only this consumer can access the queue). This is useful  * when you want a long-lived shared queue to be temporarily accessible by just one consumer.  */ ;/**  * Request exclusive access to the queue (meaning only this consumer can access the queue). This is useful  * when you want a long-lived shared queue to be temporarily accessible by just one consumer.  */ public void setExclusiveConsumer(boolean exclusiveConsumer) {     this.exclusiveConsumer = exclusiveConsumer. }
false;public;0;3;;public boolean isPassive() {     return passive. }
true;public;1;3;/**  * Passive queues depend on the queue already to be available at RabbitMQ.  */ ;/**  * Passive queues depend on the queue already to be available at RabbitMQ.  */ public void setPassive(boolean passive) {     this.passive = passive. }
true;public;1;3;/**  * If true the producer will not declare and bind a queue. This can be used  * for directing messages via an existing routing key.  */ ;/**  * If true the producer will not declare and bind a queue. This can be used  * for directing messages via an existing routing key.  */ public void setSkipQueueDeclare(boolean skipQueueDeclare) {     this.skipQueueDeclare = skipQueueDeclare. }
false;public;0;3;;public boolean isSkipQueueDeclare() {     return skipQueueDeclare. }
true;public;0;3;/**  * If true the queue will not be bound to the exchange after declaring it  */ ;/**  * If true the queue will not be bound to the exchange after declaring it  */ public boolean isSkipQueueBind() {     return skipQueueBind. }
false;public;1;3;;public void setSkipQueueBind(boolean skipQueueBind) {     this.skipQueueBind = skipQueueBind. }
true;public;1;3;/**  * This can be used if we need to declare the queue but not the exchange  */ ;/**  * This can be used if we need to declare the queue but not the exchange  */ public void setSkipExchangeDeclare(boolean skipExchangeDeclare) {     this.skipExchangeDeclare = skipExchangeDeclare. }
false;public;0;3;;public boolean isSkipExchangeDeclare() {     return skipExchangeDeclare. }
false;public;0;3;;public boolean isDeclare() {     return declare. }
true;public;1;3;/**  * If the option is true, camel declare the exchange and queue name and bind  * them together. If the option is false, camel won't declare the exchange  * and queue name on the server.  */ ;/**  * If the option is true, camel declare the exchange and queue name and bind  * them together. If the option is false, camel won't declare the exchange  * and queue name on the server.  */ public void setDeclare(boolean declare) {     this.declare = declare. }
false;public;0;3;;public String getDeadLetterExchange() {     return deadLetterExchange. }
true;public;1;3;/**  * The name of the dead letter exchange  */ ;/**  * The name of the dead letter exchange  */ public void setDeadLetterExchange(String deadLetterExchange) {     this.deadLetterExchange = deadLetterExchange. }
false;public;0;3;;public String getDeadLetterQueue() {     return deadLetterQueue. }
true;public;1;3;/**  * The name of the dead letter queue  */ ;/**  * The name of the dead letter queue  */ public void setDeadLetterQueue(String deadLetterQueue) {     this.deadLetterQueue = deadLetterQueue. }
false;public;0;3;;public String getDeadLetterRoutingKey() {     return deadLetterRoutingKey. }
true;public;1;3;/**  * The routing key for the dead letter exchange  */ ;/**  * The routing key for the dead letter exchange  */ public void setDeadLetterRoutingKey(String deadLetterRoutingKey) {     this.deadLetterRoutingKey = deadLetterRoutingKey. }
false;public;0;3;;public String getDeadLetterExchangeType() {     return deadLetterExchangeType. }
true;public;1;3;/**  * The type of the dead letter exchange  */ ;/**  * The type of the dead letter exchange  */ public void setDeadLetterExchangeType(String deadLetterExchangeType) {     this.deadLetterExchangeType = deadLetterExchangeType. }
true;public;0;3;/**  * Allow pass null values to header  */ ;/**  * Allow pass null values to header  */ public boolean isAllowNullHeaders() {     return allowNullHeaders. }
false;public;1;3;;public void setAllowNullHeaders(boolean allowNullHeaders) {     this.allowNullHeaders = allowNullHeaders. }
