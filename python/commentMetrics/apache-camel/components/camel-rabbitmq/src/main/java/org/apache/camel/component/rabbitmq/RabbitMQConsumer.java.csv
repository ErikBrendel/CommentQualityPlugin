commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public RabbitMQEndpoint getEndpoint() {     return (RabbitMQEndpoint) super.getEndpoint(). }
true;private;0;5;/**  * Open connection  */ ;/**  * Open connection  */ private void openConnection() throws IOException, TimeoutException {     log.trace("Creating connection...").     this.conn = getEndpoint().connect(executor).     log.debug("Created connection: {}", conn). }
true;protected,synchronized;0;12;/**  * Returns the exiting open connection or opens a new one  */ ;/**  * Returns the exiting open connection or opens a new one  */ protected synchronized Connection getConnection() throws IOException, TimeoutException {     if (this.conn == null) {         openConnection().         return this.conn.     } else if (this.conn.isOpen() || (!this.conn.isOpen() && isAutomaticRecoveryEnabled())) {         return this.conn.     } else {         log.debug("The existing connection is closed").         openConnection().         return this.conn.     } }
false;private;0;4;;private boolean isAutomaticRecoveryEnabled() {     return this.endpoint.getAutomaticRecoveryEnabled() != null && this.endpoint.getAutomaticRecoveryEnabled(). }
true;private;0;6;/**  * Create the consumers but don't start yet  */ ;/**  * Create the consumers but don't start yet  */ private void createConsumers() throws IOException {     // Create consumers but don't start yet     for (int i = 0. i < endpoint.getConcurrentConsumers(). i++) {         createConsumer().     } }
true;private;0;16;/**  * Start the consumers (already created)  */ ;/**  * Start the consumers (already created)  */ private void startConsumers() {     // Try starting consumers (which will fail if RabbitMQ can't connect)     Throwable fail = null.     // attempt to start all consumers if possible     for (RabbitConsumer consumer : this.consumers) {         try {             ServiceHelper.startService(consumer).         } catch (Throwable e) {             fail = e.         }     }     if (fail != null) {         log.info("Connection failed starting consumers, will start background thread to retry!", fail).         reconnect().     } }
true;private;0;4;/**  * Add a consumer thread for given channel  */ ;/**  * Add a consumer thread for given channel  */ private void createConsumer() throws IOException {     RabbitConsumer consumer = new RabbitConsumer(this).     this.consumers.add(consumer). }
false;private,synchronized;0;10;;private synchronized void reconnect() {     if (startConsumerCallable != null) {         return.     }     // Open connection, and start message listener in background     Integer networkRecoveryInterval = getEndpoint().getNetworkRecoveryInterval().     final long connectionRetryInterval = networkRecoveryInterval != null && networkRecoveryInterval > 0 ? networkRecoveryInterval : 100L.     startConsumerCallable = new StartConsumerCallable(connectionRetryInterval).     executor.submit(startConsumerCallable). }
true;private;0;18;/**  * If needed, close Connection and Channels  */ ;/**  * If needed, close Connection and Channels  */ private void closeConnectionAndChannel() throws IOException, TimeoutException {     if (startConsumerCallable != null) {         startConsumerCallable.stop().     }     for (RabbitConsumer consumer : this.consumers) {         try {             ServiceHelper.stopAndShutdownService(consumer).         } catch (Exception e) {             log.warn("Error occurred while stopping consumer. This exception is ignored", e).         }     }     this.consumers.clear().     if (conn != null) {         log.debug("Closing connection: {} with timeout: {} ms.", conn, closeTimeout).         conn.close(closeTimeout).         conn = null.     } }
false;protected;0;4;;@Override protected void doSuspend() throws Exception {     closeConnectionAndChannel(). }
false;protected;0;5;;@Override protected void doResume() throws Exception {     createConsumers().     startConsumers(). }
false;protected;0;7;;@Override protected void doStart() throws Exception {     executor = endpoint.createExecutor().     log.debug("Using executor {}", executor).     createConsumers().     startConsumers(). }
false;protected;0;13;;@Override protected void doStop() throws Exception {     closeConnectionAndChannel().     if (executor != null) {         if (endpoint != null && endpoint.getCamelContext() != null) {             endpoint.getCamelContext().getExecutorServiceManager().shutdownNow(executor).         } else {             executor.shutdownNow().         }         executor = null.     } }
false;public;0;4;;public void stop() {     running.set(false).     RabbitMQConsumer.this.startConsumerCallable = null. }
false;public;0;18;;@Override public Void call() throws Exception {     boolean connectionFailed = true.     // Reconnection loop     while (running.get() && connectionFailed) {         try {             for (RabbitConsumer consumer : consumers) {                 consumer.reconnect().             }             connectionFailed = false.         } catch (Exception e) {             log.info("Connection failed, will retry in " + connectionRetryInterval + "ms", e).             Thread.sleep(connectionRetryInterval).         }     }     stop().     return null. }
