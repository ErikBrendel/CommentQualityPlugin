commented;modifiers;parameterAmount;loc;comment;code
false;protected;6;4;;protected ReplyHandler createReplyHandler(ReplyManager replyManager, Exchange exchange, AsyncCallback callback, String originalCorrelationId, String correlationId, long requestTimeout) {     return new TemporaryQueueReplyHandler(this, exchange, callback, originalCorrelationId, correlationId, requestTimeout). }
false;public;3;8;;public void updateCorrelationId(String correlationId, String newCorrelationId, long requestTimeout) {     log.trace("Updated provisional correlationId [{}] to expected correlationId [{}]", correlationId, newCorrelationId).     ReplyHandler handler = correlation.remove(correlationId).     if (handler != null) {         correlation.put(newCorrelationId, handler, requestTimeout).     } }
false;protected;3;16;;@Override protected void handleReplyMessage(String correlationID, AMQP.BasicProperties properties, byte[] message) {     ReplyHandler handler = correlation.get(correlationID).     if (handler == null && endpoint.isUseMessageIDAsCorrelationID()) {         handler = waitForProvisionCorrelationToBeUpdated(correlationID, message).     }     if (handler != null) {         correlation.remove(correlationID).         handler.onReply(correlationID, properties, message).     } else {         // we could not correlate the received reply message to a matching request and therefore         // we cannot continue routing the unknown message         // log a warn and then ignore the message         log.warn("Reply received for unknown correlationID [{}]. The message will be ignored: {}", correlationID, message).     } }
false;protected;0;27;;@Override protected Connection createListenerContainer() throws Exception {     log.trace("Creating connection").     Connection conn = endpoint.connect(executorService).     log.trace("Creating channel").     Channel channel = conn.createChannel().     // setup the basicQos     if (endpoint.isPrefetchEnabled()) {         channel.basicQos(endpoint.getPrefetchSize(), endpoint.getPrefetchCount(), endpoint.isPrefetchGlobal()).     }     // Let the server pick a random name for us     DeclareOk result = channel.queueDeclare().     log.debug("Using temporary queue name: {}", result.getQueue()).     setReplyTo(result.getQueue()).     // TODO check for the RabbitMQConstants.EXCHANGE_NAME header     channel.queueBind(getReplyTo(), endpoint.getExchangeName(), getReplyTo()).     consumer = new RabbitConsumer(this, channel).     consumer.start().     return conn. }
false;protected;0;5;;@Override protected void doStop() throws Exception {     super.doStop().     consumer.stop(). }
false;public;4;5;;@Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {     consumer.onMessage(properties, body). }
true;private;0;3;/**  * Bind consumer to channel  */ ;/**  * Bind consumer to channel  */ private void start() throws IOException {     tag = channel.basicConsume(getReplyTo(), true, this). }
true;private;0;8;/**  * Unbind consumer from channel  */ ;/**  * Unbind consumer from channel  */ private void stop() throws IOException, TimeoutException {     if (channel.isOpen()) {         if (tag != null) {             channel.basicCancel(tag).         }         channel.close().     } }
