commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public void declareAndBindExchangesAndQueuesUsing(final Channel channel) throws IOException {     declareAndBindDeadLetterExchangeWithQueue(channel).     declareAndBindExchangeWithQueue(channel). }
false;private;1;7;;private void declareAndBindDeadLetterExchangeWithQueue(final Channel channel) throws IOException {     if (endpoint.getDeadLetterExchange() != null) {         // TODO Do we need to setup the args for the DeadLetter?         declareExchange(channel, endpoint.getDeadLetterExchange(), endpoint.getDeadLetterExchangeType(), Collections.<String, Object>emptyMap()).         declareAndBindQueue(channel, endpoint.getDeadLetterQueue(), endpoint.getDeadLetterExchange(), endpoint.getDeadLetterRoutingKey(), null, null).     } }
false;private;1;11;;private void declareAndBindExchangeWithQueue(final Channel channel) throws IOException {     if (shouldDeclareExchange()) {         declareExchange(channel, endpoint.getExchangeName(), endpoint.getExchangeType(), resolvedExchangeArguments()).     }     if (shouldDeclareQueue()) {         // need to make sure the queueDeclare is same with the exchange         // declare         declareAndBindQueue(channel, endpoint.getQueue(), endpoint.getExchangeName(), endpoint.getRoutingKey(), resolvedQueueArguments(), endpoint.getBindingArgs()).     } }
false;private;0;7;;private Map<String, Object> resolvedQueueArguments() {     Map<String, Object> queueArgs = new HashMap<>().     populateQueueArgumentsFromDeadLetterExchange(queueArgs).     queueArgs.putAll(endpoint.getQueueArgs()).     formatSpecialQueueArguments(queueArgs).     return queueArgs. }
false;private;1;22;;private void formatSpecialQueueArguments(Map<String, Object> queueArgs) {     // some arguments must be in numeric values so we need to fix this     Object queueLengthLimit = queueArgs.get(RabbitMQConstants.RABBITMQ_QUEUE_LENGTH_LIMIT_KEY).     if (queueLengthLimit instanceof String) {         queueArgs.put(RabbitMQConstants.RABBITMQ_QUEUE_LENGTH_LIMIT_KEY, Long.parseLong((String) queueLengthLimit)).     }     Object queueMaxPriority = queueArgs.get(RabbitMQConstants.RABBITMQ_QUEUE_MAX_PRIORITY_KEY).     if (queueMaxPriority instanceof String) {         queueArgs.put(RabbitMQConstants.RABBITMQ_QUEUE_MAX_PRIORITY_KEY, Integer.parseInt((String) queueMaxPriority)).     }     Object queueMessageTtl = queueArgs.get(RabbitMQConstants.RABBITMQ_QUEUE_MESSAGE_TTL_KEY).     if (queueMessageTtl instanceof String) {         queueArgs.put(RabbitMQConstants.RABBITMQ_QUEUE_MESSAGE_TTL_KEY, Long.parseLong((String) queueMessageTtl)).     }     Object queueExpiration = queueArgs.get(RabbitMQConstants.RABBITMQ_QUEUE_TTL_KEY).     if (queueExpiration instanceof String) {         queueArgs.put(RabbitMQConstants.RABBITMQ_QUEUE_TTL_KEY, Long.parseLong((String) queueExpiration)).     } }
false;private;1;6;;private void populateQueueArgumentsFromDeadLetterExchange(final Map<String, Object> queueArgs) {     if (endpoint.getDeadLetterExchange() != null) {         queueArgs.put(RabbitMQConstants.RABBITMQ_DEAD_LETTER_EXCHANGE, endpoint.getDeadLetterExchange()).         queueArgs.put(RabbitMQConstants.RABBITMQ_DEAD_LETTER_ROUTING_KEY, endpoint.getDeadLetterRoutingKey()).     } }
false;private;0;3;;private Map<String, Object> resolvedExchangeArguments() {     return endpoint.getExchangeArgs(). }
false;private;0;3;;private boolean shouldDeclareQueue() {     return !endpoint.isSkipQueueDeclare() && endpoint.getQueue() != null. }
false;private;0;3;;private boolean shouldDeclareExchange() {     return !endpoint.isSkipExchangeDeclare(). }
false;private;0;3;;private boolean shouldBindQueue() {     return !endpoint.isSkipQueueBind(). }
false;private;4;7;;private void declareExchange(final Channel channel, final String exchange, final String exchangeType, final Map<String, Object> exchangeArgs) throws IOException {     if (endpoint.isPassive()) {         channel.exchangeDeclarePassive(exchange).     } else {         channel.exchangeDeclare(exchange, exchangeType, endpoint.isDurable(), endpoint.isAutoDelete(), exchangeArgs).     } }
false;private;6;14;;private void declareAndBindQueue(final Channel channel, final String queue, final String exchange, final String routingKey, final Map<String, Object> queueArgs, final Map<String, Object> bindingArgs) throws IOException {     if (endpoint.isPassive()) {         channel.queueDeclarePassive(queue).     } else {         channel.queueDeclare(queue, endpoint.isDurable(), endpoint.isExclusive(), endpoint.isAutoDelete(), queueArgs).     }     if (shouldBindQueue()) {         channel.queueBind(queue, exchange, emptyIfNull(routingKey), bindingArgs).     } }
false;private;1;3;;private String emptyIfNull(final String routingKey) {     return routingKey == null ? "" : routingKey. }
