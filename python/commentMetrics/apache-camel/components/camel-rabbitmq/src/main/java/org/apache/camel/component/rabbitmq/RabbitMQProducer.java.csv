commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public RabbitMQEndpoint getEndpoint() {     return (RabbitMQEndpoint) super.getEndpoint(). }
false;;1;1;;T doWithChannel(Channel channel) throws Exception.
true;private;1;24;/**  * Do something with a pooled channel (similar to Spring JDBC TransactionTemplate#execute)  */ ;/**  * Do something with a pooled channel (similar to Spring JDBC TransactionTemplate#execute)  */ private <T> T execute(ChannelCallback<T> callback) throws Exception {     Channel channel.     try {         channel = channelPool.borrowObject().     } catch (IllegalStateException e) {         // Since this method is not synchronized its possible the         // channelPool has been cleared by another thread         checkConnectionAndChannelPool().         channel = channelPool.borrowObject().     }     if (!channel.isOpen()) {         log.warn("Got a closed channel from the pool. Invalidating and borrowing a new one from the pool.").         channelPool.invalidateObject(channel).         // Reconnect if another thread hasn't yet         checkConnectionAndChannelPool().         attemptDeclaration().         channel = channelPool.borrowObject().     }     try {         return callback.doWithChannel(channel).     } finally {         channelPool.returnObject(channel).     } }
true;private,synchronized;0;10;/**  * Open connection and initialize channel pool  * @throws Exception  */ ;/**  * Open connection and initialize channel pool  * @throws Exception  */ private synchronized void openConnectionAndChannelPool() throws Exception {     log.trace("Creating connection...").     this.conn = getEndpoint().connect(executorService).     log.debug("Created connection: {}", conn).     log.trace("Creating channel pool...").     channelPool = new GenericObjectPool<>(new PoolableChannelFactory(this.conn), getEndpoint().getChannelPoolMaxSize(), GenericObjectPool.WHEN_EXHAUSTED_BLOCK, getEndpoint().getChannelPoolMaxWait()).     attemptDeclaration(). }
false;public;1;5;;@Override public Void doWithChannel(Channel channel) throws Exception {     getEndpoint().declareExchangeAndQueue(channel).     return null. }
false;private,synchronized;0;11;;private synchronized void attemptDeclaration() throws Exception {     if (getEndpoint().isDeclare()) {         execute(new ChannelCallback<Void>() {              @Override             public Void doWithChannel(Channel channel) throws Exception {                 getEndpoint().declareExchangeAndQueue(channel).                 return null.             }         }).     } }
true;private,synchronized;0;11;/**  * This will reconnect only if the connection is closed.  * @throws Exception  */ ;/**  * This will reconnect only if the connection is closed.  * @throws Exception  */ private synchronized void checkConnectionAndChannelPool() throws Exception {     if (this.conn == null || !this.conn.isOpen()) {         log.info("Reconnecting to RabbitMQ").         try {             closeConnectionAndChannel().         } catch (Exception e) {         // no op         }         openConnectionAndChannelPool().     } }
false;protected;0;9;;@Override protected void doStart() throws Exception {     this.executorService = getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, "CamelRabbitMQProducer[" + getEndpoint().getQueue() + "]").     try {         openConnectionAndChannelPool().     } catch (IOException e) {         log.warn("Failed to create connection. It will attempt to connect again when publishing a message.", e).     } }
true;private,synchronized;0;15;/**  * If needed, close Connection and Channel  * @throws IOException  */ ;/**  * If needed, close Connection and Channel  * @throws IOException  */ private synchronized void closeConnectionAndChannel() throws IOException {     if (channelPool != null) {         try {             channelPool.close().             channelPool = null.         } catch (Exception e) {             throw new IOException("Error closing channelPool", e).         }     }     if (conn != null) {         log.debug("Closing connection: {} with timeout: {} ms.", conn, closeTimeout).         conn.close(closeTimeout).         conn = null.     } }
false;protected;0;9;;@Override protected void doStop() throws Exception {     unInitReplyManager().     closeConnectionAndChannel().     if (executorService != null) {         getEndpoint().getCamelContext().getExecutorServiceManager().shutdownNow(executorService).         executorService = null.     } }
false;public;2;27;;public boolean process(Exchange exchange, AsyncCallback callback) {     // deny processing if we are not started     if (!isRunAllowed()) {         if (exchange.getException() == null) {             exchange.setException(new RejectedExecutionException()).         }         // we cannot process so invoke callback         callback.done(true).         return true.     }     try {         if (exchange.getPattern().isOutCapable()) {             // in out requires a bit more work than in only             return processInOut(exchange, callback).         } else {             // in only             return processInOnly(exchange, callback).         }     } catch (Throwable e) {         // must catch exception to ensure callback is invoked as expected         // to let Camel error handling deal with this         exchange.setException(e).         callback.done(true).         return true.     } }
false;protected;2;46;;protected boolean processInOut(final Exchange exchange, final AsyncCallback callback) throws Exception {     final org.apache.camel.Message in = exchange.getIn().     initReplyManager().     // the request timeout can be overruled by a header otherwise the endpoint configured value is used     final long timeout = exchange.getIn().getHeader(RabbitMQConstants.REQUEST_TIMEOUT, getEndpoint().getRequestTimeout(), long.class).     final String originalCorrelationId = in.getHeader(RabbitMQConstants.CORRELATIONID, String.class).     // we append the 'Camel-' prefix to know it was generated by us     String correlationId = GENERATED_CORRELATION_ID_PREFIX + getEndpoint().getCamelContext().getUuidGenerator().generateUuid().     in.setHeader(RabbitMQConstants.CORRELATIONID, correlationId).     in.setHeader(RabbitMQConstants.REPLY_TO, replyManager.getReplyTo()).     // remove the OVERRIDE header so it does not propagate     String exchangeName = (String) exchange.getIn().removeHeader(RabbitMQConstants.EXCHANGE_OVERRIDE_NAME).     // If it is BridgeEndpoint we should ignore the message header of EXCHANGE_OVERRIDE_NAME     if (exchangeName == null || getEndpoint().isBridgeEndpoint()) {         exchangeName = getEndpoint().getExchangeName().     } else {         log.debug("Overriding header: {} detected sending message to exchange: {}", RabbitMQConstants.EXCHANGE_OVERRIDE_NAME, exchangeName).     }     String key = in.getHeader(RabbitMQConstants.ROUTING_KEY, String.class).     // we just need to make sure RoutingKey option take effect if it is not BridgeEndpoint     if (key == null || getEndpoint().isBridgeEndpoint()) {         key = getEndpoint().getRoutingKey() == null ? "" : getEndpoint().getRoutingKey().     }     if (ObjectHelper.isEmpty(key) && ObjectHelper.isEmpty(exchangeName)) {         throw new IllegalArgumentException("ExchangeName and RoutingKey is not provided in the endpoint: " + getEndpoint()).     }     log.debug("Registering reply for {}", correlationId).     replyManager.registerReply(replyManager, exchange, callback, originalCorrelationId, correlationId, timeout).     try {         basicPublish(exchange, exchangeName, key).     } catch (Exception e) {         replyManager.cancelCorrelationId(correlationId).         exchange.setException(e).         return true.     }     // continue routing asynchronously (reply will be processed async when its received)     return false. }
false;private;2;23;;private boolean processInOnly(Exchange exchange, AsyncCallback callback) throws Exception {     // remove the OVERRIDE header so it does not propagate     String exchangeName = (String) exchange.getIn().removeHeader(RabbitMQConstants.EXCHANGE_OVERRIDE_NAME).     // If it is BridgeEndpoint we should ignore the message header of EXCHANGE_OVERRIDE_NAME     if (exchangeName == null || getEndpoint().isBridgeEndpoint()) {         exchangeName = getEndpoint().getExchangeName().     } else {         log.debug("Overriding header: {} detected sending message to exchange: {}", RabbitMQConstants.EXCHANGE_OVERRIDE_NAME, exchangeName).     }     String key = exchange.getIn().getHeader(RabbitMQConstants.ROUTING_KEY, String.class).     // we just need to make sure RoutingKey option take effect if it is not BridgeEndpoint     if (key == null || getEndpoint().isBridgeEndpoint()) {         key = getEndpoint().getRoutingKey() == null ? "" : getEndpoint().getRoutingKey().     }     if (ObjectHelper.isEmpty(key) && ObjectHelper.isEmpty(exchangeName)) {         throw new IllegalArgumentException("ExchangeName and RoutingKey is not provided in the endpoint: " + getEndpoint()).     }     basicPublish(exchange, exchangeName, key).     callback.done(true).     return true. }
false;public;1;5;;@Override public Void doWithChannel(Channel channel) throws Exception {     getEndpoint().publishExchangeToChannel(camelExchange, channel, routingKey).     return null. }
true;private;3;13;/**  * Send a message borrowing a channel from the pool.  */ ;/**  * Send a message borrowing a channel from the pool.  */ private void basicPublish(final Exchange camelExchange, final String rabbitExchange, final String routingKey) throws Exception {     if (channelPool == null) {         // Open connection and channel lazily if another thread hasn't         checkConnectionAndChannelPool().     }     execute(new ChannelCallback<Void>() {          @Override         public Void doWithChannel(Channel channel) throws Exception {             getEndpoint().publishExchangeToChannel(camelExchange, channel, routingKey).             return null.         }     }). }
false;;1;3;;AMQP.BasicProperties.Builder buildProperties(Exchange exchange) {     return getEndpoint().getMessageConverter().buildProperties(exchange). }
false;public;0;3;;public int getCloseTimeout() {     return closeTimeout. }
false;public;1;3;;public void setCloseTimeout(int closeTimeout) {     this.closeTimeout = closeTimeout. }
false;protected;0;43;;protected void initReplyManager() {     if (!started.get()) {         synchronized (this) {             if (started.get()) {                 return.             }             log.debug("Starting reply manager").             // must use the classloader from the application context when creating reply manager,             // as it should inherit the classloader from app context and not the current which may be             // a different classloader             ClassLoader current = Thread.currentThread().getContextClassLoader().             ClassLoader ac = getEndpoint().getCamelContext().getApplicationContextClassLoader().             try {                 if (ac != null) {                     Thread.currentThread().setContextClassLoader(ac).                 }                 // validate that replyToType and replyTo is configured accordingly                 if (getEndpoint().getReplyToType() != null) {                     // setting temporary with a fixed replyTo is not supported                     if (getEndpoint().getReplyTo() != null && getEndpoint().getReplyToType().equals(ReplyToType.Temporary.name())) {                         throw new IllegalArgumentException("ReplyToType " + ReplyToType.Temporary + " is not supported when replyTo " + getEndpoint().getReplyTo() + " is also configured.").                     }                 }                 if (getEndpoint().getReplyTo() != null) {                     // specifying reply queues is not currently supported                     throw new IllegalArgumentException("Specifying replyTo " + getEndpoint().getReplyTo() + " is currently not supported.").                 } else {                     replyManager = createReplyManager().                     log.debug("Using RabbitMQReplyManager: {} to process replies from temporary queue", replyManager).                 }             } catch (Exception e) {                 throw new FailedToCreateProducerException(getEndpoint(), e).             } finally {                 if (ac != null) {                     Thread.currentThread().setContextClassLoader(current).                 }             }             started.set(true).         }     } }
false;protected;0;15;;protected void unInitReplyManager() {     try {         if (replyManager != null) {             if (log.isDebugEnabled()) {                 log.debug("Stopping RabbitMQReplyManager: {} from processing replies from: {}", replyManager, getEndpoint().getReplyTo() != null ? getEndpoint().getReplyTo() : "temporary queue").             }             ServiceHelper.stopService(replyManager).         }     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } finally {         started.set(false).     } }
false;protected;0;13;;protected ReplyManager createReplyManager() throws Exception {     // use a temporary queue     ReplyManager replyManager = new TemporaryQueueReplyManager(getEndpoint().getCamelContext()).     replyManager.setEndpoint(getEndpoint()).     String name = "RabbitMQReplyManagerTimeoutChecker[" + getEndpoint().getExchangeName() + "]".     ScheduledExecutorService replyManagerExecutorService = getEndpoint().getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(name, name).     replyManager.setScheduledExecutorService(replyManagerExecutorService).     log.debug("Staring ReplyManager: {}", name).     ServiceHelper.startService(replyManager).     return replyManager. }
