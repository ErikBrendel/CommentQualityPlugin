commented;modifiers;parameterAmount;loc;comment;code
false;public;3;5;;public Exchange createRabbitExchange(Envelope envelope, AMQP.BasicProperties properties, byte[] body) {     Exchange exchange = super.createExchange().     messageConverter.populateRabbitExchange(exchange, envelope, properties, body, false).     return exchange. }
true;protected;0;3;/**  * Gets the message converter to convert between rabbit and camel  */ ;/**  * Gets the message converter to convert between rabbit and camel  */ protected RabbitMQMessageConverter getMessageConverter() {     return messageConverter. }
true;public;3;3;/**  * Sends the body that is on the exchange  */ ;/**  * Sends the body that is on the exchange  */ public void publishExchangeToChannel(Exchange camelExchange, Channel channel, String routingKey) throws IOException {     new RabbitMQMessagePublisher(camelExchange, channel, routingKey, this).publish(). }
false;public;1;6;;@Override public Consumer createConsumer(Processor processor) throws Exception {     RabbitMQConsumer consumer = new RabbitMQConsumer(this, processor).     configureConsumer(consumer).     return consumer. }
false;public;1;7;;public Connection connect(ExecutorService executor) throws IOException, TimeoutException {     if (getAddresses() == null) {         return getOrCreateConnectionFactory().newConnection(executor).     } else {         return getOrCreateConnectionFactory().newConnection(executor, getAddresses()).     } }
true;public;1;3;/**  * If needed, declare Exchange, declare Queue and bind them with Routing Key  */ ;/**  * If needed, declare Exchange, declare Queue and bind them with Routing Key  */ public void declareExchangeAndQueue(Channel channel) throws IOException {     declareSupport.declareAndBindExchangesAndQueuesUsing(channel). }
false;private;0;6;;private ConnectionFactory getOrCreateConnectionFactory() {     if (connectionFactory == null) {         connectionFactory = factoryCreator.createFactoryFor(this).     }     return connectionFactory. }
false;public;0;4;;@Override public Producer createProducer() throws Exception {     return new RabbitMQProducer(this). }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;protected;0;7;;protected ExecutorService createExecutor() {     if (getCamelContext() != null) {         return getCamelContext().getExecutorServiceManager().newFixedThreadPool(this, "RabbitMQConsumer", getThreadPoolSize()).     } else {         return Executors.newFixedThreadPool(getThreadPoolSize()).     } }
false;public;0;3;;public String getUsername() {     return username. }
true;public;1;3;/**  * Username in case of authenticated access  */ ;/**  * Username in case of authenticated access  */ public void setUsername(String username) {     this.username = username. }
false;public;0;3;;public String getPassword() {     return password. }
true;public;1;3;/**  * Password for authenticated access  */ ;/**  * Password for authenticated access  */ public void setPassword(String password) {     this.password = password. }
false;public;0;3;;public String getVhost() {     return vhost. }
true;public;1;3;/**  * The vhost for the channel  */ ;/**  * The vhost for the channel  */ public void setVhost(String vhost) {     this.vhost = vhost. }
false;public;0;3;;public String getHostname() {     return hostname. }
true;public;1;3;/**  * The hostname of the running rabbitmq instance or cluster.  */ ;/**  * The hostname of the running rabbitmq instance or cluster.  */ public void setHostname(String hostname) {     this.hostname = hostname. }
false;public;0;3;;public int getThreadPoolSize() {     return threadPoolSize. }
true;public;1;3;/**  * The consumer uses a Thread Pool Executor with a fixed number of threads.  * This setting allows you to set that number of threads.  */ ;/**  * The consumer uses a Thread Pool Executor with a fixed number of threads.  * This setting allows you to set that number of threads.  */ public void setThreadPoolSize(int threadPoolSize) {     this.threadPoolSize = threadPoolSize. }
false;public;0;3;;public int getPortNumber() {     return portNumber. }
true;public;1;3;/**  * Port number for the host with the running rabbitmq instance or cluster.  * Default value is 5672.  */ ;/**  * Port number for the host with the running rabbitmq instance or cluster.  * Default value is 5672.  */ public void setPortNumber(int portNumber) {     this.portNumber = portNumber. }
false;public;0;3;;public boolean isAutoAck() {     return autoAck. }
true;public;1;3;/**  * If messages should be auto acknowledged  */ ;/**  * If messages should be auto acknowledged  */ public void setAutoAck(boolean autoAck) {     this.autoAck = autoAck. }
false;public;0;3;;public boolean isAutoDelete() {     return autoDelete. }
true;public;1;3;/**  * If it is true, the exchange will be deleted when it is no longer in use  */ ;/**  * If it is true, the exchange will be deleted when it is no longer in use  */ public void setAutoDelete(boolean autoDelete) {     this.autoDelete = autoDelete. }
false;public;0;3;;public boolean isDurable() {     return durable. }
true;public;1;3;/**  * If we are declaring a durable exchange (the exchange will survive a  * server restart)  */ ;/**  * If we are declaring a durable exchange (the exchange will survive a  * server restart)  */ public void setDurable(boolean durable) {     this.durable = durable. }
false;public;0;3;;public String getQueue() {     return queue. }
true;public;1;3;/**  * The queue to receive messages from  */ ;/**  * The queue to receive messages from  */ public void setQueue(String queue) {     this.queue = queue. }
false;public;0;3;;public String getExchangeName() {     return exchangeName. }
true;public;1;3;/**  * The exchange name determines which exchange produced messages will sent  * to. In the case of consumers, the exchange name determines which exchange  * the queue will bind to.  */ ;/**  * The exchange name determines which exchange produced messages will sent  * to. In the case of consumers, the exchange name determines which exchange  * the queue will bind to.  */ public void setExchangeName(String exchangeName) {     this.exchangeName = exchangeName. }
false;public;0;3;;public String getExchangeType() {     return exchangeType. }
true;public;1;3;/**  * The exchange type such as direct or topic.  */ ;/**  * The exchange type such as direct or topic.  */ public void setExchangeType(String exchangeType) {     this.exchangeType = exchangeType. }
false;public;0;3;;public String getRoutingKey() {     return routingKey. }
true;public;1;3;/**  * The routing key to use when binding a consumer queue to the exchange. For  * producer routing keys, you set the header rabbitmq.ROUTING_KEY.  */ ;/**  * The routing key to use when binding a consumer queue to the exchange. For  * producer routing keys, you set the header rabbitmq.ROUTING_KEY.  */ public void setRoutingKey(String routingKey) {     this.routingKey = routingKey. }
true;public;1;3;/**  * If true the producer will not declare and bind a queue. This can be used  * for directing messages via an existing routing key.  */ ;/**  * If true the producer will not declare and bind a queue. This can be used  * for directing messages via an existing routing key.  */ public void setSkipQueueDeclare(boolean skipQueueDeclare) {     this.skipQueueDeclare = skipQueueDeclare. }
false;public;0;3;;public boolean isSkipQueueDeclare() {     return skipQueueDeclare. }
true;public;0;3;/**  * If true the queue will not be bound to the exchange after declaring it  */ ;/**  * If true the queue will not be bound to the exchange after declaring it  */ public boolean isSkipQueueBind() {     return skipQueueBind. }
false;public;1;3;;public void setSkipQueueBind(boolean skipQueueBind) {     this.skipQueueBind = skipQueueBind. }
true;public;1;3;/**  * This can be used if we need to declare the queue but not the exchange  */ ;/**  * This can be used if we need to declare the queue but not the exchange  */ public void setSkipExchangeDeclare(boolean skipExchangeDeclare) {     this.skipExchangeDeclare = skipExchangeDeclare. }
false;public;0;3;;public boolean isSkipExchangeDeclare() {     return skipExchangeDeclare. }
true;public;1;3;/**  * If the bridgeEndpoint is true, the producer will ignore the message  * header of "rabbitmq.EXCHANGE_NAME" and "rabbitmq.ROUTING_KEY"  */ ;/**  * If the bridgeEndpoint is true, the producer will ignore the message  * header of "rabbitmq.EXCHANGE_NAME" and "rabbitmq.ROUTING_KEY"  */ public void setBridgeEndpoint(boolean bridgeEndpoint) {     this.bridgeEndpoint = bridgeEndpoint. }
false;public;0;3;;public boolean isBridgeEndpoint() {     return bridgeEndpoint. }
true;public;1;6;/**  * If this option is set, camel-rabbitmq will try to create connection based  * on the setting of option addresses. The addresses value is a string which  * looks like "server1:12345, server2:12345"  */ ;/**  * If this option is set, camel-rabbitmq will try to create connection based  * on the setting of option addresses. The addresses value is a string which  * looks like "server1:12345, server2:12345"  */ public void setAddresses(String addresses) {     Address[] addressArray = Address.parseAddresses(addresses).     if (addressArray.length > 0) {         this.addresses = addressArray.     } }
true;public;1;3;/**  * If this option is set, camel-rabbitmq will try to create connection based  * on the setting of option addresses. The addresses value is a string which  * looks like "server1:12345, server2:12345"  */ ;/**  * If this option is set, camel-rabbitmq will try to create connection based  * on the setting of option addresses. The addresses value is a string which  * looks like "server1:12345, server2:12345"  */ public void setAddresses(Address[] addresses) {     this.addresses = addresses. }
false;public;0;3;;public Address[] getAddresses() {     return addresses. }
false;public;0;3;;public int getConnectionTimeout() {     return connectionTimeout. }
true;public;1;3;/**  * Connection timeout  */ ;/**  * Connection timeout  */ public void setConnectionTimeout(int connectionTimeout) {     this.connectionTimeout = connectionTimeout. }
false;public;0;3;;public int getRequestedChannelMax() {     return requestedChannelMax. }
true;public;1;3;/**  * Connection requested channel max (max number of channels offered)  */ ;/**  * Connection requested channel max (max number of channels offered)  */ public void setRequestedChannelMax(int requestedChannelMax) {     this.requestedChannelMax = requestedChannelMax. }
false;public;0;3;;public int getRequestedFrameMax() {     return requestedFrameMax. }
true;public;1;3;/**  * Connection requested frame max (max size of frame offered)  */ ;/**  * Connection requested frame max (max size of frame offered)  */ public void setRequestedFrameMax(int requestedFrameMax) {     this.requestedFrameMax = requestedFrameMax. }
false;public;0;3;;public int getRequestedHeartbeat() {     return requestedHeartbeat. }
true;public;1;3;/**  * Connection requested heartbeat (heart-beat in seconds offered)  */ ;/**  * Connection requested heartbeat (heart-beat in seconds offered)  */ public void setRequestedHeartbeat(int requestedHeartbeat) {     this.requestedHeartbeat = requestedHeartbeat. }
false;public;0;3;;public String getSslProtocol() {     return sslProtocol. }
true;public;1;3;/**  * Enables SSL on connection, accepted value are `true`, `TLS` and 'SSLv3`  */ ;/**  * Enables SSL on connection, accepted value are `true`, `TLS` and 'SSLv3`  */ public void setSslProtocol(String sslProtocol) {     this.sslProtocol = sslProtocol. }
false;public;0;3;;public ConnectionFactory getConnectionFactory() {     return connectionFactory. }
true;public;1;3;/**  * To use a custom RabbitMQ connection factory. When this option is set, all  * connection options (connectionTimeout, requestedChannelMax...) set on URI  * are not used  */ ;/**  * To use a custom RabbitMQ connection factory. When this option is set, all  * connection options (connectionTimeout, requestedChannelMax...) set on URI  * are not used  */ public void setConnectionFactory(ConnectionFactory connectionFactory) {     this.connectionFactory = connectionFactory. }
false;public;0;3;;public TrustManager getTrustManager() {     return trustManager. }
true;public;1;3;/**  * Configure SSL trust manager, SSL should be enabled for this option to be effective  */ ;/**  * Configure SSL trust manager, SSL should be enabled for this option to be effective  */ public void setTrustManager(TrustManager trustManager) {     this.trustManager = trustManager. }
false;public;0;3;;public Map<String, Object> getClientProperties() {     return clientProperties. }
true;public;1;3;/**  * Connection client properties (client info used in negotiating with the server)  */ ;/**  * Connection client properties (client info used in negotiating with the server)  */ public void setClientProperties(Map<String, Object> clientProperties) {     this.clientProperties = clientProperties. }
false;public;0;3;;public Boolean getAutomaticRecoveryEnabled() {     return automaticRecoveryEnabled. }
true;public;1;3;/**  * Enables connection automatic recovery (uses connection implementation  * that performs automatic recovery when connection shutdown is not  * initiated by the application)  */ ;/**  * Enables connection automatic recovery (uses connection implementation  * that performs automatic recovery when connection shutdown is not  * initiated by the application)  */ public void setAutomaticRecoveryEnabled(Boolean automaticRecoveryEnabled) {     this.automaticRecoveryEnabled = automaticRecoveryEnabled. }
false;public;0;3;;public Integer getNetworkRecoveryInterval() {     return networkRecoveryInterval. }
true;public;1;3;/**  * Network recovery interval in milliseconds (interval used when recovering  * from network failure)  */ ;/**  * Network recovery interval in milliseconds (interval used when recovering  * from network failure)  */ public void setNetworkRecoveryInterval(Integer networkRecoveryInterval) {     this.networkRecoveryInterval = networkRecoveryInterval. }
false;public;0;3;;public Boolean getTopologyRecoveryEnabled() {     return topologyRecoveryEnabled. }
true;public;1;3;/**  * Enables connection topology recovery (should topology recovery be  * performed?)  */ ;/**  * Enables connection topology recovery (should topology recovery be  * performed?)  */ public void setTopologyRecoveryEnabled(Boolean topologyRecoveryEnabled) {     this.topologyRecoveryEnabled = topologyRecoveryEnabled. }
false;public;0;3;;public boolean isPrefetchEnabled() {     return prefetchEnabled. }
true;public;1;3;/**  * Enables the quality of service on the RabbitMQConsumer side. You need to  * specify the option of prefetchSize, prefetchCount, prefetchGlobal at the  * same time  */ ;/**  * Enables the quality of service on the RabbitMQConsumer side. You need to  * specify the option of prefetchSize, prefetchCount, prefetchGlobal at the  * same time  */ public void setPrefetchEnabled(boolean prefetchEnabled) {     this.prefetchEnabled = prefetchEnabled. }
true;public;1;3;/**  * The maximum amount of content (measured in octets) that the server will  * deliver, 0 if unlimited. You need to specify the option of prefetchSize,  * prefetchCount, prefetchGlobal at the same time  */ ;/**  * The maximum amount of content (measured in octets) that the server will  * deliver, 0 if unlimited. You need to specify the option of prefetchSize,  * prefetchCount, prefetchGlobal at the same time  */ public void setPrefetchSize(int prefetchSize) {     this.prefetchSize = prefetchSize. }
false;public;0;3;;public int getPrefetchSize() {     return prefetchSize. }
true;public;1;3;/**  * The maximum number of messages that the server will deliver, 0 if  * unlimited. You need to specify the option of prefetchSize, prefetchCount,  * prefetchGlobal at the same time  */ ;/**  * The maximum number of messages that the server will deliver, 0 if  * unlimited. You need to specify the option of prefetchSize, prefetchCount,  * prefetchGlobal at the same time  */ public void setPrefetchCount(int prefetchCount) {     this.prefetchCount = prefetchCount. }
false;public;0;3;;public int getPrefetchCount() {     return prefetchCount. }
true;public;1;3;/**  * If the settings should be applied to the entire channel rather than each  * consumer You need to specify the option of prefetchSize, prefetchCount,  * prefetchGlobal at the same time  */ ;/**  * If the settings should be applied to the entire channel rather than each  * consumer You need to specify the option of prefetchSize, prefetchCount,  * prefetchGlobal at the same time  */ public void setPrefetchGlobal(boolean prefetchGlobal) {     this.prefetchGlobal = prefetchGlobal. }
false;public;0;3;;public boolean isPrefetchGlobal() {     return prefetchGlobal. }
false;public;0;3;;public int getConcurrentConsumers() {     return concurrentConsumers. }
true;public;1;3;/**  * Number of concurrent consumers when consuming from broker. (eg similar as  * to the same option for the JMS component).  */ ;/**  * Number of concurrent consumers when consuming from broker. (eg similar as  * to the same option for the JMS component).  */ public void setConcurrentConsumers(int concurrentConsumers) {     this.concurrentConsumers = concurrentConsumers. }
false;public;0;3;;public boolean isDeclare() {     return declare. }
true;public;1;3;/**  * If the option is true, camel declare the exchange and queue name and bind  * them together. If the option is false, camel won't declare the exchange  * and queue name on the server.  */ ;/**  * If the option is true, camel declare the exchange and queue name and bind  * them together. If the option is false, camel won't declare the exchange  * and queue name on the server.  */ public void setDeclare(boolean declare) {     this.declare = declare. }
false;public;0;3;;public String getDeadLetterExchange() {     return deadLetterExchange. }
true;public;1;3;/**  * The name of the dead letter exchange  */ ;/**  * The name of the dead letter exchange  */ public void setDeadLetterExchange(String deadLetterExchange) {     this.deadLetterExchange = deadLetterExchange. }
false;public;0;3;;public String getDeadLetterQueue() {     return deadLetterQueue. }
true;public;1;3;/**  * The name of the dead letter queue  */ ;/**  * The name of the dead letter queue  */ public void setDeadLetterQueue(String deadLetterQueue) {     this.deadLetterQueue = deadLetterQueue. }
false;public;0;3;;public String getDeadLetterRoutingKey() {     return deadLetterRoutingKey. }
true;public;1;3;/**  * The routing key for the dead letter exchange  */ ;/**  * The routing key for the dead letter exchange  */ public void setDeadLetterRoutingKey(String deadLetterRoutingKey) {     this.deadLetterRoutingKey = deadLetterRoutingKey. }
false;public;0;3;;public String getDeadLetterExchangeType() {     return deadLetterExchangeType. }
true;public;1;3;/**  * The type of the dead letter exchange  */ ;/**  * The type of the dead letter exchange  */ public void setDeadLetterExchangeType(String deadLetterExchangeType) {     this.deadLetterExchangeType = deadLetterExchangeType. }
true;public;0;3;/**  * Get maximum number of opened channel in pool  */ ;/**  * Get maximum number of opened channel in pool  */ public int getChannelPoolMaxSize() {     return channelPoolMaxSize. }
false;public;1;3;;public void setChannelPoolMaxSize(int channelPoolMaxSize) {     this.channelPoolMaxSize = channelPoolMaxSize. }
false;public;0;3;;public long getChannelPoolMaxWait() {     return channelPoolMaxWait. }
true;public;1;3;/**  * Set the maximum number of milliseconds to wait for a channel from the  * pool  */ ;/**  * Set the maximum number of milliseconds to wait for a channel from the  * pool  */ public void setChannelPoolMaxWait(long channelPoolMaxWait) {     this.channelPoolMaxWait = channelPoolMaxWait. }
false;public;0;3;;public boolean isMandatory() {     return mandatory. }
true;public;1;3;/**  * This flag tells the server how to react if the message cannot be routed  * to a queue. If this flag is set, the server will return an unroutable  * message with a Return method. If this flag is zero, the server silently  * drops the message.  * <p/>  * If the header is present rabbitmq.MANDATORY it will override this option.  */ ;/**  * This flag tells the server how to react if the message cannot be routed  * to a queue. If this flag is set, the server will return an unroutable  * message with a Return method. If this flag is zero, the server silently  * drops the message.  * <p/>  * If the header is present rabbitmq.MANDATORY it will override this option.  */ public void setMandatory(boolean mandatory) {     this.mandatory = mandatory. }
false;public;0;3;;public boolean isImmediate() {     return immediate. }
true;public;1;3;/**  * This flag tells the server how to react if the message cannot be routed  * to a queue consumer immediately. If this flag is set, the server will  * return an undeliverable message with a Return method. If this flag is  * zero, the server will queue the message, but with no guarantee that it  * will ever be consumed.  * <p/>  * If the header is present rabbitmq.IMMEDIATE it will override this option.  */ ;/**  * This flag tells the server how to react if the message cannot be routed  * to a queue consumer immediately. If this flag is set, the server will  * return an undeliverable message with a Return method. If this flag is  * zero, the server will queue the message, but with no guarantee that it  * will ever be consumed.  * <p/>  * If the header is present rabbitmq.IMMEDIATE it will override this option.  */ public void setImmediate(boolean immediate) {     this.immediate = immediate. }
true;public;1;3;/**  * Specify arguments for configuring the different RabbitMQ concepts, a  * different prefix is required for each:  * <ul>  * <li>Exchange: arg.exchange.</li>  * <li>Queue: arg.queue.</li>  * <li>Binding: arg.binding.</li>  * </ul>  * For example to declare a queue with message ttl argument:  * http://localhost:5672/exchange/queue?args=arg.queue.x-message-ttl=60000  */ ;/**  * Specify arguments for configuring the different RabbitMQ concepts, a  * different prefix is required for each:  * <ul>  * <li>Exchange: arg.exchange.</li>  * <li>Queue: arg.queue.</li>  * <li>Binding: arg.binding.</li>  * </ul>  * For example to declare a queue with message ttl argument:  * http://localhost:5672/exchange/queue?args=arg.queue.x-message-ttl=60000  */ public void setArgs(Map<String, Object> args) {     this.args = args. }
false;public;0;3;;public Map<String, Object> getArgs() {     return args. }
false;public;0;3;;public Map<String, Object> getExchangeArgs() {     return IntrospectionSupport.extractProperties(args, EXCHANGE_ARG_PREFIX). }
false;public;0;3;;public Map<String, Object> getQueueArgs() {     return IntrospectionSupport.extractProperties(args, QUEUE_ARG_PREFIX). }
false;public;0;3;;public Map<String, Object> getBindingArgs() {     return IntrospectionSupport.extractProperties(args, BINDING_ARG_PREFIX). }
true;public;1;3;/**  * Set timeout for waiting for a reply when using the InOut Exchange Pattern  * (in milliseconds)  */ ;/**  * Set timeout for waiting for a reply when using the InOut Exchange Pattern  * (in milliseconds)  */ public void setRequestTimeout(long requestTimeout) {     this.requestTimeout = requestTimeout. }
false;public;0;3;;public long getRequestTimeout() {     return requestTimeout. }
true;public;1;3;/**  * Set requestTimeoutCheckerInterval for inOut exchange  */ ;/**  * Set requestTimeoutCheckerInterval for inOut exchange  */ public void setRequestTimeoutCheckerInterval(long requestTimeoutCheckerInterval) {     this.requestTimeoutCheckerInterval = requestTimeoutCheckerInterval. }
false;public;0;3;;public long getRequestTimeoutCheckerInterval() {     return requestTimeoutCheckerInterval. }
true;public;0;3;/**  * Get useMessageIDAsCorrelationID for inOut exchange  */ ;/**  * Get useMessageIDAsCorrelationID for inOut exchange  */ public boolean isUseMessageIDAsCorrelationID() {     return useMessageIDAsCorrelationID. }
true;public;1;3;/**  * When true and an inOut Exchange failed on the consumer side send the  * caused Exception back in the response  */ ;/**  * When true and an inOut Exchange failed on the consumer side send the  * caused Exception back in the response  */ public void setTransferException(boolean transferException) {     this.transferException = transferException. }
false;public;0;3;;public boolean isTransferException() {     return transferException. }
true;public;0;3;/**  * When true, the message will be published with  * <a href="https://www.rabbitmq.com/confirms.html">publisher acknowledgements</a> turned on  */ ;/**  * When true, the message will be published with  * <a href="https://www.rabbitmq.com/confirms.html">publisher acknowledgements</a> turned on  */ public boolean isPublisherAcknowledgements() {     return publisherAcknowledgements. }
false;public;1;3;;public void setPublisherAcknowledgements(final boolean publisherAcknowledgements) {     this.publisherAcknowledgements = publisherAcknowledgements. }
true;public;0;3;/**  * The amount of time in milliseconds to wait for a basic.ack response from  * RabbitMQ server  */ ;/**  * The amount of time in milliseconds to wait for a basic.ack response from  * RabbitMQ server  */ public long getPublisherAcknowledgementsTimeout() {     return publisherAcknowledgementsTimeout. }
false;public;1;3;;public void setPublisherAcknowledgementsTimeout(final long publisherAcknowledgementsTimeout) {     this.publisherAcknowledgementsTimeout = publisherAcknowledgementsTimeout. }
true;public;0;3;/**  * When true, an exception will be thrown when the message cannot be  * delivered (basic.return) and the message is marked as mandatory.  * PublisherAcknowledgement will also be activated in this case.  * See also <a href=https://www.rabbitmq.com/confirms.html">publisher acknowledgements</a>  * - When will messages be confirmed.  */ ;/**  * When true, an exception will be thrown when the message cannot be  * delivered (basic.return) and the message is marked as mandatory.  * PublisherAcknowledgement will also be activated in this case.  * See also <a href=https://www.rabbitmq.com/confirms.html">publisher acknowledgements</a>  * - When will messages be confirmed.  */ public boolean isGuaranteedDeliveries() {     return guaranteedDeliveries. }
false;public;1;3;;public void setGuaranteedDeliveries(boolean guaranteedDeliveries) {     this.guaranteedDeliveries = guaranteedDeliveries. }
true;public;0;3;/**  * Get replyToType for inOut exchange  */ ;/**  * Get replyToType for inOut exchange  */ public String getReplyToType() {     return replyToType. }
true;public;0;3;/**  * Gets the Queue to reply to if you dont want to use temporary reply queues  */ ;/**  * Gets the Queue to reply to if you dont want to use temporary reply queues  */ public String getReplyTo() {     return replyTo. }
false;public;0;3;;public boolean isExclusive() {     return exclusive. }
true;public;1;3;/**  * Exclusive queues may only be accessed by the current connection, and are  * deleted when that connection closes.  */ ;/**  * Exclusive queues may only be accessed by the current connection, and are  * deleted when that connection closes.  */ public void setExclusive(boolean exclusive) {     this.exclusive = exclusive. }
false;public;0;3;;public boolean isExclusiveConsumer() {     return exclusiveConsumer. }
true;public;1;3;/**  * Request exclusive access to the queue (meaning only this consumer can access the queue). This is useful  * when you want a long-lived shared queue to be temporarily accessible by just one consumer.  */ ;/**  * Request exclusive access to the queue (meaning only this consumer can access the queue). This is useful  * when you want a long-lived shared queue to be temporarily accessible by just one consumer.  */ public void setExclusiveConsumer(boolean exclusiveConsumer) {     this.exclusiveConsumer = exclusiveConsumer. }
true;public;0;3;/**  * Allow pass null values to header  */ ;/**  * Allow pass null values to header  */ public boolean isAllowNullHeaders() {     return allowNullHeaders. }
false;public;1;3;;public void setAllowNullHeaders(boolean allowNullHeaders) {     this.allowNullHeaders = allowNullHeaders. }
false;public;0;3;;public boolean isPassive() {     return passive. }
true;public;1;3;/**  * Passive queues depend on the queue already to be available at RabbitMQ.  */ ;/**  * Passive queues depend on the queue already to be available at RabbitMQ.  */ public void setPassive(boolean passive) {     this.passive = passive. }
