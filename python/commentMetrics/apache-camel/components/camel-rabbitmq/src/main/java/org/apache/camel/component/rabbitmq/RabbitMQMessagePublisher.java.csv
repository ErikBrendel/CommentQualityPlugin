commented;modifiers;parameterAmount;loc;comment;code
false;public;6;5;;@Override public void handleReturn(int replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, byte[] body) throws IOException {     LOG.warn("Delivery failed for exchange: {} and routing key: {}. replyCode: {}. replyText: {}", exchange, routingKey, replyCode, replyText).     basicReturnReceived = true. }
false;private;1;15;;private Message resolveMessageFrom(final Exchange camelExchange) {     Message message = camelExchange.hasOut() ? camelExchange.getOut() : camelExchange.getIn().     // Remove the SERIALIZE_HEADER in case it was previously set     if (message.getHeaders() != null && message.getHeaders().containsKey(RabbitMQEndpoint.SERIALIZE_HEADER)) {         LOG.trace("Removing header: {}", RabbitMQEndpoint.SERIALIZE_HEADER).         message.getHeaders().remove(RabbitMQEndpoint.SERIALIZE_HEADER).     }     if (routingKey != null && routingKey.startsWith(RabbitMQConstants.RABBITMQ_DIRECT_REPLY_ROUTING_KEY)) {         // use default exchange for reply-to messages         message.setHeader(RabbitMQConstants.EXCHANGE_NAME, RabbitMQConstants.RABBITMQ_DIRECT_REPLY_EXCHANGE).         // use default exchange for reply-to messages         message.setHeader(RabbitMQConstants.EXCHANGE_OVERRIDE_NAME, RabbitMQConstants.RABBITMQ_DIRECT_REPLY_EXCHANGE).     }     return message. }
false;public;0;25;;public void publish() throws IOException {     AMQP.BasicProperties properties.     byte[] body.     try {         // To maintain backwards compatibility try the TypeConverter (The DefaultTypeConverter seems to only work on Strings)         body = camelExchange.getContext().getTypeConverter().mandatoryConvertTo(byte[].class, camelExchange, message.getBody()).         properties = endpoint.getMessageConverter().buildProperties(camelExchange).build().     } catch (NoTypeConversionAvailableException | TypeConversionException e) {         if (message.getBody() instanceof Serializable) {             // Add the header so the reply processor knows to de-serialize it             message.getHeaders().put(RabbitMQEndpoint.SERIALIZE_HEADER, true).             properties = endpoint.getMessageConverter().buildProperties(camelExchange).build().             body = serializeBodyFrom(message).         } else if (message.getBody() == null) {             properties = endpoint.getMessageConverter().buildProperties(camelExchange).build().             body = null.         } else {             LOG.warn("Cannot convert {} to byte[]", message.getBody()).             throw new RuntimeCamelException(e).         }     }     publishToRabbitMQ(properties, body). }
false;private;2;34;;private void publishToRabbitMQ(final AMQP.BasicProperties properties, final byte[] body) throws IOException {     // remove the OVERRIDE header so it does not propagate     String exchangeName = (String) message.removeHeader(RabbitMQConstants.EXCHANGE_OVERRIDE_NAME).     // If it is BridgeEndpoint we should ignore the message header of EXCHANGE_OVERRIDE_NAME     if (exchangeName == null || endpoint.isBridgeEndpoint()) {         exchangeName = endpoint.getExchangeName().     } else {         LOG.debug("Overriding header: {} detected sending message to exchange: {}", RabbitMQConstants.EXCHANGE_OVERRIDE_NAME, exchangeName).     }     Boolean mandatory = camelExchange.getIn().getHeader(RabbitMQConstants.MANDATORY, endpoint.isMandatory(), Boolean.class).     Boolean immediate = camelExchange.getIn().getHeader(RabbitMQConstants.IMMEDIATE, endpoint.isImmediate(), Boolean.class).     LOG.debug("Sending message to exchange: {} with CorrelationId: {}", exchangeName, properties.getCorrelationId()).     if (isPublisherAcknowledgements()) {         channel.confirmSelect().     }     if (endpoint.isGuaranteedDeliveries()) {         basicReturnReceived = false.         channel.addReturnListener(guaranteedDeliveryReturnListener).     }     try {         channel.basicPublish(exchangeName, routingKey, mandatory, immediate, properties, body).         if (isPublisherAcknowledgements()) {             waitForConfirmation().         }     } finally {         if (endpoint.isGuaranteedDeliveries()) {             channel.removeReturnListener(guaranteedDeliveryReturnListener).         }     } }
false;private;0;3;;private boolean isPublisherAcknowledgements() {     return endpoint.isPublisherAcknowledgements() || endpoint.isGuaranteedDeliveries(). }
false;private;0;12;;private void waitForConfirmation() throws IOException {     try {         LOG.debug("Waiting for publisher acknowledgements for {}ms", endpoint.getPublisherAcknowledgementsTimeout()).         channel.waitForConfirmsOrDie(endpoint.getPublisherAcknowledgementsTimeout()).         if (basicReturnReceived) {             throw new RuntimeCamelException("Failed to deliver message. basic.return received").         }     } catch (InterruptedException | TimeoutException e) {         LOG.warn("Acknowledgement error for {}", camelExchange).         throw new RuntimeCamelException(e).     } }
false;private;1;9;;private byte[] serializeBodyFrom(final Message msg) throws IOException {     try (ByteArrayOutputStream b = new ByteArrayOutputStream().         ObjectOutputStream o = new ObjectOutputStream(b)) {         o.writeObject(msg.getBody()).         return b.toByteArray().     } catch (NotSerializableException nse) {         LOG.warn("Cannot send object {} via RabbitMQ because it contains non-serializable objects.", msg.getBody().getClass()).         throw new RuntimeCamelException(nse).     } }
