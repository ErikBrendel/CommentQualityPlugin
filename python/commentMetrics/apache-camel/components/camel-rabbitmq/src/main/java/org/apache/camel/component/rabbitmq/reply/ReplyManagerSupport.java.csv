commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setScheduledExecutorService(ScheduledExecutorService executorService) {     this.executorService = executorService. }
false;public;1;3;;public void setEndpoint(RabbitMQEndpoint endpoint) {     this.endpoint = endpoint. }
false;public;1;6;;public void setReplyTo(String replyTo) {     log.debug("ReplyTo destination: {}", replyTo).     this.replyTo = replyTo.     // trigger latch as the reply to has been resolved and set     replyToLatch.countDown(). }
false;public;0;20;;public String getReplyTo() {     if (replyTo != null) {         return replyTo.     }     try {         // the reply to destination has to be resolved using a DestinationResolver using         // the MessageListenerContainer which occurs asynchronously so we have to wait         // for that to happen before we can retrieve the reply to destination to be used         log.trace("Waiting for replyTo to be set").         boolean done = replyToLatch.await(replyToTimeout, TimeUnit.MILLISECONDS).         if (!done) {             log.warn("ReplyTo destination was not set and timeout occurred").         } else {             log.trace("Waiting for replyTo to be set done").         }     } catch (InterruptedException e) {     // ignore     }     return replyTo. }
false;public;6;13;;public String registerReply(ReplyManager replyManager, Exchange exchange, AsyncCallback callback, String originalCorrelationId, String correlationId, long requestTimeout) {     // add to correlation map     QueueReplyHandler handler = new QueueReplyHandler(replyManager, exchange, callback, originalCorrelationId, correlationId, requestTimeout).     // Just make sure we don't override the old value of the correlationId     ReplyHandler result = correlation.putIfAbsent(correlationId, handler, requestTimeout).     if (result != null) {         String logMessage = String.format("The correlationId [%s] is not unique.", correlationId).         throw new IllegalArgumentException(logMessage).     }     return correlationId. }
false;protected,abstract;6;2;;protected abstract ReplyHandler createReplyHandler(ReplyManager replyManager, Exchange exchange, AsyncCallback callback, String originalCorrelationId, String correlationId, long requestTimeout).
false;public;1;7;;public void cancelCorrelationId(String correlationId) {     ReplyHandler handler = correlation.get(correlationId).     if (handler != null) {         log.warn("Cancelling correlationID: {}", correlationId).         correlation.remove(correlationId).     } }
false;public;2;13;;public void onMessage(AMQP.BasicProperties properties, byte[] message) {     String correlationID = properties.getCorrelationId().     if (correlationID == null) {         log.warn("Ignoring message with no correlationID: {}", message).         return.     }     log.debug("Received reply message with correlationID [{}] -> {}", correlationID, message).     // handle the reply message     handleReplyMessage(correlationID, properties, message). }
false;public;1;37;;public void processReply(ReplyHolder holder) {     if (holder != null && isRunAllowed()) {         try {             Exchange exchange = holder.getExchange().             boolean timeout = holder.isTimeout().             if (timeout) {                 // timeout occurred do a WARN log so its easier to spot in the logs                 if (log.isWarnEnabled()) {                     log.warn("Timeout occurred after {} millis waiting for reply message with correlationID [{}] on destination {}." + " Setting ExchangeTimedOutException on {} and continue routing.", holder.getRequestTimeout(), holder.getCorrelationId(), replyTo, ExchangeHelper.logIds(exchange)).                 }                 // no response, so lets set a timed out exception                 String msg = "reply message with correlationID: " + holder.getCorrelationId() + " not received on destination: " + replyTo.                 exchange.setException(new ExchangeTimedOutException(exchange, holder.getRequestTimeout(), msg)).             } else {                 messageConverter.populateRabbitExchange(exchange, null, holder.getProperties(), holder.getMessage(), true).                 // restore correlation id in case the remote server messed with it                 if (holder.getOriginalCorrelationId() != null) {                     if (exchange.hasOut()) {                         exchange.getOut().setHeader(RabbitMQConstants.CORRELATIONID, holder.getOriginalCorrelationId()).                     } else {                         exchange.getIn().setHeader(RabbitMQConstants.CORRELATIONID, holder.getOriginalCorrelationId()).                     }                 }             }         } finally {             // notify callback             AsyncCallback callback = holder.getCallback().             callback.done(false).         }     } }
false;protected,abstract;3;1;;protected abstract void handleReplyMessage(String correlationID, AMQP.BasicProperties properties, byte[] message).
false;protected,abstract;0;1;;protected abstract Connection createListenerContainer() throws Exception.
true;protected;2;36;/**  * <b>IMPORTANT:</b> This logic is only being used due to high performance in-memory only  * testing using InOut over JMS. Its unlikely to happen in a real life situation with communication  * to a remote broker, which always will be slower to send back reply, before Camel had a chance  * to update it's internal correlation map.  */ ;/**  * <b>IMPORTANT:</b> This logic is only being used due to high performance in-memory only  * testing using InOut over JMS. Its unlikely to happen in a real life situation with communication  * to a remote broker, which always will be slower to send back reply, before Camel had a chance  * to update it's internal correlation map.  */ protected ReplyHandler waitForProvisionCorrelationToBeUpdated(String correlationID, byte[] message) {     // from the provisional id to the JMSMessageID. If so we have to wait a bit and lookup again.     if (log.isWarnEnabled()) {         log.warn("Early reply received with correlationID [{}] -> {}", correlationID, message).     }     ReplyHandler answer = null.     // wait up till 5 seconds     boolean done = false.     int counter = 0.     while (!done && counter++ < 50) {         log.trace("Early reply not found handler at attempt {}. Waiting a bit longer.", counter).         try {             Thread.sleep(100).         } catch (InterruptedException e) {         // ignore         }         // try again         answer = correlation.get(correlationID).         done = answer != null.         if (answer != null) {             if (log.isTraceEnabled()) {                 log.trace("Early reply with correlationID [{}] has been matched after {} attempts and can be processed using handler: {}", correlationID, counter, answer).             }         }     }     return answer. }
false;protected;0;17;;@Override protected void doStart() throws Exception {     ObjectHelper.notNull(executorService, "executorService", this).     ObjectHelper.notNull(endpoint, "endpoint", this).     messageConverter.setAllowNullHeaders(endpoint.isAllowNullHeaders()).     // timeout map to use for purging messages which have timed out, while waiting for an expected reply     // when doing request/reply over JMS     log.debug("Using timeout checker interval with {} millis", endpoint.getRequestTimeoutCheckerInterval()).     correlation = new CorrelationTimeoutMap(executorService, endpoint.getRequestTimeoutCheckerInterval()).     ServiceHelper.startService(correlation).     // create listener and start it     listenerContainer = createListenerContainer().     log.debug("Using executor {}", executorService). }
false;protected;0;16;;@Override protected void doStop() throws Exception {     ServiceHelper.stopService(correlation).     if (listenerContainer != null) {         log.debug("Closing connection: {} with timeout: {} ms.", listenerContainer, CLOSE_TIMEOUT).         listenerContainer.close(CLOSE_TIMEOUT).         listenerContainer = null.     }     // must also stop executor service     if (executorService != null) {         camelContext.getExecutorServiceManager().shutdownGraceful(executorService).         executorService = null.     } }
