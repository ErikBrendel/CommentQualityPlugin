commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Override public void configure() throws Exception {     from("direct:start").to(BASIC_URI).     from("direct:start-allow-null-headers").to(ALLOW_NULL_HEADERS).     from("direct:start-with-confirms").to(PUBLISHER_ACKNOWLEDGES_URI).     from("direct:start-with-confirms-bad-route").to(PUBLISHER_ACKNOWLEDGES_BAD_ROUTE_URI).     from("direct:start-with-guaranteed-delivery").to(GUARANTEED_DELIVERY_URI).     from("direct:start-with-guaranteed-delivery-bad-route").to(GUARANTEED_DELIVERY_BAD_ROUTE_URI).     from("direct:start-with-guaranteed-delivery-bad-route-but-not-mandatory").to(GUARANTEED_DELIVERY_BAD_ROUTE_NOT_MANDATORY_URI). }
false;protected;0;16;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     context().setTracing(true).     return new RouteBuilder() {          @Override         public void configure() throws Exception {             from("direct:start").to(BASIC_URI).             from("direct:start-allow-null-headers").to(ALLOW_NULL_HEADERS).             from("direct:start-with-confirms").to(PUBLISHER_ACKNOWLEDGES_URI).             from("direct:start-with-confirms-bad-route").to(PUBLISHER_ACKNOWLEDGES_BAD_ROUTE_URI).             from("direct:start-with-guaranteed-delivery").to(GUARANTEED_DELIVERY_URI).             from("direct:start-with-guaranteed-delivery-bad-route").to(GUARANTEED_DELIVERY_BAD_ROUTE_URI).             from("direct:start-with-guaranteed-delivery-bad-route-but-not-mandatory").to(GUARANTEED_DELIVERY_BAD_ROUTE_NOT_MANDATORY_URI).         }     }. }
false;public;0;7;;@Before public void setUpRabbitMQ() throws Exception {     connection = connection().     channel = connection.createChannel().     channel.queueDeclare("sammyq", false, false, true, null).     channel.queueBind("sammyq", EXCHANGE, ROUTE). }
false;public;0;5;;@After public void tearDownRabbitMQ() throws Exception {     channel.abort().     connection.abort(). }
false;public;0;9;;@Test public void producedMessageIsReceived() throws InterruptedException, IOException, TimeoutException {     final List<String> received = new ArrayList<>().     channel.basicConsume("sammyq", true, new ArrayPopulatingConsumer(received)).     template.sendBodyAndHeader("new message", RabbitMQConstants.EXCHANGE_NAME, "ex1").     assertThatBodiesReceivedIn(received, "new message"). }
false;public;0;15;;@Test public void producedMessageWithNotNullHeaders() throws InterruptedException, IOException, TimeoutException {     final List<String> received = new ArrayList<>().     final Map<String, Object> receivedHeaders = new HashMap<String, Object>().     Map<String, Object> headers = new HashMap<String, Object>().     headers.put(RabbitMQConstants.EXCHANGE_NAME, EXCHANGE).     headers.put(CUSTOM_HEADER, CUSTOM_HEADER.toLowerCase()).     channel.basicConsume("sammyq", true, new ArrayPopulatingConsumer(received, receivedHeaders)).     template.sendBodyAndHeaders("new message", headers).     assertThatBodiesAndHeadersReceivedIn(receivedHeaders, headers, received, "new message"). }
false;public;0;15;;@Test public void producedMessageAllowNullHeaders() throws InterruptedException, IOException, TimeoutException {     final List<String> received = new ArrayList<>().     final Map<String, Object> receivedHeaders = new HashMap<String, Object>().     Map<String, Object> headers = new HashMap<String, Object>().     headers.put(RabbitMQConstants.EXCHANGE_NAME, null).     headers.put(CUSTOM_HEADER, null).     channel.basicConsume("sammyq", true, new ArrayPopulatingConsumer(received, receivedHeaders)).     templateAllowNullHeaders.sendBodyAndHeaders("new message", headers).     assertThatBodiesAndHeadersReceivedIn(receivedHeaders, headers, received, "new message"). }
false;private;2;8;;private void assertThatBodiesReceivedIn(final List<String> received, final String... expected) throws InterruptedException {     Thread.sleep(500).     assertListSize(received, expected.length).     for (String body : expected) {         assertEquals(body, received.get(0)).     } }
false;private;4;18;;private void assertThatBodiesAndHeadersReceivedIn(Map<String, Object> receivedHeaders, Map<String, Object> expectedHeaders, final List<String> received, final String... expected) throws InterruptedException {     Thread.sleep(500).     assertListSize(received, expected.length).     for (String body : expected) {         assertEquals(body, received.get(0)).     }     for (Map.Entry<String, Object> headers : expectedHeaders.entrySet()) {         Object receivedValue = receivedHeaders.get(headers.getKey()).         Object expectedValue = headers.getValue().         assertTrue("Header key " + headers.getKey() + " not found", receivedHeaders.containsKey(headers.getKey())).         assertEquals(0, ObjectHelper.compare(receivedValue == null ? "" : receivedValue.toString(), expectedValue == null ? "" : expectedValue.toString())).     } }
false;public;0;9;;@Test public void producedMessageIsReceivedWhenPublisherAcknowledgementsAreEnabled() throws InterruptedException, IOException, TimeoutException {     final List<String> received = new ArrayList<>().     channel.basicConsume("sammyq", true, new ArrayPopulatingConsumer(received)).     templateWithConfirms.sendBodyAndHeader("publisher ack message", RabbitMQConstants.EXCHANGE_NAME, "ex1").     assertThatBodiesReceivedIn(received, "publisher ack message"). }
false;public;0;9;;@Test public void producedMessageIsReceivedWhenPublisherAcknowledgementsAreEnabledAndBadRoutingKeyIsUsed() throws InterruptedException, IOException, TimeoutException {     final List<String> received = new ArrayList<>().     channel.basicConsume("sammyq", true, new ArrayPopulatingConsumer(received)).     templateWithConfirmsAndBadRoute.sendBody("publisher ack message").     assertThatBodiesReceivedIn(received). }
false;public;0;9;;@Test public void shouldSuccessfullyProduceMessageWhenGuaranteedDeliveryIsActivatedAndMessageIsMarkedAsMandatory() throws InterruptedException, IOException, TimeoutException {     final List<String> received = new ArrayList<>().     channel.basicConsume("sammyq", true, new ArrayPopulatingConsumer(received)).     templateWithGuranteedDelivery.sendBodyAndHeader("publisher ack message", RabbitMQConstants.EXCHANGE_NAME, "ex1").     assertThatBodiesReceivedIn(received, "publisher ack message"). }
false;public;0;4;;@Test(expected = RuntimeCamelException.class) public void shouldFailIfMessageIsMarkedAsMandatoryAndGuaranteedDeliveryIsActiveButNoQueueIsBound() {     templateWithGuranteedDeliveryAndBadRoute.sendBody("publish with ack and return message"). }
false;public;0;9;;@Test public void shouldSuccessfullyProduceMessageWhenGuaranteedDeliveryIsActivatedOnABadRouteButMessageIsNotMandatory() throws InterruptedException, IOException, TimeoutException {     final List<String> received = new ArrayList<>().     channel.basicConsume("sammyq", true, new ArrayPopulatingConsumer(received)).     templateWithGuranteedDeliveryBadRouteButNotMandatory.sendBodyAndHeader("publisher ack message", RabbitMQConstants.EXCHANGE_NAME, "ex1").     assertThatBodiesReceivedIn(received). }
false;public;4;10;;@Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {     LOGGER.info("AMQP.BasicProperties: {}", properties).     receivedHeaders.putAll(properties.getHeaders()).     received.add(new String(body)). }
