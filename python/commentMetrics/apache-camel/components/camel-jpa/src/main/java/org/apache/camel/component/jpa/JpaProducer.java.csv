commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public JpaEndpoint getEndpoint() {     return (JpaEndpoint) super.getEndpoint(). }
false;public;0;16;;public QueryFactory getQueryFactory() {     if (queryFactory == null) {         if (query != null) {             queryFactory = QueryBuilder.query(query).         } else if (namedQuery != null) {             queryFactory = QueryBuilder.namedQuery(namedQuery).         } else if (nativeQuery != null) {             if (resultClass != null) {                 queryFactory = QueryBuilder.nativeQuery(nativeQuery, resultClass).             } else {                 queryFactory = QueryBuilder.nativeQuery(nativeQuery).             }         }     }     return queryFactory. }
false;public;1;3;;public void setQueryFactory(QueryFactory queryFactory) {     this.queryFactory = queryFactory. }
false;public;1;3;;public void setParameters(Map<String, Object> params) {     this.parameters = params. }
false;public;0;3;;public Map<String, Object> getParameters() {     return parameters. }
false;public;0;3;;public String getNamedQuery() {     return namedQuery. }
false;public;1;3;;public void setNamedQuery(String namedQuery) {     this.namedQuery = namedQuery. }
false;public;0;3;;public String getNativeQuery() {     return nativeQuery. }
false;public;1;3;;public void setNativeQuery(String nativeQuery) {     this.nativeQuery = nativeQuery. }
false;public;0;3;;public String getQuery() {     return query. }
false;public;1;3;;public void setQuery(String query) {     this.query = query. }
false;public;0;3;;public Class<?> getResultClass() {     return resultClass. }
false;public;1;3;;public void setResultClass(Class<?> resultClass) {     this.resultClass = resultClass. }
false;public;1;3;;public void setUseExecuteUpdate(Boolean executeUpdate) {     this.useExecuteUpdate = executeUpdate. }
false;public;0;20;;public boolean isUseExecuteUpdate() {     if (useExecuteUpdate == null) {         if (query != null) {             if (query.regionMatches(true, 0, "select", 0, 6)) {                 useExecuteUpdate = false.             } else {                 useExecuteUpdate = true.             }         } else if (nativeQuery != null) {             if (nativeQuery.regionMatches(true, 0, "select", 0, 6)) {                 useExecuteUpdate = false.             } else {                 useExecuteUpdate = true.             }         } else {             useExecuteUpdate = false.         }     }     return useExecuteUpdate. }
false;public;1;11;;public void process(final Exchange exchange) {     // resolve the entity manager before evaluating the expression     final EntityManager entityManager = getTargetEntityManager(exchange, entityManagerFactory, getEndpoint().isUsePassedInEntityManager(), getEndpoint().isSharedEntityManager(), true).     if (getQueryFactory() != null) {         processQuery(exchange, entityManager).     } else {         processEntity(exchange, entityManager).     } }
false;public;1;15;;public Object doInTransaction(TransactionStatus status) {     if (getEndpoint().isJoinTransaction()) {         entityManager.joinTransaction().     }     Object answer = isUseExecuteUpdate() ? query.executeUpdate() : query.getResultList().     Message target = exchange.getPattern().isOutCapable() ? exchange.getOut() : exchange.getIn().     target.setBody(answer).     if (getEndpoint().isFlushOnSend()) {         entityManager.flush().     }     return null. }
false;protected;2;22;;protected void processQuery(Exchange exchange, EntityManager entityManager) {     Query query = getQueryFactory().createQuery(entityManager).     configureParameters(query, exchange).     transactionTemplate.execute(new TransactionCallback<Object>() {          public Object doInTransaction(TransactionStatus status) {             if (getEndpoint().isJoinTransaction()) {                 entityManager.joinTransaction().             }             Object answer = isUseExecuteUpdate() ? query.executeUpdate() : query.getResultList().             Message target = exchange.getPattern().isOutCapable() ? exchange.getOut() : exchange.getIn().             target.setBody(answer).             if (getEndpoint().isFlushOnSend()) {                 entityManager.flush().             }             return null.         }     }). }
false;private;2;23;;@SuppressWarnings("unchecked") private void configureParameters(Query query, Exchange exchange) {     int maxResults = getEndpoint().getMaximumResults().     if (maxResults > 0) {         query.setMaxResults(maxResults).     }     // setup the parameters     Map<String, ?> params.     if (parameters != null) {         params = parameters.     } else {         params = exchange.getIn().getHeader(JpaConstants.JPA_PARAMETERS_HEADER, Map.class).     }     if (params != null) {         params.forEach((key, value) -> {             Object resolvedValue = value.             if (value instanceof String) {                 resolvedValue = SimpleLanguage.expression((String) value).evaluate(exchange, Object.class).             }             query.setParameter(key, resolvedValue).         }).     } }
false;public;1;41;;public Object doInTransaction(TransactionStatus status) {     if (getEndpoint().isJoinTransaction()) {         entityManager.joinTransaction().     }     if (values.getClass().isArray()) {         Object[] array = (Object[]) values.         for (Object element : array) {             if (!getEndpoint().isRemove()) {                 save(element).             } else {                 remove(element).             }         }     } else if (values instanceof Collection) {         Collection<?> collection = (Collection<?>) values.         for (Object entity : collection) {             if (!getEndpoint().isRemove()) {                 save(entity).             } else {                 remove(entity).             }         }     } else {         Object managedEntity = null.         if (!getEndpoint().isRemove()) {             managedEntity = save(values).         } else {             managedEntity = remove(values).         }         if (!getEndpoint().isUsePersist()) {             exchange.getIn().setBody(managedEntity).         }     }     if (getEndpoint().isFlushOnSend()) {         entityManager.flush().     }     return null. }
true;private;1;9;/**  * Save the given entity end return the managed entity  *  * @return the managed entity  */ ;/**  * Save the given entity end return the managed entity  *  * @return the managed entity  */ private Object save(final Object entity) {     log.debug("save: {}", entity).     if (getEndpoint().isUsePersist()) {         entityManager.persist(entity).         return entity.     } else {         return entityManager.merge(entity).     } }
true;private;1;16;/**  * Remove the given entity end return the managed entity  *  * @return the managed entity  */ ;/**  * Remove the given entity end return the managed entity  *  * @return the managed entity  */ private Object remove(final Object entity) {     log.debug("remove: {}", entity).     Object managedEntity.     // First check if entity is attached to the persistence context     if (entityManager.contains(entity)) {         managedEntity = entity.     } else {         // If not, merge entity state into context before removing it         managedEntity = entityManager.merge(entity).     }     entityManager.remove(managedEntity).     return managedEntity. }
false;protected;2;86;;protected void processEntity(Exchange exchange, EntityManager entityManager) {     final Object values = expression.evaluate(exchange, Object.class).     if (values != null) {         transactionTemplate.execute(new TransactionCallback<Object>() {              public Object doInTransaction(TransactionStatus status) {                 if (getEndpoint().isJoinTransaction()) {                     entityManager.joinTransaction().                 }                 if (values.getClass().isArray()) {                     Object[] array = (Object[]) values.                     for (Object element : array) {                         if (!getEndpoint().isRemove()) {                             save(element).                         } else {                             remove(element).                         }                     }                 } else if (values instanceof Collection) {                     Collection<?> collection = (Collection<?>) values.                     for (Object entity : collection) {                         if (!getEndpoint().isRemove()) {                             save(entity).                         } else {                             remove(entity).                         }                     }                 } else {                     Object managedEntity = null.                     if (!getEndpoint().isRemove()) {                         managedEntity = save(values).                     } else {                         managedEntity = remove(values).                     }                     if (!getEndpoint().isUsePersist()) {                         exchange.getIn().setBody(managedEntity).                     }                 }                 if (getEndpoint().isFlushOnSend()) {                     entityManager.flush().                 }                 return null.             }              /**              * Save the given entity end return the managed entity              *              * @return the managed entity              */             private Object save(final Object entity) {                 log.debug("save: {}", entity).                 if (getEndpoint().isUsePersist()) {                     entityManager.persist(entity).                     return entity.                 } else {                     return entityManager.merge(entity).                 }             }              /**              * Remove the given entity end return the managed entity              *              * @return the managed entity              */             private Object remove(final Object entity) {                 log.debug("remove: {}", entity).                 Object managedEntity.                 // First check if entity is attached to the persistence context                 if (entityManager.contains(entity)) {                     managedEntity = entity.                 } else {                     // If not, merge entity state into context before removing it                     managedEntity = entityManager.merge(entity).                 }                 entityManager.remove(managedEntity).                 return managedEntity.             }         }).     } }
