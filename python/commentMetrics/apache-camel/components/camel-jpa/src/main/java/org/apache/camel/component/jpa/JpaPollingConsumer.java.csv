commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public JpaEndpoint getEndpoint() {     return (JpaEndpoint) super.getEndpoint(). }
false;public;0;3;;public String getQuery() {     return query. }
false;public;1;3;;public void setQuery(String query) {     this.query = query. }
false;public;0;3;;public String getNamedQuery() {     return namedQuery. }
false;public;1;3;;public void setNamedQuery(String namedQuery) {     this.namedQuery = namedQuery. }
false;public;0;3;;public String getNativeQuery() {     return nativeQuery. }
false;public;1;3;;public void setNativeQuery(String nativeQuery) {     this.nativeQuery = nativeQuery. }
false;public;0;3;;public LockModeType getLockModeType() {     return lockModeType. }
false;public;1;3;;public void setLockModeType(LockModeType lockModeType) {     this.lockModeType = lockModeType. }
false;public;0;3;;public Class<?> getResultClass() {     return resultClass. }
false;public;1;3;;public void setResultClass(Class<?> resultClass) {     this.resultClass = resultClass. }
false;public;0;3;;public QueryFactory getQueryFactory() {     return queryFactory. }
false;public;1;3;;public void setQueryFactory(QueryFactory queryFactory) {     this.queryFactory = queryFactory. }
false;public;0;3;;public Map<String, Object> getParameters() {     return parameters. }
false;public;1;3;;public void setParameters(Map<String, Object> parameters) {     this.parameters = parameters. }
false;public;1;44;;public Object doInTransaction(TransactionStatus status) {     if (getEndpoint().isJoinTransaction()) {         entityManager.joinTransaction().     }     Query query = getQueryFactory().createQuery(entityManager).     configureParameters(query).     if (getEndpoint().isConsumeLockEntity()) {         query.setLockMode(getLockModeType()).     }     log.trace("Created query {}", query).     Object answer.     try {         List<?> results = query.getResultList().         if (results != null && results.size() == 1) {             // we only have 1 entity so return that             answer = results.get(0).         } else {             // we have more data so return a list             answer = results.         }         // commit         log.debug("Flushing EntityManager").         entityManager.flush().         // must clear after flush         entityManager.clear().     } catch (PersistenceException e) {         log.info("Disposing EntityManager {} on {} due to coming transaction rollback", entityManager, this).         entityManager.close().         throw e.     }     return answer. }
false;public;0;58;;@Override public Exchange receive() {     // resolve the entity manager before evaluating the expression     final EntityManager entityManager = getTargetEntityManager(null, entityManagerFactory, getEndpoint().isUsePassedInEntityManager(), getEndpoint().isSharedEntityManager(), true).     Object out = transactionTemplate.execute(new TransactionCallback<Object>() {          public Object doInTransaction(TransactionStatus status) {             if (getEndpoint().isJoinTransaction()) {                 entityManager.joinTransaction().             }             Query query = getQueryFactory().createQuery(entityManager).             configureParameters(query).             if (getEndpoint().isConsumeLockEntity()) {                 query.setLockMode(getLockModeType()).             }             log.trace("Created query {}", query).             Object answer.             try {                 List<?> results = query.getResultList().                 if (results != null && results.size() == 1) {                     // we only have 1 entity so return that                     answer = results.get(0).                 } else {                     // we have more data so return a list                     answer = results.                 }                 // commit                 log.debug("Flushing EntityManager").                 entityManager.flush().                 // must clear after flush                 entityManager.clear().             } catch (PersistenceException e) {                 log.info("Disposing EntityManager {} on {} due to coming transaction rollback", entityManager, this).                 entityManager.close().                 throw e.             }             return answer.         }     }).     Exchange exchange = createExchange(out, entityManager).     exchange.getIn().setBody(out).     return exchange. }
false;public;0;5;;@Override public Exchange receiveNoWait() {     // call receive as-is     return receive(). }
false;public;1;19;;@Override public Exchange receive(long timeout) {     // need to use a thread pool to perform the task so we can support timeout     if (executorService == null) {         executorService = getEndpoint().getComponent().getOrCreatePollingConsumerExecutorService().     }     // the task is the receive method     Future<Exchange> future = executorService.submit((Callable<Exchange>) this::receive).     try {         return future.get(timeout, TimeUnit.MILLISECONDS).     } catch (ExecutionException | InterruptedException e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } catch (TimeoutException e) {     // ignore as we hit timeout then return null     }     return null. }
false;protected;0;9;;@Override protected void doStart() throws Exception {     if (queryFactory == null) {         queryFactory = createQueryFactory().         if (queryFactory == null) {             throw new IllegalArgumentException("No queryType property configured on this consumer, nor an entityType configured on the endpoint so cannot consume").         }     } }
false;protected;0;5;;@Override protected void doStop() throws Exception { // noop }
false;protected;1;12;;protected void configureParameters(Query query) {     int maxResults = getEndpoint().getMaximumResults().     if (maxResults > 0) {         query.setMaxResults(maxResults).     }     // setup the parameter     if (parameters != null) {         for (Map.Entry<String, Object> entry : parameters.entrySet()) {             query.setParameter(entry.getKey(), entry.getValue()).         }     } }
false;protected;2;6;;protected Exchange createExchange(Object result, EntityManager entityManager) {     Exchange exchange = getEndpoint().createExchange().     exchange.getIn().setBody(result).     exchange.getIn().setHeader(JpaConstants.ENTITY_MANAGER, entityManager).     return exchange. }
false;protected;0;28;;protected QueryFactory createQueryFactory() {     if (query != null) {         return QueryBuilder.query(query).     } else if (namedQuery != null) {         return QueryBuilder.namedQuery(namedQuery).     } else if (nativeQuery != null) {         if (resultClass != null) {             return QueryBuilder.nativeQuery(nativeQuery, resultClass).         } else {             return QueryBuilder.nativeQuery(nativeQuery).         }     } else {         Class<?> entityType = getEndpoint().getEntityType().         if (entityType == null) {             return null.         } else {             // Check if we have a property name on the @Entity annotation             String name = getEntityName(entityType).             if (name != null) {                 return QueryBuilder.query("select x from " + name + " x").             } else {                 // Remove package name of the entity to be conform with JPA 1.0 spec                 return QueryBuilder.query("select x from " + entityType.getSimpleName() + " x").             }         }     } }
false;protected;1;10;;protected String getEntityName(Class<?> clazz) {     Entity entity = clazz.getAnnotation(Entity.class).     // Check if the property name has been defined for Entity annotation     if (entity != null && !entity.name().equals("")) {         return entity.name().     } else {         return null.     } }
