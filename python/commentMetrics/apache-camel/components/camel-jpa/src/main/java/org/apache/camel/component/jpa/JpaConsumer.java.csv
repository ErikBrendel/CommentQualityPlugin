commented;modifiers;parameterAmount;loc;comment;code
false;public;1;50;;public Object doInTransaction(TransactionStatus status) {     if (getEndpoint().isJoinTransaction()) {         entityManager.joinTransaction().     }     Queue<DataHolder> answer = new LinkedList<>().     Query query = getQueryFactory().createQuery(entityManager).     configureParameters(query).     log.trace("Created query {}", query).     List<?> results = query.getResultList().     log.trace("Got result list from query {}", results).     for (Object result : results) {         DataHolder holder = new DataHolder().         holder.manager = entityManager.         holder.result = result.         holder.exchange = createExchange(result, entityManager).         answer.add(holder).     }     PersistenceException cause = null.     int messagePolled = 0.     try {         messagePolled = processBatch(CastUtils.cast(answer)).     } catch (Exception e) {         if (e instanceof PersistenceException) {             cause = (PersistenceException) e.         } else {             cause = new PersistenceException(e).         }     }     if (cause != null) {         if (!isTransacted()) {             log.warn("Error processing last message due: {}. Will commit all previous successful processed message, and ignore this last failure.", cause.getMessage(), cause).         } else {             // rollback all by throwning exception             throw cause.         }     }     // commit     log.debug("Flushing EntityManager").     entityManager.flush().     // must clear after flush     entityManager.clear().     return messagePolled. }
false;protected;0;81;;@Override protected int poll() throws Exception {     // must reset for each poll     shutdownRunningTask = null.     pendingExchanges = 0.     // Recreate EntityManager in case it is disposed due to transaction rollback     if (entityManager == null) {         if (getEndpoint().isSharedEntityManager()) {             this.entityManager = SharedEntityManagerCreator.createSharedEntityManager(entityManagerFactory).         } else {             this.entityManager = entityManagerFactory.createEntityManager().         }         log.trace("Recreated EntityManager {} on {}", entityManager, this).     }     Object messagePolled = null.     try {         messagePolled = transactionTemplate.execute(new TransactionCallback<Object>() {              public Object doInTransaction(TransactionStatus status) {                 if (getEndpoint().isJoinTransaction()) {                     entityManager.joinTransaction().                 }                 Queue<DataHolder> answer = new LinkedList<>().                 Query query = getQueryFactory().createQuery(entityManager).                 configureParameters(query).                 log.trace("Created query {}", query).                 List<?> results = query.getResultList().                 log.trace("Got result list from query {}", results).                 for (Object result : results) {                     DataHolder holder = new DataHolder().                     holder.manager = entityManager.                     holder.result = result.                     holder.exchange = createExchange(result, entityManager).                     answer.add(holder).                 }                 PersistenceException cause = null.                 int messagePolled = 0.                 try {                     messagePolled = processBatch(CastUtils.cast(answer)).                 } catch (Exception e) {                     if (e instanceof PersistenceException) {                         cause = (PersistenceException) e.                     } else {                         cause = new PersistenceException(e).                     }                 }                 if (cause != null) {                     if (!isTransacted()) {                         log.warn("Error processing last message due: {}. Will commit all previous successful processed message, and ignore this last failure.", cause.getMessage(), cause).                     } else {                         // rollback all by throwning exception                         throw cause.                     }                 }                 // commit                 log.debug("Flushing EntityManager").                 entityManager.flush().                 // must clear after flush                 entityManager.clear().                 return messagePolled.             }         }).     } catch (Exception e) {         // Potentially EntityManager could be in an inconsistent state after transaction rollback,         // so disposing it to have it recreated in next poll. cf. Java Persistence API 3.3.2 Transaction Rollback         log.debug("Disposing EntityManager {} on {} due to coming transaction rollback", entityManager, this).         entityManager.close().         entityManager = null.         throw new PersistenceException(e).     }     return getEndpoint().getCamelContext().getTypeConverter().convertTo(int.class, messagePolled). }
false;public;1;42;;public int processBatch(Queue<Object> exchanges) throws Exception {     int total = exchanges.size().     // limit if needed     if (maxMessagesPerPoll > 0 && total > maxMessagesPerPoll) {         log.debug("Limiting to maximum messages to poll " + maxMessagesPerPoll + " as there were " + total + " messages in this poll.").         total = maxMessagesPerPoll.     }     for (int index = 0. index < total && isBatchAllowed(). index++) {         // only loop if we are started (allowed to run)         DataHolder holder = org.apache.camel.util.ObjectHelper.cast(DataHolder.class, exchanges.poll()).         EntityManager entityManager = holder.manager.         Exchange exchange = holder.exchange.         Object result = holder.result.         // add current index and total as properties         exchange.setProperty(Exchange.BATCH_INDEX, index).         exchange.setProperty(Exchange.BATCH_SIZE, total).         exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1).         // update pending number of exchanges         pendingExchanges = total - index - 1.         if (lockEntity(result, entityManager)) {             // Run the @PreConsumed callback             createPreDeleteHandler().deleteObject(entityManager, result, exchange).             // process the current exchange             log.debug("Processing exchange: {}", exchange).             getProcessor().process(exchange).             if (exchange.getException() != null) {                 // if we failed then throw exception                 throw exchange.getException().             }             // Run the @Consumed callback             getDeleteHandler().deleteObject(entityManager, result, exchange).         }     }     return total. }
true;public;0;4;// ------------------------------------------------------------------------- ;// Properties // ------------------------------------------------------------------------- @Override public JpaEndpoint getEndpoint() {     return (JpaEndpoint) super.getEndpoint(). }
false;public;0;9;;public QueryFactory getQueryFactory() {     if (queryFactory == null) {         queryFactory = createQueryFactory().         if (queryFactory == null) {             throw new IllegalArgumentException("No queryType property configured on this consumer, nor an entityType configured on the endpoint so cannot consume").         }     }     return queryFactory. }
false;public;1;3;;public void setQueryFactory(QueryFactory queryFactory) {     this.queryFactory = queryFactory. }
false;public;0;6;;public DeleteHandler<Object> getDeleteHandler() {     if (deleteHandler == null) {         deleteHandler = createDeleteHandler().     }     return deleteHandler. }
false;public;1;3;;public void setDeleteHandler(DeleteHandler<Object> deleteHandler) {     this.deleteHandler = deleteHandler. }
false;public;0;6;;public DeleteHandler<Object> getPreDeleteHandler() {     if (preDeleteHandler == null) {         preDeleteHandler = createPreDeleteHandler().     }     return preDeleteHandler. }
false;public;1;3;;public void setPreDeleteHandler(DeleteHandler<Object> preDeleteHandler) {     this.preDeleteHandler = preDeleteHandler. }
false;public;1;3;;public void setParameters(Map<String, Object> params) {     this.parameters = params. }
false;public;0;3;;public Map<String, Object> getParameters() {     return parameters. }
false;public;0;3;;public String getNamedQuery() {     return namedQuery. }
false;public;1;3;;public void setNamedQuery(String namedQuery) {     this.namedQuery = namedQuery. }
false;public;0;3;;public LockModeType getLockModeType() {     return lockModeType. }
false;public;1;3;;public void setLockModeType(LockModeType lockModeType) {     this.lockModeType = lockModeType. }
false;public;0;3;;public String getNativeQuery() {     return nativeQuery. }
false;public;1;3;;public void setNativeQuery(String nativeQuery) {     this.nativeQuery = nativeQuery. }
false;public;0;3;;public String getQuery() {     return query. }
false;public;1;3;;public void setQuery(String query) {     this.query = query. }
false;public;0;3;;public Class<?> getResultClass() {     return resultClass. }
false;public;1;3;;public void setResultClass(Class<?> resultClass) {     this.resultClass = resultClass. }
false;public;0;3;;public boolean isTransacted() {     return transacted. }
true;public;1;3;/**  * Sets whether to run in transacted mode or not.  * <p/>  * This option is default <tt>false</tt>. When <tt>false</tt> then all the good messages  * will commit, and the first failed message will rollback.  * However when <tt>true</tt>, then all messages will rollback, if just one message failed.  */ ;/**  * Sets whether to run in transacted mode or not.  * <p/>  * This option is default <tt>false</tt>. When <tt>false</tt> then all the good messages  * will commit, and the first failed message will rollback.  * However when <tt>true</tt>, then all messages will rollback, if just one message failed.  */ public void setTransacted(boolean transacted) {     this.transacted = transacted. }
true;public;1;3;/**  * Sets whether to use NOWAIT on lock and silently skip the entity. This  * allows different instances to process entities at the same time but not  * processing the same entity.  */ ;/**  * Sets whether to use NOWAIT on lock and silently skip the entity. This  * allows different instances to process entities at the same time but not  * processing the same entity.  */ public void setSkipLockedEntity(boolean skipLockedEntity) {     this.skipLockedEntity = skipLockedEntity. }
false;public;0;3;;public boolean isSkipLockedEntity() {     return skipLockedEntity. }
true;protected;2;28;/**  * A strategy method to lock an object with an exclusive lock so that it can  * be processed  *  * @param entity the entity to be locked  * @param entityManager entity manager  * @return true if the entity was locked  */ ;// Implementation methods // ------------------------------------------------------------------------- /**  * A strategy method to lock an object with an exclusive lock so that it can  * be processed  *  * @param entity the entity to be locked  * @param entityManager entity manager  * @return true if the entity was locked  */ protected boolean lockEntity(Object entity, EntityManager entityManager) {     if (!getEndpoint().isConsumeLockEntity()) {         return true.     }     try {         log.debug("Acquiring exclusive lock on entity: {}", entity).         if (isSkipLockedEntity()) {             entityManager.lock(entity, lockModeType, NOWAIT).         } else {             entityManager.lock(entity, lockModeType).         }         return true.     } catch (Exception e) {         if (log.isDebugEnabled()) {             log.debug("Failed to achieve lock on entity: " + entity + ". Reason: " + e, e).         }         if (e instanceof PessimisticLockException || e instanceof OptimisticLockException) {             // transaction marked as rollback can't continue gracefully             throw (PersistenceException) e.         }         // Result of native queries are Arrays and cannot be locked by all JPA Providers.         if (entity.getClass().isArray()) {             return true.         }         return false.     } }
false;protected;0;28;;protected QueryFactory createQueryFactory() {     if (query != null) {         return QueryBuilder.query(query).     } else if (namedQuery != null) {         return QueryBuilder.namedQuery(namedQuery).     } else if (nativeQuery != null) {         if (resultClass != null) {             return QueryBuilder.nativeQuery(nativeQuery, resultClass).         } else {             return QueryBuilder.nativeQuery(nativeQuery).         }     } else {         Class<?> entityType = getEndpoint().getEntityType().         if (entityType == null) {             return null.         } else {             // Check if we have a property name on the @Entity annotation             String name = getEntityName(entityType).             if (name != null) {                 return QueryBuilder.query("select x from " + name + " x").             } else {                 // Remove package name of the entity to be conform with JPA 1.0 spec                 return QueryBuilder.query("select x from " + entityType.getSimpleName() + " x").             }         }     } }
false;protected;1;10;;protected String getEntityName(Class<?> clazz) {     Entity entity = clazz.getAnnotation(Entity.class).     // Check if the property name has been defined for Entity annotation     if (entity != null && !entity.name().equals("")) {         return entity.name().     } else {         return null.     } }
false;public;3;11;;@Override public void deleteObject(EntityManager entityManager, Object entityBean, Exchange exchange) {     // The entityBean could be an Object array     if (entityType.isInstance(entityBean)) {         if (useExchangeParameter) {             ObjectHelper.invokeMethod(method, entityBean, exchange).         } else {             ObjectHelper.invokeMethod(method, entityBean).         }     } }
false;public;3;4;;@Override public void deleteObject(EntityManager entityManager, Object entityBean, Exchange exchange) { // Do nothing }
false;protected;0;36;;protected DeleteHandler<Object> createPreDeleteHandler() {     // Look for @PreConsumed to allow custom callback before the Entity has been consumed     final Class<?> entityType = getEndpoint().getEntityType().     if (entityType != null) {         // Inspect the method(s) annotated with @PreConsumed         List<Method> methods = org.apache.camel.util.ObjectHelper.findMethodsWithAnnotation(entityType, PreConsumed.class).         if (methods.size() > 1) {             throw new IllegalStateException("Only one method can be annotated with the @PreConsumed annotation but found: " + methods).         } else if (methods.size() == 1) {             // Inspect the parameters of the @PreConsumed method             final Method method = methods.get(0).             final boolean useExchangeParameter = checkParameters(method).             return new DeleteHandler<Object>() {                  @Override                 public void deleteObject(EntityManager entityManager, Object entityBean, Exchange exchange) {                     // The entityBean could be an Object array                     if (entityType.isInstance(entityBean)) {                         if (useExchangeParameter) {                             ObjectHelper.invokeMethod(method, entityBean, exchange).                         } else {                             ObjectHelper.invokeMethod(method, entityBean).                         }                     }                 }             }.         }     }     // else do nothing     return new DeleteHandler<Object>() {          @Override         public void deleteObject(EntityManager entityManager, Object entityBean, Exchange exchange) {         // Do nothing         }     }. }
false;public;3;9;;public void deleteObject(EntityManager entityManager, Object entityBean, Exchange exchange) {     if (entityType.isInstance(entityBean)) {         if (useExchangeParameter) {             ObjectHelper.invokeMethod(method, entityBean, exchange).         } else {             ObjectHelper.invokeMethod(method, entityBean).         }     } }
false;public;3;3;;public void deleteObject(EntityManager entityManager, Object entityBean, Exchange exchange) { // do nothing }
false;public;3;3;;public void deleteObject(EntityManager entityManager, Object entityBean, Exchange exchange) {     entityManager.remove(entityBean). }
false;protected;0;37;;protected DeleteHandler<Object> createDeleteHandler() {     // look for @Consumed to allow custom callback when the Entity has been consumed     final Class<?> entityType = getEndpoint().getEntityType().     if (entityType != null) {         List<Method> methods = org.apache.camel.util.ObjectHelper.findMethodsWithAnnotation(entityType, Consumed.class).         if (methods.size() > 1) {             throw new IllegalArgumentException("Only one method can be annotated with the @Consumed annotation but found: " + methods).         } else if (methods.size() == 1) {             final Method method = methods.get(0).             final boolean useExchangeParameter = checkParameters(method).             return new DeleteHandler<Object>() {                  public void deleteObject(EntityManager entityManager, Object entityBean, Exchange exchange) {                     if (entityType.isInstance(entityBean)) {                         if (useExchangeParameter) {                             ObjectHelper.invokeMethod(method, entityBean, exchange).                         } else {                             ObjectHelper.invokeMethod(method, entityBean).                         }                     }                 }             }.         }     }     if (getEndpoint().isConsumeDelete()) {         return new DeleteHandler<Object>() {              public void deleteObject(EntityManager entityManager, Object entityBean, Exchange exchange) {                 entityManager.remove(entityBean).             }         }.     } else {         return new DeleteHandler<Object>() {              public void deleteObject(EntityManager entityManager, Object entityBean, Exchange exchange) {             // do nothing             }         }.     } }
false;protected;1;11;;protected boolean checkParameters(Method method) {     boolean result = false.     Class<?>[] parameters = method.getParameterTypes().     if (parameters.length == 1 && parameters[0].isAssignableFrom(Exchange.class)) {         result = true.     }     if (parameters.length > 0 && !result) {         throw new IllegalStateException("@PreConsumed annotated method cannot have parameter other than Exchange").     }     return result. }
false;protected;1;12;;protected void configureParameters(Query query) {     int maxResults = getEndpoint().getMaximumResults().     if (maxResults > 0) {         query.setMaxResults(maxResults).     }     // setup the parameter     if (parameters != null) {         for (Entry<String, Object> entry : parameters.entrySet()) {             query.setParameter(entry.getKey(), entry.getValue()).         }     } }
false;protected;2;6;;protected Exchange createExchange(Object result, EntityManager entityManager) {     Exchange exchange = getEndpoint().createExchange().     exchange.getIn().setBody(result).     exchange.getIn().setHeader(JpaConstants.ENTITY_MANAGER, entityManager).     return exchange. }
false;protected;0;12;;@Override protected void doStart() throws Exception {     // need to setup entity manager first     if (getEndpoint().isSharedEntityManager()) {         this.entityManager = SharedEntityManagerCreator.createSharedEntityManager(entityManagerFactory).     } else {         this.entityManager = entityManagerFactory.createEntityManager().     }     log.trace("Created EntityManager {} on {}", entityManager, this).     super.doStart(). }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
false;protected;0;9;;@Override protected void doShutdown() throws Exception {     if (entityManager != null) {         this.entityManager.close().         log.trace("Closed EntityManager {} on {}", entityManager, this).     }     super.doShutdown(). }
