commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public JpaComponent getComponent() {     return (JpaComponent) super.getComponent(). }
false;public;0;11;;public Producer createProducer() throws Exception {     validate().     JpaProducer producer = new JpaProducer(this, getProducerExpression()).     producer.setQuery(getQuery()).     producer.setNamedQuery(getNamedQuery()).     producer.setNativeQuery(getNativeQuery()).     producer.setParameters(getParameters()).     producer.setResultClass(getResultClass()).     producer.setUseExecuteUpdate(isUseExecuteUpdate()).     return producer. }
false;public;1;17;;public Consumer createConsumer(Processor processor) throws Exception {     validate().     JpaConsumer consumer = new JpaConsumer(this, processor).     consumer.setMaxMessagesPerPoll(getMaxMessagesPerPoll()).     consumer.setQuery(getQuery()).     consumer.setNamedQuery(getNamedQuery()).     consumer.setNativeQuery(getNativeQuery()).     consumer.setLockModeType(getLockModeType()).     consumer.setParameters(getParameters()).     consumer.setResultClass(getResultClass()).     consumer.setTransacted(isTransacted()).     consumer.setSkipLockedEntity(isSkipLockedEntity()).     consumer.setDeleteHandler(getDeleteHandler()).     consumer.setPreDeleteHandler(getPreDeleteHandler()).     configureConsumer(consumer).     return consumer. }
false;public;0;11;;@Override public PollingConsumer createPollingConsumer() throws Exception {     JpaPollingConsumer consumer = new JpaPollingConsumer(this).     consumer.setQuery(getQuery()).     consumer.setNamedQuery(getNamedQuery()).     consumer.setNativeQuery(getNativeQuery()).     consumer.setLockModeType(getLockModeType()).     consumer.setParameters(getParameters()).     consumer.setResultClass(getResultClass()).     return consumer. }
false;public;1;8;;@Override public void configureProperties(Map<String, Object> options) {     super.configureProperties(options).     Map<String, Object> emProperties = IntrospectionSupport.extractProperties(options, "emf.").     if (emProperties != null) {         setEntityManagerProperties(emProperties).     } }
false;public;0;3;;public boolean isSingleton() {     return true. }
false;protected;0;4;;@Override protected String createEndpointUri() {     return "jpa" + (entityType != null ? "://" + entityType.getName() : ""). }
true;public;0;6;// ------------------------------------------------------------------------- ;// Properties // ------------------------------------------------------------------------- public Expression getProducerExpression() {     if (producerExpression == null) {         producerExpression = createProducerExpression().     }     return producerExpression. }
false;public;1;3;;public void setProducerExpression(Expression producerExpression) {     this.producerExpression = producerExpression. }
false;public;0;3;;public int getMaximumResults() {     return maximumResults. }
true;public;1;3;/**  * Set the maximum number of results to retrieve on the Query.  */ ;/**  * Set the maximum number of results to retrieve on the Query.  */ public void setMaximumResults(int maximumResults) {     this.maximumResults = maximumResults. }
false;public;0;3;;public Class<?> getEntityType() {     return entityType. }
true;public;1;3;/**  * The JPA annotated class to use as entity.  */ ;/**  * The JPA annotated class to use as entity.  */ public void setEntityType(Class<?> entityType) {     this.entityType = entityType. }
false;public;0;6;;public EntityManagerFactory getEntityManagerFactory() {     if (entityManagerFactory == null) {         entityManagerFactory = createEntityManagerFactory().     }     return entityManagerFactory. }
true;public;1;3;/**  * The {@link EntityManagerFactory} to use.  */ ;/**  * The {@link EntityManagerFactory} to use.  */ public void setEntityManagerFactory(EntityManagerFactory entityManagerFactory) {     this.entityManagerFactory = entityManagerFactory. }
false;public;0;6;;public PlatformTransactionManager getTransactionManager() {     if (transactionManager == null) {         transactionManager = createTransactionManager().     }     return transactionManager. }
true;public;1;3;/**  * To use the {@link PlatformTransactionManager} for managing transactions.  */ ;/**  * To use the {@link PlatformTransactionManager} for managing transactions.  */ public void setTransactionManager(PlatformTransactionManager transactionManager) {     this.transactionManager = transactionManager. }
true;public;0;6;/**  * Additional properties for the entity manager to use.  */ ;/**  * Additional properties for the entity manager to use.  */ public Map<String, Object> getEntityManagerProperties() {     if (entityManagerProperties == null) {         entityManagerProperties = CastUtils.cast(System.getProperties()).     }     return entityManagerProperties. }
false;public;1;3;;public void setEntityManagerProperties(Map<String, Object> entityManagerProperties) {     this.entityManagerProperties = entityManagerProperties. }
false;public;0;3;;public String getPersistenceUnit() {     return persistenceUnit. }
true;public;1;3;/**  * The JPA persistence unit used by default.  */ ;/**  * The JPA persistence unit used by default.  */ public void setPersistenceUnit(String persistenceUnit) {     this.persistenceUnit = persistenceUnit. }
false;public;0;3;;public boolean isConsumeDelete() {     return consumeDelete. }
true;public;1;3;/**  * If true, the entity is deleted after it is consumed. if false, the entity is not deleted.  */ ;/**  * If true, the entity is deleted after it is consumed. if false, the entity is not deleted.  */ public void setConsumeDelete(boolean consumeDelete) {     this.consumeDelete = consumeDelete. }
false;public;0;3;;public boolean isConsumeLockEntity() {     return consumeLockEntity. }
true;public;1;3;/**  * Specifies whether or not to set an exclusive lock on each entity bean while processing the results from polling.  */ ;/**  * Specifies whether or not to set an exclusive lock on each entity bean while processing the results from polling.  */ public void setConsumeLockEntity(boolean consumeLockEntity) {     this.consumeLockEntity = consumeLockEntity. }
false;public;0;3;;public boolean isFlushOnSend() {     return flushOnSend. }
true;public;1;3;/**  * Flushes the EntityManager after the entity bean has been persisted.  */ ;/**  * Flushes the EntityManager after the entity bean has been persisted.  */ public void setFlushOnSend(boolean flushOnSend) {     this.flushOnSend = flushOnSend. }
false;public;0;3;;public int getMaxMessagesPerPoll() {     return maxMessagesPerPoll. }
true;public;1;3;/**  * An integer value to define the maximum number of messages to gather per poll.  * By default, no maximum is set. Can be used to avoid polling many thousands of messages when starting up the server.  * Set a value of 0 or negative to disable.  */ ;/**  * An integer value to define the maximum number of messages to gather per poll.  * By default, no maximum is set. Can be used to avoid polling many thousands of messages when starting up the server.  * Set a value of 0 or negative to disable.  */ public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {     this.maxMessagesPerPoll = maxMessagesPerPoll. }
false;public;0;3;;public boolean isUsePersist() {     return usePersist. }
true;public;1;3;/**  * Indicates to use entityManager.persist(entity) instead of entityManager.merge(entity).  * Note: entityManager.persist(entity) doesn't work for detached entities  * (where the EntityManager has to execute an UPDATE instead of an INSERT query)!  */ ;/**  * Indicates to use entityManager.persist(entity) instead of entityManager.merge(entity).  * Note: entityManager.persist(entity) doesn't work for detached entities  * (where the EntityManager has to execute an UPDATE instead of an INSERT query)!  */ public void setUsePersist(boolean usePersist) {     this.usePersist = usePersist. }
false;public;0;3;;public boolean isRemove() {     return remove. }
true;public;1;3;/**  * Indicates to use entityManager.remove(entity).  */ ;/**  * Indicates to use entityManager.remove(entity).  */ public void setRemove(boolean isRemove) {     this.remove = isRemove. }
false;public;0;3;;public boolean isJoinTransaction() {     return joinTransaction. }
true;public;1;3;/**  * The camel-jpa component will join transaction by default.  * You can use this option to turn this off, for example if you use LOCAL_RESOURCE and join transaction  * doesn't work with your JPA provider. This option can also be set globally on the JpaComponent,  * instead of having to set it on all endpoints.  */ ;/**  * The camel-jpa component will join transaction by default.  * You can use this option to turn this off, for example if you use LOCAL_RESOURCE and join transaction  * doesn't work with your JPA provider. This option can also be set globally on the JpaComponent,  * instead of having to set it on all endpoints.  */ public void setJoinTransaction(boolean joinTransaction) {     this.joinTransaction = joinTransaction. }
false;public;0;3;;public boolean isUsePassedInEntityManager() {     return this.usePassedInEntityManager. }
true;public;1;3;/**  * If set to true, then Camel will use the EntityManager from the header  * JpaConstants.ENTITY_MANAGER instead of the configured entity manager on the component/endpoint.  * This allows end users to control which entity manager will be in use.  */ ;/**  * If set to true, then Camel will use the EntityManager from the header  * JpaConstants.ENTITY_MANAGER instead of the configured entity manager on the component/endpoint.  * This allows end users to control which entity manager will be in use.  */ public void setUsePassedInEntityManager(boolean usePassedIn) {     this.usePassedInEntityManager = usePassedIn. }
false;public;0;3;;public boolean isSharedEntityManager() {     return sharedEntityManager. }
true;public;1;3;/**  * Whether to use Spring's SharedEntityManager for the consumer/producer.  * Note in most cases joinTransaction should be set to false as this is not an EXTENDED EntityManager.  */ ;/**  * Whether to use Spring's SharedEntityManager for the consumer/producer.  * Note in most cases joinTransaction should be set to false as this is not an EXTENDED EntityManager.  */ public void setSharedEntityManager(boolean sharedEntityManager) {     this.sharedEntityManager = sharedEntityManager. }
false;public;0;3;;public String getQuery() {     return query. }
true;public;1;3;/**  * To use a custom query.  */ ;/**  * To use a custom query.  */ public void setQuery(String query) {     this.query = query. }
false;public;0;3;;public String getNamedQuery() {     return namedQuery. }
true;public;1;3;/**  * To use a named query.  */ ;/**  * To use a named query.  */ public void setNamedQuery(String namedQuery) {     this.namedQuery = namedQuery. }
false;public;0;3;;public String getNativeQuery() {     return nativeQuery. }
true;public;1;3;/**  * To use a custom native query. You may want to use the option resultClass also when using native queries.  */ ;/**  * To use a custom native query. You may want to use the option resultClass also when using native queries.  */ public void setNativeQuery(String nativeQuery) {     this.nativeQuery = nativeQuery. }
false;public;0;3;;public LockModeType getLockModeType() {     return lockModeType. }
true;public;1;3;/**  * To configure the lock mode on the consumer.  */ ;/**  * To configure the lock mode on the consumer.  */ public void setLockModeType(LockModeType lockModeType) {     this.lockModeType = lockModeType. }
false;public;0;3;;public Map<String, Object> getParameters() {     return parameters. }
true;public;1;3;/**  * <p>This key/value mapping is used for building the query parameters.  * It is expected to be of the generic type java.util.Map<String, Object> where the keys are the named parameters  * of a given JPA query and the values are their corresponding effective values you want to select for.</p>  * <p>When it's used for producer, Simple expression can be used as a parameter value. It allows you to  * retrieve parameter values from the message body, header and etc.</p>  */ ;/**  * <p>This key/value mapping is used for building the query parameters.  * It is expected to be of the generic type java.util.Map<String, Object> where the keys are the named parameters  * of a given JPA query and the values are their corresponding effective values you want to select for.</p>  * <p>When it's used for producer, Simple expression can be used as a parameter value. It allows you to  * retrieve parameter values from the message body, header and etc.</p>  */ public void setParameters(Map<String, Object> parameters) {     this.parameters = parameters. }
false;public;0;3;;public Class<?> getResultClass() {     return resultClass. }
true;public;1;3;/**  * Defines the type of the returned payload (we will call entityManager.createNativeQuery(nativeQuery, resultClass)  * instead of entityManager.createNativeQuery(nativeQuery)). Without this option, we will return an object array.  * Only has an affect when using in conjunction with native query when consuming data.  */ ;/**  * Defines the type of the returned payload (we will call entityManager.createNativeQuery(nativeQuery, resultClass)  * instead of entityManager.createNativeQuery(nativeQuery)). Without this option, we will return an object array.  * Only has an affect when using in conjunction with native query when consuming data.  */ public void setResultClass(Class<?> resultClass) {     this.resultClass = resultClass. }
false;public;0;3;;public boolean isTransacted() {     return transacted. }
true;public;1;3;/**  * Whether to run the consumer in transacted mode, by which all messages will either commit or rollback,  * when the entire batch has been processed. The default behavior (false) is to commit all the previously  * successfully processed messages, and only rollback the last failed message.  */ ;/**  * Whether to run the consumer in transacted mode, by which all messages will either commit or rollback,  * when the entire batch has been processed. The default behavior (false) is to commit all the previously  * successfully processed messages, and only rollback the last failed message.  */ public void setTransacted(boolean transacted) {     this.transacted = transacted. }
false;public;0;3;;public boolean isSkipLockedEntity() {     return skipLockedEntity. }
true;public;1;3;/**  * To configure whether to use NOWAIT on lock and silently skip the entity.  */ ;/**  * To configure whether to use NOWAIT on lock and silently skip the entity.  */ public void setSkipLockedEntity(boolean skipLockedEntity) {     this.skipLockedEntity = skipLockedEntity. }
false;public;0;3;;public DeleteHandler<Object> getDeleteHandler() {     return deleteHandler. }
true;public;1;3;/**  * To use a custom DeleteHandler to delete the row after the consumer is done processing the exchange  */ ;/**  * To use a custom DeleteHandler to delete the row after the consumer is done processing the exchange  */ public void setDeleteHandler(DeleteHandler<Object> deleteHandler) {     this.deleteHandler = deleteHandler. }
false;public;0;3;;public DeleteHandler<Object> getPreDeleteHandler() {     return preDeleteHandler. }
true;public;1;3;/**  * To use a custom Pre-DeleteHandler to delete the row after the consumer has read the entity.  */ ;/**  * To use a custom Pre-DeleteHandler to delete the row after the consumer has read the entity.  */ public void setPreDeleteHandler(DeleteHandler<Object> preDeleteHandler) {     this.preDeleteHandler = preDeleteHandler. }
false;public;0;3;;public Boolean isUseExecuteUpdate() {     return useExecuteUpdate. }
true;public;1;3;/**  * To configure whether to use executeUpdate() when producer executes a query.  * When you use INSERT, UPDATE or DELETE statement as a named query, you need to specify  * this option to 'true'.  */ ;/**  * To configure whether to use executeUpdate() when producer executes a query.  * When you use INSERT, UPDATE or DELETE statement as a named query, you need to specify  * this option to 'true'.  */ public void setUseExecuteUpdate(Boolean useExecuteUpdate) {     this.useExecuteUpdate = useExecuteUpdate. }
false;protected;0;3;;// Implementation methods // ------------------------------------------------------------------------- protected void validate() {     ObjectHelper.notNull(getEntityManagerFactory(), "entityManagerFactory"). }
false;protected;0;7;;protected EntityManagerFactory createEntityManagerFactory() {     LocalEntityManagerFactoryBean emfBean = new LocalEntityManagerFactoryBean().     emfBean.setPersistenceUnitName(persistenceUnit).     emfBean.setJpaPropertyMap(getEntityManagerProperties()).     emfBean.afterPropertiesSet().     return emfBean.getObject(). }
false;protected;0;5;;protected PlatformTransactionManager createTransactionManager() {     JpaTransactionManager tm = new JpaTransactionManager(getEntityManagerFactory()).     tm.afterPropertiesSet().     return tm. }
true;protected;0;8;/**  * @deprecated use {@link #getEntityManagerFactory()} to get hold of factory and create an entity manager using the factory.  */ ;/**  * @deprecated use {@link #getEntityManagerFactory()} to get hold of factory and create an entity manager using the factory.  */ @Deprecated protected EntityManager createEntityManager() {     if (sharedEntityManager) {         return SharedEntityManagerCreator.createSharedEntityManager(getEntityManagerFactory()).     } else {         return getEntityManagerFactory().createEntityManager().     } }
false;protected;0;6;;protected TransactionTemplate createTransactionTemplate() {     TransactionTemplate transactionTemplate = new TransactionTemplate(getTransactionManager()).     transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED).     transactionTemplate.afterPropertiesSet().     return transactionTemplate. }
false;public;1;16;;public Object evaluate(Exchange exchange) {     Object answer.     // must have a body     try {         if (getEntityType() == null) {             answer = exchange.getIn().getMandatoryBody().         } else {             answer = exchange.getIn().getMandatoryBody(getEntityType()).         }     } catch (InvalidPayloadException e) {         throw new InvalidPayloadRuntimeException(exchange, getEntityType(), e.getCause()).     }     // is never null     return answer. }
false;protected;0;20;;protected Expression createProducerExpression() {     return new ExpressionAdapter() {          public Object evaluate(Exchange exchange) {             Object answer.             // must have a body             try {                 if (getEntityType() == null) {                     answer = exchange.getIn().getMandatoryBody().                 } else {                     answer = exchange.getIn().getMandatoryBody(getEntityType()).                 }             } catch (InvalidPayloadException e) {                 throw new InvalidPayloadRuntimeException(exchange, getEntityType(), e.getCause()).             }             // is never null             return answer.         }     }. }
