commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setCompleteEndpointUri(String uri) {     setEndpointUri(uri). }
false;public;0;3;;public boolean isSingleton() {     return true. }
false;public;0;5;;@Override public boolean isLenientProperties() {     // true to allow dynamic URI options to be configured and passed to external system.     return true. }
false;public;0;8;;@Override public Exchange createExchange() {     Exchange exchange = super.createExchange().     if (isDisableStreamCache()) {         exchange.setProperty(Exchange.DISABLE_HTTP_STREAM_CACHE, Boolean.TRUE).     }     return exchange. }
false;public;1;5;;public Consumer createConsumer(Processor processor) throws Exception {     RestletConsumer answer = new RestletConsumer(this, processor).     configureConsumer(answer).     return answer. }
false;public;0;3;;public Producer createProducer() throws Exception {     return new RestletProducer(this). }
false;public;1;3;;public void connect(RestletConsumer restletConsumer) throws Exception {     ((RestletComponent) getComponent()).connect(restletConsumer). }
false;public;1;3;;public void disconnect(RestletConsumer restletConsumer) throws Exception {     ((RestletComponent) getComponent()).disconnect(restletConsumer). }
false;public;0;3;;public Method getRestletMethod() {     return restletMethod. }
true;public;1;3;/**  * On a producer endpoint, specifies the request method to use.  * On a consumer endpoint, specifies that the endpoint consumes only restletMethod requests.  */ ;/**  * On a producer endpoint, specifies the request method to use.  * On a consumer endpoint, specifies that the endpoint consumes only restletMethod requests.  */ public void setRestletMethod(Method restletMethod) {     this.restletMethod = restletMethod. }
false;public;0;3;;public String getProtocol() {     return protocol. }
true;public;1;3;/**  * The protocol to use which is http or https  */ ;/**  * The protocol to use which is http or https  */ public void setProtocol(String protocol) {     this.protocol = protocol. }
false;public;0;3;;public String getHost() {     return host. }
true;public;1;3;/**  * The hostname of the restlet service  */ ;/**  * The hostname of the restlet service  */ public void setHost(String host) {     this.host = host. }
false;public;0;3;;public int getPort() {     return port. }
true;public;1;3;/**  * The port number of the restlet service  */ ;/**  * The port number of the restlet service  */ public void setPort(int port) {     this.port = port. }
false;public;0;3;;public int getSocketTimeout() {     return socketTimeout. }
true;public;1;3;/**  * The Client socket receive timeout, 0 for unlimited wait.  */ ;/**  * The Client socket receive timeout, 0 for unlimited wait.  */ public void setSocketTimeout(int socketTimeout) {     this.socketTimeout = socketTimeout. }
false;public;0;3;;public int getConnectTimeout() {     return connectTimeout. }
true;public;1;3;/**  * The Client will give up connection if the connection is timeout, 0 for unlimited wait.  */ ;/**  * The Client will give up connection if the connection is timeout, 0 for unlimited wait.  */ public void setConnectTimeout(int connectTimeout) {     this.connectTimeout = connectTimeout. }
false;public;0;3;;public String getUriPattern() {     return uriPattern. }
true;public;1;3;/**  * The resource pattern such as /customer/{id}  */ ;/**  * The resource pattern such as /customer/{id}  */ public void setUriPattern(String uriPattern) {     this.uriPattern = uriPattern. }
false;public;0;3;;public RestletBinding getRestletBinding() {     return restletBinding. }
true;public;1;3;/**  * To use a custom RestletBinding to bind between Restlet and Camel message.  */ ;/**  * To use a custom RestletBinding to bind between Restlet and Camel message.  */ public void setRestletBinding(RestletBinding restletBinding) {     this.restletBinding = restletBinding. }
true;public;1;6;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ ;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {     this.headerFilterStrategy = headerFilterStrategy.     if (restletBinding instanceof HeaderFilterStrategyAware) {         ((HeaderFilterStrategyAware) restletBinding).setHeaderFilterStrategy(headerFilterStrategy).     } }
false;public;0;3;;public HeaderFilterStrategy getHeaderFilterStrategy() {     return headerFilterStrategy. }
true;public;1;3;/**  * To configure the security realms of restlet as a map.  */ ;/**  * To configure the security realms of restlet as a map.  */ public void setRestletRealm(Map<String, String> restletRealm) {     this.restletRealm = restletRealm. }
false;public;0;3;;public Map<String, String> getRestletRealm() {     return restletRealm. }
false;public;0;5;;@Override public ExchangePattern getExchangePattern() {     // should always use in out for restlet     return ExchangePattern.InOut. }
true;public;1;3;/**  * Specify one or more methods separated by commas (e.g. restletMethods=post,put) to be serviced by a restlet consumer endpoint.  * If both restletMethod and restletMethods options are specified, the restletMethod setting is ignored.  * The possible methods are: ALL,CONNECT,DELETE,GET,HEAD,OPTIONS,PATCH,POST,PUT,TRACE  */ ;/**  * Specify one or more methods separated by commas (e.g. restletMethods=post,put) to be serviced by a restlet consumer endpoint.  * If both restletMethod and restletMethods options are specified, the restletMethod setting is ignored.  * The possible methods are: ALL,CONNECT,DELETE,GET,HEAD,OPTIONS,PATCH,POST,PUT,TRACE  */ public void setRestletMethods(Method[] restletMethods) {     this.restletMethods = restletMethods. }
false;public;0;3;;public Method[] getRestletMethods() {     return restletMethods. }
false;public;0;3;;public boolean isThrowExceptionOnFailure() {     return throwExceptionOnFailure. }
true;public;1;3;/**  * Whether to throw exception on a producer failure. If this option is false then the http status code is set as a message header which  * can be checked if it has an error value.  */ ;/**  * Whether to throw exception on a producer failure. If this option is false then the http status code is set as a message header which  * can be checked if it has an error value.  */ public void setThrowExceptionOnFailure(boolean throwExceptionOnFailure) {     this.throwExceptionOnFailure = throwExceptionOnFailure. }
false;public;0;3;;public boolean isDisableStreamCache() {     return disableStreamCache. }
true;public;1;3;/**  * Determines whether or not the raw input stream from Restlet is cached or not  * (Camel will read the stream into a in memory/overflow to file, Stream caching) cache.  * By default Camel will cache the Restlet input stream to support reading it multiple times to ensure Camel  * can retrieve all data from the stream. However you can set this option to true when you for example need  * to access the raw stream, such as streaming it directly to a file or other persistent store.  * DefaultRestletBinding will copy the request input stream into a stream cache and put it into message body  * if this option is false to support reading the stream multiple times.  */ ;/**  * Determines whether or not the raw input stream from Restlet is cached or not  * (Camel will read the stream into a in memory/overflow to file, Stream caching) cache.  * By default Camel will cache the Restlet input stream to support reading it multiple times to ensure Camel  * can retrieve all data from the stream. However you can set this option to true when you for example need  * to access the raw stream, such as streaming it directly to a file or other persistent store.  * DefaultRestletBinding will copy the request input stream into a stream cache and put it into message body  * if this option is false to support reading the stream multiple times.  */ public void setDisableStreamCache(boolean disableStreamCache) {     this.disableStreamCache = disableStreamCache. }
false;public;0;3;;public SSLContextParameters getSslContextParameters() {     return sslContextParameters. }
true;public;1;3;/**  * To configure security using SSLContextParameters.  */ ;/**  * To configure security using SSLContextParameters.  */ public void setSslContextParameters(SSLContextParameters scp) {     this.sslContextParameters = scp. }
false;public;0;3;;public boolean isStreamRepresentation() {     return streamRepresentation. }
true;public;1;3;/**  * Whether to support stream representation as response from calling a REST service using the restlet producer.  * If the response is streaming then this option can be enabled to use an {@link java.io.InputStream} as the  * message body on the Camel {@link Message} body. If using this option you may want to enable the  * autoCloseStream option as well to ensure the input stream is closed when the Camel {@link Exchange}  * is done being routed. However if you need to read the stream outside a Camel route, you may need  * to not auto close the stream.  */ ;/**  * Whether to support stream representation as response from calling a REST service using the restlet producer.  * If the response is streaming then this option can be enabled to use an {@link java.io.InputStream} as the  * message body on the Camel {@link Message} body. If using this option you may want to enable the  * autoCloseStream option as well to ensure the input stream is closed when the Camel {@link Exchange}  * is done being routed. However if you need to read the stream outside a Camel route, you may need  * to not auto close the stream.  */ public void setStreamRepresentation(boolean streamRepresentation) {     this.streamRepresentation = streamRepresentation. }
false;public;0;3;;public boolean isAutoCloseStream() {     return autoCloseStream. }
true;public;1;3;/**  * Whether to auto close the stream representation as response from calling a REST service using the restlet producer.  * If the response is streaming and the option streamRepresentation is enabled then you may want to auto close  * the {@link InputStream} from the streaming response to ensure the input stream is closed when the Camel {@link Exchange}  * is done being routed. However if you need to read the stream outside a Camel route, you may need  * to not auto close the stream.  */ ;/**  * Whether to auto close the stream representation as response from calling a REST service using the restlet producer.  * If the response is streaming and the option streamRepresentation is enabled then you may want to auto close  * the {@link InputStream} from the streaming response to ensure the input stream is closed when the Camel {@link Exchange}  * is done being routed. However if you need to read the stream outside a Camel route, you may need  * to not auto close the stream.  */ public void setAutoCloseStream(boolean autoCloseStream) {     this.autoCloseStream = autoCloseStream. }
false;public;0;3;;public CookieHandler getCookieHandler() {     return cookieHandler. }
true;public;1;3;/**  * Configure a cookie handler to maintain a HTTP session  */ ;/**  * Configure a cookie handler to maintain a HTTP session  */ public void setCookieHandler(CookieHandler cookieHandler) {     this.cookieHandler = cookieHandler. }
false;public;0;3;;public Map<String, Object> getQueryParameters() {     return queryParameters. }
true;public;1;3;/**  * Additional query parameters for producer  */ ;/**  * Additional query parameters for producer  */ public void setQueryParameters(Map<String, Object> queryParameters) {     this.queryParameters = queryParameters. }
false;protected;0;16;;@Override protected void doStart() throws Exception {     if (headerFilterStrategy == null) {         headerFilterStrategy = new RestletHeaderFilterStrategy().     }     if (restletBinding == null) {         restletBinding = new DefaultRestletBinding().     }     if (restletBinding instanceof HeaderFilterStrategyAware) {         ((HeaderFilterStrategyAware) restletBinding).setHeaderFilterStrategy(getHeaderFilterStrategy()).     }     if (restletBinding instanceof DefaultRestletBinding) {         ((DefaultRestletBinding) restletBinding).setStreamRepresentation(isStreamRepresentation()).         ((DefaultRestletBinding) restletBinding).setAutoCloseStream(isAutoCloseStream()).     } }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
