commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void init(Series<Parameter> parameters) { // nop }
false;public;0;4;;@Override public SSLContext createSslContext() throws Exception {     return sslContext. }
false;public;0;5;;@Override public void doStart() throws Exception {     super.doStart().     client.start(). }
false;public;0;5;;@Override public void doStop() throws Exception {     client.stop().     super.doStop(). }
false;public;1;25;;@Override public void process(Exchange exchange) throws Exception {     RestletEndpoint endpoint = (RestletEndpoint) getEndpoint().     final RestletBinding binding = endpoint.getRestletBinding().     Request request.     String resourceUri = buildUri(endpoint, exchange).     URI uri = new URI(resourceUri).     request = new Request(endpoint.getRestletMethod(), resourceUri).     binding.populateRestletRequestFromExchange(request, exchange).     loadCookies(exchange, uri, request).     log.debug("Sending request synchronously: {} for exchangeId: {}", request, exchange.getExchangeId()).     Response response = client.handle(request).     log.debug("Received response synchronously: {} for exchangeId: {}", response, exchange.getExchangeId()).     if (response != null) {         Integer respCode = response.getStatus().getCode().         storeCookies(exchange, uri, response).         if (respCode > 207 && throwException) {             exchange.setException(populateRestletProducerException(exchange, response, respCode)).         } else {             binding.populateExchangeFromRestletResponse(exchange, response).         }     } }
false;private;3;17;;private void storeCookies(Exchange exchange, URI uri, Response response) {     RestletEndpoint endpoint = (RestletEndpoint) getEndpoint().     if (endpoint.getCookieHandler() != null) {         Series<CookieSetting> cookieSettings = response.getCookieSettings().         CookieStore cookieJar = endpoint.getCookieHandler().getCookieStore(exchange).         for (CookieSetting s : cookieSettings) {             HttpCookie cookie = new HttpCookie(s.getName(), s.getValue()).             cookie.setComment(s.getComment()).             cookie.setDomain(s.getDomain()).             cookie.setMaxAge(s.getMaxAge()).             cookie.setPath(s.getPath()).             cookie.setSecure(s.isSecure()).             cookie.setVersion(s.getVersion()).             cookieJar.add(uri, cookie).         }     } }
false;private;3;15;;private void loadCookies(Exchange exchange, URI uri, Request request) throws IOException {     RestletEndpoint endpoint = (RestletEndpoint) getEndpoint().     if (endpoint.getCookieHandler() != null) {         Series<Cookie> cookies = request.getCookies().         Map<String, List<String>> cookieHeaders = endpoint.getCookieHandler().loadCookies(exchange, uri).         // parse the cookies         for (String cookieHeader : cookieHeaders.keySet()) {             for (String cookieStr : cookieHeaders.get(cookieHeader)) {                 for (HttpCookie cookie : HttpCookie.parse(cookieStr)) {                     cookies.add(new Cookie(cookie.getVersion(), cookie.getName(), cookie.getValue(), cookie.getPath(), cookie.getDomain())).                 }             }         }     } }
false;public;2;21;;@Override public void handle(Request request, Response response) {     log.debug("Received response asynchronously: {} for exchangeId: {}", response, exchange.getExchangeId()).     try {         if (response != null) {             String resourceUri = buildUri(endpoint, exchange).             URI uri = new URI(resourceUri).             Integer respCode = response.getStatus().getCode().             storeCookies(exchange, uri, response).             if (respCode > 207 && throwException) {                 exchange.setException(populateRestletProducerException(exchange, response, respCode)).             } else {                 binding.populateExchangeFromRestletResponse(exchange, response).             }         }     } catch (Throwable e) {         exchange.setException(e).     } finally {         callback.done(false).     } }
false;public;2;61;;@Override public boolean process(final Exchange exchange, final AsyncCallback callback) {     RestletEndpoint endpoint = (RestletEndpoint) getEndpoint().     // force processing synchronously using different api     if (endpoint.isSynchronous()) {         try {             process(exchange).         } catch (Throwable e) {             exchange.setException(e).         }         callback.done(true).         return true.     }     log.trace("Processing asynchronously").     final RestletBinding binding = endpoint.getRestletBinding().     Request request.     try {         String resourceUri = buildUri(endpoint, exchange).         URI uri = new URI(resourceUri).         request = new Request(endpoint.getRestletMethod(), resourceUri).         binding.populateRestletRequestFromExchange(request, exchange).         loadCookies(exchange, uri, request).     } catch (Throwable e) {         // break out in case of exception         exchange.setException(e).         callback.done(true).         return true.     }     // process the request asynchronously     log.debug("Sending request asynchronously: {} for exchangeId: {}", request, exchange.getExchangeId()).     client.handle(request, new Uniform() {          @Override         public void handle(Request request, Response response) {             log.debug("Received response asynchronously: {} for exchangeId: {}", response, exchange.getExchangeId()).             try {                 if (response != null) {                     String resourceUri = buildUri(endpoint, exchange).                     URI uri = new URI(resourceUri).                     Integer respCode = response.getStatus().getCode().                     storeCookies(exchange, uri, response).                     if (respCode > 207 && throwException) {                         exchange.setException(populateRestletProducerException(exchange, response, respCode)).                     } else {                         binding.populateExchangeFromRestletResponse(exchange, response).                     }                 }             } catch (Throwable e) {                 exchange.setException(e).             } finally {                 callback.done(false).             }         }     }).     // we continue routing async     return false. }
false;private;2;46;;private String buildUri(RestletEndpoint endpoint, Exchange exchange) throws Exception {     // rest producer may provide an override url to be used which we should discard if using (hence the remove)     String uri = (String) exchange.getIn().removeHeader(Exchange.REST_HTTP_URI).     if (uri == null) {         uri = endpoint.getProtocol() + "://" + endpoint.getHost() + ":" + endpoint.getPort() + endpoint.getUriPattern().     }     // substitute { } placeholders in uri and use mandatory headers     log.trace("Substituting '{value}' placeholders in uri: {}", uri).     Matcher matcher = PATTERN.matcher(uri).     while (matcher.find()) {         String key = matcher.group(1).         String header = exchange.getIn().getHeader(key, String.class).         // header should be mandatory         if (header == null) {             throw new CamelExchangeException("Header with key: " + key + " not found in Exchange", exchange).         }         if (log.isTraceEnabled()) {             log.trace("Replacing: {} with header value: {}", matcher.group(0), header).         }         uri = matcher.replaceFirst(header).         // we replaced uri so reset and go again         matcher.reset(uri).     }     // include any query parameters if needed     if (endpoint.getQueryParameters() != null) {         uri = URISupport.appendParametersToURI(uri, endpoint.getQueryParameters()).     }     // rest producer may provide an override query string to be used which we should discard if using (hence the remove)     String query = (String) exchange.getIn().removeHeader(Exchange.REST_HTTP_QUERY).     if (query == null) {         query = exchange.getIn().getHeader(Exchange.HTTP_QUERY, String.class).     }     if (query != null) {         log.trace("Adding query: {} to uri: {}", query, uri).         uri = addQueryToUri(uri, query).     }     log.trace("Using uri: {}", uri).     return uri. }
false;protected,static;2;24;;protected static String addQueryToUri(String uri, String query) {     if (uri == null || uri.length() == 0) {         return uri.     }     StringBuilder answer = new StringBuilder().     int index = uri.indexOf('?').     if (index < 0) {         answer.append(uri).         answer.append("?").         answer.append(query).     } else {         answer.append(uri.substring(0, index)).         answer.append("?").         answer.append(query).         String remaining = uri.substring(index + 1).         if (remaining.length() > 0) {             answer.append("&").             answer.append(remaining).         }     }     return answer.toString(). }
false;protected;3;31;;protected RestletOperationException populateRestletProducerException(Exchange exchange, Response response, int responseCode) {     RestletOperationException exception.     String uri = response.getRequest().getResourceRef().toString().     String statusText = response.getStatus().getDescription().     Map<String, String> headers = parseResponseHeaders(response, exchange).     String copy.     if (response.getEntity() != null) {         try {             copy = response.getEntity().getText().         } catch (Exception ex) {             copy = ex.toString().         }     } else {         copy = response.toString().     }     if (responseCode >= 300 && responseCode < 400) {         String redirectLocation.         if (response.getStatus().isRedirection()) {             redirectLocation = response.getLocationRef().getHostIdentifier().             exception = new RestletOperationException(uri, responseCode, statusText, redirectLocation, headers, copy).         } else {             // no redirect location             exception = new RestletOperationException(uri, responseCode, statusText, null, headers, copy).         }     } else {         // internal server error(error code 500)         exception = new RestletOperationException(uri, responseCode, statusText, null, headers, copy).     }     return exception. }
false;protected;2;14;;protected Map<String, String> parseResponseHeaders(Object response, Exchange camelExchange) {     Map<String, String> answer = new HashMap<>().     if (response instanceof Response) {         for (Map.Entry<String, Object> entry : ((Response) response).getAttributes().entrySet()) {             String key = entry.getKey().             Object value = entry.getValue().             log.trace("Parse external header {}={}", key, value).             answer.put(key, value.toString()).         }     }     return answer. }
