commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Test public void testRestletProducerInFilterAllowedHeader() throws Exception {     String acceptedHeaderKey = "dontFilter".     MockEndpoint mock = getMockEndpoint("mock:out").     mock.expectedHeaderReceived(acceptedHeaderKey, "any value").     template.requestBodyAndHeader("direct:start", null, acceptedHeaderKey, "any value", String.class).     mock.assertIsSatisfied(). }
false;public;1;6;;public void process(Exchange exchange) throws Exception {     Map<String, Object> headers = exchange.getIn().getHeaders().     for (String key : headers.keySet()) {         assertFalse("Header should have been filtered: " + key, key.startsWith(HEADER_FILTER)).     } }
false;public;0;15;;@Test public void testRestletProducerInFilterNotAllowedHeader() throws Exception {     String notAcceptedHeaderKey = HEADER_FILTER + "ThisHeader".     MockEndpoint mock = getMockEndpoint("mock:out").     mock.whenAnyExchangeReceived(new Processor() {          public void process(Exchange exchange) throws Exception {             Map<String, Object> headers = exchange.getIn().getHeaders().             for (String key : headers.keySet()) {                 assertFalse("Header should have been filtered: " + key, key.startsWith(HEADER_FILTER)).             }         }     }).     template.requestBodyAndHeader("direct:start", null, notAcceptedHeaderKey, "any value", String.class).     mock.assertIsSatisfied(). }
false;public;0;14;;@Override public void configure() throws Exception {     // force synchronous processing using restlet and add filtering     DefaultHeaderFilterStrategy strategy = new DefaultHeaderFilterStrategy().     strategy.setInFilterPattern(HEADER_FILTER + ".*").     strategy.setOutFilterPattern(HEADER_FILTER + ".*").     RestletComponent restlet = context.getComponent("restlet", RestletComponent.class).     restlet.setHeaderFilterStrategy(strategy).     restlet.setSynchronous(true).     from("direct:start").to("restlet:http://localhost:" + portNum + "/users/123/exclude").to("log:reply").     from("restlet:http://localhost:" + portNum + "/users/{id}/{filterExcluded}?restletMethods=GET").to("mock:out"). }
false;protected;0;19;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             // force synchronous processing using restlet and add filtering             DefaultHeaderFilterStrategy strategy = new DefaultHeaderFilterStrategy().             strategy.setInFilterPattern(HEADER_FILTER + ".*").             strategy.setOutFilterPattern(HEADER_FILTER + ".*").             RestletComponent restlet = context.getComponent("restlet", RestletComponent.class).             restlet.setHeaderFilterStrategy(strategy).             restlet.setSynchronous(true).             from("direct:start").to("restlet:http://localhost:" + portNum + "/users/123/exclude").to("log:reply").             from("restlet:http://localhost:" + portNum + "/users/{id}/{filterExcluded}?restletMethods=GET").to("mock:out").         }     }. }
