commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;43;;@Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {     if (currentFramelength == null) {         // find index of the first space, it should be after the length field         int index = indexOf(in, Unpooled.wrappedBuffer(new byte[] { ' ' })).         // Read part until the first space, if we have found one         StringBuffer lengthbuffer = new StringBuffer().         if (index > -1) {             ByteBuf byteBuf = in.readBytes(index).             byte[] dest = new byte[byteBuf.readableBytes()].             byteBuf.readBytes(dest).             lengthbuffer.append(new String(dest)).         }         int length.         try {             // add one because we have to take in account the space after             // the length field             length = Integer.parseInt(lengthbuffer.toString()) + 1.         } catch (NumberFormatException e) {             length = -1.         }         // retry next time         if (length < 0) {             in.resetReaderIndex().             return.         }         currentFramelength = length.     }     // Buffer does not contain enough data yet, wait until it does     if (in.readableBytes() < currentFramelength) {         return.     }     // read the message     int lengthToRead = currentFramelength.     currentFramelength = null.     out.add(in.readBytes(lengthToRead)). }
true;private,static;2;22;/**  * Borrowed from the DelimiterBasedFrameDecoder Returns the number of bytes  * between the readerIndex of the haystack and the first needle found in the  * haystack. -1 is returned if no needle is found in the haystack.  */ ;/**  * Borrowed from the DelimiterBasedFrameDecoder Returns the number of bytes  * between the readerIndex of the haystack and the first needle found in the  * haystack. -1 is returned if no needle is found in the haystack.  */ private static int indexOf(ByteBuf haystack, ByteBuf needle) {     for (int i = haystack.readerIndex(). i < haystack.writerIndex(). i++) {         int haystackIndex = i.         int needleIndex.         for (needleIndex = 0. needleIndex < needle.capacity(). needleIndex++) {             if (haystack.getByte(haystackIndex) != needle.getByte(needleIndex)) {                 break.             } else {                 haystackIndex++.                 if (haystackIndex == haystack.writerIndex() && needleIndex != needle.capacity() - 1) {                     return -1.                 }             }         }         if (needleIndex == needle.capacity()) {             // Found the needle from the haystack!             return i - haystack.readerIndex().         }     }     return -1. }
false;public;0;4;;@Override public ChannelHandler newChannelHandler() {     return new Rfc5425FrameDecoder(). }
