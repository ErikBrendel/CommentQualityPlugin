commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public JettyHttpComponent getComponent() {     return (JettyHttpComponent) super.getComponent(). }
false;public;0;20;;@Override public Producer createProducer() throws Exception {     JettyHttpProducer answer = new JettyHttpProducer(this).     if (httpClient != null) {         // use shared client, and ensure its started so we can use it         httpClient.start().         answer.setSharedClient(httpClient).         answer.setBinding(getJettyBinding(httpClient)).     } else {         HttpClient httpClient = createJettyHttpClient().         answer.setClient(httpClient).         answer.setBinding(getJettyBinding(httpClient)).     }     if (isSynchronous()) {         return new SynchronousDelegateProducer(answer).     } else {         return answer.     } }
false;protected;0;24;;protected HttpClient createJettyHttpClient() throws Exception {     // create a new client     // thread pool min/max from endpoint take precedence over from component     Integer min = httpClientMinThreads != null ? httpClientMinThreads : getComponent().getHttpClientMinThreads().     Integer max = httpClientMaxThreads != null ? httpClientMaxThreads : getComponent().getHttpClientMaxThreads().     HttpClient httpClient = getComponent().createHttpClient(this, min, max, sslContextParameters).     // set optional http client parameters     if (httpClientParameters != null) {         // copy parameters as we need to re-use them again if creating a new producer later         Map<String, Object> params = new HashMap<>(httpClientParameters).         // Can not be set on httpClient for jetty 9         params.remove("timeout").         IntrospectionSupport.setProperties(httpClient, params).         // validate we could set all parameters         if (params.size() > 0) {             throw new ResolveEndpointFailedException(getEndpointUri(), "There are " + params.size() + " parameters that couldn't be set on the endpoint." + " Check the uri if the parameters are spelt correctly and that they are properties of the endpoint." + " Unknown parameters=[" + params + "]").         }     }     return httpClient. }
false;public;1;6;;@Override public Consumer createConsumer(Processor processor) throws Exception {     JettyHttpConsumer answer = new JettyHttpConsumer(this, processor).     configureConsumer(answer).     return answer. }
true;public;1;3;/**  * Specifies whether to enable the session manager on the server side of Jetty.  */ ;/**  * Specifies whether to enable the session manager on the server side of Jetty.  */ public void setSessionSupport(boolean support) {     sessionSupport = support. }
false;public;0;3;;public boolean isSessionSupport() {     return sessionSupport. }
false;public;0;3;;public List<Handler> getHandlers() {     return handlers. }
true;public;1;3;/**  * Specifies a comma-delimited set of org.mortbay.jetty.Handler instances in your Registry (such as your Spring ApplicationContext).  * These handlers are added to the Jetty servlet context (for example, to add security).  * Important: You can not use different handlers with different Jetty endpoints using the same port number.  * The handlers is associated to the port number. If you need different handlers, then use different port numbers.  */ ;/**  * Specifies a comma-delimited set of org.mortbay.jetty.Handler instances in your Registry (such as your Spring ApplicationContext).  * These handlers are added to the Jetty servlet context (for example, to add security).  * Important: You can not use different handlers with different Jetty endpoints using the same port number.  * The handlers is associated to the port number. If you need different handlers, then use different port numbers.  */ public void setHandlers(List<Handler> handlers) {     this.handlers = handlers. }
false;public;0;3;;public HttpClient getHttpClient() throws Exception {     return httpClient. }
true;public;1;3;/**  * Sets a shared {@link HttpClient} to use for all producers  * created by this endpoint. By default each producer will  * use a new http client, and not share.  * <p/>  * <b>Important: </b> Make sure to handle the lifecycle of the shared  * client, such as stopping the client, when it is no longer in use.  * Camel will call the <tt>start</tt> method on the client to ensure  * its started when this endpoint creates a producer.  * <p/>  * This options should only be used in special circumstances.  */ ;/**  * Sets a shared {@link HttpClient} to use for all producers  * created by this endpoint. By default each producer will  * use a new http client, and not share.  * <p/>  * <b>Important: </b> Make sure to handle the lifecycle of the shared  * client, such as stopping the client, when it is no longer in use.  * Camel will call the <tt>start</tt> method on the client to ensure  * its started when this endpoint creates a producer.  * <p/>  * This options should only be used in special circumstances.  */ public void setHttpClient(HttpClient httpClient) {     this.httpClient = httpClient. }
false;public,synchronized;1;13;;public synchronized JettyHttpBinding getJettyBinding(HttpClient httpClient) {     if (jettyBinding == null) {         jettyBinding = new DefaultJettyHttpBinding().         jettyBinding.setHeaderFilterStrategy(getHeaderFilterStrategy()).         jettyBinding.setThrowExceptionOnFailure(isThrowExceptionOnFailure()).         jettyBinding.setTransferException(isTransferException()).         if (getComponent() != null) {             jettyBinding.setAllowJavaSerializedObject(getComponent().isAllowJavaSerializedObject()).         }         jettyBinding.setOkStatusCodeRange(getOkStatusCodeRange()).     }     return jettyBinding. }
true;public;1;3;/**  * To use a custom JettyHttpBinding which be used to customize how a response should be written for the producer.  */ ;/**  * To use a custom JettyHttpBinding which be used to customize how a response should be written for the producer.  */ public void setJettyBinding(JettyHttpBinding jettyBinding) {     this.jettyBinding = jettyBinding. }
false;public;0;3;;public boolean isEnableJmx() {     return this.enableJmx. }
true;public;1;3;/**  * If this option is true, Jetty JMX support will be enabled for this endpoint. See Jetty JMX support for more details.  */ ;/**  * If this option is true, Jetty JMX support will be enabled for this endpoint. See Jetty JMX support for more details.  */ public void setEnableJmx(boolean enableJmx) {     this.enableJmx = enableJmx. }
false;public;0;3;;public boolean isSendServerVersion() {     return sendServerVersion. }
true;public;1;3;/**  * If the option is true, jetty will send the server header with the jetty version information to the client which sends the request.  * NOTE please make sure there is no any other camel-jetty endpoint is share the same port, otherwise this option may not work as expected.  */ ;/**  * If the option is true, jetty will send the server header with the jetty version information to the client which sends the request.  * NOTE please make sure there is no any other camel-jetty endpoint is share the same port, otherwise this option may not work as expected.  */ public void setSendServerVersion(boolean sendServerVersion) {     this.sendServerVersion = sendServerVersion. }
false;public;0;3;;public boolean isSendDateHeader() {     return sendDateHeader. }
true;public;1;3;/**  * If the option is true, jetty server will send the date header to the client which sends the request.  * NOTE please make sure there is no any other camel-jetty endpoint is share the same port, otherwise this option may not work as expected.  */ ;/**  * If the option is true, jetty server will send the date header to the client which sends the request.  * NOTE please make sure there is no any other camel-jetty endpoint is share the same port, otherwise this option may not work as expected.  */ public void setSendDateHeader(boolean sendDateHeader) {     this.sendDateHeader = sendDateHeader. }
false;public;0;3;;public boolean isEnableMultipartFilter() {     return enableMultipartFilter. }
true;public;1;3;/**  * Whether Jetty org.eclipse.jetty.servlets.MultiPartFilter is enabled or not.  * You should set this value to false when bridging endpoints, to ensure multipart requests is proxied/bridged as well.  */ ;/**  * Whether Jetty org.eclipse.jetty.servlets.MultiPartFilter is enabled or not.  * You should set this value to false when bridging endpoints, to ensure multipart requests is proxied/bridged as well.  */ public void setEnableMultipartFilter(boolean enableMultipartFilter) {     this.enableMultipartFilter = enableMultipartFilter. }
true;public;1;3;/**  * Allows using a custom multipart filter. Note: setting multipartFilter forces the value of enableMultipartFilter to true.  */ ;/**  * Allows using a custom multipart filter. Note: setting multipartFilter forces the value of enableMultipartFilter to true.  */ public void setMultipartFilter(Filter filter) {     this.multipartFilter = filter. }
false;public;0;3;;public Filter getMultipartFilter() {     return multipartFilter. }
true;public;1;3;/**  * Allows using a custom filters which is putted into a list and can be find in the Registry.  * Multiple values can be separated by comma.  */ ;/**  * Allows using a custom filters which is putted into a list and can be find in the Registry.  * Multiple values can be separated by comma.  */ public void setFilters(List<Filter> filterList) {     this.filters = filterList. }
false;public;0;3;;public List<Filter> getFilters() {     return filters. }
false;public;0;3;;public Long getContinuationTimeout() {     return continuationTimeout. }
true;public;1;3;/**  * Allows to set a timeout in millis when using Jetty as consumer (server).  * By default Jetty uses 30000. You can use a value of <= 0 to never expire.  * If a timeout occurs then the request will be expired and Jetty will return back a http error 503 to the client.  * This option is only in use when using Jetty with the Asynchronous Routing Engine.  */ ;/**  * Allows to set a timeout in millis when using Jetty as consumer (server).  * By default Jetty uses 30000. You can use a value of <= 0 to never expire.  * If a timeout occurs then the request will be expired and Jetty will return back a http error 503 to the client.  * This option is only in use when using Jetty with the Asynchronous Routing Engine.  */ public void setContinuationTimeout(Long continuationTimeout) {     this.continuationTimeout = continuationTimeout. }
false;public;0;3;;public Boolean getUseContinuation() {     return useContinuation. }
true;public;1;3;/**  * Whether or not to use Jetty continuations for the Jetty Server.  */ ;/**  * Whether or not to use Jetty continuations for the Jetty Server.  */ public void setUseContinuation(Boolean useContinuation) {     this.useContinuation = useContinuation. }
false;public;0;3;;public SSLContextParameters getSslContextParameters() {     return sslContextParameters. }
true;public;1;3;/**  * To configure security using SSLContextParameters  */ ;/**  * To configure security using SSLContextParameters  */ public void setSslContextParameters(SSLContextParameters sslContextParameters) {     this.sslContextParameters = sslContextParameters. }
false;public;0;3;;public Integer getHttpClientMinThreads() {     return httpClientMinThreads. }
true;public;1;3;/**  * To set a value for minimum number of threads in HttpClient thread pool.  * This setting override any setting configured on component level.  * Notice that both a min and max size must be configured. If not set it default to min 8 threads used in Jettys thread pool.  */ ;/**  * To set a value for minimum number of threads in HttpClient thread pool.  * This setting override any setting configured on component level.  * Notice that both a min and max size must be configured. If not set it default to min 8 threads used in Jettys thread pool.  */ public void setHttpClientMinThreads(Integer httpClientMinThreads) {     this.httpClientMinThreads = httpClientMinThreads. }
false;public;0;3;;public Integer getHttpClientMaxThreads() {     return httpClientMaxThreads. }
true;public;1;3;/**  * To set a value for maximum number of threads in HttpClient thread pool.  * This setting override any setting configured on component level.  * Notice that both a min and max size must be configured. If not set it default to max 254 threads used in Jettys thread pool.  */ ;/**  * To set a value for maximum number of threads in HttpClient thread pool.  * This setting override any setting configured on component level.  * Notice that both a min and max size must be configured. If not set it default to max 254 threads used in Jettys thread pool.  */ public void setHttpClientMaxThreads(Integer httpClientMaxThreads) {     this.httpClientMaxThreads = httpClientMaxThreads. }
false;public;0;3;;public Map<String, Object> getHttpClientParameters() {     return httpClientParameters. }
true;public;1;3;/**  * Configuration of Jetty's HttpClient. For example, setting httpClient.idleTimeout=30000 sets the idle timeout to 30 seconds.  * And httpClient.timeout=30000 sets the request timeout to 30 seconds, in case you want to timeout sooner if you have long running request/response calls.  */ ;/**  * Configuration of Jetty's HttpClient. For example, setting httpClient.idleTimeout=30000 sets the idle timeout to 30 seconds.  * And httpClient.timeout=30000 sets the request timeout to 30 seconds, in case you want to timeout sooner if you have long running request/response calls.  */ public void setHttpClientParameters(Map<String, Object> httpClientParameters) {     this.httpClientParameters = httpClientParameters. }
false;public;0;3;;public Map<String, String> getFilterInitParameters() {     return filterInitParameters. }
true;public;1;3;/**  *  Configuration of the filter init parameters. These parameters will be applied to the filter list before starting the jetty server.  */ ;/**  *  Configuration of the filter init parameters. These parameters will be applied to the filter list before starting the jetty server.  */ public void setFilterInitParameters(Map<String, String> filterInitParameters) {     this.filterInitParameters = filterInitParameters. }
false;public;0;3;;public boolean isEnableCORS() {     return enableCORS. }
true;public;1;3;/**  * If the option is true, Jetty server will setup the CrossOriginFilter which supports the CORS out of box.  */ ;/**  * If the option is true, Jetty server will setup the CrossOriginFilter which supports the CORS out of box.  */ public void setEnableCORS(boolean enableCORS) {     this.enableCORS = enableCORS. }
false;public;0;3;;public CookieHandler getCookieHandler() {     return cookieHandler. }
true;public;1;3;/**  * Configure a cookie handler to maintain a HTTP session  */ ;/**  * Configure a cookie handler to maintain a HTTP session  */ public void setCookieHandler(CookieHandler cookieHandler) {     this.cookieHandler = cookieHandler. }
false;public,abstract;0;1;;public abstract JettyContentExchange createContentExchange().
