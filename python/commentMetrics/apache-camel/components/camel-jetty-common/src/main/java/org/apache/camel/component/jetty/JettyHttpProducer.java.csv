commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public JettyHttpEndpoint getEndpoint() {     return (JettyHttpEndpoint) super.getEndpoint(). }
false;public;2;14;;public boolean process(Exchange exchange, final AsyncCallback callback) {     try {         processInternal(exchange, callback).     } catch (Exception e) {         // error occurred before we had a chance to go async         // so set exception and invoke callback true         exchange.setException(e).         callback.done(true).         return true.     }     // we should continue processing this asynchronously     return false. }
false;private;2;178;;private void processInternal(Exchange exchange, AsyncCallback callback) throws Exception {     // creating the url to use takes 2-steps     String url = HttpHelper.createURL(exchange, getEndpoint()).     URI uri = HttpHelper.createURI(exchange, url, getEndpoint()).     // get the url from the uri     url = uri.toASCIIString().     // execute any custom url rewrite     String rewriteUrl = HttpHelper.urlRewrite(exchange, url, getEndpoint(), this).     if (rewriteUrl != null) {         // update url and query string from the rewritten url         url = rewriteUrl.     }     String methodName = HttpHelper.createMethod(exchange, getEndpoint(), exchange.getIn().getBody() != null).name().     JettyContentExchange httpExchange = getEndpoint().createContentExchange().     httpExchange.init(exchange, getBinding(), client, callback).     // url must have scheme     try {         uri = new URI(url).         String scheme = uri.getScheme().         if (scheme == null) {             throw new IllegalArgumentException("Url must include scheme: " + url + ". If you are bridging endpoints set bridgeEndpoint=true." + " If you want to call a specific url, then you may need to remove all CamelHttp* headers in the route before this." + " See more details at: http://camel.apache.org/how-to-remove-the-http-protocol-headers-in-the-camel-message.html").         }     } catch (URISyntaxException e) {     // ignore     }     // Url has to be set first     httpExchange.setURL(url).     httpExchange.setMethod(methodName).     if (getEndpoint().getHttpClientParameters() != null) {         // For jetty 9 these parameters can not be set on the client         // so we need to set them on the httpExchange         String timeout = (String) getEndpoint().getHttpClientParameters().get("timeout").         if (timeout != null) {             httpExchange.setTimeout(new Long(timeout)).         }         String supportRedirect = (String) getEndpoint().getHttpClientParameters().get("supportRedirect").         if (supportRedirect != null) {             httpExchange.setSupportRedirect(Boolean.valueOf(supportRedirect)).         }     }     log.trace("Using URL: {} with method: {}", url, methodName).     // if there is a body to send as data     if (exchange.getIn().getBody() != null) {         String contentType = ExchangeHelper.getContentType(exchange).         if (contentType != null) {             httpExchange.setRequestContentType(contentType).         }         if (contentType != null && HttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT.equals(contentType)) {             if (getEndpoint().getComponent().isAllowJavaSerializedObject() || getEndpoint().isTransferException()) {                 // serialized java object                 Serializable obj = exchange.getIn().getMandatoryBody(Serializable.class).                 // write object to output stream                 ByteArrayOutputStream bos = new ByteArrayOutputStream().                 try {                     HttpHelper.writeObjectToStream(bos, obj).                     httpExchange.setRequestContent(bos.toByteArray()).                 } finally {                     IOHelper.close(bos, "body", log).                 }             } else {                 throw new RuntimeCamelException("Content-type " + HttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT + " is not allowed").             }         } else {             Object body = exchange.getIn().getBody().             if (body instanceof String) {                 String data = (String) body.                 // be a bit careful with String as any type can most likely be converted to String                 // so we only do an instanceof check and accept String if the body is really a String                 // do not fallback to use the default charset as it can influence the request                 // (for example application/x-www-form-urlencoded forms being sent)                 String charset = ExchangeHelper.getCharsetName(exchange, false).                 httpExchange.setRequestContent(data, charset).             } else {                 // then fallback to input stream                 InputStream is = exchange.getContext().getTypeConverter().mandatoryConvertTo(InputStream.class, exchange, exchange.getIn().getBody()).                 // setup the content length if it is possible                 String length = exchange.getIn().getHeader(Exchange.CONTENT_LENGTH, String.class).                 if (org.apache.camel.util.ObjectHelper.isNotEmpty(length)) {                     httpExchange.addRequestHeader(Exchange.CONTENT_LENGTH, length).                     // send with content-length                     httpExchange.setRequestContent(is, new Integer(length)).                 } else {                     // send chunked                     httpExchange.setRequestContent(is).                 }             }         }     }     // if we bridge endpoint then we need to skip matching headers with the HTTP_QUERY to avoid sending     // duplicated headers to the receiver, so use this skipRequestHeaders as the list of headers to skip     Map<String, Object> skipRequestHeaders = null.     if (getEndpoint().isBridgeEndpoint()) {         exchange.setProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.TRUE).         String queryString = exchange.getIn().getHeader(Exchange.HTTP_QUERY, String.class).         if (queryString != null) {             skipRequestHeaders = URISupport.parseQuery(queryString, false, true).         }     }     // propagate headers as HTTP headers     Message in = exchange.getIn().     HeaderFilterStrategy strategy = getEndpoint().getHeaderFilterStrategy().     for (Map.Entry<String, Object> entry : in.getHeaders().entrySet()) {         String key = entry.getKey().         Object headerValue = in.getHeader(key).         if (headerValue != null) {             // use an iterator as there can be multiple values. (must not use a delimiter, and allow empty values)             final Iterator<?> it = ObjectHelper.createIterator(headerValue, null, true).             // the values to add as a request header             final List<String> values = new ArrayList<>().             // should be combined into a single value             while (it.hasNext()) {                 String value = exchange.getContext().getTypeConverter().convertTo(String.class, it.next()).                 // as then we would duplicate headers on both the endpoint uri, and in HTTP headers as well                 if (skipRequestHeaders != null && skipRequestHeaders.containsKey(key)) {                     continue.                 }                 if (value != null && strategy != null && !strategy.applyFilterToCamelHeaders(key, value, exchange)) {                     values.add(value).                 }             }             // add the value(s) as a http request header             if (values.size() > 0) {                 // use the default toString of a ArrayList to create in the form [xxx, yyy]                 // if multi valued, for a single value, then just output the value as is                 String s = values.size() > 1 ? values.toString() : values.get(0).                 httpExchange.addRequestHeader(key, s).             }         }     }     if (getEndpoint().isConnectionClose()) {         httpExchange.addRequestHeader("Connection", "close").     }     // if this option is set, and the exchange Host header is not null, we will set it's current value on the httpExchange     if (getEndpoint().isPreserveHostHeader()) {         String hostHeader = exchange.getIn().getHeader("Host", String.class).         if (hostHeader != null) {             // HttpClient 4 will check to see if the Host header is present, and use it if it is, see org.apache.http.protocol.RequestTargetHost in httpcore             httpExchange.addRequestHeader("Host", hostHeader).         }     }     // set the callback, which will handle all the response logic     if (log.isDebugEnabled()) {         log.debug("Sending HTTP request to: {}", httpExchange.getUrl()).     }     if (getEndpoint().getCookieHandler() != null) {         // this will store the cookie in the cookie store         CookieStore cookieStore = getEndpoint().getCookieHandler().getCookieStore(exchange).         if (!client.getCookieStore().equals(cookieStore)) {             client.setCookieStore(cookieStore).         }     }     httpExchange.send(client). }
false;public;0;3;;public JettyHttpBinding getBinding() {     return binding. }
false;public;1;3;;public void setBinding(JettyHttpBinding binding) {     this.binding = binding. }
false;public;0;3;;public HttpClient getClient() {     return client. }
false;public;1;4;;public void setClient(HttpClient client) {     this.client = client.     this.sharedClient = false. }
false;public;0;7;;public HttpClient getSharedClient() {     if (sharedClient) {         return client.     } else {         return null.     } }
false;public;1;4;;public void setSharedClient(HttpClient sharedClient) {     this.client = sharedClient.     this.sharedClient = true. }
false;private;0;8;;private Object getClientThreadPool() {     try {         return client.getClass().getMethod("getThreadPool").invoke(client).     } catch (Throwable t) {     // not found in Jetty 9 which is OK as the threadpool is auto started on Jetty 9     }     return null. }
false;protected;0;14;;@Override protected void doStart() throws Exception {     // only start non-shared client     if (!sharedClient && client != null) {         client.start().         // start the thread pool         Object tp = getClientThreadPool().         if (tp instanceof LifeCycle) {             log.debug("Starting client thread pool {}", tp).             ((LifeCycle) tp).start().         }     }     super.doStart(). }
false;protected;0;14;;@Override protected void doStop() throws Exception {     super.doStop().     // only stop non-shared client     if (!sharedClient && client != null) {         client.stop().         // stop thread pool         Object tp = getClientThreadPool().         if (tp instanceof LifeCycle) {             log.debug("Stopping client thread pool {}", tp).             ((LifeCycle) tp).stop().         }     } }
