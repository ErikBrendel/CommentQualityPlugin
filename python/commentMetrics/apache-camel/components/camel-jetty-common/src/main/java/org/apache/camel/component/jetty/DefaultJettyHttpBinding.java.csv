commented;modifiers;parameterAmount;loc;comment;code
false;public;2;25;;public void populateResponse(Exchange exchange, JettyContentExchange httpExchange) throws Exception {     int responseCode = httpExchange.getResponseStatus().     LOG.debug("HTTP responseCode: {}", responseCode).     Message in = exchange.getIn().     if (!isThrowExceptionOnFailure()) {         // if we do not use failed exception then populate response for all response codes         populateResponse(exchange, httpExchange, in, getHeaderFilterStrategy(), responseCode).     } else {         boolean ok = HttpHelper.isStatusCodeOk(responseCode, okStatusCodeRange).         if (ok) {             // only populate response for OK response             populateResponse(exchange, httpExchange, in, getHeaderFilterStrategy(), responseCode).         } else {             // operation failed so populate exception to throw             Exception ex = populateHttpOperationFailedException(exchange, httpExchange, responseCode).             if (ex != null) {                 throw ex.             } else {                 populateResponse(exchange, httpExchange, in, getHeaderFilterStrategy(), responseCode).             }         }     } }
false;public;0;3;;public HeaderFilterStrategy getHeaderFilterStrategy() {     return headerFilterStrategy. }
false;public;1;3;;public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {     this.headerFilterStrategy = headerFilterStrategy. }
false;public;0;3;;public boolean isThrowExceptionOnFailure() {     return throwExceptionOnFailure. }
false;public;1;3;;public void setThrowExceptionOnFailure(boolean throwExceptionOnFailure) {     this.throwExceptionOnFailure = throwExceptionOnFailure. }
false;public;0;3;;public boolean isTransferException() {     return transferException. }
false;public;1;3;;public void setTransferException(boolean transferException) {     this.transferException = transferException. }
false;public;0;3;;public boolean isAllowJavaSerializedObject() {     return allowJavaSerializedObject. }
false;public;1;3;;public void setAllowJavaSerializedObject(boolean allowJavaSerializedObject) {     this.allowJavaSerializedObject = allowJavaSerializedObject. }
false;public;0;3;;public String getOkStatusCodeRange() {     return okStatusCodeRange. }
false;public;1;3;;public void setOkStatusCodeRange(String okStatusCodeRange) {     this.okStatusCodeRange = okStatusCodeRange. }
false;protected;5;32;;protected void populateResponse(Exchange exchange, JettyContentExchange httpExchange, Message in, HeaderFilterStrategy strategy, int responseCode) throws IOException {     Message answer = exchange.getOut().     answer.setHeader(Exchange.HTTP_RESPONSE_CODE, responseCode).     // must use response fields to get the http headers as     // httpExchange.getHeaders() does not work well with multi valued headers     Map<String, Collection<String>> headers = httpExchange.getResponseHeaders().     for (Map.Entry<String, Collection<String>> ent : headers.entrySet()) {         String name = ent.getKey().         Collection<String> values = ent.getValue().         for (String value : values) {             if (name.toLowerCase().equals("content-type")) {                 name = Exchange.CONTENT_TYPE.                 exchange.setProperty(Exchange.CHARSET_NAME, IOHelper.getCharsetNameFromContentType(value)).             }             if (strategy != null && !strategy.applyFilterToExternalHeaders(name, value, exchange)) {                 HttpHelper.appendHeader(answer.getHeaders(), name, value).             }         }     }     // preserve headers from in by copying any non existing headers     // to avoid overriding existing headers with old values     // We also need to apply the httpProtocolHeaderFilterStrategy to filter the http protocol header     MessageHelper.copyHeaders(exchange.getIn(), answer, httpProtocolHeaderFilterStrategy, false).     // extract body after headers has been set as we want to ensure content-type from Jetty HttpExchange     // has been populated first     answer.setBody(extractResponseBody(exchange, httpExchange)). }
false;protected;3;34;;protected Exception populateHttpOperationFailedException(Exchange exchange, JettyContentExchange httpExchange, int responseCode) throws IOException {     HttpOperationFailedException answer.     String uri = httpExchange.getUrl().     Map<String, String> headers = getSimpleMap(httpExchange.getResponseHeaders()).     Object responseBody = extractResponseBody(exchange, httpExchange).     if (transferException && responseBody instanceof Exception) {         // if the response was a serialized exception then use that         return (Exception) responseBody.     }     // make a defensive copy of the response body in the exception so its detached from the cache     String copy = null.     if (responseBody != null) {         copy = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, responseBody).     }     if (responseCode >= 300 && responseCode < 400) {         Collection<String> loc = httpExchange.getResponseHeaders().get("location").         if (loc != null && !loc.isEmpty()) {             String locationHeader = loc.iterator().next().             answer = new HttpOperationFailedException(uri, responseCode, null, locationHeader, headers, copy).         } else {             // no redirect location             answer = new HttpOperationFailedException(uri, responseCode, null, null, headers, copy).         }     } else {         // internal server error (error code 500)         answer = new HttpOperationFailedException(uri, responseCode, null, null, headers, copy).     }     return answer. }
false;protected;2;23;;protected Object extractResponseBody(Exchange exchange, JettyContentExchange httpExchange) throws IOException {     Map<String, String> headers = getSimpleMap(httpExchange.getResponseHeaders()).     String contentType = headers.get(Exchange.CONTENT_TYPE).     // if content type is serialized java object, then de-serialize it to a Java object     if (contentType != null && HttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT.equals(contentType)) {         // only deserialize java if allowed         if (isAllowJavaSerializedObject() || isTransferException()) {             try {                 InputStream is = exchange.getContext().getTypeConverter().mandatoryConvertTo(InputStream.class, httpExchange.getResponseContentBytes()).                 return HttpHelper.deserializeJavaObjectFromStream(is, exchange.getContext()).             } catch (Exception e) {                 throw new RuntimeCamelException("Cannot deserialize body to Java object", e).             }         } else {             // empty body             return null.         }     } else {         // just grab the raw content body         return httpExchange.getBody().     } }
false;;1;9;;Map<String, String> getSimpleMap(Map<String, Collection<String>> headers) {     Map<String, String> result = new HashMap<>().     for (String key : headers.keySet()) {         Collection<String> valueCol = headers.get(key).         String value = (valueCol == null) ? null : valueCol.iterator().next().         result.put(key, value).     }     return result. }
