commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public DockerEndpoint getEndpoint() {     return (DockerEndpoint) super.getEndpoint(). }
true;private;0;9;/**  * Determine the point in time to begin streaming events  */ ;/**  * Determine the point in time to begin streaming events  */ private long processInitialEvent() {     long currentTime = new Date().getTime().     Long initialRange = DockerHelper.getProperty(DockerConstants.DOCKER_INITIAL_RANGE, endpoint.getConfiguration(), null, Long.class).     if (initialRange != null) {         currentTime = currentTime - initialRange.     }     return currentTime. }
false;protected;0;7;;@Override protected void doStart() throws Exception {     this.eventsCmd = DockerClientFactory.getDockerClient(component, endpoint.getConfiguration(), null).eventsCmd().withSince(String.valueOf(processInitialEvent())).     this.eventsCmd.exec(new EventsCallback()).     super.doStart(). }
false;protected;0;6;;@Override protected void doStop() throws Exception {     this.eventsCmd.close().     super.doStop(). }
false;public;1;4;;@Override public void done(boolean doneSync) {     log.trace("Done processing exchange [{}]...", exchange). }
false;public;1;22;;public void onNext(Event event) {     log.debug("Received Docker Event: {}", event).     final Exchange exchange = getEndpoint().createExchange().     Message message = exchange.getIn().     message.setBody(event).     try {         log.trace("Processing exchange [{}]...", exchange).         getAsyncProcessor().process(exchange, new AsyncCallback() {              @Override             public void done(boolean doneSync) {                 log.trace("Done processing exchange [{}]...", exchange).             }         }).     } catch (Exception e) {         exchange.setException(e).     }     if (exchange.getException() != null) {         getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException()).     } }
