# id;timestamp;commentText;codeText;commentWords;codeWords
SparkConfiguration -> public void setDisableStreamCache(boolean disableStreamCache);1429282863;Determines whether or not the raw input stream from Spark HttpRequest#getContent() is cached or not_(Camel will read the stream into a in light-weight memory based Stream caching) cache._By default Camel will cache the Netty input stream to support reading it multiple times to ensure Camel_can retrieve all data from the stream. However you can set this option to true when you for example need_to access the raw stream, such as streaming it directly to a file or other persistent store._Mind that if you enable this option, then you cannot read the Netty stream multiple times out of the box,_and you would need manually to reset the reader index on the Spark raw stream.;public void setDisableStreamCache(boolean disableStreamCache) {_        this.disableStreamCache = disableStreamCache__    };determines,whether,or,not,the,raw,input,stream,from,spark,http,request,get,content,is,cached,or,not,camel,will,read,the,stream,into,a,in,light,weight,memory,based,stream,caching,cache,by,default,camel,will,cache,the,netty,input,stream,to,support,reading,it,multiple,times,to,ensure,camel,can,retrieve,all,data,from,the,stream,however,you,can,set,this,option,to,true,when,you,for,example,need,to,access,the,raw,stream,such,as,streaming,it,directly,to,a,file,or,other,persistent,store,mind,that,if,you,enable,this,option,then,you,cannot,read,the,netty,stream,multiple,times,out,of,the,box,and,you,would,need,manually,to,reset,the,reader,index,on,the,spark,raw,stream;public,void,set,disable,stream,cache,boolean,disable,stream,cache,this,disable,stream,cache,disable,stream,cache
SparkConfiguration -> public void setDisableStreamCache(boolean disableStreamCache);1447336366;Determines whether or not the raw input stream from Spark HttpRequest#getContent() is cached or not_(Camel will read the stream into a in light-weight memory based Stream caching) cache._By default Camel will cache the Netty input stream to support reading it multiple times to ensure Camel_can retrieve all data from the stream. However you can set this option to true when you for example need_to access the raw stream, such as streaming it directly to a file or other persistent store._Mind that if you enable this option, then you cannot read the Netty stream multiple times out of the box,_and you would need manually to reset the reader index on the Spark raw stream.;public void setDisableStreamCache(boolean disableStreamCache) {_        this.disableStreamCache = disableStreamCache__    };determines,whether,or,not,the,raw,input,stream,from,spark,http,request,get,content,is,cached,or,not,camel,will,read,the,stream,into,a,in,light,weight,memory,based,stream,caching,cache,by,default,camel,will,cache,the,netty,input,stream,to,support,reading,it,multiple,times,to,ensure,camel,can,retrieve,all,data,from,the,stream,however,you,can,set,this,option,to,true,when,you,for,example,need,to,access,the,raw,stream,such,as,streaming,it,directly,to,a,file,or,other,persistent,store,mind,that,if,you,enable,this,option,then,you,cannot,read,the,netty,stream,multiple,times,out,of,the,box,and,you,would,need,manually,to,reset,the,reader,index,on,the,spark,raw,stream;public,void,set,disable,stream,cache,boolean,disable,stream,cache,this,disable,stream,cache,disable,stream,cache
SparkConfiguration -> public void setDisableStreamCache(boolean disableStreamCache);1456586710;Determines whether or not the raw input stream from Spark HttpRequest#getContent() is cached or not_(Camel will read the stream into a in light-weight memory based Stream caching) cache._By default Camel will cache the Netty input stream to support reading it multiple times to ensure Camel_can retrieve all data from the stream. However you can set this option to true when you for example need_to access the raw stream, such as streaming it directly to a file or other persistent store._Mind that if you enable this option, then you cannot read the Netty stream multiple times out of the box,_and you would need manually to reset the reader index on the Spark raw stream.;public void setDisableStreamCache(boolean disableStreamCache) {_        this.disableStreamCache = disableStreamCache__    };determines,whether,or,not,the,raw,input,stream,from,spark,http,request,get,content,is,cached,or,not,camel,will,read,the,stream,into,a,in,light,weight,memory,based,stream,caching,cache,by,default,camel,will,cache,the,netty,input,stream,to,support,reading,it,multiple,times,to,ensure,camel,can,retrieve,all,data,from,the,stream,however,you,can,set,this,option,to,true,when,you,for,example,need,to,access,the,raw,stream,such,as,streaming,it,directly,to,a,file,or,other,persistent,store,mind,that,if,you,enable,this,option,then,you,cannot,read,the,netty,stream,multiple,times,out,of,the,box,and,you,would,need,manually,to,reset,the,reader,index,on,the,spark,raw,stream;public,void,set,disable,stream,cache,boolean,disable,stream,cache,this,disable,stream,cache,disable,stream,cache
SparkConfiguration -> public void setDisableStreamCache(boolean disableStreamCache);1457098435;Determines whether or not the raw input stream from Spark HttpRequest#getContent() is cached or not_(Camel will read the stream into a in light-weight memory based Stream caching) cache._By default Camel will cache the Netty input stream to support reading it multiple times to ensure Camel_can retrieve all data from the stream. However you can set this option to true when you for example need_to access the raw stream, such as streaming it directly to a file or other persistent store._Mind that if you enable this option, then you cannot read the Netty stream multiple times out of the box,_and you would need manually to reset the reader index on the Spark raw stream.;public void setDisableStreamCache(boolean disableStreamCache) {_        this.disableStreamCache = disableStreamCache__    };determines,whether,or,not,the,raw,input,stream,from,spark,http,request,get,content,is,cached,or,not,camel,will,read,the,stream,into,a,in,light,weight,memory,based,stream,caching,cache,by,default,camel,will,cache,the,netty,input,stream,to,support,reading,it,multiple,times,to,ensure,camel,can,retrieve,all,data,from,the,stream,however,you,can,set,this,option,to,true,when,you,for,example,need,to,access,the,raw,stream,such,as,streaming,it,directly,to,a,file,or,other,persistent,store,mind,that,if,you,enable,this,option,then,you,cannot,read,the,netty,stream,multiple,times,out,of,the,box,and,you,would,need,manually,to,reset,the,reader,index,on,the,spark,raw,stream;public,void,set,disable,stream,cache,boolean,disable,stream,cache,this,disable,stream,cache,disable,stream,cache
SparkConfiguration -> public void setUrlDecodeHeaders(boolean urlDecodeHeaders);1429282863;If this option is enabled, then during binding from Spark to Camel Message then the header values will be URL decoded (eg %20 will be a space character.);public void setUrlDecodeHeaders(boolean urlDecodeHeaders) {_        this.urlDecodeHeaders = urlDecodeHeaders__    };if,this,option,is,enabled,then,during,binding,from,spark,to,camel,message,then,the,header,values,will,be,url,decoded,eg,20,will,be,a,space,character;public,void,set,url,decode,headers,boolean,url,decode,headers,this,url,decode,headers,url,decode,headers
SparkConfiguration -> public void setUrlDecodeHeaders(boolean urlDecodeHeaders);1447336366;If this option is enabled, then during binding from Spark to Camel Message then the header values will be URL decoded (eg %20 will be a space character.);public void setUrlDecodeHeaders(boolean urlDecodeHeaders) {_        this.urlDecodeHeaders = urlDecodeHeaders__    };if,this,option,is,enabled,then,during,binding,from,spark,to,camel,message,then,the,header,values,will,be,url,decoded,eg,20,will,be,a,space,character;public,void,set,url,decode,headers,boolean,url,decode,headers,this,url,decode,headers,url,decode,headers
SparkConfiguration -> public void setUrlDecodeHeaders(boolean urlDecodeHeaders);1456586710;If this option is enabled, then during binding from Spark to Camel Message then the header values will be URL decoded (eg %20 will be a space character.);public void setUrlDecodeHeaders(boolean urlDecodeHeaders) {_        this.urlDecodeHeaders = urlDecodeHeaders__    };if,this,option,is,enabled,then,during,binding,from,spark,to,camel,message,then,the,header,values,will,be,url,decoded,eg,20,will,be,a,space,character;public,void,set,url,decode,headers,boolean,url,decode,headers,this,url,decode,headers,url,decode,headers
SparkConfiguration -> public void setUrlDecodeHeaders(boolean urlDecodeHeaders);1457098435;If this option is enabled, then during binding from Spark to Camel Message then the header values will be URL decoded (eg %20 will be a space character.);public void setUrlDecodeHeaders(boolean urlDecodeHeaders) {_        this.urlDecodeHeaders = urlDecodeHeaders__    };if,this,option,is,enabled,then,during,binding,from,spark,to,camel,message,then,the,header,values,will,be,url,decoded,eg,20,will,be,a,space,character;public,void,set,url,decode,headers,boolean,url,decode,headers,this,url,decode,headers,url,decode,headers
SparkConfiguration -> public void setMapHeaders(boolean mapHeaders);1429282863;If this option is enabled, then during binding from Spark to Camel Message then the headers will be mapped as well_(eg added as header to the Camel Message as well). You can turn off this option to disable this._The headers can still be accessed from the org.apache.camel.component.sparkrest.SparkMessage message with the_method getRequest() that returns the Spark HTTP request instance.;public void setMapHeaders(boolean mapHeaders) {_        this.mapHeaders = mapHeaders__    };if,this,option,is,enabled,then,during,binding,from,spark,to,camel,message,then,the,headers,will,be,mapped,as,well,eg,added,as,header,to,the,camel,message,as,well,you,can,turn,off,this,option,to,disable,this,the,headers,can,still,be,accessed,from,the,org,apache,camel,component,sparkrest,spark,message,message,with,the,method,get,request,that,returns,the,spark,http,request,instance;public,void,set,map,headers,boolean,map,headers,this,map,headers,map,headers
SparkConfiguration -> public void setMapHeaders(boolean mapHeaders);1447336366;If this option is enabled, then during binding from Spark to Camel Message then the headers will be mapped as well_(eg added as header to the Camel Message as well). You can turn off this option to disable this._The headers can still be accessed from the org.apache.camel.component.sparkrest.SparkMessage message with the_method getRequest() that returns the Spark HTTP request instance.;public void setMapHeaders(boolean mapHeaders) {_        this.mapHeaders = mapHeaders__    };if,this,option,is,enabled,then,during,binding,from,spark,to,camel,message,then,the,headers,will,be,mapped,as,well,eg,added,as,header,to,the,camel,message,as,well,you,can,turn,off,this,option,to,disable,this,the,headers,can,still,be,accessed,from,the,org,apache,camel,component,sparkrest,spark,message,message,with,the,method,get,request,that,returns,the,spark,http,request,instance;public,void,set,map,headers,boolean,map,headers,this,map,headers,map,headers
SparkConfiguration -> public void setMapHeaders(boolean mapHeaders);1456586710;If this option is enabled, then during binding from Spark to Camel Message then the headers will be mapped as well_(eg added as header to the Camel Message as well). You can turn off this option to disable this._The headers can still be accessed from the org.apache.camel.component.sparkrest.SparkMessage message with the_method getRequest() that returns the Spark HTTP request instance.;public void setMapHeaders(boolean mapHeaders) {_        this.mapHeaders = mapHeaders__    };if,this,option,is,enabled,then,during,binding,from,spark,to,camel,message,then,the,headers,will,be,mapped,as,well,eg,added,as,header,to,the,camel,message,as,well,you,can,turn,off,this,option,to,disable,this,the,headers,can,still,be,accessed,from,the,org,apache,camel,component,sparkrest,spark,message,message,with,the,method,get,request,that,returns,the,spark,http,request,instance;public,void,set,map,headers,boolean,map,headers,this,map,headers,map,headers
SparkConfiguration -> public void setMapHeaders(boolean mapHeaders);1457098435;If this option is enabled, then during binding from Spark to Camel Message then the headers will be mapped as well_(eg added as header to the Camel Message as well). You can turn off this option to disable this._The headers can still be accessed from the org.apache.camel.component.sparkrest.SparkMessage message with the_method getRequest() that returns the Spark HTTP request instance.;public void setMapHeaders(boolean mapHeaders) {_        this.mapHeaders = mapHeaders__    };if,this,option,is,enabled,then,during,binding,from,spark,to,camel,message,then,the,headers,will,be,mapped,as,well,eg,added,as,header,to,the,camel,message,as,well,you,can,turn,off,this,option,to,disable,this,the,headers,can,still,be,accessed,from,the,org,apache,camel,component,sparkrest,spark,message,message,with,the,method,get,request,that,returns,the,spark,http,request,instance;public,void,set,map,headers,boolean,map,headers,this,map,headers,map,headers
SparkConfiguration -> public void setMatchOnUriPrefix(boolean matchOnUriPrefix);1456586710;Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.;public void setMatchOnUriPrefix(boolean matchOnUriPrefix) {_        this.matchOnUriPrefix = matchOnUriPrefix__    };whether,or,not,the,consumer,should,try,to,find,a,target,consumer,by,matching,the,uri,prefix,if,no,exact,match,is,found;public,void,set,match,on,uri,prefix,boolean,match,on,uri,prefix,this,match,on,uri,prefix,match,on,uri,prefix
SparkConfiguration -> public void setMatchOnUriPrefix(boolean matchOnUriPrefix);1457098435;Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.;public void setMatchOnUriPrefix(boolean matchOnUriPrefix) {_        this.matchOnUriPrefix = matchOnUriPrefix__    };whether,or,not,the,consumer,should,try,to,find,a,target,consumer,by,matching,the,uri,prefix,if,no,exact,match,is,found;public,void,set,match,on,uri,prefix,boolean,match,on,uri,prefix,this,match,on,uri,prefix,match,on,uri,prefix
SparkConfiguration -> public SparkConfiguration copy();1456586710;Returns a copy of this configuration;public SparkConfiguration copy() {_        try {_            SparkConfiguration copy = (SparkConfiguration) clone()__            return copy__        } catch (CloneNotSupportedException e) {_            throw new RuntimeCamelException(e)__        }_    };returns,a,copy,of,this,configuration;public,spark,configuration,copy,try,spark,configuration,copy,spark,configuration,clone,return,copy,catch,clone,not,supported,exception,e,throw,new,runtime,camel,exception,e
SparkConfiguration -> public SparkConfiguration copy();1457098435;Returns a copy of this configuration;public SparkConfiguration copy() {_        try {_            SparkConfiguration copy = (SparkConfiguration) clone()__            return copy__        } catch (CloneNotSupportedException e) {_            throw new RuntimeCamelException(e)__        }_    };returns,a,copy,of,this,configuration;public,spark,configuration,copy,try,spark,configuration,copy,spark,configuration,clone,return,copy,catch,clone,not,supported,exception,e,throw,new,runtime,camel,exception,e
SparkConfiguration -> public void setTransferException(boolean transferException);1429282863;If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized_in the response as a application/x-java-serialized-object content type.;public void setTransferException(boolean transferException) {_        this.transferException = transferException__    };if,enabled,and,an,exchange,failed,processing,on,the,consumer,side,and,if,the,caused,exception,was,send,back,serialized,in,the,response,as,a,application,x,java,serialized,object,content,type;public,void,set,transfer,exception,boolean,transfer,exception,this,transfer,exception,transfer,exception
SparkConfiguration -> public void setTransferException(boolean transferException);1447336366;If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized_in the response as a application/x-java-serialized-object content type._<p/>_This is by default turned off. If you enable this then be aware that Java will deserialize the incoming_data from the request to Java and that can be a potential security risk.;public void setTransferException(boolean transferException) {_        this.transferException = transferException__    };if,enabled,and,an,exchange,failed,processing,on,the,consumer,side,and,if,the,caused,exception,was,send,back,serialized,in,the,response,as,a,application,x,java,serialized,object,content,type,p,this,is,by,default,turned,off,if,you,enable,this,then,be,aware,that,java,will,deserialize,the,incoming,data,from,the,request,to,java,and,that,can,be,a,potential,security,risk;public,void,set,transfer,exception,boolean,transfer,exception,this,transfer,exception,transfer,exception
SparkConfiguration -> public void setTransferException(boolean transferException);1456586710;If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized_in the response as a application/x-java-serialized-object content type._<p/>_This is by default turned off. If you enable this then be aware that Java will deserialize the incoming_data from the request to Java and that can be a potential security risk.;public void setTransferException(boolean transferException) {_        this.transferException = transferException__    };if,enabled,and,an,exchange,failed,processing,on,the,consumer,side,and,if,the,caused,exception,was,send,back,serialized,in,the,response,as,a,application,x,java,serialized,object,content,type,p,this,is,by,default,turned,off,if,you,enable,this,then,be,aware,that,java,will,deserialize,the,incoming,data,from,the,request,to,java,and,that,can,be,a,potential,security,risk;public,void,set,transfer,exception,boolean,transfer,exception,this,transfer,exception,transfer,exception
SparkConfiguration -> public void setTransferException(boolean transferException);1457098435;If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized_in the response as a application/x-java-serialized-object content type._<p/>_This is by default turned off. If you enable this then be aware that Java will deserialize the incoming_data from the request to Java and that can be a potential security risk.;public void setTransferException(boolean transferException) {_        this.transferException = transferException__    };if,enabled,and,an,exchange,failed,processing,on,the,consumer,side,and,if,the,caused,exception,was,send,back,serialized,in,the,response,as,a,application,x,java,serialized,object,content,type,p,this,is,by,default,turned,off,if,you,enable,this,then,be,aware,that,java,will,deserialize,the,incoming,data,from,the,request,to,java,and,that,can,be,a,potential,security,risk;public,void,set,transfer,exception,boolean,transfer,exception,this,transfer,exception,transfer,exception
