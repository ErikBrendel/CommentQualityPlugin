commented;modifiers;parameterAmount;loc;comment;code
false;public;1;13;;@Override public Object lookupByName(String key) {     // Substitute $ character in key     key = key.replaceAll("\\$", "/").     kvClient = consul.keyValueClient().     return kvClient.getValueAsString(key).map(result -> {         byte[] postDecodedValue = ConsulRegistryUtils.decodeBase64(result).         return ConsulRegistryUtils.deserialize(postDecodedValue).     }).orElse(null). }
false;public;2;14;;@Override public <T> T lookupByNameAndType(String name, Class<T> type) {     Object object = lookupByName(name).     if (object == null) {         return null.     }     try {         return type.cast(object).     } catch (Throwable e) {         String msg = "Found bean: " + name + " in Consul Registry: " + this + " of type: " + object.getClass().getName() + "expected type was: " + type.         throw new NoSuchBeanException(name, msg, e).     } }
false;public;1;28;;@Override public <T> Map<String, T> findByTypeWithName(Class<T> type) {     Map<String, T> result = new HashMap<>().     // encode $ signs as they occur in subclass types     String keyPrefix = type.getName().replaceAll("\\$", "/").     kvClient = consul.keyValueClient().     List<String> keys.     try {         keys = kvClient.getKeys(keyPrefix).     } catch (ConsulException e) {         return result.     }     if (keys != null) {         Object obj.         for (String key : keys) {             // change bookmark back into actual key             key = key.substring(key.lastIndexOf('/') + 1).             obj = lookupByName(key.replaceAll("\\$", "/")).             if (type.isInstance(obj)) {                 result.put(key, type.cast(obj)).             }         }     }     return result. }
false;public;1;26;;@Override public <T> Set<T> findByType(Class<T> type) {     String keyPrefix = type.getName().replaceAll("\\$", "/").     Set<T> result = new HashSet<>().     List<String> keys.     try {         keys = kvClient.getKeys(keyPrefix).     } catch (ConsulException e) {         return result.     }     if (keys != null) {         Object obj.         for (String key : keys) {             // change bookmark back into actual key             key = key.substring(key.lastIndexOf('/') + 1).             obj = lookupByName(key.replaceAll("\\$", "/")).             if (type.isInstance(obj)) {                 result.add(type.cast(obj)).             }         }     }     return result. }
false;public;2;4;;@Override public void bind(String id, Object bean) throws RuntimeCamelException {     put(id, bean). }
false;public;1;20;;public void remove(String key) {     // create session to avoid conflicts (not sure if that is safe enough)     SessionClient sessionClient = consul.sessionClient().     String sessionName = "session_" + UUID.randomUUID().toString().     SessionCreatedResponse response = sessionClient.createSession(ImmutableSession.builder().name(sessionName).build()).     String sessionId = response.getId().     kvClient = consul.keyValueClient().     String lockKey = "lock_" + key.     kvClient.acquireLock(lockKey, sessionName, sessionId).     Object object = lookupByName(key).     if (object == null) {         String msg = "Bean with key '" + key + "' did not exist in Consul Registry.".         throw new NoSuchBeanException(msg).     }     kvClient.deleteKey(key).     kvClient.deleteKey(object.getClass().getName() + "/" + key).     kvClient.releaseLock(lockKey, sessionId). }
false;public;2;28;;public void put(String key, Object object) {     // Substitute $ character in key     key = key.replaceAll("\\$", "/").     // create session to avoid conflicts     // (not sure if that is safe enough, again)     SessionClient sessionClient = consul.sessionClient().     String sessionName = "session_" + UUID.randomUUID().toString().     SessionCreatedResponse response = sessionClient.createSession(ImmutableSession.builder().name(sessionName).build()).     String sessionId = response.getId().     kvClient = consul.keyValueClient().     String lockKey = "lock_" + key.     kvClient.acquireLock(lockKey, sessionName, sessionId).     // Allow only unique keys, last one wins     if (lookupByName(key) != null) {         remove(key).     }     Object clone = ConsulRegistryUtils.clone((Serializable) object).     byte[] serializedObject = ConsulRegistryUtils.serialize((Serializable) clone).     // pre-encode due native encoding issues     String value = ConsulRegistryUtils.encodeBase64(serializedObject).     // store the actual class     kvClient.putValue(key, value).     // store just as a bookmark     kvClient.putValue(object.getClass().getName().replaceAll("\\$", "/") + "/" + key, "1").     kvClient.releaseLock(lockKey, sessionId). }
false;public;1;4;;public Builder port(Integer port) {     this.port = port.     return this. }
false;public;0;3;;public ConsulRegistry build() {     return new ConsulRegistry(this). }
false;public;0;3;;public String getHostname() {     return hostname. }
false;public;1;3;;public void setHostname(String hostname) {     this.hostname = hostname. }
false;public;0;3;;public int getPort() {     return port. }
false;public;1;3;;public void setPort(int port) {     this.port = port. }
true;static;1;3;/**  * Decodes using Base64.  *  * @param base64String the {@link String} to decode  * @return a decoded data as a byte array  */ ;/**  * Decodes using Base64.  *  * @param base64String the {@link String} to decode  * @return a decoded data as a byte array  */ static byte[] decodeBase64(final String base64String) {     return Base64.getDecoder().decode(base64String.getBytes(StandardCharsets.ISO_8859_1)). }
true;static;1;4;/**  * Encodes using Base64.  *  * @param binaryData the data to encode  * @return an encoded data as a {@link String}  */ ;/**  * Encodes using Base64.  *  * @param binaryData the data to encode  * @return an encoded data as a {@link String}  */ static String encodeBase64(final byte[] binaryData) {     final byte[] encoded = Base64.getEncoder().encode(binaryData).     return new String(encoded, StandardCharsets.ISO_8859_1). }
true;static;1;7;/**  * Deserializes an object out of the given byte array.  *  * @param bytes the byte array to deserialize from  * @return an {@link Object} deserialized from the given byte array  */ ;/**  * Deserializes an object out of the given byte array.  *  * @param bytes the byte array to deserialize from  * @return an {@link Object} deserialized from the given byte array  */ static Object deserialize(byte[] bytes) {     try (ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes))) {         return in.readObject().     } catch (IOException | ClassNotFoundException e) {         throw new RuntimeException(e).     } }
true;static;1;3;/**  * A deep serialization based clone  *  * @param object the object to clone  * @return a deep clone  */ ;/**  * A deep serialization based clone  *  * @param object the object to clone  * @return a deep clone  */ static Object clone(Serializable object) {     return deserialize(serialize(object)). }
true;static;1;8;/**  * Serializes the given {@code serializable} using Java Serialization  * @param serializable  * @return the serialized object as a byte array  */ ;/**  * Serializes the given {@code serializable} using Java Serialization  * @param serializable  * @return the serialized object as a byte array  */ static byte[] serialize(Serializable serializable) {     try (ByteArrayOutputStream baos = new ByteArrayOutputStream(512).         ObjectOutputStream out = new ObjectOutputStream(baos)) {         out.writeObject(serializable).         return baos.toByteArray().     } catch (IOException e) {         throw new RuntimeException(e).     } }
