commented;modifiers;parameterAmount;loc;comment;code
true;public;1;19;/**  * The incoming message is expected to be either  * - a List of Exchanges (aggregated)  * - an Exchange  */ ;/**  * The incoming message is expected to be either  * - a List of Exchanges (aggregated)  * - an Exchange  */ @Override public void process(Exchange exchange) throws Exception {     List<Exchange> entryList = prepareExchangeList(exchange).     if (entryList == null || entryList.size() == 0) {         logger.warn("The incoming message is either null or empty. Triggered by an aggregation timeout?").         return.     }     if (logger.isDebugEnabled()) {         logger.debug("uploader thread/id: " + Thread.currentThread().getId() + " / " + exchange.getExchangeId() + " . api call completed.").     }     sendMessages(entryList). }
true;private,static;1;13;/**  * The method converts a single incoming message into a List  *  * @param exchange  * @return  */ ;/**  * The method converts a single incoming message into a List  *  * @param exchange  * @return  */ private static List<Exchange> prepareExchangeList(Exchange exchange) {     List<Exchange> entryList = null.     if (null == exchange.getProperty(Exchange.GROUPED_EXCHANGE)) {         entryList = new ArrayList<>().         entryList.add(exchange).     } else {         entryList = (List<Exchange>) exchange.getProperty(Exchange.GROUPED_EXCHANGE).     }     return entryList. }
false;private;1;45;;private void sendMessages(List<Exchange> exchanges) throws Exception {     GooglePubsubEndpoint endpoint = (GooglePubsubEndpoint) getEndpoint().     String topicName = String.format("projects/%s/topics/%s", endpoint.getProjectId(), endpoint.getDestinationName()).     List<PubsubMessage> messages = new ArrayList<>().     for (Exchange exchange : exchanges) {         PubsubMessage message = new PubsubMessage().         Object body = exchange.getIn().getBody().         if (body instanceof String) {             message.encodeData(((String) body).getBytes("UTF-8")).         } else if (body instanceof byte[]) {             message.encodeData((byte[]) body).         } else {             message.encodeData(serialize(body)).         }         Object attributes = exchange.getIn().getHeader(GooglePubsubConstants.ATTRIBUTES).         if (attributes != null && attributes instanceof Map && ((Map) attributes).size() > 0) {             message.setAttributes((Map) attributes).         }         messages.add(message).     }     PublishRequest publishRequest = new PublishRequest().setMessages(messages).     PublishResponse response = endpoint.getPubsub().projects().topics().publish(topicName, publishRequest).execute().     List<String> sentMessageIds = response.getMessageIds().     int i = 0.     for (Exchange entry : exchanges) {         entry.getIn().setHeader(GooglePubsubConstants.MESSAGE_ID, sentMessageIds.get(i)).         i++.     } }
false;public,static;1;6;;public static byte[] serialize(Object obj) throws IOException {     ByteArrayOutputStream out = new ByteArrayOutputStream().     ObjectOutputStream os = new ObjectOutputStream(out).     os.writeObject(obj).     return out.toByteArray(). }
