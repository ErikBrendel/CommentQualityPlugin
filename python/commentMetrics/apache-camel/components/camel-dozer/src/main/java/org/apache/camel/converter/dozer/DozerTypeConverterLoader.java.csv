commented;modifiers;parameterAmount;loc;comment;code
true;public;2;70;/**  * Doses the actual querying and registration of {@link DozerTypeConverter}s  * with the {@link CamelContext}.  *  * @param camelContext the context to register the  *                     {@link DozerTypeConverter} in  * @param mapper       the DozerMapperBean to be wrapped as a type converter.  */ ;/**  * Doses the actual querying and registration of {@link DozerTypeConverter}s  * with the {@link CamelContext}.  *  * @param camelContext the context to register the  *                     {@link DozerTypeConverter} in  * @param mapper       the DozerMapperBean to be wrapped as a type converter.  */ public void init(CamelContext camelContext, Mapper mapper) {     this.camelContext = camelContext.     if (mapper != null) {         this.mapper = mapper.     }     ClassLoader tccl = Thread.currentThread().getContextClassLoader().     try {         ClassLoader appcl = camelContext.getApplicationContextClassLoader().         if (appcl != null) {             Thread.currentThread().setContextClassLoader(appcl).         }         Map<String, Mapper> mappers = lookupDozerBeanMappers().         // only add if we do not already have it         if (mapper != null && !mappers.containsValue(mapper)) {             mappers.put("parameter", mapper).         }         // add any dozer bean mapper configurations         Map<String, DozerBeanMapperConfiguration> configurations = lookupDozerBeanMapperConfigurations().         if (configurations != null && configuration != null) {             // filter out existing configuration, as we do not want to use it twice             String key = null.             for (Map.Entry<String, DozerBeanMapperConfiguration> entry : configurations.entrySet()) {                 if (entry.getValue() == configuration) {                     key = entry.getKey().                     break.                 }             }             if (key != null) {                 configurations.remove(key).             }         }         if (configurations != null) {             for (Map.Entry<String, DozerBeanMapperConfiguration> entry : configurations.entrySet()) {                 String id = entry.getKey().                 MapperFactory factory = new MapperFactory(getCamelContext(), entry.getValue()).                 Mapper beanMapper = factory.create().                 // only add if we do not already have it                 if (!mappers.containsValue(beanMapper)) {                     mappers.put(id, beanMapper).                 }             }         }         log.info("Loaded {} Dozer mappers from Camel registry.", mappers.size()).         if (mappers.size() == 0) {             log.warn("No Dozer mappers found in Camel registry. You should add Dozer mappers as beans to the registry of the type: {}", Mapper.class.getName()).         }         TypeConverterRegistry registry = camelContext.getTypeConverterRegistry().         for (Map.Entry<String, Mapper> entry : mappers.entrySet()) {             String mapperId = entry.getKey().             Mapper dozer = entry.getValue().             MappingMetadata meta = dozer.getMappingMetadata().             List<ClassMappingMetadata> all = meta.getClassMappings().             registerClassMaps(registry, mapperId, dozer, all).         }     } finally {         Thread.currentThread().setContextClassLoader(tccl).     } }
true;protected;0;3;/**  * Lookup the dozer {@link Mapper} to be used.  */ ;/**  * Lookup the dozer {@link Mapper} to be used.  */ protected Map<String, Mapper> lookupDozerBeanMappers() {     return new HashMap<>(camelContext.getRegistry().findByTypeWithName(Mapper.class)). }
true;protected;0;3;/**  * Lookup the dozer {@link DozerBeanMapperConfiguration} to be used.  */ ;/**  * Lookup the dozer {@link DozerBeanMapperConfiguration} to be used.  */ protected Map<String, DozerBeanMapperConfiguration> lookupDozerBeanMapperConfigurations() {     return new HashMap<>(camelContext.getRegistry().findByTypeWithName(DozerBeanMapperConfiguration.class)). }
false;protected;4;11;;protected void registerClassMaps(TypeConverterRegistry registry, String dozerId, Mapper dozer, List<ClassMappingMetadata> all) {     DozerTypeConverter converter = new DozerTypeConverter(dozer).     for (ClassMappingMetadata map : all) {         addDozerTypeConverter(registry, converter, dozerId, map.getSourceClass(), map.getDestinationClass()).         // if not one way then add the other way around also         if (map.getMappingDirection() != ONE_WAY) {             addDozerTypeConverter(registry, converter, dozerId, map.getDestinationClass(), map.getSourceClass()).         }     } }
false;protected;5;12;;protected void addDozerTypeConverter(TypeConverterRegistry registry, DozerTypeConverter converter, String dozerId, Class<?> to, Class<?> from) {     if (log.isInfoEnabled()) {         if (dozerId != null) {             log.info("Added Dozer: {} as Camel type converter: {} -> {}", new Object[] { dozerId, from, to }).         } else {             log.info("Added Dozer as Camel type converter: {} -> {}", new Object[] { from, to }).         }     }     registry.addTypeConverter(from, to, converter). }
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
true;public;1;10;/**  * Sets the {@link CamelContext} <b>and also</b> initializes this loader.  * <p/>  * The reason why {@link #init(org.apache.camel.CamelContext, com.github.dozermapper.core.Mapper)} is also called  * is because making using Dozer in Spring XML files easier, as no need to use the init-method attribute.  *  * @param camelContext the CamelContext  */ ;/**  * Sets the {@link CamelContext} <b>and also</b> initializes this loader.  * <p/>  * The reason why {@link #init(org.apache.camel.CamelContext, com.github.dozermapper.core.Mapper)} is also called  * is because making using Dozer in Spring XML files easier, as no need to use the init-method attribute.  *  * @param camelContext the CamelContext  */ public void setCamelContext(CamelContext camelContext) {     if (this.camelContext == null) {         this.camelContext = camelContext.         try {             camelContext.addService(this).         } catch (Exception e) {             throw RuntimeCamelException.wrapRuntimeCamelException(e).         }     } }
false;public;0;3;;public Mapper getMapper() {     return mapper. }
false;public;1;3;;public void setMapper(Mapper mapper) {     this.mapper = mapper. }
false;protected,static;2;13;;protected static URL loadMappingFile(ClassResolver classResolver, String mappingFile) {     URL url = null.     try {         url = ResourceHelper.resolveResourceAsUrl(classResolver, mappingFile).     } catch (MalformedURLException e) {     // ignore     }     if (url == null) {         // using the classloader of DozerClassLoader as a fallback         url = DozerClassLoader.class.getClassLoader().getResource(mappingFile).     }     return url. }
false;protected;0;4;;@Override protected void doStart() throws Exception {     init(camelContext, mapper). }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
