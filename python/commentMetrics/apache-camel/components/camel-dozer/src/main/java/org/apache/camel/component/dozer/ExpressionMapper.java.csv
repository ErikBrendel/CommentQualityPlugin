commented;modifiers;parameterAmount;loc;comment;code
false;public;4;33;;@Override public Object convert(Object existingDestinationFieldValue, Object sourceFieldValue, Class<?> destinationClass, Class<?> sourceClass) {     try {         if (currentExchange.get() == null) {             throw new IllegalStateException("Current exchange has not been set for ExpressionMapper").         }         Expression exp.         // Resolve the language being used for this expression and evaluate         Exchange exchange = currentExchange.get().         Language expLang = exchange.getContext().resolveLanguage(getLanguagePart()).         String scheme = getSchemePart().         if (scheme != null && (scheme.equalsIgnoreCase("classpath") || scheme.equalsIgnoreCase("file") || scheme.equalsIgnoreCase("http"))) {             String path = getPathPart().             try {                 exp = expLang.createExpression(resolveScript(scheme + ":" + path)).             } catch (IOException e) {                 throw new IllegalStateException("Expression script specified but not found", e).             }         } else {             exp = expLang.createExpression(getExpressionPart()).         }         return exp.evaluate(exchange, destinationClass).     } finally {         done().     } }
true;protected;1;12;/**  * Resolves the script.  *  * @param script script or uri for a script to load  * @return the script  * @throws IOException is thrown if error loading the script  */ ;/**  * Resolves the script.  *  * @param script script or uri for a script to load  * @return the script  * @throws IOException is thrown if error loading the script  */ protected String resolveScript(String script) throws IOException {     String answer.     if (ResourceHelper.hasScheme(script)) {         InputStream is = loadResource(script).         answer = currentExchange.get().getContext().getTypeConverter().convertTo(String.class, is).         IOHelper.close(is).     } else {         answer = script.     }     return answer. }
true;protected;1;3;/**  * Loads the given resource.  *  * @param uri uri of the resource.  * @return the loaded resource  * @throws IOException is thrown if resource is not found or cannot be loaded  */ ;/**  * Loads the given resource.  *  * @param uri uri of the resource.  * @return the loaded resource  * @throws IOException is thrown if resource is not found or cannot be loaded  */ protected InputStream loadResource(String uri) throws IOException {     return ResourceHelper.resolveMandatoryResourceAsInputStream(currentExchange.get().getContext(), uri). }
true;public;0;3;/**  * Used as the source field for Dozer mappings.  */ ;/**  * Used as the source field for Dozer mappings.  */ public String getExpression() {     return getParameter(). }
true;public;0;3;/**  * The actual expression, without the language prefix.  */ ;/**  * The actual expression, without the language prefix.  */ public String getExpressionPart() {     return getParameter().substring(getParameter().indexOf(":") + 1). }
true;public;0;3;/**  * The expression language used for this mapping.  */ ;/**  * The expression language used for this mapping.  */ public String getLanguagePart() {     return getParameter().substring(0, getParameter().indexOf(":")). }
true;public;1;3;/**  * Sets the Camel exchange reference for this mapping.  The exchange  * reference is stored in a thread-local which is cleaned up after the  * mapping has been performed via the done() method.  * @param exchange  */ ;/**  * Sets the Camel exchange reference for this mapping.  The exchange  * reference is stored in a thread-local which is cleaned up after the  * mapping has been performed via the done() method.  * @param exchange  */ public void setCurrentExchange(Exchange exchange) {     currentExchange.set(exchange). }
true;public;0;3;/**  * The scheme used for this mapping's resource file (classpath, file, http).  */ ;/**  * The scheme used for this mapping's resource file (classpath, file, http).  */ public String getSchemePart() {     return getParameterPart(":", 1). }
true;public;0;3;/**  * The path used for this mapping's resource file.  */ ;/**  * The path used for this mapping's resource file.  */ public String getPathPart() {     return getParameterPart(":", 2). }
true;private;2;8;/*      * Parse the URI to get at one of the parameters.      * @param separator      * @param idx      * @return      */ ;/*      * Parse the URI to get at one of the parameters.      * @param separator      * @param idx      * @return      */ private String getParameterPart(String separator, int idx) {     String part = null.     String[] parts = getParameter().split(separator).     if (parts.length > idx) {         part = parts[idx].     }     return part. }
