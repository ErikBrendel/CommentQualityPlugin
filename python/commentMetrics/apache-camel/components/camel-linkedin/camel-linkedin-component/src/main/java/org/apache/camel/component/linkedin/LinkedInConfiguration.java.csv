commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public LinkedInApiName getApiName() {     return apiName. }
true;public;1;3;/**  * What kind of operation to perform  */ ;/**  * What kind of operation to perform  */ public void setApiName(LinkedInApiName apiName) {     this.apiName = apiName. }
false;public;0;3;;public String getMethodName() {     return methodName. }
true;public;1;3;/**  * What sub operation to use for the selected operation  */ ;/**  * What sub operation to use for the selected operation  */ public void setMethodName(String methodName) {     this.methodName = methodName. }
false;public;0;3;;public String getUserName() {     return userName. }
true;public;1;3;/**  * LinkedIn user account name, MUST be provided  */ ;/**  * LinkedIn user account name, MUST be provided  */ public void setUserName(String userName) {     this.userName = userName. }
false;public;0;3;;public String getUserPassword() {     return userPassword. }
true;public;1;3;/**  * LinkedIn account password  */ ;/**  * LinkedIn account password  */ public void setUserPassword(String userPassword) {     this.userPassword = userPassword. }
false;public;0;3;;public OAuthSecureStorage getSecureStorage() {     return secureStorage. }
false;public;0;3;;public String getAccessToken() {     return accessToken. }
true;public;1;3;/**  * LinkedIn access token to avoid username and password login procedure.  * LinkedIn responds to login forms by using a CAPTCHA. This makes it impossible  * for a standalone, headless process to log in to LinkedIn by specifying a username and password.  * To work around this, obtain a LinkedIn access token and provide the token as  * the setting of the accessToken parameter.  *  * Obtaining a LinkedIn access token is a multi-step procedure. You must configure your  * LinkedIn application, obtain a LinkedIn authorization code, and exchange that  * code for the LinkedIn access token. For details, see: https://developer.linkedin.com/docs/oauth2  *  * The default behavior is that the access token expires after 60 days. To change this, specify a value  * for the expiryTime paramter. If the access token expires, the LinkedIn component tries to log in to  * LinkedIn by providing a username and password, which results in a CAPTCHA so the login fails.  * The LinkedIn component cannot refresh the access token. You must manually obtain a new access token  * each time an access token expires. When you update the access token you must restart the application  * so that it uses the new token.  */ ;/**  * LinkedIn access token to avoid username and password login procedure.  * LinkedIn responds to login forms by using a CAPTCHA. This makes it impossible  * for a standalone, headless process to log in to LinkedIn by specifying a username and password.  * To work around this, obtain a LinkedIn access token and provide the token as  * the setting of the accessToken parameter.  *  * Obtaining a LinkedIn access token is a multi-step procedure. You must configure your  * LinkedIn application, obtain a LinkedIn authorization code, and exchange that  * code for the LinkedIn access token. For details, see: https://developer.linkedin.com/docs/oauth2  *  * The default behavior is that the access token expires after 60 days. To change this, specify a value  * for the expiryTime paramter. If the access token expires, the LinkedIn component tries to log in to  * LinkedIn by providing a username and password, which results in a CAPTCHA so the login fails.  * The LinkedIn component cannot refresh the access token. You must manually obtain a new access token  * each time an access token expires. When you update the access token you must restart the application  * so that it uses the new token.  */ public void setAccessToken(String accessToken) {     this.accessToken = accessToken. }
false;public;0;3;;public Long getExpiryTime() {     return expiryTime. }
true;public;1;3;/**  * A number of milliseconds since the UNIX Epoch. The default is 60 days.  * A LinkedIn access token expires when this amount of time elapses after the token is in use.  */ ;/**  * A number of milliseconds since the UNIX Epoch. The default is 60 days.  * A LinkedIn access token expires when this amount of time elapses after the token is in use.  */ public void setExpiryTime(Long expiryTime) {     this.expiryTime = expiryTime. }
true;public;1;3;/**  * Callback interface for providing an OAuth token or to store the token generated by the component.  * The callback should return null on the first call and then save the created token in the saveToken() callback.  * If the callback returns null the first time, a userPassword MUST be provided.  */ ;/**  * Callback interface for providing an OAuth token or to store the token generated by the component.  * The callback should return null on the first call and then save the created token in the saveToken() callback.  * If the callback returns null the first time, a userPassword MUST be provided.  */ public void setSecureStorage(OAuthSecureStorage secureStorage) {     this.secureStorage = secureStorage. }
false;public;0;3;;public String getClientId() {     return clientId. }
true;public;1;3;/**  * LinkedIn application client ID  */ ;/**  * LinkedIn application client ID  */ public void setClientId(String clientId) {     this.clientId = clientId. }
false;public;0;3;;public String getClientSecret() {     return clientSecret. }
true;public;1;3;/**  * LinkedIn application client secret  */ ;/**  * LinkedIn application client secret  */ public void setClientSecret(String clientSecret) {     this.clientSecret = clientSecret. }
false;public;0;3;;public OAuthScope[] getScopes() {     return scopes. }
true;public;1;3;/**  * List of LinkedIn scopes as specified at https://developer.linkedin.com/documents/authentication#granting  */ ;/**  * List of LinkedIn scopes as specified at https://developer.linkedin.com/documents/authentication#granting  */ public void setScopes(OAuthScope[] scopes) {     this.scopes = scopes. }
false;public;0;3;;public String getRedirectUri() {     return redirectUri. }
true;public;1;3;/**  * Application redirect URI, although the component never redirects to this page to avoid having to have a functioning redirect server.  * For testing, one could use https://localhost.  */ ;/**  * Application redirect URI, although the component never redirects to this page to avoid having to have a functioning redirect server.  * For testing, one could use https://localhost.  */ public void setRedirectUri(String redirectUri) {     this.redirectUri = redirectUri. }
false;public;0;3;;public Map<String, Object> getHttpParams() {     return httpParams. }
true;public;1;3;/**  * Custom HTTP parameters, for example, proxy host and port. Use constants from AllClientPNames.  */ ;/**  * Custom HTTP parameters, for example, proxy host and port. Use constants from AllClientPNames.  */ public void setHttpParams(Map<String, Object> httpParams) {     this.httpParams = httpParams. }
false;public;0;3;;public boolean isLazyAuth() {     return lazyAuth. }
true;public;1;3;/**  * Flag to enable/disable lazy OAuth, default is true. When enabled, OAuth token retrieval or generation is not done until the first REST call.  */ ;/**  * Flag to enable/disable lazy OAuth, default is true. When enabled, OAuth token retrieval or generation is not done until the first REST call.  */ public void setLazyAuth(boolean lazyAuth) {     this.lazyAuth = lazyAuth. }
false;public;1;16;;@Override public boolean equals(Object obj) {     if (obj instanceof LinkedInConfiguration) {         final LinkedInConfiguration other = (LinkedInConfiguration) obj.         return (userName == null ? other.userName == null : userName.equals(other.userName)) && (userPassword == null ? other.userPassword == null : userPassword.equals(other.userPassword)) && secureStorage == other.secureStorage && (clientId == null ? other.clientId == null : clientId.equals(other.clientId)) && (clientSecret == null ? other.clientSecret == null : clientSecret.equals(other.clientSecret)) && (redirectUri == null ? other.redirectUri == null : redirectUri.equals(other.redirectUri)) && Arrays.equals(scopes, other.scopes) && (httpParams == null ? other.httpParams == null : httpParams.equals(other.httpParams)) && (lazyAuth == other.lazyAuth).     }     return false. }
false;public;0;6;;@Override public int hashCode() {     return new HashCodeBuilder().append(userName).append(userPassword).append(secureStorage).append(clientId).append(clientSecret).append(redirectUri).append(scopes).append(httpParams).append(lazyAuth).toHashCode(). }
false;public;0;9;;public void validate() throws IllegalArgumentException {     StringHelper.notEmpty(userName, "userName").     if (ObjectHelper.isEmpty(userPassword) && secureStorage == null) {         throw new IllegalArgumentException("Property userPassword or secureStorage is required").     }     StringHelper.notEmpty(clientId, "clientId").     StringHelper.notEmpty(clientSecret, "clientSecret").     StringHelper.notEmpty(redirectUri, "redirectUri"). }
