commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Producer createProducer() throws Exception {     return new LinkedInProducer(this). }
false;public;1;10;;public Consumer createConsumer(Processor processor) throws Exception {     // make sure inBody is not set for consumers     if (inBody != null) {         throw new IllegalArgumentException("Option inBody is not supported for consumer endpoint").     }     final LinkedInConsumer consumer = new LinkedInConsumer(this, processor).     // also set consumer.* properties     configureConsumer(consumer).     return consumer. }
false;protected;0;4;;@Override protected ApiMethodPropertiesHelper<LinkedInConfiguration> getPropertiesHelper() {     return LinkedInPropertiesHelper.getHelper(). }
false;protected;0;3;;protected String getThreadProfileName() {     return LinkedInConstants.THREAD_PROFILE_NAME. }
false;protected;0;4;;@Override protected void afterConfigureProperties() {     createProxy(). }
true;private;0;37;// create API proxy, set connection properties, etc. ;// create API proxy, set connection properties, etc. private void createProxy() {     // create endpoint filter or get shared filter if configuration values are same as component     requestFilter = getComponent().getRequestFilter(configuration).     final Class<?> proxyClass.     switch(apiName) {         case COMMENTS:             proxyClass = CommentsResource.class.             break.         case COMPANIES:             proxyClass = CompaniesResource.class.             break.         case GROUPS:             proxyClass = GroupsResource.class.             break.         case JOBS:             proxyClass = JobsResource.class.             break.         case PEOPLE:             proxyClass = PeopleResource.class.             break.         case POSTS:             proxyClass = PostsResource.class.             break.         case SEARCH:             proxyClass = SearchResource.class.             break.         default:             throw new IllegalArgumentException("Invalid API name " + apiName).     }     // create endpoint proxy     Bus bus = BusFactory.getThreadDefaultBus().     bus.setProperty("allow.empty.path.template.value", true).     resourceProxy = JAXRSClientFactory.create(LinkedInOAuthRequestFilter.BASE_ADDRESS, proxyClass, Arrays.asList(new Object[] { requestFilter, new EnumQueryParamConverterProvider() })). }
false;public;2;4;;@Override public Object getApiProxy(ApiMethod method, Map<String, Object> args) {     return resourceProxy. }
false;protected;0;8;;@Override protected void doStart() throws Exception {     super.doStart().     if (resourceProxy == null) {         createProxy().     } }
false;protected;0;18;;@Override protected void doStop() throws Exception {     super.doStop().     if (resourceProxy != null) {         try {             WebClient.client(resourceProxy).close().         } catch (Exception e) {             log.warn("Error closing LinkedIn REST proxy: {}", e.getMessage(), e).         }         resourceProxy = null.     }     if (requestFilter != null) {         getComponent().closeRequestFilter(requestFilter).         requestFilter = null.     } }
false;public;0;4;;@Override public LinkedInComponent getComponent() {     return (LinkedInComponent) super.getComponent(). }
false;public;1;6;;@Override public void interceptProperties(Map<String, Object> properties) {     if (!properties.containsKey(FIELDS_OPTION)) {         properties.put(FIELDS_OPTION, DEFAULT_FIELDS_SELECTOR).     } }
