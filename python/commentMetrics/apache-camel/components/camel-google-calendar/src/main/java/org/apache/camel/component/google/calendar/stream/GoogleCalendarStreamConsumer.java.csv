commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;3;;protected GoogleCalendarStreamConfiguration getConfiguration() {     return getEndpoint().getConfiguration(). }
false;protected;0;3;;protected Calendar getClient() {     return getEndpoint().getClient(). }
false;public;0;4;;@Override public GoogleCalendarStreamEndpoint getEndpoint() {     return (GoogleCalendarStreamEndpoint) super.getEndpoint(). }
false;protected;0;37;;@Override protected int poll() throws Exception {     com.google.api.services.calendar.Calendar.Events.List request = getClient().events().list(getConfiguration().getCalendarId()).setOrderBy("updated").     if (ObjectHelper.isNotEmpty(getConfiguration().getQuery())) {         request.setQ(getConfiguration().getQuery()).     }     if (ObjectHelper.isNotEmpty(getConfiguration().getMaxResults())) {         request.setMaxResults(getConfiguration().getMaxResults()).     }     if (getConfiguration().isConsumeFromNow()) {         Date date = new Date().         request.setTimeMin(new DateTime(date)).     }     if (getConfiguration().isConsiderLastUpdate()) {         if (ObjectHelper.isNotEmpty(lastUpdate)) {             request.setUpdatedMin(lastUpdate).         }     }     Queue<Exchange> answer = new LinkedList<>().     List<Date> dateList = new ArrayList<>().     Events c = request.execute().     if (c != null) {         List<Event> list = c.getItems().         for (Event event : list) {             Exchange exchange = getEndpoint().createExchange(getEndpoint().getExchangePattern(), event).             answer.add(exchange).             dateList.add(new Date(event.getUpdated().getValue())).         }     }     lastUpdate = retrieveLastUpdateDate(dateList).     return processBatch(CastUtils.cast(answer)). }
false;private;1;14;;private DateTime retrieveLastUpdateDate(List<Date> dateList) {     Date finalLastUpdate.     if (!dateList.isEmpty()) {         dateList.sort((o1, o2) -> o1.compareTo(o2)).         Date lastUpdateDate = dateList.get(dateList.size() - 1).         java.util.Calendar calendar = java.util.Calendar.getInstance().         calendar.setTime(lastUpdateDate).         calendar.add(java.util.Calendar.SECOND, 1).         finalLastUpdate = calendar.getTime().     } else {         finalLastUpdate = new Date().     }     return new DateTime(finalLastUpdate). }
false;public;1;4;;@Override public void done(boolean doneSync) {     log.trace("Processing exchange done"). }
false;public;1;24;;@Override public int processBatch(Queue<Object> exchanges) throws Exception {     int total = exchanges.size().     for (int index = 0. index < total && isBatchAllowed(). index++) {         // only loop if we are started (allowed to run)         final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll()).         // add current index and total as properties         exchange.setProperty(Exchange.BATCH_INDEX, index).         exchange.setProperty(Exchange.BATCH_SIZE, total).         exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1).         // update pending number of exchanges         pendingExchanges = total - index - 1.         getAsyncProcessor().process(exchange, new AsyncCallback() {              @Override             public void done(boolean doneSync) {                 log.trace("Processing exchange done").             }         }).     }     return total. }
