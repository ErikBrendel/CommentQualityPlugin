commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public ServletComponent getComponent() {     return (ServletComponent) super.getComponent(). }
false;public;0;23;;@Override public HttpBinding getHttpBinding() {     // make sure we include servlet variant of the http binding     if (this.binding == null) {         // is attachment binding enabled?         if (isAttachmentMultipartBinding()) {             this.binding = new AttachmentHttpBinding().         } else {             this.binding = new DefaultHttpBinding().         }         this.binding.setFileNameExtWhitelist(getFileNameExtWhitelist()).         this.binding.setTransferException(isTransferException()).         if (getComponent() != null) {             this.binding.setAllowJavaSerializedObject(getComponent().isAllowJavaSerializedObject()).         }         this.binding.setHeaderFilterStrategy(getHeaderFilterStrategy()).         this.binding.setEagerCheckContentAvailable(isEagerCheckContentAvailable()).         this.binding.setMapHttpMessageBody(isMapHttpMessageBody()).         this.binding.setMapHttpMessageHeaders(isMapHttpMessageHeaders()).         this.binding.setMapHttpMessageFormUrlEncodedBody(isMapHttpMessageFormUrlEncodedBody()).     }     return this.binding. }
false;public;1;5;;@Override public void setHttpBinding(HttpBinding binding) {     super.setHttpBinding(binding).     this.binding = binding. }
false;public;0;3;;public String getContextPath() {     return contextPath. }
true;public;1;3;/**  * The context-path to use  */ ;/**  * The context-path to use  */ public void setContextPath(String contextPath) {     this.contextPath = contextPath. }
true;public;1;3;/**  * Name of the servlet to use  */ ;/**  * Name of the servlet to use  */ public void setServletName(String name) {     servletName = name. }
false;public;0;3;;public String getServletName() {     return servletName. }
false;public;0;3;;public boolean isAttachmentMultipartBinding() {     return attachmentMultipartBinding. }
true;public;1;3;/**  * Whether to automatic bind multipart/form-data as attachments on the Camel {@link Exchange}.  * <p/>  * The options attachmentMultipartBinding=true and disableStreamCache=false cannot work together.  * Remove disableStreamCache to use AttachmentMultipartBinding.  * <p/>  * This is turn off by default as this may require servlet specific configuration to enable this when using Servlet's.  */ ;/**  * Whether to automatic bind multipart/form-data as attachments on the Camel {@link Exchange}.  * <p/>  * The options attachmentMultipartBinding=true and disableStreamCache=false cannot work together.  * Remove disableStreamCache to use AttachmentMultipartBinding.  * <p/>  * This is turn off by default as this may require servlet specific configuration to enable this when using Servlet's.  */ public void setAttachmentMultipartBinding(boolean attachmentMultipartBinding) {     this.attachmentMultipartBinding = attachmentMultipartBinding. }
false;public;0;3;;public String getFileNameExtWhitelist() {     return fileNameExtWhitelist. }
true;public;1;3;/**  * Whitelist of accepted filename extensions for accepting uploaded files.  * <p/>  * Multiple extensions can be separated by comma, such as txt,xml.  */ ;/**  * Whitelist of accepted filename extensions for accepting uploaded files.  * <p/>  * Multiple extensions can be separated by comma, such as txt,xml.  */ public void setFileNameExtWhitelist(String fileNameExtWhitelist) {     this.fileNameExtWhitelist = fileNameExtWhitelist. }
false;public;0;4;;@Override public Producer createProducer() throws Exception {     throw new UnsupportedOperationException("You cannot create producer with servlet endpoint, please consider to use http or http4 endpoint."). }
false;public;1;6;;@Override public Consumer createConsumer(Processor processor) throws Exception {     ServletConsumer answer = new ServletConsumer(this, processor).     configureConsumer(answer).     return answer. }
false;public;0;5;;@Override public boolean isLenientProperties() {     // in contrast to the HttpEndpoint, the ServletEndpoint knows about all it's options on the passed URI     return false. }
