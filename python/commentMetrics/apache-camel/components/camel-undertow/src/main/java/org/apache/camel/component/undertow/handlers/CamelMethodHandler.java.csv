commented;modifiers;parameterAmount;loc;comment;code
false;public;1;19;;@Override public void handleRequest(HttpServerExchange exchange) throws Exception {     HttpHandler handler = null.     /* No need to lock methodMap for read access in this method */     MethodEntry entry = methodMap.get(exchange.getRequestMethod().toString()).     if (entry != null && (handler = entry.handler) != null) {         handler.handleRequest(exchange).     } else {         entry = methodMap.get(DEFAULT_HANDLER_KEY).         if (entry != null && (handler = entry.handler) != null) {             handler.handleRequest(exchange).         } else {             exchange.setStatusCode(StatusCodes.METHOD_NOT_ALLOWED).             exchange.getResponseHeaders().put(ExchangeHeaders.CONTENT_TYPE, MimeMappings.DEFAULT_MIME_MAPPINGS.get("txt")).             exchange.getResponseHeaders().put(ExchangeHeaders.CONTENT_LENGTH, 0).             exchange.endExchange().         }     } }
false;public;2;11;;public HttpHandler add(String methods, HttpHandler handler) {     HttpHandler result = null.     synchronized (methodMap) {         // we lock on methodMap to get a reliable sum of refCounts in remove(String)         for (String method : splitMethods(methods)) {             MethodEntry en = methodMap.computeIfAbsent(method, m -> new MethodEntry()).             result = en.addRef(handler, method).         }     }     handlerString = null.     return result. }
false;public;1;14;;public boolean remove(String methods) {     boolean result.     synchronized (methodMap) {         // we lock on methodMap to get a reliable sum of refCounts         for (String method : splitMethods(methods)) {             final MethodEntry en = methodMap.get(method).             if (en != null) {                 en.removeRef().             }         }         result = methodMap.values().stream().mapToInt(en -> en.refCount).sum() == 0.     }     handlerString = null.     return result. }
false;public;0;6;;public String toString() {     if (handlerString == null) {         handlerString = "CamelMethodHandler[" + methodMap + "]".     }     return handlerString. }
false;private;1;4;;private String[] splitMethods(String methods) {     String[] result = methods != null ? methods.split(",") : DEFAULT_METHODS.     return result.length == 0 ? DEFAULT_METHODS : result. }
false;public;2;13;;public HttpHandler addRef(HttpHandler handler, String method) {     if (this.handler == null) {         this.handler = handler.         refCount++.         return handler.     } else if ("OPTIONS".equals(method) || CamelWebSocketHandler.class == this.handler.getClass() && CamelWebSocketHandler.class == handler.getClass()) {         refCount++.         return this.handler.     } else {         throw new IllegalArgumentException(String.format("Duplicate handler for %s method: '%s', '%s'", method, this.handler, handler)).     } }
false;public;0;5;;public void removeRef() {     if (--refCount == 0) {         this.handler = null.     } }
false;public;0;4;;@Override public String toString() {     return handler == null ? "null" : handler.toString(). }
