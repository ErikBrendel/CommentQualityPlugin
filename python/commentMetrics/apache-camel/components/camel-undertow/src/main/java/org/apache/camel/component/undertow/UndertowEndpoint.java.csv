commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public UndertowComponent getComponent() {     return component. }
false;public;0;4;;@Override public Producer createProducer() throws Exception {     return new UndertowProducer(this, optionMap). }
false;public;1;4;;@Override public Consumer createConsumer(Processor processor) throws Exception {     return new UndertowConsumer(this, processor). }
false;public;0;4;;@Override public PollingConsumer createPollingConsumer() throws Exception {     throw new UnsupportedOperationException("This component does not support polling consumer"). }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;public;0;5;;@Override public boolean isLenientProperties() {     // true to allow dynamic URI options to be configured and passed to external system for eg. the UndertowProducer     return true. }
false;public;0;8;;// Service Registration // ------------------------------------------------------------------------- @Override public Map<String, String> getServiceProperties() {     return CollectionHelper.immutableMapOf(ServiceDefinition.SERVICE_META_PORT, Integer.toString(httpURI.getPort()), ServiceDefinition.SERVICE_META_PATH, httpURI.getPath(), ServiceDefinition.SERVICE_META_PROTOCOL, httpURI.getScheme()). }
false;public;1;11;;public Exchange createExchange(HttpServerExchange httpExchange) throws Exception {     Exchange exchange = createExchange(ExchangePattern.InOut).     Message in = getUndertowHttpBinding().toCamelMessage(httpExchange, exchange).     exchange.setProperty(Exchange.CHARSET_NAME, httpExchange.getRequestCharset()).     in.setHeader(Exchange.HTTP_CHARACTER_ENCODING, httpExchange.getRequestCharset()).     exchange.setIn(in).     return exchange. }
false;public;0;3;;public SSLContext getSslContext() {     return sslContext. }
false;public;0;3;;public URI getHttpURI() {     return httpURI. }
true;public;1;3;/**  * The url of the HTTP endpoint to use.  */ ;/**  * The url of the HTTP endpoint to use.  */ public void setHttpURI(URI httpURI) {     this.httpURI = UndertowHelper.makeHttpURI(httpURI). }
false;public;0;3;;public String getHttpMethodRestrict() {     return httpMethodRestrict. }
true;public;1;3;/**  * Used to only allow consuming if the HttpMethod matches, such as GET/POST/PUT etc. Multiple methods can be specified separated by comma.  */ ;/**  * Used to only allow consuming if the HttpMethod matches, such as GET/POST/PUT etc. Multiple methods can be specified separated by comma.  */ public void setHttpMethodRestrict(String httpMethodRestrict) {     this.httpMethodRestrict = httpMethodRestrict. }
false;public;0;3;;public Boolean getMatchOnUriPrefix() {     return matchOnUriPrefix. }
true;public;1;3;/**  * Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.  */ ;/**  * Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.  */ public void setMatchOnUriPrefix(Boolean matchOnUriPrefix) {     this.matchOnUriPrefix = matchOnUriPrefix. }
false;public;0;3;;public HeaderFilterStrategy getHeaderFilterStrategy() {     return headerFilterStrategy. }
true;public;1;3;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ ;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {     this.headerFilterStrategy = headerFilterStrategy. }
false;public;0;3;;public SSLContextParameters getSslContextParameters() {     return sslContextParameters. }
true;public;1;3;/**  * To configure security using SSLContextParameters  */ ;/**  * To configure security using SSLContextParameters  */ public void setSslContextParameters(SSLContextParameters sslContextParameters) {     this.sslContextParameters = sslContextParameters. }
false;public;0;3;;public Boolean getThrowExceptionOnFailure() {     return throwExceptionOnFailure. }
true;public;1;3;/**  * Option to disable throwing the HttpOperationFailedException in case of failed responses from the remote server.  * This allows you to get all responses regardless of the HTTP status code.  */ ;/**  * Option to disable throwing the HttpOperationFailedException in case of failed responses from the remote server.  * This allows you to get all responses regardless of the HTTP status code.  */ public void setThrowExceptionOnFailure(Boolean throwExceptionOnFailure) {     this.throwExceptionOnFailure = throwExceptionOnFailure. }
false;public;0;3;;public Boolean getTransferException() {     return transferException. }
true;public;1;3;/**  * If enabled and an Exchange failed processing on the consumer side and if the caused Exception  * was send back serialized in the response as a application/x-java-serialized-object content type.  * On the producer side the exception will be deserialized and thrown as is instead of the HttpOperationFailedException. The caused exception is required to be serialized.  * This is by default turned off. If you enable this  * then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk.  */ ;/**  * If enabled and an Exchange failed processing on the consumer side and if the caused Exception  * was send back serialized in the response as a application/x-java-serialized-object content type.  * On the producer side the exception will be deserialized and thrown as is instead of the HttpOperationFailedException. The caused exception is required to be serialized.  * This is by default turned off. If you enable this  * then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk.  */ public void setTransferException(Boolean transferException) {     this.transferException = transferException. }
false;public;0;9;;public UndertowHttpBinding getUndertowHttpBinding() {     if (undertowHttpBinding == null) {         // create a new binding and use the options from this endpoint         undertowHttpBinding = new DefaultUndertowHttpBinding().         undertowHttpBinding.setHeaderFilterStrategy(getHeaderFilterStrategy()).         undertowHttpBinding.setTransferException(getTransferException()).     }     return undertowHttpBinding. }
true;public;1;3;/**  * To use a custom UndertowHttpBinding to control the mapping between Camel message and undertow.  */ ;/**  * To use a custom UndertowHttpBinding to control the mapping between Camel message and undertow.  */ public void setUndertowHttpBinding(UndertowHttpBinding undertowHttpBinding) {     this.undertowHttpBinding = undertowHttpBinding. }
false;public;0;3;;public Boolean getKeepAlive() {     return keepAlive. }
true;public;1;3;/**  * Setting to ensure socket is not closed due to inactivity  */ ;/**  * Setting to ensure socket is not closed due to inactivity  */ public void setKeepAlive(Boolean keepAlive) {     this.keepAlive = keepAlive. }
false;public;0;3;;public Boolean getTcpNoDelay() {     return tcpNoDelay. }
true;public;1;3;/**  * Setting to improve TCP protocol performance  */ ;/**  * Setting to improve TCP protocol performance  */ public void setTcpNoDelay(Boolean tcpNoDelay) {     this.tcpNoDelay = tcpNoDelay. }
false;public;0;3;;public Boolean getReuseAddresses() {     return reuseAddresses. }
true;public;1;3;/**  * Setting to facilitate socket multiplexing  */ ;/**  * Setting to facilitate socket multiplexing  */ public void setReuseAddresses(Boolean reuseAddresses) {     this.reuseAddresses = reuseAddresses. }
false;public;0;3;;public Map<String, Object> getOptions() {     return options. }
true;public;1;3;/**  * Sets additional channel options. The options that can be used are defined in {@link org.xnio.Options}.  * To configure from endpoint uri, then prefix each option with <tt>option.</tt>, such as <tt>option.close-abort=true&option.send-buffer=8192</tt>  */ ;/**  * Sets additional channel options. The options that can be used are defined in {@link org.xnio.Options}.  * To configure from endpoint uri, then prefix each option with <tt>option.</tt>, such as <tt>option.close-abort=true&option.send-buffer=8192</tt>  */ public void setOptions(Map<String, Object> options) {     this.options = options. }
false;public;0;3;;public boolean isOptionsEnabled() {     return optionsEnabled. }
true;public;1;3;/**  * Specifies whether to enable HTTP OPTIONS for this Servlet consumer. By default OPTIONS is turned off.  */ ;/**  * Specifies whether to enable HTTP OPTIONS for this Servlet consumer. By default OPTIONS is turned off.  */ public void setOptionsEnabled(boolean optionsEnabled) {     this.optionsEnabled = optionsEnabled. }
false;public;0;3;;public CookieHandler getCookieHandler() {     return cookieHandler. }
true;public;1;3;/**  * Configure a cookie handler to maintain a HTTP session  */ ;/**  * Configure a cookie handler to maintain a HTTP session  */ public void setCookieHandler(CookieHandler cookieHandler) {     this.cookieHandler = cookieHandler. }
false;public;0;3;;public Boolean getSendToAll() {     return sendToAll. }
true;public;1;3;/**  * To send to all websocket subscribers. Can be used to configure on endpoint level, instead of having to use the  * {@code UndertowConstants.SEND_TO_ALL} header on the message.  */ ;/**  * To send to all websocket subscribers. Can be used to configure on endpoint level, instead of having to use the  * {@code UndertowConstants.SEND_TO_ALL} header on the message.  */ public void setSendToAll(Boolean sendToAll) {     this.sendToAll = sendToAll. }
false;public;0;3;;public Integer getSendTimeout() {     return sendTimeout. }
true;public;1;3;/**  * Timeout in milliseconds when sending to a websocket channel.  * The default timeout is 30000 (30 seconds).  */ ;/**  * Timeout in milliseconds when sending to a websocket channel.  * The default timeout is 30000 (30 seconds).  */ public void setSendTimeout(Integer sendTimeout) {     this.sendTimeout = sendTimeout. }
false;public;0;3;;public boolean isUseStreaming() {     return useStreaming. }
true;public;1;3;/**  * if {@code true}, text and binary messages coming through a WebSocket will be wrapped as java.io.Reader and  * java.io.InputStream respectively before they are passed to an {@link Exchange}. otherwise they will be passed as  * String and byte[] respectively.  */ ;/**  * if {@code true}, text and binary messages coming through a WebSocket will be wrapped as java.io.Reader and  * java.io.InputStream respectively before they are passed to an {@link Exchange}. otherwise they will be passed as  * String and byte[] respectively.  */ public void setUseStreaming(boolean useStreaming) {     this.useStreaming = useStreaming. }
false;public;0;3;;public boolean isFireWebSocketChannelEvents() {     return fireWebSocketChannelEvents. }
true;public;1;3;/**  * if {@code true}, the consumer will post notifications to the route when a new WebSocket peer connects,  * disconnects, etc. See {@code UndertowConstants.EVENT_TYPE} and {@link EventType}.  */ ;/**  * if {@code true}, the consumer will post notifications to the route when a new WebSocket peer connects,  * disconnects, etc. See {@code UndertowConstants.EVENT_TYPE} and {@link EventType}.  */ public void setFireWebSocketChannelEvents(boolean fireWebSocketChannelEvents) {     this.fireWebSocketChannelEvents = fireWebSocketChannelEvents. }
false;protected;0;61;;@Override protected void doStart() throws Exception {     super.doStart().     final String scheme = httpURI.getScheme().     this.isWebSocket = UndertowConstants.WS_PROTOCOL.equalsIgnoreCase(scheme) || UndertowConstants.WSS_PROTOCOL.equalsIgnoreCase(scheme).     if (sslContextParameters != null) {         sslContext = sslContextParameters.createSSLContext(getCamelContext()).     }     // create options map     if (options != null && !options.isEmpty()) {         // favor to use the classloader that loaded the user application         ClassLoader cl = getComponent().getCamelContext().getApplicationContextClassLoader().         if (cl == null) {             cl = Options.class.getClassLoader().         }         OptionMap.Builder builder = OptionMap.builder().         for (Map.Entry<String, Object> entry : options.entrySet()) {             String key = entry.getKey().             Object value = entry.getValue().             if (key != null && value != null) {                 // upper case and dash as underscore                 key = key.toUpperCase(Locale.ENGLISH).replace('-', '_').                 // must be field name                 key = Options.class.getName() + "." + key.                 Option option = Option.fromString(key, cl).                 value = option.parseValue(value.toString(), cl).                 log.trace("Parsed option {}={}", option.getName(), value).                 builder.set(option, value).             }         }         optionMap = builder.getMap().     } else {         // use an empty map         optionMap = OptionMap.EMPTY.     }     // and then configure these default options if they have not been explicit configured     if (keepAlive != null && !optionMap.contains(Options.KEEP_ALIVE)) {         // rebuild map         OptionMap.Builder builder = OptionMap.builder().         builder.addAll(optionMap).set(Options.KEEP_ALIVE, keepAlive).         optionMap = builder.getMap().     }     if (tcpNoDelay != null && !optionMap.contains(Options.TCP_NODELAY)) {         // rebuild map         OptionMap.Builder builder = OptionMap.builder().         builder.addAll(optionMap).set(Options.TCP_NODELAY, tcpNoDelay).         optionMap = builder.getMap().     }     if (reuseAddresses != null && !optionMap.contains(Options.REUSE_ADDRESSES)) {         // rebuild map         OptionMap.Builder builder = OptionMap.builder().         builder.addAll(optionMap).set(Options.REUSE_ADDRESSES, reuseAddresses).         optionMap = builder.getMap().     } }
true;public;0;3;/**  * @return {@code true} if {@link #getHttpURI()}'s scheme is {@code ws} or {@code wss}  */ ;/**  * @return {@code true} if {@link #getHttpURI()}'s scheme is {@code ws} or {@code wss}  */ public boolean isWebSocket() {     return isWebSocket. }
false;public;0;6;;public HttpHandlerRegistrationInfo getHttpHandlerRegistrationInfo() {     if (registrationInfo == null) {         registrationInfo = new HttpHandlerRegistrationInfo(getHttpURI(), getHttpMethodRestrict(), getMatchOnUriPrefix()).     }     return registrationInfo. }
false;public;0;6;;public CamelWebSocketHandler getWebSocketHttpHandler() {     if (webSocketHttpHandler == null) {         webSocketHttpHandler = new CamelWebSocketHandler().     }     return webSocketHttpHandler. }
