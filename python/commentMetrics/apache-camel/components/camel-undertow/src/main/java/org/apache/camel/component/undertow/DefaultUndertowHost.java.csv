commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void validateEndpointURI(URI httpURI) { // all URIs are good }
false;public,synchronized;2;51;;@Override public synchronized HttpHandler registerHandler(HttpHandlerRegistrationInfo registrationInfo, HttpHandler handler) {     if (undertow == null) {         Undertow.Builder builder = Undertow.builder().         if (key.getSslContext() != null) {             builder.addHttpsListener(key.getPort(), key.getHost(), key.getSslContext()).         } else {             builder.addHttpListener(key.getPort(), key.getHost()).         }         if (options != null) {             if (options.getIoThreads() != null) {                 builder.setIoThreads(options.getIoThreads()).             }             if (options.getWorkerThreads() != null) {                 builder.setWorkerThreads(options.getWorkerThreads()).             }             if (options.getBufferSize() != null) {                 builder.setBufferSize(options.getBufferSize()).             }             if (options.getDirectBuffers() != null) {                 builder.setDirectBuffers(options.getDirectBuffers()).             }             if (options.getHttp2Enabled() != null) {                 builder.setServerOption(UndertowOptions.ENABLE_HTTP2, options.getHttp2Enabled()).             }         }         undertow = builder.setHandler(rootHandler).build().         LOG.info("Starting Undertow server on {}://{}:{}", key.getSslContext() != null ? "https" : "http", key.getHost(), key.getPort()).         try {             // If there is an exception while starting up, Undertow wraps it             // as RuntimeException which leaves the consumer in an inconsistent             // state as a subsequent start if the route (i.e. manually) won't             // start the Undertow instance as undertow is not null.             undertow.start().         } catch (RuntimeException e) {             LOG.warn("Failed to start Undertow server on {}://{}:{}, reason: {}", key.getSslContext() != null ? "https" : "http", key.getHost(), key.getPort(), e.getMessage()).             // Cleanup any resource that may have been created during start             // and reset the instance so a subsequent start will trigger the             // initialization again.             undertow.stop().             undertow = null.             throw e.         }     }     return rootHandler.add(registrationInfo.getUri().getPath(), registrationInfo.getMethodRestrict(), registrationInfo.isMatchOnUriPrefix(), handler). }
false;public,synchronized;1;14;;@Override public synchronized void unregisterHandler(HttpHandlerRegistrationInfo registrationInfo) {     if (undertow == null) {         return.     }     rootHandler.remove(registrationInfo.getUri().getPath(), registrationInfo.getMethodRestrict(), registrationInfo.isMatchOnUriPrefix()).     if (rootHandler.isEmpty()) {         LOG.info("Stopping Undertow server on {}://{}:{}", key.getSslContext() != null ? "https" : "http", key.getHost(), key.getPort()).         undertow.stop().         undertow = null.     } }
false;public;0;6;;public String toString() {     if (hostString == null) {         hostString = String.format("DefaultUndertowHost[%s://%s:%s]", key.getSslContext() != null ? "https" : "http", key.getHost(), key.getPort()).     }     return hostString. }
