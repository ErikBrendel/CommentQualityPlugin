commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void completed(final T result) {     consumer.accept(result). }
false;public;1;4;;@Override public void failed(final IOException e) {     hasFailedWith(e). }
false;public;1;9;;@Override public void completed(final ClientConnection connection) {     // we have established connection, make sure we close it     deferClose(connection).     // now we can send the request and perform the exchange: writing the     // request and reading the response     connection.sendRequest(request, on(this::performClientExchange)). }
false;public;1;4;;@Override public void failed(final IOException e) {     hasFailedWith(e). }
false;;1;15;;ChannelListener<StreamSinkChannel> asyncWriter(final ByteBuffer body) {     return channel -> {         try {             write(channel, body).             if (body.hasRemaining()) {                 channel.resumeWrites().             } else {                 flush(channel).             }         } catch (final IOException e) {             hasFailedWith(e).         }     }. }
false;;1;7;;void deferClose(final Closeable closeable) {     try {         closables.putFirst(closeable).     } catch (final InterruptedException e) {         hasFailedWith(e).     } }
false;;1;15;;void finish(final Message result) {     for (final Closeable closeable : closables) {         IoUtils.safeClose(closeable).     }     if (result != null) {         if (ExchangeHelper.isOutCapable(exchange)) {             exchange.setOut(result).         } else {             exchange.setIn(result).         }     }     callback.done(false). }
false;;1;8;;void hasFailedWith(final Throwable e) {     LOG.trace("Exchange has failed with", e).     if (Boolean.TRUE.equals(throwExceptionOnFailure)) {         exchange.setException(e).     }     finish(null). }
false;;1;3;;<T> ClientCallback<T> on(final Consumer<T> consumer) {     return new ErrorHandlingClientCallback<>(consumer). }
false;;1;8;;void performClientExchange(final ClientExchange clientExchange) {     // add response listener to the exchange, we could receive the response     // at any time (async)     setupResponseListener(clientExchange).     // write the request     writeRequest(clientExchange, body). }
false;;1;48;;void setupResponseListener(final ClientExchange clientExchange) {     clientExchange.setResponseListener(on((ClientExchange response) -> {         LOG.trace("completed: {}", clientExchange).         try {             storeCookies(clientExchange).             final UndertowHttpBinding binding = endpoint.getUndertowHttpBinding().             final Message result = binding.toCamelMessage(clientExchange, exchange).             // if there was a http error code then check if we should throw an exception             final int code = clientExchange.getResponse().getResponseCode().             LOG.debug("Http responseCode: {}", code).             final boolean ok = HttpHelper.isStatusCodeOk(code, "200-299").             if (!ok && throwExceptionOnFailure) {                 // operation failed so populate exception to throw                 final String uri = endpoint.getHttpURI().toString().                 final String statusText = clientExchange.getResponse().getStatus().                 // Convert Message headers (Map<String, Object>) to Map<String, String> as expected by HttpOperationsFailedException                 // using Message versus clientExchange as its header values have extra formatting                 final Map<String, String> headers = result.getHeaders().entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, (entry) -> entry.getValue().toString())).                 // Since result (Message) isn't associated with an Exchange yet, you can not use result.getBody(String.class)                 final String bodyText = ExchangeHelper.convertToType(exchange, String.class, result.getBody()).                 final Exception cause = new HttpOperationFailedException(uri, code, statusText, null, headers, bodyText).                 if (ExchangeHelper.isOutCapable(exchange)) {                     exchange.setOut(result).                 } else {                     exchange.setIn(result).                 }                 // make sure to fail with HttpOperationFailedException                 hasFailedWith(cause).             } else {                 // we end Camel exchange here                 finish(result).             }         } catch (Throwable e) {             hasFailedWith(e).         }     })). }
false;;1;17;;void storeCookies(final ClientExchange clientExchange) throws IOException, URISyntaxException {     if (endpoint.getCookieHandler() != null) {         // creating the url to use takes 2-steps         final String url = UndertowHelper.createURL(exchange, endpoint).         final URI uri = UndertowHelper.createURI(exchange, url, endpoint).         final HeaderMap headerMap = clientExchange.getResponse().getResponseHeaders().         final Map<String, List<String>> m = new HashMap<>().         for (final HttpString headerName : headerMap.getHeaderNames()) {             final List<String> headerValue = new LinkedList<>().             for (int i = 0. i < headerMap.count(headerName). i++) {                 headerValue.add(headerMap.get(headerName, i)).             }             m.put(headerName.toString(), headerValue).         }         endpoint.getCookieHandler().storeCookies(exchange, uri, m).     } }
false;;2;22;;void writeRequest(final ClientExchange clientExchange, final ByteBuffer body) {     final StreamSinkChannel requestChannel = clientExchange.getRequestChannel().     if (body != null) {         try {             // try writing, we could be on IO thread and ready to write to             // the socket (or not)             write(requestChannel, body).             if (body.hasRemaining()) {                 // we did not write all of body (or at all) register a write                 // listener to write asynchronously                 requestChannel.getWriteSetter().set(asyncWriter(body)).                 requestChannel.resumeWrites().             } else {                 // we are done, we need to flush the request                 flush(requestChannel).             }         } catch (final IOException e) {             hasFailedWith(e).         }     } }
false;static;1;13;;static void flush(final StreamSinkChannel channel) throws IOException {     // the canonical way of flushing Xnio channels     channel.shutdownWrites().     if (!channel.flush()) {         final ChannelListener<StreamSinkChannel> safeClose = IoUtils::safeClose.         final ChannelExceptionHandler<Channel> closingChannelExceptionHandler = ChannelListeners.closingChannelExceptionHandler().         final ChannelListener<StreamSinkChannel> flushingChannelListener = ChannelListeners.flushingChannelListener(safeClose, closingChannelExceptionHandler).         channel.getWriteSetter().set(flushingChannelListener).         channel.resumeWrites().     } }
false;static;2;6;;static void write(final StreamSinkChannel channel, final ByteBuffer body) throws IOException {     int written = 1.     while (body.hasRemaining() && written > 0) {         written = channel.write(body).     } }
