commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;46;;@Override protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {     URI uriHttpUriAddress = new URI(UnsafeUriCharactersEncoder.encodeHttpURI(remaining)).     URI endpointUri = URISupport.createRemainingURI(uriHttpUriAddress, parameters).     // any additional channel options     Map<String, Object> options = IntrospectionSupport.extractProperties(parameters, "option.").     // determine sslContextParameters     SSLContextParameters sslParams = this.sslContextParameters.     if (sslParams == null) {         sslParams = retrieveGlobalSslContextParameters().     }     // create the endpoint first     UndertowEndpoint endpoint = createEndpointInstance(endpointUri, this).     // set options from component     endpoint.setSslContextParameters(sslParams).     // Prefer endpoint configured over component configured     if (undertowHttpBinding == null) {         // fallback to component configured         undertowHttpBinding = getUndertowHttpBinding().     }     if (undertowHttpBinding != null) {         endpoint.setUndertowHttpBinding(undertowHttpBinding).     }     // set options from parameters     setProperties(endpoint, parameters).     if (options != null) {         endpoint.setOptions(options).     }     // then re-create the http uri with the remaining parameters which the endpoint did not use     URI httpUri = URISupport.createRemainingURI(new URI(uriHttpUriAddress.getScheme(), uriHttpUriAddress.getUserInfo(), uriHttpUriAddress.getHost(), uriHttpUriAddress.getPort(), uriHttpUriAddress.getPath(), uriHttpUriAddress.getQuery(), uriHttpUriAddress.getFragment()), parameters).     endpoint.setHttpURI(httpUri).     return endpoint. }
false;protected;2;3;;protected UndertowEndpoint createEndpointInstance(URI endpointUri, UndertowComponent component) throws URISyntaxException {     return new UndertowEndpoint(endpointUri.toString(), component). }
false;public;9;5;;@Override public Consumer createConsumer(CamelContext camelContext, Processor processor, String verb, String basePath, String uriTemplate, String consumes, String produces, RestConfiguration configuration, Map<String, Object> parameters) throws Exception {     return doCreateConsumer(camelContext, processor, verb, basePath, uriTemplate, consumes, produces, configuration, parameters, false). }
false;public;5;6;;@Override public Consumer createApiConsumer(CamelContext camelContext, Processor processor, String contextPath, RestConfiguration configuration, Map<String, Object> parameters) throws Exception {     // reuse the createConsumer method we already have. The api need to use GET and match on uri prefix     return doCreateConsumer(camelContext, processor, "GET", contextPath, null, null, null, configuration, parameters, true). }
false;;10;112;;Consumer doCreateConsumer(CamelContext camelContext, Processor processor, String verb, String basePath, String uriTemplate, String consumes, String produces, RestConfiguration configuration, Map<String, Object> parameters, boolean api) throws Exception {     String path = basePath.     if (uriTemplate != null) {         // make sure to avoid double slashes         if (uriTemplate.startsWith("/")) {             path = path + uriTemplate.         } else {             path = path + "/" + uriTemplate.         }     }     path = FileUtil.stripLeadingSeparator(path).     String scheme = "http".     String host = "".     int port = 0.     RestConfiguration config = configuration.     if (config == null) {         config = camelContext.getRestConfiguration(getComponentName(), true).     }     if (config.getScheme() != null) {         scheme = config.getScheme().     }     if (config.getHost() != null) {         host = config.getHost().     }     int num = config.getPort().     if (num > 0) {         port = num.     }     // prefix path with context-path if configured in rest-dsl configuration     String contextPath = config.getContextPath().     if (ObjectHelper.isNotEmpty(contextPath)) {         contextPath = FileUtil.stripTrailingSeparator(contextPath).         contextPath = FileUtil.stripLeadingSeparator(contextPath).         if (ObjectHelper.isNotEmpty(contextPath)) {             path = contextPath + "/" + path.         }     }     // if no explicit hostname set then resolve the hostname     if (ObjectHelper.isEmpty(host)) {         if (config.getHostNameResolver() == RestConfiguration.RestHostNameResolver.allLocalIp) {             host = "0.0.0.0".         } else if (config.getHostNameResolver() == RestConfiguration.RestHostNameResolver.localHostName) {             host = HostUtils.getLocalHostName().         } else if (config.getHostNameResolver() == RestConfiguration.RestHostNameResolver.localIp) {             host = HostUtils.getLocalIp().         }     }     Map<String, Object> map = new HashMap<>().     // build query string, and append any endpoint configuration properties     if (config.getComponent() == null || config.getComponent().equals(getComponentName())) {         // setup endpoint options         if (config.getEndpointProperties() != null && !config.getEndpointProperties().isEmpty()) {             map.putAll(config.getEndpointProperties()).         }     }     boolean explicitOptions = true.     // must use upper case for restrict     String restrict = verb.toUpperCase(Locale.US).     // allow OPTIONS in rest-dsl to allow clients to call the API and have responses with ALLOW headers     if (!restrict.contains("OPTIONS")) {         restrict += ",OPTIONS".         // this is not an explicit OPTIONS path in the rest-dsl         explicitOptions = false.     }     boolean cors = config.isEnableCORS().     if (cors) {         // allow HTTP Options as we want to handle CORS in rest-dsl         map.put("optionsEnabled", "true").     } else if (explicitOptions) {         // the rest-dsl is using OPTIONS         map.put("optionsEnabled", "true").     }     String query = URISupport.createQueryString(map).     String url.     if (api) {         url = getComponentName() + ":%s://%s:%s/%s?matchOnUriPrefix=true&httpMethodRestrict=%s".     } else {         url = getComponentName() + ":%s://%s:%s/%s?matchOnUriPrefix=false&httpMethodRestrict=%s".     }     // get the endpoint     url = String.format(url, scheme, host, port, path, restrict).     if (!query.isEmpty()) {         url = url + "&" + query.     }     UndertowEndpoint endpoint = camelContext.getEndpoint(url, UndertowEndpoint.class).     setProperties(camelContext, endpoint, parameters).     if (!map.containsKey("undertowHttpBinding")) {         // use the rest binding, if not using a custom http binding         endpoint.setUndertowHttpBinding(new RestUndertowHttpBinding()).     }     // configure consumer properties     Consumer consumer = endpoint.createConsumer(processor).     if (config.getConsumerProperties() != null && !config.getConsumerProperties().isEmpty()) {         setProperties(camelContext, consumer, config.getConsumerProperties()).     }     return consumer. }
false;public;10;55;;@Override public Producer createProducer(CamelContext camelContext, String host, String verb, String basePath, String uriTemplate, String queryParameters, String consumes, String produces, RestConfiguration configuration, Map<String, Object> parameters) throws Exception {     // avoid leading slash     basePath = FileUtil.stripLeadingSeparator(basePath).     uriTemplate = FileUtil.stripLeadingSeparator(uriTemplate).     // get the endpoint     String url = getComponentName() + ":" + host.     if (!ObjectHelper.isEmpty(basePath)) {         url += "/" + basePath.     }     if (!ObjectHelper.isEmpty(uriTemplate)) {         url += "/" + uriTemplate.     }     RestConfiguration config = configuration.     if (config == null) {         config = camelContext.getRestConfiguration(getComponentName(), true).     }     Map<String, Object> map = new HashMap<>().     // build query string, and append any endpoint configuration properties     if (config.getComponent() == null || config.getComponent().equals(getComponentName())) {         // setup endpoint options         if (config.getEndpointProperties() != null && !config.getEndpointProperties().isEmpty()) {             map.putAll(config.getEndpointProperties()).         }     }     // get the endpoint     String query = URISupport.createQueryString(map).     if (!query.isEmpty()) {         url = url + "?" + query.     }     // there are cases where we might end up here without component being created beforehand     // we need to abide by the component properties specified in the parameters when creating     // the component     RestProducerFactoryHelper.setupComponentFor(url, camelContext, (Map<String, Object>) parameters.get("component")).     UndertowEndpoint endpoint = camelContext.getEndpoint(url, UndertowEndpoint.class).     if (parameters != null && !parameters.isEmpty()) {         setProperties(camelContext, endpoint, parameters).     }     String path = uriTemplate != null ? uriTemplate : basePath.     endpoint.setHeaderFilterStrategy(new UndertowRestHeaderFilterStrategy(path, queryParameters)).     // the endpoint must be started before creating the producer     ServiceHelper.startService(endpoint).     return endpoint.createProducer(). }
false;protected;0;10;;@Override protected void doStart() throws Exception {     super.doStart().     RestConfiguration config = getCamelContext().getRestConfiguration(getComponentName(), true).     // configure additional options on undertow configuration     if (config.getComponentProperties() != null && !config.getComponentProperties().isEmpty()) {         setProperties(this, config.getComponentProperties()).     } }
false;public;3;9;;public HttpHandler registerEndpoint(HttpHandlerRegistrationInfo registrationInfo, SSLContext sslContext, HttpHandler handler) {     final URI uri = registrationInfo.getUri().     final UndertowHostKey key = new UndertowHostKey(uri.getHost(), uri.getPort(), sslContext).     final UndertowHost host = undertowRegistry.computeIfAbsent(key, k -> createUndertowHost(k)).     host.validateEndpointURI(uri).     handlers.add(registrationInfo).     return host.registerHandler(registrationInfo, handler). }
false;public;2;7;;public void unregisterEndpoint(HttpHandlerRegistrationInfo registrationInfo, SSLContext sslContext) {     final URI uri = registrationInfo.getUri().     final UndertowHostKey key = new UndertowHostKey(uri.getHost(), uri.getPort(), sslContext).     final UndertowHost host = undertowRegistry.get(key).     handlers.remove(registrationInfo).     host.unregisterHandler(registrationInfo). }
false;protected;1;3;;protected UndertowHost createUndertowHost(UndertowHostKey key) {     return new DefaultUndertowHost(key, hostOptions). }
false;public;0;3;;public UndertowHttpBinding getUndertowHttpBinding() {     return undertowHttpBinding. }
true;public;1;3;/**  * To use a custom HttpBinding to control the mapping between Camel message and HttpClient.  */ ;/**  * To use a custom HttpBinding to control the mapping between Camel message and HttpClient.  */ public void setUndertowHttpBinding(UndertowHttpBinding undertowHttpBinding) {     this.undertowHttpBinding = undertowHttpBinding. }
false;public;0;3;;public SSLContextParameters getSslContextParameters() {     return sslContextParameters. }
true;public;1;3;/**  * To configure security using SSLContextParameters  */ ;/**  * To configure security using SSLContextParameters  */ public void setSslContextParameters(SSLContextParameters sslContextParameters) {     this.sslContextParameters = sslContextParameters. }
false;public;0;4;;@Override public boolean isUseGlobalSslContextParameters() {     return this.useGlobalSslContextParameters. }
true;public;1;4;/**  * Enable usage of global SSL context parameters.  */ ;/**  * Enable usage of global SSL context parameters.  */ @Override public void setUseGlobalSslContextParameters(boolean useGlobalSslContextParameters) {     this.useGlobalSslContextParameters = useGlobalSslContextParameters. }
false;public;0;3;;public UndertowHostOptions getHostOptions() {     return hostOptions. }
true;public;1;3;/**  * To configure common options, such as thread pools  */ ;/**  * To configure common options, such as thread pools  */ public void setHostOptions(UndertowHostOptions hostOptions) {     this.hostOptions = hostOptions. }
false;public;0;3;;public ComponentVerifierExtension getVerifier() {     return (scope, parameters) -> getExtension(ComponentVerifierExtension.class).orElseThrow(UnsupportedOperationException::new).verify(scope, parameters). }
false;protected;0;3;;protected String getComponentName() {     return "undertow". }
false;public;0;3;;public Set<HttpHandlerRegistrationInfo> getHandlers() {     return handlers. }
