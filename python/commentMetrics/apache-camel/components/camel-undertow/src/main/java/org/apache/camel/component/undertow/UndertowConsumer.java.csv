commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public UndertowEndpoint getEndpoint() {     return (UndertowEndpoint) super.getEndpoint(). }
false;protected;0;18;;@Override protected void doStart() throws Exception {     super.doStart().     final UndertowEndpoint endpoint = getEndpoint().     if (endpoint.isWebSocket()) {         /*              * note that the new CamelWebSocketHandler() we pass to registerEndpoint() does not necessarily have to be              * the same instance that is returned from there              */         this.webSocketHandler = (CamelWebSocketHandler) endpoint.getComponent().registerEndpoint(endpoint.getHttpHandlerRegistrationInfo(), endpoint.getSslContext(), new CamelWebSocketHandler()).         this.webSocketHandler.setConsumer(this).     } else {         // allow for HTTP 1.1 continue         endpoint.getComponent().registerEndpoint(endpoint.getHttpHandlerRegistrationInfo(), endpoint.getSslContext(), Handlers.httpContinueRead(// wrap with EagerFormParsingHandler to enable undertow form parsers         new EagerFormParsingHandler().setNext(UndertowConsumer.this))).     } }
false;protected;0;9;;@Override protected void doStop() throws Exception {     super.doStop().     if (this.webSocketHandler != null) {         this.webSocketHandler.setConsumer(null).     }     UndertowEndpoint endpoint = getEndpoint().     endpoint.getComponent().unregisterEndpoint(endpoint.getHttpHandlerRegistrationInfo(), endpoint.getSslContext()). }
false;public;1;71;;@Override public void handleRequest(HttpServerExchange httpExchange) throws Exception {     HttpString requestMethod = httpExchange.getRequestMethod().     if (Methods.OPTIONS.equals(requestMethod) && !getEndpoint().isOptionsEnabled()) {         CollectionStringBuffer csb = new CollectionStringBuffer(",").         Collection<HttpHandlerRegistrationInfo> handlers = getEndpoint().getComponent().getHandlers().         for (HttpHandlerRegistrationInfo reg : handlers) {             URI uri = reg.getUri().             // what other HTTP methods may exists for the same path             if (reg.getMethodRestrict() != null && getEndpoint().getHttpURI().equals(uri)) {                 String restrict = reg.getMethodRestrict().                 if (restrict.endsWith(",OPTIONS")) {                     restrict = restrict.substring(0, restrict.length() - 8).                 }                 csb.append(restrict).             }         }         String allowedMethods = csb.toString().         if (ObjectHelper.isEmpty(allowedMethods)) {             allowedMethods = getEndpoint().getHttpMethodRestrict().         }         if (ObjectHelper.isEmpty(allowedMethods)) {             allowedMethods = "GET,HEAD,POST,PUT,DELETE,TRACE,OPTIONS,CONNECT,PATCH".         }         if (!allowedMethods.contains("OPTIONS")) {             allowedMethods = allowedMethods + ",OPTIONS".         }         // return list of allowed methods in response headers         httpExchange.setStatusCode(StatusCodes.OK).         httpExchange.getResponseHeaders().put(ExchangeHeaders.CONTENT_LENGTH, 0).         // do not include content-type as that would indicate to the caller that we can only do text/plain         httpExchange.getResponseHeaders().put(Headers.ALLOW, allowedMethods).         httpExchange.getResponseSender().close().         return.     }     // perform blocking operation on exchange     if (httpExchange.isInIoThread()) {         httpExchange.dispatch(this).         return.     }     // create new Exchange     // binding is used to extract header and payload(if available)     Exchange camelExchange = getEndpoint().createExchange(httpExchange).     // Unit of Work to process the Exchange     createUoW(camelExchange).     try {         getProcessor().process(camelExchange).     } catch (Exception e) {         getExceptionHandler().handleException(e).     } finally {         doneUoW(camelExchange).     }     Object body = getResponseBody(httpExchange, camelExchange).     TypeConverter tc = getEndpoint().getCamelContext().getTypeConverter().     if (body == null) {         log.trace("No payload to send as reply for exchange: {}", camelExchange).         httpExchange.getResponseHeaders().put(ExchangeHeaders.CONTENT_TYPE, MimeMappings.DEFAULT_MIME_MAPPINGS.get("txt")).         httpExchange.getResponseSender().send("No response available").     } else {         ByteBuffer bodyAsByteBuffer = tc.convertTo(ByteBuffer.class, body).         httpExchange.getResponseSender().send(bodyAsByteBuffer).     }     httpExchange.getResponseSender().close(). }
false;public;1;6;;public void done(boolean doneSync) {     if (exchange.getException() != null) {         getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException()).     } }
true;public;2;18;/**  * Create an {@link Exchange} from the associated {@link UndertowEndpoint} and set the {@code in} {@link Message}'s  * body to the given {@code message} and {@link UndertowConstants#CONNECTION_KEY} header to the given  * {@code connectionKey}.  *  * @param connectionKey an identifier of {@link WebSocketChannel} through which the {@code message} was received  * @param message the message received via the {@link WebSocketChannel}  */ ;/**  * Create an {@link Exchange} from the associated {@link UndertowEndpoint} and set the {@code in} {@link Message}'s  * body to the given {@code message} and {@link UndertowConstants#CONNECTION_KEY} header to the given  * {@code connectionKey}.  *  * @param connectionKey an identifier of {@link WebSocketChannel} through which the {@code message} was received  * @param message the message received via the {@link WebSocketChannel}  */ public void sendMessage(final String connectionKey, final Object message) {     final Exchange exchange = getEndpoint().createExchange().     // set header and body     exchange.getIn().setHeader(UndertowConstants.CONNECTION_KEY, connectionKey).     exchange.getIn().setBody(message).     // send exchange using the async routing engine     getAsyncProcessor().process(exchange, new AsyncCallback() {          public void done(boolean doneSync) {             if (exchange.getException() != null) {                 getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException()).             }         }     }). }
false;public;1;5;;public void done(boolean doneSync) {     if (exchange.getException() != null) {         getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException()).     } }
true;public;2;17;/**  * Send a notification related a WebSocket peer.  *  * @param connectionKey of WebSocket peer  * @param eventType the type of the event  */ ;/**  * Send a notification related a WebSocket peer.  *  * @param connectionKey of WebSocket peer  * @param eventType the type of the event  */ public void sendEventNotification(String connectionKey, EventType eventType) {     final Exchange exchange = getEndpoint().createExchange().     final Message in = exchange.getIn().     in.setHeader(UndertowConstants.CONNECTION_KEY, connectionKey).     in.setHeader(UndertowConstants.EVENT_TYPE, eventType.getCode()).     in.setHeader(UndertowConstants.EVENT_TYPE_ENUM, eventType).     // send exchange using the async routing engine     getAsyncProcessor().process(exchange, new AsyncCallback() {          public void done(boolean doneSync) {             if (exchange.getException() != null) {                 getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException()).             }         }     }). }
false;private;2;9;;private Object getResponseBody(HttpServerExchange httpExchange, Exchange camelExchange) throws IOException {     Object result.     if (camelExchange.hasOut()) {         result = getEndpoint().getUndertowHttpBinding().toHttpResponse(httpExchange, camelExchange.getOut()).     } else {         result = getEndpoint().getUndertowHttpBinding().toHttpResponse(httpExchange, camelExchange.getIn()).     }     return result. }
