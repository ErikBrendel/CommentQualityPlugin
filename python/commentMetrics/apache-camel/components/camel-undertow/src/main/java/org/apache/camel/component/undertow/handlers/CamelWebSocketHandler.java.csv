# id;timestamp;commentText;codeText;commentWords;codeWords
CamelWebSocketHandler -> private static void send(WebSocketChannel channel, Object message, ExtendedWebSocketCallback callback,             long timeoutMillis) throws IOException;1513161172;Send the given {@code message} to the given {@code channel} and report the outcome to the given {@code callback}_within the given {@code timeoutMillis}.__@param channel_the channel to sent the {@code message} to_@param message_the message to send_@param callback_where to report the outcome_@param timeoutMillis_the timeout in milliseconds_@throws IOException;private static void send(WebSocketChannel channel, Object message, ExtendedWebSocketCallback callback,_            long timeoutMillis) throws IOException {_        if (channel.isOpen()) {_            if (message instanceof String) {_                WebSockets.sendText((String) message, channel, callback)__            } else if (message instanceof byte[]) {_                ByteBuffer buffer = ByteBuffer.wrap((byte[]) message)__                WebSockets.sendBinary(buffer, channel, callback, timeoutMillis)__            } else if (message instanceof Reader) {_                Reader r = (Reader) message__                WebSockets.sendText(IOConverter.toString(r), channel, callback)__            } else if (message instanceof InputStream) {_                InputStream in = (InputStream) message__                ByteBuffer buffer = ByteBuffer.wrap(IOConverter.toBytes(in))__                WebSockets.sendBinary(buffer, channel, callback, timeoutMillis)__            } else {_                throw new RuntimeCamelException(_                        "Unexpected type of message " + message.getClass().getName() + "_ expected String, byte[], "_                                + Reader.class.getName() + " or " + InputStream.class.getName())__            }_        } else {_            callback.closedBeforeSent(channel)__        }_    };send,the,given,code,message,to,the,given,code,channel,and,report,the,outcome,to,the,given,code,callback,within,the,given,code,timeout,millis,param,channel,the,channel,to,sent,the,code,message,to,param,message,the,message,to,send,param,callback,where,to,report,the,outcome,param,timeout,millis,the,timeout,in,milliseconds,throws,ioexception;private,static,void,send,web,socket,channel,channel,object,message,extended,web,socket,callback,callback,long,timeout,millis,throws,ioexception,if,channel,is,open,if,message,instanceof,string,web,sockets,send,text,string,message,channel,callback,else,if,message,instanceof,byte,byte,buffer,buffer,byte,buffer,wrap,byte,message,web,sockets,send,binary,buffer,channel,callback,timeout,millis,else,if,message,instanceof,reader,reader,r,reader,message,web,sockets,send,text,ioconverter,to,string,r,channel,callback,else,if,message,instanceof,input,stream,input,stream,in,input,stream,message,byte,buffer,buffer,byte,buffer,wrap,ioconverter,to,bytes,in,web,sockets,send,binary,buffer,channel,callback,timeout,millis,else,throw,new,runtime,camel,exception,unexpected,type,of,message,message,get,class,get,name,expected,string,byte,reader,class,get,name,or,input,stream,class,get,name,else,callback,closed,before,sent,channel
CamelWebSocketHandler -> private static void send(WebSocketChannel channel, Object message, ExtendedWebSocketCallback callback,             long timeoutMillis) throws IOException;1537290824;Send the given {@code message} to the given {@code channel} and report the outcome to the given {@code callback}_within the given {@code timeoutMillis}.__@param channel_the channel to sent the {@code message} to_@param message_the message to send_@param callback_where to report the outcome_@param timeoutMillis_the timeout in milliseconds_@throws IOException;private static void send(WebSocketChannel channel, Object message, ExtendedWebSocketCallback callback,_            long timeoutMillis) throws IOException {_        if (channel.isOpen()) {_            if (message instanceof String) {_                WebSockets.sendText((String) message, channel, callback)__            } else if (message instanceof byte[]) {_                ByteBuffer buffer = ByteBuffer.wrap((byte[]) message)__                WebSockets.sendBinary(buffer, channel, callback, timeoutMillis)__            } else if (message instanceof Reader) {_                Reader r = (Reader) message__                WebSockets.sendText(IOConverter.toString(r), channel, callback)__            } else if (message instanceof InputStream) {_                InputStream in = (InputStream) message__                ByteBuffer buffer = ByteBuffer.wrap(IOConverter.toBytes(in))__                WebSockets.sendBinary(buffer, channel, callback, timeoutMillis)__            } else {_                throw new RuntimeCamelException(_                        "Unexpected type of message " + message.getClass().getName() + "_ expected String, byte[], "_                                + Reader.class.getName() + " or " + InputStream.class.getName())__            }_        } else {_            callback.closedBeforeSent(channel)__        }_    };send,the,given,code,message,to,the,given,code,channel,and,report,the,outcome,to,the,given,code,callback,within,the,given,code,timeout,millis,param,channel,the,channel,to,sent,the,code,message,to,param,message,the,message,to,send,param,callback,where,to,report,the,outcome,param,timeout,millis,the,timeout,in,milliseconds,throws,ioexception;private,static,void,send,web,socket,channel,channel,object,message,extended,web,socket,callback,callback,long,timeout,millis,throws,ioexception,if,channel,is,open,if,message,instanceof,string,web,sockets,send,text,string,message,channel,callback,else,if,message,instanceof,byte,byte,buffer,buffer,byte,buffer,wrap,byte,message,web,sockets,send,binary,buffer,channel,callback,timeout,millis,else,if,message,instanceof,reader,reader,r,reader,message,web,sockets,send,text,ioconverter,to,string,r,channel,callback,else,if,message,instanceof,input,stream,input,stream,in,input,stream,message,byte,buffer,buffer,byte,buffer,wrap,ioconverter,to,bytes,in,web,sockets,send,binary,buffer,channel,callback,timeout,millis,else,throw,new,runtime,camel,exception,unexpected,type,of,message,message,get,class,get,name,expected,string,byte,reader,class,get,name,or,input,stream,class,get,name,else,callback,closed,before,sent,channel
CamelWebSocketHandler -> private static void send(WebSocketChannel channel, Object message, ExtendedWebSocketCallback callback,             long timeoutMillis) throws IOException;1540108160;Send the given {@code message} to the given {@code channel} and report the outcome to the given {@code callback}_within the given {@code timeoutMillis}.__@param channel_the channel to sent the {@code message} to_@param message_the message to send_@param callback_where to report the outcome_@param timeoutMillis_the timeout in milliseconds_@throws IOException;private static void send(WebSocketChannel channel, Object message, ExtendedWebSocketCallback callback,_            long timeoutMillis) throws IOException {_        if (channel.isOpen()) {_            if (message instanceof String) {_                WebSockets.sendText((String) message, channel, callback)__            } else if (message instanceof byte[]) {_                ByteBuffer buffer = ByteBuffer.wrap((byte[]) message)__                WebSockets.sendBinary(buffer, channel, callback, timeoutMillis)__            } else if (message instanceof Reader) {_                Reader r = (Reader) message__                WebSockets.sendText(IOConverter.toString(r), channel, callback)__            } else if (message instanceof InputStream) {_                InputStream in = (InputStream) message__                ByteBuffer buffer = ByteBuffer.wrap(IOConverter.toBytes(in))__                WebSockets.sendBinary(buffer, channel, callback, timeoutMillis)__            } else {_                throw new RuntimeCamelException(_                        "Unexpected type of message " + message.getClass().getName() + "_ expected String, byte[], "_                                + Reader.class.getName() + " or " + InputStream.class.getName())__            }_        } else {_            callback.closedBeforeSent(channel)__        }_    };send,the,given,code,message,to,the,given,code,channel,and,report,the,outcome,to,the,given,code,callback,within,the,given,code,timeout,millis,param,channel,the,channel,to,sent,the,code,message,to,param,message,the,message,to,send,param,callback,where,to,report,the,outcome,param,timeout,millis,the,timeout,in,milliseconds,throws,ioexception;private,static,void,send,web,socket,channel,channel,object,message,extended,web,socket,callback,callback,long,timeout,millis,throws,ioexception,if,channel,is,open,if,message,instanceof,string,web,sockets,send,text,string,message,channel,callback,else,if,message,instanceof,byte,byte,buffer,buffer,byte,buffer,wrap,byte,message,web,sockets,send,binary,buffer,channel,callback,timeout,millis,else,if,message,instanceof,reader,reader,r,reader,message,web,sockets,send,text,ioconverter,to,string,r,channel,callback,else,if,message,instanceof,input,stream,input,stream,in,input,stream,message,byte,buffer,buffer,byte,buffer,wrap,ioconverter,to,bytes,in,web,sockets,send,binary,buffer,channel,callback,timeout,millis,else,throw,new,runtime,camel,exception,unexpected,type,of,message,message,get,class,get,name,expected,string,byte,reader,class,get,name,or,input,stream,class,get,name,else,callback,closed,before,sent,channel
CamelWebSocketHandler -> MultiCallback -> private void finish();1513161172;{@link #finish()} should be called only inside a <code>synchronized(lock) { ... }</code> block to prevent_concurrent access to {@link #errors}.;private void finish() {_            if (errors != null && !errors.isEmpty()) {_                if (errors.size() == 1) {_                    final Entry<String, Throwable> en = errors.entrySet().iterator().next()__                    final String msg = "Delivery to the WebSocket peer " + en.getKey() + " channels has failed"__                    camelExchange.setException(new CamelExchangeException(msg, camelExchange, en.getValue()))__                } else {_                    final StringBuilder msg = new StringBuilder(_                            "Delivery to the following WebSocket peer channels has failed: ")__                    for (Entry<String, Throwable> en : errors.entrySet()) {_                        msg.append("\n    ").append(en.getKey()).append(en.getValue().getMessage())__                    }_                    camelExchange.setException(new CamelExchangeException(msg.toString(), camelExchange))__                }_            }_            camelCallback.done(false)__        };link,finish,should,be,called,only,inside,a,code,synchronized,lock,code,block,to,prevent,concurrent,access,to,link,errors;private,void,finish,if,errors,null,errors,is,empty,if,errors,size,1,final,entry,string,throwable,en,errors,entry,set,iterator,next,final,string,msg,delivery,to,the,web,socket,peer,en,get,key,channels,has,failed,camel,exchange,set,exception,new,camel,exchange,exception,msg,camel,exchange,en,get,value,else,final,string,builder,msg,new,string,builder,delivery,to,the,following,web,socket,peer,channels,has,failed,for,entry,string,throwable,en,errors,entry,set,msg,append,n,append,en,get,key,append,en,get,value,get,message,camel,exchange,set,exception,new,camel,exchange,exception,msg,to,string,camel,exchange,camel,callback,done,false
CamelWebSocketHandler -> MultiCallback -> private void finish();1537290824;{@link #finish()} should be called only inside a <code>synchronized(lock) { ... }</code> block to prevent_concurrent access to {@link #errors}.;private void finish() {_            if (errors != null && !errors.isEmpty()) {_                if (errors.size() == 1) {_                    final Entry<String, Throwable> en = errors.entrySet().iterator().next()__                    final String msg = "Delivery to the WebSocket peer " + en.getKey() + " channels has failed"__                    camelExchange.setException(new CamelExchangeException(msg, camelExchange, en.getValue()))__                } else {_                    final StringBuilder msg = new StringBuilder(_                            "Delivery to the following WebSocket peer channels has failed: ")__                    for (Entry<String, Throwable> en : errors.entrySet()) {_                        msg.append("\n    ").append(en.getKey()).append(en.getValue().getMessage())__                    }_                    camelExchange.setException(new CamelExchangeException(msg.toString(), camelExchange))__                }_            }_            camelCallback.done(false)__        };link,finish,should,be,called,only,inside,a,code,synchronized,lock,code,block,to,prevent,concurrent,access,to,link,errors;private,void,finish,if,errors,null,errors,is,empty,if,errors,size,1,final,entry,string,throwable,en,errors,entry,set,iterator,next,final,string,msg,delivery,to,the,web,socket,peer,en,get,key,channels,has,failed,camel,exchange,set,exception,new,camel,exchange,exception,msg,camel,exchange,en,get,value,else,final,string,builder,msg,new,string,builder,delivery,to,the,following,web,socket,peer,channels,has,failed,for,entry,string,throwable,en,errors,entry,set,msg,append,n,append,en,get,key,append,en,get,value,get,message,camel,exchange,set,exception,new,camel,exchange,exception,msg,to,string,camel,exchange,camel,callback,done,false
CamelWebSocketHandler -> MultiCallback -> private void finish();1540108160;{@link #finish()} should be called only inside a <code>synchronized(lock) { ... }</code> block to prevent_concurrent access to {@link #errors}.;private void finish() {_            if (errors != null && !errors.isEmpty()) {_                if (errors.size() == 1) {_                    final Entry<String, Throwable> en = errors.entrySet().iterator().next()__                    final String msg = "Delivery to the WebSocket peer " + en.getKey() + " channels has failed"__                    camelExchange.setException(new CamelExchangeException(msg, camelExchange, en.getValue()))__                } else {_                    final StringBuilder msg = new StringBuilder(_                            "Delivery to the following WebSocket peer channels has failed: ")__                    for (Entry<String, Throwable> en : errors.entrySet()) {_                        msg.append("\n    ").append(en.getKey()).append(en.getValue().getMessage())__                    }_                    camelExchange.setException(new CamelExchangeException(msg.toString(), camelExchange))__                }_            }_            camelCallback.done(false)__        };link,finish,should,be,called,only,inside,a,code,synchronized,lock,code,block,to,prevent,concurrent,access,to,link,errors;private,void,finish,if,errors,null,errors,is,empty,if,errors,size,1,final,entry,string,throwable,en,errors,entry,set,iterator,next,final,string,msg,delivery,to,the,web,socket,peer,en,get,key,channels,has,failed,camel,exchange,set,exception,new,camel,exchange,exception,msg,camel,exchange,en,get,value,else,final,string,builder,msg,new,string,builder,delivery,to,the,following,web,socket,peer,channels,has,failed,for,entry,string,throwable,en,errors,entry,set,msg,append,n,append,en,get,key,append,en,get,value,get,message,camel,exchange,set,exception,new,camel,exchange,exception,msg,to,string,camel,exchange,camel,callback,done,false
CamelWebSocketHandler -> public boolean send(Predicate<WebSocketChannel> peerFilter, Object message, final int timeout,             final Exchange camelExchange, final AsyncCallback camelCallback) throws IOException;1513161172;Send the given {@code message} to one or more channels selected using the given {@code peerFilter} within the_given {@code timeout} and report the outcome to the given {@code camelExchange} and {@code camelCallback}.__@param peerFilter_a {@link Predicate} to apply to the set of peers obtained via {@link #delegate}'s_{@link WebSocketProtocolHandshakeHandler#getPeerConnections()}_@param message_the message to send_@param camelExchange to notify about the outcome_@param camelCallback to notify about the outcome_@param timeout_in milliseconds_@return {@code true} if the execution finished synchronously or {@code false} otherwise_@throws IOException;public boolean send(Predicate<WebSocketChannel> peerFilter, Object message, final int timeout,_            final Exchange camelExchange, final AsyncCallback camelCallback) throws IOException {_        List<WebSocketChannel> targetPeers = delegate.getPeerConnections().stream().filter(peerFilter).collect(Collectors.toList())__        if (targetPeers.isEmpty()) {_            camelCallback.done(true)__            return true__        } else {_            _            MultiCallback wsCallback = new MultiCallback(targetPeers, camelCallback, camelExchange)__            for (WebSocketChannel peer : targetPeers) {_                send(peer, message, wsCallback, timeout)__            }_            return false__        }_    };send,the,given,code,message,to,one,or,more,channels,selected,using,the,given,code,peer,filter,within,the,given,code,timeout,and,report,the,outcome,to,the,given,code,camel,exchange,and,code,camel,callback,param,peer,filter,a,link,predicate,to,apply,to,the,set,of,peers,obtained,via,link,delegate,s,link,web,socket,protocol,handshake,handler,get,peer,connections,param,message,the,message,to,send,param,camel,exchange,to,notify,about,the,outcome,param,camel,callback,to,notify,about,the,outcome,param,timeout,in,milliseconds,return,code,true,if,the,execution,finished,synchronously,or,code,false,otherwise,throws,ioexception;public,boolean,send,predicate,web,socket,channel,peer,filter,object,message,final,int,timeout,final,exchange,camel,exchange,final,async,callback,camel,callback,throws,ioexception,list,web,socket,channel,target,peers,delegate,get,peer,connections,stream,filter,peer,filter,collect,collectors,to,list,if,target,peers,is,empty,camel,callback,done,true,return,true,else,multi,callback,ws,callback,new,multi,callback,target,peers,camel,callback,camel,exchange,for,web,socket,channel,peer,target,peers,send,peer,message,ws,callback,timeout,return,false
CamelWebSocketHandler -> public boolean send(Predicate<WebSocketChannel> peerFilter, Object message, final int timeout,             final Exchange camelExchange, final AsyncCallback camelCallback) throws IOException;1537290824;Send the given {@code message} to one or more channels selected using the given {@code peerFilter} within the_given {@code timeout} and report the outcome to the given {@code camelExchange} and {@code camelCallback}.__@param peerFilter_a {@link Predicate} to apply to the set of peers obtained via {@link #delegate}'s_{@link WebSocketProtocolHandshakeHandler#getPeerConnections()}_@param message_the message to send_@param camelExchange to notify about the outcome_@param camelCallback to notify about the outcome_@param timeout_in milliseconds_@return {@code true} if the execution finished synchronously or {@code false} otherwise_@throws IOException;public boolean send(Predicate<WebSocketChannel> peerFilter, Object message, final int timeout,_            final Exchange camelExchange, final AsyncCallback camelCallback) throws IOException {_        List<WebSocketChannel> targetPeers = delegate.getPeerConnections().stream().filter(peerFilter).collect(Collectors.toList())__        if (targetPeers.isEmpty()) {_            camelCallback.done(true)__            return true__        } else {_            _            MultiCallback wsCallback = new MultiCallback(targetPeers, camelCallback, camelExchange)__            for (WebSocketChannel peer : targetPeers) {_                send(peer, message, wsCallback, timeout)__            }_            return false__        }_    };send,the,given,code,message,to,one,or,more,channels,selected,using,the,given,code,peer,filter,within,the,given,code,timeout,and,report,the,outcome,to,the,given,code,camel,exchange,and,code,camel,callback,param,peer,filter,a,link,predicate,to,apply,to,the,set,of,peers,obtained,via,link,delegate,s,link,web,socket,protocol,handshake,handler,get,peer,connections,param,message,the,message,to,send,param,camel,exchange,to,notify,about,the,outcome,param,camel,callback,to,notify,about,the,outcome,param,timeout,in,milliseconds,return,code,true,if,the,execution,finished,synchronously,or,code,false,otherwise,throws,ioexception;public,boolean,send,predicate,web,socket,channel,peer,filter,object,message,final,int,timeout,final,exchange,camel,exchange,final,async,callback,camel,callback,throws,ioexception,list,web,socket,channel,target,peers,delegate,get,peer,connections,stream,filter,peer,filter,collect,collectors,to,list,if,target,peers,is,empty,camel,callback,done,true,return,true,else,multi,callback,ws,callback,new,multi,callback,target,peers,camel,callback,camel,exchange,for,web,socket,channel,peer,target,peers,send,peer,message,ws,callback,timeout,return,false
CamelWebSocketHandler -> public boolean send(Predicate<WebSocketChannel> peerFilter, Object message, final int timeout,             final Exchange camelExchange, final AsyncCallback camelCallback) throws IOException;1540108160;Send the given {@code message} to one or more channels selected using the given {@code peerFilter} within the_given {@code timeout} and report the outcome to the given {@code camelExchange} and {@code camelCallback}.__@param peerFilter_a {@link Predicate} to apply to the set of peers obtained via {@link #delegate}'s_{@link WebSocketProtocolHandshakeHandler#getPeerConnections()}_@param message_the message to send_@param camelExchange to notify about the outcome_@param camelCallback to notify about the outcome_@param timeout_in milliseconds_@return {@code true} if the execution finished synchronously or {@code false} otherwise_@throws IOException;public boolean send(Predicate<WebSocketChannel> peerFilter, Object message, final int timeout,_            final Exchange camelExchange, final AsyncCallback camelCallback) throws IOException {_        List<WebSocketChannel> targetPeers = delegate.getPeerConnections().stream().filter(peerFilter).collect(Collectors.toList())__        if (targetPeers.isEmpty()) {_            camelCallback.done(true)__            return true__        } else {_            _            MultiCallback wsCallback = new MultiCallback(targetPeers, camelCallback, camelExchange)__            for (WebSocketChannel peer : targetPeers) {_                send(peer, message, wsCallback, timeout)__            }_            return false__        }_    };send,the,given,code,message,to,one,or,more,channels,selected,using,the,given,code,peer,filter,within,the,given,code,timeout,and,report,the,outcome,to,the,given,code,camel,exchange,and,code,camel,callback,param,peer,filter,a,link,predicate,to,apply,to,the,set,of,peers,obtained,via,link,delegate,s,link,web,socket,protocol,handshake,handler,get,peer,connections,param,message,the,message,to,send,param,camel,exchange,to,notify,about,the,outcome,param,camel,callback,to,notify,about,the,outcome,param,timeout,in,milliseconds,return,code,true,if,the,execution,finished,synchronously,or,code,false,otherwise,throws,ioexception;public,boolean,send,predicate,web,socket,channel,peer,filter,object,message,final,int,timeout,final,exchange,camel,exchange,final,async,callback,camel,callback,throws,ioexception,list,web,socket,channel,target,peers,delegate,get,peer,connections,stream,filter,peer,filter,collect,collectors,to,list,if,target,peers,is,empty,camel,callback,done,true,return,true,else,multi,callback,ws,callback,new,multi,callback,target,peers,camel,callback,camel,exchange,for,web,socket,channel,peer,target,peers,send,peer,message,ws,callback,timeout,return,false
CamelWebSocketHandler -> @Override     public void handleRequest(HttpServerExchange exchange) throws Exception;1513161172;{@inheritDoc};@Override_    public void handleRequest(HttpServerExchange exchange) throws Exception {_        this.delegate.handleRequest(exchange)__    };inherit,doc;override,public,void,handle,request,http,server,exchange,exchange,throws,exception,this,delegate,handle,request,exchange
CamelWebSocketHandler -> @Override     public void handleRequest(HttpServerExchange exchange) throws Exception;1537290824;{@inheritDoc};@Override_    public void handleRequest(HttpServerExchange exchange) throws Exception {_        this.delegate.handleRequest(exchange)__    };inherit,doc;override,public,void,handle,request,http,server,exchange,exchange,throws,exception,this,delegate,handle,request,exchange
CamelWebSocketHandler -> @Override     public void handleRequest(HttpServerExchange exchange) throws Exception;1540108160;{@inheritDoc};@Override_    public void handleRequest(HttpServerExchange exchange) throws Exception {_        this.delegate.handleRequest(exchange)__    };inherit,doc;override,public,void,handle,request,http,server,exchange,exchange,throws,exception,this,delegate,handle,request,exchange
CamelWebSocketHandler -> public void setConsumer(UndertowConsumer consumer);1513161172;@param consumer the {@link UndertowConsumer} to set;public void setConsumer(UndertowConsumer consumer) {_        synchronized (consumerLock) {_            if (consumer != null && this.consumer != null) {_                throw new IllegalStateException("Cannot call " + getClass().getName()_                        + ".setConsumer(UndertowConsumer) with a non-null consumer before unsetting it via setConsumer(null)")__            }_            this.consumer = consumer__        }_    };param,consumer,the,link,undertow,consumer,to,set;public,void,set,consumer,undertow,consumer,consumer,synchronized,consumer,lock,if,consumer,null,this,consumer,null,throw,new,illegal,state,exception,cannot,call,get,class,get,name,set,consumer,undertow,consumer,with,a,non,null,consumer,before,unsetting,it,via,set,consumer,null,this,consumer,consumer
CamelWebSocketHandler -> public void setConsumer(UndertowConsumer consumer);1537290824;@param consumer the {@link UndertowConsumer} to set;public void setConsumer(UndertowConsumer consumer) {_        synchronized (consumerLock) {_            if (consumer != null && this.consumer != null) {_                throw new IllegalStateException("Cannot call " + getClass().getName()_                        + ".setConsumer(UndertowConsumer) with a non-null consumer before unsetting it via setConsumer(null)")__            }_            this.consumer = consumer__        }_    };param,consumer,the,link,undertow,consumer,to,set;public,void,set,consumer,undertow,consumer,consumer,synchronized,consumer,lock,if,consumer,null,this,consumer,null,throw,new,illegal,state,exception,cannot,call,get,class,get,name,set,consumer,undertow,consumer,with,a,non,null,consumer,before,unsetting,it,via,set,consumer,null,this,consumer,consumer
CamelWebSocketHandler -> public void setConsumer(UndertowConsumer consumer);1540108160;@param consumer the {@link UndertowConsumer} to set;public void setConsumer(UndertowConsumer consumer) {_        synchronized (consumerLock) {_            if (consumer != null && this.consumer != null) {_                throw new IllegalStateException("Cannot call " + getClass().getName()_                        + ".setConsumer(UndertowConsumer) with a non-null consumer before unsetting it via setConsumer(null)")__            }_            this.consumer = consumer__        }_    };param,consumer,the,link,undertow,consumer,to,set;public,void,set,consumer,undertow,consumer,consumer,synchronized,consumer,lock,if,consumer,null,this,consumer,null,throw,new,illegal,state,exception,cannot,call,get,class,get,name,set,consumer,undertow,consumer,with,a,non,null,consumer,before,unsetting,it,via,set,consumer,null,this,consumer,consumer
