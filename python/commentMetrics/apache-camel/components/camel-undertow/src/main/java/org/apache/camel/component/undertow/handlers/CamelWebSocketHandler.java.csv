commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public void handleEvent(WebSocketChannel channel) {     sendEventNotificationIfNeeded((String) channel.getAttribute(UndertowConstants.CONNECTION_KEY), EventType.ONCLOSE). }
true;private,static;4;24;/**  * Send the given {@code message} to the given {@code channel} and report the outcome to the given {@code callback}  * within the given {@code timeoutMillis}.  *  * @param channel  *            the channel to sent the {@code message} to  * @param message  *            the message to send  * @param callback  *            where to report the outcome  * @param timeoutMillis  *            the timeout in milliseconds  * @throws IOException  */ ;/**  * Send the given {@code message} to the given {@code channel} and report the outcome to the given {@code callback}  * within the given {@code timeoutMillis}.  *  * @param channel  *            the channel to sent the {@code message} to  * @param message  *            the message to send  * @param callback  *            where to report the outcome  * @param timeoutMillis  *            the timeout in milliseconds  * @throws IOException  */ private static void send(WebSocketChannel channel, Object message, ExtendedWebSocketCallback callback, long timeoutMillis) throws IOException {     if (channel.isOpen()) {         if (message instanceof String) {             WebSockets.sendText((String) message, channel, callback).         } else if (message instanceof byte[]) {             ByteBuffer buffer = ByteBuffer.wrap((byte[]) message).             WebSockets.sendBinary(buffer, channel, callback, timeoutMillis).         } else if (message instanceof Reader) {             Reader r = (Reader) message.             WebSockets.sendText(IOConverter.toString(r), channel, callback).         } else if (message instanceof InputStream) {             InputStream in = (InputStream) message.             ByteBuffer buffer = ByteBuffer.wrap(IOConverter.toBytes(in)).             WebSockets.sendBinary(buffer, channel, callback, timeoutMillis).         } else {             throw new RuntimeCamelException("Unexpected type of message " + message.getClass().getName() + ". expected String, byte[], " + Reader.class.getName() + " or " + InputStream.class.getName()).         }     } else {         callback.closedBeforeSent(channel).     } }
true;public;1;4;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public void handleRequest(HttpServerExchange exchange) throws Exception {     this.delegate.handleRequest(exchange). }
true;public;5;15;/**  * Send the given {@code message} to one or more channels selected using the given {@code peerFilter} within the  * given {@code timeout} and report the outcome to the given {@code camelExchange} and {@code camelCallback}.  *  * @param peerFilter  *            a {@link Predicate} to apply to the set of peers obtained via {@link #delegate}'s  *            {@link WebSocketProtocolHandshakeHandler#getPeerConnections()}  * @param message  *            the message to send  * @param camelExchange to notify about the outcome  * @param camelCallback to notify about the outcome  * @param timeout  *            in milliseconds  * @return {@code true} if the execution finished synchronously or {@code false} otherwise  * @throws IOException  */ ;/**  * Send the given {@code message} to one or more channels selected using the given {@code peerFilter} within the  * given {@code timeout} and report the outcome to the given {@code camelExchange} and {@code camelCallback}.  *  * @param peerFilter  *            a {@link Predicate} to apply to the set of peers obtained via {@link #delegate}'s  *            {@link WebSocketProtocolHandshakeHandler#getPeerConnections()}  * @param message  *            the message to send  * @param camelExchange to notify about the outcome  * @param camelCallback to notify about the outcome  * @param timeout  *            in milliseconds  * @return {@code true} if the execution finished synchronously or {@code false} otherwise  * @throws IOException  */ public boolean send(Predicate<WebSocketChannel> peerFilter, Object message, final int timeout, final Exchange camelExchange, final AsyncCallback camelCallback) throws IOException {     List<WebSocketChannel> targetPeers = delegate.getPeerConnections().stream().filter(peerFilter).collect(Collectors.toList()).     if (targetPeers.isEmpty()) {         camelCallback.done(true).         return true.     } else {         /* There are some peers to send the message to */         MultiCallback wsCallback = new MultiCallback(targetPeers, camelCallback, camelExchange).         for (WebSocketChannel peer : targetPeers) {             send(peer, message, wsCallback, timeout).         }         return false.     } }
true;public;1;9;/**  * @param consumer the {@link UndertowConsumer} to set  */ ;/**  * @param consumer the {@link UndertowConsumer} to set  */ public void setConsumer(UndertowConsumer consumer) {     synchronized (consumerLock) {         if (consumer != null && this.consumer != null) {             throw new IllegalStateException("Cannot call " + getClass().getName() + ".setConsumer(UndertowConsumer) with a non-null consumer before unsetting it via setConsumer(null)").         }         this.consumer = consumer.     } }
false;;2;13;;void sendEventNotificationIfNeeded(String connectionKey, EventType eventType) {     synchronized (consumerLock) {         synchronized (consumerLock) {             if (consumer != null) {                 if (consumer.getEndpoint().isFireWebSocketChannelEvents()) {                     consumer.sendEventNotification(connectionKey, eventType).                 }             } else {                 LOG.debug("No consumer to handle a peer {} event type {}", connectionKey, eventType).             }         }     } }
false;public;1;9;;@Override public void closedBeforeSent(WebSocketChannel channel) {     synchronized (lock) {         peers.remove(channel).         if (peers.isEmpty()) {             finish().         }     } }
false;public;2;9;;@Override public void complete(WebSocketChannel channel, Void context) {     synchronized (lock) {         peers.remove(channel).         if (peers.isEmpty()) {             finish().         }     } }
true;private;0;17;/**  * {@link #finish()} should be called only inside a <code>synchronized(lock) { ... }</code> block to prevent  * concurrent access to {@link #errors}.  */ ;/**  * {@link #finish()} should be called only inside a <code>synchronized(lock) { ... }</code> block to prevent  * concurrent access to {@link #errors}.  */ private void finish() {     if (errors != null && !errors.isEmpty()) {         if (errors.size() == 1) {             final Entry<String, Throwable> en = errors.entrySet().iterator().next().             final String msg = "Delivery to the WebSocket peer " + en.getKey() + " channels has failed".             camelExchange.setException(new CamelExchangeException(msg, camelExchange, en.getValue())).         } else {             final StringBuilder msg = new StringBuilder("Delivery to the following WebSocket peer channels has failed: ").             for (Entry<String, Throwable> en : errors.entrySet()) {                 msg.append("\n    ").append(en.getKey()).append(en.getValue().getMessage()).             }             camelExchange.setException(new CamelExchangeException(msg.toString(), camelExchange)).         }     }     camelCallback.done(false). }
false;public;3;18;;@Override public void onError(WebSocketChannel channel, Void context, Throwable throwable) {     synchronized (lock) {         peers.remove(channel).         final String connectionKey = (String) channel.getAttribute(UndertowConstants.CONNECTION_KEY).         if (connectionKey == null) {             throw new RuntimeCamelException(UndertowConstants.CONNECTION_KEY + " attribute not found on " + WebSocketChannel.class.getSimpleName() + " " + channel).         }         if (errors == null) {             errors = new HashMap<>().         }         errors.put(connectionKey, throwable).         if (peers.isEmpty()) {             finish().         }     } }
false;protected;2;34;;protected void onFullBinaryMessage(final WebSocketChannel channel, BufferedBinaryMessage message) throws IOException {     LOG.debug("onFullBinaryMessage()").     final String connectionKey = (String) channel.getAttribute(UndertowConstants.CONNECTION_KEY).     if (connectionKey == null) {         throw new RuntimeCamelException(UndertowConstants.CONNECTION_KEY + " attribute not found on " + WebSocketChannel.class.getSimpleName() + " " + channel).     }     final Pooled<ByteBuffer[]> data = message.getData().     try {         final ByteBuffer[] buffers = data.getResource().         int len = 0.         for (ByteBuffer buffer : buffers) {             len += buffer.remaining().         }         byte[] bytes = new byte[len].         int offset = 0.         for (ByteBuffer buffer : buffers) {             int increment = buffer.remaining().             buffer.get(bytes, offset, increment).             offset += increment.         }         synchronized (consumerLock) {             if (consumer != null) {                 final Object outMsg = consumer.getEndpoint().isUseStreaming() ? new ByteArrayInputStream(bytes) : bytes.                 consumer.sendMessage(connectionKey, outMsg).             } else {                 LOG.debug("No consumer to handle message received: {}", message).             }         }     } finally {         data.free().     } }
false;protected;2;18;;@Override protected void onFullTextMessage(WebSocketChannel channel, BufferedTextMessage message) {     final String text = message.getData().     LOG.debug("onFullTextMessage(): {}", text).     final String connectionKey = (String) channel.getAttribute(UndertowConstants.CONNECTION_KEY).     if (connectionKey == null) {         throw new RuntimeCamelException(UndertowConstants.CONNECTION_KEY + " attribute not found on " + WebSocketChannel.class.getSimpleName() + " " + channel).     }     synchronized (consumerLock) {         if (consumer != null) {             final Object outMsg = consumer.getEndpoint().isUseStreaming() ? new StringReader(text) : text.             consumer.sendMessage(connectionKey, outMsg).         } else {             LOG.debug("No consumer to handle message received: {}", message).         }     } }
false;public;2;10;;@Override public void onConnect(WebSocketHttpExchange exchange, WebSocketChannel channel) {     LOG.trace("onConnect {}", exchange).     final String connectionKey = UUID.randomUUID().toString().     channel.setAttribute(UndertowConstants.CONNECTION_KEY, connectionKey).     channel.getReceiveSetter().set(receiveListener).     channel.addCloseTask(closeListener).     sendEventNotificationIfNeeded(connectionKey, EventType.ONOPEN).     channel.resumeReceives(). }
