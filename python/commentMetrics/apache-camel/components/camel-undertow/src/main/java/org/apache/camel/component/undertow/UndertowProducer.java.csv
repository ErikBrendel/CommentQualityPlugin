commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public UndertowEndpoint getEndpoint() {     return endpoint. }
false;;1;5;;boolean isSendToAll(Message in) {     // header may be null. have to be careful here (and fallback to use sendToAll option configured from endpoint)     Boolean value = in.getHeader(UndertowConstants.SEND_TO_ALL, endpoint.getSendToAll(), Boolean.class).     return value == null ? false : value. }
false;public;2;82;;@Override public boolean process(final Exchange camelExchange, final AsyncCallback callback) {     if (endpoint.isWebSocket()) {         return processWebSocket(camelExchange, callback).     } else {         /* not a WebSocket */         final URI uri.         final HttpString method.         try {             final String exchangeUri = UndertowHelper.createURL(camelExchange, getEndpoint()).             uri = UndertowHelper.createURI(camelExchange, exchangeUri, getEndpoint()).             method = UndertowHelper.createMethod(camelExchange, endpoint, camelExchange.getIn().getBody() != null).         } catch (final URISyntaxException e) {             camelExchange.setException(e).             callback.done(true).             return true.         }         final String pathAndQuery = URISupport.pathAndQueryOf(uri).         final UndertowHttpBinding undertowHttpBinding = endpoint.getUndertowHttpBinding().         final CookieHandler cookieHandler = endpoint.getCookieHandler().         final Map<String, List<String>> cookieHeaders.         if (cookieHandler != null) {             try {                 cookieHeaders = cookieHandler.loadCookies(camelExchange, uri).             } catch (final IOException e) {                 camelExchange.setException(e).                 callback.done(true).                 return true.             }         } else {             cookieHeaders = Collections.emptyMap().         }         final ClientRequest request = new ClientRequest().         request.setMethod(method).         request.setPath(pathAndQuery).         final HeaderMap requestHeaders = request.getRequestHeaders().         // Set the Host header         final Message message = camelExchange.getIn().         final String host = message.getHeader(Headers.HOST_STRING, String.class).         requestHeaders.put(Headers.HOST, Optional.ofNullable(host).orElseGet(() -> uri.getAuthority())).         final Object body = undertowHttpBinding.toHttpRequest(request, camelExchange.getIn()).         final TypeConverter tc = endpoint.getCamelContext().getTypeConverter().         final ByteBuffer bodyAsByte = tc.tryConvertTo(ByteBuffer.class, body).         // or the call bodyAsByte.remaining() may throw an NPE         if (body != null && bodyAsByte != null) {             requestHeaders.put(Headers.CONTENT_LENGTH, bodyAsByte.remaining()).         }         for (final Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {             requestHeaders.putAll(HttpString.tryFromString(entry.getKey()), entry.getValue()).         }         if (log.isDebugEnabled()) {             log.debug("Executing http {} method: {}", method, pathAndQuery).         }         final UndertowClientCallback clientCallback = new UndertowClientCallback(camelExchange, callback, getEndpoint(), request, bodyAsByte).         // when connect succeeds or fails UndertowClientCallback will         // get notified on a I/O thread run by Xnio worker. The writing         // of request and reading of response is performed also in the         // callback         client.connect(clientCallback, uri, worker, ssl, pool, options).         // ends with success or failure from UndertowClientCallback         return false.     } }
false;private;2;41;;private boolean processWebSocket(final Exchange camelExchange, final AsyncCallback camelCallback) {     final Message in = camelExchange.getIn().     try {         Object message = in.getBody().         if (!(message instanceof String || message instanceof byte[] || message instanceof Reader || message instanceof InputStream)) {             message = in.getBody(String.class).         }         if (message != null) {             final int timeout = endpoint.getSendTimeout().             if (isSendToAll(in)) {                 return webSocketHandler.send(peer -> true, message, timeout, camelExchange, camelCallback).             }             final List<String> connectionKeys = in.getHeader(UndertowConstants.CONNECTION_KEY_LIST, List.class).             if (connectionKeys != null) {                 return webSocketHandler.send(peer -> connectionKeys.contains(peer.getAttribute(UndertowConstants.CONNECTION_KEY)), message, timeout, camelExchange, camelCallback).             }             final String connectionKey = in.getHeader(UndertowConstants.CONNECTION_KEY, String.class).             if (connectionKey != null) {                 return webSocketHandler.send(peer -> connectionKey.equals(peer.getAttribute(UndertowConstants.CONNECTION_KEY)), message, timeout, camelExchange, camelCallback).             }             throw new IllegalStateException(String.format("Cannot process message which has none of the headers %s, %s or %s set: %s", UndertowConstants.SEND_TO_ALL, UndertowConstants.CONNECTION_KEY_LIST, UndertowConstants.CONNECTION_KEY, in)).         } else {             /* nothing to do for a null body */             camelCallback.done(true).             return true.         }     } catch (Exception e) {         camelExchange.setException(e).         camelCallback.done(true).         return true.     } }
false;protected;0;23;;@Override protected void doStart() throws Exception {     super.doStart().     // as in Undertow tests     pool = new DefaultByteBufferPool(true, 17 * 1024).     final Xnio xnio = Xnio.getInstance().     worker = xnio.createWorker(options).     final SSLContext sslContext = getEndpoint().getSslContext().     if (sslContext != null) {         ssl = new UndertowXnioSsl(xnio, options, sslContext).     }     client = UndertowClient.getInstance().     if (endpoint.isWebSocket()) {         this.webSocketHandler = (CamelWebSocketHandler) endpoint.getComponent().registerEndpoint(endpoint.getHttpHandlerRegistrationInfo(), endpoint.getSslContext(), new CamelWebSocketHandler()).     }     log.debug("Created worker: {} with options: {}", worker, options). }
false;protected;0;13;;@Override protected void doStop() throws Exception {     super.doStop().     if (endpoint.isWebSocket()) {         endpoint.getComponent().unregisterEndpoint(endpoint.getHttpHandlerRegistrationInfo(), endpoint.getSslContext()).     }     if (worker != null && !worker.isShutdown()) {         log.debug("Shutting down worker: {}", worker).         worker.shutdown().     } }
