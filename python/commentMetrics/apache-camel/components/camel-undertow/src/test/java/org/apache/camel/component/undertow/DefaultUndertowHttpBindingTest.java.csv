commented;modifiers;parameterAmount;loc;comment;code
false;public;0;14;;@Test(timeout = 1000) public void readEntireDelayedPayload() throws Exception {     String[] delayedPayloads = new String[] { "", "chunk" }.     StreamSourceChannel source = source(delayedPayloads).     DefaultUndertowHttpBinding binding = new DefaultUndertowHttpBinding().     String result = new String(binding.readFromChannel(source)).     checkResult(result, delayedPayloads). }
false;public;0;15;;@Test(timeout = 1000) public void readEntireMultiDelayedPayload() throws Exception {     String[] delayedPayloads = new String[] { "", "first ", "second" }.     StreamSourceChannel source = source(delayedPayloads).     DefaultUndertowHttpBinding binding = new DefaultUndertowHttpBinding().     String result = new String(binding.readFromChannel(source)).     checkResult(result, delayedPayloads). }
false;private;2;5;;private void checkResult(String result, String[] delayedPayloads) {     assertThat(result, is(Stream.of(delayedPayloads).collect(Collectors.joining()))). }
false;public;0;16;;@Test(timeout = 1000) public void readEntireMultiDelayedWithPausePayload() throws Exception {     String[] delayedPayloads = new String[] { "", "first ", "", "second" }.     StreamSourceChannel source = source(delayedPayloads).     DefaultUndertowHttpBinding binding = new DefaultUndertowHttpBinding().     String result = new String(binding.readFromChannel(source)).     checkResult(result, delayedPayloads). }
false;public;1;16;;@Override public int read(ByteBuffer dst) throws IOException {     if (mustWait) {         fail("must wait before reading").     }     if (chunk < delayedPayloads.length) {         byte[] delayedPayload = delayedPayloads[chunk].getBytes().         dst.put(delayedPayload).         chunk++.         if (delayedPayload.length == 0) {             mustWait = true.         }         return delayedPayload.length.     }     return -1. }
false;public;0;9;;@Override public void resumeReads() {     /**      * {@link io.undertow.server.HttpServerExchange.ReadDispatchChannel} delays resumes in the main thread      */     if (sourceThread != Thread.currentThread()) {         super.resumeReads().     } }
false;public;0;5;;@Override public void awaitReadable() throws IOException {     mustWait = false.     super.awaitReadable(). }
false;private;1;41;;private StreamSourceChannel source(final String[] delayedPayloads) {     Thread sourceThread = Thread.currentThread().     return new EmptyStreamSourceChannel(thread()) {          int chunk.          // make sure that the caller is not spinning on read==0         boolean mustWait.          @Override         public int read(ByteBuffer dst) throws IOException {             if (mustWait) {                 fail("must wait before reading").             }             if (chunk < delayedPayloads.length) {                 byte[] delayedPayload = delayedPayloads[chunk].getBytes().                 dst.put(delayedPayload).                 chunk++.                 if (delayedPayload.length == 0) {                     mustWait = true.                 }                 return delayedPayload.length.             }             return -1.         }          @Override         public void resumeReads() {             /**              * {@link io.undertow.server.HttpServerExchange.ReadDispatchChannel} delays resumes in the main thread              */             if (sourceThread != Thread.currentThread()) {                 super.resumeReads().             }         }          @Override         public void awaitReadable() throws IOException {             mustWait = false.             super.awaitReadable().         }     }. }
false;public;1;4;;@Override public void execute(Runnable runnable) {     executor.execute(runnable). }
false;public;3;5;;@Override public Key executeAfter(Runnable runnable, long l, TimeUnit timeUnit) {     execute(runnable).     return null. }
false;public;3;5;;@Override public Key executeAtInterval(Runnable runnable, long l, TimeUnit timeUnit) {     execute(runnable).     return null. }
false;private;0;21;;private XnioIoThread thread() {     ExecutorService executor = Executors.newFixedThreadPool(1).     return new XnioIoThread(null, 0) {          @Override         public void execute(Runnable runnable) {             executor.execute(runnable).         }          @Override         public Key executeAfter(Runnable runnable, long l, TimeUnit timeUnit) {             execute(runnable).             return null.         }          @Override         public Key executeAtInterval(Runnable runnable, long l, TimeUnit timeUnit) {             execute(runnable).             return null.         }     }. }
