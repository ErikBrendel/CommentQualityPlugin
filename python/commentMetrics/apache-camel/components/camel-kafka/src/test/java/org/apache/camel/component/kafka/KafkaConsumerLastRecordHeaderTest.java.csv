commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Before public void before() {     Properties props = getDefaultProperties().     producer = new org.apache.kafka.clients.producer.KafkaProducer<>(props). }
false;public;0;6;;@After public void after() {     if (producer != null) {         producer.close().     } }
true;public;0;18;/**  * When consuming data with autoCommitEnable=false  * Then the LAST_RECORD_BEFORE_COMMIT header must be always defined  * And it should be true only for the last one  */ ;/**  * When consuming data with autoCommitEnable=false  * Then the LAST_RECORD_BEFORE_COMMIT header must be always defined  * And it should be true only for the last one  */ @Test public void shouldStartFromBeginningWithEmptyOffsetRepository() throws InterruptedException {     result.expectedMessageCount(5).     result.expectedBodiesReceived("message-0", "message-1", "message-2", "message-3", "message-4").     for (int i = 0. i < 5. i++) {         producer.send(new ProducerRecord<>(TOPIC, "1", "message-" + i)).     }     result.assertIsSatisfied(3000).     List<Exchange> exchanges = result.getExchanges().     for (int i = 0. i < exchanges.size(). i++) {         Boolean header = exchanges.get(i).getIn().getHeader(KafkaConstants.LAST_RECORD_BEFORE_COMMIT, Boolean.class).         assertNotNull("Header not set for #" + i, header).         assertEquals("Header invalid for #" + i, header, i == exchanges.size() - 1).     } }
false;public;0;4;;@Override public void configure() throws Exception {     from("kafka:" + TOPIC + "?groupId=A&autoOffsetReset=earliest&autoCommitEnable=false").to("mock:result"). }
false;protected;0;9;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             from("kafka:" + TOPIC + "?groupId=A&autoOffsetReset=earliest&autoCommitEnable=false").to("mock:result").         }     }. }
