commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Test public void testPropertyBuilder() throws Exception {     Properties props = producer.getProps().     assertEquals("broker1:1234,broker2:4567", props.getProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG)). }
false;public;0;13;;@Test @SuppressWarnings({ "unchecked" }) public void processSendsMessage() throws Exception {     endpoint.getConfiguration().setTopic("sometopic").     Mockito.when(exchange.getIn()).thenReturn(in).     Mockito.when(exchange.getOut()).thenReturn(out).     in.setHeader(KafkaConstants.PARTITION_KEY, 4).     producer.process(exchange).     Mockito.verify(producer.getKafkaProducer()).send(any(ProducerRecord.class)).     assertRecordMetadataExists(). }
false;public;0;14;;@Test(expected = Exception.class) @SuppressWarnings({ "unchecked" }) public void processSendsMessageWithException() throws Exception {     endpoint.getConfiguration().setTopic("sometopic").     // setup the exception here     org.apache.kafka.clients.producer.KafkaProducer kp = producer.getKafkaProducer().     Mockito.when(kp.send(any(ProducerRecord.class))).thenThrow(new ApiException()).     Mockito.when(exchange.getIn()).thenReturn(in).     in.setHeader(KafkaConstants.PARTITION_KEY, 4).     producer.process(exchange).     assertRecordMetadataExists(). }
false;public;0;16;;@Test public void processAsyncSendsMessage() throws Exception {     endpoint.getConfiguration().setTopic("sometopic").     Mockito.when(exchange.getIn()).thenReturn(in).     Mockito.when(exchange.getOut()).thenReturn(out).     in.setHeader(KafkaConstants.PARTITION_KEY, 4).     producer.process(exchange, callback).     ArgumentCaptor<Callback> callBackCaptor = ArgumentCaptor.forClass(Callback.class).     Mockito.verify(producer.getKafkaProducer()).send(any(ProducerRecord.class), callBackCaptor.capture()).     Callback kafkaCallback = callBackCaptor.getValue().     kafkaCallback.onCompletion(new RecordMetadata(null, 0, 0, 0, new Long(0), 0, 0), null).     assertRecordMetadataExists(). }
false;public;0;22;;@Test public void processAsyncSendsMessageWithException() throws Exception {     endpoint.getConfiguration().setTopic("sometopic").     Mockito.when(exchange.getIn()).thenReturn(in).     Mockito.when(exchange.getOut()).thenReturn(out).     // setup the exception here     org.apache.kafka.clients.producer.KafkaProducer kp = producer.getKafkaProducer().     Mockito.when(kp.send(any(ProducerRecord.class), any(Callback.class))).thenThrow(new ApiException()).     in.setHeader(KafkaConstants.PARTITION_KEY, 4).     producer.process(exchange, callback).     ArgumentCaptor<Callback> callBackCaptor = ArgumentCaptor.forClass(Callback.class).     Mockito.verify(producer.getKafkaProducer()).send(any(ProducerRecord.class), callBackCaptor.capture()).     Mockito.verify(exchange).setException(isA(ApiException.class)).     Mockito.verify(callback).done(eq(true)).     Callback kafkaCallback = callBackCaptor.getValue().     kafkaCallback.onCompletion(new RecordMetadata(null, 0, 0, 0, new Long(0), 0, 0), null).     assertRecordMetadataExists(). }
false;public;0;12;;@Test public void processSendsMessageWithTopicHeaderAndNoTopicInEndPoint() throws Exception {     endpoint.getConfiguration().setTopic(null).     Mockito.when(exchange.getIn()).thenReturn(in).     in.setHeader(KafkaConstants.TOPIC, "anotherTopic").     Mockito.when(exchange.getOut()).thenReturn(out).     producer.process(exchange).     verifySendMessage("anotherTopic").     assertRecordMetadataExists(). }
false;public;0;15;;@Test public void processSendsMessageWithTopicHeaderAndEndPoint() throws Exception {     endpoint.getConfiguration().setTopic("sometopic").     Mockito.when(exchange.getIn()).thenReturn(in).     Mockito.when(exchange.getOut()).thenReturn(out).     in.setHeader(KafkaConstants.PARTITION_KEY, 4).     in.setHeader(KafkaConstants.TOPIC, "anotherTopic").     in.setHeader(KafkaConstants.KEY, "someKey").     producer.process(exchange).     verifySendMessage(4, "anotherTopic", "someKey").     assertRecordMetadataExists(). }
false;public;0;12;;@Test public void processRequiresTopicInEndpointOrInHeader() throws Exception {     endpoint.getConfiguration().setTopic(null).     Mockito.when(exchange.getIn()).thenReturn(in).     in.setHeader(KafkaConstants.PARTITION_KEY, 4).     in.setHeader(KafkaConstants.KEY, "someKey").     producer.process(exchange).     verifySendMessage("sometopic", "someKey").     assertRecordMetadataExists(). }
false;public;0;12;;@Test public void processRequiresTopicInConfiguration() throws Exception {     endpoint.getConfiguration().setTopic("configTopic").     Mockito.when(exchange.getIn()).thenReturn(in).     in.setHeader(KafkaConstants.PARTITION_KEY, 4).     in.setHeader(KafkaConstants.KEY, "someKey").     producer.process(exchange).     verifySendMessage("configTopic", "someKey").     assertRecordMetadataExists(). }
false;public;0;10;;@Test public void processDoesNotRequirePartitionHeader() throws Exception {     endpoint.getConfiguration().setTopic("sometopic").     Mockito.when(exchange.getIn()).thenReturn(in).     Mockito.when(exchange.getOut()).thenReturn(out).     producer.process(exchange).     assertRecordMetadataExists(). }
false;public;0;13;;@Test public void processSendsMessageWithPartitionKeyHeader() throws Exception {     endpoint.getConfiguration().setTopic("someTopic").     Mockito.when(exchange.getIn()).thenReturn(in).     Mockito.when(exchange.getOut()).thenReturn(out).     in.setHeader(KafkaConstants.PARTITION_KEY, 4).     in.setHeader(KafkaConstants.KEY, "someKey").     producer.process(exchange).     verifySendMessage(4, "someTopic", "someKey").     assertRecordMetadataExists(). }
false;public;0;12;;@Test public void processSendsMessageWithMessageKeyHeader() throws Exception {     endpoint.getConfiguration().setTopic("someTopic").     Mockito.when(exchange.getIn()).thenReturn(in).     Mockito.when(exchange.getOut()).thenReturn(out).     in.setHeader(KafkaConstants.KEY, "someKey").     producer.process(exchange).     verifySendMessage("someTopic", "someKey").     assertRecordMetadataExists(). }
false;public;0;15;;@Test public void processSendMessageWithBridgeEndpoint() throws Exception {     endpoint.getConfiguration().setTopic("someTopic").     endpoint.getConfiguration().setBridgeEndpoint(true).     Mockito.when(exchange.getIn()).thenReturn(in).     Mockito.when(exchange.getOut()).thenReturn(out).     in.setHeader(KafkaConstants.TOPIC, "anotherTopic").     in.setHeader(KafkaConstants.KEY, "someKey").     in.setHeader(KafkaConstants.PARTITION_KEY, 4).     producer.process(exchange).     verifySendMessage(4, "someTopic", "someKey").     assertRecordMetadataExists(). }
false;public;0;16;;@Test public void processSendMessageWithCircularDetected() throws Exception {     endpoint.getConfiguration().setTopic("sometopic").     endpoint.getConfiguration().setCircularTopicDetection(true).     Mockito.when(exchange.getIn()).thenReturn(in).     Mockito.when(exchange.getOut()).thenReturn(out).     Mockito.when(exchange.getFromEndpoint()).thenReturn(fromEndpoint).     // this is the from topic that are from the fromEndpoint     in.setHeader(KafkaConstants.TOPIC, "fromtopic").     in.setHeader(KafkaConstants.KEY, "somekey").     producer.process(exchange).     verifySendMessage("sometopic", "somekey").     assertRecordMetadataExists(). }
false;public;0;17;;@Test public void processSendMessageWithNoCircularDetected() throws Exception {     endpoint.getConfiguration().setTopic("sometopic").     endpoint.getConfiguration().setCircularTopicDetection(false).     Mockito.when(exchange.getIn()).thenReturn(in).     Mockito.when(exchange.getOut()).thenReturn(out).     Mockito.when(exchange.getFromEndpoint()).thenReturn(fromEndpoint).     // this is the from topic that are from the fromEndpoint     in.setHeader(KafkaConstants.TOPIC, "fromtopic").     in.setHeader(KafkaConstants.KEY, "somekey").     producer.process(exchange).     // will end up sending back to itself at fromtopic     verifySendMessage("fromtopic", "somekey").     assertRecordMetadataExists(). }
false;public;0;11;;// Message and Topic Name alone @Test public void processSendsMessageWithMessageTopicName() throws Exception {     endpoint.getConfiguration().setTopic("someTopic").     Mockito.when(exchange.getIn()).thenReturn(in).     Mockito.when(exchange.getOut()).thenReturn(out).     producer.process(exchange).     verifySendMessage("someTopic").     assertRecordMetadataExists(). }
false;protected;3;8;;@SuppressWarnings({ "unchecked", "rawtypes" }) protected void verifySendMessage(Integer partitionKey, String topic, String messageKey) {     ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class).     Mockito.verify(producer.getKafkaProducer()).send(captor.capture()).     assertEquals(partitionKey, captor.getValue().partition()).     assertEquals(messageKey, captor.getValue().key()).     assertEquals(topic, captor.getValue().topic()). }
false;protected;2;7;;@SuppressWarnings({ "unchecked", "rawtypes" }) protected void verifySendMessage(String topic, String messageKey) {     ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class).     Mockito.verify(producer.getKafkaProducer()).send(captor.capture()).     assertEquals(messageKey, captor.getValue().key()).     assertEquals(topic, captor.getValue().topic()). }
false;protected;1;6;;@SuppressWarnings({ "unchecked", "rawtypes" }) protected void verifySendMessage(String topic) {     ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class).     Mockito.verify(producer.getKafkaProducer()).send(captor.capture()).     assertEquals(topic, captor.getValue().topic()). }
false;private;0;6;;private void assertRecordMetadataExists() {     List<RecordMetadata> recordMetaData1 = (List<RecordMetadata>) in.getHeader(KafkaConstants.KAFKA_RECORDMETA).     assertTrue(recordMetaData1 != null).     assertEquals("Expected one recordMetaData", recordMetaData1.size(), 1).     assertTrue(recordMetaData1.get(0) != null). }
