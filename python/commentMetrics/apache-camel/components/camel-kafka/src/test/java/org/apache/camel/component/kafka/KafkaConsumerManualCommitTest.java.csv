commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Before public void before() {     Properties props = getDefaultProperties().     producer = new org.apache.kafka.clients.producer.KafkaProducer<>(props). }
false;public;0;6;;@After public void after() {     if (producer != null) {         producer.close().     } }
false;public;0;10;;@Override public void configure() throws Exception {     from(from).routeId("foo").to(to).process(e -> {         KafkaManualCommit manual = e.getIn().getHeader(KafkaConstants.MANUAL_COMMIT, KafkaManualCommit.class).         assertNotNull(manual).         manual.commitSync().     }). }
false;protected;0;16;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             from(from).routeId("foo").to(to).process(e -> {                 KafkaManualCommit manual = e.getIn().getHeader(KafkaConstants.MANUAL_COMMIT, KafkaManualCommit.class).                 assertNotNull(manual).                 manual.commitSync().             }).         }     }. }
false;public;0;17;;@Test public void kafkaManualCommit() throws InterruptedException, IOException {     to.expectedMessageCount(5).     to.expectedBodiesReceivedInAnyOrder("message-0", "message-1", "message-2", "message-3", "message-4").     // The LAST_RECORD_BEFORE_COMMIT header should include a value as we use manual commit     to.allMessages().header(KafkaConstants.LAST_RECORD_BEFORE_COMMIT).isNotNull().     for (int k = 0. k < 5. k++) {         String msg = "message-" + k.         ProducerRecord<String, String> data = new ProducerRecord<>(TOPIC, "1", msg).         producer.send(data).     }     to.assertIsSatisfied(3000).     assertEquals(5, StreamSupport.stream(MockConsumerInterceptor.recordsCaptured.get(0).records(TOPIC).spliterator(), false).count()). }
