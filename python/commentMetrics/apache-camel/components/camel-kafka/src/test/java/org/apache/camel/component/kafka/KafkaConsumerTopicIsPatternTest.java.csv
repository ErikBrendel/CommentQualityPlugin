commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before public void before() {     Properties props = getDefaultProperties().     producer = new org.apache.kafka.clients.producer.KafkaProducer<>(props). }
false;public;0;6;;@After public void after() {     if (producer != null) {         producer.close().     } }
false;public;0;4;;@Override public void configure() throws Exception {     from(from).to(to). }
false;protected;0;10;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             from(from).to(to).         }     }. }
false;public;0;18;;@Test public void kafkaTopicIsPattern() throws Exception {     to.expectedMessageCount(5).     to.expectedBodiesReceivedInAnyOrder("message-0", "message-1", "message-2", "message-3", "message-4").     to.allMessages().header(KafkaConstants.TOPIC).isEqualTo("test").     // The LAST_RECORD_BEFORE_COMMIT header should not be configured on any exchange because autoCommitEnable=true     to.expectedHeaderValuesReceivedInAnyOrder(KafkaConstants.LAST_RECORD_BEFORE_COMMIT, null, null, null, null, null).     for (int k = 0. k < 5. k++) {         String msg = "message-" + k.         ProducerRecord<String, String> data = new ProducerRecord<>(TOPIC, "1", msg).         producer.send(data).     }     to.assertIsSatisfied(3000).     assertEquals(5, StreamSupport.stream(MockConsumerInterceptor.recordsCaptured.get(0).records(TOPIC).spliterator(), false).count()). }
