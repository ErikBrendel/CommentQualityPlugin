commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;30;;@Override protected KafkaEndpoint createEndpoint(String uri, String remaining, Map<String, Object> params) throws Exception {     if (ObjectHelper.isEmpty(remaining)) {         throw new IllegalArgumentException("Topic must be configured on endpoint using syntax kafka:topic").     }     KafkaEndpoint endpoint = new KafkaEndpoint(uri, this).     if (configuration != null) {         KafkaConfiguration copy = configuration.copy().         endpoint.setConfiguration(copy).     }     endpoint.getConfiguration().setTopic(remaining).     endpoint.getConfiguration().setWorkerPool(getWorkerPool()).     endpoint.getConfiguration().setBreakOnFirstError(isBreakOnFirstError()).     endpoint.getConfiguration().setAllowManualCommit(isAllowManualCommit()).     // brokers can be configured on either component or endpoint level     // and the consumer and produce is aware of this and act accordingly     setProperties(endpoint.getConfiguration(), params).     setProperties(endpoint, params).     if (endpoint.getConfiguration().getSslContextParameters() == null) {         endpoint.getConfiguration().setSslContextParameters(retrieveGlobalSslContextParameters()).     }     return endpoint. }
false;public;0;3;;public KafkaConfiguration getConfiguration() {     return configuration. }
true;public;1;3;/**  * Allows to pre-configure the Kafka component with common options that the endpoints will reuse.  */ ;/**  * Allows to pre-configure the Kafka component with common options that the endpoints will reuse.  */ public void setConfiguration(KafkaConfiguration configuration) {     this.configuration = configuration. }
false;public;0;3;;public String getBrokers() {     return configuration != null ? configuration.getBrokers() : null. }
true;public;1;6;/**  * URL of the Kafka brokers to use.  * The format is host1:port1,host2:port2, and the list can be a subset of brokers or a VIP pointing to a subset of brokers.  * <p/>  * This option is known as <tt>bootstrap.servers</tt> in the Kafka documentation.  */ ;/**  * URL of the Kafka brokers to use.  * The format is host1:port1,host2:port2, and the list can be a subset of brokers or a VIP pointing to a subset of brokers.  * <p/>  * This option is known as <tt>bootstrap.servers</tt> in the Kafka documentation.  */ public void setBrokers(String brokers) {     if (configuration == null) {         configuration = new KafkaConfiguration().     }     configuration.setBrokers(brokers). }
false;public;0;3;;public ExecutorService getWorkerPool() {     return workerPool. }
true;public;1;3;/**  * To use a shared custom worker pool for continue routing {@link Exchange} after kafka server has acknowledge  * the message that was sent to it from {@link KafkaProducer} using asynchronous non-blocking processing.  * If using this option then you must handle the lifecycle of the thread pool to shut the pool down when no longer needed.  */ ;/**  * To use a shared custom worker pool for continue routing {@link Exchange} after kafka server has acknowledge  * the message that was sent to it from {@link KafkaProducer} using asynchronous non-blocking processing.  * If using this option then you must handle the lifecycle of the thread pool to shut the pool down when no longer needed.  */ public void setWorkerPool(ExecutorService workerPool) {     this.workerPool = workerPool. }
false;public;0;4;;@Override public boolean isUseGlobalSslContextParameters() {     return this.useGlobalSslContextParameters. }
true;public;1;4;/**  * Enable usage of global SSL context parameters.  */ ;/**  * Enable usage of global SSL context parameters.  */ @Override public void setUseGlobalSslContextParameters(boolean useGlobalSslContextParameters) {     this.useGlobalSslContextParameters = useGlobalSslContextParameters. }
false;public;0;3;;public boolean isBreakOnFirstError() {     return breakOnFirstError. }
true;public;1;3;/**  * This options controls what happens when a consumer is processing an exchange and it fails.  * If the option is <tt>false</tt> then the consumer continues to the next message and processes it.  * If the option is <tt>true</tt> then the consumer breaks out, and will seek back to offset of the  * message that caused a failure, and then re-attempt to process this message. However this can lead  * to endless processing of the same message if its bound to fail every time, eg a poison message.  * Therefore its recommended to deal with that for example by using Camel's error handler.  */ ;/**  * This options controls what happens when a consumer is processing an exchange and it fails.  * If the option is <tt>false</tt> then the consumer continues to the next message and processes it.  * If the option is <tt>true</tt> then the consumer breaks out, and will seek back to offset of the  * message that caused a failure, and then re-attempt to process this message. However this can lead  * to endless processing of the same message if its bound to fail every time, eg a poison message.  * Therefore its recommended to deal with that for example by using Camel's error handler.  */ public void setBreakOnFirstError(boolean breakOnFirstError) {     this.breakOnFirstError = breakOnFirstError. }
false;public;0;3;;public boolean isAllowManualCommit() {     return allowManualCommit. }
true;public;1;3;/**  * Whether to allow doing manual commits via {@link KafkaManualCommit}.  * <p/>  * If this option is enabled then an instance of {@link KafkaManualCommit} is stored on the {@link Exchange} message header,  * which allows end users to access this API and perform manual offset commits via the Kafka consumer.  */ ;/**  * Whether to allow doing manual commits via {@link KafkaManualCommit}.  * <p/>  * If this option is enabled then an instance of {@link KafkaManualCommit} is stored on the {@link Exchange} message header,  * which allows end users to access this API and perform manual offset commits via the Kafka consumer.  */ public void setAllowManualCommit(boolean allowManualCommit) {     this.allowManualCommit = allowManualCommit. }
false;public;0;3;;public KafkaManualCommitFactory getKafkaManualCommitFactory() {     return kafkaManualCommitFactory. }
true;public;1;3;/**  * Factory to use for creating {@link KafkaManualCommit} instances. This allows to plugin a custom factory  * to create custom {@link KafkaManualCommit} instances in case special logic is needed when doing manual commits  * that deviates from the default implementation that comes out of the box.  */ ;/**  * Factory to use for creating {@link KafkaManualCommit} instances. This allows to plugin a custom factory  * to create custom {@link KafkaManualCommit} instances in case special logic is needed when doing manual commits  * that deviates from the default implementation that comes out of the box.  */ public void setKafkaManualCommitFactory(KafkaManualCommitFactory kafkaManualCommitFactory) {     this.kafkaManualCommitFactory = kafkaManualCommitFactory. }
