commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;public XmlSignerConfiguration copy() {     try {         return (XmlSignerConfiguration) clone().     } catch (CloneNotSupportedException e) {         throw new RuntimeCamelException(e).     } }
false;public;1;9;;@Override public void setCamelContext(CamelContext camelContext) {     super.setCamelContext(camelContext).     // try to retrieve the references once the context is available.     setTransformMethods(transformMethodsName).     setCanonicalizationMethod(canonicalizationMethodName).     setKeyAccessor(keyAccessorName).     setProperties(propertiesName). }
false;public;0;3;;public KeyAccessor getKeyAccessor() {     return keyAccessor. }
true;public;1;3;/**  * For the signing process, a private key is necessary. You specify a key accessor bean which provides this private key.  * The key accessor bean must implement the KeyAccessor interface. The package org.apache.camel.component.xmlsecurity.api  * contains the default implementation class DefaultKeyAccessor which reads the private key from a Java keystore.  */ ;/**  * For the signing process, a private key is necessary. You specify a key accessor bean which provides this private key.  * The key accessor bean must implement the KeyAccessor interface. The package org.apache.camel.component.xmlsecurity.api  * contains the default implementation class DefaultKeyAccessor which reads the private key from a Java keystore.  */ public void setKeyAccessor(KeyAccessor keyAccessor) {     this.keyAccessor = keyAccessor. }
true;public;1;11;/**  * Sets the reference name for a KeyAccessor that can be found in the registry.  */ ;/**  * Sets the reference name for a KeyAccessor that can be found in the registry.  */ public void setKeyAccessor(String keyAccessorName) {     if (getCamelContext() != null && keyAccessorName != null) {         KeyAccessor accessor = getCamelContext().getRegistry().lookupByNameAndType(keyAccessorName, KeyAccessor.class).         if (accessor != null) {             setKeyAccessor(accessor).         }     }     if (keyAccessorName != null) {         this.keyAccessorName = keyAccessorName.     } }
false;public;0;3;;public AlgorithmMethod getCanonicalizationMethod() {     return canonicalizationMethod. }
true;public;1;3;/**  * Canonicalization method used to canonicalize the SignedInfo element before the digest is calculated.  * You can use the helper methods XmlSignatureHelper.getCanonicalizationMethod(String algorithm)  * or getCanonicalizationMethod(String algorithm, List<String> inclusiveNamespacePrefixes) to create a canonicalization method.  */ ;/**  * Canonicalization method used to canonicalize the SignedInfo element before the digest is calculated.  * You can use the helper methods XmlSignatureHelper.getCanonicalizationMethod(String algorithm)  * or getCanonicalizationMethod(String algorithm, List<String> inclusiveNamespacePrefixes) to create a canonicalization method.  */ public void setCanonicalizationMethod(AlgorithmMethod canonicalizationMethod) {     this.canonicalizationMethod = canonicalizationMethod. }
true;public;1;11;/**  * Sets the reference name for a AlgorithmMethod that can be found in the registry.  */ ;/**  * Sets the reference name for a AlgorithmMethod that can be found in the registry.  */ public void setCanonicalizationMethod(String canonicalizationMethodName) {     if (getCamelContext() != null && canonicalizationMethodName != null) {         AlgorithmMethod method = getCamelContext().getRegistry().lookupByNameAndType(canonicalizationMethodName, AlgorithmMethod.class).         if (method != null) {             setCanonicalizationMethod(method).         }     }     if (canonicalizationMethodName != null) {         this.canonicalizationMethodName = canonicalizationMethodName.     } }
false;public;0;3;;public List<AlgorithmMethod> getTransformMethods() {     return transformMethods. }
true;public;1;3;/**  * Transforms which are executed on the message body before the digest is calculated.  * By default, C14n is added and in the case of enveloped signature (see option parentLocalName) also http://www.w3.org/2000/09/xmldsig#enveloped-signature  * is added at position 0 of the list. Use methods in XmlSignatureHelper to create the transform methods.  */ ;/**  * Transforms which are executed on the message body before the digest is calculated.  * By default, C14n is added and in the case of enveloped signature (see option parentLocalName) also http://www.w3.org/2000/09/xmldsig#enveloped-signature  * is added at position 0 of the list. Use methods in XmlSignatureHelper to create the transform methods.  */ public void setTransformMethods(List<AlgorithmMethod> transformMethods) {     this.transformMethods = transformMethods. }
true;public;1;12;/**  * Sets the reference name for a List<AlgorithmMethod> that can be found in the registry.  */ ;/**  * Sets the reference name for a List<AlgorithmMethod> that can be found in the registry.  */ public void setTransformMethods(String transformMethodsName) {     if (getCamelContext() != null && transformMethodsName != null) {         @SuppressWarnings("unchecked")         List<AlgorithmMethod> list = getCamelContext().getRegistry().lookupByNameAndType(transformMethodsName, List.class).         if (list != null) {             setTransformMethods(list).         }     }     if (transformMethodsName != null) {         this.transformMethodsName = transformMethodsName.     } }
false;public;0;3;;public String getSignatureAlgorithm() {     return signatureAlgorithm. }
true;public;1;3;/**  * Signature algorithm. Default value is  * "http://www.w3.org/2000/09/xmldsig#rsa-sha1".  */ ;/**  * Signature algorithm. Default value is  * "http://www.w3.org/2000/09/xmldsig#rsa-sha1".  */ public void setSignatureAlgorithm(String signatureAlgorithm) {     this.signatureAlgorithm = signatureAlgorithm. }
false;public;0;3;;public String getDigestAlgorithm() {     return digestAlgorithm. }
true;public;1;3;/**  * Digest algorithm URI. Optional parameter. This digest algorithm is used  * for calculating the digest of the input message. If this digest algorithm  * is not specified then the digest algorithm is calculated from the  * signature algorithm. Example: "http://www.w3.org/2001/04/xmlenc#sha256"  */ ;/**  * Digest algorithm URI. Optional parameter. This digest algorithm is used  * for calculating the digest of the input message. If this digest algorithm  * is not specified then the digest algorithm is calculated from the  * signature algorithm. Example: "http://www.w3.org/2001/04/xmlenc#sha256"  */ public void setDigestAlgorithm(String digestAlgorithm) {     this.digestAlgorithm = digestAlgorithm. }
false;public;0;3;;public Boolean getAddKeyInfoReference() {     return addKeyInfoReference. }
true;public;1;3;/**  * In order to protect the KeyInfo element from tampering you can add a  * reference to the signed info element so that it is protected via the  * signature value. The default value is <tt>true</tt>.  * <p>  * Only relevant when a KeyInfo is returned by {@link KeyAccessor}. and  * {@link KeyInfo#getId()} is not <code>null</code>.  */ ;/**  * In order to protect the KeyInfo element from tampering you can add a  * reference to the signed info element so that it is protected via the  * signature value. The default value is <tt>true</tt>.  * <p>  * Only relevant when a KeyInfo is returned by {@link KeyAccessor}. and  * {@link KeyInfo#getId()} is not <code>null</code>.  */ public void setAddKeyInfoReference(Boolean addKeyInfoReference) {     this.addKeyInfoReference = addKeyInfoReference. }
false;public;0;3;;public String getPrefixForXmlSignatureNamespace() {     return prefixForXmlSignatureNamespace. }
true;public;1;3;/**  * Namespace prefix for the XML signature namespace  * "http://www.w3.org/2000/09/xmldsig#". Default value is "ds".  *  * If <code>null</code> or an empty value is set then no prefix is used for  * the XML signature namespace.  * <p>  * See best practice  * http://www.w3.org/TR/xmldsig-bestpractices/#signing-xml-  * without-namespaces  *  * @param prefixForXmlSignatureNamespace  *            prefix  */ ;/**  * Namespace prefix for the XML signature namespace  * "http://www.w3.org/2000/09/xmldsig#". Default value is "ds".  *  * If <code>null</code> or an empty value is set then no prefix is used for  * the XML signature namespace.  * <p>  * See best practice  * http://www.w3.org/TR/xmldsig-bestpractices/#signing-xml-  * without-namespaces  *  * @param prefixForXmlSignatureNamespace  *            prefix  */ public void setPrefixForXmlSignatureNamespace(String prefixForXmlSignatureNamespace) {     this.prefixForXmlSignatureNamespace = prefixForXmlSignatureNamespace. }
false;public;0;3;;public String getParentLocalName() {     return parentLocalName. }
true;public;1;3;/**  * Local name of the parent element to which the XML signature element will  * be added. Only relevant for enveloped XML signature. Alternatively you can  * also use {@link #setParentXpath(XPathFilterParameterSpec)}.  *  * <p> Default value is  * <code>null</code>. The value must be <code>null</code> for enveloping and  * detached XML signature.  * <p>  * This parameter or the parameter {@link #setParentXpath(XPathFilterParameterSpec)}  * for enveloped signature and the parameter {@link #setXpathsToIdAttributes(List)}  * for detached signature must not be set in the same configuration.  * <p>  * If the parameters <tt>parentXpath</tt> and <tt>parentLocalName</tt> are specified  * in the same configuration then an exception is thrown.  *  * @param parentLocalName  *            local name  */ ;/**  * Local name of the parent element to which the XML signature element will  * be added. Only relevant for enveloped XML signature. Alternatively you can  * also use {@link #setParentXpath(XPathFilterParameterSpec)}.  *  * <p> Default value is  * <code>null</code>. The value must be <code>null</code> for enveloping and  * detached XML signature.  * <p>  * This parameter or the parameter {@link #setParentXpath(XPathFilterParameterSpec)}  * for enveloped signature and the parameter {@link #setXpathsToIdAttributes(List)}  * for detached signature must not be set in the same configuration.  * <p>  * If the parameters <tt>parentXpath</tt> and <tt>parentLocalName</tt> are specified  * in the same configuration then an exception is thrown.  *  * @param parentLocalName  *            local name  */ public void setParentLocalName(String parentLocalName) {     this.parentLocalName = parentLocalName. }
false;public;0;3;;public String getParentNamespace() {     return parentNamespace. }
true;public;1;3;/**  * Namespace of the parent element to which the XML signature element will  * be added.  */ ;/**  * Namespace of the parent element to which the XML signature element will  * be added.  */ public void setParentNamespace(String parentNamespace) {     this.parentNamespace = parentNamespace. }
false;public;0;7;;public String getContentObjectId() {     if (contentObjectId == null) {         // content object ID must always be set, because it is only used in enveloping case.         contentObjectId = "_" + UUID.randomUUID().toString().     }     return contentObjectId. }
true;public;1;3;/**  * Sets the content object Id attribute value. By default a UUID is  * generated. If you set the <code>null</code> value, then a new UUID will  * be generated. Only used in the enveloping case.  */ ;/**  * Sets the content object Id attribute value. By default a UUID is  * generated. If you set the <code>null</code> value, then a new UUID will  * be generated. Only used in the enveloping case.  */ public void setContentObjectId(String contentObjectId) {     this.contentObjectId = contentObjectId. }
false;public;0;3;;public String getSignatureId() {     return signatureId. }
true;public;1;3;/**  * Sets the signature Id. If this parameter is not set (null value) then a  * unique ID is generated for the signature ID (default). If this parameter  * is set to "" (empty string) then no Id attribute is created in the  * signature element.  */ ;/**  * Sets the signature Id. If this parameter is not set (null value) then a  * unique ID is generated for the signature ID (default). If this parameter  * is set to "" (empty string) then no Id attribute is created in the  * signature element.  */ public void setSignatureId(String signatureId) {     this.signatureId = signatureId. }
false;public;0;3;;public String getContentReferenceUri() {     return contentReferenceUri. }
true;public;1;3;/**  * Reference URI for the content to be signed. Only used in the enveloped  * case. If the reference URI contains an ID attribute value, then the  * resource schema URI ( {@link #setSchemaResourceUri(String)}) must also be  * set because the schema validator will then find out which attributes are  * ID attributes. Will be ignored in the enveloping or detached case.  */ ;/**  * Reference URI for the content to be signed. Only used in the enveloped  * case. If the reference URI contains an ID attribute value, then the  * resource schema URI ( {@link #setSchemaResourceUri(String)}) must also be  * set because the schema validator will then find out which attributes are  * ID attributes. Will be ignored in the enveloping or detached case.  */ public void setContentReferenceUri(String referenceUri) {     this.contentReferenceUri = referenceUri. }
false;public;0;3;;public String getContentReferenceType() {     return contentReferenceType. }
true;public;1;3;/**  * Type of the content reference. The default value is <code>null</code>.  * This value can be overwritten by the header  * {@link XmlSignatureConstants#HEADER_CONTENT_REFERENCE_TYPE}.  */ ;/**  * Type of the content reference. The default value is <code>null</code>.  * This value can be overwritten by the header  * {@link XmlSignatureConstants#HEADER_CONTENT_REFERENCE_TYPE}.  */ public void setContentReferenceType(String referenceType) {     this.contentReferenceType = referenceType. }
false;public;0;3;;public Boolean getPlainText() {     return plainText. }
true;public;1;3;/**  * Indicator whether the message body contains plain text. The default value  * is <code>false</code>, indicating that the message body contains XML. The  * value can be overwritten by the header  * {@link XmlSignatureConstants#HEADER_MESSAGE_IS_PLAIN_TEXT}.  */ ;/**  * Indicator whether the message body contains plain text. The default value  * is <code>false</code>, indicating that the message body contains XML. The  * value can be overwritten by the header  * {@link XmlSignatureConstants#HEADER_MESSAGE_IS_PLAIN_TEXT}.  */ public void setPlainText(Boolean plainText) {     this.plainText = plainText. }
false;public;0;3;;public String getPlainTextEncoding() {     return plainTextEncoding. }
true;public;1;3;/**  * Encoding of the plain text. Only relevant if the message body is plain  * text (see parameter {@link #plainText}. Default value is "UTF-8".  */ ;/**  * Encoding of the plain text. Only relevant if the message body is plain  * text (see parameter {@link #plainText}. Default value is "UTF-8".  */ public void setPlainTextEncoding(String plainTextEncoding) {     this.plainTextEncoding = plainTextEncoding. }
false;public;0;3;;public XmlSignatureProperties getProperties() {     return properties. }
true;public;1;3;/**  * For adding additional References and Objects to the XML signature which contain additional properties,  * you can provide a bean which implements the XmlSignatureProperties interface.  */ ;/**  * For adding additional References and Objects to the XML signature which contain additional properties,  * you can provide a bean which implements the XmlSignatureProperties interface.  */ public void setProperties(XmlSignatureProperties properties) {     this.properties = properties. }
true;public;1;12;/**  * Sets the reference name for a XmlSignatureProperties that can be found in the registry.  */ ;/**  * Sets the reference name for a XmlSignatureProperties that can be found in the registry.  */ public void setProperties(String propertiesName) {     if (getCamelContext() != null && propertiesName != null) {         XmlSignatureProperties props = getCamelContext().getRegistry().lookupByNameAndType(propertiesName, XmlSignatureProperties.class).         if (props != null) {             setProperties(props).         }     }     if (propertiesName != null) {         this.propertiesName = propertiesName.     } }
false;public;0;3;;public String getKeyAccessorName() {     return keyAccessorName. }
false;public;1;3;;public void setKeyAccessorName(String keyAccessorName) {     this.keyAccessorName = keyAccessorName. }
false;public;0;3;;public String getCanonicalizationMethodName() {     return canonicalizationMethodName. }
false;public;1;3;;public void setCanonicalizationMethodName(String canonicalizationMethodName) {     this.canonicalizationMethodName = canonicalizationMethodName. }
false;public;0;3;;public String getTransformMethodsName() {     return transformMethodsName. }
false;public;1;3;;public void setTransformMethodsName(String transformMethodsName) {     this.transformMethodsName = transformMethodsName. }
false;public;0;3;;public String getPropertiesName() {     return propertiesName. }
false;public;1;3;;public void setPropertiesName(String propertiesName) {     this.propertiesName = propertiesName. }
false;public;0;3;;public List<XPathFilterParameterSpec> getXpathsToIdAttributes() {     return xpathsToIdAttributes. }
true;public;1;7;/**  * Define the elements which are signed in the detached case via XPATH  * expressions to ID attributes (attributes of type ID). For each element  * found via the XPATH expression a detached signature is created whose  * reference URI contains the corresponding attribute value (preceded by  * '#'). The signature becomes the last sibling of the signed element.  * Elements with deeper hierarchy level are signed first.  * <p>  * You can also set the XPATH list dynamically via the header  * {@link XmlSignatureConstants#HEADER_XPATHS_TO_ID_ATTRIBUTES}.  * <p>  * The parameter {@link #setParentLocalName(String)} or {@link #setParentXpath(XPathFilterParameterSpec)}  * for enveloped signature and this parameter for detached signature must not  * be set in the same configuration.  */ ;/**  * Define the elements which are signed in the detached case via XPATH  * expressions to ID attributes (attributes of type ID). For each element  * found via the XPATH expression a detached signature is created whose  * reference URI contains the corresponding attribute value (preceded by  * '#'). The signature becomes the last sibling of the signed element.  * Elements with deeper hierarchy level are signed first.  * <p>  * You can also set the XPATH list dynamically via the header  * {@link XmlSignatureConstants#HEADER_XPATHS_TO_ID_ATTRIBUTES}.  * <p>  * The parameter {@link #setParentLocalName(String)} or {@link #setParentXpath(XPathFilterParameterSpec)}  * for enveloped signature and this parameter for detached signature must not  * be set in the same configuration.  */ public void setXpathsToIdAttributes(List<XPathFilterParameterSpec> xpathsToIdAttributes) {     if (xpathsToIdAttributes == null) {         this.xpathsToIdAttributes = Collections.emptyList().     } else {         this.xpathsToIdAttributes = Collections.unmodifiableList(xpathsToIdAttributes).     } }
false;public;0;3;;public XPathFilterParameterSpec getParentXpath() {     return parentXpath. }
true;public;1;3;/**  * Sets the XPath to find the parent node in the enveloped case.  * Either you specify the parent node via this method or the local name and namespace of the parent  * with the methods {@link #setParentLocalName(String)} and {@link #setParentNamespace(String)}.  * <p>  * Default value is <code>null</code>. The value must be <code>null</code> for enveloping and  * detached XML signature.  * <p>  * If the parameters <tt>parentXpath</tt> and <tt>parentLocalName</tt> are specified  * in the same configuration then an exception is thrown.  *  * @param parentXpath xpath to the parent node, if the xpath returns several values then the first Element node is used  */ ;/**  * Sets the XPath to find the parent node in the enveloped case.  * Either you specify the parent node via this method or the local name and namespace of the parent  * with the methods {@link #setParentLocalName(String)} and {@link #setParentNamespace(String)}.  * <p>  * Default value is <code>null</code>. The value must be <code>null</code> for enveloping and  * detached XML signature.  * <p>  * If the parameters <tt>parentXpath</tt> and <tt>parentLocalName</tt> are specified  * in the same configuration then an exception is thrown.  *  * @param parentXpath xpath to the parent node, if the xpath returns several values then the first Element node is used  */ public void setParentXpath(XPathFilterParameterSpec parentXpath) {     this.parentXpath = parentXpath. }
