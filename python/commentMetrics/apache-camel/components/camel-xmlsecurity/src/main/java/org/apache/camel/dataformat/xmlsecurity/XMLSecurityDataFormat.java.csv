commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;public Boolean run() {     String lineBreakPropName = "org.apache.xml.security.ignoreLineBreaks".     if (System.getProperty(lineBreakPropName) == null) {         System.setProperty(lineBreakPropName, "true").         return false.     }     return true. }
false;public;0;6;;public Boolean run() throws Exception {     Field f = XMLUtils.class.getDeclaredField("ignoreLineBreaks").     f.setAccessible(true).     f.set(null, Boolean.TRUE).     return false. }
false;public;0;4;;@Override public String getDataFormatName() {     return "secureXML". }
false;public;1;4;;@Override public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;0;4;;@Override public CamelContext getCamelContext() {     return camelContext. }
false;protected;0;4;;@Override protected void doStart() throws Exception { // noop }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
false;public;3;16;;public void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception {     // Retrieve the message body as input stream     InputStream is = exchange.getContext().getTypeConverter().mandatoryConvertTo(InputStream.class, graph).     // and covert that to XML     Document document = exchange.getContext().getTypeConverter().convertTo(Document.class, exchange, is).     if (null != keyCipherAlgorithm && (keyCipherAlgorithm.equals(XMLCipher.RSA_v1dot5) || keyCipherAlgorithm.equals(XMLCipher.RSA_OAEP) || keyCipherAlgorithm.equals(XMLCipher.RSA_OAEP_11))) {         encryptAsymmetric(exchange, document, stream).     } else if (null != recipientKeyAlias) {         encryptAsymmetric(exchange, document, stream).     } else {         encryptSymmetric(exchange, document, stream).     } }
true;private;3;44;/**  * Configure the public key for the asymmetric key wrap algorithm, create the key cipher, and delegate  * to common encryption method.  *  * The method first checks the exchange for a declared key alias, and will fall back to the  * statically-defined instance variable if no value is found in the exchange. This allows different  * aliases / keys to be used for multiple-recipient messaging integration patterns such as CBR  * or recipient list.  */ ;/**  * Configure the public key for the asymmetric key wrap algorithm, create the key cipher, and delegate  * to common encryption method.  *  * The method first checks the exchange for a declared key alias, and will fall back to the  * statically-defined instance variable if no value is found in the exchange. This allows different  * aliases / keys to be used for multiple-recipient messaging integration patterns such as CBR  * or recipient list.  */ private void encryptAsymmetric(Exchange exchange, Document document, OutputStream stream) throws Exception {     String exchangeRecipientAlias = getRecipientKeyAlias().     if (null == exchangeRecipientAlias) {         throw new IllegalStateException("The  recipient's key alias must be defined for asymmetric key encryption.").     }     if (trustStore == null && null != this.keyOrTrustStoreParameters) {         trustStore = keyOrTrustStoreParameters.createKeyStore().         trustStorePassword = keyOrTrustStoreParameters.getPassword().     }     if (null == trustStore) {         throw new IllegalStateException("A trust store must be defined for asymmetric key encryption.").     }     String password = this.keyPassword != null ? this.keyPassword : this.trustStorePassword.     Key keyEncryptionKey = getPublicKey(this.trustStore, exchangeRecipientAlias, password).     if (null == keyEncryptionKey) {         throw new IllegalStateException("No key for the alias [ " + exchangeRecipientAlias + " ] exists in " + "the configured trust store.").     }     SecretKey dataEncryptionKey = generateDataEncryptionKey().     XMLCipher keyCipher.     if (null != this.getKeyCipherAlgorithm()) {         keyCipher = XMLCipher.getInstance(this.getKeyCipherAlgorithm(), null, digestAlgorithm).     } else {         keyCipher = XMLCipher.getInstance(XMLCipher.RSA_OAEP, null, digestAlgorithm).     }     keyCipher.init(XMLCipher.WRAP_MODE, keyEncryptionKey).     encrypt(exchange, document, stream, dataEncryptionKey, keyCipher, keyEncryptionKey).     // Clean the secret key from memory     try {         dataEncryptionKey.destroy().     } catch (javax.security.auth.DestroyFailedException ex) {         LOG.debug("Error destroying key: {}", ex.getMessage()).     } }
false;private;3;35;;private void encryptSymmetric(Exchange exchange, Document document, OutputStream stream) throws Exception {     SecretKey keyEncryptionKey.     SecretKey dataEncryptionKey.     if (xmlCipherAlgorithm.equals(XMLCipher.TRIPLEDES)) {         keyEncryptionKey = generateKeyEncryptionKey("DESede").         dataEncryptionKey = generateDataEncryptionKey().     } else if (xmlCipherAlgorithm.equals(XMLCipher.SEED_128)) {         keyEncryptionKey = generateKeyEncryptionKey("SEED").         dataEncryptionKey = generateDataEncryptionKey().     } else if (xmlCipherAlgorithm.contains("camellia")) {         keyEncryptionKey = generateKeyEncryptionKey("CAMELLIA").         dataEncryptionKey = generateDataEncryptionKey().     } else {         keyEncryptionKey = generateKeyEncryptionKey("AES").         dataEncryptionKey = generateDataEncryptionKey().     }     XMLCipher keyCipher = XMLCipher.getInstance(generateXmlCipherAlgorithmKeyWrap()).     keyCipher.init(XMLCipher.WRAP_MODE, keyEncryptionKey).     encrypt(exchange, document, stream, dataEncryptionKey, keyCipher, keyEncryptionKey).     // Clean the secret keys from memory     try {         dataEncryptionKey.destroy().     } catch (javax.security.auth.DestroyFailedException ex) {         LOG.debug("Error destroying key: {}", ex.getMessage()).     }     try {         keyEncryptionKey.destroy().     } catch (javax.security.auth.DestroyFailedException ex) {         LOG.debug("Error destroying key: {}", ex.getMessage()).     } }
true;private;3;8;// TODO Move this to a crypto utility class ;/**  * Returns the private key for the specified alias, or null if the alias or private key is not found.  */ // TODO Move this to a crypto utility class private PrivateKey getPrivateKey(KeyStore keystore, String alias, String password) throws Exception {     Key key = keystore.getKey(alias, password.toCharArray()).     if (key instanceof PrivateKey) {         return (PrivateKey) key.     } else {         return null.     } }
true;private;3;8;// TODO Move this to a crypto utility class ;/**  * Returns the public key for the specified alias, or null if the alias or private key is not found.  */ // TODO Move this to a crypto utility class private Key getPublicKey(KeyStore keystore, String alias, String password) throws Exception {     java.security.cert.Certificate cert = keystore.getCertificate(alias).     if (cert != null) {         // Get public key         return cert.getPublicKey().     }     return keystore.getKey(alias, password.toCharArray()). }
false;private;6;33;;private void encrypt(Exchange exchange, Document document, OutputStream stream, Key dataEncryptionKey, XMLCipher keyCipher, Key keyEncryptionKey) throws Exception {     XMLCipher xmlCipher = XMLCipher.getInstance(xmlCipherAlgorithm).     xmlCipher.init(XMLCipher.ENCRYPT_MODE, dataEncryptionKey).     if (secureTag.equalsIgnoreCase("")) {         embedKeyInfoInEncryptedData(document, keyCipher, xmlCipher, dataEncryptionKey, keyEncryptionKey).         document = xmlCipher.doFinal(document, document.getDocumentElement()).     } else {         XPathBuilder xpathBuilder = new XPathBuilder(secureTag).         xpathBuilder.setNamespaceContext(getNamespaceContext()).         NodeList nodeList = xpathBuilder.evaluate(exchange, NodeList.class).         for (int i = 0. i < nodeList.getLength(). i++) {             Node node = nodeList.item(i).             document = node.getOwnerDocument().             embedKeyInfoInEncryptedData(node.getOwnerDocument(), keyCipher, xmlCipher, dataEncryptionKey, keyEncryptionKey).             Document temp = xmlCipher.doFinal(node.getOwnerDocument(), (Element) node, getSecureTagContents()).             document.importNode(temp.getDocumentElement().cloneNode(true), true).         }     }     try {         DOMSource source = new DOMSource(document).         InputStream sis = exchange.getContext().getTypeConverter().mandatoryConvertTo(InputStream.class, source).         IOHelper.copy(sis, stream).     } finally {         stream.close().     } }
false;public;2;4;;public Object unmarshal(Exchange exchange, Document document) throws Exception {     InputStream is = exchange.getIn().getMandatoryBody(InputStream.class).     return unmarshal(exchange, is). }
false;public;2;14;;@Override public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {     Document encodedDocument = exchange.getContext().getTypeConverter().convertTo(Document.class, exchange, stream).     if (null != keyCipherAlgorithm && (keyCipherAlgorithm.equals(XMLCipher.RSA_v1dot5) || keyCipherAlgorithm.equals(XMLCipher.RSA_OAEP) || keyCipherAlgorithm.equals(XMLCipher.RSA_OAEP_11))) {         return decodeWithAsymmetricKey(exchange, encodedDocument).     } else {         LOG.debug("No (known) asymmetric keyCipherAlgorithm specified. Attempting to " + "decrypt using a symmetric key").         return decodeWithSymmetricKey(exchange, encodedDocument).     } }
false;private;2;29;;private Object decodeWithSymmetricKey(Exchange exchange, Document encodedDocument) throws Exception {     SecretKey keyEncryptionKey.     if (xmlCipherAlgorithm.equals(XMLCipher.TRIPLEDES)) {         keyEncryptionKey = generateKeyEncryptionKey("DESede").     } else {         keyEncryptionKey = generateKeyEncryptionKey("AES").     }     Object ret = null.     try {         ret = decode(exchange, encodedDocument, keyEncryptionKey, true).     } catch (org.apache.xml.security.encryption.XMLEncryptionException ex) {         if (ex.getMessage().equals("encryption.nokey")) {             // the message don't have EncryptionKey, try key directly             ret = decode(exchange, encodedDocument, keyEncryptionKey, false).         } else {             throw ex.         }     }     // Clean the secret key from memory     try {         keyEncryptionKey.destroy().     } catch (javax.security.auth.DestroyFailedException ex) {         LOG.debug("Error destroying key: {}", ex.getMessage()).     }     return ret. }
false;private;2;34;;private Object decodeWithAsymmetricKey(Exchange exchange, Document encodedDocument) throws Exception {     if (keyStore == null && null != keyOrTrustStoreParameters) {         keyStore = keyOrTrustStoreParameters.createKeyStore().         keyStorePassword = keyOrTrustStoreParameters.getPassword().     }     if (this.keyStore == null) {         throw new IllegalStateException("A key store must be defined for asymmetric key decryption.").     }     PrivateKey keyEncryptionKey = getPrivateKey(this.keyStore, this.recipientKeyAlias, this.keyPassword != null ? this.keyPassword : this.keyStorePassword).     Object ret = null.     try {         ret = decode(exchange, encodedDocument, keyEncryptionKey, true).     } catch (org.apache.xml.security.encryption.XMLEncryptionException ex) {         if (ex.getMessage().equals("encryption.nokey")) {             // the message don't have EncryptionKey, try key directly             ret = decode(exchange, encodedDocument, keyEncryptionKey, false).         } else {             throw ex.         }     }     // Clean the private key from memory     try {         keyEncryptionKey.destroy().     } catch (javax.security.auth.DestroyFailedException ex) {         LOG.debug("Error destroying key: {}", ex.getMessage()).     }     return ret. }
false;private;4;54;;private Object decode(Exchange exchange, Document encodedDocument, Key keyEncryptionKey, boolean hasEncrytionKey) throws Exception {     XMLCipher xmlCipher = XMLCipher.getInstance().     xmlCipher.setSecureValidation(true).     if (hasEncrytionKey) {         xmlCipher.init(XMLCipher.DECRYPT_MODE, null).         xmlCipher.setKEK(keyEncryptionKey).     } else {         xmlCipher.init(XMLCipher.DECRYPT_MODE, keyEncryptionKey).     }     if (secureTag.equalsIgnoreCase("")) {         checkEncryptionAlgorithm(keyEncryptionKey, encodedDocument.getDocumentElement()).         encodedDocument = xmlCipher.doFinal(encodedDocument, encodedDocument.getDocumentElement()).     } else {         XPathBuilder xpathBuilder = new XPathBuilder(secureTag).         xpathBuilder.setNamespaceContext(getNamespaceContext()).         NodeList nodeList = xpathBuilder.evaluate(exchange, NodeList.class).         for (int i = 0. i < nodeList.getLength(). i++) {             Node node = nodeList.item(i).             encodedDocument = node.getOwnerDocument().             if (getSecureTagContents()) {                 checkEncryptionAlgorithm(keyEncryptionKey, (Element) node).                 Document temp = xmlCipher.doFinal(encodedDocument, (Element) node, true).                 encodedDocument.importNode(temp.getDocumentElement().cloneNode(true), true).             } else {                 NodeList childNodes = node.getChildNodes().                 for (int j = 0. j < childNodes.getLength(). j++) {                     Node childNode = childNodes.item(j).                     if (childNode.getLocalName().equals("EncryptedData")) {                         checkEncryptionAlgorithm(keyEncryptionKey, (Element) childNode).                         Document temp = xmlCipher.doFinal(encodedDocument, (Element) childNode, false).                         encodedDocument.importNode(temp.getDocumentElement().cloneNode(true), true).                     }                 }             }         }     }     ByteArrayOutputStream bos = new ByteArrayOutputStream().     try {         DOMSource source = new DOMSource(encodedDocument).         InputStream sis = exchange.getContext().getTypeConverter().mandatoryConvertTo(InputStream.class, source).         IOHelper.copy(sis, bos).     } finally {         bos.close().     }     // Return the decrypted data     return bos.toByteArray(). }
false;private;1;30;;private SecretKey generateKeyEncryptionKey(String algorithm) throws InvalidKeyException, NoSuchAlgorithmException, InvalidKeySpecException {     DESedeKeySpec keySpec.     SecretKey secretKey.     try {         if (algorithm.equalsIgnoreCase("DESede")) {             keySpec = new DESedeKeySpec(passPhrase).             SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(algorithm).             secretKey = keyFactory.generateSecret(keySpec).         } else if (algorithm.equalsIgnoreCase("SEED")) {             secretKey = new SecretKeySpec(passPhrase, "SEED").         } else if (algorithm.equalsIgnoreCase("CAMELLIA")) {             secretKey = new SecretKeySpec(passPhrase, "CAMELLIA").         } else {             secretKey = new SecretKeySpec(passPhrase, "AES").         }         if (Arrays.equals(passPhrase, DEFAULT_KEY.getBytes())) {             LOG.warn("Using the default encryption key is not secure").         }     } catch (InvalidKeyException e) {         throw new InvalidKeyException("InvalidKeyException due to invalid passPhrase: " + Arrays.toString(passPhrase)).     } catch (NoSuchAlgorithmException e) {         throw new NoSuchAlgorithmException("NoSuchAlgorithmException while using algorithm: " + algorithm).     } catch (InvalidKeySpecException e) {         throw new InvalidKeySpecException("Invalid Key generated while using passPhrase: " + Arrays.toString(passPhrase)).     }     return secretKey. }
false;private;0;24;;private SecretKey generateDataEncryptionKey() throws Exception {     KeyGenerator keyGenerator = null.     if (xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.TRIPLEDES)) {         keyGenerator = KeyGenerator.getInstance("DESede").     } else {         keyGenerator = KeyGenerator.getInstance("AES").         if (xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.AES_128) || xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.AES_128_GCM) || xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.SEED_128) || xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.CAMELLIA_128)) {             keyGenerator.init(128).         } else if (xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.AES_192) || xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.AES_192_GCM) || xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.CAMELLIA_192)) {             keyGenerator.init(192).         } else if (xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.AES_256) || xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.AES_256_GCM) || xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.CAMELLIA_256)) {             keyGenerator.init(256).         }     }     return keyGenerator.generateKey(). }
false;private;5;17;;private void embedKeyInfoInEncryptedData(Document document, XMLCipher keyCipher, XMLCipher xmlCipher, Key dataEncryptionkey, Key keyEncryptionKey) throws XMLEncryptionException {     EncryptedKey encryptedKey = keyCipher.encryptKey(document, dataEncryptionkey, mgfAlgorithm, null).     if (addKeyValueForEncryptedKey && keyEncryptionKey instanceof PublicKey) {         KeyInfo keyInfo = new KeyInfo(document).         keyInfo.add((PublicKey) keyEncryptionKey).         encryptedKey.setKeyInfo(keyInfo).     }     KeyInfo keyInfo = new KeyInfo(document).     keyInfo.add(encryptedKey).     EncryptedData encryptedDataElement = xmlCipher.getEncryptedData().     encryptedDataElement.setKeyInfo(keyInfo). }
false;private;0;25;;private String generateXmlCipherAlgorithmKeyWrap() {     String algorithmKeyWrap = null.     if (xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.TRIPLEDES)) {         algorithmKeyWrap = XMLCipher.TRIPLEDES_KeyWrap.     } else if (xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.AES_128) || xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.AES_128_GCM)) {         algorithmKeyWrap = XMLCipher.AES_128_KeyWrap.     } else if (xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.AES_192) || xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.AES_192_GCM)) {         algorithmKeyWrap = XMLCipher.AES_192_KeyWrap.     } else if (xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.AES_256) || xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.AES_256_GCM)) {         algorithmKeyWrap = XMLCipher.AES_256_KeyWrap.     } else if (xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.SEED_128)) {         algorithmKeyWrap = XMLCipher.SEED_128_KeyWrap.     } else if (xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.CAMELLIA_128)) {         algorithmKeyWrap = XMLCipher.CAMELLIA_128_KeyWrap.     } else if (xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.CAMELLIA_192)) {         algorithmKeyWrap = XMLCipher.CAMELLIA_192_KeyWrap.     } else if (xmlCipherAlgorithm.equalsIgnoreCase(XMLCipher.CAMELLIA_256)) {         algorithmKeyWrap = XMLCipher.CAMELLIA_256_KeyWrap.     }     return algorithmKeyWrap. }
true;private;2;19;// Check to see if the asymmetric key transport algorithm is allowed ;// Check to see if the asymmetric key transport algorithm is allowed private void checkEncryptionAlgorithm(Key keyEncryptionKey, Element parentElement) throws Exception {     if (XMLCipher.RSA_v1dot5.equals(keyCipherAlgorithm) || keyCipherAlgorithm == null || !(keyEncryptionKey instanceof PrivateKey)) {         // This only applies for Asymmetric Encryption         return.     }     Element encryptedElement = findEncryptedDataElement(parentElement).     if (encryptedElement == null) {         return.     }     // The EncryptedKey EncryptionMethod algorithm     String foundEncryptedKeyMethod = findEncryptedKeyMethod(encryptedElement).     if (XMLCipher.RSA_v1dot5.equals(foundEncryptedKeyMethod)) {         String errorMessage = "The found key transport encryption method is not allowed".         throw new XMLEncryptionException(errorMessage).     } }
false;private;1;22;;private Element findEncryptedDataElement(Element element) {     // First check the Element itself     if (EncryptionConstants._TAG_ENCRYPTEDDATA.equals(element.getLocalName()) && EncryptionConstants.EncryptionSpecNS.equals(element.getNamespaceURI())) {         return element.     }     // Now check the child nodes     Node child = element.getFirstChild().     while (child != null) {         if (child.getNodeType() == Node.ELEMENT_NODE) {             Element childElement = (Element) child.             if (EncryptionConstants._TAG_ENCRYPTEDDATA.equals(childElement.getLocalName()) && EncryptionConstants.EncryptionSpecNS.equals(childElement.getNamespaceURI())) {                 return childElement.             }         }         child = child.getNextSibling().     }     return null. }
false;private;1;15;;private String findEncryptionMethod(Element element) {     Node child = element.getFirstChild().     while (child != null) {         if (child.getNodeType() == Node.ELEMENT_NODE) {             Element childElement = (Element) child.             if (EncryptionConstants._TAG_ENCRYPTIONMETHOD.equals(childElement.getLocalName()) && EncryptionConstants.EncryptionSpecNS.equals(childElement.getNamespaceURI())) {                 return childElement.getAttributeNS(null, EncryptionConstants._ATT_ALGORITHM).             }         }         child = child.getNextSibling().     }     return null. }
false;private;1;25;;private String findEncryptedKeyMethod(Element element) {     Node child = element.getFirstChild().     while (child != null) {         if (child.getNodeType() == Node.ELEMENT_NODE) {             Element childElement = (Element) child.             if (Constants._TAG_KEYINFO.equals(childElement.getLocalName()) && Constants.SignatureSpecNS.equals(childElement.getNamespaceURI())) {                 Node keyInfoChild = child.getFirstChild().                 while (keyInfoChild != null) {                     if (child.getNodeType() == Node.ELEMENT_NODE) {                         childElement = (Element) keyInfoChild.                         if (EncryptionConstants._TAG_ENCRYPTEDKEY.equals(childElement.getLocalName()) && EncryptionConstants.EncryptionSpecNS.equals(childElement.getNamespaceURI())) {                             return findEncryptionMethod(childElement).                         }                     }                     keyInfoChild = keyInfoChild.getNextSibling().                 }             }         }         child = child.getNextSibling().     }     return null. }
false;private;0;3;;private DefaultNamespaceContext getNamespaceContext() {     return this.nsContext. }
false;public;0;3;;public String getXmlCipherAlgorithm() {     return xmlCipherAlgorithm. }
false;public;1;3;;public void setXmlCipherAlgorithm(String xmlCipherAlgorithm) {     this.xmlCipherAlgorithm = xmlCipherAlgorithm. }
false;public;0;3;;public String getKeyCipherAlgorithm() {     return keyCipherAlgorithm. }
false;public;1;3;;public void setKeyCipherAlgorithm(String keyCipherAlgorithm) {     this.keyCipherAlgorithm = keyCipherAlgorithm. }
false;public;0;3;;public String getRecipientKeyAlias() {     return this.recipientKeyAlias. }
false;public;1;3;;public void setRecipientKeyAlias(String recipientKeyAlias) {     this.recipientKeyAlias = recipientKeyAlias. }
false;public;0;3;;public byte[] getPassPhrase() {     return passPhrase. }
false;public;1;3;;public void setPassPhrase(byte[] passPhrase) {     this.passPhrase = passPhrase. }
false;public;0;3;;public String getSecureTag() {     return secureTag. }
false;public;1;3;;public void setSecureTag(String secureTag) {     this.secureTag = secureTag. }
false;public;0;3;;public boolean isSecureTagContents() {     return secureTagContents. }
false;public;0;3;;public boolean getSecureTagContents() {     return secureTagContents. }
false;public;1;3;;public void setSecureTagContents(boolean secureTagContents) {     this.secureTagContents = secureTagContents. }
false;public;1;3;;public void setKeyOrTrustStoreParameters(KeyStoreParameters parameters) {     this.keyOrTrustStoreParameters = parameters. }
false;public;0;3;;public KeyStoreParameters getKeyOrTrustStoreParameters() {     return this.keyOrTrustStoreParameters. }
false;public;1;13;;public void setKeyOrTrustStoreParametersRef(String registryId) {     this.keyOrTrustStoreParametersRef = registryId.     if (camelContext != null) {         Object parametersObj = camelContext.getRegistry().lookupByName(this.keyOrTrustStoreParametersRef).         if (parametersObj instanceof KeyStoreParameters) {             this.keyOrTrustStoreParameters = (KeyStoreParameters) parametersObj.         } else {             throw new IllegalStateException("Could not initialize XMLSecurityDataFormat with camelContext." + "The id for the keyOrTrustStoreParameters specified [ " + keyOrTrustStoreParametersRef + " ] does not identify a KeyStoreParameters bean.").         }     } }
false;public;0;3;;public String getKeyOrTrustStoreParametersRef() {     return this.keyOrTrustStoreParametersRef. }
false;public;1;3;;public void setNamespaces(Map<String, String> namespaces) {     getNamespaceContext().setNamespaces(namespaces). }
false;public;1;3;;public void setKeyPassword(String keyPassword) {     this.keyPassword = keyPassword. }
false;public;0;3;;public String getDigestAlgorithm() {     return digestAlgorithm. }
false;public;1;3;;public void setDigestAlgorithm(String digestAlgorithm) {     this.digestAlgorithm = digestAlgorithm. }
false;public;0;3;;public String getMgfAlgorithm() {     return mgfAlgorithm. }
false;public;1;3;;public void setMgfAlgorithm(String mgfAlgorithm) {     this.mgfAlgorithm = mgfAlgorithm. }
false;public;0;3;;public boolean isAddKeyValueForEncryptedKey() {     return addKeyValueForEncryptedKey. }
false;public;1;3;;public void setAddKeyValueForEncryptedKey(boolean addKeyValueForEncryptedKey) {     this.addKeyValueForEncryptedKey = addKeyValueForEncryptedKey. }
