commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public XmlSignerConfiguration getConfiguration() {     return config. }
false;public;1;27;;@Override public void process(Exchange exchange) throws Exception {     try {         LOG.debug("XML signature generation started using algorithm {} and canonicalization method {}", getConfiguration().getSignatureAlgorithm(), getConfiguration().getCanonicalizationMethod().getAlgorithm()).         // lets setup the out message before we invoke the signing         // so that it can mutate it if necessary         Message out = exchange.getOut().         out.copyFrom(exchange.getIn()).         Document outputDoc = sign(out).         ByteArrayOutputStream outStream = new ByteArrayOutputStream().         XmlSignatureHelper.transformNonTextNodeToOutputStream(outputDoc, outStream, omitXmlDeclaration(out), getConfiguration().getOutputXmlEncoding()).         byte[] data = outStream.toByteArray().         out.setBody(data).         setOutputEncodingToMessageHeader(out).         clearMessageHeaders(out).         LOG.debug("XML signature generation finished").     } catch (Exception e) {         // remove OUT message, as an exception occurred         exchange.setOut(null).         throw e.     } }
false;protected;1;95;;protected Document sign(final Message out) throws Exception {     try {         XMLSignatureFactory fac.         // not work         try {             fac = XMLSignatureFactory.getInstance("DOM", "ApacheXMLDSig").         } catch (NoSuchProviderException ex) {             fac = XMLSignatureFactory.getInstance("DOM").         }         final Node node = getMessageBodyNode(out).         if (getConfiguration().getKeyAccessor() == null) {             throw new XmlSignatureNoKeyException("Key accessor is missing for XML signature generation. Specify a key accessor in the configuration.").         }         final KeySelector keySelector = getConfiguration().getKeyAccessor().getKeySelector(out).         if (keySelector == null) {             throw new XmlSignatureNoKeyException("Key selector is missing for XML signature generation. Specify a key selector in the configuration.").         }         SignatureType signatureType = determineSignatureType(out).         final List<String> contentReferenceUris = getContentReferenceUris(out, signatureType, node).         Node lastParent = null.         // only in the detached case there can be several         for (final String contentReferenceUri : contentReferenceUris) {             // the method KeyAccessor.getKeyInfo must be called after the method KeyAccessor.getKeySelector, this is part of the interface contract!             // and this method must be called within the loop over the content reference URIs, because for each signature the key info ID must be different             final KeyInfo keyInfo = getConfiguration().getKeyAccessor().getKeyInfo(out, node, fac.getKeyInfoFactory()).             String signatureId = getConfiguration().getSignatureId().             if (signatureId == null) {                 signatureId = "_" + UUID.randomUUID().toString().             } else if (signatureId.isEmpty()) {                 // indicator that no signature Id attribute shall be generated                 signatureId = null.             }             // parent only relevant for enveloped or detached signature             Node parent = getParentOfSignature(out, node, contentReferenceUri, signatureType).             if (parent == null) {                 // for enveloping signature, create new document                 parent = XmlSignatureHelper.newDocumentBuilder(Boolean.TRUE).newDocument().             }             lastParent = parent.             XmlSignatureProperties.Input input = new InputBuilder().contentDigestAlgorithm(getDigestAlgorithmUri()).keyInfo(keyInfo).message(out).messageBodyNode(node).parent(parent).signatureAlgorithm(getConfiguration().getSignatureAlgorithm()).signatureFactory(fac).signatureId(signatureId).contentReferenceUri(contentReferenceUri).signatureType(signatureType).prefixForXmlSignatureNamespace(getConfiguration().getPrefixForXmlSignatureNamespace()).build().             XmlSignatureProperties.Output properties = getSignatureProperties(input).             // the signature properties can overwrite the signature Id             if (properties != null && properties.getSignatureId() != null && !properties.getSignatureId().isEmpty()) {                 signatureId = properties.getSignatureId().             }             List<? extends XMLObject> objects = getObjects(input, properties).             List<? extends Reference> refs = getReferences(input, properties, getKeyInfoId(keyInfo)).             SignedInfo si = createSignedInfo(fac, refs).             DOMSignContext dsc = createAndConfigureSignContext(parent, keySelector).             XMLSignature signature = fac.newXMLSignature(si, keyInfo, objects, signatureId, null).             // generate the signature             signature.sign(dsc).         }         return XmlSignatureHelper.getDocument(lastParent).     } catch (XMLSignatureException se) {         if (se.getCause() instanceof InvalidKeyException) {             throw new XmlSignatureInvalidKeyException(se.getMessage(), se).         } else {             throw new XmlSignatureException(se).         }     } catch (GeneralSecurityException e) {         // like NoSuchAlgorithmException, InvalidAlgorithmParameterException, NoSuchProviderException         throw new XmlSignatureException(e).     } }
false;private;1;45;;private SignatureType determineSignatureType(Message message) throws XmlSignatureException {     if (getConfiguration().getParentLocalName() != null && getConfiguration().getParentXpath() != null) {         throw new XmlSignatureException("The configuration of the XML signer component is wrong. The parent local name " + getConfiguration().getParentLocalName() + " and the parent XPath " + getConfiguration().getParentXpath().getXPath() + " are specified. You must not specify both parameters.").     }     boolean isEnveloped = getConfiguration().getParentLocalName() != null || getConfiguration().getParentXpath() != null.     boolean isDetached = getXpathToIdAttributes(message).size() > 0.     if (isEnveloped && isDetached) {         if (getConfiguration().getParentLocalName() != null) {             throw new XmlSignatureException("The configuration of the XML signer component is wrong. The parent local name " + getConfiguration().getParentLocalName() + " for an enveloped signature and the XPATHs to ID attributes for a detached signature are specified. You must not specify both parameters.").         } else {             throw new XmlSignatureException("The configuration of the XML signer component is wrong. The parent XPath " + getConfiguration().getParentXpath().getXPath() + " for an enveloped signature and the XPATHs to ID attributes for a detached signature are specified. You must not specify both parameters.").         }     }     SignatureType result.     if (isEnveloped) {         result = SignatureType.enveloped.     } else if (isDetached) {         if (getSchemaResourceUri(message) == null) {             throw new XmlSignatureException("The configruation of the XML Signature component is wrong: No XML schema specified in the detached case").         }         result = SignatureType.detached.     } else {         result = SignatureType.enveloping.     }     LOG.debug("Signature type: {}", result).     return result. }
false;protected;1;10;;protected List<XPathFilterParameterSpec> getXpathToIdAttributes(Message message) {     @SuppressWarnings("unchecked")     List<XPathFilterParameterSpec> result = (List<XPathFilterParameterSpec>) message.getHeader(XmlSignatureConstants.HEADER_XPATHS_TO_ID_ATTRIBUTES).     if (result == null) {         result = getConfiguration().getXpathsToIdAttributes().     }     return result. }
false;protected;1;8;;protected XmlSignatureProperties.Output getSignatureProperties(XmlSignatureProperties.Input input) throws Exception {     // NOPMD     XmlSignatureProperties propGetter = getConfiguration().getProperties().     XmlSignatureProperties.Output propsOutput = null.     if (propGetter != null) {         propsOutput = propGetter.get(input).     }     return propsOutput. }
false;private;2;12;;private DOMSignContext createAndConfigureSignContext(Node parent, KeySelector keySelector) {     DOMSignContext dsc = new DOMSignContext(keySelector, parent).     // set namespace prefix for "http://www.w3.org/2000/09/xmldsig#" according to best practice described in http://www.w3.org/TR/xmldsig-bestpractices/#signing-xml-without-namespaces     if (getConfiguration().getPrefixForXmlSignatureNamespace() != null && !getConfiguration().getPrefixForXmlSignatureNamespace().isEmpty()) {         dsc.putNamespacePrefix("http://www.w3.org/2000/09/xmldsig#", getConfiguration().getPrefixForXmlSignatureNamespace()).     }     dsc.putNamespacePrefix("http://www.w3.org/2001/10/xml-exc-c14n#", "ec").     setCryptoContextProperties(dsc).     setUriDereferencerAndBaseUri(dsc).     return dsc. }
false;protected;1;11;;protected Boolean omitXmlDeclaration(Message message) {     Boolean omitXmlDeclaration = message.getHeader(XmlSignatureConstants.HEADER_OMIT_XML_DECLARATION, Boolean.class).     if (omitXmlDeclaration == null) {         omitXmlDeclaration = getConfiguration().getOmitXmlDeclaration().     }     if (omitXmlDeclaration == null) {         omitXmlDeclaration = Boolean.FALSE.     }     LOG.debug("Omit XML declaration: {}", omitXmlDeclaration).     return omitXmlDeclaration. }
false;protected;2;5;;protected SignedInfo createSignedInfo(XMLSignatureFactory fac, List<? extends Reference> refs) throws Exception {     // NOPMD     return fac.newSignedInfo(fac.newCanonicalizationMethod(getConfiguration().getCanonicalizationMethod().getAlgorithm(), (C14NMethodParameterSpec) getConfiguration().getCanonicalizationMethod().getParameterSpec()), getSignatureMethod(getConfiguration().getSignatureAlgorithm(), fac), refs). }
false;private;2;4;;private SignatureMethod getSignatureMethod(String signatureAlgorithm, XMLSignatureFactory fac) throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {     return fac.newSignatureMethod(signatureAlgorithm, null). }
false;protected;1;18;;protected Node getMessageBodyNode(Message message) throws Exception {     // NOPMD     InputStream is = message.getMandatoryBody(InputStream.class).     Boolean isPlainText = isPlainText(message).     Node node.     if (isPlainText != null && isPlainText) {         node = getTextNode(message, is).     } else {         ValidatorErrorHandler errorHandler = new DefaultValidationErrorHandler().         Schema schema = getSchemaForSigner(message, errorHandler).         Document doc = parseInput(is, getConfiguration().getDisallowDoctypeDecl(), schema, errorHandler).         // throws ValidationException         errorHandler.handleErrors(message.getExchange(), schema, null).         node = doc.getDocumentElement().         LOG.debug("Root element of document to be signed: {}", node).     }     return node. }
false;protected;2;11;;protected Schema getSchemaForSigner(Message message, ValidatorErrorHandler errorHandler) throws XmlSignatureException, SAXException, IOException {     Schema schema.     String schemaResourceUri = getSchemaResourceUri(message).     if (schemaResourceUri == null) {         schema = null.     } else {         schema = getSchema(message).     }     return schema. }
false;protected;1;8;;protected Boolean isPlainText(Message message) {     Boolean isPlainText = message.getHeader(XmlSignatureConstants.HEADER_MESSAGE_IS_PLAIN_TEXT, Boolean.class).     if (isPlainText == null) {         isPlainText = getConfiguration().getPlainText().     }     LOG.debug("Is plain text: {}", isPlainText).     return isPlainText. }
false;protected;4;19;;protected Element getParentOfSignature(Message inMessage, Node messageBodyNode, String contentReferenceURI, SignatureType sigType) throws Exception {     // NOPMD     if (SignatureType.enveloping == sigType) {         // enveloping case         return null.     }     if (messageBodyNode.getParentNode() == null || messageBodyNode.getParentNode().getNodeType() != Node.DOCUMENT_NODE) {         throw new XmlSignatureFormatException("Incomming message has wrong format: It is not an XML document. Cannot create an enveloped or detached XML signature.").     }     Document doc = (Document) messageBodyNode.getParentNode().     if (SignatureType.detached == sigType) {         return getParentForDetachedCase(doc, inMessage, contentReferenceURI).     } else {         // enveloped case         return getParentForEnvelopedCase(doc, inMessage).     } }
false;protected;2;35;;protected Element getParentForEnvelopedCase(Document doc, Message inMessage) throws Exception {     // NOPMD     if (getConfiguration().getParentXpath() != null) {         XPathFilterParameterSpec xp = getConfiguration().getParentXpath().         XPathExpression exp.         try {             exp = XmlSignatureHelper.getXPathExpression(xp).         } catch (XPathExpressionException e) {             throw new XmlSignatureException("The parent XPath " + getConfiguration().getParentXpath().getXPath() + " is wrongly configured: The XPath " + xp.getXPath() + " is invalid.", e).         }         NodeList list = (NodeList) exp.evaluate(doc.getDocumentElement(), XPathConstants.NODESET).         if (list == null || list.getLength() == 0) {             throw new XmlSignatureException("The parent XPath " + xp.getXPath() + " returned no result. Check the configuration of the XML signer component.").         }         int length = list.getLength().         for (int i = 0. i < length. i++) {             Node node = list.item(i).             if (node.getNodeType() == Node.ELEMENT_NODE) {                 // return the first element                 return (Element) node.             }         }         throw new XmlSignatureException("The parent XPath " + xp.getXPath() + " returned no element. Check the configuration of the XML signer component.").     } else {         // parent local name is not null!         NodeList parents = doc.getElementsByTagNameNS(getConfiguration().getParentNamespace(), getConfiguration().getParentLocalName()).         if (parents == null || parents.getLength() == 0) {             throw new XmlSignatureFormatException(String.format("Incoming message has wrong format: The parent element with the local name %s and the namespace %s was not found in the message to build an enveloped XML signature.", getConfiguration().getParentLocalName(), getConfiguration().getParentNamespace())).         }         // return the first element         return (Element) parents.item(0).     } }
false;private;3;22;;private Element getParentForDetachedCase(Document doc, Message inMessage, String referenceUri) throws XmlSignatureException {     String elementId = referenceUri.     if (elementId.startsWith("#")) {         elementId = elementId.substring(1).     }     Element el = doc.getElementById(elementId).     if (el == null) {         // should not happen because has been checked before         throw new IllegalStateException("No element found for element ID " + elementId).     }     LOG.debug("Sibling element of the detached XML Signature with reference URI {}: {}  {}", new Object[] { referenceUri, el.getLocalName(), el.getNamespaceURI() }).     Element result = getParentElement(el).     if (result != null) {         return result.     } else {         throw new XmlSignatureException("Either the configuration of the XML Signature component is wrong or the incoming document has an invalid structure: The element " + el.getLocalName() + "{" + el.getNamespaceURI() + "} which is referenced by the reference URI " + referenceUri + " has no parent element. The element must have a parent element in the configured detached case.").     } }
false;private;1;13;;private Element getParentElement(Node node) {     int counter = 0.     while (node != null && counter < 10000) {         // counter is for avoiding security attacks         Node parent = node.getParentNode().         if (parent != null && parent.getNodeType() == Node.ELEMENT_NODE) {             return (Element) parent.         }         node = parent.         counter++.     }     return null. }
false;protected;3;22;;protected List<? extends Reference> getReferences(XmlSignatureProperties.Input input, XmlSignatureProperties.Output properties, String keyInfoId) throws Exception {     // NOPMD     String referenceId = properties == null ? null : properties.getContentReferenceId().     // Create Reference with URI="#<objectId>" for enveloping signature, URI="" for enveloped signature, and URI = <value from configuration> for detached signature and the transforms     Reference ref = createReference(input.getSignatureFactory(), input.getContentReferenceUri(), getContentReferenceType(input.getMessage()), input.getSignatureType(), referenceId, input.getMessage()).     Reference keyInfoRef = createKeyInfoReference(input.getSignatureFactory(), keyInfoId, input.getContentDigestAlgorithm()).     int propsRefsSize = properties == null || properties.getReferences() == null || properties.getReferences().isEmpty() ? 0 : properties.getReferences().size().     int size = keyInfoRef == null ? propsRefsSize + 1 : propsRefsSize + 2.     List<Reference> referenceList = new ArrayList<>(size).     referenceList.add(ref).     if (keyInfoRef != null) {         referenceList.add(keyInfoRef).     }     if (properties != null && properties.getReferences() != null && !properties.getReferences().isEmpty()) {         referenceList.addAll(properties.getReferences()).     }     return referenceList. }
false;protected;2;23;;protected List<? extends XMLObject> getObjects(XmlSignatureProperties.Input input, XmlSignatureProperties.Output properties) throws Exception {     if (SignatureType.enveloped == input.getSignatureType() || SignatureType.detached == input.getSignatureType()) {         if (properties == null || properties.getObjects() == null) {             return Collections.emptyList().         }         return properties.getObjects().     }     // enveloping signature --> add additional object     final String objectId = getConfiguration().getContentObjectId().     LOG.debug("Object Content Id {}", objectId).     XMLObject obj = createXMLObject(input.getSignatureFactory(), input.getMessageBodyNode(), objectId).     if (properties == null || properties.getObjects() == null || properties.getObjects().isEmpty()) {         return Collections.singletonList(obj).     }     List<XMLObject> result = new ArrayList<>(properties.getObjects().size() + 1).     result.add(obj).     result.addAll(properties.getObjects()).     return result. }
false;private;2;12;;private Node getTextNode(Message inMessage, InputStream is) throws IOException, ParserConfigurationException, XmlSignatureException {     LOG.debug("Message body to be signed is plain text").     String encoding = getMessageEncoding(inMessage).     ByteArrayOutputStream bos = new ByteArrayOutputStream().     IOHelper.copyAndCloseInput(is, bos).     try {         String text = new String(bos.toByteArray(), encoding).         return XmlSignatureHelper.newDocumentBuilder(true).newDocument().createTextNode(text).     } catch (UnsupportedEncodingException e) {         throw new XmlSignatureException(String.format("The message encoding %s is not supported.", encoding), e).     } }
false;protected;1;8;;protected String getMessageEncoding(Message inMessage) {     String encoding = inMessage.getHeader(XmlSignatureConstants.HEADER_PLAIN_TEXT_ENCODING, String.class).     if (encoding == null) {         encoding = getConfiguration().getPlainTextEncoding().     }     LOG.debug("Messge encoding: {}", encoding).     return encoding. }
false;protected;4;13;;protected Document parseInput(InputStream is, Boolean disallowDoctypeDecl, Schema schema, ErrorHandler errorHandler) throws ParserConfigurationException, IOException, XmlSignatureFormatException {     try {         DocumentBuilder db = XmlSignatureHelper.newDocumentBuilder(disallowDoctypeDecl, schema).         db.setErrorHandler(errorHandler).         return db.parse(is).     } catch (SAXException e) {         throw new XmlSignatureFormatException("XML signature generation not possible. Sent message is not an XML document. Check the sent message.", e).     } finally {         IOHelper.close(is, "input stream").     } }
false;protected;6;10;;protected Reference createReference(XMLSignatureFactory fac, String uri, String type, SignatureType sigType, String id, Message message) throws InvalidAlgorithmParameterException, XmlSignatureException {     try {         List<Transform> transforms = getTransforms(fac, sigType, message).         Reference ref = fac.newReference(uri, fac.newDigestMethod(getDigestAlgorithmUri(), null), transforms, type, id).         return ref.     } catch (NoSuchAlgorithmException e) {         throw new XmlSignatureException("Wrong algorithm specified in the configuration.", e).     } }
false;protected;1;8;;protected String getContentReferenceType(Message message) {     String type = message.getHeader(XmlSignatureConstants.HEADER_CONTENT_REFERENCE_TYPE, String.class).     if (type == null) {         type = getConfiguration().getContentReferenceType().     }     LOG.debug("Content reference type: {}", type).     return type. }
false;protected;3;27;;protected List<String> getContentReferenceUris(Message message, SignatureType signatureType, Node messageBodyNode) throws XmlSignatureException, XPathExpressionException {     List<String> result.     if (SignatureType.enveloping == signatureType) {         String uri = "#" + getConfiguration().getContentObjectId().         result = Collections.singletonList(uri).     } else if (SignatureType.enveloped == signatureType) {         // only for enveloped the parameter content reference URI is used         String uri = message.getHeader(XmlSignatureConstants.HEADER_CONTENT_REFERENCE_URI, String.class).         if (uri == null) {             uri = getConfiguration().getContentReferenceUri().         }         if (uri == null) {             uri = "".         }         result = Collections.singletonList(uri).     } else if (SignatureType.detached == signatureType) {         result = getContentReferenceUrisForDetachedCase(message, messageBodyNode).     } else {         // should not occur         throw new IllegalStateException("Signature type " + signatureType + " not supported").     }     LOG.debug("Content reference URI(s): {}", result).     return result. }
false;private;2;54;;private List<String> getContentReferenceUrisForDetachedCase(Message message, Node messageBodyNode) throws XmlSignatureException, XPathExpressionException {     List<XPathFilterParameterSpec> xpathsToIdAttributes = getXpathToIdAttributes(message).     if (xpathsToIdAttributes.isEmpty()) {         // should not happen, has already been checked earlier         throw new IllegalStateException("List of XPATHs to ID attributes is empty in detached signature case").     }     List<ComparableNode> result = new ArrayList<>(xpathsToIdAttributes.size()).     for (XPathFilterParameterSpec xp : xpathsToIdAttributes) {         XPathExpression exp.         try {             exp = XmlSignatureHelper.getXPathExpression(xp).         } catch (XPathExpressionException e) {             throw new XmlSignatureException("The configured xpath expression " + xp.getXPath() + " is invalid.", e).         }         NodeList list = (NodeList) exp.evaluate(messageBodyNode, XPathConstants.NODESET).         if (list == null) {             // assume optional element, XSD validation has been done before             LOG.warn("No ID attribute found for xpath expression {}. Therfore this xpath expression will be ignored.", xp.getXPath()).             continue.         }         int length = list.getLength().         for (int i = 0. i < length. i++) {             Node node = list.item(i).             if (node.getNodeType() == Node.ATTRIBUTE_NODE) {                 Attr attr = (Attr) node.                 String value = attr.getValue().                 // check that attribute is ID attribute                 Element element = messageBodyNode.getOwnerDocument().getElementById(value).                 if (element == null) {                     throw new XmlSignatureException("Wrong configured xpath expression for ID attributes: The evaluation of the xpath expression " + xp.getXPath() + " resulted in an attribute which is not of type ID. The attribute value is " + value + ".").                 }                 result.add(new ComparableNode(element, "#" + value)).                 LOG.debug("ID attribute with value {} found for xpath {}", value, xp.getXPath()).             } else {                 throw new XmlSignatureException("Wrong configured xpath expression for ID attributes: The evaluation of the xpath expression " + xp.getXPath() + " returned a node which was not of type Attribute.").             }         }     }     if (result.size() == 0) {         throw new XmlSignatureException("No element to sign found in the detached case. No node found for the configured xpath expressions " + toString(xpathsToIdAttributes) + ". Either the configuration of the XML signature component is wrong or the incoming message has not the correct structure.").     }     // sort so that elements with deeper hierarchy level are treated first     Collections.sort(result).     return ComparableNode.getReferenceUris(result). }
false;private;1;12;;private String toString(List<XPathFilterParameterSpec> xpathsToIdAttributes) {     StringBuilder result = new StringBuilder().     int counter = 0.     for (XPathFilterParameterSpec xp : xpathsToIdAttributes) {         counter++.         result.append(xp.getXPath()).         if (counter < xpathsToIdAttributes.size()) {             result.append(", ").         }     }     return result.toString(). }
false;protected;3;3;;protected XMLObject createXMLObject(XMLSignatureFactory fac, Node node, String id) {     return fac.newXMLObject(Collections.singletonList(new DOMStructure(node)), id, null, null). }
false;private;3;41;;private List<Transform> getTransforms(XMLSignatureFactory fac, SignatureType sigType, Message message) throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {     String transformMethodsHeaderValue = message.getHeader(XmlSignatureConstants.HEADER_TRANSFORM_METHODS, String.class).     if (transformMethodsHeaderValue == null) {         List<AlgorithmMethod> configuredTrafos = getConfiguration().getTransformMethods().         if (SignatureType.enveloped == sigType) {             // add enveloped transform if necessary             if (configuredTrafos.size() > 0) {                 if (!containsEnvelopedTransform(configuredTrafos)) {                     configuredTrafos = new ArrayList<>(configuredTrafos.size() + 1).                     configuredTrafos.add(XmlSignatureHelper.getEnvelopedTransform()).                     configuredTrafos.addAll(getConfiguration().getTransformMethods()).                 }             } else {                 // add enveloped and C14N trafo                 configuredTrafos = new ArrayList<>(2).                 configuredTrafos.add(XmlSignatureHelper.getEnvelopedTransform()).                 configuredTrafos.add(XmlSignatureHelper.getCanonicalizationMethod(CanonicalizationMethod.INCLUSIVE)).             }         }         List<Transform> transforms = new ArrayList<>(configuredTrafos.size()).         for (AlgorithmMethod trafo : configuredTrafos) {             Transform transform = fac.newTransform(trafo.getAlgorithm(), (TransformParameterSpec) trafo.getParameterSpec()).             transforms.add(transform).             LOG.debug("Transform method: {}", trafo.getAlgorithm()).         }         return transforms.     } else {         LOG.debug("Header {} with value '{}' found", XmlSignatureConstants.HEADER_TRANSFORM_METHODS, transformMethodsHeaderValue).         String[] transformAlgorithms = transformMethodsHeaderValue.split(",").         List<Transform> transforms = new ArrayList<>(transformAlgorithms.length).         for (String transformAlgorithm : transformAlgorithms) {             transformAlgorithm = transformAlgorithm.trim().             Transform transform = fac.newTransform(transformAlgorithm, (TransformParameterSpec) null).             transforms.add(transform).             LOG.debug("Transform method: {}", transformAlgorithm).         }         return transforms.     } }
false;private;1;8;;private boolean containsEnvelopedTransform(List<AlgorithmMethod> configuredTrafos) {     for (AlgorithmMethod m : configuredTrafos) {         if (Transform.ENVELOPED.equals(m.getAlgorithm())) {             return true.         }     }     return false. }
false;protected;0;28;;protected String getDigestAlgorithmUri() throws XmlSignatureException {     String result = getConfiguration().getDigestAlgorithm().     if (result == null) {         String signatureAlgorithm = getConfiguration().getSignatureAlgorithm().         if (signatureAlgorithm != null) {             if (signatureAlgorithm.contains(SHA1)) {                 result = DigestMethod.SHA1.             } else if (signatureAlgorithm.contains(SHA224)) {                 result = HTTP_WWW_W3_ORG_2001_04_XMLDSIG_MORE_SHA224.             } else if (signatureAlgorithm.contains(SHA256)) {                 result = DigestMethod.SHA256.             } else if (signatureAlgorithm.contains(SHA384)) {                 result = HTTP_WWW_W3_ORG_2001_04_XMLDSIG_MORE_SHA384.             } else if (signatureAlgorithm.contains(SHA512)) {                 result = DigestMethod.SHA512.             } else if (signatureAlgorithm.contains(RIPEMD160)) {                 return DigestMethod.RIPEMD160.             }         }     }     if (result != null) {         LOG.debug("Digest algorithm: {}", result).         return result.     }     throw new XmlSignatureException("Digest algorithm missing for XML signature generation. Specify the digest algorithm in the configuration."). }
false;protected;3;19;;protected Reference createKeyInfoReference(XMLSignatureFactory fac, String keyInfoId, String digestAlgorithm) throws Exception {     if (keyInfoId == null) {         return null.     }     if (getConfiguration().getAddKeyInfoReference() == null) {         return null.     }     if (!getConfiguration().getAddKeyInfoReference()) {         return null.     }     LOG.debug("Creating reference to key info element with Id: {}", keyInfoId).     List<Transform> transforms = new ArrayList<>(1).     Transform transform = fac.newTransform(CanonicalizationMethod.INCLUSIVE, (TransformParameterSpec) null).     transforms.add(transform).     return fac.newReference("#" + keyInfoId, fac.newDigestMethod(digestAlgorithm, null), transforms, null, null). }
false;private;1;6;;private String getKeyInfoId(KeyInfo keyInfo) throws Exception {     // NOPMD     if (keyInfo == null) {         return null.     }     return keyInfo.getId(). }
false;protected;1;5;;protected void setOutputEncodingToMessageHeader(Message message) {     if (getConfiguration().getOutputXmlEncoding() != null) {         message.setHeader(Exchange.CHARSET_NAME, getConfiguration().getOutputXmlEncoding()).     } }
false;public;1;4;;public InputBuilder signatureFactory(XMLSignatureFactory signatureFactory) {     this.signatureFactory = signatureFactory.     return this. }
false;public;1;4;;public InputBuilder signatureAlgorithm(String signatureAlgorithm) {     this.signatureAlgorithm = signatureAlgorithm.     return this. }
false;public;1;4;;public InputBuilder parent(Node parent) {     this.parent = parent.     return this. }
false;public;1;4;;public InputBuilder messageBodyNode(Node messageBodyNode) {     this.messageBodyNode = messageBodyNode.     return this. }
false;public;1;4;;public InputBuilder message(Message message) {     this.message = message.     return this. }
false;public;1;4;;public InputBuilder keyInfo(KeyInfo keyInfo) {     this.keyInfo = keyInfo.     return this. }
false;public;1;4;;public InputBuilder contentDigestAlgorithm(String contentDigestAlgorithm) {     this.contentDigestAlgorithm = contentDigestAlgorithm.     return this. }
false;public;1;4;;public InputBuilder signatureId(String signatureId) {     this.signatureId = signatureId.     return this. }
false;public;1;4;;public InputBuilder contentReferenceUri(String contentReferenceUri) {     this.contentReferenceUri = contentReferenceUri.     return this. }
false;public;1;4;;public InputBuilder signatureType(SignatureType signatureType) {     this.signatureType = signatureType.     return this. }
false;public;1;4;;public InputBuilder prefixForXmlSignatureNamespace(String prefixForXmlSignatureNamespace) {     this.prefixForXmlSignatureNamespace = prefixForXmlSignatureNamespace.     return this. }
false;public;0;4;;@Override public XMLSignatureFactory getSignatureFactory() {     return signatureFactory. }
false;public;0;4;;@Override public String getSignatureAlgorithm() {     return signatureAlgorithm. }
false;public;0;4;;@Override public Node getParent() {     return parent. }
false;public;0;4;;@Override public Node getMessageBodyNode() {     return messageBodyNode. }
false;public;0;4;;@Override public Message getMessage() {     return message. }
false;public;0;4;;@Override public KeyInfo getKeyInfo() {     return keyInfo. }
false;public;0;4;;@Override public String getContentDigestAlgorithm() {     return contentDigestAlgorithm. }
false;public;0;4;;@Override public String getSignatureId() {     return signatureId. }
false;public;0;4;;@Override public String getContentReferenceUri() {     return contentReferenceUri. }
false;public;0;4;;@Override public SignatureType getSignatureType() {     return signatureType. }
false;public;0;4;;@Override public String getPrefixForXmlSignatureNamespace() {     return prefixForXmlSignatureNamespace. }
false;public;0;60;;public XmlSignatureProperties.Input build() {     return new XmlSignatureProperties.Input() {          @Override         public XMLSignatureFactory getSignatureFactory() {             return signatureFactory.         }          @Override         public String getSignatureAlgorithm() {             return signatureAlgorithm.         }          @Override         public Node getParent() {             return parent.         }          @Override         public Node getMessageBodyNode() {             return messageBodyNode.         }          @Override         public Message getMessage() {             return message.         }          @Override         public KeyInfo getKeyInfo() {             return keyInfo.         }          @Override         public String getContentDigestAlgorithm() {             return contentDigestAlgorithm.         }          @Override         public String getSignatureId() {             return signatureId.         }          @Override         public String getContentReferenceUri() {             return contentReferenceUri.         }          @Override         public SignatureType getSignatureType() {             return signatureType.         }          @Override         public String getPrefixForXmlSignatureNamespace() {             return prefixForXmlSignatureNamespace.         }     }. }
false;private;1;13;;private int calculateLevel(Element node) {     int counter = 0.     for (Node n = node. n != null. n = n.getParentNode()) {         if (Node.ELEMENT_NODE == n.getNodeType()) {             counter++.             if (counter > 10000) {                 // prevent security attack                 throw new IllegalStateException("Hierachy level is limited to 10000").             }         }     }     return counter. }
false;public;1;4;;@Override public int compareTo(ComparableNode o) {     return o.level - level. }
false;;0;3;;String getReferenceUri() {     return referenceUri. }
false;static;1;7;;static List<String> getReferenceUris(List<ComparableNode> input) {     List<String> result = new ArrayList<>(input.size()).     for (ComparableNode cn : input) {         result.add(cn.getReferenceUri()).     }     return result. }
