commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public XmlVerifierConfiguration getConfiguration() {     return config. }
false;public;1;18;;@Override public void process(Exchange exchange) throws Exception {     // NOPMD     InputStream stream = exchange.getIn().getMandatoryBody(InputStream.class).     try {         // lets setup the out message before we invoke the signing         // so that it can mutate it if necessary         Message out = exchange.getOut().         out.copyFrom(exchange.getIn()).         verify(stream, out).         clearMessageHeaders(out).     } catch (Exception e) {         // remove OUT message, as an exception occurred         exchange.setOut(null).         throw e.     } finally {         IOHelper.close(stream, "input stream").     } }
false;protected;2;73;;@SuppressWarnings("unchecked") protected void verify(InputStream input, final Message out) throws Exception {     // NOPMD     LOG.debug("Verification of XML signature document started").     final Document doc = parseInput(input, out).     XMLSignatureFactory fac.     // not work     try {         fac = XMLSignatureFactory.getInstance("DOM", "ApacheXMLDSig").     } catch (NoSuchProviderException ex) {         fac = XMLSignatureFactory.getInstance("DOM").     }     KeySelector selector = getConfiguration().getKeySelector().     if (selector == null) {         throw new IllegalStateException("Wrong configuration. Key selector is missing.").     }     DOMValidateContext valContext = new DOMValidateContext(selector, doc).     valContext.setProperty("javax.xml.crypto.dsig.cacheReference", Boolean.TRUE).     valContext.setProperty("org.jcp.xml.dsig.validateManifests", Boolean.TRUE).     if (getConfiguration().getSecureValidation() == Boolean.TRUE) {         valContext.setProperty("org.apache.jcp.xml.dsig.secureValidation", Boolean.TRUE).         valContext.setProperty("org.jcp.xml.dsig.secureValidation", Boolean.TRUE).     }     setUriDereferencerAndBaseUri(valContext).     setCryptoContextProperties(valContext).     NodeList signatureNodes = getSignatureNodes(doc).     List<XMLObject> collectedObjects = new ArrayList<>(3).     List<Reference> collectedReferences = new ArrayList<>(3).     int totalCount = signatureNodes.getLength().     for (int i = 0. i < totalCount. i++) {         Element signatureNode = (Element) signatureNodes.item(i).         valContext.setNode(signatureNode).         final XMLSignature signature = fac.unmarshalXMLSignature(valContext).         if (getConfiguration().getXmlSignatureChecker() != null) {             XmlSignatureChecker.Input checkerInput = new CheckerInputBuilder().message(out).messageBodyDocument(doc).keyInfo(signature.getKeyInfo()).currentCountOfSignatures(i + 1).currentSignatureElement(signatureNode).objects(signature.getObjects()).signatureValue(signature.getSignatureValue()).signedInfo(signature.getSignedInfo()).totalCountOfSignatures(totalCount).xmlSchemaValidationExecuted(getSchemaResourceUri(out) != null).build().             getConfiguration().getXmlSignatureChecker().checkBeforeCoreValidation(checkerInput).         }         boolean coreValidity.         try {             coreValidity = signature.validate(valContext).         } catch (XMLSignatureException se) {             throw getConfiguration().getValidationFailedHandler().onXMLSignatureException(se).         }         // Check core validation status         boolean goon = coreValidity.         if (!coreValidity) {             goon = handleSignatureValidationFailed(valContext, signature).         }         if (goon) {             LOG.debug("XML signature {} verified", i + 1).         } else {             throw new XmlSignatureInvalidException("XML signature validation failed").         }         collectedObjects.addAll(signature.getObjects()).         collectedReferences.addAll(signature.getSignedInfo().getReferences()).     }     map2Message(collectedReferences, collectedObjects, out, doc). }
false;public;0;4;;@Override public List<Reference> getReferences() {     return refs. }
false;public;0;4;;@Override public List<XMLObject> getObjects() {     return objs. }
false;public;0;4;;@Override public Document getMessageBodyDocument() {     return messageBodyDocument. }
false;public;0;4;;@Override public Boolean omitXmlDeclaration() {     return getConfiguration().getOmitXmlDeclaration(). }
false;public;0;4;;@Override public Object getOutputNodeSearch() {     return getConfiguration().getOutputNodeSearch(). }
false;public;0;4;;@Override public String getOutputNodeSearchType() {     return getConfiguration().getOutputNodeSearchType(). }
false;public;0;4;;@Override public Boolean getRemoveSignatureElements() {     return getConfiguration().getRemoveSignatureElements(). }
false;public;0;4;;@Override public String getOutputXmlEncoding() {     return getConfiguration().getOutputXmlEncoding(). }
false;private;4;48;;private void map2Message(final List<Reference> refs, final List<XMLObject> objs, Message out, final Document messageBodyDocument) throws Exception {     // NOPMD     XmlSignature2Message.Input refsAndObjects = new XmlSignature2Message.Input() {          @Override         public List<Reference> getReferences() {             return refs.         }          @Override         public List<XMLObject> getObjects() {             return objs.         }          @Override         public Document getMessageBodyDocument() {             return messageBodyDocument.         }          @Override         public Boolean omitXmlDeclaration() {             return getConfiguration().getOmitXmlDeclaration().         }          @Override         public Object getOutputNodeSearch() {             return getConfiguration().getOutputNodeSearch().         }          @Override         public String getOutputNodeSearchType() {             return getConfiguration().getOutputNodeSearchType().         }          @Override         public Boolean getRemoveSignatureElements() {             return getConfiguration().getRemoveSignatureElements().         }          @Override         public String getOutputXmlEncoding() {             return getConfiguration().getOutputXmlEncoding().         }     }.     getConfiguration().getXmlSignature2Message().mapToMessage(refsAndObjects, out). }
false;private;1;12;;private NodeList getSignatureNodes(Document doc) throws IOException, ParserConfigurationException, XmlSignatureFormatException {     // Find Signature element     NodeList nl = doc.getElementsByTagNameNS(XMLSignature.XMLNS, "Signature").     if (nl.getLength() == 0) {         throw new XmlSignatureFormatException("Message is not a correct XML signature document: 'Signature' element is missing. Check the sent message.").     }     LOG.debug("{} signature elements found", nl.getLength()).     return nl. }
false;protected;2;49;;@SuppressWarnings("unchecked") protected boolean handleSignatureValidationFailed(DOMValidateContext valContext, XMLSignature signature) throws Exception {     // NOPMD     ValidationFailedHandler handler = getConfiguration().getValidationFailedHandler().     LOG.debug("handleSignatureValidationFailed called").     try {         handler.start().         // first check signature value, see         // https://www.isecpartners.com/media/12012/XMLDSIG_Command_Injection.pdf         SignatureValue sigValue = signature.getSignatureValue().         boolean sv = sigValue.validate(valContext).         if (!sv) {             handler.signatureValueValidationFailed(sigValue).         }         // check the validation status of each Reference         for (Reference ref : (List<Reference>) signature.getSignedInfo().getReferences()) {             boolean refValid = ref.validate(valContext).             if (!refValid) {                 handler.referenceValidationFailed(ref).             }         }         // validate Manifests, if property set         if (Boolean.TRUE.equals(valContext.getProperty("org.jcp.xml.dsig.validateManifests"))) {             for (XMLObject xo : (List<XMLObject>) signature.getObjects()) {                 List<XMLStructure> content = xo.getContent().                 for (XMLStructure xs : content) {                     if (xs instanceof Manifest) {                         Manifest man = (Manifest) xs.                         for (Reference ref : (List<Reference>) man.getReferences()) {                             boolean refValid = ref.validate(valContext).                             if (!refValid) {                                 handler.manifestReferenceValidationFailed(ref).                             }                         }                     }                 }             }         }         boolean goon = handler.ignoreCoreValidationFailure().         LOG.debug("Ignore Core Validation failure: {}", goon).         return goon.     } finally {         handler.end().     } }
false;protected;2;14;;protected Document parseInput(InputStream is, Message message) throws Exception {     // NOPMD     try {         ValidatorErrorHandler errorHandler = new DefaultValidationErrorHandler().         Schema schema = getSchema(message).         DocumentBuilder db = XmlSignatureHelper.newDocumentBuilder(getConfiguration().getDisallowDoctypeDecl(), schema).         db.setErrorHandler(errorHandler).         Document doc = db.parse(is).         // throws ValidationException         errorHandler.handleErrors(message.getExchange(), schema, null).         return doc.     } catch (SAXException e) {         throw new XmlSignatureFormatException("Message has wrong format, it is not a XML signature document. Check the sent message.", e).     } }
false;;1;4;;CheckerInputBuilder xmlSchemaValidationExecuted(boolean xmlSchemaValidationExecuted) {     this.xmlSchemaValidationExecuted = xmlSchemaValidationExecuted.     return this. }
false;;1;4;;CheckerInputBuilder totalCountOfSignatures(int totalCountOfSignatures) {     this.totalCountOfSignatures = totalCountOfSignatures.     return this. }
false;;1;4;;CheckerInputBuilder signedInfo(SignedInfo signedInfo) {     this.signedInfo = signedInfo.     return this. }
false;;1;4;;CheckerInputBuilder signatureValue(SignatureValue signatureValue) {     this.signatureValue = signatureValue.     return this. }
false;;1;4;;CheckerInputBuilder objects(List<? extends XMLObject> objects) {     this.objects = objects.     return this. }
false;;1;4;;CheckerInputBuilder messageBodyDocument(Document messageBodyDocument) {     this.messageBodyDocument = messageBodyDocument.     return this. }
false;;1;4;;CheckerInputBuilder message(Message message) {     this.message = message.     return this. }
false;;1;4;;CheckerInputBuilder keyInfo(KeyInfo keyInfo) {     this.keyInfo = keyInfo.     return this. }
false;;1;4;;CheckerInputBuilder currentSignatureElement(Element currentSignatureElement) {     this.currentSignatureElement = currentSignatureElement.     return this. }
false;;1;4;;CheckerInputBuilder currentCountOfSignatures(int currentCountOfSignatures) {     this.currentCountOfSignatures = currentCountOfSignatures.     return this. }
false;public;0;4;;@Override public boolean isXmlSchemaValidationExecuted() {     return xmlSchemaValidationExecuted. }
false;public;0;4;;@Override public int getTotalCountOfSignatures() {     return totalCountOfSignatures. }
false;public;0;4;;@Override public SignedInfo getSignedInfo() {     return signedInfo. }
false;public;0;4;;@Override public SignatureValue getSignatureValue() {     return signatureValue. }
false;public;0;4;;@Override public List<? extends XMLObject> getObjects() {     return objects. }
false;public;0;4;;@Override public Document getMessageBodyDocument() {     return messageBodyDocument. }
false;public;0;4;;@Override public Message getMessage() {     return message. }
false;public;0;4;;@Override public KeyInfo getKeyInfo() {     return keyInfo. }
false;public;0;4;;@Override public Element getCurrentSignatureElement() {     return currentSignatureElement. }
false;public;0;4;;@Override public int getCurrentCountOfSignatures() {     return currentCountOfSignatures. }
false;;0;54;;XmlSignatureChecker.Input build() {     return new XmlSignatureChecker.Input() {          @Override         public boolean isXmlSchemaValidationExecuted() {             return xmlSchemaValidationExecuted.         }          @Override         public int getTotalCountOfSignatures() {             return totalCountOfSignatures.         }          @Override         public SignedInfo getSignedInfo() {             return signedInfo.         }          @Override         public SignatureValue getSignatureValue() {             return signatureValue.         }          @Override         public List<? extends XMLObject> getObjects() {             return objects.         }          @Override         public Document getMessageBodyDocument() {             return messageBodyDocument.         }          @Override         public Message getMessage() {             return message.         }          @Override         public KeyInfo getKeyInfo() {             return keyInfo.         }          @Override         public Element getCurrentSignatureElement() {             return currentSignatureElement.         }          @Override         public int getCurrentCountOfSignatures() {             return currentCountOfSignatures.         }     }. }
