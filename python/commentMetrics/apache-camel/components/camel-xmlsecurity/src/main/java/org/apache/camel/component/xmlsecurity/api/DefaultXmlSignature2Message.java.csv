commented;modifiers;parameterAmount;loc;comment;code
false;public;2;35;;@Override public void mapToMessage(Input input, Message output) throws Exception {     // NOPMD     Node node.     boolean removeSignatureElements = false.     if (OUTPUT_NODE_SEARCH_TYPE_DEFAULT.equals(input.getOutputNodeSearchType())) {         LOG.debug("Searching for output node via default search").         if (isEnveloping(input)) {             node = getNodeForMessageBodyInEnvelopingCase(input).         } else {             // enveloped or detached XML signature  --> remove signature element             node = input.getMessageBodyDocument().getDocumentElement().             removeSignatureElements = true.         }     } else if (OUTPUT_NODE_SEARCH_TYPE_ELEMENT_NAME.equals(input.getOutputNodeSearchType())) {         node = getOutputElementViaLocalNameAndNamespace(input).     } else if (OUTPUT_NODE_SEARCH_TYPE_XPATH.equals(input.getOutputNodeSearchType())) {         node = getOutputNodeViaXPath(input).     } else {         throw new XmlSignatureException(String.format("Wrong configuration: The output node search type %s is not supported.", input.getOutputNodeSearchType())).     }     LOG.debug("Output node with local name {} and namespace {} found", node.getLocalName(), node.getNamespaceURI()).     if (!removeSignatureElements) {         removeSignatureElements = input.getRemoveSignatureElements() != null && input.getRemoveSignatureElements().     }     if (removeSignatureElements) {         removeSignatureElements(node).     }     transformNodeToByteArrayAndSetToOutputMessage(input, output, node). }
false;protected;3;10;;protected void transformNodeToByteArrayAndSetToOutputMessage(Input input, Message output, Node node) throws Exception {     ByteArrayOutputStream os = new ByteArrayOutputStream().     XmlSignatureHelper.transformToOutputStream(node, os, omitXmlDeclaration(output, input), input.getOutputXmlEncoding()).     output.setBody(os.toByteArray()).     if (input.getOutputXmlEncoding() != null) {         output.setHeader(Exchange.CHARSET_NAME, input.getOutputXmlEncoding()).     } }
false;protected;1;27;;protected Node getOutputNodeViaXPath(Input input) throws Exception {     // NOPMD     checkSearchValueNotNull(input).     checkSearchValueOfType(XPathFilterParameterSpec.class, input).     XPathFilterParameterSpec xpathFilter = (XPathFilterParameterSpec) input.getOutputNodeSearch().     XPathExpression expr = XmlSignatureHelper.getXPathExpression(xpathFilter).     NodeList nodes = (NodeList) expr.evaluate(input.getMessageBodyDocument(), XPathConstants.NODESET).     if (nodes == null || nodes.getLength() == 0) {         throw new XmlSignatureException(String.format("Cannot extract root node for the output document from the XML signature document. No node found for XPATH %s as specified in the output node search.", xpathFilter.getXPath())).     }     if (nodes.getLength() > 1) {         throw new XmlSignatureException(String.format("Cannot extract root node for the output document from the XML signature document. XPATH %s as specified in the output node search results into more than one child.", xpathFilter.getXPath())).     }     Node result = nodes.item(0).     if (Node.ELEMENT_NODE == result.getNodeType() || Node.TEXT_NODE == result.getNodeType() || Node.DOCUMENT_NODE == result.getNodeType()) {         return result.     }     throw new XmlSignatureException(String.format("Cannot extract root node for the output document from the XML signature document. " + "XPATH %s as specified in the output node search results into a node which has the wrong type.", xpathFilter.getXPath())). }
false;protected;1;42;;protected Node getOutputElementViaLocalNameAndNamespace(Input input) throws Exception {     // NOPMD     String search = getNonEmptyStringSearchValue(input).     String namespace.     String localName.     if ('{' == search.charAt(0)) {         // namespace         int index = search.indexOf('}').         if (index < 1) {             throw new XmlSignatureException(String.format("Wrong configuration: Value %s for the output node search %s has wrong format. " + "Value must have the form '{<namespace>}<element local name>' or '<element local name>' if no the element has no namespace.", search, input.getOutputNodeSearchType())).         }         namespace = search.substring(1, index).         if (search.length() < index + 1) {             throw new XmlSignatureException(String.format("Wrong configuration: Value %s for the output node search %s has wrong format. " + "Value must have the form '{<namespace>}<element local name>' or '<element local name>' if no the element has no namespace.", search, input.getOutputNodeSearchType())).         }         localName = search.substring(index + 1).     } else {         namespace = null.         localName = search.     }     NodeList nodeList = input.getMessageBodyDocument().getElementsByTagNameNS(namespace, localName).     if (nodeList.getLength() == 0) {         throw new XmlSignatureException(String.format("Cannot extract root element for the output document from the XML signature document. Element with local name %s and namespace %s does not exist.", namespace, localName)).     }     if (nodeList.getLength() > 1) {         throw new XmlSignatureException(String.format("Cannot extract root element for the output document from the XML signature document. More than one element found with local name %s and namespace %s.", namespace, localName)).     }     return nodeList.item(0). }
false;protected;1;7;;protected String getNonEmptyStringSearchValue(Input input) throws Exception {     // NOPMD     checkSearchValueNotNull(input).     checkSearchValueOfType(String.class, input).     String search = (String) input.getOutputNodeSearch().     checkStringSarchValueNotEmpty(search, input.getOutputNodeSearchType()).     return search. }
false;protected;2;8;;protected void checkSearchValueOfType(Class<?> cl, Input input) throws Exception {     // NOPMD     if (!cl.isAssignableFrom(input.getOutputNodeSearch().getClass())) {         throw new XMLSignatureException(String.format("Wrong configruation: Search value is of class %s, the output node search %s requires class %s.", input.getOutputNodeSearch().getClass().getName(), input.getOutputNodeSearchType(), cl.getName())).     } }
false;protected;2;6;;protected void checkStringSarchValueNotEmpty(String searchValue, String outputNodeSearchType) throws Exception {     // NOPMD     if (searchValue.isEmpty()) {         throw new XMLSignatureException(String.format("Wrong configruation: Value for output node search %s is empty.", outputNodeSearchType)).     } }
false;protected;1;8;;protected void checkSearchValueNotNull(Input input) throws Exception {     // NOPMD     LOG.debug("Searching for output element with search value '{}' and sarch type {}", input.getOutputNodeSearch(), input.getOutputNodeSearchType()).     if (input.getOutputNodeSearch() == null) {         throw new XMLSignatureException(String.format("Wrong configruation: Value is missing for output node search %s.", input.getOutputNodeSearchType())).     } }
false;protected;1;10;;protected Node getNodeForMessageBodyInEnvelopingCase(Input input) throws Exception {     // NOPMD     Node node.     List<Reference> relevantReferences = getReferencesForMessageMapping(input).     List<XMLObject> relevantObjects = getObjectsForMessageMapping(input).     DOMStructure domStruc = getDomStructureForMessageBody(relevantReferences, relevantObjects).     node = domStruc.getNode().     return node. }
true;protected;1;15;/**  * Removes the Signature elements from the document.  *  * @param doc  *            document  */ ;/**  * Removes the Signature elements from the document.  *  * @param doc  *            document  */ protected void removeSignatureElements(Node node) {     Document doc = XmlSignatureHelper.getDocument(node).     NodeList nl = doc.getElementsByTagNameNS(XMLSignature.XMLNS, "Signature").     List<Node> nodesToBeRemoved = new ArrayList<>(nl.getLength()).     for (int i = 0. i < nl.getLength(). i++) {         // you cannot remove the nodes within this loop, because nl list would change         nodesToBeRemoved.add(nl.item(i)).     }     for (Node n : nodesToBeRemoved) {         Node parent = n.getParentNode().         if (parent != null) {             parent.removeChild(n).         }     } }
true;protected;1;7;/**  * Checks whether the XML document has as root element the signature  * element.  *  * @param input  *            XML signature input  * @return <code>true</code> if the root element of the xml signature  *         document is the signature element. otherwise <code>false</code>  * @throws Exception  */ ;/**  * Checks whether the XML document has as root element the signature  * element.  *  * @param input  *            XML signature input  * @return <code>true</code> if the root element of the xml signature  *         document is the signature element. otherwise <code>false</code>  * @throws Exception  */ protected boolean isEnveloping(Input input) throws Exception {     // NOPMD     Element el = input.getMessageBodyDocument().getDocumentElement().     if ("Signature".equals(el.getLocalName()) && XMLSignature.XMLNS.equals(el.getNamespaceURI())) {         return true.     }     return false. }
false;protected;2;10;;protected Boolean omitXmlDeclaration(Message message, Input input) {     Boolean omitXmlDeclaration = message.getHeader(XmlSignatureConstants.HEADER_OMIT_XML_DECLARATION, Boolean.class).     if (omitXmlDeclaration == null) {         omitXmlDeclaration = input.omitXmlDeclaration().     }     if (omitXmlDeclaration == null) {         omitXmlDeclaration = Boolean.FALSE.     }     return omitXmlDeclaration. }
true;protected;1;3;/**  * Returns the references whose referenced objects are taken into account  * for the message body. This message you can use to filter the relevant  * references from the references provided by the input parameter.  *  * @param input  *            references and objects  * @return relevant references for the mapping to the camel message  * @throws Exception  *             if an error occurs  */ ;/**  * Returns the references whose referenced objects are taken into account  * for the message body. This message you can use to filter the relevant  * references from the references provided by the input parameter.  *  * @param input  *            references and objects  * @return relevant references for the mapping to the camel message  * @throws Exception  *             if an error occurs  */ protected List<Reference> getReferencesForMessageMapping(Input input) throws Exception {     // NOPMD     return input.getReferences(). }
true;protected;1;3;/**  * Returns the objects which must be taken into account for the mapping to  * the camel message.  *  * @param input  *            references and objects  * @return relevant objects for the mapping to camel message  * @throws Exception  *             if an error occurs  */ ;/**  * Returns the objects which must be taken into account for the mapping to  * the camel message.  *  * @param input  *            references and objects  * @return relevant objects for the mapping to camel message  * @throws Exception  *             if an error occurs  */ protected List<XMLObject> getObjectsForMessageMapping(Input input) throws Exception {     // NOPMD     return input.getObjects(). }
true;protected;2;37;/**  * Returns the DOM structure which is transformed to a byte array and set to  * the camel message body.  *  * @param relevantReferences  *            input from method  *            {@link #getReferencesForMessageMapping(ReferencesAndObjects)}  * @param relevantObjects  *            input from method  *            {@link #getObjectsForMessageMapping(ReferencesAndObjects)}  * @return dom structure  * @throws Exception  *             if an error occurs  */ ;/**  * Returns the DOM structure which is transformed to a byte array and set to  * the camel message body.  *  * @param relevantReferences  *            input from method  *            {@link #getReferencesForMessageMapping(ReferencesAndObjects)}  * @param relevantObjects  *            input from method  *            {@link #getObjectsForMessageMapping(ReferencesAndObjects)}  * @return dom structure  * @throws Exception  *             if an error occurs  */ protected DOMStructure getDomStructureForMessageBody(List<Reference> relevantReferences, List<XMLObject> relevantObjects) throws Exception {     // NOPMD     List<XMLObject> referencedObjects = getReferencedSameDocumentObjects(relevantReferences, relevantObjects).     if (referencedObjects.isEmpty()) {         throw new XmlSignatureException(String.format("Unsupported XML signature document: Content object not found in the enveloping XML signature.")).     }     if (referencedObjects.size() > 1) {         StringBuilder sb = new StringBuilder().         for (int i = 0. i < referencedObjects.size(). i++) {             XMLObject xmlOb = referencedObjects.get(i).             sb.append(xmlOb.getId()).             if (i < referencedObjects.size() - 1) {                 sb.append(", ").             }         }         throw new XmlSignatureException(String.format("Unsupported XML signature document: More than one content objects found. Object IDs: %s", sb.toString())).     }     @SuppressWarnings("unchecked")     List<XMLStructure> structures = referencedObjects.get(0).getContent().     if (structures.size() == 0) {         throw new XmlSignatureException("Unsupported XML signature: XML signature is not enveloping. content not found in XML signature: structure list is empty.").     }     if (structures.size() > 1) {         throw new XmlSignatureException("Unsupported XML signature: more than one structure elements in referenced content object.").     }     XMLStructure structure = structures.get(0).     // only dom currently supported     DOMStructure domStruc = (DOMStructure) structure.     return domStruc. }
false;protected;2;18;;protected List<XMLObject> getReferencedSameDocumentObjects(List<Reference> relevantReferences, List<XMLObject> relevantObjects) {     List<XMLObject> referencedObjects = new ArrayList<>(1).     for (Reference ref : relevantReferences) {         String refUri = getSameDocumentReferenceUri(ref).         if (refUri == null) {             continue.         }         XMLObject referencedOb = getReferencedObject(relevantObjects, refUri).         if (referencedOb != null) {             referencedObjects.add(referencedOb).             continue.         }         // content could also be indirectly referenced via manifest         addManifestReferencedObjects(relevantObjects, referencedObjects, refUri).     }     return referencedObjects. }
false;protected;3;17;;@SuppressWarnings("unchecked") protected void addManifestReferencedObjects(List<XMLObject> allObjects, List<XMLObject> referencedObjects, String manifestId) {     Manifest manifest = getReferencedManifest(allObjects, manifestId).     if (manifest == null) {         return.     }     for (Reference manifestRef : (List<Reference>) manifest.getReferences()) {         String manifestRefUri = getSameDocumentReferenceUri(manifestRef).         if (manifestRefUri == null) {             continue.         }         XMLObject manifestReferencedOb = getReferencedObject(allObjects, manifestRefUri).         if (manifestReferencedOb != null) {             referencedObjects.add(manifestReferencedOb).         }     } }
false;protected;1;12;;protected String getSameDocumentReferenceUri(Reference ref) {     String refUri = ref.getURI().     if (refUri == null) {         LOG.warn("Ignoring reference {} which has no URI", ref).         return null.     }     if (!refUri.startsWith("#")) {         LOG.warn("Ignoring non-same document reference {}", refUri).         return null.     }     return refUri.substring(1). }
false;protected;2;15;;protected Manifest getReferencedManifest(List<XMLObject> objects, String id) {     for (XMLObject xo : objects) {         @SuppressWarnings("unchecked")         List<XMLStructure> content = xo.getContent().         for (XMLStructure xs : content) {             if (xs instanceof Manifest) {                 Manifest man = (Manifest) xs.                 if (id.equals(man.getId())) {                     return man.                 }             }         }     }     return null. }
false;protected;2;8;;protected XMLObject getReferencedObject(List<XMLObject> objects, String id) {     for (XMLObject ob : objects) {         if (id.equals(ob.getId())) {             return ob.         }     }     return null. }
