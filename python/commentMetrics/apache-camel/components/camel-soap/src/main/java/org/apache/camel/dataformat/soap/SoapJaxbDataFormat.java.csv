commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getDataFormatName() {     return "soapjaxb". }
false;protected;0;11;;@Override protected void doStart() throws Exception {     if ("1.2".equals(version)) {         log.debug("Using SOAP 1.2 adapter").         adapter = new Soap12DataFormatAdapter(this).     } else {         log.debug("Using SOAP 1.1 adapter").         adapter = new Soap11DataFormatAdapter(this).     }     super.doStart(). }
false;protected;1;16;;protected void checkElementNameStrategy(Exchange exchange) {     if (elementNameStrategy == null) {         synchronized (this) {             if (elementNameStrategy != null) {                 return.             } else {                 if (elementNameStrategyRef != null) {                     elementNameStrategy = exchange.getContext().getRegistry().lookupByNameAndType(elementNameStrategyRef, ElementNameStrategy.class).                 } else {                     elementNameStrategy = new TypeNameStrategy().                 }             }         }     } }
true;public;3;17;/**  * Marshal inputObjects to SOAP xml. If the exchange or message has an  * EXCEPTION_CAUGTH property or header then instead of the object the  * exception is marshaled.  *  * To determine the name of the top level xml elements the elementNameStrategy  * is used.  */ ;/**  * Marshal inputObjects to SOAP xml. If the exchange or message has an  * EXCEPTION_CAUGTH property or header then instead of the object the  * exception is marshaled.  *  * To determine the name of the top level xml elements the elementNameStrategy  * is used.  */ public void marshal(Exchange exchange, Object inputObject, OutputStream stream) throws IOException {     checkElementNameStrategy(exchange).     String soapAction = getSoapActionFromExchange(exchange).     if (soapAction == null && inputObject instanceof BeanInvocation) {         BeanInvocation beanInvocation = (BeanInvocation) inputObject.         WebMethod webMethod = beanInvocation.getMethod().getAnnotation(WebMethod.class).         if (webMethod != null && webMethod.action() != null) {             soapAction = webMethod.action().         }     }     Object envelope = adapter.doMarshal(exchange, inputObject, stream, soapAction).     // and continue in super     super.marshal(exchange, envelope, stream). }
true;protected;3;69;/**  * Create body content from a non Exception object. If the inputObject is a  * BeanInvocation the following should be considered: The first parameter  * will be used for the SOAP body. BeanInvocations with more than one  * parameter are not supported. So the interface should be in doc lit bare  * style.  *  * @param inputObject  *            object to be put into the SOAP body  * @param soapAction  *            for name resolution  * @param headerElements  *            in/out parameter used to capture header content if present  *  * @return JAXBElement for the body content  */ ;/**  * Create body content from a non Exception object. If the inputObject is a  * BeanInvocation the following should be considered: The first parameter  * will be used for the SOAP body. BeanInvocations with more than one  * parameter are not supported. So the interface should be in doc lit bare  * style.  *  * @param inputObject  *            object to be put into the SOAP body  * @param soapAction  *            for name resolution  * @param headerElements  *            in/out parameter used to capture header content if present  *  * @return JAXBElement for the body content  */ protected List<Object> createContentFromObject(final Object inputObject, String soapAction, List<Object> headerElements) {     List<Object> bodyParts = new ArrayList<>().     List<Object> headerParts = new ArrayList<>().     if (inputObject instanceof BeanInvocation) {         BeanInvocation bi = (BeanInvocation) inputObject.         Annotation[][] annotations = bi.getMethod().getParameterAnnotations().         List<WebParam> webParams = new ArrayList<>().         for (Annotation[] singleParameterAnnotations : annotations) {             for (Annotation annotation : singleParameterAnnotations) {                 if (annotation instanceof WebParam) {                     webParams.add((WebParam) annotation).                 }             }         }         if (webParams.size() > 0) {             if (webParams.size() == bi.getArgs().length) {                 int index = -1.                 for (Object o : bi.getArgs()) {                     if (webParams.get(++index).header()) {                         headerParts.add(o).                     } else {                         bodyParts.add(o).                     }                 }             } else {                 throw new RuntimeCamelException("The number of bean invocation parameters does not " + "match the number of parameters annotated with @WebParam for the method [ " + bi.getMethod().getName() + "].").             }         } else {             // try to map all objects for the body             for (Object o : bi.getArgs()) {                 bodyParts.add(o).             }         }     } else {         bodyParts.add(inputObject).     }     List<Object> bodyElements = new ArrayList<>().     for (Object bodyObj : bodyParts) {         QName name = elementNameStrategy.findQNameForSoapActionOrType(soapAction, bodyObj.getClass()).         if (name == null) {             log.warn("Could not find QName for class {}", bodyObj.getClass().getName()).             continue.         } else {             bodyElements.add(getElement(bodyObj, name)).         }     }     for (Object headerObj : headerParts) {         QName name = elementNameStrategy.findQNameForSoapActionOrType(soapAction, headerObj.getClass()).         if (name == null) {             log.warn("Could not find QName for class {}", headerObj.getClass().getName()).             continue.         } else {             JAXBElement<?> headerElem = getElement(headerObj, name).             if (null != headerElem) {                 headerElements.add(headerElem).             }         }     }     return bodyElements. }
false;private;2;20;;@SuppressWarnings({ "rawtypes", "unchecked" }) private JAXBElement<?> getElement(Object fromObj, QName name) {     Object value = null.     if (fromObj instanceof javax.xml.ws.Holder) {         javax.xml.ws.Holder holder = (javax.xml.ws.Holder) fromObj.         value = holder.value.         if (null == value) {             return null.         }     } else {         value = fromObj.     }     return new JAXBElement(name, value.getClass(), value). }
true;public;2;23;/**  * Unmarshal a given SOAP xml stream and return the content of the SOAP body  */ ;/**  * Unmarshal a given SOAP xml stream and return the content of the SOAP body  */ public Object unmarshal(Exchange exchange, InputStream stream) throws IOException {     checkElementNameStrategy(exchange).     String soapAction = getSoapActionFromExchange(exchange).     // Determine the method name for an eventual BeanProcessor in the route     if (soapAction != null && elementNameStrategy instanceof ServiceInterfaceStrategy) {         ServiceInterfaceStrategy strategy = (ServiceInterfaceStrategy) elementNameStrategy.         String methodName = strategy.getMethodForSoapAction(soapAction).         exchange.getOut().setHeader(Exchange.BEAN_METHOD_NAME, methodName).     }     // This is necessary as the soap action in the message may get lost on the way     if (soapAction != null) {         exchange.setProperty(Exchange.SOAP_ACTION, soapAction).     }     Object unmarshalledObject = super.unmarshal(exchange, stream).     Object rootObject = JAXBIntrospector.getValue(unmarshalledObject).     return adapter.doUnmarshal(exchange, stream, rootObject). }
false;private;1;14;;private String getSoapActionFromExchange(Exchange exchange) {     Message inMessage = exchange.getIn().     String soapAction = inMessage.getHeader(Exchange.SOAP_ACTION, String.class).     if (soapAction == null) {         soapAction = inMessage.getHeader("SOAPAction", String.class).         if (soapAction != null && soapAction.startsWith("\"")) {             soapAction = soapAction.substring(1, soapAction.length() - 1).         }     }     if (soapAction == null) {         soapAction = exchange.getProperty(Exchange.SOAP_ACTION, String.class).     }     return soapAction. }
true;protected;0;8;/**  * Added the generated SOAP package to the JAXB context so Soap datatypes  * are available  */ ;/**  * Added the generated SOAP package to the JAXB context so Soap datatypes  * are available  */ @Override protected JAXBContext createContext() throws JAXBException {     if (getContextPath() != null) {         return JAXBContext.newInstance(adapter.getSoapPackageName() + ":" + getContextPath()).     } else {         return JAXBContext.newInstance().     } }
false;public;0;3;;public ElementNameStrategy getElementNameStrategy() {     return elementNameStrategy. }
false;public;1;10;;public void setElementNameStrategy(Object nameStrategy) {     if (nameStrategy == null) {         this.elementNameStrategy = null.     } else if (nameStrategy instanceof ElementNameStrategy) {         this.elementNameStrategy = (ElementNameStrategy) nameStrategy.     } else {         throw new IllegalArgumentException("The argument for setElementNameStrategy should be subClass of " + ElementNameStrategy.class.getName()).     } }
false;public;0;3;;public String getElementNameStrategyRef() {     return elementNameStrategyRef. }
false;public;1;3;;public void setElementNameStrategyRef(String elementNameStrategyRef) {     this.elementNameStrategyRef = elementNameStrategyRef. }
false;public;0;3;;public boolean isIgnoreUnmarshalledHeaders() {     return ignoreUnmarshalledHeaders. }
false;public;1;3;;public void setIgnoreUnmarshalledHeaders(boolean ignoreUnmarshalledHeaders) {     this.ignoreUnmarshalledHeaders = ignoreUnmarshalledHeaders. }
false;public;0;3;;public String getVersion() {     return version. }
false;public;1;3;;public void setVersion(String version) {     this.version = version. }
