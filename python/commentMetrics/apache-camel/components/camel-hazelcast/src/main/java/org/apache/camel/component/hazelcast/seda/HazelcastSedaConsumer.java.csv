commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;10;;@Override protected void doStart() throws Exception {     int concurrentConsumers = endpoint.getConfiguration().getConcurrentConsumers().     executor = endpoint.getCamelContext().getExecutorServiceManager().newFixedThreadPool(this, endpoint.getEndpointUri(), concurrentConsumers).     for (int i = 0. i < concurrentConsumers. i++) {         executor.execute(this).     }     super.doStart(). }
false;protected;0;8;;@Override protected void doStop() throws Exception {     if (executor != null) {         endpoint.getCamelContext().getExecutorServiceManager().shutdown(executor).         executor = null.     }     super.doStop(). }
false;public;1;3;;public void done(boolean asyncDone) { // noop }
false;public;0;79;;public void run() {     BaseQueue<?> queue = endpoint.getHazelcastInstance().getQueue(endpoint.getConfiguration().getQueueName()).     while (queue != null && isRunAllowed()) {         final Exchange exchange = this.getEndpoint().createExchange().         TransactionContext transactionCtx = null.         try {             if (endpoint.getConfiguration().isTransacted()) {                 // Get and begin transaction if exist                 transactionCtx = endpoint.getHazelcastInstance().newTransactionContext().                 if (transactionCtx != null) {                     log.trace("Begin transaction: {}", transactionCtx.getTxnId()).                     transactionCtx.beginTransaction().                     queue = transactionCtx.getQueue(endpoint.getConfiguration().getQueueName()).                 }             }             final Object body = queue.poll(endpoint.getConfiguration().getPollTimeout(), TimeUnit.MILLISECONDS).             if (body != null) {                 if (body instanceof DefaultExchangeHolder) {                     DefaultExchangeHolder.unmarshal(exchange, (DefaultExchangeHolder) body).                 } else {                     exchange.getIn().setBody(body).                 }                 try {                     // process using the asynchronous routing engine                     processor.process(exchange, new AsyncCallback() {                          public void done(boolean asyncDone) {                         // noop                         }                     }).                     if (exchange.getException() != null) {                         // Rollback                         if (transactionCtx != null) {                             transactionCtx.rollbackTransaction().                         }                         getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException()).                     }                 } catch (Exception e) {                     log.error("Hzlq Exception caught: {}", e, e).                     // Rollback                     if (transactionCtx != null) {                         log.trace("Rollback transaction: {}", transactionCtx.getTxnId()).                         transactionCtx.rollbackTransaction().                     }                 }             }             // It's OK, I commit             if (exchange.getException() == null && transactionCtx != null) {                 log.trace("Commit transaction: {}", transactionCtx.getTxnId()).                 transactionCtx.commitTransaction().             }         } catch (InterruptedException e) {             if (log.isDebugEnabled()) {                 log.debug("Hzlq Consumer Interrupted: {}", e, e).             }             continue.         } catch (Throwable e) {             // Rollback             if (transactionCtx != null) {                 log.trace("Rollback transaction: {}", transactionCtx.getTxnId()).                 try {                     transactionCtx.rollbackTransaction().                 } catch (Throwable ignore) {                 }             }             getExceptionHandler().handleException("Error processing exchange", exchange, e).             try {                 Thread.sleep(endpoint.getConfiguration().getOnErrorDelay()).             } catch (InterruptedException ignore) {             }         }     } }
