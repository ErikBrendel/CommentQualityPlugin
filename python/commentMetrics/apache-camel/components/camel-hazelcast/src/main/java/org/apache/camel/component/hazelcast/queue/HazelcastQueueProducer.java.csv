commented;modifiers;parameterAmount;loc;comment;code
false;public;1;71;;public void process(Exchange exchange) throws Exception {     Map<String, Object> headers = exchange.getIn().getHeaders().     // get header parameters     Object drainToCollection = null.     if (headers.containsKey(HazelcastConstants.DRAIN_TO_COLLECTION)) {         drainToCollection = headers.get(HazelcastConstants.DRAIN_TO_COLLECTION).     }     final HazelcastOperation operation = lookupOperation(exchange).     switch(operation) {         case ADD:             this.add(exchange).             break.         case PUT:             this.put(exchange).             break.         case POLL:             this.poll(exchange).             break.         case PEEK:             this.peek(exchange).             break.         case OFFER:             this.offer(exchange).             break.         case REMOVE_VALUE:             this.remove(exchange).             break.         case REMAINING_CAPACITY:             this.remainingCapacity(exchange).             break.         case REMOVE_ALL:             this.removeAll(exchange).             break.         case REMOVE_IF:             this.removeIf(exchange).             break.         case DRAIN_TO:             this.drainTo((Collection) drainToCollection, exchange).             break.         case TAKE:             this.take(exchange).             break.         case RETAIN_ALL:             this.retainAll(exchange).             break.         default:             throw new IllegalArgumentException(String.format("The value '%s' is not allowed for parameter '%s' on the QUEUE cache.", operation, HazelcastConstants.OPERATION)).     }     // finally copy headers     HazelcastComponentHelper.copyHeaders(exchange). }
false;private;1;4;;private void add(Exchange exchange) {     Object body = exchange.getIn().getBody().     this.queue.add(body). }
false;private;1;4;;private void put(Exchange exchange) throws InterruptedException {     Object body = exchange.getIn().getBody().     this.queue.put(body). }
false;private;1;3;;private void poll(Exchange exchange) {     exchange.getOut().setBody(this.queue.poll()). }
false;private;1;3;;private void peek(Exchange exchange) {     exchange.getOut().setBody(this.queue.peek()). }
false;private;1;4;;private void offer(Exchange exchange) {     Object body = exchange.getIn().getBody().     this.queue.offer(body). }
false;private;1;8;;private void remove(Exchange exchange) {     Object body = exchange.getIn().getBody().     if (body != null) {         this.queue.remove(body).     } else {         this.queue.remove().     } }
false;private;1;3;;private void remainingCapacity(Exchange exchange) {     exchange.getOut().setBody(this.queue.remainingCapacity()). }
false;private;2;4;;private void drainTo(Collection c, Exchange exchange) {     exchange.getOut().setBody(this.queue.drainTo(c)).     exchange.getOut().setHeader(HazelcastConstants.DRAIN_TO_COLLECTION, c). }
false;private;1;4;;private void removeAll(Exchange exchange) {     Collection body = exchange.getIn().getBody(Collection.class).     this.queue.removeAll(body). }
false;private;1;4;;private void removeIf(Exchange exchange) {     Predicate filter = exchange.getIn().getBody(Predicate.class).     exchange.getOut().setBody(this.queue.removeIf(filter)). }
false;private;1;3;;private void take(Exchange exchange) throws InterruptedException {     exchange.getOut().setBody(this.queue.take()). }
false;private;1;4;;private void retainAll(Exchange exchange) {     Collection body = exchange.getIn().getBody(Collection.class).     this.queue.retainAll(body). }
