commented;modifiers;parameterAmount;loc;comment;code
false;public;4;27;;@Override public Exchange add(CamelContext camelContext, String key, Exchange oldExchange, Exchange newExchange) throws OptimisticLockingException {     if (!optimistic) {         throw new UnsupportedOperationException().     }     LOG.trace("Adding an Exchange with ID {} for key {} in an optimistic manner.", newExchange.getExchangeId(), key).     if (oldExchange == null) {         DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(newExchange, true, allowSerializedHeaders).         final DefaultExchangeHolder misbehaviorHolder = cache.putIfAbsent(key, holder).         if (misbehaviorHolder != null) {             Exchange misbehaviorEx = unmarshallExchange(camelContext, misbehaviorHolder).             LOG.error("Optimistic locking failed for exchange with key {}: IMap#putIfAbsend returned Exchange with ID {}, while it's expected no exchanges to be returned", key, misbehaviorEx != null ? misbehaviorEx.getExchangeId() : "<null>").             throw new OptimisticLockingException().         }     } else {         DefaultExchangeHolder oldHolder = DefaultExchangeHolder.marshal(oldExchange, true, allowSerializedHeaders).         DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(newExchange, true, allowSerializedHeaders).         if (!cache.replace(key, oldHolder, newHolder)) {             LOG.error("Optimistic locking failed for exchange with key {}: IMap#replace returned no Exchanges, while it's expected to replace one", key).             throw new OptimisticLockingException().         }     }     LOG.trace("Added an Exchange with ID {} for key {} in optimistic manner.", newExchange.getExchangeId(), key).     return oldExchange. }
false;public;3;17;;@Override public Exchange add(CamelContext camelContext, String key, Exchange exchange) {     if (optimistic) {         throw new UnsupportedOperationException().     }     LOG.trace("Adding an Exchange with ID {} for key {} in a thread-safe manner.", exchange.getExchangeId(), key).     Lock l = hzInstance.getLock(mapName).     try {         l.lock().         DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders).         DefaultExchangeHolder oldHolder = cache.put(key, newHolder).         return unmarshallExchange(camelContext, oldHolder).     } finally {         LOG.trace("Added an Exchange with ID {} for key {} in a thread-safe manner.", exchange.getExchangeId(), key).         l.unlock().     } }
false;public;1;13;;@Override public Set<String> scan(CamelContext camelContext) {     if (useRecovery) {         LOG.trace("Scanning for exchanges to recover in {} context", camelContext.getName()).         Set<String> scanned = Collections.unmodifiableSet(persistedCache.keySet()).         LOG.trace("Found {} keys for exchanges to recover in {} context", scanned.size(), camelContext.getName()).         return scanned.     } else {         LOG.warn("What for to run recovery scans in {} context while repository {} is running in non-recoverable aggregation repository mode?!", camelContext.getName(), mapName).         return Collections.emptySet().     } }
false;public;2;5;;@Override public Exchange recover(CamelContext camelContext, String exchangeId) {     LOG.trace("Recovering an Exchange with ID {}.", exchangeId).     return useRecovery ? unmarshallExchange(camelContext, persistedCache.get(exchangeId)) : null. }
false;public;2;4;;@Override public void setRecoveryInterval(long interval, TimeUnit timeUnit) {     this.recoveryInterval = timeUnit.toMillis(interval). }
false;public;1;4;;@Override public void setRecoveryInterval(long interval) {     this.recoveryInterval = interval. }
false;public;0;4;;@Override public long getRecoveryIntervalInMillis() {     return recoveryInterval. }
false;public;1;4;;@Override public void setUseRecovery(boolean useRecovery) {     this.useRecovery = useRecovery. }
false;public;0;4;;@Override public boolean isUseRecovery() {     return useRecovery. }
false;public;1;4;;@Override public void setDeadLetterUri(String deadLetterUri) {     this.deadLetterChannel = deadLetterUri. }
false;public;0;4;;@Override public String getDeadLetterUri() {     return deadLetterChannel. }
false;public;1;4;;@Override public void setMaximumRedeliveries(int maximumRedeliveries) {     this.maximumRedeliveries = maximumRedeliveries. }
false;public;0;4;;@Override public int getMaximumRedeliveries() {     return maximumRedeliveries. }
false;public;2;4;;@Override public Exchange get(CamelContext camelContext, String key) {     return unmarshallExchange(camelContext, cache.get(key)). }
true;public;1;7;/**  * Checks if the key in question is in the repository.  *  * @param key Object - key in question  */ ;/**  * Checks if the key in question is in the repository.  *  * @param key Object - key in question  */ public boolean containsKey(Object key) {     if (cache != null) {         return cache.containsKey(key).     } else {         return false.     } }
false;public;0;3;;public boolean isAllowSerializedHeaders() {     return allowSerializedHeaders. }
false;public;1;3;;public void setAllowSerializedHeaders(boolean allowSerializedHeaders) {     this.allowSerializedHeaders = allowSerializedHeaders. }
true;public;3;57;/**  * This method performs transactional operation on removing the {@code exchange}  * from the operational storage and moving it into the persistent one if the {@link HazelcastAggregationRepository}  * runs in recoverable mode and {@code optimistic} is false. It will act at <u>your own</u> risk otherwise.  * @param camelContext   the current CamelContext  * @param key            the correlation key  * @param exchange       the exchange to remove  */ ;/**  * This method performs transactional operation on removing the {@code exchange}  * from the operational storage and moving it into the persistent one if the {@link HazelcastAggregationRepository}  * runs in recoverable mode and {@code optimistic} is false. It will act at <u>your own</u> risk otherwise.  * @param camelContext   the current CamelContext  * @param key            the correlation key  * @param exchange       the exchange to remove  */ @Override public void remove(CamelContext camelContext, String key, Exchange exchange) {     DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders).     if (optimistic) {         LOG.trace("Removing an exchange with ID {} for key {} in an optimistic manner.", exchange.getExchangeId(), key).         if (!cache.remove(key, holder)) {             LOG.error("Optimistic locking failed for exchange with key {}: IMap#remove removed no Exchanges, while it's expected to remove one.", key).             throw new OptimisticLockingException().         }         LOG.trace("Removed an exchange with ID {} for key {} in an optimistic manner.", exchange.getExchangeId(), key).         if (useRecovery) {             LOG.trace("Putting an exchange with ID {} for key {} into a recoverable storage in an optimistic manner.", exchange.getExchangeId(), key).             persistedCache.put(exchange.getExchangeId(), holder).             LOG.trace("Put an exchange with ID {} for key {} into a recoverable storage in an optimistic manner.", exchange.getExchangeId(), key).         }     } else {         if (useRecovery) {             LOG.trace("Removing an exchange with ID {} for key {} in a thread-safe manner.", exchange.getExchangeId(), key).             // The only considerable case for transaction usage is fault tolerance:             // the transaction will be rolled back automatically (default timeout is 2 minutes)             // if no commit occurs during the timeout. So we are still consistent whether local node crashes.             TransactionOptions tOpts = new TransactionOptions().             tOpts.setTransactionType(TransactionOptions.TransactionType.ONE_PHASE).             TransactionContext tCtx = hzInstance.newTransactionContext(tOpts).             try {                 tCtx.beginTransaction().                 TransactionalMap<String, DefaultExchangeHolder> tCache = tCtx.getMap(cache.getName()).                 TransactionalMap<String, DefaultExchangeHolder> tPersistentCache = tCtx.getMap(persistedCache.getName()).                 DefaultExchangeHolder removedHolder = tCache.remove(key).                 LOG.trace("Putting an exchange with ID {} for key {} into a recoverable storage in a thread-safe manner.", exchange.getExchangeId(), key).                 tPersistentCache.put(exchange.getExchangeId(), removedHolder).                 tCtx.commitTransaction().                 LOG.trace("Removed an exchange with ID {} for key {} in a thread-safe manner.", exchange.getExchangeId(), key).                 LOG.trace("Put an exchange with ID {} for key {} into a recoverable storage in a thread-safe manner.", exchange.getExchangeId(), key).             } catch (Throwable throwable) {                 tCtx.rollbackTransaction().                 final String msg = String.format("Transaction with ID %s was rolled back for remove operation with a key %s and an Exchange ID %s.", tCtx.getTxnId(), key, exchange.getExchangeId()).                 LOG.warn(msg, throwable).                 throw new RuntimeException(msg, throwable).             }         } else {             cache.remove(key).         }     } }
false;public;2;7;;@Override public void confirm(CamelContext camelContext, String exchangeId) {     LOG.trace("Confirming an exchange with ID {}.", exchangeId).     if (useRecovery) {         persistedCache.remove(exchangeId).     } }
false;public;0;4;;@Override public Set<String> getKeys() {     return Collections.unmodifiableSet(cache.keySet()). }
true;public;0;3;/**  * @return Persistent repository {@link IMap} name.  */ ;/**  * @return Persistent repository {@link IMap} name.  */ public String getPersistentRepositoryName() {     return persistenceMapName. }
false;protected;0;21;;@Override protected void doStart() throws Exception {     if (maximumRedeliveries < 0) {         throw new IllegalArgumentException("Maximum redelivery retries must be zero or a positive integer.").     }     if (recoveryInterval < 0) {         throw new IllegalArgumentException("Recovery interval must be zero or a positive integer.").     }     StringHelper.notEmpty(mapName, "repositoryName").     if (useLocalHzInstance) {         Config cfg = new XmlConfigBuilder().build().         cfg.setProperty("hazelcast.version.check.enabled", "false").         hzInstance = Hazelcast.newHazelcastInstance(cfg).     } else {         ObjectHelper.notNull(hzInstance, "hzInstanse").     }     cache = hzInstance.getMap(mapName).     if (useRecovery) {         persistedCache = hzInstance.getMap(persistenceMapName).     } }
false;protected;0;7;;@Override protected void doStop() throws Exception {     // noop     if (useLocalHzInstance) {         hzInstance.getLifecycleService().shutdown().     } }
false;protected;2;8;;protected Exchange unmarshallExchange(CamelContext camelContext, DefaultExchangeHolder holder) {     Exchange exchange = null.     if (holder != null) {         exchange = new DefaultExchange(camelContext).         DefaultExchangeHolder.unmarshal(exchange, holder).     }     return exchange. }
