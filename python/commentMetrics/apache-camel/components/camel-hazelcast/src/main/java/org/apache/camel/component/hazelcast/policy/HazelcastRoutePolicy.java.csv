commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public CamelContext getCamelContext() {     return camelContext. }
false;public;1;4;;@Override public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public;1;5;;@Override public void onInit(Route route) {     super.onInit(route).     this.route = route. }
false;public;1;6;;@Override public void onStart(Route route) {     if (!leader.get() && shouldStopConsumer) {         stopConsumer(route).     } }
false;public,synchronized;1;4;;@Override public synchronized void onStop(Route route) {     suspendedRoutes.remove(route). }
false;public,synchronized;1;4;;@Override public synchronized void onSuspend(Route route) {     suspendedRoutes.remove(route). }
false;protected;0;14;;@Override protected void doStart() throws Exception {     // validate     StringHelper.notEmpty(lockMapName, "lockMapName", this).     StringHelper.notEmpty(lockKey, "lockKey", this).     StringHelper.notEmpty(lockValue, "lockValue", this).     executorService = getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, "HazelcastRoutePolicy").     locks = instance.getMap(lockMapName).     future = executorService.submit(this::acquireLeadership).     super.doStart(). }
false;protected;0;15;;@Override protected void doStop() throws Exception {     if (future != null) {         future.cancel(true).         future = null.     }     if (managedInstance) {         instance.shutdown().     }     getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService).     super.doStop(). }
false;protected;1;17;;// ************************************************************************* //  // ************************************************************************* protected void setLeader(boolean isLeader) {     if (isLeader && leader.compareAndSet(false, isLeader)) {         LOGGER.info("Leadership taken (map={}, key={}, val={})", lockMapName, lockKey, lockValue).         startAllStoppedConsumers().     } else {         if (!leader.getAndSet(isLeader) && isLeader) {             LOGGER.info("Leadership lost (map={}, key={} val={})", lockMapName, lockKey, lockValue).         }     } }
false;private,synchronized;1;10;;private synchronized void startConsumer(Route route) {     try {         if (suspendedRoutes.contains(route)) {             startConsumer(route.getConsumer()).             suspendedRoutes.remove(route).         }     } catch (Exception e) {         handleException(e).     } }
false;private,synchronized;1;11;;private synchronized void stopConsumer(Route route) {     try {         if (!suspendedRoutes.contains(route)) {             LOGGER.debug("Stopping consumer for {} ({})", route.getId(), route.getConsumer()).             stopConsumer(route.getConsumer()).             suspendedRoutes.add(route).         }     } catch (Exception e) {         handleException(e).     } }
false;private,synchronized;0;12;;private synchronized void startAllStoppedConsumers() {     try {         for (Route route : suspendedRoutes) {             LOGGER.debug("Starting consumer for {} ({})", route.getId(), route.getConsumer()).             startConsumer(route.getConsumer()).         }         suspendedRoutes.clear().     } catch (Exception e) {         handleException(e).     } }
false;public;0;7;;// ************************************************************************* // Getter/Setters // ************************************************************************* @ManagedAttribute(description = "The route id") public String getRouteId() {     if (route != null) {         return route.getId().     }     return null. }
false;public;0;7;;@ManagedAttribute(description = "The consumer endpoint", mask = true) public String getEndpointUrl() {     if (route != null && route.getConsumer() != null && route.getConsumer().getEndpoint() != null) {         return route.getConsumer().getEndpoint().toString().     }     return null. }
false;public;0;4;;@ManagedAttribute(description = "The lock map name") public String getLockMapName() {     return lockMapName. }
false;public;1;3;;public void setLockMapName(String lockMapName) {     this.lockMapName = lockMapName. }
false;public;0;4;;@ManagedAttribute(description = "Whether to stop consumer when starting up and failed to become master") public boolean isShouldStopConsumer() {     return shouldStopConsumer. }
false;public;1;3;;public void setShouldStopConsumer(boolean shouldStopConsumer) {     this.shouldStopConsumer = shouldStopConsumer. }
false;public;0;4;;@ManagedAttribute(description = "The lock key") public String getLockKey() {     return lockKey. }
false;public;1;3;;public void setLockKey(String lockKey) {     this.lockKey = lockKey. }
false;public;0;4;;@ManagedAttribute(description = "The lock value") public String getLockValue() {     return lockValue. }
false;public;1;3;;public void setLockValue(String lockValue) {     this.lockValue = lockValue. }
false;public;0;4;;@ManagedAttribute(description = "Timeout used by slaves to try to obtain the lock to become new master") public long getTryLockTimeout() {     return tryLockTimeout. }
false;public;1;3;;public void setTryLockTimeout(long tryLockTimeout) {     this.tryLockTimeout = tryLockTimeout. }
false;public;2;4;;public void setTryLockTimeout(long tryLockTimeout, TimeUnit tryLockTimeoutUnit) {     this.tryLockTimeout = tryLockTimeout.     this.tryLockTimeoutUnit = tryLockTimeoutUnit. }
false;public;0;4;;@ManagedAttribute(description = "Timeout unit") public TimeUnit getTryLockTimeoutUnit() {     return tryLockTimeoutUnit. }
false;public;1;3;;public void setTryLockTimeoutUnit(TimeUnit tryLockTimeoutUnit) {     this.tryLockTimeoutUnit = tryLockTimeoutUnit. }
false;public;0;4;;@ManagedAttribute(description = "Is this route the master or a slave") public boolean isLeader() {     return leader.get(). }
false;private;0;37;;// ************************************************************************* //  // ************************************************************************* private Void acquireLeadership() throws Exception {     boolean locked = false.     while (isRunAllowed()) {         try {             locked = locks.tryLock(lockKey, tryLockTimeout, tryLockTimeoutUnit).             if (locked) {                 locks.put(lockKey, lockValue).                 setLeader(true).                 // Wait almost forever                 Thread.sleep(Long.MAX_VALUE).             } else {                 LOGGER.debug("Failed to acquire lock (map={}, key={}, val={}) after {} {}", lockMapName, lockKey, lockValue, tryLockTimeout, tryLockTimeoutUnit.name()).             }         } catch (InterruptedException e) {         // ignore         } catch (Exception e) {             getExceptionHandler().handleException(e).         } finally {             if (locked) {                 locks.remove(lockKey).                 locks.unlock(lockKey).                 locked = false.             }             setLeader(false).         }     }     return null. }
