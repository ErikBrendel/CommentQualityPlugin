commented;modifiers;parameterAmount;loc;comment;code
false;public;1;105;;public void process(Exchange exchange) throws Exception {     Map<String, Object> headers = exchange.getIn().getHeaders().     // GET header parameters     Object oid = null.     Object ovalue = null.     Object ttl = null.     Object ttlUnit = null.     String query = null.     if (headers.containsKey(HazelcastConstants.OBJECT_ID)) {         oid = headers.get(HazelcastConstants.OBJECT_ID).     }     if (headers.containsKey(HazelcastConstants.OBJECT_VALUE)) {         ovalue = headers.get(HazelcastConstants.OBJECT_VALUE).     }     if (headers.containsKey(HazelcastConstants.TTL_VALUE)) {         ttl = headers.get(HazelcastConstants.TTL_VALUE).     }     if (headers.containsKey(HazelcastConstants.TTL_UNIT)) {         ttlUnit = headers.get(HazelcastConstants.TTL_UNIT).     }     if (headers.containsKey(HazelcastConstants.QUERY)) {         query = (String) headers.get(HazelcastConstants.QUERY).     }     final HazelcastOperation operation = lookupOperation(exchange).     switch(operation) {         case PUT:             if (ObjectHelper.isEmpty(ttl) && ObjectHelper.isEmpty(ttlUnit)) {                 this.put(oid, exchange).             } else {                 this.put(oid, ttl, ttlUnit, exchange).             }             break.         case PUT_IF_ABSENT:             if (ObjectHelper.isEmpty(ttl) && ObjectHelper.isEmpty(ttlUnit)) {                 this.putIfAbsent(oid, exchange).             } else {                 this.putIfAbsent(oid, ttl, ttlUnit, exchange).             }             break.         case GET:             this.get(oid, exchange).             break.         case GET_ALL:             this.getAll(oid, exchange).             break.         case GET_KEYS:             this.getKeys(exchange).             break.         case CONTAINS_KEY:             this.containsKey(oid, exchange).             break.         case CONTAINS_VALUE:             this.containsValue(exchange).             break.         case DELETE:             this.delete(oid).             break.         case UPDATE:             if (ObjectHelper.isEmpty(ovalue)) {                 this.update(oid, exchange).             } else {                 this.update(oid, ovalue, exchange).             }             break.         case QUERY:             this.query(query, exchange).             break.         case CLEAR:             this.clear(exchange).             break.         case EVICT:             this.evict(oid).             break.         case EVICT_ALL:             this.evictAll().             break.         default:             throw new IllegalArgumentException(String.format("The value '%s' is not allowed for parameter '%s' on the MAP cache.", operation, HazelcastConstants.OPERATION)).     }     // finally copy headers     HazelcastComponentHelper.copyHeaders(exchange). }
true;private;2;9;/**  * QUERY map with a sql like syntax (see http://www.hazelcast.com/)  */ ;/**  * QUERY map with a sql like syntax (see http://www.hazelcast.com/)  */ private void query(String query, Exchange exchange) {     Collection<Object> result.     if (ObjectHelper.isNotEmpty(query)) {         result = this.cache.values(new SqlPredicate(query)).     } else {         result = this.cache.values().     }     exchange.getOut().setBody(result). }
true;private;2;6;/**  * UPDATE an object in your cache (the whole object will be replaced)  */ ;/**  * UPDATE an object in your cache (the whole object will be replaced)  */ private void update(Object oid, Exchange exchange) {     Object body = exchange.getIn().getBody().     this.cache.lock(oid).     this.cache.replace(oid, body).     this.cache.unlock(oid). }
true;private;3;6;/**  * Replaces the entry for given id with a specific value in the body, only if currently mapped to a given value  */ ;/**  * Replaces the entry for given id with a specific value in the body, only if currently mapped to a given value  */ private void update(Object oid, Object ovalue, Exchange exchange) {     Object body = exchange.getIn().getBody().     this.cache.lock(oid).     this.cache.replace(oid, ovalue, body).     this.cache.unlock(oid). }
true;private;1;3;/**  * remove an object from the cache  */ ;/**  * remove an object from the cache  */ private void delete(Object oid) {     this.cache.remove(oid). }
true;private;2;3;/**  * find an object by the given id and give it back  */ ;/**  * find an object by the given id and give it back  */ private void get(Object oid, Exchange exchange) {     exchange.getOut().setBody(this.cache.get(oid)). }
true;private;2;3;/**  * GET All objects and give it back  */ ;/**  * GET All objects and give it back  */ private void getAll(Object oid, Exchange exchange) {     exchange.getOut().setBody(this.cache.getAll((Set<Object>) oid)). }
true;private;2;4;/**  * PUT a new object into the cache  */ ;/**  * PUT a new object into the cache  */ private void put(Object oid, Exchange exchange) {     Object body = exchange.getIn().getBody().     this.cache.put(oid, body). }
true;private;4;4;/**  * PUT a new object into the cache with a specific time to live  */ ;/**  * PUT a new object into the cache with a specific time to live  */ private void put(Object oid, Object ttl, Object ttlUnit, Exchange exchange) {     Object body = exchange.getIn().getBody().     this.cache.put(oid, body, (long) ttl, (TimeUnit) ttlUnit). }
true;private;2;4;/**  * if the specified key is not already associated with a value, associate it with the given value.  */ ;/**  * if the specified key is not already associated with a value, associate it with the given value.  */ private void putIfAbsent(Object oid, Exchange exchange) {     Object body = exchange.getIn().getBody().     this.cache.putIfAbsent(oid, body). }
true;private;4;4;/**  * Puts an entry into this map with a given ttl (time to live) value if the specified key is not already associated with a value.  */ ;/**  * Puts an entry into this map with a given ttl (time to live) value if the specified key is not already associated with a value.  */ private void putIfAbsent(Object oid, Object ttl, Object ttlUnit, Exchange exchange) {     Object body = exchange.getIn().getBody().     this.cache.putIfAbsent(oid, body, (long) ttl, (TimeUnit) ttlUnit). }
true;private;1;3;/**  * Clear all the entries  */ ;/**  * Clear all the entries  */ private void clear(Exchange exchange) {     this.cache.clear(). }
true;private;1;3;/**  * Eviction operation for a specific key  */ ;/**  * Eviction operation for a specific key  */ private void evict(Object oid) {     this.cache.evict(oid). }
true;private;0;3;/**  * Evict All operation  */ ;/**  * Evict All operation  */ private void evictAll() {     this.cache.evictAll(). }
true;private;2;3;/**  * Check for a specific key in the cache and return true if it exists or false otherwise  */ ;/**  * Check for a specific key in the cache and return true if it exists or false otherwise  */ private void containsKey(Object oid, Exchange exchange) {     exchange.getOut().setBody(this.cache.containsKey(oid)). }
true;private;1;4;/**  * Check for a specific value in the cache and return true if it exists or false otherwise  */ ;/**  * Check for a specific value in the cache and return true if it exists or false otherwise  */ private void containsValue(Exchange exchange) {     Object body = exchange.getIn().getBody().     exchange.getOut().setBody(this.cache.containsValue(body)). }
true;private;1;3;/**  * GET keys set of objects and give it back  */ ;/**  * GET keys set of objects and give it back  */ private void getKeys(Exchange exchange) {     exchange.getOut().setBody(this.cache.keySet()). }
