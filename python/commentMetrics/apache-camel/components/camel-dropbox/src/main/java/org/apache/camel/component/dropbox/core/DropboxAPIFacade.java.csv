commented;modifiers;parameterAmount;loc;comment;code
true;public;3;17;/**  * Put or upload a new file or an entire directory to dropbox  *  * @param localPath the file path or the dir path on the local filesystem  * @param remotePath the remote path destination on dropbox  * @param mode how a file should be saved on dropbox. in case of "add" the  *            new file will be renamed in case a file with the same name  *            already exists on dropbox. in case of "force" the file already  *            existing with the same name will be overridden.  * @return a result object reporting for each remote path the result of the  *         operation.  * @throws DropboxException  */ ;/**  * Put or upload a new file or an entire directory to dropbox  *  * @param localPath the file path or the dir path on the local filesystem  * @param remotePath the remote path destination on dropbox  * @param mode how a file should be saved on dropbox. in case of "add" the  *            new file will be renamed in case a file with the same name  *            already exists on dropbox. in case of "force" the file already  *            existing with the same name will be overridden.  * @return a result object reporting for each remote path the result of the  *         operation.  * @throws DropboxException  */ public DropboxFileUploadResult put(String localPath, String remotePath, DropboxUploadMode mode) throws DropboxException {     // in case the remote path is not specified, the remotePath = localPath     String dropboxPath = remotePath == null ? localPath : remotePath.     boolean isPresent = true.     try {         client.files().getMetadata(dropboxPath).     } catch (DbxException e) {         isPresent = false.     }     if (localPath != null) {         return putFile(localPath, mode, dropboxPath, isPresent).     } else {         return putBody(exchange, mode, dropboxPath, isPresent).     } }
false;private;4;74;;private DropboxFileUploadResult putFile(String localPath, DropboxUploadMode mode, String dropboxPath, boolean isPresent) throws DropboxException {     File fileLocalPath = new File(localPath).     // verify uploading of a single file     if (fileLocalPath.isFile()) {         // check if dropbox file exists         if (isPresent && !DropboxUploadMode.force.equals(mode)) {             throw new DropboxException(dropboxPath + " exists on dropbox. Use force upload mode to override").         }         // should be appended         if (!isPresent) {             if (dropboxPath.endsWith(DropboxConstants.DROPBOX_FILE_SEPARATOR)) {                 dropboxPath = dropboxPath + fileLocalPath.getName().             }         }         LOG.debug("Uploading: {},{}", fileLocalPath, dropboxPath).         DropboxFileUploadResult result.         try {             FileMetadata uploadedFile = putSingleFile(fileLocalPath, dropboxPath, mode).             if (uploadedFile == null) {                 result = new DropboxFileUploadResult(dropboxPath, DropboxResultCode.KO).             } else {                 result = new DropboxFileUploadResult(dropboxPath, DropboxResultCode.OK).             }         } catch (Exception ex) {             result = new DropboxFileUploadResult(dropboxPath, DropboxResultCode.KO).         }         return result.     } else if (fileLocalPath.isDirectory()) {         // verify uploading of a list of files inside a dir         LOG.debug("Uploading a dir...").         // check if dropbox folder exists         if (isPresent && !DropboxUploadMode.force.equals(mode)) {             throw new DropboxException(dropboxPath + " exists on dropbox and is not a folder!").         }         if (!dropboxPath.endsWith(DropboxConstants.DROPBOX_FILE_SEPARATOR)) {             dropboxPath = dropboxPath + DropboxConstants.DROPBOX_FILE_SEPARATOR.         }         // revert to old path         String oldDropboxPath = dropboxPath.         // list all files in a dir         Collection<File> listFiles = FileUtils.listFiles(fileLocalPath, null, true).         if (listFiles.isEmpty()) {             throw new DropboxException(localPath + " does not contain any files").         }         HashMap<String, DropboxResultCode> resultMap = new HashMap<>(listFiles.size()).         for (File file : listFiles) {             String absPath = file.getAbsolutePath().             int indexRemainingPath = localPath.length().             if (!localPath.endsWith("/")) {                 indexRemainingPath += 1.             }             String remainingPath = absPath.substring(indexRemainingPath).             dropboxPath = dropboxPath + remainingPath.             try {                 LOG.debug("Uploading: {},{}", fileLocalPath, dropboxPath).                 FileMetadata uploadedFile = putSingleFile(file, dropboxPath, mode).                 if (uploadedFile == null) {                     resultMap.put(dropboxPath, DropboxResultCode.KO).                 } else {                     resultMap.put(dropboxPath, DropboxResultCode.OK).                 }             } catch (Exception ex) {                 resultMap.put(dropboxPath, DropboxResultCode.KO).             }             dropboxPath = oldDropboxPath.         }         return new DropboxFileUploadResult(resultMap).     } else {         return null.     } }
false;private;4;34;;private DropboxFileUploadResult putBody(Exchange exchange, DropboxUploadMode mode, String dropboxPath, boolean isPresent) throws DropboxException {     String name = exchange.getIn().getHeader(HEADER_PUT_FILE_NAME, String.class).     if (name == null) {         // fallback to use CamelFileName         name = exchange.getIn().getHeader(Exchange.FILE_NAME, String.class).     }     if (name == null) {         // use message id as file name         name = exchange.getIn().getMessageId().     }     // be appended     if (!isPresent) {         if (dropboxPath.endsWith(DropboxConstants.DROPBOX_FILE_SEPARATOR)) {             dropboxPath = dropboxPath + name.         }     }     LOG.debug("Uploading message body: {}", dropboxPath).     DropboxFileUploadResult result.     try {         FileMetadata uploadedFile = putSingleBody(exchange, dropboxPath, mode).         if (uploadedFile == null) {             result = new DropboxFileUploadResult(dropboxPath, DropboxResultCode.KO).         } else {             result = new DropboxFileUploadResult(dropboxPath, DropboxResultCode.OK).         }     } catch (Exception ex) {         result = new DropboxFileUploadResult(dropboxPath, DropboxResultCode.KO).     }     return result. }
false;private;3;16;;private FileMetadata putSingleFile(File inputFile, String dropboxPath, DropboxUploadMode mode) throws Exception {     FileInputStream inputStream = new FileInputStream(inputFile).     FileMetadata uploadedFile.     try {         WriteMode uploadMode.         if (mode == DropboxUploadMode.force) {             uploadMode = WriteMode.OVERWRITE.         } else {             uploadMode = WriteMode.ADD.         }         uploadedFile = client.files().uploadBuilder(dropboxPath).withMode(uploadMode).uploadAndFinish(inputStream, inputFile.length()).         return uploadedFile.     } finally {         IOHelper.close(inputStream).     } }
false;private;3;17;;private FileMetadata putSingleBody(Exchange exchange, String dropboxPath, DropboxUploadMode mode) throws Exception {     byte[] data = exchange.getIn().getMandatoryBody(byte[].class).     InputStream is = new ByteArrayInputStream(data).     try {         FileMetadata uploadedFile.         WriteMode uploadMode.         if (mode == DropboxUploadMode.force) {             uploadMode = WriteMode.OVERWRITE.         } else {             uploadMode = WriteMode.ADD.         }         uploadedFile = client.files().uploadBuilder(dropboxPath).withMode(uploadMode).uploadAndFinish(is, data.length).         return uploadedFile.     } finally {         IOHelper.close(is).     } }
true;public;2;23;/**  * Search inside a remote path including its sub directories. The query  * param can be null.  *  * @param remotePath the remote path where starting the search from  * @param query a space-separated list of substrings to search for. A file  *            matches only if it contains all the substrings  * @return a result object containing all the files found.  * @throws DropboxException  */ ;/**  * Search inside a remote path including its sub directories. The query  * param can be null.  *  * @param remotePath the remote path where starting the search from  * @param query a space-separated list of substrings to search for. A file  *            matches only if it contains all the substrings  * @return a result object containing all the files found.  * @throws DropboxException  */ public DropboxSearchResult search(String remotePath, String query) throws DropboxException {     SearchResult listing.     List<SearchMatch> searchMatches.     if (query == null) {         LOG.debug("Search no query").         try {             listing = client.files().search(remotePath, null).             searchMatches = listing.getMatches().             return new DropboxSearchResult(searchMatches).         } catch (DbxException e) {             throw new DropboxException(remotePath + " does not exist or cannot obtain metadata", e).         }     } else {         LOG.debug("Search by query: {}", query).         try {             listing = client.files().search(remotePath, query).             searchMatches = listing.getMatches().             return new DropboxSearchResult(searchMatches).         } catch (DbxException e) {             throw new DropboxException(remotePath + " does not exist or cannot obtain metadata", e).         }     } }
true;public;1;8;/**  * Delete every files and subdirectories inside the remote directory. In  * case the remotePath is a file, delete the file.  *  * @param remotePath the remote location to delete  * @return a result object with the result of the delete operation.  * @throws DropboxException  */ ;/**  * Delete every files and subdirectories inside the remote directory. In  * case the remotePath is a file, delete the file.  *  * @param remotePath the remote location to delete  * @return a result object with the result of the delete operation.  * @throws DropboxException  */ public DropboxDelResult del(String remotePath) throws DropboxException {     try {         client.files().deleteV2(remotePath).     } catch (DbxException e) {         throw new DropboxException(remotePath + " does not exist or cannot obtain metadata", e).     }     return new DropboxDelResult(remotePath). }
true;public;2;8;/**  * Rename a remote path with the new path location.  *  * @param remotePath the existing remote path to be renamed  * @param newRemotePath the new remote path substituting the old one  * @return a result object with the result of the move operation.  * @throws DropboxException  */ ;/**  * Rename a remote path with the new path location.  *  * @param remotePath the existing remote path to be renamed  * @param newRemotePath the new remote path substituting the old one  * @return a result object with the result of the move operation.  * @throws DropboxException  */ public DropboxMoveResult move(String remotePath, String newRemotePath) throws DropboxException {     try {         client.files().moveV2(remotePath, newRemotePath).         return new DropboxMoveResult(remotePath, newRemotePath).     } catch (DbxException e) {         throw new DropboxException(remotePath + " does not exist or cannot obtain metadata", e).     } }
true;public;1;3;/**  * Get the content of every file inside the remote path.  *  * @param remotePath the remote path where to download from  * @return a result object with the content (ByteArrayOutputStream) of every  *         files inside the remote path.  * @throws DropboxException  */ ;/**  * Get the content of every file inside the remote path.  *  * @param remotePath the remote path where to download from  * @return a result object with the content (ByteArrayOutputStream) of every  *         files inside the remote path.  * @throws DropboxException  */ public DropboxFileDownloadResult get(String remotePath) throws DropboxException {     return new DropboxFileDownloadResult(downloadFilesInFolder(remotePath)). }
false;private;1;25;;private Map<String, Object> downloadFilesInFolder(String path) throws DropboxException {     try {         ListFolderResult folderResult = client.files().listFolder(path.equals("/") ? "" : path).         Map<String, Object> returnMap = new LinkedHashMap<>().         for (Metadata entry : folderResult.getEntries()) {             returnMap.put(entry.getPathDisplay(), downloadSingleFile(entry.getPathDisplay()).getValue()).         }         return returnMap.     } catch (ListFolderErrorException e) {         try {             DbxDownloader<FileMetadata> listing = client.files().download(path).             if (listing == null) {                 return Collections.emptyMap().             } else {                 LOG.debug("downloading a single file...").                 Map.Entry<String, Object> entry = downloadSingleFile(path).                 return Collections.singletonMap(entry.getKey(), entry.getValue()).             }         } catch (DbxException dbxException) {             throw new DropboxException(dbxException).         }     } catch (DbxException e) {         throw new DropboxException(e).     } }
false;private;1;17;;private Map.Entry<String, Object> downloadSingleFile(String path) throws DropboxException {     try {         OutputStreamBuilder target = OutputStreamBuilder.withExchange(exchange).         DbxDownloader<FileMetadata> downloadedFile = client.files().download(path).         if (downloadedFile != null) {             downloadedFile.download(target).             LOG.debug("downloaded path={}", path).             return new AbstractMap.SimpleEntry<>(path, target.build()).         } else {             return null.         }     } catch (DbxException e) {         throw new DropboxException(path + " does not exist or cannot obtain metadata", e).     } catch (IOException e) {         throw new DropboxException(path + " cannot obtain a stream", e).     } }
