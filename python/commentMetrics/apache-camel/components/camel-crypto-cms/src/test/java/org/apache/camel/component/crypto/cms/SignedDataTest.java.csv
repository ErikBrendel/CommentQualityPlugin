commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void setUpProvider() {     Security.addProvider(new BouncyCastleProvider()). }
false;public;0;4;;@Test public void testWithCertificatesIncluded() throws Exception {     signAndVerify("Test Message", "system.jks", "SHA1withRSA", "rsa", true, true). }
false;public;0;4;;@Test public void testWithCertificatesIncludedNoSignedAttributes() throws Exception {     signAndVerify("Test Message", "system.jks", "SHA1withRSA", "rsa", true, true). }
false;public;0;4;;@Test public void testWithCertificatesIncludedTimestampSignedAttribute() throws Exception {     signAndVerify("Test Message", "system.jks", "SHA1withRSA", "rsa", true, true). }
false;public;0;4;;@Test public void testWithCertificatesIncludedCertificateSignedAttribute() throws Exception {     signAndVerify("Test Message", "system.jks", "SHA1withRSA", "rsa", true, true). }
false;public;0;4;;@Test public void testWithoutCertificatesIncludedAndDigestAlgorithmSHA1andSignatureAlgorithm() throws Exception {     signAndVerify("Test Message", "system.jks", "SHA1withDSA", "dsa", true, false). }
false;private;6;8;;private void signAndVerify(String message, String keystoreName, String signatureAlgorithm, String alias, boolean includeContent, boolean includeCertificates) throws UnsupportedEncodingException, Exception {     byte[] signed = sign(message, keystoreName, signatureAlgorithm, includeContent, includeCertificates, alias).     byte[] result = verify(keystoreName, alias, signed, false).     Assert.assertEquals(message, new String(result, "UTF-8")). }
false;private;6;35;;private byte[] sign(String message, String keystoreName, String signatureAlgorithm, boolean includeContent, boolean includeCertificates, String... aliases) throws UnsupportedEncodingException, Exception {     KeyStoreParameters keystore = KeystoreUtil.getKeyStoreParameters(keystoreName).     List<SignerInfo> signers = new ArrayList<>(aliases.length).     for (String alias : aliases) {         DefaultSignerInfo signerInfo = new DefaultSignerInfo().         // without         signerInfo.setIncludeCertificates(includeCertificates).         // certificates,         // optional         // default         // value is         // true         // mandatory         signerInfo.setSignatureAlgorithm(signatureAlgorithm).         signerInfo.setPrivateKeyAlias(alias).         signerInfo.setKeyStoreParameters(keystore).         signers.add(signerInfo).     }     SignedDataCreatorConfiguration config = new SignedDataCreatorConfiguration(new DefaultCamelContext()).     for (SignerInfo signer : signers) {         config.setSigner(signer).     }     // config.setBlockSize(blockSize). // optional     // optional default value is     config.setIncludeContent(includeContent).     // true     config.init().     SignedDataCreator signer = new SignedDataCreator(config).     Exchange exchange = ExchangeUtil.getExchange().     exchange.getIn().setBody(new ByteArrayInputStream(message.getBytes("UTF-8"))).     signer.process(exchange).     byte[] signed = (byte[]) exchange.getOut().getBody().     return signed. }
false;private;4;12;;private byte[] verify(String keystoreName, String alias, byte[] signed, boolean base64) throws Exception, UnsupportedEncodingException {     DefaultSignedDataVerifierConfiguration verifierConf = getCryptoCmsSignedDataVerifierConf(keystoreName, Collections.singletonList(alias), base64).     SignedDataVerifier verifier = new SignedDataVerifier(verifierConf).     InputStream is = new BufferedInputStream(new ByteArrayInputStream(signed)).     Exchange exchangeVeri = ExchangeUtil.getExchange().     exchangeVeri.getIn().setBody(is).     verifier.process(exchangeVeri).     byte[] result = (byte[]) exchangeVeri.getOut().getBody().     return result. }
false;;3;20;;DefaultSignedDataVerifierConfiguration getCryptoCmsSignedDataVerifierConf(String keystoreName, Collection<String> aliases, boolean base64) throws GeneralSecurityException, IOException, KeyStoreException, NoSuchAlgorithmException, CertificateException {     KeyStoreParameters keystorePas = KeystoreUtil.getKeyStoreParameters(keystoreName).     KeyStore keystore = keystorePas.createKeyStore().     KeyStore verifierKeystore = KeyStore.getInstance("JCEKS").     verifierKeystore.load(null, "".toCharArray()).     // add only verifier certs     for (String alias : aliases) {         Certificate verifierCert = keystore.getCertificate(alias).         if (verifierCert != null) {             verifierKeystore.setCertificateEntry(alias, verifierCert).         }     }     DefaultSignedDataVerifierConfiguration verifierConf = new DefaultSignedDataVerifierConfiguration().     verifierConf.setKeyStore(verifierKeystore).     verifierConf.setFromBase64(base64).     return verifierConf. }
false;public;0;4;;@Test public void signWithTwoAliases() throws Exception {     sign("", "system.jks", "SHA1withRSA", true, false, "rsa", "rsa2"). }
false;public;0;4;;@Test(expected = CryptoCmsNoKeyOrCertificateForAliasException.class) public void signWithTwoAliasesOneWithNoPrivateKeyInKeystore() throws Exception {     sign("Test Message", "system.jks", "SHA1withDSA", true, false, "dsa", "noEntry"). }
false;public;0;5;;@Test(expected = CryptoCmsNoKeyOrCertificateForAliasException.class) public void signWrongAlias() throws Exception {     sign("Test Message", "system.jks", "SHA1withDSA", true, false, "wrong"). }
false;public;0;4;;@Test public void signEmptyContent() throws Exception {     sign("", "system.jks", "SHA1withDSA", true, false, "dsa"). }
false;public;0;4;;@Test(expected = CryptoCmsInvalidKeyException.class) public void signSignatureAlgorithmNotCorrespondingToPrivateKey() throws Exception {     sign("testMessage", "system.jks", "MD5withRSA", true, false, "dsa"). }
false;public;0;4;;@Test(expected = IllegalArgumentException.class) public void signWrongSignatureAlgorithm() throws Exception {     sign("testMessage", "system.jks", "wrongRSA", true, false, "rsa"). }
false;public;0;16;;@Test public void verifySignedDataWithoutSignedContent() throws Exception {     InputStream is = SignedDataTest.class.getClassLoader().getResourceAsStream("detached_signature.binary").     ByteArrayOutputStream os = new ByteArrayOutputStream().     IOHelper.copy(is, os).     byte[] signed = os.toByteArray().     try {         verify("system.jks", "rsa", signed, false).     } catch (CryptoCmsException e) {         String message = e.getMessage().         assertEquals("PKCS7/CMS signature validation not possible: The content for which the hash-value must be calculated is missing in the PKCS7/CMS signed data instance. " + "Please check the configuration of the sender of the PKCS7/CMS signature.", message).         return.     }     fail("Exception expected"). }
false;public;0;11;;@Test(expected = CryptoCmsNoCertificateForSignerInfosException.class) public void verifyNoVerifierCerts() throws Exception {     byte[] signed = sign("Test Message", "system.jks", "SHA1withRSA", true, true, "rsa").     // wrongAlias means     verify("system.jks", "wrongAlias", signed, false). // that no // certificates are // added to the // verifier keystore }
false;public;0;5;;@Test(expected = CryptoCmsFormatException.class) public void verifyWrongFormat() throws Exception {     verify("system.jks", "rsa", "test".getBytes(), false). }
false;public;0;5;;@Test(expected = CryptoCmsFormatException.class) public void verifyWrongFormatInHeader() throws Exception {     verifyContentWithSeparateSignature(new ByteArrayInputStream("ABCDEFG1ABCDEFG1ABCDEFG1".getBytes()), new ByteArrayInputStream("ABCDEFG1ABCDEFG1ABCDEFG1".getBytes()), "rsa"). }
false;public;0;10;;@Test public void verifyContentWithSeparateSignature() throws Exception {     InputStream message = new ByteArrayInputStream("Test Message".getBytes(StandardCharsets.UTF_8)).     InputStream signature = this.getClass().getClassLoader().getResourceAsStream("detached_signature.binary").     assertNotNull(signature).     verifyContentWithSeparateSignature(message, signature, "rsa"). }
false;public;0;11;;@Test(expected = CryptoCmsSignatureInvalidContentHashException.class) public void verifyContentWithSeparateSignatureWrongContent() throws Exception {     InputStream message = new ByteArrayInputStream("Wrong Message".getBytes()).     InputStream signature = this.getClass().getClassLoader().getResourceAsStream("detached_signature.binary").     assertNotNull(signature).     verifyContentWithSeparateSignature(message, signature, "rsa"). }
false;private;3;10;;private void verifyContentWithSeparateSignature(InputStream content, InputStream signature, String alias) throws Exception {     DefaultSignedDataVerifierConfiguration verifierConf = getCryptoCmsSignedDataVerifierConf("system.jks", Collections.singletonList(alias), Boolean.FALSE).     SignedDataVerifier verifier = new SignedDataVerifierFromHeader(verifierConf).     Exchange exchange = ExchangeUtil.getExchange().     exchange.getIn().setBody(content).     exchange.getIn().setHeader(CryptoCmsConstants.CAMEL_CRYPTO_CMS_SIGNED_DATA, signature).     verifier.process(exchange). }
false;public;0;4;;@Test public void verifyWithServeralAliases() throws Exception {     verifyDetachedSignatureWithKeystore("system.jks", "rsa", "rsa2"). }
false;public;0;4;;@Test public void verifyWithServeralAliasesOneWithNoEntryInKeystore() throws Exception {     verifyDetachedSignatureWithKeystore("system.jks", "noEntry", "rsa"). }
false;public;0;4;;@Test(expected = CryptoCmsException.class) public void verifyWithEmptyAlias() throws Exception {     verifyDetachedSignatureWithKeystore("system.jks", ""). }
false;public;0;4;;@Test(expected = CryptoCmsNoCertificateForSignerInfoException.class) public void verifyDetachedSignatureWithAliasNotFittingToSigner() throws Exception {     verifyDetachedSignatureWithKeystore("system.jks", "rsa2"). }
false;public;0;4;;@Test(expected = CryptoCmsNoCertificateForSignerInfosException.class) public void verifyDetachedSignatureWithAliasNotFittingToSignerWithVerifiyAllSignaturesFalse() throws Exception {     verifyDetachedSignatureWithKeystore("system.jks", Boolean.FALSE, "rsa2"). }
false;private;2;3;;private void verifyDetachedSignatureWithKeystore(String keystoreName, String... aliases) throws FileNotFoundException, CryptoCmsException, Exception {     verifyDetachedSignatureWithKeystore(keystoreName, Boolean.TRUE, aliases). }
false;private;3;22;;private void verifyDetachedSignatureWithKeystore(String keystoreName, Boolean verifyAllSignatures, String... aliases) throws FileNotFoundException, CryptoCmsException, Exception {     InputStream message = new ByteArrayInputStream("Test Message".getBytes(StandardCharsets.UTF_8)).     assertNotNull(message).     DefaultSignedDataVerifierConfiguration verifierConf = getCryptoCmsSignedDataVerifierConf(keystoreName, Arrays.asList(aliases), Boolean.FALSE).     verifierConf.setVerifySignaturesOfAllSigners(verifyAllSignatures).     verifierConf.setSignedDataHeaderBase64(Boolean.TRUE).     SignedDataVerifier verifier = new SignedDataVerifierFromHeader(verifierConf).     InputStream signature = this.getClass().getClassLoader().getResourceAsStream("detached_signature.base64").     assertNotNull(signature).     Exchange exchange = ExchangeUtil.getExchange().     exchange.getIn().setBody(message).     exchange.getIn().setHeader(CryptoCmsConstants.CAMEL_CRYPTO_CMS_SIGNED_DATA, signature).     verifier.process(exchange). }
false;public;0;40;;@Test public void signatureAndContentSeparatedExplicitMode() throws Exception {     String keystoreName = "system.jks".     String alias = "rsa".     KeyStoreParameters keystore = KeystoreUtil.getKeyStoreParameters(keystoreName).     DefaultSignerInfo signerInfo = new DefaultSignerInfo().     // without certificates,     signerInfo.setIncludeCertificates(false).     // optional default value is     // true     // mandatory     signerInfo.setSignatureAlgorithm("SHA1withRSA").     signerInfo.setPrivateKeyAlias(alias).     signerInfo.setKeyStoreParameters(keystore).     SignedDataCreatorConfiguration config = new SignedDataCreatorConfiguration(new DefaultCamelContext()).     config.setSigner(signerInfo).     // optional default value is true     config.setIncludeContent(false).     config.setToBase64(Boolean.TRUE).     config.init().     SignedDataCreator signer = new SignedDataCreator(config).     String message = "Test Message".     Exchange exchange = ExchangeUtil.getExchange().     exchange.getIn().setBody(new ByteArrayInputStream(message.getBytes(StandardCharsets.UTF_8))).     signer.process(exchange).     byte[] signature = exchange.getOut().getHeader(CryptoCmsConstants.CAMEL_CRYPTO_CMS_SIGNED_DATA, byte[].class).     DefaultSignedDataVerifierConfiguration verifierConf = getCryptoCmsSignedDataVerifierConf(keystoreName, Collections.singleton(alias), Boolean.FALSE).     verifierConf.setSignedDataHeaderBase64(Boolean.TRUE).     SignedDataVerifier verifier = new SignedDataVerifierFromHeader(verifierConf).     exchange = ExchangeUtil.getExchange().     exchange.getIn().setBody(new ByteArrayInputStream(message.getBytes(StandardCharsets.UTF_8))).     exchange.getIn().setHeader(CryptoCmsConstants.CAMEL_CRYPTO_CMS_SIGNED_DATA, new ByteArrayInputStream(signature)).     verifier.process(exchange). }
false;private;1;4;;private void signAndVerifyByDSASigAlgorithm(String sigAlgorithm) throws UnsupportedEncodingException, Exception {     // digest algorithm is calculated     signAndVerify("Test Message", "system.jks", sigAlgorithm, "dsa", true, false). }
false;private;1;4;;private void signAndVerifyByRSASigAlgorithm(String sigAlgorithm) throws UnsupportedEncodingException, Exception {     // digest algorithm is calculated     signAndVerify("Test Message", "system.jks", sigAlgorithm, "rsa", true, false). }
false;public;0;4;;@Test public void testSigAlgorithmSHADSA() throws Exception {     signAndVerifyByDSASigAlgorithm("SHA1withDSA"). }
true;public;0;4;// SHA224withDSA ;// SHA224withDSA @Test public void testSigAlgorithmSHA224withDSA() throws Exception {     signAndVerifyByDSASigAlgorithm("SHA224withDSA"). }
true;public;0;4;// SHA256withDSA ;// SHA256withDSA @Test public void testSigAlgorithmSHA256withDSA() throws Exception {     signAndVerifyByDSASigAlgorithm("SHA256withDSA"). }
true;public;0;4;// SHA1withECDSA // ECSDSA keys not supported ;// SHA1withECDSA // ECSDSA keys not supported @Test(expected = CryptoCmsException.class) public void testSigAlgorithmSHA1withECDSA() throws Exception {     signAndVerifyByDSASigAlgorithm("SHA1withECDSA"). }
true;public;0;4;// MD2withRSA ;// MD2withRSA @Test public void testSigAlgorithmMD2withRSA() throws Exception {     signAndVerifyByRSASigAlgorithm("MD2withRSA"). }
true;public;0;4;// MD2withRSA ;// MD5/RSA // MD2withRSA @Test public void testSigAlgorithmMD5withRSA() throws Exception {     signAndVerifyByRSASigAlgorithm("MD5withRSA"). }
true;public;0;4;// SHA/RSA ;// SHA/RSA @Test public void testSigAlgorithmSHAwithRSA() throws Exception {     // SHA/RSA").     signAndVerifyByRSASigAlgorithm("SHA1withRSA"). }
true;public;0;4;// SHA224/RSA ;// SHA224/RSA @Test public void testSigAlgorithmSHA224withRSA() throws Exception {     signAndVerifyByRSASigAlgorithm("SHA224withRSA"). }
true;public;0;4;// SHA256/RSA ;// SHA256/RSA @Test public void testSigAlgorithmSHA256withRSA() throws Exception {     signAndVerifyByRSASigAlgorithm("SHA256withRSA"). }
true;public;0;4;// SHA384/RSA ;// SHA384/RSA @Test public void testSigAlgorithmSHA384withRSA() throws Exception {     signAndVerifyByRSASigAlgorithm("SHA384withRSA"). }
true;public;0;4;// SHA512/RSA ;// SHA512/RSA @Test public void testSigAlgorithmSHA512withRSA() throws Exception {     signAndVerifyByRSASigAlgorithm("SHA512withRSA"). }
true;public;0;4;// RIPEMD160/RSA ;// RIPEMD160/RSA @Test public void testSigAlgorithmRIPEMD160withRSA() throws Exception {     signAndVerifyByRSASigAlgorithm("RIPEMD160withRSA"). }
true;public;0;4;// RIPEMD128/RSA ;// RIPEMD128/RSA @Test public void testSigAlgorithmRIPEMD128withRSA() throws Exception {     signAndVerifyByRSASigAlgorithm("RIPEMD128withRSA"). }
true;public;0;4;// RIPEMD256/RSA ;// RIPEMD256/RSA @Test public void testSigAlgorithmRIPEMD256withRSA() throws Exception {     signAndVerifyByRSASigAlgorithm("RIPEMD256withRSA"). }
false;public;0;4;;@Test(expected = CryptoCmsInvalidKeyException.class) public void testSigAlgorithmDoesnotFitToDSAPrivateKey() throws Exception {     signAndVerifyByDSASigAlgorithm("RIPEMD128withRSA"). }
false;public;0;4;;@Test(expected = CryptoCmsInvalidKeyException.class) public void testSigAlgorithmDoesnotFitToRSAPrivateKey() throws Exception {     signAndVerifyByRSASigAlgorithm("SHA224withDSA"). }
