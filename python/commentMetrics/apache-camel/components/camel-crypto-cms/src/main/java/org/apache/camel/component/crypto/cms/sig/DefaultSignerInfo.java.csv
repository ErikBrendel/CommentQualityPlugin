commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Password of the private key. If not set then the password set in the  * parameter 'keystoreParameters' is used.  */ ;/**  * Password of the private key. If not set then the password set in the  * parameter 'keystoreParameters' is used.  */ public void setPassword(char[] password) {     this.password = password. }
false;protected;1;14;;protected char[] getPassword(Exchange exchange) throws CryptoCmsException {     if (password != null) {         return password.     }     String pw = null.     if (getKeyStoreParameters() != null) {         pw = getKeyStoreParameters().getPassword().     }     if (pw == null) {         throw new CryptoCmsException("No password for accessing the private key from the keystore found for the singer infor " + this).     }     return pw.toCharArray(). }
false;protected;1;6;;protected String getPrivateKeyAlias(Exchange exchange) throws CryptoCmsException {     if (privateKeyAlias == null) {         throw new CryptoCmsException("No alias defined for signer info " + this).     }     return privateKeyAlias. }
true;public;1;3;/**  * Alias of the private key entry in the keystore which is used for signing.  */ ;/**  * Alias of the private key entry in the keystore which is used for signing.  */ public void setPrivateKeyAlias(String privateKeyAlias) {     this.privateKeyAlias = privateKeyAlias. }
true;public;1;3;/**  * Signature algorithm. The default algorithm is "SHA256withRSA".  * <p>  * Attention, the signature algorithm must fit to the signer private key.  */ ;/**  * Signature algorithm. The default algorithm is "SHA256withRSA".  * <p>  * Attention, the signature algorithm must fit to the signer private key.  */ public void setSignatureAlgorithm(String signatureAlgorithm) {     this.signatureAlgorithm = signatureAlgorithm. }
true;public;1;3;/**  * If <tt>true</tt> then the certificate chain corresponding to the alias of  * the private key is added to the certificate list of the Signed Data  * instance.  */ ;/**  * If <tt>true</tt> then the certificate chain corresponding to the alias of  * the private key is added to the certificate list of the Signed Data  * instance.  */ public void setIncludeCertificates(boolean includeCertificates) {     this.includeCertificates = includeCertificates. }
false;public;1;4;;@Override public String getSignatureAlgorithm(Exchange exchange) throws CryptoCmsException {     return signatureAlgorithm. }
false;public;1;13;;@Override public PrivateKey getPrivateKey(Exchange exchange) throws CryptoCmsException {     String alias = getPrivateKeyAlias(exchange).     try {         Key key = getKeyStore().getKey(alias, getPassword(exchange)).         if (key instanceof PrivateKey) {             return (PrivateKey) key.         }     } catch (UnrecoverableKeyException | KeyStoreException | NoSuchAlgorithmException e) {         throw new CryptoCmsException("Problem occured during accessing the private key for the alias '" + alias + "' in the keystore of signer " + this).     }     throw new CryptoCmsNoKeyOrCertificateForAliasException("No private key found  for the alias '" + alias + "' in the keystore of signer " + this). }
false;public;1;15;;@Override public X509Certificate getCertificate(Exchange exchange) throws CryptoCmsException {     String alias = getPrivateKeyAlias(exchange).     Certificate cert.     try {         cert = getKeyStore().getCertificate(alias).     } catch (KeyStoreException e) {         throw new CryptoCmsException("Problem during accessing the certificate for the alias '" + alias + "' in the signer " + this, e).     }     if (cert instanceof X509Certificate) {         return (X509Certificate) cert.     }     throw new CryptoCmsNoKeyOrCertificateForAliasException("No X.509 certificate found for alias '" + alias + "' in the keystore of signer " + this). }
false;public;1;19;;@Override public Certificate[] getCertificateChain(Exchange exchange) throws CryptoCmsException {     if (includeCertificates) {         String alias = getPrivateKeyAlias(exchange).         Certificate[] certs.         try {             certs = getKeyStore().getCertificateChain(alias).         } catch (KeyStoreException e) {             throw new CryptoCmsException("Problem during accessing the certificate chain for the alias '" + alias + "' in the keystore of signer " + this, e).         }         if (certs == null) {             return new Certificate[0].         } else {             return certs.         }     } else {         return new Certificate[0].     } }
true;public;1;3;/**  * Signed attributes of the Signed Data instance. By default contentType,  * signingTime, messageDigest, and id-aa-CMSAlgorithmProtection are set.  */ ;/**  * Signed attributes of the Signed Data instance. By default contentType,  * signingTime, messageDigest, and id-aa-CMSAlgorithmProtection are set.  */ public void setSignedAttributeGenerator(CMSAttributeTableGenerator signedAttributeGenerator) {     this.signedAttributeGenerator = signedAttributeGenerator. }
true;public;1;3;/**  * Unsigned attributes of the Signed Data instance. By default no unsigned  * attribute is set.  */ ;/**  * Unsigned attributes of the Signed Data instance. By default no unsigned  * attribute is set.  */ public void setUnsignedAttributeGenerator(CMSAttributeTableGenerator unsignedAttributeGenerator) {     this.unsignedAttributeGenerator = unsignedAttributeGenerator. }
false;public;1;4;;@Override public CMSAttributeTableGenerator getSignedAttributeGenerator(Exchange exchange) throws CryptoCmsException {     return signedAttributeGenerator. }
false;public;1;4;;@Override public CMSAttributeTableGenerator getUnsignedAttributeGenerator(Exchange exchange) throws CryptoCmsException {     return unsignedAttributeGenerator. }
false;public;0;3;;public String toString() {     return "private key alias=" + privateKeyAlias + ", signature algorithm=" + signatureAlgorithm + ", isIncludeCertificates=" + includeCertificates. }
