commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;11;;private static boolean isLimitedEncryptionStrength() {     // limited encryption strength     boolean limitedEncryptionStrength.     try {         limitedEncryptionStrength = Cipher.getMaxAllowedKeyLength("AES") < 256.     } catch (NoSuchAlgorithmException e) {         // should never occur         throw new IllegalStateException(e).     }     return limitedEncryptionStrength. }
false;public;0;3;;public List<RecipientInfo> getRecipient() {     return recipient. }
false;public;1;3;;public void setRecipient(RecipientInfo recipient) {     this.recipient.add(recipient). }
true;public;1;18;// for multi values ;// for multi values public void setRecipient(List<?> recipients) {     if (recipients == null) {         return.     }     for (Object recipientOb : recipients) {         if (recipientOb instanceof String) {             String recipientName = (String) recipientOb.             String valueNoHash = recipientName.replaceAll("#", "").             if (getContext() != null && recipientName != null) {                 RecipientInfo recipient = getContext().getRegistry().lookupByNameAndType(valueNoHash, RecipientInfo.class).                 if (recipient != null) {                     setRecipient(recipient).                 }             }         }     } }
false;public;0;3;;public String getContentEncryptionAlgorithm() {     return contentEncryptionAlgorithm. }
true;public;1;3;/**  * Encryption algorithm, for example "DESede/CBC/PKCS5Padding". Further  * possible values: DESede/CBC/PKCS5Padding, AES/CBC/PKCS5Padding,  * Camellia/CBC/PKCS5Padding, CAST5/CBC/PKCS5Padding.  */ ;/**  * Encryption algorithm, for example "DESede/CBC/PKCS5Padding". Further  * possible values: DESede/CBC/PKCS5Padding, AES/CBC/PKCS5Padding,  * Camellia/CBC/PKCS5Padding, CAST5/CBC/PKCS5Padding.  */ public void setContentEncryptionAlgorithm(String contentEncryptionAlgorithm) {     this.contentEncryptionAlgorithm = contentEncryptionAlgorithm. }
false;public;0;3;;public int getSecretKeyLength() {     return secretKeyLength. }
true;public;1;3;/**  * Key length for the secret symmetric key used for the content encryption.  * Only used if the specified content-encryption algorithm allows keys of  * different sizes. If contentEncryptionAlgorithm=AES/CBC/PKCS5Padding or  * Camellia/CBC/PKCS5Padding then 128. if  * contentEncryptionAlgorithm=DESede/CBC/PKCS5Padding then 192, 128. if  * strong encryption is enabled then for AES/CBC/PKCS5Padding and  * Camellia/CBC/PKCS5Padding also the key lengths 192 and 256 are possible.  */ ;/**  * Key length for the secret symmetric key used for the content encryption.  * Only used if the specified content-encryption algorithm allows keys of  * different sizes. If contentEncryptionAlgorithm=AES/CBC/PKCS5Padding or  * Camellia/CBC/PKCS5Padding then 128. if  * contentEncryptionAlgorithm=DESede/CBC/PKCS5Padding then 192, 128. if  * strong encryption is enabled then for AES/CBC/PKCS5Padding and  * Camellia/CBC/PKCS5Padding also the key lengths 192 and 256 are possible.  */ public void setSecretKeyLength(int secretKeyLength) {     this.secretKeyLength = secretKeyLength. }
false;public;0;3;;public AttributesGeneratorProvider getUnprotectedAttributesGeneratorProvider() {     return unprotectedAttributesGeneratorProvider. }
true;public;1;3;/**  * Provider of the generator for the unprotected attributes. The default  * value is <code>null</code> which means no unprotected attribute is added  * to the Enveloped Data object. See  * https://tools.ietf.org/html/rfc5652#section-6.1.  */ ;/**  * Provider of the generator for the unprotected attributes. The default  * value is <code>null</code> which means no unprotected attribute is added  * to the Enveloped Data object. See  * https://tools.ietf.org/html/rfc5652#section-6.1.  */ public void setUnprotectedAttributesGeneratorProvider(AttributesGeneratorProvider unprotectedAttributeTableGeneratorProvider) {     this.unprotectedAttributesGeneratorProvider = unprotectedAttributeTableGeneratorProvider. }
false;public;0;3;;public OriginatorInformationProvider getOriginatorInformationProvider() {     return originatorInformationProvider. }
true;public;1;3;/**  * Provider for the originator info. See  * https://tools.ietf.org/html/rfc5652#section-6.1. The default value is  * <code>null</code>.  */ ;/**  * Provider for the originator info. See  * https://tools.ietf.org/html/rfc5652#section-6.1. The default value is  * <code>null</code>.  */ public void setOriginatorInformationProvider(OriginatorInformationProvider originatorInformationProvider) {     this.originatorInformationProvider = originatorInformationProvider. }
false;public;0;8;;public void init() throws CryptoCmsException {     if (recipient.size() == 0) {         logErrorAndThrow(LOG, "No recipient configured.").     }     checkEncryptionAlgorithmAndSecretKeyLength().     calcualteAlgorithmIdWithKeyLength(). }
false;private;0;9;;private void checkEncryptionAlgorithmAndSecretKeyLength() throws CryptoCmsException {     if (contentEncryptionAlgorithm == null) {         logErrorAndThrow(LOG, "Content encryption algorithm is null").     } else if (!SUPPORTED_ENCRYPTION_ALGORITHMS.keySet().contains(contentEncryptionAlgorithm)) {         logErrorAndThrow(LOG, "Content encryption algorithm " + contentEncryptionAlgorithm + " not supported").     } else if (!SUPPORTED_ENCRYPTION_ALGORITHMS.get(contentEncryptionAlgorithm).contains(secretKeyLength)) {         logErrorAndThrow(LOG, "Content encryption algorithm " + contentEncryptionAlgorithm + " does not supported secretKeyLength of " + secretKeyLength).     } }
false;private;0;59;;private void calcualteAlgorithmIdWithKeyLength() {     if (DESEDE_CBC_PKCS5_PADDING.equals(getContentEncryptionAlgorithm())) {         algorithmId = CMSAlgorithm.DES_EDE3_CBC.     } else if (DES_CBC_PKCS5_PADDING.equals(getContentEncryptionAlgorithm())) {         algorithmId = CMSAlgorithm.DES_CBC.     } else if (AES_CBC_PKCS5_PADDING.equals(getContentEncryptionAlgorithm())) {         switch(getSecretKeyLength()) {             case 256:                 algorithmId = CMSAlgorithm.AES256_CBC.                 break.             case 192:                 algorithmId = CMSAlgorithm.AES192_CBC.                 break.             case 128:                 algorithmId = CMSAlgorithm.AES128_CBC.                 break.             default:                 // should not happen, has already been checked                 throw new IllegalStateException("Unsupported secret key length " + getSecretKeyLength() + " for algorithm AES").         }     } else if (CAMELLIA_CBC_PKCS5_PADDING.equals(getContentEncryptionAlgorithm())) {         switch(getSecretKeyLength()) {             case 256:                 algorithmId = CMSAlgorithm.CAMELLIA256_CBC.                 break.             case 192:                 algorithmId = CMSAlgorithm.CAMELLIA192_CBC.                 break.             case 128:                 algorithmId = CMSAlgorithm.CAMELLIA128_CBC.                 break.             default:                 // should not happen, has already been checked                 throw new IllegalStateException("Unsupported secret key length " + getSecretKeyLength() + " for algorithm Camellia").         }     } else if (RC2_CBC_PKCS5_PADDING.equals(getContentEncryptionAlgorithm())) {         algorithmId = CMSAlgorithm.RC2_CBC.     } else if (CAST5_CBC_PKCS5_PADDING.equals(getContentEncryptionAlgorithm())) {         algorithmId = CMSAlgorithm.CAST5_CBC.     } else {         // should not occur, has already been checked         throw new IllegalStateException("Content encryption algorithm " + getContentEncryptionAlgorithm() + " not supported").     } }
true;public;0;3;/**  * Content encryption algorithm.  *  * @return algorithm Id  */ ;/**  * Content encryption algorithm.  *  * @return algorithm Id  */ public ASN1ObjectIdentifier getAlgorithmID() {     return algorithmId. }
