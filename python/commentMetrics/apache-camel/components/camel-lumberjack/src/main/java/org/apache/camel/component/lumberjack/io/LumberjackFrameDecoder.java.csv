commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;41;;@Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {     // mark the reader index to be able to start decoding from the same position if there is not enough data to finish the frame decoding     in.markReaderIndex().     boolean frameDecoded = false.     try {         if (!in.isReadable(FRAME_HEADER_LENGTH)) {             return.         }         int frameVersion = in.readUnsignedByte().         sessionHandler.versionRead(frameVersion).         int frameType = in.readUnsignedByte().         LOG.debug("Received a lumberjack frame of type {}", (char) frameType).         switch(frameType) {             case TYPE_JSON:                 frameDecoded = handleJsonFrame(in, out).                 break.             case TYPE_DATA:                 frameDecoded = handleDataFrame(in, out).                 break.             case TYPE_WINDOW:                 frameDecoded = handleWindowFrame(in).                 break.             case TYPE_COMPRESS:                 frameDecoded = handleCompressedFrame(ctx, in, out).                 break.             default:                 throw new RuntimeException("Unsupported frame type=" + frameType).         }     } finally {         if (!frameDecoded) {             LOG.debug("Not enough data to decode a complete frame, retry when more data is available. Reader index was {}", in.readerIndex()).             in.resetReaderIndex().         }     } }
false;private;2;19;;private boolean handleJsonFrame(ByteBuf in, List<Object> out) throws IOException {     if (!in.isReadable(FRAME_JSON_HEADER_LENGTH)) {         return false.     }     int sequenceNumber = in.readInt().     // read message string and then decode it as JSON     String jsonStr = readLengthPrefixedString(in).     if (jsonStr == null) {         return false.     }     Object jsonMessage = jackson.readValue(jsonStr, Object.class).     // put message in the pipeline     out.add(new LumberjackMessage(sequenceNumber, jsonMessage)).     return true. }
false;private;2;27;;private boolean handleDataFrame(ByteBuf in, List<Object> out) {     if (!in.isReadable(FRAME_DATA_HEADER_LENGTH)) {         return false.     }     int sequenceNumber = in.readInt().     int entriesCount = in.readInt().     Map<String, String> dataMessage = new LinkedHashMap<>().     while (entriesCount-- > 0) {         String key = readLengthPrefixedString(in).         if (key == null) {             return false.         }         String value = readLengthPrefixedString(in).         if (value == null) {             return false.         }         dataMessage.put(key, value).     }     out.add(new LumberjackMessage(sequenceNumber, dataMessage)).     return true. }
false;private;1;9;;private boolean handleWindowFrame(ByteBuf in) {     if (!in.isReadable(FRAME_WINDOW_HEADER_LENGTH)) {         return false.     }     // update window size     sessionHandler.windowSizeRead(in.readInt()).     return true. }
false;private;3;32;;private boolean handleCompressedFrame(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {     if (!in.isReadable(FRAME_COMPRESS_HEADER_LENGTH)) {         return false.     }     int compressedPayloadLength = in.readInt().     if (!in.isReadable(compressedPayloadLength)) {         return false.     }     // decompress payload     Inflater inflater = new Inflater().     if (in.hasArray()) {         inflater.setInput(in.array(), in.arrayOffset() + in.readerIndex(), compressedPayloadLength).         in.skipBytes(compressedPayloadLength).     } else {         byte[] array = new byte[compressedPayloadLength].         in.readBytes(array).         inflater.setInput(array).     }     while (!inflater.finished()) {         ByteBuf decompressed = ctx.alloc().heapBuffer(1024, 1024).         byte[] outArray = decompressed.array().         int count = inflater.inflate(outArray, decompressed.arrayOffset(), decompressed.writableBytes()).         decompressed.writerIndex(count).         // put data in the pipeline         out.add(decompressed).     }     return true. }
true;private;1;13;/**  * Read a string that is prefixed by its length encoded by a 4 bytes integer.  *  * @param in the buffer to consume  * @return the read string or {@code null} if not enough data available to read the whole string  */ ;/**  * Read a string that is prefixed by its length encoded by a 4 bytes integer.  *  * @param in the buffer to consume  * @return the read string or {@code null} if not enough data available to read the whole string  */ private String readLengthPrefixedString(ByteBuf in) {     if (!in.isReadable(INT_LENGTH)) {         return null.     }     int length = in.readInt().     if (!in.isReadable(length)) {         return null.     }     String str = in.toString(in.readerIndex(), length, StandardCharsets.UTF_8).     in.skipBytes(length).     return str. }
