commented;modifiers;parameterAmount;loc;comment;code
false;public;2;2;;public void beforeWrap(RouteContext routeContext, NamedNode definition) { }
false;public;2;4;;public Processor wrap(RouteContext routeContext, Processor processor) {     // wrap the processor with authorizeDelegateProcessor     return new AuthorizeDelegateProcess(processor). }
false;protected;1;32;;protected void beforeProcess(Exchange exchange) throws Exception {     List<ConfigAttribute> attributes = accessPolicy.getConfigAttributes().     try {         Authentication authToken = getAuthentication(exchange.getIn()).         if (authToken == null) {             CamelAuthorizationException authorizationException = new CamelAuthorizationException("Cannot find the Authentication instance.", exchange).             throw authorizationException.         }         Authentication authenticated = authenticateIfRequired(authToken).         // Attempt authorization with exchange         try {             this.accessDecisionManager.decide(authenticated, exchange, attributes).         } catch (AccessDeniedException accessDeniedException) {             exchange.getIn().setHeader(Exchange.AUTHENTICATION_FAILURE_POLICY_ID, getId()).             AuthorizationFailureEvent event = new AuthorizationFailureEvent(exchange, attributes, authenticated, accessDeniedException).             publishEvent(event).             throw accessDeniedException.         }         publishEvent(new AuthorizedEvent(exchange, attributes, authenticated)).     } catch (RuntimeException exception) {         exchange.getIn().setHeader(Exchange.AUTHENTICATION_FAILURE_POLICY_ID, getId()).         CamelAuthorizationException authorizationException = new CamelAuthorizationException("Cannot access the processor which has been protected.", exchange, exception).         throw authorizationException.     } }
false;protected;1;13;;protected Authentication getAuthentication(Message message) {     Subject subject = message.getHeader(Exchange.AUTHENTICATION, Subject.class).     Authentication answer = null.     if (subject != null) {         answer = getAuthenticationAdapter().toAuthentication(subject).     }     // try to get it from thread context as a fallback     if (answer == null && useThreadSecurityContext) {         answer = SecurityContextHolder.getContext().getAuthentication().         LOG.debug("Get the authentication from SecurityContextHolder").     }     return answer. }
false;public;1;4;;public void process(Exchange exchange) throws Exception {     beforeProcess(exchange).     processNext(exchange). }
false;public;0;5;;public void afterPropertiesSet() throws Exception {     Assert.notNull(this.authenticationManager, "An AuthenticationManager is required").     Assert.notNull(this.accessDecisionManager, "An AccessDecisionManager is required").     Assert.notNull(this.accessPolicy, "The accessPolicy is required"). }
false;private;1;10;;private Authentication authenticateIfRequired(Authentication authentication) {     if (authentication.isAuthenticated() && !alwaysReauthenticate) {         LOG.debug("Previously Authenticated: {}", authentication).         return authentication.     }     authentication = authenticationManager.authenticate(authentication).     LOG.debug("Successfully Authenticated: {}", authentication).     return authentication. }
false;private;1;5;;private void publishEvent(ApplicationEvent event) {     if (this.eventPublisher != null) {         this.eventPublisher.publishEvent(event).     } }
false;public;0;12;;public AuthenticationAdapter getAuthenticationAdapter() {     if (authenticationAdapter == null) {         synchronized (this) {             if (authenticationAdapter != null) {                 return authenticationAdapter.             } else {                 authenticationAdapter = new DefaultAuthenticationAdapter().             }         }     }     return authenticationAdapter. }
false;public;1;3;;public void setAuthenticationAdapter(AuthenticationAdapter adapter) {     this.authenticationAdapter = adapter. }
false;public;0;3;;public AccessDecisionManager getAccessDecisionManager() {     return accessDecisionManager. }
false;public;0;3;;public AuthenticationManager getAuthenticationManager() {     return this.authenticationManager. }
false;public;1;3;;public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {     this.eventPublisher = applicationEventPublisher. }
false;public;1;3;;public void setSpringSecurityAccessPolicy(SpringSecurityAccessPolicy policy) {     this.accessPolicy = policy. }
false;public;0;3;;public SpringSecurityAccessPolicy getSpringSecurityAccessPolicy() {     return accessPolicy. }
false;public;0;3;;public boolean isAlwaysReauthenticate() {     return alwaysReauthenticate. }
false;public;1;3;;public void setAlwaysReauthenticate(boolean alwaysReauthenticate) {     this.alwaysReauthenticate = alwaysReauthenticate. }
false;public;0;3;;public boolean isUseThreadSecurityContext() {     return useThreadSecurityContext. }
false;public;1;3;;public void setUseThreadSecurityContext(boolean useThreadSecurityContext) {     this.useThreadSecurityContext = useThreadSecurityContext. }
false;public;1;3;;public void setAuthenticationManager(AuthenticationManager newManager) {     this.authenticationManager = newManager. }
false;public;1;3;;public void setAccessDecisionManager(AccessDecisionManager accessDecisionManager) {     this.accessDecisionManager = accessDecisionManager. }
