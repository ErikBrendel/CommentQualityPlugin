commented;modifiers;parameterAmount;loc;comment;code
false;static;1;4;;static Predicate<Bean> hasType(Type type) {     requireNonNull(type).     return bean -> bean.getTypes().contains(type). }
false;static;1;4;;static Predicate<Annotation> isAnnotationType(Class<? extends Annotation> clazz) {     requireNonNull(clazz).     return annotation -> clazz.equals(annotation.annotationType()). }
false;static;1;17;;static Class<?> getRawType(Type type) {     if (type instanceof Class<?>) {         return Class.class.cast(type).     } else if (type instanceof ParameterizedType) {         return getRawType(ParameterizedType.class.cast(type).getRawType()).     } else if (type instanceof TypeVariable<?>) {         return getBound(TypeVariable.class.cast(type).getBounds()).     } else if (type instanceof WildcardType) {         return getBound(WildcardType.class.cast(type).getUpperBounds()).     } else if (type instanceof GenericArrayType) {         Class<?> rawType = getRawType(GenericArrayType.class.cast(type).getGenericComponentType()).         if (rawType != null) {             return Array.newInstance(rawType, 0).getClass().         }     }     throw new UnsupportedOperationException("Unable to retrieve raw type for [" + type + "]"). }
false;private,static;1;7;;private static Class<?> getBound(Type[] bounds) {     if (bounds.length == 0) {         return Object.class.     } else {         return getRawType(bounds[0]).     } }
false;static;2;5;;@SafeVarargs static boolean hasAnnotation(AnnotatedType<?> type, Class<? extends Annotation>... annotations) {     return Stream.of(annotations).anyMatch(annotation -> hasAnnotation(type, annotation)). }
false;static;2;21;;static boolean hasAnnotation(AnnotatedType<?> type, Class<? extends Annotation> annotation) {     if (type.isAnnotationPresent(annotation)) {         return true.     }     for (AnnotatedMethod<?> method : type.getMethods()) {         if (method.isAnnotationPresent(annotation)) {             return true.         }     }     for (AnnotatedConstructor<?> constructor : type.getConstructors()) {         if (constructor.isAnnotationPresent(annotation)) {             return true.         }     }     for (AnnotatedField<?> field : type.getFields()) {         if (field.isAnnotationPresent(annotation)) {             return true.         }     }     return false. }
false;static;2;13;;static Set<Annotation> getQualifiers(Annotated annotated, BeanManager manager) {     return annotated.getAnnotations().stream().filter(annotation -> manager.isQualifier(annotation.annotationType())).collect(collectingAndThen(toSet(), qualifiers -> {         if (qualifiers.isEmpty()) {             qualifiers.add(DEFAULT).         }         qualifiers.add(ANY).         return qualifiers.     })). }
true;static;1;8;/**  * Generates a unique signature for {@link Bean}.  */ ;/**  * Generates a unique signature for {@link Bean}.  */ static String createBeanId(Bean<?> bean) {     return Stream.of(bean.getName(), bean.getScope().getName(), createAnnotationCollectionId(bean.getQualifiers()), createTypeCollectionId(bean.getTypes())).filter(Objects::nonNull).collect(joining(",")). }
true;private,static;1;6;/**  * Generates a unique signature of a collection of types.  */ ;/**  * Generates a unique signature of a collection of types.  */ private static String createTypeCollectionId(Collection<Type> types) {     return types.stream().sorted(comparing(CdiSpiHelper::createTypeId)).map(CdiSpiHelper::createTypeId).collect(joining(",", "[", "]")). }
true;private,static;1;22;/**  * Generates a unique signature for a {@link Type}.  */ ;/**  * Generates a unique signature for a {@link Type}.  */ private static String createTypeId(Type type) {     if (type instanceof Class<?>) {         return Class.class.cast(type).getName().     }     if (type instanceof ParameterizedType) {         return createTypeId(((ParameterizedType) type).getRawType()) + Stream.of(((ParameterizedType) type).getActualTypeArguments()).map(CdiSpiHelper::createTypeId).collect(joining(",", "<", ">")).     }     if (type instanceof TypeVariable<?>) {         return TypeVariable.class.cast(type).getName().     }     if (type instanceof GenericArrayType) {         return createTypeId(GenericArrayType.class.cast(type).getGenericComponentType()).     }     throw new UnsupportedOperationException("Unable to create type id for type [" + type + "]"). }
true;private,static;1;10;/**  * Generates a unique signature for a collection of annotations.  */ ;/**  * Generates a unique signature for a collection of annotations.  */ private static String createAnnotationCollectionId(Collection<Annotation> annotations) {     if (annotations.isEmpty()) {         return "".     }     return annotations.stream().sorted(comparing(a -> a.annotationType().getName())).map(CdiSpiHelper::createAnnotationId).collect(joining(",", "[", "]")). }
true;static;1;20;/**  * Generates a unique signature for an {@link Annotation}.  */ ;/**  * Generates a unique signature for an {@link Annotation}.  */ static String createAnnotationId(Annotation annotation) {     Method[] methods = doPrivileged((PrivilegedAction<Method[]>) () -> annotation.annotationType().getDeclaredMethods()).     return Stream.of(methods).filter(method -> !method.isAnnotationPresent(Nonbinding.class)).sorted(comparing(Method::getName)).collect(() -> new StringJoiner(",", "@" + annotation.annotationType().getCanonicalName() + "(", ")"), (joiner, method) -> {         try {             joiner.add(method.getName() + "=" + method.invoke(annotation).toString()).         } catch (NullPointerException | IllegalArgumentException | IllegalAccessException | InvocationTargetException cause) {             throw new RuntimeException("Error while accessing member [" + method.getName() + "]" + " of annotation [" + annotation.annotationType().getName() + "]", cause).         }     }, StringJoiner::merge).toString(). }
true;static;2;10;/**  * Wraps creation of a {@link CamelContext} with the current thread context ClassLoader  * set with the ClassLoader associated to the {@link Annotated} java class.  */ ;/**  * Wraps creation of a {@link CamelContext} with the current thread context ClassLoader  * set with the ClassLoader associated to the {@link Annotated} java class.  */ static <T extends CamelContext> T createCamelContextWithTCCL(Supplier<T> supplier, Annotated annotated) {     ClassLoader oldTccl = Thread.currentThread().getContextClassLoader().     try {         ClassLoader classLoader = getClassLoader(annotated).         Thread.currentThread().setContextClassLoader(classLoader).         return supplier.get().     } finally {         Thread.currentThread().setContextClassLoader(oldTccl).     } }
false;private,static;1;31;;private static ClassLoader getClassLoader(Annotated annotated) {     // Try to find a ClassLoader associated with the class containing AnnotatedMember     if (annotated instanceof AnnotatedMember) {         AnnotatedMember annotatedMember = (AnnotatedMember) annotated.         AnnotatedType type = annotatedMember.getDeclaringType().         return type.getJavaClass().getClassLoader().     }     // Try to find a ClassLoader associated with the annotated class     if (annotated instanceof AnnotatedType) {         AnnotatedType type = (AnnotatedType) annotated.         return type.getJavaClass().getClassLoader().     }     if (annotated instanceof SyntheticAnnotated) {         SyntheticAnnotated syntheticAnnotated = (SyntheticAnnotated) annotated.         Class<?> javaClass = syntheticAnnotated.getJavaClass().         if (javaClass != null) {             return javaClass.getClassLoader().         }     }     // Fallback to TCCL if available     ClassLoader tccl = Thread.currentThread().getContextClassLoader().     if (tccl != null) {         return tccl.     }     // If no TCCL is available, use the ClassLoader of this class     return CdiSpiHelper.class.getClassLoader(). }
