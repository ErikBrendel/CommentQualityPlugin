commented;modifiers;parameterAmount;loc;comment;code
false;;0;1;;void run() throws Throwable.
false;public;2;8;;@Override public void beforeWrap(RouteContext routeContext, NamedNode definition) {     // do not inherit since we create our own     // (otherwise the default error handler would be used two times     // because we inherit it on our own but only in case of a     // non-transactional error handler)     ((ProcessorDefinition<?>) definition).setInheritErrorHandler(false). }
false;public,abstract;1;1;;public abstract void run(Runnable runnable) throws Throwable.
false;public;2;65;;@Override public Processor wrap(RouteContext routeContext, Processor processor) {     JtaTransactionErrorHandler answer.     // the goal is to configure the error handler builder on the route as a     // transacted error handler,     // either its already a transacted or if not we replace it with a     // transacted one that we configure here     // and wrap the processor in the transacted error handler as we can have     // transacted routes that change     // propagation behavior, eg: from A required -> B -> requiresNew C     // (advanced use-case)     // if we should not support this we do not need to wrap the processor as     // we only need one transacted error handler     // find the existing error handler builder     RouteDefinition route = (RouteDefinition) routeContext.getRoute().     ErrorHandlerBuilder builder = (ErrorHandlerBuilder) route.getErrorHandlerBuilder().     // check if its a ref if so then do a lookup     if (builder instanceof ErrorHandlerBuilderRef) {         // its a reference to a error handler so lookup the reference         ErrorHandlerBuilderRef builderRef = (ErrorHandlerBuilderRef) builder.         String ref = builderRef.getRef().         // and if so then we can safely replace that with our transacted error handler         if (ErrorHandlerBuilderRef.isErrorHandlerBuilderConfigured(ref)) {             LOG.debug("Looking up ErrorHandlerBuilder with ref: {}", ref).             builder = (ErrorHandlerBuilder) ErrorHandlerBuilderRef.lookupErrorHandlerBuilder(routeContext, ref).         }     }     JtaTransactionErrorHandlerBuilder txBuilder.     if ((builder != null) && builder.supportTransacted()) {         if (!(builder instanceof JtaTransactionErrorHandlerBuilder)) {             throw new RuntimeCamelException("The given transactional error handler builder '" + builder + "' is not of type '" + JtaTransactionErrorHandlerBuilder.class.getName() + "' which is required in this environment!").         }         LOG.debug("The ErrorHandlerBuilder configured is a JtaTransactionErrorHandlerBuilder: {}", builder).         txBuilder = (JtaTransactionErrorHandlerBuilder) builder.cloneBuilder().     } else {         LOG.debug("No or no transactional ErrorHandlerBuilder configured, will use default JtaTransactionErrorHandlerBuilder settings").         txBuilder = new JtaTransactionErrorHandlerBuilder().     }     txBuilder.setTransactionPolicy(this).     // use error handlers from the configured builder     if (builder != null) {         txBuilder.setErrorHandlers(routeContext, builder.getErrorHandlers(routeContext)).     }     answer = createTransactionErrorHandler(routeContext, processor, txBuilder).     answer.setExceptionPolicy(txBuilder.getExceptionPolicyStrategy()).     // configure our answer based on the existing error handler     txBuilder.configure(routeContext, answer).     // set the route to use our transacted error handler builder     route.setErrorHandlerBuilder(txBuilder).     // return with wrapped transacted error handler     return answer. }
false;protected;3;10;;protected JtaTransactionErrorHandler createTransactionErrorHandler(RouteContext routeContext, Processor processor, ErrorHandlerBuilder builder) {     JtaTransactionErrorHandler answer.     try {         answer = (JtaTransactionErrorHandler) builder.createErrorHandler(routeContext, processor).     } catch (Exception e) {         throw RuntimeCamelException.wrapRuntimeCamelException(e).     }     return answer. }
false;public;0;4;;@Override public String toString() {     return getClass().getName(). }
