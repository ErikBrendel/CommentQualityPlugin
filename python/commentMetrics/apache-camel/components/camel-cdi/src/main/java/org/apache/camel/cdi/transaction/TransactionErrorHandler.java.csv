commented;modifiers;parameterAmount;loc;comment;code
false;public;1;14;;public void process(Exchange exchange) throws Exception {     // support using multiple threads to span a transaction     if (exchange.getUnitOfWork().isTransactedBy(transactionKey)) {         // already transacted by this transaction template         // so lets just let the error handler process it         processByErrorHandler(exchange).     } else {         // not yet wrapped in transaction so lets do that         // and then have it invoke the error handler from within that         // transaction         processInTransaction(exchange).     } }
false;public;2;13;;public boolean process(Exchange exchange, AsyncCallback callback) {     // support using multiple threads to span a transaction     try {         process(exchange).     } catch (Throwable e) {         exchange.setException(e).     }     // notify callback we are done synchronously     callback.done(true).     return true. }
false;public;1;6;;@Override public CompletableFuture<Exchange> processAsync(Exchange exchange) {     AsyncCallbackToCompletableFutureAdapter<Exchange> callback = new AsyncCallbackToCompletableFutureAdapter<>(exchange).     process(exchange, callback).     return callback.getFuture(). }
false;protected;1;51;;protected void processInTransaction(final Exchange exchange) throws Exception {     // is the exchange redelivered, for example JMS brokers support such     // details     Boolean externalRedelivered = exchange.isExternalRedelivered().     final String redelivered = externalRedelivered != null ? externalRedelivered.toString() : "unknown".     final String ids = ExchangeHelper.logIds(exchange).     try {         // mark the beginning of this transaction boundary         exchange.getUnitOfWork().beginTransactedBy(transactionKey).         // do in transaction         logTransactionBegin(redelivered, ids).         doInTransactionTemplate(exchange).         logTransactionCommit(redelivered, ids).     } catch (TransactionRolledbackException e) {         // do not set as exception, as its just a dummy exception to force         // spring TX to rollback         logTransactionRollback(redelivered, ids, null, true).     } catch (Throwable e) {         exchange.setException(e).         logTransactionRollback(redelivered, ids, e, false).     } finally {         // mark the end of this transaction boundary         exchange.getUnitOfWork().endTransactedBy(transactionKey).     }     // if it was a local rollback only then remove its marker so outer     // transaction wont see the marker     Boolean onlyLast = (Boolean) exchange.removeProperty(Exchange.ROLLBACK_ONLY_LAST).     if (onlyLast != null && onlyLast) {         // we only want this logged at debug level         if (log.isDebugEnabled()) {             // log exception if there was a cause exception so we have the             // stack trace             Exception cause = exchange.getException().             if (cause != null) {                 log.debug("Transaction rollback ({}) redelivered({}) for {} " + "due exchange was marked for rollbackOnlyLast and caught: ", transactionKey, redelivered, ids, cause).             } else {                 log.debug("Transaction rollback ({}) redelivered({}) for {} " + "due exchange was marked for rollbackOnlyLast", transactionKey, redelivered, ids).             }         }         // remove caused exception due we was marked as rollback only last         // so by removing the exception, any outer transaction will not be         // affected         exchange.setException(null).     } }
false;public;1;3;;public void setTransactionPolicy(JtaTransactionPolicy transactionPolicy) {     this.transactionPolicy = transactionPolicy. }
false;public;0;32;;@Override public void run() throws Throwable {     // wrapper exception to throw if the exchange failed     // IMPORTANT: Must be a runtime exception to let Spring regard     // it as to do "rollback"     Throwable rce.     // and now let process the exchange by the error handler     processByErrorHandler(exchange).     // only then rollback     if (exchange.getException() != null || exchange.isRollbackOnly()) {         // wrap exception in transacted exception         if (exchange.getException() != null) {             rce = exchange.getException().         } else {             // create dummy exception to force spring transaction             // manager to rollback             rce = new TransactionRolledbackException().         }         // best to rollback with Spring transaction manager)         if (log.isTraceEnabled()) {             log.trace("Throwing runtime exception to force transaction to rollback on {}", transactionPolicy).         }         throw rce.     } }
false;protected;1;40;;protected void doInTransactionTemplate(final Exchange exchange) throws Throwable {     // spring transaction template is working best with rollback if you     // throw it a runtime exception     // otherwise it may not rollback messages send to JMS queues etc.     transactionPolicy.run(new JtaTransactionPolicy.Runnable() {          @Override         public void run() throws Throwable {             // wrapper exception to throw if the exchange failed             // IMPORTANT: Must be a runtime exception to let Spring regard             // it as to do "rollback"             Throwable rce.             // and now let process the exchange by the error handler             processByErrorHandler(exchange).             // only then rollback             if (exchange.getException() != null || exchange.isRollbackOnly()) {                 // wrap exception in transacted exception                 if (exchange.getException() != null) {                     rce = exchange.getException().                 } else {                     // create dummy exception to force spring transaction                     // manager to rollback                     rce = new TransactionRolledbackException().                 }                 // best to rollback with Spring transaction manager)                 if (log.isTraceEnabled()) {                     log.trace("Throwing runtime exception to force transaction to rollback on {}", transactionPolicy).                 }                 throw rce.             }         }     }). }
true;protected;1;7;/**  * Processes the {@link Exchange} using the error handler.  * <p/>  * This implementation will invoke ensure this occurs synchronously, that  * means if the async routing engine did kick in, then this implementation  * will wait for the task to complete before it continues.  *  * @param exchange  *            the exchange  */ ;/**  * Processes the {@link Exchange} using the error handler.  * <p/>  * This implementation will invoke ensure this occurs synchronously, that  * means if the async routing engine did kick in, then this implementation  * will wait for the task to complete before it continues.  *  * @param exchange  *            the exchange  */ protected void processByErrorHandler(final Exchange exchange) {     try {         output.process(exchange).     } catch (Throwable e) {         throw new RuntimeCamelException(e).     } }
true;private;2;6;/**  * Logs the transaction begin  */ ;/**  * Logs the transaction begin  */ private void logTransactionBegin(String redelivered, String ids) {     if (log.isDebugEnabled()) {         log.debug("Transaction begin ({}) redelivered({}) for {})", transactionKey, redelivered, ids).     } }
true;private;2;18;/**  * Logs the transaction commit  */ ;/**  * Logs the transaction commit  */ private void logTransactionCommit(String redelivered, String ids) {     if ("true".equals(redelivered)) {         // committed this time         if (rollbackLoggingLevel == LoggingLevel.INFO || rollbackLoggingLevel == LoggingLevel.WARN || rollbackLoggingLevel == LoggingLevel.ERROR) {             log.info("Transaction commit ({}) redelivered({}) for {})", transactionKey, redelivered, ids).             // return after we have logged             return.         }     }     // log non redelivered by default at DEBUG level     log.debug("Transaction commit ({}) redelivered({}) for {})", transactionKey, redelivered, ids). }
true;private;4;45;/**  * Logs the transaction rollback.  */ ;/**  * Logs the transaction rollback.  */ private void logTransactionRollback(String redelivered, String ids, Throwable e, boolean rollbackOnly) {     if (rollbackLoggingLevel == LoggingLevel.OFF) {         return.     } else if (rollbackLoggingLevel == LoggingLevel.ERROR && log.isErrorEnabled()) {         if (rollbackOnly) {             log.error("Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly", transactionKey, redelivered, ids).         } else {             log.error("Transaction rollback ({}) redelivered({}) for {} caught: {}", transactionKey, redelivered, ids, e.getMessage()).         }     } else if (rollbackLoggingLevel == LoggingLevel.WARN && log.isWarnEnabled()) {         if (rollbackOnly) {             log.warn("Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly", transactionKey, redelivered, ids).         } else {             log.warn("Transaction rollback ({}) redelivered({}) for {} caught: {}", transactionKey, redelivered, ids, e.getMessage()).         }     } else if (rollbackLoggingLevel == LoggingLevel.INFO && log.isInfoEnabled()) {         if (rollbackOnly) {             log.info("Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly", transactionKey, redelivered, ids).         } else {             log.info("Transaction rollback ({}) redelivered({}) for {} caught: {}", transactionKey, redelivered, ids, e.getMessage()).         }     } else if (rollbackLoggingLevel == LoggingLevel.DEBUG && log.isDebugEnabled()) {         if (rollbackOnly) {             log.debug("Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly", transactionKey, redelivered, ids).         } else {             log.debug("Transaction rollback ({}) redelivered({}) for {} caught: {}", transactionKey, redelivered, ids, e.getMessage()).         }     } else if (rollbackLoggingLevel == LoggingLevel.TRACE && log.isTraceEnabled()) {         if (rollbackOnly) {             log.trace("Transaction rollback ({}) redelivered({}) for {} due exchange was marked for rollbackOnly", transactionKey, redelivered, ids).         } else {             log.trace("Transaction rollback ({}) redelivered({}) for {} caught: {}", transactionKey, redelivered, ids, e.getMessage()).         }     } }
false;public;1;3;;public void setExceptionPolicy(ExceptionPolicyStrategy exceptionPolicy) {     this.exceptionPolicy = exceptionPolicy. }
false;public;0;3;;public ExceptionPolicyStrategy getExceptionPolicy() {     return exceptionPolicy. }
false;public;0;4;;@Override public Processor getOutput() {     return output. }
false;protected;0;5;;@Override protected void doStart() throws Exception {     ServiceHelper.startService(output).     preparingShutdown = false. }
false;protected;0;6;;@Override protected void doStop() throws Exception { // noop, do not stop any services which we only do when shutting down // as the error handler can be context scoped, and should not stop in // case a route stops }
false;protected;0;4;;@Override protected void doShutdown() throws Exception {     ServiceHelper.stopAndShutdownServices(output). }
false;public;0;4;;@Override public boolean supportTransacted() {     return true. }
false;public;0;3;;public boolean hasNext() {     return output != null. }
false;public;0;9;;@Override public List<Processor> next() {     if (!hasNext()) {         return null.     }     List<Processor> answer = new ArrayList<>(1).     answer.add(output).     return answer. }
false;public;2;6;;@Override public void prepareShutdown(boolean suspendOnly, boolean forced) {     // prepare for shutdown, eg do not allow redelivery if configured     log.trace("Prepare shutdown on error handler {}", this).     preparingShutdown = true. }
