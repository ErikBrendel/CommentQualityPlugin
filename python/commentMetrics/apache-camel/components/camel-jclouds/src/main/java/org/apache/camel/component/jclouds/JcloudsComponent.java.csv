commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;25;;protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {     String[] uriParts = remaining.split(JcloudsConstants.DELIMETER).     if (uriParts.length != 2) {         throw new IllegalArgumentException("Invalid Endpoint URI: " + uri + ". It should contains a valid command and providerId").     }     String endpointType = uriParts[0].     String providerId = uriParts[1].     JcloudsCommand command = JcloudsCommand.valueOf(endpointType).     JcloudsConfiguration configuration = new JcloudsConfiguration().     configuration.setCommand(command).     configuration.setProviderId(providerId).     setProperties(configuration, parameters).     JcloudsEndpoint endpoint.     if (JcloudsCommand.blobstore == command) {         endpoint = new JcloudsBlobStoreEndpoint(uri, this, getBlobStore(providerId)).     } else {         endpoint = new JcloudsComputeEndpoint(uri, this, getComputeService(providerId)).     }     endpoint.setConfiguration(configuration).     setProperties(endpoint, parameters).     return endpoint. }
true;protected;1;22;/**  * Returns the {@link BlobStore} that matches the given providerOrApi.  * @param predicate The blobstore context name, provider or api.  * @return The matching {@link BlobStore}  */ ;/**  * Returns the {@link BlobStore} that matches the given providerOrApi.  * @param predicate The blobstore context name, provider or api.  * @return The matching {@link BlobStore}  */ protected BlobStore getBlobStore(String predicate) throws IllegalArgumentException {     if (blobStores != null && !blobStores.isEmpty()) {         // First try using name and then fallback to the provider or api.         if (isNameSupportedByContext()) {             for (BlobStore blobStore : blobStores) {                 if (blobStore.getContext().unwrap().getName().equals(predicate)) {                     return blobStore.                 }             }         }         for (BlobStore blobStore : blobStores) {             if (blobStore.getContext().unwrap().getId().equals(predicate)) {                 return blobStore.             }         }         throw new IllegalArgumentException(String.format("No blobstore found for:%s", predicate)).     } else {         throw new IllegalArgumentException("No blobstore available.").     } }
true;protected;1;21;/**  * Returns the {@link ComputeService} that matches the given predicate.  * @param predicate The compute context name, provider or api.  * @return The matching {@link ComputeService}  */ ;/**  * Returns the {@link ComputeService} that matches the given predicate.  * @param predicate The compute context name, provider or api.  * @return The matching {@link ComputeService}  */ protected ComputeService getComputeService(String predicate) throws IllegalArgumentException {     if (computeServices != null && !computeServices.isEmpty()) {         // First try using name and then fallback to the provider or api.         if (isNameSupportedByContext()) {             for (ComputeService computeService : computeServices) {                 if (computeService.getContext().unwrap().getName().equals(predicate)) {                     return computeService.                 }             }         }         for (ComputeService computeService : computeServices) {             if (computeService.getContext().unwrap().getId().equals(predicate)) {                 return computeService.             }         }         throw new IllegalArgumentException(String.format("No compute service found for :%s", predicate)).     } else {         throw new IllegalArgumentException("No compute service available.").     } }
true;private;0;8;/**  * Checks if jclouds {@link Context} supports the name.  * We need this method as getName is not supported in earlier micro version of 1.5.x.  * So we use this check to fallback to traditional means of looking up contexts and services, if name is not present.  */ ;/**  * Checks if jclouds {@link Context} supports the name.  * We need this method as getName is not supported in earlier micro version of 1.5.x.  * So we use this check to fallback to traditional means of looking up contexts and services, if name is not present.  */ private boolean isNameSupportedByContext() {     try {         Context.class.getMethod("getName").         return true.     } catch (NoSuchMethodException ex) {         return false.     } }
false;public;0;3;;public List<BlobStore> getBlobStores() {     return blobStores. }
true;public;1;3;/**  * To use the given BlobStore which must be configured when using blobstore.  */ ;/**  * To use the given BlobStore which must be configured when using blobstore.  */ public void setBlobStores(List<BlobStore> blobStores) {     this.blobStores = blobStores. }
false;public;0;3;;public List<ComputeService> getComputeServices() {     return computeServices. }
true;public;1;3;/**  * To use the given ComputeService which must be configured when use compute.  */ ;/**  * To use the given ComputeService which must be configured when use compute.  */ public void setComputeServices(List<ComputeService> computeServices) {     this.computeServices = computeServices. }
