commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;public;0;4;;@Override public ExchangePattern getExchangePattern() {     return ExchangePattern.InOut. }
false;protected;0;4;;@Override protected String createEndpointUri() {     return "mvel:" + getResourceUri(). }
false;public;0;3;;public String getEncoding() {     return encoding. }
true;public;1;3;/**  * Character encoding of the resource content.  */ ;/**  * Character encoding of the resource content.  */ public void setEncoding(String encoding) {     this.encoding = encoding. }
false;protected;1;52;;@Override protected void onExchange(Exchange exchange) throws Exception {     String path = getResourceUri().     ObjectHelper.notNull(path, "resourceUri").     String newResourceUri = exchange.getIn().getHeader(MvelConstants.MVEL_RESOURCE_URI, String.class).     if (newResourceUri != null) {         exchange.getIn().removeHeader(MvelConstants.MVEL_RESOURCE_URI).         log.debug("{} set to {} creating new endpoint to handle exchange", MvelConstants.MVEL_RESOURCE_URI, newResourceUri).         MvelEndpoint newEndpoint = findOrCreateEndpoint(getEndpointUri(), newResourceUri).         newEndpoint.onExchange(exchange).         return.     }     CompiledTemplate compiled.     ParserContext mvelContext = ParserContext.create().     Map<String, Object> variableMap = ExchangeHelper.createVariableMap(exchange).     String content = exchange.getIn().getHeader(MvelConstants.MVEL_TEMPLATE, String.class).     if (content != null) {         // use content from header         if (log.isDebugEnabled()) {             log.debug("Mvel content read from header {} for endpoint {}", MvelConstants.MVEL_TEMPLATE, getEndpointUri()).         }         // remove the header to avoid it being propagated in the routing         exchange.getIn().removeHeader(MvelConstants.MVEL_TEMPLATE).         compiled = TemplateCompiler.compileTemplate(content, mvelContext).     } else {         if (log.isDebugEnabled()) {             log.debug("Mvel content read from resource {} with resourceUri: {} for endpoint {}", getResourceUri(), path, getEndpointUri()).         }         // getResourceAsInputStream also considers the content cache         Reader reader = getEncoding() != null ? new InputStreamReader(getResourceAsInputStream(), getEncoding()) : new InputStreamReader(getResourceAsInputStream()).         String template = IOHelper.toString(reader).         if (!template.equals(this.template)) {             this.template = template.             this.compiled = TemplateCompiler.compileTemplate(template, mvelContext).         }         compiled = this.compiled.     }     // let mvel parse and execute the template     log.debug("Mvel is evaluating using mvel context: {}", variableMap).     Object result = TemplateRuntime.execute(compiled, mvelContext, variableMap).     // now lets output the results to the exchange     Message out = exchange.getOut().     out.setBody(result.toString()).     out.setHeaders(exchange.getIn().getHeaders()).     out.setAttachments(exchange.getIn().getAttachments()). }
false;public;2;5;;public MvelEndpoint findOrCreateEndpoint(String uri, String newResourceUri) {     String newUri = uri.replace(getResourceUri(), newResourceUri).     log.debug("Getting endpoint with URI: {}", newUri).     return getCamelContext().getEndpoint(newUri, MvelEndpoint.class). }
