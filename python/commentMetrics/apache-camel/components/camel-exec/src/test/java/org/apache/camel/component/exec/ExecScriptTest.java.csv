commented;modifiers;parameterAmount;loc;comment;code
true;public;0;21;/**  * TODO <b>the test is ignored for now to prevent accidental build  * failures.</b> Java 1.5 does not offer a method to check if a file is  * executable there is only a canRead method, which is not enough to  * guarantee that the script can be executed. <br>  *  * @throws Exception  */ ;/**  * TODO <b>the test is ignored for now to prevent accidental build  * failures.</b> Java 1.5 does not offer a method to check if a file is  * executable there is only a canRead method, which is not enough to  * guarantee that the script can be executed. <br>  *  * @throws Exception  */ @Test @DirtiesContext @Ignore public void testExecuteScript() throws Exception {     File scriptFile = getExecScriptFileOrNull("exec-test-script").     if (scriptFile != null) {         String classpathArg = getClasspathArg().         Exchange exchange = executeScript(scriptFile, NO_TIMEOUT, classpathArg, PRINT_IN_STDOUT).         if (exchange != null) {             String out = exchange.getIn().getBody(String.class).             String err = (String) exchange.getIn().getHeader(EXEC_STDERR).             assertNotNull(out).             assertTrue(out.contains(PRINT_IN_STDOUT)).             assertNull(err).         }     } else {         String os = System.getProperty("os.name").         logger.warn("Executing batch scripts is not tested on " + os).     } }
false;public;1;6;;public void process(Exchange exchange) throws Exception {     exchange.getIn().setBody(PRINT_IN_STDOUT).     exchange.getIn().setHeader(EXEC_COMMAND_TIMEOUT, NO_TIMEOUT).     exchange.getIn().setHeader(EXEC_COMMAND_EXECUTABLE, scriptFile.getAbsolutePath()).     exchange.getIn().setHeader(EXEC_COMMAND_ARGS, whiteSpaceSeparatedArgs). }
false;private;3;16;;private Exchange executeScript(final File scriptFile, long timeout, String... args) {     StringBuilder argsBuilder = new StringBuilder().     for (String arg : args) {         argsBuilder.append(arg + " ").     }     final String whiteSpaceSeparatedArgs = argsBuilder.toString().trim().     return producerTemplate.send(new Processor() {          public void process(Exchange exchange) throws Exception {             exchange.getIn().setBody(PRINT_IN_STDOUT).             exchange.getIn().setHeader(EXEC_COMMAND_TIMEOUT, NO_TIMEOUT).             exchange.getIn().setHeader(EXEC_COMMAND_EXECUTABLE, scriptFile.getAbsolutePath()).             exchange.getIn().setHeader(EXEC_COMMAND_ARGS, whiteSpaceSeparatedArgs).         }     }). }
false;private;0;15;;private String getClasspathArg() {     String classpath = System.getProperty("java.class.path").     if (OS.isFamilyWindows()) {         // On windows the "." character is replaced by a space by the         // command interpreter. Thus the classpath is split with the         // .-token. Therefore the classpath should be quoted with double         // quotes         classpath = "\"\"" + classpath + "\"\"".     } else {         // quote only once         classpath = "\"" + classpath + "\"".     }     return classpath. }
false;private;1;16;;private File getExecScriptFileOrNull(String scriptNameBase) {     String resource = null.     if (OS.isFamilyWindows()) {         resource = scriptNameBase + ".bat".     } else if (OS.isFamilyUnix()) {         resource = scriptNameBase + ".sh".     }     File resourceFile = getClasspathResourceFileOrNull(resource).     // TODO use canExecute here (available since java 1.6)     if (resourceFile != null && !resourceFile.canRead()) {         logger.warn("The resource  " + resourceFile.getAbsolutePath() + " is not readable!").         // it is not readable, do not try to execute it         return null.     }     return resourceFile. }
