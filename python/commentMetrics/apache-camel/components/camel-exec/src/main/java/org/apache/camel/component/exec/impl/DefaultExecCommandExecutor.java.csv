commented;modifiers;parameterAmount;loc;comment;code
false;public;1;59;;@Override public ExecResult execute(ExecCommand command) {     notNull(command, "command").     ByteArrayOutputStream out = new ByteArrayOutputStream().     ByteArrayOutputStream err = new ByteArrayOutputStream().     DefaultExecutor executor = prepareDefaultExecutor(command).     // handle error and output of the process and write them to the given     // out stream     PumpStreamHandler handler = new PumpStreamHandler(out, err, command.getInput()).     executor.setStreamHandler(handler).     CommandLine cl = toCommandLine(command).     try {         int exitValue = executor.execute(cl).         // if the size is zero, we have no output, so construct the result         // with null (required by ExecResult)         InputStream stdout = out.size() == 0 ? null : new ByteArrayInputStream(out.toByteArray()).         InputStream stderr = err.size() == 0 ? null : new ByteArrayInputStream(err.toByteArray()).         ExecResult result = new ExecResult(command, stdout, stderr, exitValue).         return result.     } catch (ExecuteException ee) {         LOG.error("ExecException while executing command: " + command.toString() + " - " + ee.getMessage()).         InputStream stdout = out.size() == 0 ? null : new ByteArrayInputStream(out.toByteArray()).         InputStream stderr = err.size() == 0 ? null : new ByteArrayInputStream(err.toByteArray()).         throw new ExecException("Failed to execute command " + command, stdout, stderr, ee.getExitValue(), ee).     } catch (IOException ioe) {         InputStream stdout = out.size() == 0 ? null : new ByteArrayInputStream(out.toByteArray()).         InputStream stderr = err.size() == 0 ? null : new ByteArrayInputStream(err.toByteArray()).         // use 0 as exit value as the executor didn't return the value         int exitValue = 0.         if (executor instanceof ExecDefaultExecutor) {             // get the exit value from the executor as it captures this to work around the common-exec bug             exitValue = ((ExecDefaultExecutor) executor).getExitValue().         }         // workaround to ignore if the stream was already closes due some race condition in commons-exec         String msg = ioe.getMessage().         if (msg != null && "stream closed".equals(msg.toLowerCase(Locale.ENGLISH))) {             LOG.debug("Ignoring Stream closed IOException", ioe).             ExecResult result = new ExecResult(command, stdout, stderr, exitValue).             return result.         }         // invalid working dir         LOG.error("IOException while executing command: " + command.toString() + " - " + ioe.getMessage()).         throw new ExecException("Unable to execute command " + command, stdout, stderr, exitValue, ioe).     } finally {         // the inputStream must be closed after the execution         IOUtils.closeQuietly(command.getInput()).     } }
false;protected;1;13;;protected DefaultExecutor prepareDefaultExecutor(ExecCommand execCommand) {     DefaultExecutor executor = new ExecDefaultExecutor().     executor.setExitValues(null).     if (execCommand.getWorkingDir() != null) {         executor.setWorkingDirectory(new File(execCommand.getWorkingDir()).getAbsoluteFile()).     }     if (execCommand.getTimeout() != ExecEndpoint.NO_TIMEOUT) {         executor.setWatchdog(new ExecuteWatchdog(execCommand.getTimeout())).     }     executor.setProcessDestroyer(new ShutdownHookProcessDestroyer()).     return executor. }
true;protected;1;10;/**  * Transforms an {@link ExecCommand} to a {@link CommandLine}. No quoting fo  * the arguments is used.  *  * @param execCommand a not-null <code>ExecCommand</code> instance.  * @return a {@link CommandLine} object.  */ ;/**  * Transforms an {@link ExecCommand} to a {@link CommandLine}. No quoting fo  * the arguments is used.  *  * @param execCommand a not-null <code>ExecCommand</code> instance.  * @return a {@link CommandLine} object.  */ protected CommandLine toCommandLine(ExecCommand execCommand) {     notNull(execCommand, "execCommand").     CommandLine cl = new CommandLine(execCommand.getExecutable()).     List<String> args = execCommand.getArgs().     for (String arg : args) {         // do not handle quoting here, it is already quoted         cl.addArgument(arg, false).     }     return cl. }
