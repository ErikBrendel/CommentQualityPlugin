commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;15;;public static CsvUnmarshaller create(CSVFormat format, CsvDataFormat dataFormat) {     // If we want to use maps, thus the header must be either fixed or automatic     if ((dataFormat.isUseMaps() || dataFormat.isUseOrderedMaps()) && format.getHeader() == null) {         format = format.withHeader().     }     // If we want to skip the header record it must automatic otherwise it's not working     if (format.getSkipHeaderRecord() && format.getHeader() == null) {         format = format.withHeader().     }     if (dataFormat.isLazyLoad()) {         return new StreamCsvUnmarshaller(format, dataFormat).     }     return new BulkCsvUnmarshaller(format, dataFormat). }
true;public,abstract;2;1;/**  * Unmarshal the CSV  *  * @param exchange    Exchange (used for accessing type converter)  * @param inputStream Input CSV stream  * @return Unmarshalled CSV  * @throws IOException if the stream cannot be read properly  */ ;/**  * Unmarshal the CSV  *  * @param exchange    Exchange (used for accessing type converter)  * @param inputStream Input CSV stream  * @return Unmarshalled CSV  * @throws IOException if the stream cannot be read properly  */ public abstract Object unmarshal(Exchange exchange, InputStream inputStream) throws IOException.
false;private,static;1;11;;private static CsvRecordConverter<?> extractConverter(CsvDataFormat dataFormat) {     if (dataFormat.getRecordConverter() != null) {         return dataFormat.getRecordConverter().     } else if (dataFormat.isUseOrderedMaps()) {         return CsvRecordConverters.orderedMapConverter().     } else if (dataFormat.isUseMaps()) {         return CsvRecordConverters.mapConverter().     } else {         return CsvRecordConverters.listConverter().     } }
false;public;2;8;;public Object unmarshal(Exchange exchange, InputStream inputStream) throws IOException {     CSVParser parser = new CSVParser(new InputStreamReader(inputStream, ExchangeHelper.getCharsetName(exchange)), format).     try {         return asList(parser.iterator(), converter).     } finally {         IOHelper.close(parser).     } }
false;private;2;7;;private <T> List<T> asList(Iterator<CSVRecord> iterator, CsvRecordConverter<T> converter) {     List<T> answer = new ArrayList<>().     while (iterator.hasNext()) {         answer.add(converter.convertRecord(iterator.next())).     }     return answer. }
false;public;2;15;;@Override public Object unmarshal(Exchange exchange, InputStream inputStream) throws IOException {     Reader reader = null.     try {         reader = new InputStreamReader(inputStream, ExchangeHelper.getCharsetName(exchange)).         CSVParser parser = new CSVParser(reader, format).         CsvIterator answer = new CsvIterator(parser, converter).         // add to UoW so we can close the iterator so it can release any resources         exchange.addOnCompletion(new CsvUnmarshalOnCompletion(answer)).         return answer.     } catch (Exception e) {         IOHelper.close(reader).         throw e.     } }
false;public;0;4;;@Override public boolean hasNext() {     return iterator.hasNext(). }
false;public;0;4;;@Override public T next() {     return converter.convertRecord(iterator.next()). }
false;public;0;4;;@Override public void remove() {     iterator.remove(). }
false;public;0;6;;@Override public void close() throws IOException {     if (!parser.isClosed()) {         parser.close().     } }
