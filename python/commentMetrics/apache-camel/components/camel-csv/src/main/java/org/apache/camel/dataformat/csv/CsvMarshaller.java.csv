commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;14;/**  * Creates a new instance.  *  * @param format     CSV format  * @param dataFormat Camel CSV data format  * @return New instance  */ ;/**  * Creates a new instance.  *  * @param format     CSV format  * @param dataFormat Camel CSV data format  * @return New instance  */ public static CsvMarshaller create(CSVFormat format, CsvDataFormat dataFormat) {     org.apache.camel.util.ObjectHelper.notNull(format, "CSV format").     org.apache.camel.util.ObjectHelper.notNull(dataFormat, "CSV data format").     // If we don't want the header record, clear it     if (format.getSkipHeaderRecord()) {         format = format.withHeader((String[]) null).     }     String[] fixedColumns = dataFormat.getHeader().     if (fixedColumns != null && fixedColumns.length > 0) {         return new FixedColumnsMarshaller(format, fixedColumns).     }     return new DynamicColumnsMarshaller(format). }
true;public;3;13;/**  * Marshals the given object into the given stream.  *  * @param exchange     Exchange (used for access to type conversion)  * @param object       Body to marshal  * @param outputStream Output stream of the CSV  * @throws NoTypeConversionAvailableException if the body cannot be converted  * @throws IOException                        if we cannot write into the given stream  */ ;/**  * Marshals the given object into the given stream.  *  * @param exchange     Exchange (used for access to type conversion)  * @param object       Body to marshal  * @param outputStream Output stream of the CSV  * @throws NoTypeConversionAvailableException if the body cannot be converted  * @throws IOException                        if we cannot write into the given stream  */ @SuppressWarnings("rawtypes") public void marshal(Exchange exchange, Object object, OutputStream outputStream) throws NoTypeConversionAvailableException, IOException {     CSVPrinter printer = createPrinter(exchange, outputStream).     try {         Iterator it = ObjectHelper.createIterator(object).         while (it.hasNext()) {             Object child = it.next().             printer.printRecord(getRecordValues(exchange, child)).         }     } finally {         IOHelper.close(printer).     } }
true;protected;2;5;/**  * Creates and returns a {@link CSVPrinter}.  *  * @param exchange     Exchange (used for access to type conversion). Could NOT be <code>null</code>.  * @param outputStream Output stream of the CSV. Could NOT be <code>null</code>.  * @return a new {@link CSVPrinter}. Never <code>null</code>.  */ ;/**  * Creates and returns a {@link CSVPrinter}.  *  * @param exchange     Exchange (used for access to type conversion). Could NOT be <code>null</code>.  * @param outputStream Output stream of the CSV. Could NOT be <code>null</code>.  * @return a new {@link CSVPrinter}. Never <code>null</code>.  */ protected CSVPrinter createPrinter(Exchange exchange, OutputStream outputStream) throws IOException {     org.apache.camel.util.ObjectHelper.notNull(exchange, "Exchange").     org.apache.camel.util.ObjectHelper.notNull(outputStream, "Output stream").     return new CSVPrinter(new OutputStreamWriter(outputStream, ExchangeHelper.getCharsetName(exchange)), format). }
false;private;2;8;;private Iterable<?> getRecordValues(Exchange exchange, Object data) throws NoTypeConversionAvailableException {     // each row must be a map or list based     Map<?, ?> map = exchange.getContext().getTypeConverter().tryConvertTo(Map.class, exchange, data).     if (map != null) {         return getMapRecordValues(map).     }     return ExchangeHelper.convertToMandatoryType(exchange, List.class, data). }
true;protected,abstract;1;1;/**  * Gets the CSV record values of the given map.  *  * @param map Input map  * @return CSV record values of the given map  */ ;/**  * Gets the CSV record values of the given map.  *  * @param map Input map  * @return CSV record values of the given map  */ protected abstract Iterable<?> getMapRecordValues(Map<?, ?> map).
false;protected;1;8;;@Override protected Iterable<?> getMapRecordValues(Map<?, ?> map) {     List<Object> result = new ArrayList<>(fixedColumns.length).     for (String key : fixedColumns) {         result.add(map.get(key)).     }     return result. }
false;protected;1;8;;@Override protected Iterable<?> getMapRecordValues(Map<?, ?> map) {     List<Object> result = new ArrayList<>(map.size()).     for (Object key : map.keySet()) {         result.add(map.get(key)).     }     return result. }
