commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;3;/**  * Returns a converter that transforms the CSV record into a list.  *  * @return converter that transforms the CSV record into a list  */ ;/**  * Returns a converter that transforms the CSV record into a list.  *  * @return converter that transforms the CSV record into a list  */ public static CsvRecordConverter<List<String>> listConverter() {     return ListCsvRecordConverter.SINGLETON. }
false;public;1;8;;@Override public List<String> convertRecord(CSVRecord record) {     List<String> answer = new ArrayList<>(record.size()).     for (int i = 0. i < record.size(). i++) {         answer.add(record.get(i)).     }     return answer. }
true;public,static;0;3;/**  * Returns a converter that transforms the CSV record into a map.  *  * @return converter that transforms the CSV record into a map  */ ;/**  * Returns a converter that transforms the CSV record into a map.  *  * @return converter that transforms the CSV record into a map  */ public static CsvRecordConverter<Map<String, String>> mapConverter() {     return MapCsvRecordConverter.SINGLETON. }
false;public;1;4;;@Override public Map<String, String> convertRecord(CSVRecord record) {     return record.toMap(). }
true;public,static;0;3;/**  * Returns a converter that transforms the CSV record into an ordered map.  *  * @return converter that transforms the CSV record into an ordered map  */ ;/**  * Returns a converter that transforms the CSV record into an ordered map.  *  * @return converter that transforms the CSV record into an ordered map  */ public static CsvRecordConverter<Map<String, String>> orderedMapConverter() {     return OrderedMapCsvRecordConverter.SINGLETON. }
false;public;1;23;;@Override @SuppressWarnings("unchecked") public Map<String, String> convertRecord(CSVRecord record) {     Map<String, String> answer = new LinkedHashMap<>().     // use reflection because CSVRecord does not return maps ordered     try {         Field field = record.getClass().getDeclaredField("mapping").         field.setAccessible(true).         Map<String, Integer> mapping = (Map<String, Integer>) field.get(record).         if (mapping != null) {             for (Object o : mapping.entrySet()) {                 Map.Entry<String, Integer> entry = (Map.Entry) o.                 int col = entry.getValue().                 answer.put(entry.getKey(), record.get(col)).             }         }     } catch (Exception e) {         e.printStackTrace().     // ignore     }     return answer. }
