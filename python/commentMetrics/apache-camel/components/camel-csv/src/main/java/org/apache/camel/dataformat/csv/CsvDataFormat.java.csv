commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getDataFormatName() {     return "csv". }
false;public;3;3;;public void marshal(Exchange exchange, Object object, OutputStream outputStream) throws Exception {     marshaller.marshal(exchange, object, outputStream). }
false;public;2;3;;public Object unmarshal(Exchange exchange, InputStream inputStream) throws Exception {     return unmarshaller.unmarshal(exchange, inputStream). }
false;protected;0;5;;@Override protected void doStart() throws Exception {     marshaller = marshallerFactory.create(getActiveFormat(), this).     unmarshaller = CsvUnmarshaller.create(getActiveFormat(), this). }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
false;;0;77;;CSVFormat getActiveFormat() {     CSVFormat answer = format.     if (commentMarkerDisabled) {         // null disables the comment marker         answer = answer.withCommentMarker(null).     } else if (commentMarker != null) {         answer = answer.withCommentMarker(commentMarker).     }     if (delimiter != null) {         answer = answer.withDelimiter(delimiter).     }     if (escapeDisabled) {         // null disables the escape         answer = answer.withEscape(null).     } else if (escape != null) {         answer = answer.withEscape(escape).     }     if (headerDisabled) {         // null disables the header         answer = answer.withHeader((String[]) null).     } else if (header != null) {         answer = answer.withHeader(header).     }     if (allowMissingColumnNames != null) {         answer = answer.withAllowMissingColumnNames(allowMissingColumnNames).     }     if (ignoreEmptyLines != null) {         answer = answer.withIgnoreEmptyLines(ignoreEmptyLines).     }     if (ignoreSurroundingSpaces != null) {         answer = answer.withIgnoreSurroundingSpaces(ignoreSurroundingSpaces).     }     if (nullStringDisabled) {         // null disables the null string replacement         answer = answer.withNullString(null).     } else if (nullString != null) {         answer = answer.withNullString(nullString).     }     if (quoteDisabled) {         // null disables quotes         answer = answer.withQuote(null).     } else if (quote != null) {         answer = answer.withQuote(quote).     }     if (quoteMode != null) {         answer = answer.withQuoteMode(quoteMode).     }     if (recordSeparatorDisabled) {         // null disables the record separator         answer = answer.withRecordSeparator(null).     } else if (recordSeparator != null) {         answer = answer.withRecordSeparator(recordSeparator).     }     if (skipHeaderRecord != null) {         answer = answer.withSkipHeaderRecord(skipHeaderRecord).     }     if (trim != null) {         answer = answer.withTrim(trim).     }     if (ignoreHeaderCase != null) {         answer = answer.withIgnoreHeaderCase(ignoreHeaderCase).     }     if (trailingDelimiter != null) {         answer = answer.withTrailingDelimiter(trailingDelimiter).     }     return answer. }
true;public;0;3;/**  * Gets the CSV format before applying any changes.  * It cannot be {@code null}, the default one is {@link org.apache.commons.csv.CSVFormat#DEFAULT}.  *  * @return CSV format  */ ;// region Getters/Setters /**  * Gets the CSV format before applying any changes.  * It cannot be {@code null}, the default one is {@link org.apache.commons.csv.CSVFormat#DEFAULT}.  *  * @return CSV format  */ public CSVFormat getFormat() {     return format. }
true;public;1;4;/**  * Sets the CSV format before applying any changes.  * If {@code null}, then {@link org.apache.commons.csv.CSVFormat#DEFAULT} is used instead.  *  * @param format CSV format  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat  * @see org.apache.commons.csv.CSVFormat#DEFAULT  */ ;/**  * Sets the CSV format before applying any changes.  * If {@code null}, then {@link org.apache.commons.csv.CSVFormat#DEFAULT} is used instead.  *  * @param format CSV format  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat  * @see org.apache.commons.csv.CSVFormat#DEFAULT  */ public CsvDataFormat setFormat(CSVFormat format) {     this.format = (format == null) ? CSVFormat.DEFAULT : format.     return this. }
true;public;1;4;/**  * Sets the {@link CsvMarshaller} factory.  * If {@code null}, then {@link CsvMarshallerFactory#DEFAULT} is used instead.  *  * @param marshallerFactory  * @return Current {@code CsvDataFormat}, fluent API  */ ;/**  * Sets the {@link CsvMarshaller} factory.  * If {@code null}, then {@link CsvMarshallerFactory#DEFAULT} is used instead.  *  * @param marshallerFactory  * @return Current {@code CsvDataFormat}, fluent API  */ public CsvDataFormat setMarshallerFactory(CsvMarshallerFactory marshallerFactory) {     this.marshallerFactory = (marshallerFactory == null) ? CsvMarshallerFactory.DEFAULT : marshallerFactory.     return this. }
true;public;0;3;/**  * Returns the used {@link CsvMarshallerFactory}.  *  * @return never {@code null}.  */ ;/**  * Returns the used {@link CsvMarshallerFactory}.  *  * @return never {@code null}.  */ public CsvMarshallerFactory getMarshallerFactory() {     return marshallerFactory. }
true;public;1;18;/**  * Sets the CSV format by name before applying any changes.  *  * @param name CSV format name  * @return Current {@code CsvDataFormat}, fluent API  * @see #setFormat(org.apache.commons.csv.CSVFormat)  * @see org.apache.commons.csv.CSVFormat  */ ;/**  * Sets the CSV format by name before applying any changes.  *  * @param name CSV format name  * @return Current {@code CsvDataFormat}, fluent API  * @see #setFormat(org.apache.commons.csv.CSVFormat)  * @see org.apache.commons.csv.CSVFormat  */ public CsvDataFormat setFormatName(String name) {     if (name == null) {         setFormat(null).     } else if ("DEFAULT".equals(name)) {         setFormat(CSVFormat.DEFAULT).     } else if ("RFC4180".equals(name)) {         setFormat(CSVFormat.RFC4180).     } else if ("EXCEL".equals(name)) {         setFormat(CSVFormat.EXCEL).     } else if ("TDF".equals(name)) {         setFormat(CSVFormat.TDF).     } else if ("MYSQL".equals(name)) {         setFormat(CSVFormat.MYSQL).     } else {         throw new IllegalArgumentException("Unsupported format").     }     return this. }
true;public;0;3;/**  * Indicates whether or not the comment markers are disabled.  *  * @return {@code true} if the comment markers are disabled, {@code false} otherwise  */ ;/**  * Indicates whether or not the comment markers are disabled.  *  * @return {@code true} if the comment markers are disabled, {@code false} otherwise  */ public boolean isCommentMarkerDisabled() {     return commentMarkerDisabled. }
true;public;1;4;/**  * Sets whether or not the comment markers are disabled.  *  * @param commentMarkerDisabled {@code true} if the comment markers are disabled, {@code false} otherwise  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withCommentMarker(java.lang.Character)  */ ;/**  * Sets whether or not the comment markers are disabled.  *  * @param commentMarkerDisabled {@code true} if the comment markers are disabled, {@code false} otherwise  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withCommentMarker(java.lang.Character)  */ public CsvDataFormat setCommentMarkerDisabled(boolean commentMarkerDisabled) {     this.commentMarkerDisabled = commentMarkerDisabled.     return this. }
true;public;0;3;/**  * Gets the comment marker.  * If {@code null} then the default one of the format used.  *  * @return Comment marker  */ ;/**  * Gets the comment marker.  * If {@code null} then the default one of the format used.  *  * @return Comment marker  */ public Character getCommentMarker() {     return commentMarker. }
true;public;1;4;/**  * Sets the comment marker to use.  * If {@code null} then the default one of the format used.  *  * @param commentMarker Comment marker  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withCommentMarker(Character)  */ ;/**  * Sets the comment marker to use.  * If {@code null} then the default one of the format used.  *  * @param commentMarker Comment marker  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withCommentMarker(Character)  */ public CsvDataFormat setCommentMarker(Character commentMarker) {     this.commentMarker = commentMarker.     return this. }
true;public;0;3;/**  * Gets the delimiter.  * If {@code null} then the default one of the format used.  *  * @return Delimiter  */ ;/**  * Gets the delimiter.  * If {@code null} then the default one of the format used.  *  * @return Delimiter  */ public Character getDelimiter() {     return delimiter. }
true;public;1;4;/**  * Sets the delimiter.  * If {@code null} then the default one of the format used.  *  * @param delimiter Delimiter  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withDelimiter(char)  */ ;/**  * Sets the delimiter.  * If {@code null} then the default one of the format used.  *  * @param delimiter Delimiter  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withDelimiter(char)  */ public CsvDataFormat setDelimiter(Character delimiter) {     this.delimiter = delimiter.     return this. }
true;public;0;3;/**  * Indicates whether or not the escaping is disabled.  *  * @return {@code true} if the escaping is disabled, {@code false} otherwise  */ ;/**  * Indicates whether or not the escaping is disabled.  *  * @return {@code true} if the escaping is disabled, {@code false} otherwise  */ public boolean isEscapeDisabled() {     return escapeDisabled. }
true;public;1;4;/**  * Sets whether or not the escaping is disabled.  *  * @param escapeDisabled {@code true} if the escaping is disabled, {@code false} otherwise  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withEscape(Character)  */ ;/**  * Sets whether or not the escaping is disabled.  *  * @param escapeDisabled {@code true} if the escaping is disabled, {@code false} otherwise  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withEscape(Character)  */ public CsvDataFormat setEscapeDisabled(boolean escapeDisabled) {     this.escapeDisabled = escapeDisabled.     return this. }
true;public;0;3;/**  * Gets the escape character.  * If {@code null} then the default one of the format used.  *  * @return Escape character  */ ;/**  * Gets the escape character.  * If {@code null} then the default one of the format used.  *  * @return Escape character  */ public Character getEscape() {     return escape. }
true;public;1;4;/**  * Sets the escape character.  * If {@code null} then the default one of the format used.  *  * @param escape Escape character  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withEscape(Character)  */ ;/**  * Sets the escape character.  * If {@code null} then the default one of the format used.  *  * @param escape Escape character  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withEscape(Character)  */ public CsvDataFormat setEscape(Character escape) {     this.escape = escape.     return this. }
true;public;0;3;/**  * Indicates whether or not the headers are disabled.  *  * @return {@code true} if the headers are disabled, {@code false} otherwise  */ ;/**  * Indicates whether or not the headers are disabled.  *  * @return {@code true} if the headers are disabled, {@code false} otherwise  */ public boolean isHeaderDisabled() {     return headerDisabled. }
true;public;1;4;/**  * Sets whether or not the headers are disabled.  *  * @param headerDisabled {@code true} if the headers are disabled, {@code false} otherwise  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withHeader(String...)  */ ;/**  * Sets whether or not the headers are disabled.  *  * @param headerDisabled {@code true} if the headers are disabled, {@code false} otherwise  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withHeader(String...)  */ public CsvDataFormat setHeaderDisabled(boolean headerDisabled) {     this.headerDisabled = headerDisabled.     return this. }
true;public;0;3;/**  * Gets the header.  * If {@code null} then the default one of the format used. If empty then it will be automatically handled.  *  * @return Header  */ ;/**  * Gets the header.  * If {@code null} then the default one of the format used. If empty then it will be automatically handled.  *  * @return Header  */ public String[] getHeader() {     return header. }
true;public;1;4;/**  * Gets the header.  * If {@code null} then the default one of the format used. If empty then it will be automatically handled.  *  * @param header Header  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withHeader(String...)  */ ;/**  * Gets the header.  * If {@code null} then the default one of the format used. If empty then it will be automatically handled.  *  * @param header Header  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withHeader(String...)  */ public CsvDataFormat setHeader(String[] header) {     this.header = Arrays.copyOf(header, header.length).     return this. }
true;public;0;3;/**  * Indicates whether or not missing column names are allowed.  * If {@code null} then the default value of the format used.  *  * @return Whether or not missing column names are allowed  */ ;/**  * Indicates whether or not missing column names are allowed.  * If {@code null} then the default value of the format used.  *  * @return Whether or not missing column names are allowed  */ public Boolean getAllowMissingColumnNames() {     return allowMissingColumnNames. }
true;public;1;4;/**  * Sets whether or not missing column names are allowed.  * If {@code null} then the default value of the format used.  *  * @param allowMissingColumnNames Whether or not missing column names are allowed  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withAllowMissingColumnNames(boolean)  */ ;/**  * Sets whether or not missing column names are allowed.  * If {@code null} then the default value of the format used.  *  * @param allowMissingColumnNames Whether or not missing column names are allowed  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withAllowMissingColumnNames(boolean)  */ public CsvDataFormat setAllowMissingColumnNames(Boolean allowMissingColumnNames) {     this.allowMissingColumnNames = allowMissingColumnNames.     return this. }
true;public;0;3;/**  * Indicates whether or not empty lines must be ignored.  * If {@code null} then the default value of the format used.  *  * @return Whether or not empty lines must be ignored  */ ;/**  * Indicates whether or not empty lines must be ignored.  * If {@code null} then the default value of the format used.  *  * @return Whether or not empty lines must be ignored  */ public Boolean getIgnoreEmptyLines() {     return ignoreEmptyLines. }
true;public;1;4;/**  * Sets whether or not empty lines must be ignored.  * If {@code null} then the default value of the format used.  *  * @param ignoreEmptyLines Whether or not empty lines must be ignored  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withIgnoreEmptyLines(boolean)  */ ;/**  * Sets whether or not empty lines must be ignored.  * If {@code null} then the default value of the format used.  *  * @param ignoreEmptyLines Whether or not empty lines must be ignored  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withIgnoreEmptyLines(boolean)  */ public CsvDataFormat setIgnoreEmptyLines(Boolean ignoreEmptyLines) {     this.ignoreEmptyLines = ignoreEmptyLines.     return this. }
true;public;0;3;/**  * Indicates whether or not surrounding spaces must be ignored.  * If {@code null} then the default value of the format used.  *  * @return Whether or not surrounding spaces must be ignored  */ ;/**  * Indicates whether or not surrounding spaces must be ignored.  * If {@code null} then the default value of the format used.  *  * @return Whether or not surrounding spaces must be ignored  */ public Boolean getIgnoreSurroundingSpaces() {     return ignoreSurroundingSpaces. }
true;public;1;4;/**  * Sets whether or not surrounding spaces must be ignored.  * If {@code null} then the default value of the format used.  *  * @param ignoreSurroundingSpaces Whether or not surrounding spaces must be ignored  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withIgnoreSurroundingSpaces(boolean)  */ ;/**  * Sets whether or not surrounding spaces must be ignored.  * If {@code null} then the default value of the format used.  *  * @param ignoreSurroundingSpaces Whether or not surrounding spaces must be ignored  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withIgnoreSurroundingSpaces(boolean)  */ public CsvDataFormat setIgnoreSurroundingSpaces(Boolean ignoreSurroundingSpaces) {     this.ignoreSurroundingSpaces = ignoreSurroundingSpaces.     return this. }
true;public;0;3;/**  * Indicates whether or not the null string replacement is disabled.  *  * @return {@code true} if the null string replacement is disabled, {@code false} otherwise  */ ;/**  * Indicates whether or not the null string replacement is disabled.  *  * @return {@code true} if the null string replacement is disabled, {@code false} otherwise  */ public boolean isNullStringDisabled() {     return nullStringDisabled. }
true;public;1;4;/**  * Sets whether or not the null string replacement is disabled.  *  * @param nullStringDisabled {@code true} if the null string replacement is disabled, {@code false} otherwise  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withNullString(String)  */ ;/**  * Sets whether or not the null string replacement is disabled.  *  * @param nullStringDisabled {@code true} if the null string replacement is disabled, {@code false} otherwise  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withNullString(String)  */ public CsvDataFormat setNullStringDisabled(boolean nullStringDisabled) {     this.nullStringDisabled = nullStringDisabled.     return this. }
true;public;0;3;/**  * Gets the null string replacement.  * If {@code null} then the default one of the format used.  *  * @return Null string replacement  */ ;/**  * Gets the null string replacement.  * If {@code null} then the default one of the format used.  *  * @return Null string replacement  */ public String getNullString() {     return nullString. }
true;public;1;4;/**  * Sets the null string replacement.  * If {@code null} then the default one of the format used.  *  * @param nullString Null string replacement  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withNullString(String)  */ ;/**  * Sets the null string replacement.  * If {@code null} then the default one of the format used.  *  * @param nullString Null string replacement  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withNullString(String)  */ public CsvDataFormat setNullString(String nullString) {     this.nullString = nullString.     return this. }
true;public;0;3;/**  * Indicates whether or not quotes are disabled.  *  * @return {@code true} if quotes are disabled, {@code false} otherwise  */ ;/**  * Indicates whether or not quotes are disabled.  *  * @return {@code true} if quotes are disabled, {@code false} otherwise  */ public boolean isQuoteDisabled() {     return quoteDisabled. }
true;public;1;4;/**  * Sets whether or not quotes are disabled  *  * @param quoteDisabled {@code true} if quotes are disabled, {@code false} otherwise  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withQuote(Character)  */ ;/**  * Sets whether or not quotes are disabled  *  * @param quoteDisabled {@code true} if quotes are disabled, {@code false} otherwise  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withQuote(Character)  */ public CsvDataFormat setQuoteDisabled(boolean quoteDisabled) {     this.quoteDisabled = quoteDisabled.     return this. }
true;public;0;3;/**  * Gets the quote character.  * If {@code null} then the default one of the format used.  *  * @return Quote character  */ ;/**  * Gets the quote character.  * If {@code null} then the default one of the format used.  *  * @return Quote character  */ public Character getQuote() {     return quote. }
true;public;1;4;/**  * Sets the quote character.  * If {@code null} then the default one of the format used.  *  * @param quote Quote character  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withQuote(Character)  */ ;/**  * Sets the quote character.  * If {@code null} then the default one of the format used.  *  * @param quote Quote character  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withQuote(Character)  */ public CsvDataFormat setQuote(Character quote) {     this.quote = quote.     return this. }
true;public;0;3;/**  * Gets the quote mode.  * If {@code null} then the default one of the format used.  *  * @return Quote mode  */ ;/**  * Gets the quote mode.  * If {@code null} then the default one of the format used.  *  * @return Quote mode  */ public QuoteMode getQuoteMode() {     return quoteMode. }
true;public;1;4;/**  * Sets the quote mode.  * If {@code null} then the default one of the format used.  *  * @param quoteMode Quote mode  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withQuoteMode(org.apache.commons.csv.QuoteMode)  */ ;/**  * Sets the quote mode.  * If {@code null} then the default one of the format used.  *  * @param quoteMode Quote mode  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withQuoteMode(org.apache.commons.csv.QuoteMode)  */ public CsvDataFormat setQuoteMode(QuoteMode quoteMode) {     this.quoteMode = quoteMode.     return this. }
true;public;0;3;/**  * Indicates whether or not the record separator is disabled.  *  * @return {@code true} if the record separator disabled, {@code false} otherwise  */ ;/**  * Indicates whether or not the record separator is disabled.  *  * @return {@code true} if the record separator disabled, {@code false} otherwise  */ public boolean isRecordSeparatorDisabled() {     return recordSeparatorDisabled. }
true;public;1;4;/**  * Sets whether or not the record separator is disabled.  *  * @param recordSeparatorDisabled {@code true} if the record separator disabled, {@code false} otherwise  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withRecordSeparator(String)  */ ;/**  * Sets whether or not the record separator is disabled.  *  * @param recordSeparatorDisabled {@code true} if the record separator disabled, {@code false} otherwise  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withRecordSeparator(String)  */ public CsvDataFormat setRecordSeparatorDisabled(boolean recordSeparatorDisabled) {     this.recordSeparatorDisabled = recordSeparatorDisabled.     return this. }
true;public;0;3;/**  * Gets the record separator.  * If {@code null} then the default one of the format used.  *  * @return Record separator  */ ;/**  * Gets the record separator.  * If {@code null} then the default one of the format used.  *  * @return Record separator  */ public String getRecordSeparator() {     return recordSeparator. }
true;public;1;4;/**  * Sets the record separator.  * If {@code null} then the default one of the format used.  *  * @param recordSeparator Record separator  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withRecordSeparator(String)  */ ;/**  * Sets the record separator.  * If {@code null} then the default one of the format used.  *  * @param recordSeparator Record separator  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withRecordSeparator(String)  */ public CsvDataFormat setRecordSeparator(String recordSeparator) {     this.recordSeparator = recordSeparator.     return this. }
true;public;0;3;/**  * Indicates whether or not header record must be skipped.  * If {@code null} then the default value of the format used.  *  * @return Whether or not header record must be skipped  */ ;/**  * Indicates whether or not header record must be skipped.  * If {@code null} then the default value of the format used.  *  * @return Whether or not header record must be skipped  */ public Boolean getSkipHeaderRecord() {     return skipHeaderRecord. }
true;public;1;4;/**  * Sets whether or not header record must be skipped.  * If {@code null} then the default value of the format used.  *  * @param skipHeaderRecord Whether or not header record must be skipped  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withSkipHeaderRecord(boolean)  */ ;/**  * Sets whether or not header record must be skipped.  * If {@code null} then the default value of the format used.  *  * @param skipHeaderRecord Whether or not header record must be skipped  * @return Current {@code CsvDataFormat}, fluent API  * @see org.apache.commons.csv.CSVFormat#withSkipHeaderRecord(boolean)  */ public CsvDataFormat setSkipHeaderRecord(Boolean skipHeaderRecord) {     this.skipHeaderRecord = skipHeaderRecord.     return this. }
true;public;0;3;/**  * Indicates whether or not the unmarshalling should lazily load the records.  *  * @return {@code true} for lazy loading, {@code false} otherwise  */ ;/**  * Indicates whether or not the unmarshalling should lazily load the records.  *  * @return {@code true} for lazy loading, {@code false} otherwise  */ public boolean isLazyLoad() {     return lazyLoad. }
true;public;1;4;/**  * Indicates whether or not the unmarshalling should lazily load the records.  *  * @param lazyLoad {@code true} for lazy loading, {@code false} otherwise  * @return Current {@code CsvDataFormat}, fluent API  */ ;/**  * Indicates whether or not the unmarshalling should lazily load the records.  *  * @param lazyLoad {@code true} for lazy loading, {@code false} otherwise  * @return Current {@code CsvDataFormat}, fluent API  */ public CsvDataFormat setLazyLoad(boolean lazyLoad) {     this.lazyLoad = lazyLoad.     return this. }
true;public;0;3;/**  * Indicates whether or not the unmarshalling should produce maps instead of lists.  *  * @return {@code true} for maps, {@code false} for lists  */ ;/**  * Indicates whether or not the unmarshalling should produce maps instead of lists.  *  * @return {@code true} for maps, {@code false} for lists  */ public boolean isUseMaps() {     return useMaps. }
true;public;1;4;/**  * Sets whether or not the unmarshalling should produce maps instead of lists.  *  * @param useMaps {@code true} for maps, {@code false} for lists  * @return Current {@code CsvDataFormat}, fluent API  */ ;/**  * Sets whether or not the unmarshalling should produce maps instead of lists.  *  * @param useMaps {@code true} for maps, {@code false} for lists  * @return Current {@code CsvDataFormat}, fluent API  */ public CsvDataFormat setUseMaps(boolean useMaps) {     this.useMaps = useMaps.     return this. }
true;public;0;3;/**  * Indicates whether or not the unmarshalling should produce ordered maps instead of lists.  *  * @return {@code true} for maps, {@code false} for lists  */ ;/**  * Indicates whether or not the unmarshalling should produce ordered maps instead of lists.  *  * @return {@code true} for maps, {@code false} for lists  */ public boolean isUseOrderedMaps() {     return useOrderedMaps. }
true;public;1;4;/**  * Sets whether or not the unmarshalling should produce ordered maps instead of lists.  *  * @param useOrderedMaps {@code true} for maps, {@code false} for lists  * @return Current {@code CsvDataFormat}, fluent API  */ ;/**  * Sets whether or not the unmarshalling should produce ordered maps instead of lists.  *  * @param useOrderedMaps {@code true} for maps, {@code false} for lists  * @return Current {@code CsvDataFormat}, fluent API  */ public CsvDataFormat setUseOrderedMaps(boolean useOrderedMaps) {     this.useOrderedMaps = useOrderedMaps.     return this. }
true;public;0;3;/**  * Gets the record converter to use. If {@code null} then it will use {@link CsvDataFormat#isUseMaps()} for finding  * the proper converter.  *  * @return Record converter to use  */ ;/**  * Gets the record converter to use. If {@code null} then it will use {@link CsvDataFormat#isUseMaps()} for finding  * the proper converter.  *  * @return Record converter to use  */ public CsvRecordConverter<?> getRecordConverter() {     return recordConverter. }
true;public;1;4;/**  * Sets the record converter to use. If {@code null} then it will use {@link CsvDataFormat#isUseMaps()} for finding  * the proper converter.  *  * @param recordConverter Record converter to use  * @return Current {@code CsvDataFormat}, fluent API  */ ;/**  * Sets the record converter to use. If {@code null} then it will use {@link CsvDataFormat#isUseMaps()} for finding  * the proper converter.  *  * @param recordConverter Record converter to use  * @return Current {@code CsvDataFormat}, fluent API  */ public CsvDataFormat setRecordConverter(CsvRecordConverter<?> recordConverter) {     this.recordConverter = recordConverter.     return this. }
true;public;1;4;/**  * Sets whether or not to trim leading and trailing blanks.  * <p>  * If {@code null} then the default value of the format used.  * </p>  *  * @param trim whether or not to trim leading and trailing blanks.  *            <code>null</code> value allowed.  * @return Current {@code CsvDataFormat}, fluent API.  */ ;// endregion /**  * Sets whether or not to trim leading and trailing blanks.  * <p>  * If {@code null} then the default value of the format used.  * </p>  *  * @param trim whether or not to trim leading and trailing blanks.  *            <code>null</code> value allowed.  * @return Current {@code CsvDataFormat}, fluent API.  */ public CsvDataFormat setTrim(Boolean trim) {     this.trim = trim.     return this. }
true;public;0;3;/**  * Indicates whether or not to trim leading and trailing blanks.  *  * @return {@link Boolean#TRUE} if leading and trailing blanks should be  *         trimmed. {@link Boolean#FALSE} otherwise. Could return  *         <code>null</code> if value has NOT been set.  */ ;/**  * Indicates whether or not to trim leading and trailing blanks.  *  * @return {@link Boolean#TRUE} if leading and trailing blanks should be  *         trimmed. {@link Boolean#FALSE} otherwise. Could return  *         <code>null</code> if value has NOT been set.  */ public Boolean getTrim() {     return trim. }
true;public;1;4;/**  * Sets whether or not to ignore case when accessing header names.  * <p>  * If {@code null} then the default value of the format used.  * </p>  *  * @param ignoreHeaderCase whether or not to ignore case when accessing header names.  *            <code>null</code> value allowed.  * @return Current {@code CsvDataFormat}, fluent API.  */ ;/**  * Sets whether or not to ignore case when accessing header names.  * <p>  * If {@code null} then the default value of the format used.  * </p>  *  * @param ignoreHeaderCase whether or not to ignore case when accessing header names.  *            <code>null</code> value allowed.  * @return Current {@code CsvDataFormat}, fluent API.  */ public CsvDataFormat setIgnoreHeaderCase(Boolean ignoreHeaderCase) {     this.ignoreHeaderCase = ignoreHeaderCase.     return this. }
true;public;0;3;/**  * Indicates whether or not to ignore case when accessing header names.  *  * @return {@link Boolean#TRUE} if case should be ignored when accessing  *         header name. {@link Boolean#FALSE} otherwise. Could return  *         <code>null</code> if value has NOT been set.  */ ;/**  * Indicates whether or not to ignore case when accessing header names.  *  * @return {@link Boolean#TRUE} if case should be ignored when accessing  *         header name. {@link Boolean#FALSE} otherwise. Could return  *         <code>null</code> if value has NOT been set.  */ public Boolean getIgnoreHeaderCase() {     return ignoreHeaderCase. }
true;public;1;4;/**  * Sets whether or not to add a trailing delimiter.  * <p>  * If {@code null} then the default value of the format used.  * </p>  *  * @param trailingDelimiter whether or not to add a trailing delimiter.  * @return Current {@code CsvDataFormat}, fluent API.  */ ;/**  * Sets whether or not to add a trailing delimiter.  * <p>  * If {@code null} then the default value of the format used.  * </p>  *  * @param trailingDelimiter whether or not to add a trailing delimiter.  * @return Current {@code CsvDataFormat}, fluent API.  */ public CsvDataFormat setTrailingDelimiter(Boolean trailingDelimiter) {     this.trailingDelimiter = trailingDelimiter.     return this. }
true;public;0;3;/**  * Indicates whether or not to add a trailing delimiter.  *  * @return {@link Boolean#TRUE} if a trailing delimiter should be added.  *         {@link Boolean#FALSE} otherwise. Could return <code>null</code>  *         if value has NOT been set.  */ ;/**  * Indicates whether or not to add a trailing delimiter.  *  * @return {@link Boolean#TRUE} if a trailing delimiter should be added.  *         {@link Boolean#FALSE} otherwise. Could return <code>null</code>  *         if value has NOT been set.  */ public Boolean getTrailingDelimiter() {     return trailingDelimiter. }
