commented;modifiers;parameterAmount;loc;comment;code
true;public;1;25;/**  * Builds lines from words. Utilizes the same behaviour as office software:  * <ul>  *     <li>If word doesn't fit in current line, and current lines contains other words, then  *     it will be moved to new line.</td>  *     <li>Word doesn't fit in the line and line does not contain other words, then word will be  *     slitted, and split index will be on max amount of characters that fits in the line </li>  * </ul>  */ ;/**  * Builds lines from words. Utilizes the same behaviour as office software:  * <ul>  *     <li>If word doesn't fit in current line, and current lines contains other words, then  *     it will be moved to new line.</td>  *     <li>Word doesn't fit in the line and line does not contain other words, then word will be  *     slitted, and split index will be on max amount of characters that fits in the line </li>  * </ul>  */ @Override public Collection<String> buildLines(Collection<String> splittedText) throws IOException {     LinkedList<String> wordsList = new LinkedList<>(splittedText).     Collection<String> lines = new ArrayList<>().     LineBuilder currentLine = new LineBuilder().     float allowedLineWidth = getAllowedLineWidth().     while (!wordsList.isEmpty()) {         String word = wordsList.removeFirst().         if (isWordFitInCurrentLine(currentLine, word, allowedLineWidth)) {             currentLine.appendWord(word).             if (wordsList.isEmpty()) {                 lines.add(currentLine.buildLine()).             }         } else if (currentLine.getWordsCount() != 0) {             lines.add(currentLine.buildLine()).             wordsList.addFirst(word).         } else {             int splitIndex = findSplitIndex(word, allowedLineWidth).             currentLine.appendWord(word.substring(0, splitIndex)).             lines.add(currentLine.buildLine()).             wordsList.addFirst(word.substring(splitIndex)).         }     }     return lines. }
false;private;2;20;;private int findSplitIndex(String word, float allowedLineWidth) throws IOException {     // Using binary search algorithm to find max amount of characters that fit int the line.     int middle = word.length() >> 1.     int end = word.length().     int currentSplitIndex = 0.     do {         if (isLineFitInLineWidth(word.substring(0, middle), allowedLineWidth)) {             currentSplitIndex = middle.             middle += word.substring(middle, end).length() >> 1.         } else {             end = middle.             middle = currentSplitIndex + (word.substring(currentSplitIndex, middle).length() >> 1).         }     } while ((currentSplitIndex == -1) || !isSplitIndexFound(word, allowedLineWidth, currentSplitIndex)).     return currentSplitIndex. }
false;private;3;4;;private boolean isSplitIndexFound(String word, float allowedLineWidth, int currentSplitIndex) throws IOException {     return isLineFitInLineWidth(word.substring(0, currentSplitIndex), allowedLineWidth) && !isLineFitInLineWidth(word.substring(0, currentSplitIndex + 1), allowedLineWidth). }
false;private;3;4;;private boolean isWordFitInCurrentLine(LineBuilder currentLine, String word, float allowedLineWidth) throws IOException {     LineBuilder lineBuilder = currentLine.clone().appendWord(word).     return isLineFitInLineWidth(lineBuilder.buildLine(), allowedLineWidth). }
false;private;2;8;;private boolean isLineFitInLineWidth(String currentLine, float allowedLineWidth) throws IOException {     float fontWidth = PdfUtils.getFontWidth(currentLine, pdfConfiguration.getFont(), pdfConfiguration.getFontSize()).     return fontWidth <= allowedLineWidth. }
false;public;0;10;;public float getAllowedLineWidth() {     float result = pdfConfiguration.getPageSize().getWidth() - pdfConfiguration.getMarginLeft() - pdfConfiguration.getMarginRight().     if (result < MIN_CONTENT_WIDTH) {         throw new IllegalStateException(String.format("Allowed line width cannot be < %d, make sure" + " (marginLeft + marginRight) < pageSize", MIN_CONTENT_WIDTH)).     }     return result. }
false;public;1;5;;public LineBuilder appendWord(String word) {     line.append(word).append(" ").     wordsCount++.     return this. }
false;public;0;5;;public String buildLine() {     String line = this.line.toString().     reset().     return line. }
false;public;0;3;;public int getWordsCount() {     return wordsCount. }
false;private;0;4;;private void reset() {     line = new StringBuilder().     wordsCount = 0. }
false;public;0;3;;public LineBuilder clone() {     return new LineBuilder(this.line.toString(), this.wordsCount). }
false;public;0;4;;@Override public String toString() {     return ToStringBuilder.reflectionToString(this). }
