commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;7;;@Override protected void doStart() throws Exception {     if (logger == null) {         logger = createLogger().     }     ServiceHelper.startService(logger). }
false;protected;0;4;;@Override protected void doStop() throws Exception {     ServiceHelper.stopService(logger). }
false;public;1;5;;public void setLogger(Processor logger) {     this.logger = logger.     // the logger is the processor     setProcessor(this.logger). }
false;public;0;3;;public Processor getLogger() {     return logger. }
false;public;0;9;;@Override public Producer createProducer() throws Exception {     // ensure logger is created and started first     if (logger == null) {         logger = createLogger().     }     ServiceHelper.startService(logger).     return new LogProducer(this, logger). }
false;protected;0;4;;@Override protected String createEndpointUri() {     return "log:" + logger.toString(). }
true;protected;0;26;/**  * Creates the logger {@link Processor} to be used.  */ ;/**  * Creates the logger {@link Processor} to be used.  */ protected Processor createLogger() throws Exception {     Processor answer.     // setup a new logger here     CamelLogger camelLogger.     LoggingLevel loggingLevel = LoggingLevel.INFO.     if (level != null) {         loggingLevel = LoggingLevel.valueOf(level).     }     if (providedLogger == null) {         camelLogger = new CamelLogger(loggerName, loggingLevel, getMarker()).     } else {         camelLogger = new CamelLogger(providedLogger, loggingLevel, getMarker()).     }     if (getGroupSize() != null) {         answer = new ThroughputLogger(camelLogger, getGroupSize()).     } else if (getGroupInterval() != null) {         Boolean groupActiveOnly = getGroupActiveOnly() != null ? getGroupActiveOnly() : Boolean.TRUE.         Long groupDelay = getGroupDelay().         answer = new ThroughputLogger(camelLogger, this.getCamelContext(), getGroupInterval(), groupDelay, groupActiveOnly).     } else {         answer = new CamelLogProcessor(camelLogger, localFormatter, getMaskingFormatter(), getCamelContext().getLogListeners()).     }     // the logger is the processor     setProcessor(answer).     return answer. }
false;private;0;10;;private MaskingFormatter getMaskingFormatter() {     if (logMask != null ? logMask : getCamelContext().isLogMask()) {         MaskingFormatter formatter = getCamelContext().getRegistry().lookupByNameAndType(MaskingFormatter.CUSTOM_LOG_MASK_REF, MaskingFormatter.class).         if (formatter == null) {             formatter = new DefaultMaskingFormatter().         }         return formatter.     }     return null. }
true;public;0;3;/**  * Logging level to use.  * <p/>  * The default value is INFO.  */ ;/**  * Logging level to use.  * <p/>  * The default value is INFO.  */ public String getLevel() {     return level. }
true;public;1;3;/**  * Logging level to use.  * <p/>  * The default value is INFO.  */ ;/**  * Logging level to use.  * <p/>  * The default value is INFO.  */ public void setLevel(String level) {     this.level = level. }
true;public;0;3;/**  * An optional Marker name to use.  */ ;/**  * An optional Marker name to use.  */ public String getMarker() {     return marker. }
true;public;1;3;/**  * An optional Marker name to use.  */ ;/**  * An optional Marker name to use.  */ public void setMarker(String marker) {     this.marker = marker. }
true;public;0;3;/**  * An integer that specifies a group size for throughput logging.  */ ;/**  * An integer that specifies a group size for throughput logging.  */ public Integer getGroupSize() {     return groupSize. }
true;public;1;3;/**  * An integer that specifies a group size for throughput logging.  */ ;/**  * An integer that specifies a group size for throughput logging.  */ public void setGroupSize(Integer groupSize) {     this.groupSize = groupSize. }
true;public;0;3;/**  * If specified will group message stats by this time interval (in millis)  */ ;/**  * If specified will group message stats by this time interval (in millis)  */ public Long getGroupInterval() {     return groupInterval. }
true;public;1;3;/**  * If specified will group message stats by this time interval (in millis)  */ ;/**  * If specified will group message stats by this time interval (in millis)  */ public void setGroupInterval(Long groupInterval) {     this.groupInterval = groupInterval. }
true;public;0;3;/**  * If true, will hide stats when no new messages have been received for a time interval, if false, show stats regardless of message traffic.  */ ;/**  * If true, will hide stats when no new messages have been received for a time interval, if false, show stats regardless of message traffic.  */ public Boolean getGroupActiveOnly() {     return groupActiveOnly. }
true;public;1;3;/**  * If true, will hide stats when no new messages have been received for a time interval, if false, show stats regardless of message traffic.  */ ;/**  * If true, will hide stats when no new messages have been received for a time interval, if false, show stats regardless of message traffic.  */ public void setGroupActiveOnly(Boolean groupActiveOnly) {     this.groupActiveOnly = groupActiveOnly. }
true;public;0;3;/**  * Set the initial delay for stats (in millis)  */ ;/**  * Set the initial delay for stats (in millis)  */ public Long getGroupDelay() {     return groupDelay. }
true;public;1;3;/**  * Set the initial delay for stats (in millis)  */ ;/**  * Set the initial delay for stats (in millis)  */ public void setGroupDelay(Long groupDelay) {     this.groupDelay = groupDelay. }
false;public;0;3;;public ExchangeFormatter getLocalFormatter() {     return localFormatter. }
false;public;1;3;;public void setLocalFormatter(ExchangeFormatter localFormatter) {     this.localFormatter = localFormatter. }
false;public;0;3;;public Logger getProvidedLogger() {     return providedLogger. }
false;public;1;3;;public void setProvidedLogger(Logger providedLogger) {     this.providedLogger = providedLogger. }
true;public;0;3;/**  * The logger name to use  */ ;/**  * The logger name to use  */ public String getLoggerName() {     return loggerName. }
true;public;1;3;/**  * The logger name to use  */ ;/**  * The logger name to use  */ public void setLoggerName(String loggerName) {     this.loggerName = loggerName. }
false;public;0;3;;public Boolean getLogMask() {     return logMask. }
true;public;1;3;/**  * If true, mask sensitive information like password or passphrase in the log.  */ ;/**  * If true, mask sensitive information like password or passphrase in the log.  */ public void setLogMask(Boolean logMask) {     this.logMask = logMask. }
