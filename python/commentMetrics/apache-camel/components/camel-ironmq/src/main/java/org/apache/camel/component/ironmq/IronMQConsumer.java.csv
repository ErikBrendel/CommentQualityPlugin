commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;23;;@Override protected int poll() throws Exception {     // must reset for each poll     shutdownRunningTask = null.     pendingExchanges = 0.     try {         Messages messages = null.         log.trace("Receiving messages with request [messagePerPoll {}, timeout {}]...", getMaxMessagesPerPoll(), getEndpoint().getConfiguration().getTimeout()).         messages = this.ironQueue.reserve(getMaxMessagesPerPoll(), getEndpoint().getConfiguration().getTimeout(), getEndpoint().getConfiguration().getWait()).         log.trace("Received {} messages", messages.getSize()).         Queue<Exchange> exchanges = createExchanges(messages.getMessages()).         int noProcessed = processBatch(CastUtils.cast(exchanges)).         // delete all processed messages in one batch.         if (getEndpoint().getConfiguration().isBatchDelete()) {             log.trace("Batch deleting {} messages", messages.getSize()).             this.ironQueue.deleteMessages(messages).         }         return noProcessed.     } catch (EmptyQueueException e) {         return 0.     } }
false;protected;1;10;;protected Queue<Exchange> createExchanges(Message[] messages) {     log.trace("Received {} messages in this poll", messages.length).     Queue<Exchange> answer = new LinkedList<>().     for (Message message : messages) {         Exchange exchange = getEndpoint().createExchange(message).         answer.add(exchange).     }     return answer. }
false;public;1;3;;public void onComplete(Exchange exchange) {     processCommit(exchange, messageid, reservationId). }
false;public;1;3;;public void onFailure(Exchange exchange) {     processRollback(exchange). }
false;public;0;4;;@Override public String toString() {     return "IronMQConsumerOnCompletion". }
false;public;1;44;;@Override public int processBatch(Queue<Object> exchanges) throws Exception {     int total = exchanges.size().     for (int index = 0. index < total && isBatchAllowed(). index++) {         // only loop if we are started (allowed to run)         final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll()).         // add current index and total as properties         exchange.setProperty(Exchange.BATCH_INDEX, index).         exchange.setProperty(Exchange.BATCH_SIZE, total).         exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1).         // update pending number of exchanges         pendingExchanges = total - index - 1.         // if batchDelete is not enabled         if (!getEndpoint().getConfiguration().isBatchDelete()) {             exchange.addOnCompletion(new Synchronization() {                  final String reservationId = ExchangeHelper.getMandatoryHeader(exchange, IronMQConstants.MESSAGE_RESERVATION_ID, String.class).                  final String messageid = ExchangeHelper.getMandatoryHeader(exchange, IronMQConstants.MESSAGE_ID, String.class).                  public void onComplete(Exchange exchange) {                     processCommit(exchange, messageid, reservationId).                 }                  public void onFailure(Exchange exchange) {                     processRollback(exchange).                 }                  @Override                 public String toString() {                     return "IronMQConsumerOnCompletion".                 }             }).         }         log.trace("Processing exchange [{}]...", exchange).         getProcessor().process(exchange).     }     return total. }
true;protected;3;9;/**  * Strategy to delete the message after being processed.  *  * @param exchange the exchange  */ ;/**  * Strategy to delete the message after being processed.  *  * @param exchange the exchange  */ protected void processCommit(Exchange exchange, String messageid, String reservationId) {     try {         log.trace("Deleting message with messageId {} and reservationId {}...", messageid, reservationId).         this.ironQueue.deleteMessage(messageid, reservationId).         log.trace("Message deleted").     } catch (Exception e) {         getExceptionHandler().handleException("Error occurred during delete of message. This exception is ignored.", exchange, e).     } }
true;protected;1;8;/**  * Strategy when processing the exchange failed.  *  * @param exchange the exchange  */ ;/**  * Strategy when processing the exchange failed.  *  * @param exchange the exchange  */ protected void processRollback(Exchange exchange) {     Exception cause = exchange.getException().     if (cause != null) {         log.warn("Exchange failed, so rolling back message status: {}", exchange, cause).     } else {         log.warn("Exchange failed, so rolling back message status: {}", exchange).     } }
false;public;0;4;;@Override public IronMQEndpoint getEndpoint() {     return (IronMQEndpoint) super.getEndpoint(). }
