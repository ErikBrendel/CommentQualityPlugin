commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getDataFormatName() {     return "yaml-snakeyaml". }
false;public;3;6;;@Override public void marshal(final Exchange exchange, final Object graph, final OutputStream stream) throws Exception {     try (OutputStreamWriter osw = new OutputStreamWriter(stream, ExchangeHelper.getCharsetName(exchange))) {         getYaml(exchange.getContext()).dump(graph, osw).     } }
false;public;2;7;;@Override public Object unmarshal(final Exchange exchange, final InputStream stream) throws Exception {     try (InputStreamReader isr = new InputStreamReader(stream, ExchangeHelper.getCharsetName(exchange))) {         Class<?> unmarshalObjectType = unmarshalType != null ? unmarshalType : Object.class.         return getYaml(exchange.getContext()).loadAs(isr, unmarshalObjectType).     } }
false;protected;0;4;;@Override protected void doStart() throws Exception { // noop }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
false;protected;1;21;;protected Yaml getYaml(CamelContext context) {     Yaml yaml = null.     WeakReference<Yaml> ref = yamlCache.get().     if (ref != null) {         yaml = ref.get().     }     if (yaml == null) {         yaml = new Yaml(this.constructor.apply(context), this.representer.apply(context), this.dumperOptions.apply(context), this.resolver.apply(context)).         yamlCache.set(new WeakReference<>(yaml)).     }     return yaml. }
false;public;0;3;;public Function<CamelContext, BaseConstructor> getConstructor() {     return constructor. }
true;public;1;3;/**  * BaseConstructor to construct incoming documents.  */ ;/**  * BaseConstructor to construct incoming documents.  */ public void setConstructor(Function<CamelContext, BaseConstructor> constructor) {     this.constructor = constructor. }
false;public;0;3;;public Function<CamelContext, Representer> getRepresenter() {     return representer. }
true;public;1;3;/**  * Representer to emit outgoing objects.  */ ;/**  * Representer to emit outgoing objects.  */ public void setRepresenter(Function<CamelContext, Representer> representer) {     this.representer = representer. }
false;public;0;3;;public Function<CamelContext, DumperOptions> getDumperOptions() {     return dumperOptions. }
true;public;1;3;/**  * DumperOptions to configure outgoing objects.  */ ;/**  * DumperOptions to configure outgoing objects.  */ public void setDumperOptions(Function<CamelContext, DumperOptions> dumperOptions) {     this.dumperOptions = dumperOptions. }
false;public;0;3;;public Function<CamelContext, Resolver> getResolver() {     return resolver. }
true;public;1;3;/**  * Resolver to detect implicit type  */ ;/**  * Resolver to detect implicit type  */ public void setResolver(Function<CamelContext, Resolver> resolver) {     this.resolver = resolver. }
false;public;0;3;;public ClassLoader getClassLoader() {     return classLoader. }
true;public;1;3;/**  * Set a custom classloader  */ ;/**  * Set a custom classloader  */ public void setClassLoader(ClassLoader classLoader) {     this.classLoader = classLoader. }
false;public;0;3;;public Class<?> getUnmarshalType() {     return this.unmarshalType. }
true;public;1;4;/**  * Class of the object to be created  */ ;/**  * Class of the object to be created  */ public void setUnmarshalType(Class<?> unmarshalType) {     this.unmarshalType = unmarshalType.     addTypeFilters(TypeFilters.types(unmarshalType)). }
false;public;0;3;;public List<TypeDescription> getTypeDescriptions() {     return typeDescriptions. }
true;public;1;3;/**  * Make YAML aware how to parse a custom Class.  */ ;/**  * Make YAML aware how to parse a custom Class.  */ public void setTypeDescriptions(List<TypeDescription> typeDescriptions) {     this.typeDescriptions = new CopyOnWriteArrayList<>(typeDescriptions). }
false;public;1;7;;public void addTypeDescriptions(Collection<TypeDescription> typeDescriptions) {     if (this.typeDescriptions == null) {         this.typeDescriptions = new CopyOnWriteArrayList<>().     }     this.typeDescriptions.addAll(typeDescriptions). }
false;public;1;3;;public void addTypeDescriptions(TypeDescription... typeDescriptions) {     addTypeDescriptions(Arrays.asList(typeDescriptions)). }
false;public;2;7;;public void addTypeDescription(Class<?> type, Tag tag) {     if (this.typeDescriptions == null) {         this.typeDescriptions = new CopyOnWriteArrayList<>().     }     this.typeDescriptions.add(new TypeDescription(type, tag)). }
false;public;0;3;;public Map<Class<?>, Tag> getClassTags() {     return classTags. }
true;public;1;4;/**  * Define a tag for the <code>Class</code> to serialize.  */ ;/**  * Define a tag for the <code>Class</code> to serialize.  */ public void setClassTags(Map<Class<?>, Tag> classTags) {     this.classTags = new ConcurrentHashMap<>().     this.classTags.putAll(classTags). }
false;public;2;7;;public void addClassTags(Class<?> type, Tag tag) {     if (this.classTags == null) {         this.classTags = new ConcurrentHashMap<>().     }     this.classTags.put(type, tag). }
false;public;0;3;;public boolean isUseApplicationContextClassLoader() {     return useApplicationContextClassLoader. }
true;public;1;3;/**  * Use ApplicationContextClassLoader as custom ClassLoader  */ ;/**  * Use ApplicationContextClassLoader as custom ClassLoader  */ public void setUseApplicationContextClassLoader(boolean useApplicationContextClassLoader) {     this.useApplicationContextClassLoader = useApplicationContextClassLoader. }
false;public;0;3;;public boolean isPrettyFlow() {     return prettyFlow. }
true;public;1;3;/**  * Force the emitter to produce a pretty YAML document when using the flow  * style.  */ ;/**  * Force the emitter to produce a pretty YAML document when using the flow  * style.  */ public void setPrettyFlow(boolean prettyFlow) {     this.prettyFlow = prettyFlow. }
true;public;2;4;/**  * Convenience method to set class tag for bot <code>Constructor</code> and  * <code>Representer</code>  */ ;/**  * Convenience method to set class tag for bot <code>Constructor</code> and  * <code>Representer</code>  */ public void addTag(Class<?> type, Tag tag) {     addClassTags(type, tag).     addTypeDescription(type, tag). }
false;public;0;3;;public List<TypeFilter> getTypeFilters() {     return typeFilters. }
true;public;1;3;/**  * Set the types SnakeYAML is allowed to un-marshall  */ ;/**  * Set the types SnakeYAML is allowed to un-marshall  */ public void setTypeFilters(List<TypeFilter> typeFilters) {     this.typeFilters = new CopyOnWriteArrayList<>(typeFilters). }
false;public;1;7;;public void setTypeFilterDefinitions(List<String> typeFilterDefinitions) {     this.typeFilters = new CopyOnWriteArrayList<>().     for (String definition : typeFilterDefinitions) {         TypeFilters.valueOf(definition).ifPresent(this.typeFilters::add).     } }
false;public;1;7;;public void addTypeFilters(Collection<TypeFilter> typeFilters) {     if (this.typeFilters == null) {         this.typeFilters = new CopyOnWriteArrayList<>().     }     this.typeFilters.addAll(typeFilters). }
false;public;1;3;;public void addTypeFilters(TypeFilter... typeFilters) {     addTypeFilters(Arrays.asList(typeFilters)). }
false;public;0;3;;public boolean isAllowAnyType() {     return allowAnyType. }
true;public;1;3;/**  * Allow any class to be un-marshaled, same as setTypeFilters(TypeFilters.allowAll())  */ ;/**  * Allow any class to be un-marshaled, same as setTypeFilters(TypeFilters.allowAll())  */ public void setAllowAnyType(boolean allowAnyType) {     this.allowAnyType = allowAnyType. }
false;private;1;29;;// *************************** // Defaults // *************************** private BaseConstructor defaultConstructor(CamelContext context) {     ClassLoader yamlClassLoader = this.classLoader.     Collection<TypeFilter> yamlTypeFilters = this.typeFilters.     if (yamlClassLoader == null && useApplicationContextClassLoader) {         yamlClassLoader = context.getApplicationContextClassLoader().     }     if (allowAnyType) {         yamlTypeFilters = Collections.singletonList(TypeFilters.allowAll()).     }     BaseConstructor yamlConstructor.     if (yamlTypeFilters != null) {         yamlConstructor = yamlClassLoader != null ? typeFilterConstructor(yamlClassLoader, yamlTypeFilters) : typeFilterConstructor(yamlTypeFilters).     } else {         yamlConstructor = new SafeConstructor().     }     if (typeDescriptions != null && yamlConstructor instanceof Constructor) {         for (TypeDescription typeDescription : typeDescriptions) {             ((Constructor) yamlConstructor).addTypeDescription(typeDescription).         }     }     return yamlConstructor. }
false;private;1;11;;private Representer defaultRepresenter(CamelContext context) {     Representer yamlRepresenter = new Representer().     if (classTags != null) {         for (Map.Entry<Class<?>, Tag> entry : classTags.entrySet()) {             yamlRepresenter.addClassTag(entry.getKey(), entry.getValue()).         }     }     return yamlRepresenter. }
false;private;1;6;;private DumperOptions defaultDumperOptions(CamelContext context) {     DumperOptions yamlDumperOptions = new DumperOptions().     yamlDumperOptions.setPrettyFlow(prettyFlow).     return yamlDumperOptions. }
false;private;1;3;;private Resolver defaultResolver(CamelContext context) {     return new Resolver(). }
false;protected;1;8;;@Override protected Class<?> getClassForName(String name) throws ClassNotFoundException {     if (typeFilters.stream().noneMatch(f -> f.test(name))) {         throw new IllegalArgumentException("Type " + name + " is not allowed").     }     return super.getClassForName(name). }
false;private,static;1;12;;// *************************** // Constructors // *************************** private static Constructor typeFilterConstructor(final Collection<TypeFilter> typeFilters) {     return new Constructor() {          @Override         protected Class<?> getClassForName(String name) throws ClassNotFoundException {             if (typeFilters.stream().noneMatch(f -> f.test(name))) {                 throw new IllegalArgumentException("Type " + name + " is not allowed").             }             return super.getClassForName(name).         }     }. }
false;protected;1;8;;@Override protected Class<?> getClassForName(String name) throws ClassNotFoundException {     if (typeFilters.stream().noneMatch(f -> f.test(name))) {         throw new IllegalArgumentException("Type " + name + " is not allowed").     }     return super.getClassForName(name). }
false;private,static;2;12;;private static Constructor typeFilterConstructor(final ClassLoader classLoader, final Collection<TypeFilter> typeFilters) {     return new CustomClassLoaderConstructor(classLoader) {          @Override         protected Class<?> getClassForName(String name) throws ClassNotFoundException {             if (typeFilters.stream().noneMatch(f -> f.test(name))) {                 throw new IllegalArgumentException("Type " + name + " is not allowed").             }             return super.getClassForName(name).         }     }. }
