commented;modifiers;parameterAmount;loc;comment;code
false;public;2;55;;@Override public Source resolve(String href, String base) throws TransformerException {     // supports the empty href     if (ObjectHelper.isEmpty(href)) {         href = location.     }     if (ObjectHelper.isEmpty(href)) {         throw new TransformerException("include href is empty").     }     LOG.trace("Resolving URI with href: {} and base: {}", href, base).     String scheme = ResourceHelper.getScheme(href).     if (scheme != null) {         // need to compact paths for file/classpath as it can be relative paths using .. to go backwards         String hrefPath = StringHelper.after(href, scheme).         if ("file:".equals(scheme)) {             // compact path use file OS separator             href = scheme + FileUtil.compactPath(hrefPath).         } else if ("classpath:".equals(scheme)) {             // for classpath always use /             href = scheme + FileUtil.compactPath(hrefPath, '/').         }         LOG.debug("Resolving URI from {}: {}", scheme, href).         InputStream is.         try {             is = ResourceHelper.resolveMandatoryResourceAsInputStream(context, href).         } catch (IOException e) {             throw new TransformerException(e).         }         return new StreamSource(is, href).     }     // if href and location is the same, then its the initial resolve     if (href.equals(location)) {         String path = baseScheme + href.         return resolve(path, base).     }     // okay then its relative to the starting location from the XSLT importing this one     String path = FileUtil.onlyPath(base).     if (ObjectHelper.isEmpty(path)) {         path = baseScheme + href.         return resolve(path, base).     } else {         if (ResourceHelper.hasScheme(path)) {             path = path + "/" + href.         } else {             path = baseScheme + path + "/" + href.         }         return resolve(path, base).     } }
