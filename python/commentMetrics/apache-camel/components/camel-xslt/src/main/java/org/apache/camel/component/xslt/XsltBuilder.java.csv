commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "XSLT[" + template + "]". }
false;public;1;51;;public void process(Exchange exchange) throws Exception {     notNull(getTemplate(), "template").     if (isDeleteOutputFile()) {         // add on completion so we can delete the file when the Exchange is done         String fileName = ExchangeHelper.getMandatoryHeader(exchange, Exchange.XSLT_FILE_NAME, String.class).         exchange.addOnCompletion(new XsltBuilderOnCompletion(fileName)).     }     Transformer transformer = getTransformer().     configureTransformer(transformer, exchange).     ResultHandler resultHandler = resultHandlerFactory.createResult(exchange).     Result result = resultHandler.getResult().     // let's copy the headers before we invoke the transform in case they modify them     Message out = exchange.getOut().     out.copyFrom(exchange.getIn()).     // the underlying input stream, which we need to close to avoid locking files or other resources     InputStream is = null.     try {         Source source.         // only convert to input stream if really needed         if (isInputStreamNeeded(exchange)) {             is = exchange.getIn().getBody(InputStream.class).             source = getSource(exchange, is).         } else {             Object body = exchange.getIn().getBody().             source = getSource(exchange, body).         }         if (source instanceof StAXSource) {             // Always convert StAXSource to SAXSource.             // * Xalan and Saxon-B don't support StAXSource.             // * The JDK default implementation (XSLTC) doesn't handle CDATA events             // (see com.sun.org.apache.xalan.internal.xsltc.trax.StAXStream2SAX).             // * Saxon-HE/PE/EE seem to support StAXSource, but don't advertise this             // officially (via TransformerFactory.getFeature(StAXSource.FEATURE))             source = new StAX2SAXSource(((StAXSource) source).getXMLStreamReader()).         }         LOG.trace("Using {} as source", source).         transformer.transform(source, result).         LOG.trace("Transform complete with result {}", result).         resultHandler.setBody(out).     } finally {         releaseTransformer(transformer).         // IOHelper can handle if is is null         IOHelper.close(is).     } }
true;public,static;1;3;/**  * Creates an XSLT processor using the given templates instance  */ ;// Builder methods // ------------------------------------------------------------------------- /**  * Creates an XSLT processor using the given templates instance  */ public static XsltBuilder xslt(Templates templates) {     return new XsltBuilder(templates). }
true;public,static;1;6;/**  * Creates an XSLT processor using the given XSLT source  */ ;/**  * Creates an XSLT processor using the given XSLT source  */ public static XsltBuilder xslt(Source xslt) throws TransformerConfigurationException {     notNull(xslt, "xslt").     XsltBuilder answer = new XsltBuilder().     answer.setTransformerSource(xslt).     return answer. }
true;public,static;1;4;/**  * Creates an XSLT processor using the given XSLT source  */ ;/**  * Creates an XSLT processor using the given XSLT source  */ public static XsltBuilder xslt(File xslt) throws TransformerConfigurationException {     notNull(xslt, "xslt").     return xslt(new StreamSource(xslt)). }
true;public,static;1;4;/**  * Creates an XSLT processor using the given XSLT source  */ ;/**  * Creates an XSLT processor using the given XSLT source  */ public static XsltBuilder xslt(URL xslt) throws TransformerConfigurationException, IOException {     notNull(xslt, "xslt").     return xslt(xslt.openStream()). }
true;public,static;1;4;/**  * Creates an XSLT processor using the given XSLT source  */ ;/**  * Creates an XSLT processor using the given XSLT source  */ public static XsltBuilder xslt(InputStream xslt) throws TransformerConfigurationException, IOException {     notNull(xslt, "xslt").     return xslt(new StreamSource(xslt)). }
true;public;0;4;/**  * Sets the output as being a byte[]  */ ;/**  * Sets the output as being a byte[]  */ public XsltBuilder outputBytes() {     setResultHandlerFactory(new StreamResultHandlerFactory()).     return this. }
true;public;0;4;/**  * Sets the output as being a String  */ ;/**  * Sets the output as being a String  */ public XsltBuilder outputString() {     setResultHandlerFactory(new StringResultHandlerFactory()).     return this. }
true;public;0;4;/**  * Sets the output as being a DOM  */ ;/**  * Sets the output as being a DOM  */ public XsltBuilder outputDOM() {     setResultHandlerFactory(new DomResultHandlerFactory()).     return this. }
true;public;0;4;/**  * Sets the output as being a File where the filename  * must be provided in the {@link Exchange#XSLT_FILE_NAME} header.  */ ;/**  * Sets the output as being a File where the filename  * must be provided in the {@link Exchange#XSLT_FILE_NAME} header.  */ public XsltBuilder outputFile() {     setResultHandlerFactory(new FileResultHandlerFactory()).     return this. }
true;public;0;4;/**  * Should the output file be deleted when the {@link Exchange} is done.  * <p/>  * This option should only be used if you use {@link #outputFile()} as well.  */ ;/**  * Should the output file be deleted when the {@link Exchange} is done.  * <p/>  * This option should only be used if you use {@link #outputFile()} as well.  */ public XsltBuilder deleteOutputFile() {     this.deleteOutputFile = true.     return this. }
false;public;2;4;;public XsltBuilder parameter(String name, Object value) {     parameters.put(name, value).     return this. }
true;public;1;4;/**  * Sets a custom URI resolver to be used  */ ;/**  * Sets a custom URI resolver to be used  */ public XsltBuilder uriResolver(URIResolver uriResolver) {     setUriResolver(uriResolver).     return this. }
true;public;0;4;/**  * Enables to allow using StAX.  * <p/>  * When enabled StAX is preferred as the first choice as {@link Source}.  */ ;/**  * Enables to allow using StAX.  * <p/>  * When enabled StAX is preferred as the first choice as {@link Source}.  */ public XsltBuilder allowStAX() {     setAllowStAX(true).     return this. }
true;public;1;8;/**  * Used for caching {@link Transformer}s.  * <p/>  * By default no caching is in use.  *  * @param numberToCache  the maximum number of transformers to cache  */ ;/**  * Used for caching {@link Transformer}s.  * <p/>  * By default no caching is in use.  *  * @param numberToCache  the maximum number of transformers to cache  */ public XsltBuilder transformerCacheSize(int numberToCache) {     if (numberToCache > 0) {         transformers = new ArrayBlockingQueue<>(numberToCache).     } else {         transformers = null.     }     return this. }
true;public;1;4;/**  * Uses a custom {@link javax.xml.transform.ErrorListener}.  */ ;/**  * Uses a custom {@link javax.xml.transform.ErrorListener}.  */ public XsltBuilder errorListener(ErrorListener errorListener) {     setErrorListener(errorListener).     return this. }
false;public;0;3;;// Properties // ------------------------------------------------------------------------- public Map<String, Object> getParameters() {     return parameters. }
false;public;1;3;;public void setParameters(Map<String, Object> parameters) {     this.parameters = parameters. }
false;public;1;6;;public void setTemplate(Templates template) {     this.template = template.     if (transformers != null) {         transformers.clear().     } }
false;public;0;3;;public Templates getTemplate() {     return template. }
false;public;0;3;;public boolean isFailOnNullBody() {     return failOnNullBody. }
false;public;1;3;;public void setFailOnNullBody(boolean failOnNullBody) {     this.failOnNullBody = failOnNullBody. }
false;public;0;3;;public ResultHandlerFactory getResultHandlerFactory() {     return resultHandlerFactory. }
false;public;1;3;;public void setResultHandlerFactory(ResultHandlerFactory resultHandlerFactory) {     this.resultHandlerFactory = resultHandlerFactory. }
false;public;0;3;;public boolean isAllowStAX() {     return allowStAX. }
false;public;1;3;;public void setAllowStAX(boolean allowStAX) {     this.allowStAX = allowStAX. }
true;public;1;24;/**  * Sets the XSLT transformer from a Source  *  * @param source  the source  * @throws TransformerConfigurationException is thrown if creating a XSLT transformer failed.  */ ;/**  * Sets the XSLT transformer from a Source  *  * @param source  the source  * @throws TransformerConfigurationException is thrown if creating a XSLT transformer failed.  */ public void setTransformerSource(Source source) throws TransformerConfigurationException {     TransformerFactory factory = converter.getTransformerFactory().     if (errorListener != null) {         factory.setErrorListener(errorListener).     } else {         // use a logger error listener so users can see from the logs what the error may be         factory.setErrorListener(new XsltErrorListener()).     }     if (getUriResolver() != null) {         factory.setURIResolver(getUriResolver()).     }     // Check that the call to newTemplates() returns a valid template instance.     // In case of an xslt parse error, it will return null and we should stop the     // deployment and raise an exception as the route will not be setup properly.     Templates templates = factory.newTemplates(source).     if (templates != null) {         setTemplate(templates).     } else {         throw new TransformerConfigurationException("Error creating XSLT template. " + "This is most likely be caused by a XML parse error. " + "Please verify your XSLT file configured.").     } }
true;public;1;3;/**  * Sets the XSLT transformer from a File  */ ;/**  * Sets the XSLT transformer from a File  */ public void setTransformerFile(File xslt) throws TransformerConfigurationException {     setTransformerSource(new StreamSource(xslt)). }
true;public;1;4;/**  * Sets the XSLT transformer from a URL  */ ;/**  * Sets the XSLT transformer from a URL  */ public void setTransformerURL(URL url) throws TransformerConfigurationException, IOException {     notNull(url, "url").     setTransformerInputStream(url.openStream()). }
true;public;1;4;/**  * Sets the XSLT transformer from the given input stream  */ ;/**  * Sets the XSLT transformer from the given input stream  */ public void setTransformerInputStream(InputStream in) throws TransformerConfigurationException, IOException {     notNull(in, "InputStream").     setTransformerSource(new StreamSource(in)). }
false;public;0;3;;public URIResolver getUriResolver() {     return uriResolver. }
false;public;1;3;;public void setUriResolver(URIResolver uriResolver) {     this.uriResolver = uriResolver. }
false;public;1;3;;public void setEntityResolver(EntityResolver entityResolver) {     this.entityResolver = entityResolver. }
false;public;0;3;;public boolean isDeleteOutputFile() {     return deleteOutputFile. }
false;public;1;3;;public void setDeleteOutputFile(boolean deleteOutputFile) {     this.deleteOutputFile = deleteOutputFile. }
false;public;0;3;;public ErrorListener getErrorListener() {     return errorListener. }
false;public;1;3;;public void setErrorListener(ErrorListener errorListener) {     this.errorListener = errorListener. }
true;public;1;3;// ------------------------------------------------------------------------- ;// Implementation methods // ------------------------------------------------------------------------- public void setTransformerFactory(TransformerFactory transformerFactory) {     this.converter.setTransformerFactory(transformerFactory). }
false;private;1;6;;private void releaseTransformer(Transformer transformer) {     if (transformers != null) {         transformer.reset().         transformers.offer(transformer).     } }
false;private;0;10;;private Transformer getTransformer() throws Exception {     Transformer t = null.     if (transformers != null) {         t = transformers.poll().     }     if (t == null) {         t = createTransformer().     }     return t. }
false;protected;0;3;;protected Transformer createTransformer() throws Exception {     return getTemplate().newTransformer(). }
true;protected;1;23;/**  * Checks whether we need an {@link InputStream} to access the message body.  * <p/>  * Depending on the content in the message body, we may not need to convert  * to {@link InputStream}.  *  * @param exchange the current exchange  * @return <tt>true</tt> to convert to {@link InputStream} beforehand converting to {@link Source} afterwards.  */ ;/**  * Checks whether we need an {@link InputStream} to access the message body.  * <p/>  * Depending on the content in the message body, we may not need to convert  * to {@link InputStream}.  *  * @param exchange the current exchange  * @return <tt>true</tt> to convert to {@link InputStream} beforehand converting to {@link Source} afterwards.  */ protected boolean isInputStreamNeeded(Exchange exchange) {     Object body = exchange.getIn().getBody().     if (body == null) {         return false.     }     if (body instanceof InputStream) {         return true.     } else if (body instanceof Source) {         return false.     } else if (body instanceof String) {         return false.     } else if (body instanceof byte[]) {         return false.     } else if (body instanceof Node) {         return false.     } else if (exchange.getContext().getTypeConverterRegistry().lookup(Source.class, body.getClass()) != null) {         // there is a direct and hopefully optimized converter to Source         return false.     }     // yes an input stream is needed     return true. }
true;protected;2;46;/**  * Converts the inbound body to a {@link Source}, if the body is <b>not</b> already a {@link Source}.  * <p/>  * This implementation will prefer to source in the following order:  * <ul>  *   <li>StAX - If StAX is allowed</li>  *   <li>SAX - SAX as 2nd choice</li>  *   <li>Stream - Stream as 3rd choice</li>  *   <li>DOM - DOM as 4th choice</li>  * </ul>  */ ;/**  * Converts the inbound body to a {@link Source}, if the body is <b>not</b> already a {@link Source}.  * <p/>  * This implementation will prefer to source in the following order:  * <ul>  *   <li>StAX - If StAX is allowed</li>  *   <li>SAX - SAX as 2nd choice</li>  *   <li>Stream - Stream as 3rd choice</li>  *   <li>DOM - DOM as 4th choice</li>  * </ul>  */ protected Source getSource(Exchange exchange, Object body) {     // body may already be a source     if (body instanceof Source) {         return (Source) body.     }     Source source = null.     if (body != null) {         if (isAllowStAX()) {             // try StAX if enabled             source = exchange.getContext().getTypeConverter().tryConvertTo(StAXSource.class, exchange, body).         }         if (source == null) {             // then try SAX             source = exchange.getContext().getTypeConverter().tryConvertTo(SAXSource.class, exchange, body).             tryAddEntityResolver((SAXSource) source).         }         if (source == null) {             // then try stream             source = exchange.getContext().getTypeConverter().tryConvertTo(StreamSource.class, exchange, body).         }         if (source == null) {             // and fallback to DOM             source = exchange.getContext().getTypeConverter().tryConvertTo(DOMSource.class, exchange, body).         }         // now we just put the call of source converter at last         if (source == null) {             TypeConverter tc = exchange.getContext().getTypeConverterRegistry().lookup(Source.class, body.getClass()).             if (tc != null) {                 source = tc.convertTo(Source.class, exchange, body).             }         }     }     if (source == null) {         if (isFailOnNullBody()) {             throw new ExpectedBodyTypeException(exchange, Source.class).         } else {             try {                 source = converter.toDOMSource(converter.createDocument()).             } catch (ParserConfigurationException | TransformerException e) {                 throw new RuntimeTransformException(e).             }         }     }     return source. }
false;private;1;6;;private void tryAddEntityResolver(SAXSource source) {     // expecting source to have not null XMLReader     if (this.entityResolver != null && source != null) {         source.getXMLReader().setEntityResolver(this.entityResolver).     } }
true;protected;2;21;/**  * Configures the transformer with exchange specific parameters  */ ;/**  * Configures the transformer with exchange specific parameters  */ protected void configureTransformer(Transformer transformer, Exchange exchange) throws Exception {     if (uriResolver == null) {         uriResolver = new XsltUriResolver(exchange.getContext(), null).     }     transformer.setURIResolver(uriResolver).     if (errorListener == null) {         // set our error listener so we can capture errors and report them back on the exchange         transformer.setErrorListener(new DefaultTransformErrorHandler(exchange)).     } else {         // use custom error listener         transformer.setErrorListener(errorListener).     }     transformer.clearParameters().     addParameters(transformer, exchange.getProperties()).     addParameters(transformer, exchange.getIn().getHeaders()).     addParameters(transformer, getParameters()).     transformer.setParameter("exchange", exchange).     transformer.setParameter("in", exchange.getIn()).     transformer.setParameter("out", exchange.getOut()). }
false;protected;2;11;;protected void addParameters(Transformer transformer, Map<String, Object> map) {     Set<Map.Entry<String, Object>> propertyEntries = map.entrySet().     for (Map.Entry<String, Object> entry : propertyEntries) {         String key = entry.getKey().         Object value = entry.getValue().         if (value != null) {             LOG.trace("Transformer set parameter {} -> {}", key, value).             transformer.setParameter(key, value).         }     } }
false;public;1;4;;@Override public void onDone(Exchange exchange) {     FileUtil.deleteFile(new File(fileName)). }
false;public;0;4;;@Override public String toString() {     return "XsltBuilderOnCompletion". }
