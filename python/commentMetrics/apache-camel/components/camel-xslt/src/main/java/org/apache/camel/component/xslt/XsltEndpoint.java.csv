commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@ManagedOperation(description = "Clears the cached XSLT stylesheet, forcing to re-load the stylesheet on next request") public void clearCachedStylesheet() {     this.cacheCleared = true. }
false;public;0;4;;@ManagedAttribute(description = "Whether the XSLT stylesheet is cached") public boolean isCacheStylesheet() {     return contentCache. }
false;public;2;5;;public XsltEndpoint findOrCreateEndpoint(String uri, String newResourceUri) {     String newUri = uri.replace(resourceUri, newResourceUri).     log.trace("Getting endpoint with URI: {}", newUri).     return getCamelContext().getEndpoint(newUri, XsltEndpoint.class). }
false;protected;1;7;;@Override protected void onExchange(Exchange exchange) throws Exception {     if (!contentCache || cacheCleared) {         loadResource(resourceUri).     }     super.onExchange(exchange). }
false;public;0;3;;public boolean isCacheCleared() {     return cacheCleared. }
false;public;1;3;;public void setCacheCleared(boolean cacheCleared) {     this.cacheCleared = cacheCleared. }
false;public;0;3;;public XsltBuilder getXslt() {     return xslt. }
false;public;1;3;;public void setXslt(XsltBuilder xslt) {     this.xslt = xslt. }
false;public;0;4;;@ManagedAttribute(description = "Path to the template") public String getResourceUri() {     return resourceUri. }
true;public;1;3;/**  * Path to the template.  * <p/>  * The following is supported by the default URIResolver.  * You can prefix with: classpath, file, http, ref, or bean.  * classpath, file and http loads the resource using these protocols (classpath is default).  * ref will lookup the resource in the registry.  * bean will call a method on a bean to be used as the resource.  * For bean you can specify the method name after dot, eg bean:myBean.myMethod  *  * @param resourceUri  the resource path  */ ;/**  * Path to the template.  * <p/>  * The following is supported by the default URIResolver.  * You can prefix with: classpath, file, http, ref, or bean.  * classpath, file and http loads the resource using these protocols (classpath is default).  * ref will lookup the resource in the registry.  * bean will call a method on a bean to be used as the resource.  * For bean you can specify the method name after dot, eg bean:myBean.myMethod  *  * @param resourceUri  the resource path  */ public void setResourceUri(String resourceUri) {     this.resourceUri = resourceUri. }
false;public;0;3;;public String getTransformerFactoryClass() {     return transformerFactoryClass. }
true;public;1;3;/**  * To use a custom XSLT transformer factory, specified as a FQN class name  */ ;/**  * To use a custom XSLT transformer factory, specified as a FQN class name  */ public void setTransformerFactoryClass(String transformerFactoryClass) {     this.transformerFactoryClass = transformerFactoryClass. }
false;public;0;3;;public TransformerFactory getTransformerFactory() {     return transformerFactory. }
true;public;1;3;/**  * To use a custom XSLT transformer factory  */ ;/**  * To use a custom XSLT transformer factory  */ public void setTransformerFactory(TransformerFactory transformerFactory) {     this.transformerFactory = transformerFactory. }
false;public;0;4;;@ManagedAttribute(description = "Whether to use Saxon as the transformerFactoryClass") public boolean isSaxon() {     return saxon. }
true;public;1;3;/**  * Whether to use Saxon as the transformerFactoryClass.  * If enabled then the class net.sf.saxon.TransformerFactoryImpl. You would need to add Saxon to the classpath.  */ ;/**  * Whether to use Saxon as the transformerFactoryClass.  * If enabled then the class net.sf.saxon.TransformerFactoryImpl. You would need to add Saxon to the classpath.  */ public void setSaxon(boolean saxon) {     this.saxon = saxon. }
false;public;0;3;;public List<Object> getSaxonExtensionFunctions() {     return saxonExtensionFunctions. }
true;public;1;3;/**  * Allows you to use a custom net.sf.saxon.lib.ExtensionFunctionDefinition.  * You would need to add camel-saxon to the classpath.  * The function is looked up in the registry, where you can comma to separate multiple values to lookup.  */ ;/**  * Allows you to use a custom net.sf.saxon.lib.ExtensionFunctionDefinition.  * You would need to add camel-saxon to the classpath.  * The function is looked up in the registry, where you can comma to separate multiple values to lookup.  */ public void setSaxonExtensionFunctions(List<Object> extensionFunctions) {     this.saxonExtensionFunctions = extensionFunctions. }
true;public;1;7;/**  * Allows you to use a custom net.sf.saxon.lib.ExtensionFunctionDefinition.  * You would need to add camel-saxon to the classpath.  * The function is looked up in the registry, where you can comma to separate multiple values to lookup.  */ ;/**  * Allows you to use a custom net.sf.saxon.lib.ExtensionFunctionDefinition.  * You would need to add camel-saxon to the classpath.  * The function is looked up in the registry, where you can comma to separate multiple values to lookup.  */ public void setSaxonExtensionFunctions(String extensionFunctions) {     this.saxonExtensionFunctions = EndpointHelper.resolveReferenceListParameter(getCamelContext(), extensionFunctions, Object.class). }
false;public;0;3;;public Object getSaxonConfiguration() {     return saxonConfiguration. }
true;public;1;3;/**  * To use a custom Saxon configuration  */ ;/**  * To use a custom Saxon configuration  */ public void setSaxonConfiguration(Object saxonConfiguration) {     this.saxonConfiguration = saxonConfiguration. }
false;public;0;3;;public Map<String, Object> getSaxonConfigurationProperties() {     return saxonConfigurationProperties. }
true;public;1;3;/**  * To set custom Saxon configuration properties  */ ;/**  * To set custom Saxon configuration properties  */ public void setSaxonConfigurationProperties(Map<String, Object> configurationProperties) {     this.saxonConfigurationProperties = configurationProperties. }
false;public;0;3;;public ResultHandlerFactory getResultHandlerFactory() {     return resultHandlerFactory. }
true;public;1;3;/**  * Allows you to use a custom org.apache.camel.builder.xml.ResultHandlerFactory which is capable of  * using custom org.apache.camel.builder.xml.ResultHandler types.  */ ;/**  * Allows you to use a custom org.apache.camel.builder.xml.ResultHandlerFactory which is capable of  * using custom org.apache.camel.builder.xml.ResultHandler types.  */ public void setResultHandlerFactory(ResultHandlerFactory resultHandlerFactory) {     this.resultHandlerFactory = resultHandlerFactory. }
false;public;0;4;;@ManagedAttribute(description = "Whether or not to throw an exception if the input body is null") public boolean isFailOnNullBody() {     return failOnNullBody. }
true;public;1;3;/**  * Whether or not to throw an exception if the input body is null.  */ ;/**  * Whether or not to throw an exception if the input body is null.  */ public void setFailOnNullBody(boolean failOnNullBody) {     this.failOnNullBody = failOnNullBody. }
false;public;0;4;;@ManagedAttribute(description = "What kind of option to use.") public XsltOutput getOutput() {     return output. }
true;public;1;3;/**  * Option to specify which output type to use.  * Possible values are: string, bytes, DOM, file. The first three options are all in memory based, where as file is streamed directly to a java.io.File.  * For file you must specify the filename in the IN header with the key Exchange.XSLT_FILE_NAME which is also CamelXsltFileName.  * Also any paths leading to the filename must be created beforehand, otherwise an exception is thrown at runtime.  */ ;/**  * Option to specify which output type to use.  * Possible values are: string, bytes, DOM, file. The first three options are all in memory based, where as file is streamed directly to a java.io.File.  * For file you must specify the filename in the IN header with the key Exchange.XSLT_FILE_NAME which is also CamelXsltFileName.  * Also any paths leading to the filename must be created beforehand, otherwise an exception is thrown at runtime.  */ public void setOutput(XsltOutput output) {     this.output = output. }
false;public;0;3;;public int getTransformerCacheSize() {     return transformerCacheSize. }
true;public;1;3;/**  * The number of javax.xml.transform.Transformer object that are cached for reuse to avoid calls to Template.newTransformer().  */ ;/**  * The number of javax.xml.transform.Transformer object that are cached for reuse to avoid calls to Template.newTransformer().  */ public void setTransformerCacheSize(int transformerCacheSize) {     this.transformerCacheSize = transformerCacheSize. }
false;public;0;3;;public ErrorListener getErrorListener() {     return errorListener. }
true;public;1;3;/**  *  Allows to configure to use a custom javax.xml.transform.ErrorListener. Beware when doing this then the default error  *  listener which captures any errors or fatal errors and store information on the Exchange as properties is not in use.  *  So only use this option for special use-cases.  */ ;/**  *  Allows to configure to use a custom javax.xml.transform.ErrorListener. Beware when doing this then the default error  *  listener which captures any errors or fatal errors and store information on the Exchange as properties is not in use.  *  So only use this option for special use-cases.  */ public void setErrorListener(ErrorListener errorListener) {     this.errorListener = errorListener. }
false;public;0;4;;@ManagedAttribute(description = "Cache for the resource content (the stylesheet file) when it is loaded.") public boolean isContentCache() {     return contentCache. }
true;public;1;3;/**  * Cache for the resource content (the stylesheet file) when it is loaded.  * If set to false Camel will reload the stylesheet file on each message processing. This is good for development.  * A cached stylesheet can be forced to reload at runtime via JMX using the clearCachedStylesheet operation.  */ ;/**  * Cache for the resource content (the stylesheet file) when it is loaded.  * If set to false Camel will reload the stylesheet file on each message processing. This is good for development.  * A cached stylesheet can be forced to reload at runtime via JMX using the clearCachedStylesheet operation.  */ public void setContentCache(boolean contentCache) {     this.contentCache = contentCache. }
false;public;0;3;;public URIResolver getUriResolver() {     return uriResolver. }
true;public;1;3;/**  * To use a custom javax.xml.transform.URIResolver  */ ;/**  * To use a custom javax.xml.transform.URIResolver  */ public void setUriResolver(URIResolver uriResolver) {     this.uriResolver = uriResolver. }
false;public;0;4;;@ManagedAttribute(description = "Whether to allow using StAX as the javax.xml.transform.Source") public boolean isAllowStAX() {     return allowStAX. }
true;public;1;3;/**  * Whether to allow using StAX as the javax.xml.transform.Source.  */ ;/**  * Whether to allow using StAX as the javax.xml.transform.Source.  */ public void setAllowStAX(boolean allowStAX) {     this.allowStAX = allowStAX. }
false;public;0;3;;public boolean isDeleteOutputFile() {     return deleteOutputFile. }
true;public;1;3;/**  * If you have output=file then this option dictates whether or not the output file should be deleted when the Exchange  * is done processing. For example suppose the output file is a temporary file, then it can be a good idea to delete it after use.  */ ;/**  * If you have output=file then this option dictates whether or not the output file should be deleted when the Exchange  * is done processing. For example suppose the output file is a temporary file, then it can be a good idea to delete it after use.  */ public void setDeleteOutputFile(boolean deleteOutputFile) {     this.deleteOutputFile = deleteOutputFile. }
false;public;0;3;;public EntityResolver getEntityResolver() {     return entityResolver. }
true;public;1;3;/**  * To use a custom org.xml.sax.EntityResolver with javax.xml.transform.sax.SAXSource.  */ ;/**  * To use a custom org.xml.sax.EntityResolver with javax.xml.transform.sax.SAXSource.  */ public void setEntityResolver(EntityResolver entityResolver) {     this.entityResolver = entityResolver. }
false;public;0;3;;public Map<String, Object> getParameters() {     return parameters. }
true;public;1;3;/**  * Additional parameters to configure on the javax.xml.transform.Transformer.  */ ;/**  * Additional parameters to configure on the javax.xml.transform.Transformer.  */ public void setParameters(Map<String, Object> parameters) {     this.parameters = parameters. }
true;protected;1;11;/**  * Loads the resource.  *  * @param resourceUri  the resource to load  * @throws TransformerException is thrown if error loading resource  * @throws IOException is thrown if error loading resource  */ ;/**  * Loads the resource.  *  * @param resourceUri  the resource to load  * @throws TransformerException is thrown if error loading resource  * @throws IOException is thrown if error loading resource  */ protected void loadResource(String resourceUri) throws TransformerException, IOException {     log.trace("{} loading schema resource: {}", this, resourceUri).     Source source = xslt.getUriResolver().resolve(resourceUri, null).     if (source == null) {         throw new IOException("Cannot load schema resource " + resourceUri).     } else {         xslt.setTransformerSource(source).     }     // now loaded so clear flag     cacheCleared = false. }
false;protected;0;63;;@Override protected void doStart() throws Exception {     super.doStart().     final CamelContext ctx = getCamelContext().     final ClassResolver resolver = ctx.getClassResolver().     final Injector injector = ctx.getInjector().     log.debug("{} using schema resource: {}", this, resourceUri).     this.xslt = injector.newInstance(XsltBuilder.class).     boolean useSaxon = false.     if (transformerFactoryClass == null && (saxon || saxonExtensionFunctions != null)) {         useSaxon = true.         transformerFactoryClass = SAXON_TRANSFORMER_FACTORY_CLASS_NAME.     }     TransformerFactory factory = transformerFactory.     if (factory == null && transformerFactoryClass != null) {         // provide the class loader of this component to work in OSGi environments         Class<TransformerFactory> factoryClass = resolver.resolveMandatoryClass(transformerFactoryClass, TransformerFactory.class, XsltComponent.class.getClassLoader()).         log.debug("Using TransformerFactoryClass {}", factoryClass).         factory = injector.newInstance(factoryClass).         if (useSaxon) {             XsltHelper.registerSaxonConfiguration(ctx, factoryClass, factory, saxonConfiguration).             XsltHelper.registerSaxonConfigurationProperties(ctx, factoryClass, factory, saxonConfigurationProperties).             XsltHelper.registerSaxonExtensionFunctions(ctx, factoryClass, factory, saxonExtensionFunctions).         }     }     if (factory != null) {         log.debug("Using TransformerFactory {}", factory).         xslt.setTransformerFactory(factory).     }     if (resultHandlerFactory != null) {         xslt.setResultHandlerFactory(resultHandlerFactory).     }     if (errorListener != null) {         xslt.errorListener(errorListener).     }     xslt.setFailOnNullBody(failOnNullBody).     xslt.transformerCacheSize(transformerCacheSize).     xslt.setUriResolver(uriResolver).     xslt.setEntityResolver(entityResolver).     xslt.setAllowStAX(allowStAX).     xslt.setDeleteOutputFile(deleteOutputFile).     configureOutput(xslt, output.name()).     // any additional transformer parameters then make a copy to avoid side-effects     if (parameters != null) {         Map<String, Object> copy = new HashMap<>(parameters).         xslt.setParameters(copy).     }     // must load resource first which sets a template and do a stylesheet compilation to catch errors early     loadResource(resourceUri).     // the processor is the xslt builder     setProcessor(xslt). }
false;protected;2;17;;protected void configureOutput(XsltBuilder xslt, String output) throws Exception {     if (ObjectHelper.isEmpty(output)) {         return.     }     if ("string".equalsIgnoreCase(output)) {         xslt.outputString().     } else if ("bytes".equalsIgnoreCase(output)) {         xslt.outputBytes().     } else if ("DOM".equalsIgnoreCase(output)) {         xslt.outputDOM().     } else if ("file".equalsIgnoreCase(output)) {         xslt.outputFile().     } else {         throw new IllegalArgumentException("Unknown output type: " + output).     } }
false;protected;0;5;;@Override protected void doStop() throws Exception {     super.doStop().     ServiceHelper.stopService(xslt). }
