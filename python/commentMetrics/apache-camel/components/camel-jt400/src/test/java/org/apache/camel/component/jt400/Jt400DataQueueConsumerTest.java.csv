commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;@Before public void setUp() throws Exception {     // Load endpoint URI     InputStream is = getClass().getResourceAsStream("jt400test.properties").     Properties props = new Properties().     String endpointURI.     props.load(is).     endpointURI = props.getProperty("org.apache.camel.component.jt400.emptydtaq.uri").     // Instantiate consumer     CamelContext camel = new DefaultCamelContext().     Jt400Component component = new Jt400Component().     component.setCamelContext(camel).     consumer = (Jt400DataQueueConsumer) component.createEndpoint(endpointURI).createPollingConsumer().     camel.start(). }
true;public;0;4;/**  * Tests whether <code>receive(long)</code> honours the <code>timeout</code> parameter.  */ ;/**  * Tests whether <code>receive(long)</code> honours the <code>timeout</code> parameter.  */ @Test(timeout = TIMEOUT_VALUE + TIMEOUT_TOLERANCE) public void testReceiveLong() {     consumer.receive(TIMEOUT_VALUE). }
false;public;0;4;;public void run() {     consumer.receive().     receiveFlag = true. }
true;public;0;19;/**  * Tests whether receive() blocks indefinitely.  */ ;/**  * Tests whether receive() blocks indefinitely.  */ @Test public void testReceive() throws InterruptedException {     new Thread(new Runnable() {          public void run() {             consumer.receive().             receiveFlag = true.         }     }).start().     final long startTime = System.currentTimeMillis().     while (!receiveFlag) {         if ((System.currentTimeMillis() - startTime) > BLOCKING_THRESHOLD) {             /* Passed test. */             return.         }         Thread.sleep(50L).     }     assertTrue("Method receive() has returned from call.", false). }
