commented;modifiers;parameterAmount;loc;comment;code
true;public;0;13;/**  * Returns a copy of this configuration  */ ;/**  * Returns a copy of this configuration  */ public NettyConfiguration copy() {     try {         NettyConfiguration answer = (NettyConfiguration) clone().         // make sure the lists is copied in its own instance         List<ChannelHandler> encodersCopy = new ArrayList<>(encoders).         answer.setEncoders(encodersCopy).         List<ChannelHandler> decodersCopy = new ArrayList<>(decoders).         answer.setDecoders(decodersCopy).         return answer.     } catch (CloneNotSupportedException e) {         throw new RuntimeCamelException(e).     } }
false;public;0;30;;public void validateConfiguration() {     // validate that the encoders is either shareable or is a handler factory     for (ChannelHandler encoder : encoders) {         if (encoder instanceof ChannelHandlerFactory) {             continue.         }         if (ObjectHelper.getAnnotation(encoder, ChannelHandler.Sharable.class) != null) {             continue.         }         LOG.warn("The encoder {} is not @Shareable or an ChannelHandlerFactory instance. The encoder cannot safely be used.", encoder).     }     // validate that the decoders is either shareable or is a handler factory     for (ChannelHandler decoder : decoders) {         if (decoder instanceof ChannelHandlerFactory) {             continue.         }         if (ObjectHelper.getAnnotation(decoder, ChannelHandler.Sharable.class) != null) {             continue.         }         LOG.warn("The decoder {} is not @Shareable or an ChannelHandlerFactory instance. The decoder cannot safely be used.", decoder).     }     if (sslHandler != null) {         boolean factory = sslHandler instanceof ChannelHandlerFactory.         boolean shareable = ObjectHelper.getAnnotation(sslHandler, ChannelHandler.Sharable.class) != null.         if (!factory && !shareable) {             LOG.warn("The sslHandler {} is not @Shareable or an ChannelHandlerFactory instance. The sslHandler cannot safely be used.", sslHandler).         }     } }
false;public;4;84;;public void parseURI(URI uri, Map<String, Object> parameters, NettyComponent component, String... supportedProtocols) throws Exception {     protocol = uri.getScheme().     boolean found = false.     for (String supportedProtocol : supportedProtocols) {         if (protocol != null && protocol.equalsIgnoreCase(supportedProtocol)) {             found = true.             break.         }     }     if (!found) {         throw new IllegalArgumentException("Unrecognized Netty protocol: " + protocol + " for uri: " + uri).     }     setHost(uri.getHost()).     if (uri.getPort() != -1) {         setPort(uri.getPort()).     }     ssl = component.getAndRemoveOrResolveReferenceParameter(parameters, "ssl", boolean.class, false).     sslHandler = component.getAndRemoveOrResolveReferenceParameter(parameters, "sslHandler", SslHandler.class, sslHandler).     passphrase = component.getAndRemoveOrResolveReferenceParameter(parameters, "passphrase", String.class, passphrase).     keyStoreFormat = component.getAndRemoveOrResolveReferenceParameter(parameters, "keyStoreFormat", String.class, keyStoreFormat == null ? "JKS" : keyStoreFormat).     securityProvider = component.getAndRemoveOrResolveReferenceParameter(parameters, "securityProvider", String.class, securityProvider == null ? "SunX509" : securityProvider).     keyStoreResource = uriRef(component, parameters, "keyStoreResource", keyStoreResource).     trustStoreResource = uriRef(component, parameters, "trustStoreResource", trustStoreResource).     clientInitializerFactory = component.getAndRemoveOrResolveReferenceParameter(parameters, "clientInitializerFactory", ClientInitializerFactory.class, clientInitializerFactory).     serverInitializerFactory = component.getAndRemoveOrResolveReferenceParameter(parameters, "serverInitializerFactory", ServerInitializerFactory.class, serverInitializerFactory).     // set custom encoders and decoders first     List<ChannelHandler> referencedEncoders = component.resolveAndRemoveReferenceListParameter(parameters, "encoders", ChannelHandler.class, null).     addToHandlersList(encoders, referencedEncoders, ChannelHandler.class).     List<ChannelHandler> referencedDecoders = component.resolveAndRemoveReferenceListParameter(parameters, "decoders", ChannelHandler.class, null).     addToHandlersList(decoders, referencedDecoders, ChannelHandler.class).     // then set parameters with the help of the camel context type converters     EndpointHelper.setReferenceProperties(component.getCamelContext(), this, parameters).     EndpointHelper.setProperties(component.getCamelContext(), this, parameters).     // additional netty options, we don't want to store an empty map, so set it as null if empty     options = IntrospectionSupport.extractProperties(parameters, "option.").     if (options != null && options.isEmpty()) {         options = null.     }     // add default encoders and decoders     if (encoders.isEmpty() && decoders.isEmpty()) {         if (isAllowDefaultCodec()) {             if ("udp".equalsIgnoreCase(protocol)) {                 encoders.add(ChannelHandlerFactories.newDatagramPacketEncoder()).             }             // are we textline or object?             if (isTextline()) {                 Charset charset = getEncoding() != null ? Charset.forName(getEncoding()) : CharsetUtil.UTF_8.                 encoders.add(ChannelHandlerFactories.newStringEncoder(charset, protocol)).                 ByteBuf[] delimiters = delimiter == TextLineDelimiter.LINE ? Delimiters.lineDelimiter() : Delimiters.nulDelimiter().                 decoders.add(ChannelHandlerFactories.newDelimiterBasedFrameDecoder(decoderMaxLineLength, delimiters, protocol)).                 decoders.add(ChannelHandlerFactories.newStringDecoder(charset, protocol)).                 if (LOG.isDebugEnabled()) {                     LOG.debug("Using textline encoders and decoders with charset: {}, delimiter: {} and decoderMaxLineLength: {}", new Object[] { charset, delimiter, decoderMaxLineLength }).                 }             } else if ("udp".equalsIgnoreCase(protocol) && isUdpByteArrayCodec()) {                 encoders.add(ChannelHandlerFactories.newByteArrayEncoder(protocol)).                 decoders.add(ChannelHandlerFactories.newByteArrayDecoder(protocol)).             } else {                 // object serializable is then used                 encoders.add(ChannelHandlerFactories.newObjectEncoder(protocol)).                 decoders.add(ChannelHandlerFactories.newObjectDecoder(protocol)).                 LOG.debug("Using object encoders and decoders").             }             if ("udp".equalsIgnoreCase(protocol)) {                 decoders.add(ChannelHandlerFactories.newDatagramPacketDecoder()).             }         } else {             LOG.debug("No encoders and decoders will be used").         }     } else {         LOG.debug("Using configured encoders and/or decoders").     } }
false;private;4;16;;private String uriRef(NettyComponent component, Map<String, Object> parameters, String key, String defaultValue) {     Object value = parameters.remove(key).     if (value == null) {         value = defaultValue.     } else if (value instanceof String && EndpointHelper.isReferenceParameter((String) value)) {         String name = StringHelper.replaceAll((String) value, "#", "").         value = CamelContextHelper.mandatoryLookup(component.getCamelContext(), name).     }     if (value instanceof File) {         return "file:" + value.toString().     } else if (value != null) {         return value.toString().     } else {         return null.     } }
false;public;0;10;;public String getCharsetName() {     if (encoding == null) {         return null.     }     if (!Charset.isSupported(encoding)) {         throw new IllegalArgumentException("The encoding: " + encoding + " is not supported").     }     return Charset.forName(encoding).name(). }
false;public;0;3;;public long getRequestTimeout() {     return requestTimeout. }
true;public;1;3;/**  * Allows to use a timeout for the Netty producer when calling a remote server.  * By default no timeout is in use. The value is in milli seconds, so eg 30000 is 30 seconds.  * The requestTimeout is using Netty's ReadTimeoutHandler to trigger the timeout.  */ ;/**  * Allows to use a timeout for the Netty producer when calling a remote server.  * By default no timeout is in use. The value is in milli seconds, so eg 30000 is 30 seconds.  * The requestTimeout is using Netty's ReadTimeoutHandler to trigger the timeout.  */ public void setRequestTimeout(long requestTimeout) {     this.requestTimeout = requestTimeout. }
false;public;0;3;;public boolean isSync() {     return sync. }
true;public;1;3;/**  * Setting to set endpoint as one-way or request-response  */ ;/**  * Setting to set endpoint as one-way or request-response  */ public void setSync(boolean sync) {     this.sync = sync. }
false;public;0;3;;public boolean isTextline() {     return textline. }
true;public;1;3;/**  * Only used for TCP. If no codec is specified, you can use this flag to indicate a text line based codec.  * if not specified or the value is false, then Object Serialization is assumed over TCP.  */ ;/**  * Only used for TCP. If no codec is specified, you can use this flag to indicate a text line based codec.  * if not specified or the value is false, then Object Serialization is assumed over TCP.  */ public void setTextline(boolean textline) {     this.textline = textline. }
false;public;0;3;;public int getDecoderMaxLineLength() {     return decoderMaxLineLength. }
true;public;1;3;/**  * The max line length to use for the textline codec.  */ ;/**  * The max line length to use for the textline codec.  */ public void setDecoderMaxLineLength(int decoderMaxLineLength) {     this.decoderMaxLineLength = decoderMaxLineLength. }
false;public;0;3;;public TextLineDelimiter getDelimiter() {     return delimiter. }
true;public;1;3;/**  * The delimiter to use for the textline codec. Possible values are LINE and NULL.  */ ;/**  * The delimiter to use for the textline codec. Possible values are LINE and NULL.  */ public void setDelimiter(TextLineDelimiter delimiter) {     this.delimiter = delimiter. }
false;public;0;3;;public boolean isAutoAppendDelimiter() {     return autoAppendDelimiter. }
true;public;1;3;/**  * Whether or not to auto append missing end delimiter when sending using the textline codec.  */ ;/**  * Whether or not to auto append missing end delimiter when sending using the textline codec.  */ public void setAutoAppendDelimiter(boolean autoAppendDelimiter) {     this.autoAppendDelimiter = autoAppendDelimiter. }
false;public;0;3;;public String getEncoding() {     return encoding. }
true;public;1;3;/**  * The encoding (a charset name) to use for the textline codec. If not provided, Camel will use the JVM default Charset.  */ ;/**  * The encoding (a charset name) to use for the textline codec. If not provided, Camel will use the JVM default Charset.  */ public void setEncoding(String encoding) {     this.encoding = encoding. }
false;public;0;3;;public List<ChannelHandler> getDecoders() {     return decoders. }
true;public;1;3;/**  * A list of decoders to be used.  * You can use a String which have values separated by comma, and have the values be looked up in the Registry.  * Just remember to prefix the value with # so Camel knows it should lookup.  */ ;/**  * A list of decoders to be used.  * You can use a String which have values separated by comma, and have the values be looked up in the Registry.  * Just remember to prefix the value with # so Camel knows it should lookup.  */ public void setDecoders(List<ChannelHandler> decoders) {     this.decoders = decoders. }
false;public;0;3;;public List<ChannelHandler> getEncoders() {     return encoders. }
true;public;1;3;/**  * A list of encoders to be used. You can use a String which have values separated by comma, and have the values be looked up in the Registry.  * Just remember to prefix the value with # so Camel knows it should lookup.  */ ;/**  * A list of encoders to be used. You can use a String which have values separated by comma, and have the values be looked up in the Registry.  * Just remember to prefix the value with # so Camel knows it should lookup.  */ public void setEncoders(List<ChannelHandler> encoders) {     this.encoders = encoders. }
false;public;0;3;;public ChannelHandler getEncoder() {     return encoders.isEmpty() ? null : encoders.get(0). }
true;public;1;5;/**  * A custom ChannelHandler class that can be used to perform special marshalling of outbound payloads.  */ ;/**  * A custom ChannelHandler class that can be used to perform special marshalling of outbound payloads.  */ public void setEncoder(ChannelHandler encoder) {     if (!encoders.contains(encoder)) {         encoders.add(encoder).     } }
false;public;0;3;;public ChannelHandler getDecoder() {     return decoders.isEmpty() ? null : decoders.get(0). }
true;public;1;5;/**  * A custom ChannelHandler class that can be used to perform special marshalling of inbound payloads.  */ ;/**  * A custom ChannelHandler class that can be used to perform special marshalling of inbound payloads.  */ public void setDecoder(ChannelHandler decoder) {     if (!decoders.contains(decoder)) {         decoders.add(decoder).     } }
false;public;0;3;;public boolean isDisconnect() {     return disconnect. }
true;public;1;3;/**  * Whether or not to disconnect(close) from Netty Channel right after use. Can be used for both consumer and producer.  */ ;/**  * Whether or not to disconnect(close) from Netty Channel right after use. Can be used for both consumer and producer.  */ public void setDisconnect(boolean disconnect) {     this.disconnect = disconnect. }
false;public;0;3;;public boolean isLazyChannelCreation() {     return lazyChannelCreation. }
true;public;1;3;/**  * Channels can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.  */ ;/**  * Channels can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.  */ public void setLazyChannelCreation(boolean lazyChannelCreation) {     this.lazyChannelCreation = lazyChannelCreation. }
false;public;0;3;;public boolean isTransferExchange() {     return transferExchange. }
true;public;1;3;/**  * Only used for TCP. You can transfer the exchange over the wire instead of just the body.  * The following fields are transferred: In body, Out body, fault body, In headers, Out headers, fault headers,  * exchange properties, exchange exception.  * This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.  */ ;/**  * Only used for TCP. You can transfer the exchange over the wire instead of just the body.  * The following fields are transferred: In body, Out body, fault body, In headers, Out headers, fault headers,  * exchange properties, exchange exception.  * This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.  */ public void setTransferExchange(boolean transferExchange) {     this.transferExchange = transferExchange. }
false;public;0;3;;public boolean isAllowSerializedHeaders() {     return allowSerializedHeaders. }
true;public;1;3;/**  * Only used for TCP when transferExchange is true. When set to true, serializable objects in headers and properties  * will be added to the exchange. Otherwise Camel will exclude any non-serializable objects and log it at WARN  * level.  */ ;/**  * Only used for TCP when transferExchange is true. When set to true, serializable objects in headers and properties  * will be added to the exchange. Otherwise Camel will exclude any non-serializable objects and log it at WARN  * level.  */ public void setAllowSerializedHeaders(final boolean allowSerializedHeaders) {     this.allowSerializedHeaders = allowSerializedHeaders. }
false;public;0;3;;public boolean isDisconnectOnNoReply() {     return disconnectOnNoReply. }
true;public;1;3;/**  * If sync is enabled then this option dictates NettyConsumer if it should disconnect where there is no reply to send back.  */ ;/**  * If sync is enabled then this option dictates NettyConsumer if it should disconnect where there is no reply to send back.  */ public void setDisconnectOnNoReply(boolean disconnectOnNoReply) {     this.disconnectOnNoReply = disconnectOnNoReply. }
false;public;0;3;;public LoggingLevel getNoReplyLogLevel() {     return noReplyLogLevel. }
true;public;1;3;/**  * If sync is enabled this option dictates NettyConsumer which logging level to use when logging a there is no reply to send back.  */ ;/**  * If sync is enabled this option dictates NettyConsumer which logging level to use when logging a there is no reply to send back.  */ public void setNoReplyLogLevel(LoggingLevel noReplyLogLevel) {     this.noReplyLogLevel = noReplyLogLevel. }
false;public;0;3;;public LoggingLevel getServerExceptionCaughtLogLevel() {     return serverExceptionCaughtLogLevel. }
true;public;1;3;/**  * If the server (NettyConsumer) catches an exception then its logged using this logging level.  */ ;/**  * If the server (NettyConsumer) catches an exception then its logged using this logging level.  */ public void setServerExceptionCaughtLogLevel(LoggingLevel serverExceptionCaughtLogLevel) {     this.serverExceptionCaughtLogLevel = serverExceptionCaughtLogLevel. }
false;public;0;3;;public LoggingLevel getServerClosedChannelExceptionCaughtLogLevel() {     return serverClosedChannelExceptionCaughtLogLevel. }
true;public;1;3;/**  * If the server (NettyConsumer) catches an java.nio.channels.ClosedChannelException then its logged using this logging level.  * This is used to avoid logging the closed channel exceptions, as clients can disconnect abruptly and then cause a flood of closed exceptions in the Netty server.  */ ;/**  * If the server (NettyConsumer) catches an java.nio.channels.ClosedChannelException then its logged using this logging level.  * This is used to avoid logging the closed channel exceptions, as clients can disconnect abruptly and then cause a flood of closed exceptions in the Netty server.  */ public void setServerClosedChannelExceptionCaughtLogLevel(LoggingLevel serverClosedChannelExceptionCaughtLogLevel) {     this.serverClosedChannelExceptionCaughtLogLevel = serverClosedChannelExceptionCaughtLogLevel. }
false;public;0;3;;public boolean isAllowDefaultCodec() {     return allowDefaultCodec. }
true;public;1;3;/**  * The netty component installs a default codec if both, encoder/decoder is null and textline is false.  * Setting allowDefaultCodec to false prevents the netty component from installing a default codec as the first element in the filter chain.  */ ;/**  * The netty component installs a default codec if both, encoder/decoder is null and textline is false.  * Setting allowDefaultCodec to false prevents the netty component from installing a default codec as the first element in the filter chain.  */ public void setAllowDefaultCodec(boolean allowDefaultCodec) {     this.allowDefaultCodec = allowDefaultCodec. }
true;public;1;4;/**  * @deprecated use #setClientInitializerFactory  */ ;/**  * @deprecated use #setClientInitializerFactory  */ @Deprecated public void setClientPipelineFactory(ClientInitializerFactory clientPipelineFactory) {     this.clientInitializerFactory = clientPipelineFactory. }
true;public;0;4;/**  * @deprecated use #getClientInitializerFactory  */ ;/**  * @deprecated use #getClientInitializerFactory  */ @Deprecated public ClientInitializerFactory getClientPipelineFactory() {     return clientInitializerFactory. }
false;public;0;3;;public ClientInitializerFactory getClientInitializerFactory() {     return clientInitializerFactory. }
true;public;1;3;/**  * To use a custom ClientInitializerFactory  */ ;/**  * To use a custom ClientInitializerFactory  */ public void setClientInitializerFactory(ClientInitializerFactory clientInitializerFactory) {     this.clientInitializerFactory = clientInitializerFactory. }
false;public;0;3;;public boolean isUsingExecutorService() {     return usingExecutorService. }
true;public;1;3;/**  * Whether to use ordered thread pool, to ensure events are processed orderly on the same channel.  */ ;/**  * Whether to use ordered thread pool, to ensure events are processed orderly on the same channel.  */ public void setUsingExecutorService(boolean usingExecutorService) {     this.usingExecutorService = usingExecutorService. }
false;public;0;3;;public int getProducerPoolMaxActive() {     return producerPoolMaxActive. }
true;public;1;3;/**  * Sets the cap on the number of objects that can be allocated by the pool  * (checked out to clients, or idle awaiting checkout) at a given time. Use a negative value for no limit.  */ ;/**  * Sets the cap on the number of objects that can be allocated by the pool  * (checked out to clients, or idle awaiting checkout) at a given time. Use a negative value for no limit.  */ public void setProducerPoolMaxActive(int producerPoolMaxActive) {     this.producerPoolMaxActive = producerPoolMaxActive. }
false;public;0;3;;public int getProducerPoolMinIdle() {     return producerPoolMinIdle. }
true;public;1;3;/**  * Sets the minimum number of instances allowed in the producer pool before the evictor thread (if active) spawns new objects.  */ ;/**  * Sets the minimum number of instances allowed in the producer pool before the evictor thread (if active) spawns new objects.  */ public void setProducerPoolMinIdle(int producerPoolMinIdle) {     this.producerPoolMinIdle = producerPoolMinIdle. }
false;public;0;3;;public int getProducerPoolMaxIdle() {     return producerPoolMaxIdle. }
true;public;1;3;/**  * Sets the cap on the number of "idle" instances in the pool.  */ ;/**  * Sets the cap on the number of "idle" instances in the pool.  */ public void setProducerPoolMaxIdle(int producerPoolMaxIdle) {     this.producerPoolMaxIdle = producerPoolMaxIdle. }
false;public;0;3;;public long getProducerPoolMinEvictableIdle() {     return producerPoolMinEvictableIdle. }
true;public;1;3;/**  * Sets the minimum amount of time (value in millis) an object may sit idle in the pool before it is eligible for eviction by the idle object evictor.  */ ;/**  * Sets the minimum amount of time (value in millis) an object may sit idle in the pool before it is eligible for eviction by the idle object evictor.  */ public void setProducerPoolMinEvictableIdle(long producerPoolMinEvictableIdle) {     this.producerPoolMinEvictableIdle = producerPoolMinEvictableIdle. }
false;public;0;3;;public boolean isProducerPoolEnabled() {     return producerPoolEnabled. }
true;public;1;3;/**  * Whether producer pool is enabled or not.  *  * Important: If you turn this off then a single shared connection is used for the producer, also if you are doing request/reply.  * That means there is a potential issue with interleaved responses if replies comes back out-of-order. Therefore you need to  * have a correlation id in both the request and reply messages so you can properly correlate the replies to the Camel callback  * that is responsible for continue processing the message in Camel. To do this you need to implement {@link NettyCamelStateCorrelationManager}  * as correlation manager and configure it via the <tt>correlationManager</tt> option.  * <p/>  * See also the <tt>correlationManager</tt> option for more details.  */ ;/**  * Whether producer pool is enabled or not.  *  * Important: If you turn this off then a single shared connection is used for the producer, also if you are doing request/reply.  * That means there is a potential issue with interleaved responses if replies comes back out-of-order. Therefore you need to  * have a correlation id in both the request and reply messages so you can properly correlate the replies to the Camel callback  * that is responsible for continue processing the message in Camel. To do this you need to implement {@link NettyCamelStateCorrelationManager}  * as correlation manager and configure it via the <tt>correlationManager</tt> option.  * <p/>  * See also the <tt>correlationManager</tt> option for more details.  */ public void setProducerPoolEnabled(boolean producerPoolEnabled) {     this.producerPoolEnabled = producerPoolEnabled. }
false;public;0;3;;public boolean isUdpConnectionlessSending() {     return udpConnectionlessSending. }
true;public;1;3;/**  * This option supports connection less udp sending which is a real fire and forget.  * A connected udp send receive the PortUnreachableException if no one is listen on the receiving port.  */ ;/**  * This option supports connection less udp sending which is a real fire and forget.  * A connected udp send receive the PortUnreachableException if no one is listen on the receiving port.  */ public void setUdpConnectionlessSending(boolean udpConnectionlessSending) {     this.udpConnectionlessSending = udpConnectionlessSending. }
false;public;0;3;;public boolean isClientMode() {     return clientMode. }
true;public;1;3;/**  * If the clientMode is true, netty consumer will connect the address as a TCP client.  */ ;/**  * If the clientMode is true, netty consumer will connect the address as a TCP client.  */ public void setClientMode(boolean clientMode) {     this.clientMode = clientMode. }
false;public;0;3;;public boolean isUseByteBuf() {     return useByteBuf. }
true;public;1;3;/**  * If the useByteBuf is true, netty producer will turn the message body into {@link ByteBuf} before sending it out.  */ ;/**  * If the useByteBuf is true, netty producer will turn the message body into {@link ByteBuf} before sending it out.  */ public void setUseByteBuf(boolean useByteBuf) {     this.useByteBuf = useByteBuf. }
false;public;0;3;;public boolean isUdpByteArrayCodec() {     return udpByteArrayCodec. }
true;public;1;3;/**  * For UDP only. If enabled the using byte array codec instead of Java serialization protocol.  */ ;/**  * For UDP only. If enabled the using byte array codec instead of Java serialization protocol.  */ public void setUdpByteArrayCodec(boolean udpByteArrayCodec) {     this.udpByteArrayCodec = udpByteArrayCodec. }
false;public;0;3;;public boolean isReuseChannel() {     return reuseChannel. }
true;public;1;3;/**  * This option allows producers and consumers (in client mode) to reuse the same Netty {@link Channel} for the lifecycle of processing the {@link Exchange}.  * This is useful if you need to call a server multiple times in a Camel route and want to use the same network connection.  * When using this, the channel is not returned to the connection pool until the {@link Exchange} is done. or disconnected  * if the disconnect option is set to true.  * <p/>  * The reused {@link Channel} is stored on the {@link Exchange} as an exchange property with the key {@link NettyConstants#NETTY_CHANNEL}  * which allows you to obtain the channel during routing and use it as well.  */ ;/**  * This option allows producers and consumers (in client mode) to reuse the same Netty {@link Channel} for the lifecycle of processing the {@link Exchange}.  * This is useful if you need to call a server multiple times in a Camel route and want to use the same network connection.  * When using this, the channel is not returned to the connection pool until the {@link Exchange} is done. or disconnected  * if the disconnect option is set to true.  * <p/>  * The reused {@link Channel} is stored on the {@link Exchange} as an exchange property with the key {@link NettyConstants#NETTY_CHANNEL}  * which allows you to obtain the channel during routing and use it as well.  */ public void setReuseChannel(boolean reuseChannel) {     this.reuseChannel = reuseChannel. }
false;public;0;3;;public NettyCamelStateCorrelationManager getCorrelationManager() {     return correlationManager. }
true;public;1;3;/**  * To use a custom correlation manager to manage how request and reply messages are mapped when using request/reply with the netty producer.  * This should only be used if you have a way to map requests together with replies such as if there is correlation ids in both the request  * and reply messages. This can be used if you want to multiplex concurrent messages on the same channel (aka connection) in netty. When doing  * this you must have a way to correlate the request and reply messages so you can store the right reply on the inflight Camel Exchange before  * its continued routed.  * <p/>  * We recommend extending the {@link TimeoutCorrelationManagerSupport} when you build custom correlation managers.  * This provides support for timeout and other complexities you otherwise would need to implement as well.  * <p/>  * See also the <tt>producerPoolEnabled</tt> option for more details.  */ ;/**  * To use a custom correlation manager to manage how request and reply messages are mapped when using request/reply with the netty producer.  * This should only be used if you have a way to map requests together with replies such as if there is correlation ids in both the request  * and reply messages. This can be used if you want to multiplex concurrent messages on the same channel (aka connection) in netty. When doing  * this you must have a way to correlate the request and reply messages so you can store the right reply on the inflight Camel Exchange before  * its continued routed.  * <p/>  * We recommend extending the {@link TimeoutCorrelationManagerSupport} when you build custom correlation managers.  * This provides support for timeout and other complexities you otherwise would need to implement as well.  * <p/>  * See also the <tt>producerPoolEnabled</tt> option for more details.  */ public void setCorrelationManager(NettyCamelStateCorrelationManager correlationManager) {     this.correlationManager = correlationManager. }
false;private,static;3;9;;private static <T> void addToHandlersList(List<T> configured, List<T> handlers, Class<T> handlerType) {     if (handlers != null) {         for (T handler : handlers) {             if (handlerType.isInstance(handler)) {                 configured.add(handler).             }         }     } }
