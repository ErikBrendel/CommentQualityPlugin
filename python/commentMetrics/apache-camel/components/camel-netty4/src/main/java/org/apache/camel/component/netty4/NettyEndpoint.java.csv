commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;public Consumer createConsumer(Processor processor) throws Exception {     Consumer answer = new NettyConsumer(this, processor, configuration).     configureConsumer(answer).     return answer. }
false;public;0;8;;public Producer createProducer() throws Exception {     Producer answer = new NettyProducer(this, configuration).     if (isSynchronous()) {         return new SynchronousDelegateProducer(answer).     } else {         return answer.     } }
false;public;2;6;;public Exchange createExchange(ChannelHandlerContext ctx, Object message) throws Exception {     Exchange exchange = createExchange().     updateMessageHeader(exchange.getIn(), ctx).     NettyPayloadHelper.setIn(exchange, message).     return exchange. }
false;public;0;3;;public boolean isSingleton() {     return true. }
false;public;0;4;;@Override public NettyComponent getComponent() {     return (NettyComponent) super.getComponent(). }
false;public;0;3;;public NettyConfiguration getConfiguration() {     return configuration. }
false;public;1;3;;public void setConfiguration(NettyConfiguration configuration) {     this.configuration = configuration. }
false;protected;0;5;;@Override protected String createEndpointUri() {     ObjectHelper.notNull(configuration, "configuration").     return "netty4:" + getConfiguration().getProtocol() + "://" + getConfiguration().getHost() + ":" + getConfiguration().getPort(). }
false;protected;1;8;;protected SSLSession getSSLSession(ChannelHandlerContext ctx) {     final SslHandler sslHandler = ctx.pipeline().get(SslHandler.class).     SSLSession sslSession = null.     if (sslHandler != null) {         sslSession = sslHandler.engine().getSession().     }     return sslSession. }
false;protected;2;16;;protected void updateMessageHeader(Message in, ChannelHandlerContext ctx) {     in.setHeader(NettyConstants.NETTY_CHANNEL_HANDLER_CONTEXT, ctx).     in.setHeader(NettyConstants.NETTY_REMOTE_ADDRESS, ctx.channel().remoteAddress()).     in.setHeader(NettyConstants.NETTY_LOCAL_ADDRESS, ctx.channel().localAddress()).     if (configuration.isSsl()) {         // setup the SslSession header         SSLSession sslSession = getSSLSession(ctx).         in.setHeader(NettyConstants.NETTY_SSL_SESSION, sslSession).         // enrich headers with details from the client certificate if option is enabled         if (configuration.isSslClientCertHeaders()) {             enrichWithClientCertInformation(sslSession, in).         }     } }
true;protected;2;25;/**  * Enriches the message with client certificate details such as subject name, serial number etc.  * <p/>  * If the certificate is unverified then the headers is not enriched.  *  * @param sslSession  the SSL session  * @param message     the message to enrich  */ ;/**  * Enriches the message with client certificate details such as subject name, serial number etc.  * <p/>  * If the certificate is unverified then the headers is not enriched.  *  * @param sslSession  the SSL session  * @param message     the message to enrich  */ protected void enrichWithClientCertInformation(SSLSession sslSession, Message message) {     try {         X509Certificate[] certificates = sslSession.getPeerCertificateChain().         if (certificates != null && certificates.length > 0) {             X509Certificate cert = certificates[0].             Principal subject = cert.getSubjectDN().             if (subject != null) {                 message.setHeader(NettyConstants.NETTY_SSL_CLIENT_CERT_SUBJECT_NAME, subject.getName()).             }             Principal issuer = cert.getIssuerDN().             if (issuer != null) {                 message.setHeader(NettyConstants.NETTY_SSL_CLIENT_CERT_ISSUER_NAME, issuer.getName()).             }             BigInteger serial = cert.getSerialNumber().             if (serial != null) {                 message.setHeader(NettyConstants.NETTY_SSL_CLIENT_CERT_SERIAL_NO, serial.toString()).             }             message.setHeader(NettyConstants.NETTY_SSL_CLIENT_CERT_NOT_BEFORE, cert.getNotBefore()).             message.setHeader(NettyConstants.NETTY_SSL_CLIENT_CERT_NOT_AFTER, cert.getNotAfter()).         }     } catch (SSLPeerUnverifiedException e) {     // ignore     } }
