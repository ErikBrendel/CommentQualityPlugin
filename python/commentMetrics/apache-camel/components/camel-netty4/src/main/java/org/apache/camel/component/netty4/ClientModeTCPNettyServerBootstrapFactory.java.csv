commented;modifiers;parameterAmount;loc;comment;code
false;public;3;5;;public void init(CamelContext camelContext, NettyServerBootstrapConfiguration configuration, ChannelInitializer<Channel> pipelineFactory) {     this.camelContext = camelContext.     this.configuration = configuration.     this.pipelineFactory = pipelineFactory. }
false;public;3;5;;public void init(ThreadFactory threadFactory, NettyServerBootstrapConfiguration configuration, ChannelInitializer<Channel> pipelineFactory) {     this.threadFactory = threadFactory.     this.configuration = configuration.     this.pipelineFactory = pipelineFactory. }
false;public;1;3;;public void addChannel(Channel channel) { // we don't need to track the channel in client mode }
false;public;1;3;;public void removeChannel(Channel channel) { // we don't need to track the channel in client mode }
false;public;1;3;;public void addConsumer(NettyConsumer consumer) { // does not allow sharing }
false;public;1;3;;public void removeConsumer(NettyConsumer consumer) { // does not allow sharing }
false;protected;0;7;;@Override protected void doStart() throws Exception {     if (camelContext == null && threadFactory == null) {         throw new IllegalArgumentException("Either CamelContext or ThreadFactory must be set on " + this).     }     startServerBootstrap(). }
false;protected;0;4;;@Override protected void doStop() throws Exception {     stopServerBootstrap(). }
false;protected;0;38;;protected void startServerBootstrap() throws Exception {     // prefer using explicit configured thread pools     EventLoopGroup wg = configuration.getWorkerGroup().     if (wg == null) {         // create new pool which we should shutdown when stopping as its not shared         workerGroup = new NettyWorkerPoolBuilder().withNativeTransport(configuration.isNativeTransport()).withWorkerCount(configuration.getWorkerCount()).withName("NettyServerTCPWorker").build().         wg = workerGroup.     }     clientBootstrap = new Bootstrap().     if (configuration.isNativeTransport()) {         clientBootstrap.channel(EpollSocketChannel.class).     } else {         clientBootstrap.channel(NioSocketChannel.class).     }     clientBootstrap.group(wg).     clientBootstrap.option(ChannelOption.SO_KEEPALIVE, configuration.isKeepAlive()).     clientBootstrap.option(ChannelOption.TCP_NODELAY, configuration.isTcpNoDelay()).     clientBootstrap.option(ChannelOption.SO_REUSEADDR, configuration.isReuseAddress()).     clientBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, configuration.getConnectTimeout()).     LOG.debug("Created ClientBootstrap {}", clientBootstrap).     clientBootstrap.handler(pipelineFactory).     ChannelFuture channelFuture = clientBootstrap.connect(new InetSocketAddress(configuration.getHost(), configuration.getPort())).     if (LOG.isDebugEnabled()) {         LOG.debug("Created new TCP client bootstrap connecting to {}:{} with options: {}", new Object[] { configuration.getHost(), configuration.getPort(), clientBootstrap }).     }     LOG.info("ClientModeServerBootstrap binding to {}:{}", configuration.getHost(), configuration.getPort()).     channel = openChannel(channelFuture). }
false;protected;0;9;;protected void stopServerBootstrap() {     // close all channels     LOG.info("ClientModeServerBootstrap unbinding from {}:{}", configuration.getHost(), configuration.getPort()).     if (workerGroup != null) {         workerGroup.shutdownGracefully().         workerGroup = null.     } }
false;protected;0;7;;protected void doReconnectIfNeeded() throws Exception {     if (channel == null || !channel.isActive()) {         LOG.debug("ClientModeServerBootstrap re-connect to {}:{}", configuration.getHost(), configuration.getPort()).         ChannelFuture connectFuture = clientBootstrap.connect(new InetSocketAddress(configuration.getHost(), configuration.getPort())).         channel = openChannel(connectFuture).     } }
false;public;1;4;;@Override public void operationComplete(ChannelFuture future) throws Exception {     scheduleReconnect(channelFuture). }
false;protected;1;40;;protected Channel openChannel(final ChannelFuture channelFuture) throws Exception {     // blocking for channel to be done     if (LOG.isTraceEnabled()) {         LOG.trace("Waiting for operation to complete {} for {} millis", channelFuture, configuration.getConnectTimeout()).     }     // wait for the channel to be open (see io.netty.channel.ChannelFuture javadoc for example/recommendation)     channelFuture.awaitUninterruptibly().     if (!channelFuture.isDone() || !channelFuture.isSuccess()) {         // check if reconnect is enabled and schedule a reconnect, if from handler then don't schedule a reconnect         if (configuration.isReconnect()) {             scheduleReconnect(channelFuture).             return null.         } else {             ConnectException cause = new ConnectException("Cannot connect to " + configuration.getAddress()).             if (channelFuture.cause() != null) {                 cause.initCause(channelFuture.cause()).             }             throw cause.         }     }     Channel answer = channelFuture.channel().     if (LOG.isDebugEnabled()) {         LOG.debug("Creating connector to address: {}", configuration.getAddress()).     }     // schedule a reconnect to happen when the channel closes     if (configuration.isReconnect()) {         answer.closeFuture().addListener(new ChannelFutureListener() {              @Override             public void operationComplete(ChannelFuture future) throws Exception {                 scheduleReconnect(channelFuture).             }         }).     }     return answer. }
false;public;0;10;;@Override public void run() {     try {         LOG.trace("Re-connecting to {} if needed", configuration.getAddress()).         doReconnectIfNeeded().     } catch (Exception e) {         LOG.warn("Error during re-connect to " + configuration.getAddress() + ". Will attempt again in " + configuration.getReconnectInterval() + " millis. This exception is ignored.", e).     } }
false;private;1;15;;private void scheduleReconnect(final ChannelFuture channelFuture) {     final EventLoop loop = channelFuture.channel().eventLoop().     loop.schedule(new Runnable() {          @Override         public void run() {             try {                 LOG.trace("Re-connecting to {} if needed", configuration.getAddress()).                 doReconnectIfNeeded().             } catch (Exception e) {                 LOG.warn("Error during re-connect to " + configuration.getAddress() + ". Will attempt again in " + configuration.getReconnectInterval() + " millis. This exception is ignored.", e).             }         }     }, configuration.getReconnectInterval(), TimeUnit.MILLISECONDS). }
