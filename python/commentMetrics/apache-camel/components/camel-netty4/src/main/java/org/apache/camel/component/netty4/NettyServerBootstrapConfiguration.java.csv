commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getAddress() {     return host + ":" + port. }
false;public;0;3;;public boolean isTcp() {     return protocol.equalsIgnoreCase("tcp"). }
false;public;0;3;;public String getProtocol() {     return protocol. }
true;public;1;3;/**  * The protocol to use which can be tcp or udp.  */ ;/**  * The protocol to use which can be tcp or udp.  */ public void setProtocol(String protocol) {     this.protocol = protocol. }
false;public;0;3;;public String getHost() {     return host. }
true;public;1;3;/**  * The hostname.  * <p/>  * For the consumer the hostname is localhost or 0.0.0.0.  * For the producer the hostname is the remote host to connect to  */ ;/**  * The hostname.  * <p/>  * For the consumer the hostname is localhost or 0.0.0.0.  * For the producer the hostname is the remote host to connect to  */ public void setHost(String host) {     this.host = host. }
false;public;0;3;;public int getPort() {     return port. }
true;public;1;3;/**  * The host port number  */ ;/**  * The host port number  */ public void setPort(int port) {     this.port = port. }
false;public;0;3;;public boolean isBroadcast() {     return broadcast. }
true;public;1;3;/**  * Setting to choose Multicast over UDP  */ ;/**  * Setting to choose Multicast over UDP  */ public void setBroadcast(boolean broadcast) {     this.broadcast = broadcast. }
false;public;0;3;;public int getSendBufferSize() {     return sendBufferSize. }
true;public;1;3;/**  * The TCP/UDP buffer sizes to be used during outbound communication. Size is bytes.  */ ;/**  * The TCP/UDP buffer sizes to be used during outbound communication. Size is bytes.  */ public void setSendBufferSize(int sendBufferSize) {     this.sendBufferSize = sendBufferSize. }
false;public;0;3;;public int getReceiveBufferSize() {     return receiveBufferSize. }
true;public;1;3;/**  * The TCP/UDP buffer sizes to be used during inbound communication. Size is bytes.  */ ;/**  * The TCP/UDP buffer sizes to be used during inbound communication. Size is bytes.  */ public void setReceiveBufferSize(int receiveBufferSize) {     this.receiveBufferSize = receiveBufferSize. }
false;public;0;3;;public int getReceiveBufferSizePredictor() {     return receiveBufferSizePredictor. }
true;public;1;3;/**  * Configures the buffer size predictor. See details at Jetty documentation and this mail thread.  */ ;/**  * Configures the buffer size predictor. See details at Jetty documentation and this mail thread.  */ public void setReceiveBufferSizePredictor(int receiveBufferSizePredictor) {     this.receiveBufferSizePredictor = receiveBufferSizePredictor. }
false;public;0;3;;public int getWorkerCount() {     return workerCount. }
true;public;1;3;/**  * When netty works on nio mode, it uses default workerCount parameter from Netty, which is cpu_core_threads x 2.  * User can use this operation to override the default workerCount from Netty.  */ ;/**  * When netty works on nio mode, it uses default workerCount parameter from Netty, which is cpu_core_threads x 2.  * User can use this operation to override the default workerCount from Netty.  */ public void setWorkerCount(int workerCount) {     this.workerCount = workerCount. }
false;public;0;3;;public int getBossCount() {     return bossCount. }
true;public;1;3;/**  * When netty works on nio mode, it uses default bossCount parameter from Netty, which is 1.  * User can use this operation to override the default bossCount from Netty  */ ;/**  * When netty works on nio mode, it uses default bossCount parameter from Netty, which is 1.  * User can use this operation to override the default bossCount from Netty  */ public void setBossCount(int bossCount) {     this.bossCount = bossCount. }
false;public;0;3;;public boolean isKeepAlive() {     return keepAlive. }
true;public;1;3;/**  * Setting to ensure socket is not closed due to inactivity  */ ;/**  * Setting to ensure socket is not closed due to inactivity  */ public void setKeepAlive(boolean keepAlive) {     this.keepAlive = keepAlive. }
false;public;0;3;;public boolean isTcpNoDelay() {     return tcpNoDelay. }
true;public;1;3;/**  * Setting to improve TCP protocol performance  */ ;/**  * Setting to improve TCP protocol performance  */ public void setTcpNoDelay(boolean tcpNoDelay) {     this.tcpNoDelay = tcpNoDelay. }
false;public;0;3;;public boolean isReuseAddress() {     return reuseAddress. }
true;public;1;3;/**  * Setting to facilitate socket multiplexing  */ ;/**  * Setting to facilitate socket multiplexing  */ public void setReuseAddress(boolean reuseAddress) {     this.reuseAddress = reuseAddress. }
false;public;0;3;;public int getConnectTimeout() {     return connectTimeout. }
true;public;1;3;/**  * Time to wait for a socket connection to be available. Value is in milliseconds.  */ ;/**  * Time to wait for a socket connection to be available. Value is in milliseconds.  */ public void setConnectTimeout(int connectTimeout) {     this.connectTimeout = connectTimeout. }
false;public;0;3;;public int getBacklog() {     return backlog. }
true;public;1;3;/**  * Allows to configure a backlog for netty consumer (server).  * Note the backlog is just a best effort depending on the OS.  * Setting this option to a value such as 200, 500 or 1000, tells the TCP stack how long the "accept" queue can be  * If this option is not configured, then the backlog depends on OS setting.  */ ;/**  * Allows to configure a backlog for netty consumer (server).  * Note the backlog is just a best effort depending on the OS.  * Setting this option to a value such as 200, 500 or 1000, tells the TCP stack how long the "accept" queue can be  * If this option is not configured, then the backlog depends on OS setting.  */ public void setBacklog(int backlog) {     this.backlog = backlog. }
false;public;0;3;;public boolean isSsl() {     return ssl. }
true;public;1;3;/**  * Setting to specify whether SSL encryption is applied to this endpoint  */ ;/**  * Setting to specify whether SSL encryption is applied to this endpoint  */ public void setSsl(boolean ssl) {     this.ssl = ssl. }
false;public;0;3;;public boolean isSslClientCertHeaders() {     return sslClientCertHeaders. }
true;public;1;3;/**  * When enabled and in SSL mode, then the Netty consumer will enrich the Camel Message with headers having  * information about the client certificate such as subject name, issuer name, serial number, and the valid date range.  */ ;/**  * When enabled and in SSL mode, then the Netty consumer will enrich the Camel Message with headers having  * information about the client certificate such as subject name, issuer name, serial number, and the valid date range.  */ public void setSslClientCertHeaders(boolean sslClientCertHeaders) {     this.sslClientCertHeaders = sslClientCertHeaders. }
false;public;0;3;;public SslHandler getSslHandler() {     return sslHandler. }
true;public;1;3;/**  * Reference to a class that could be used to return an SSL Handler  */ ;/**  * Reference to a class that could be used to return an SSL Handler  */ public void setSslHandler(SslHandler sslHandler) {     this.sslHandler = sslHandler. }
false;public;0;3;;public SSLContextParameters getSslContextParameters() {     return sslContextParameters. }
true;public;1;3;/**  * To configure security using SSLContextParameters  */ ;/**  * To configure security using SSLContextParameters  */ public void setSslContextParameters(SSLContextParameters sslContextParameters) {     this.sslContextParameters = sslContextParameters. }
false;public;0;3;;public boolean isNeedClientAuth() {     return needClientAuth. }
true;public;1;3;/**  * Configures whether the server needs client authentication when using SSL.  */ ;/**  * Configures whether the server needs client authentication when using SSL.  */ public void setNeedClientAuth(boolean needClientAuth) {     this.needClientAuth = needClientAuth. }
false;public;0;4;;@Deprecated public File getKeyStoreFile() {     return keyStoreFile. }
true;public;1;4;/**  * Client side certificate keystore to be used for encryption  */ ;/**  * Client side certificate keystore to be used for encryption  */ @Deprecated public void setKeyStoreFile(File keyStoreFile) {     this.keyStoreFile = keyStoreFile. }
false;public;0;4;;@Deprecated public File getTrustStoreFile() {     return trustStoreFile. }
true;public;1;4;/**  * Server side certificate keystore to be used for encryption  */ ;/**  * Server side certificate keystore to be used for encryption  */ @Deprecated public void setTrustStoreFile(File trustStoreFile) {     this.trustStoreFile = trustStoreFile. }
false;public;0;3;;public String getKeyStoreResource() {     return keyStoreResource. }
true;public;1;3;/**  * Client side certificate keystore to be used for encryption. Is loaded by default from classpath,  * but you can prefix with "classpath:", "file:", or "http:" to load the resource from different systems.  */ ;/**  * Client side certificate keystore to be used for encryption. Is loaded by default from classpath,  * but you can prefix with "classpath:", "file:", or "http:" to load the resource from different systems.  */ public void setKeyStoreResource(String keyStoreResource) {     this.keyStoreResource = keyStoreResource. }
false;public;0;3;;public String getTrustStoreResource() {     return trustStoreResource. }
true;public;1;3;/**  * Server side certificate keystore to be used for encryption.  * Is loaded by default from classpath, but you can prefix with "classpath:", "file:", or "http:" to load the resource from different systems.  */ ;/**  * Server side certificate keystore to be used for encryption.  * Is loaded by default from classpath, but you can prefix with "classpath:", "file:", or "http:" to load the resource from different systems.  */ public void setTrustStoreResource(String trustStoreResource) {     this.trustStoreResource = trustStoreResource. }
false;public;0;3;;public String getKeyStoreFormat() {     return keyStoreFormat. }
true;public;1;3;/**  * Keystore format to be used for payload encryption. Defaults to "JKS" if not set  */ ;/**  * Keystore format to be used for payload encryption. Defaults to "JKS" if not set  */ public void setKeyStoreFormat(String keyStoreFormat) {     this.keyStoreFormat = keyStoreFormat. }
false;public;0;3;;public String getSecurityProvider() {     return securityProvider. }
true;public;1;3;/**  * Security provider to be used for payload encryption. Defaults to "SunX509" if not set.  */ ;/**  * Security provider to be used for payload encryption. Defaults to "SunX509" if not set.  */ public void setSecurityProvider(String securityProvider) {     this.securityProvider = securityProvider. }
false;public;0;3;;public String getPassphrase() {     return passphrase. }
true;public;1;3;/**  * Password setting to use in order to encrypt/decrypt payloads sent using SSH  */ ;/**  * Password setting to use in order to encrypt/decrypt payloads sent using SSH  */ public void setPassphrase(String passphrase) {     this.passphrase = passphrase. }
true;public;0;4;/**  * @deprecated use #getServerInitializerFactory  */ ;/**  * @deprecated use #getServerInitializerFactory  */ @Deprecated public ServerInitializerFactory getServerPipelineFactory() {     return serverInitializerFactory. }
true;public;1;4;/**  * @deprecated use #setServerInitializerFactory  */ ;/**  * @deprecated use #setServerInitializerFactory  */ @Deprecated public void setServerPipelineFactory(ServerInitializerFactory serverPipelineFactory) {     this.serverInitializerFactory = serverPipelineFactory. }
false;public;0;3;;public ServerInitializerFactory getServerInitializerFactory() {     return serverInitializerFactory. }
true;public;1;3;/**  * To use a custom ServerInitializerFactory  */ ;/**  * To use a custom ServerInitializerFactory  */ public void setServerInitializerFactory(ServerInitializerFactory serverInitializerFactory) {     this.serverInitializerFactory = serverInitializerFactory. }
false;public;0;3;;public NettyServerBootstrapFactory getNettyServerBootstrapFactory() {     return nettyServerBootstrapFactory. }
true;public;1;3;/**  * To use a custom NettyServerBootstrapFactory  */ ;/**  * To use a custom NettyServerBootstrapFactory  */ public void setNettyServerBootstrapFactory(NettyServerBootstrapFactory nettyServerBootstrapFactory) {     this.nettyServerBootstrapFactory = nettyServerBootstrapFactory. }
false;public;0;3;;public Map<String, Object> getOptions() {     return options. }
true;public;1;3;/**  * Allows to configure additional netty options using "option." as prefix.  * For example "option.child.keepAlive=false" to set the netty option "child.keepAlive=false". See the Netty documentation for possible options that can be used.  */ ;/**  * Allows to configure additional netty options using "option." as prefix.  * For example "option.child.keepAlive=false" to set the netty option "child.keepAlive=false". See the Netty documentation for possible options that can be used.  */ public void setOptions(Map<String, Object> options) {     this.options = options. }
false;public;0;3;;public boolean isNativeTransport() {     return nativeTransport. }
true;public;1;3;/**  * Whether to use native transport instead of NIO. Native transport takes advantage of the host operating system and is only supported on some platforms.  * You need to add the netty JAR for the host operating system you are using. See more details at: http://netty.io/wiki/native-transports.html  */ ;/**  * Whether to use native transport instead of NIO. Native transport takes advantage of the host operating system and is only supported on some platforms.  * You need to add the netty JAR for the host operating system you are using. See more details at: http://netty.io/wiki/native-transports.html  */ public void setNativeTransport(boolean nativeTransport) {     this.nativeTransport = nativeTransport. }
false;public;0;3;;public EventLoopGroup getBossGroup() {     return bossGroup. }
true;public;1;3;/**  * Set the BossGroup which could be used for handling the new connection of the server side across the NettyEndpoint  */ ;/**  * Set the BossGroup which could be used for handling the new connection of the server side across the NettyEndpoint  */ public void setBossGroup(EventLoopGroup bossGroup) {     this.bossGroup = bossGroup. }
false;public;0;3;;public EventLoopGroup getWorkerGroup() {     return workerGroup. }
true;public;1;3;/**  * To use a explicit EventLoopGroup as the boss thread pool.  * For example to share a thread pool with multiple consumers or producers. By default each consumer or producer has their own worker pool with 2 x cpu count core threads.  */ ;/**  * To use a explicit EventLoopGroup as the boss thread pool.  * For example to share a thread pool with multiple consumers or producers. By default each consumer or producer has their own worker pool with 2 x cpu count core threads.  */ public void setWorkerGroup(EventLoopGroup workerGroup) {     this.workerGroup = workerGroup. }
false;public;0;3;;public ChannelGroup getChannelGroup() {     return channelGroup. }
true;public;1;3;/**  * To use a explicit ChannelGroup.  */ ;/**  * To use a explicit ChannelGroup.  */ public void setChannelGroup(ChannelGroup channelGroup) {     this.channelGroup = channelGroup. }
false;public;0;3;;public String getNetworkInterface() {     return networkInterface. }
true;public;1;3;/**  * When using UDP then this option can be used to specify a network interface by its name, such as eth0 to join a multicast group.  */ ;/**  * When using UDP then this option can be used to specify a network interface by its name, such as eth0 to join a multicast group.  */ public void setNetworkInterface(String networkInterface) {     this.networkInterface = networkInterface. }
false;public;0;3;;public String getEnabledProtocols() {     return enabledProtocols. }
true;public;1;3;/**  * Which protocols to enable when using SSL  */ ;/**  * Which protocols to enable when using SSL  */ public void setEnabledProtocols(String enabledProtocols) {     this.enabledProtocols = enabledProtocols. }
true;public;0;3;/**  * Used only in clientMode in consumer, the consumer will attempt to reconnect on disconnection if this is enabled  */ ;/**  * Used only in clientMode in consumer, the consumer will attempt to reconnect on disconnection if this is enabled  */ public boolean isReconnect() {     return reconnect. }
false;public;1;3;;public void setReconnect(boolean reconnect) {     this.reconnect = reconnect. }
true;public;0;3;/**  * Used if reconnect and clientMode is enabled. The interval in milli seconds to attempt reconnection  */ ;/**  * Used if reconnect and clientMode is enabled. The interval in milli seconds to attempt reconnection  */ public int getReconnectInterval() {     return reconnectInterval. }
false;public;1;3;;public void setReconnectInterval(int reconnectInterval) {     this.reconnectInterval = reconnectInterval. }
true;public;1;82;/**  * Checks if the other {@link NettyServerBootstrapConfiguration} is compatible  * with this, as a Netty listener bound on port X shares the same common  * {@link NettyServerBootstrapConfiguration}, which must be identical.  */ ;/**  * Checks if the other {@link NettyServerBootstrapConfiguration} is compatible  * with this, as a Netty listener bound on port X shares the same common  * {@link NettyServerBootstrapConfiguration}, which must be identical.  */ public boolean compatible(NettyServerBootstrapConfiguration other) {     boolean isCompatible = true.     if (!protocol.equals(other.protocol)) {         isCompatible = false.     } else if (!host.equals(other.host)) {         isCompatible = false.     } else if (port != other.port) {         isCompatible = false.     } else if (broadcast != other.broadcast) {         isCompatible = false.     } else if (sendBufferSize != other.sendBufferSize) {         return false.     } else if (receiveBufferSize != other.receiveBufferSize) {         isCompatible = false.     } else if (receiveBufferSizePredictor != other.receiveBufferSizePredictor) {         isCompatible = false.     } else if (workerCount != other.workerCount) {         isCompatible = false.     } else if (bossCount != other.bossCount) {         isCompatible = false.     } else if (keepAlive != other.keepAlive) {         isCompatible = false.     } else if (tcpNoDelay != other.tcpNoDelay) {         isCompatible = false.     } else if (reuseAddress != other.reuseAddress) {         isCompatible = false.     } else if (connectTimeout != other.connectTimeout) {         isCompatible = false.     } else if (backlog != other.backlog) {         isCompatible = false.     } else if (serverInitializerFactory != other.serverInitializerFactory) {         isCompatible = false.     } else if (nettyServerBootstrapFactory != other.nettyServerBootstrapFactory) {         isCompatible = false.     } else if (options == null && other.options != null) {         // validate all the options is identical         isCompatible = false.     } else if (options != null && other.options == null) {         isCompatible = false.     } else if (options != null && other.options != null && options.size() != other.options.size()) {         isCompatible = false.     } else if (options != null && other.options != null && !options.keySet().containsAll(other.options.keySet())) {         isCompatible = false.     } else if (options != null && other.options != null && !options.values().containsAll(other.options.values())) {         isCompatible = false.     } else if (ssl != other.ssl) {         isCompatible = false.     } else if (sslHandler != other.sslHandler) {         isCompatible = false.     } else if (sslContextParameters != other.sslContextParameters) {         isCompatible = false.     } else if (needClientAuth != other.needClientAuth) {         isCompatible = false.     } else if (keyStoreFile != other.keyStoreFile) {         isCompatible = false.     } else if (trustStoreFile != other.trustStoreFile) {         isCompatible = false.     } else if (keyStoreResource != null && !keyStoreResource.equals(other.keyStoreResource)) {         isCompatible = false.     } else if (trustStoreResource != null && !trustStoreResource.equals(other.trustStoreResource)) {         isCompatible = false.     } else if (keyStoreFormat != null && !keyStoreFormat.equals(other.keyStoreFormat)) {         isCompatible = false.     } else if (securityProvider != null && !securityProvider.equals(other.securityProvider)) {         isCompatible = false.     } else if (passphrase != null && !passphrase.equals(other.passphrase)) {         isCompatible = false.     } else if (bossGroup != other.bossGroup) {         isCompatible = false.     } else if (workerGroup != other.workerGroup) {         isCompatible = false.     } else if (networkInterface != null && !networkInterface.equals(other.networkInterface)) {         isCompatible = false.     } else if (reconnect != other.reconnect) {         isCompatible = false.     } else if (reconnectInterval != other.reconnectInterval) {         isCompatible = false.     }     return isCompatible. }
false;public;0;38;;public String toStringBootstrapConfiguration() {     return "NettyServerBootstrapConfiguration{" + "protocol='" + protocol + '\'' + ", host='" + host + '\'' + ", port=" + port + ", broadcast=" + broadcast + ", sendBufferSize=" + sendBufferSize + ", receiveBufferSize=" + receiveBufferSize + ", receiveBufferSizePredictor=" + receiveBufferSizePredictor + ", workerCount=" + workerCount + ", bossCount=" + bossCount + ", keepAlive=" + keepAlive + ", tcpNoDelay=" + tcpNoDelay + ", reuseAddress=" + reuseAddress + ", connectTimeout=" + connectTimeout + ", backlog=" + backlog + ", serverInitializerFactory=" + serverInitializerFactory + ", nettyServerBootstrapFactory=" + nettyServerBootstrapFactory + ", options=" + options + ", ssl=" + ssl + ", sslHandler=" + sslHandler + ", sslContextParameters='" + sslContextParameters + '\'' + ", needClientAuth=" + needClientAuth + ", enabledProtocols='" + enabledProtocols + ", keyStoreFile=" + keyStoreFile + ", trustStoreFile=" + trustStoreFile + ", keyStoreResource='" + keyStoreResource + '\'' + ", trustStoreResource='" + trustStoreResource + '\'' + ", keyStoreFormat='" + keyStoreFormat + '\'' + ", securityProvider='" + securityProvider + '\'' + ", passphrase='" + passphrase + '\'' + ", bossGroup=" + bossGroup + ", workerGroup=" + workerGroup + ", networkInterface='" + networkInterface + '\'' + ", reconnect='" + reconnect + '\'' + ", reconnectInterval='" + reconnectInterval + '\'' + '}'. }
