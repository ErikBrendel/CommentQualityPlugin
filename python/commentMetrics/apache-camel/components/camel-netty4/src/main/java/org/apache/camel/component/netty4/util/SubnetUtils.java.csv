commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns <code>true</code> if the return value of {@link SubnetInfo#getAddressCount()}  * includes the network and broadcast addresses.  * @since 2.2  * @return true if the hostcount includes the network and broadcast addresses  */ ;/**  * Returns <code>true</code> if the return value of {@link SubnetInfo#getAddressCount()}  * includes the network and broadcast addresses.  * @since 2.2  * @return true if the hostcount includes the network and broadcast addresses  */ public boolean isInclusiveHostCount() {     return inclusiveHostCount. }
true;public;1;3;/**  * Set to <code>true</code> if you want the return value of {@link SubnetInfo#getAddressCount()}  * to include the network and broadcast addresses.  * @param inclusiveHostCount true if network and broadcast addresses are to be included  * @since 2.2  */ ;/**  * Set to <code>true</code> if you want the return value of {@link SubnetInfo#getAddressCount()}  * to include the network and broadcast addresses.  * @param inclusiveHostCount true if network and broadcast addresses are to be included  * @since 2.2  */ public void setInclusiveHostCount(boolean inclusiveHostCount) {     this.inclusiveHostCount = inclusiveHostCount. }
false;private;0;3;;private int netmask() {     return netmask. }
false;private;0;3;;private int network() {     return network. }
false;private;0;3;;private int address() {     return address. }
false;private;0;3;;private int broadcast() {     return broadcast. }
true;private;0;3;// long versions of the values (as unsigned int) which are more suitable for range checking ;// long versions of the values (as unsigned int) which are more suitable for range checking private long networkLong() {     return network & UNSIGNED_INT_MASK. }
false;private;0;3;;private long broadcastLong() {     return broadcast & UNSIGNED_INT_MASK. }
false;private;0;4;;private int low() {     return isInclusiveHostCount() ? network() : broadcastLong() - networkLong() > 1 ? network() + 1 : 0. }
false;private;0;4;;private int high() {     return isInclusiveHostCount() ? broadcast() : broadcastLong() - networkLong() > 1 ? broadcast() - 1 : 0. }
true;public;1;8;/**  * Returns true if the parameter <code>address</code> is in the  * range of usable endpoint addresses for this subnet. This excludes the  * network and broadcast adresses.  * @param address A dot-delimited IPv4 address, e.g. "192.168.0.1"  * @return True if in range, false otherwise  */ ;/**  * Returns true if the parameter <code>address</code> is in the  * range of usable endpoint addresses for this subnet. This excludes the  * network and broadcast adresses.  * @param address A dot-delimited IPv4 address, e.g. "192.168.0.1"  * @return True if in range, false otherwise  */ public boolean isInRange(String address) {     Matcher matcher = ADDRESS_PATTERN.matcher(address).     if (matcher.matches()) {         return isInRange(toInteger(address)).     } else {         return false.     } }
false;private;1;6;;private boolean isInRange(int address) {     long addLong = address & UNSIGNED_INT_MASK.     long lowLong = low() & UNSIGNED_INT_MASK.     long highLong = high() & UNSIGNED_INT_MASK.     return addLong >= lowLong && addLong <= highLong. }
false;public;0;3;;public String getBroadcastAddress() {     return format(toArray(broadcast())). }
false;public;0;3;;public String getNetworkAddress() {     return format(toArray(network())). }
false;public;0;3;;public String getNetmask() {     return format(toArray(netmask())). }
false;public;0;3;;public String getAddress() {     return format(toArray(address())). }
true;public;0;3;/**  * Return the low address as a dotted IP address.  * Will be zero for CIDR/31 and CIDR/32 if the inclusive flag is false.  *  * @return the IP address in dotted format, may be "0.0.0.0" if there is no valid address  */ ;/**  * Return the low address as a dotted IP address.  * Will be zero for CIDR/31 and CIDR/32 if the inclusive flag is false.  *  * @return the IP address in dotted format, may be "0.0.0.0" if there is no valid address  */ public String getLowAddress() {     return format(toArray(low())). }
true;public;0;3;/**  * Return the high address as a dotted IP address.  * Will be zero for CIDR/31 and CIDR/32 if the inclusive flag is false.  *  * @return the IP address in dotted format, may be "0.0.0.0" if there is no valid address  */ ;/**  * Return the high address as a dotted IP address.  * Will be zero for CIDR/31 and CIDR/32 if the inclusive flag is false.  *  * @return the IP address in dotted format, may be "0.0.0.0" if there is no valid address  */ public String getHighAddress() {     return format(toArray(high())). }
true;public;0;9;/**  * Get the count of available addresses.  * Will be zero for CIDR/31 and CIDR/32 if the inclusive flag is false.  * @return the count of addresses, may be zero.  * @throws RuntimeException if the correct count is greater than {@code Integer.MAX_VALUE}  * @deprecated use {@link #getAddressCountLong()} instead  */ ;/**  * Get the count of available addresses.  * Will be zero for CIDR/31 and CIDR/32 if the inclusive flag is false.  * @return the count of addresses, may be zero.  * @throws RuntimeException if the correct count is greater than {@code Integer.MAX_VALUE}  * @deprecated use {@link #getAddressCountLong()} instead  */ @Deprecated public int getAddressCount() {     long countLong = getAddressCountLong().     if (countLong > Integer.MAX_VALUE) {         throw new RuntimeException("Count is larger than an integer: " + countLong).     }     // N.B. cannot be negative     return (int) countLong. }
true;public;0;6;/**  * Get the count of available addresses.  * Will be zero for CIDR/31 and CIDR/32 if the inclusive flag is false.  * @return the count of addresses, may be zero.  */ ;/**  * Get the count of available addresses.  * Will be zero for CIDR/31 and CIDR/32 if the inclusive flag is false.  * @return the count of addresses, may be zero.  */ public long getAddressCountLong() {     long b = broadcastLong().     long n = networkLong().     long count = b - n + (isInclusiveHostCount() ? 1 : -1).     return count < 0 ? 0 : count. }
false;public;1;3;;public int asInteger(String address) {     return toInteger(address). }
false;public;0;6;;public String getCidrSignature() {     return toCidrNotation(format(toArray(address())), format(toArray(netmask()))). }
false;public;0;13;;public String[] getAllAddresses() {     int ct = getAddressCount().     String[] addresses = new String[ct].     if (ct == 0) {         return addresses.     }     int j = 0.     for (int add = low(). add <= high(). ++add) {         addresses[j] = format(toArray(add)).         ++j.     }     return addresses. }
true;public;0;12;/**  * {@inheritDoc}  * @since 2.2  */ ;/**  * {@inheritDoc}  * @since 2.2  */ @Override public String toString() {     final StringBuilder buf = new StringBuilder().     buf.append("CIDR Signature:\t[").append(getCidrSignature()).append("]").append(" Netmask: [").append(getNetmask()).append("]\n").append("Network:\t[").append(getNetworkAddress()).append("]\n").append("Broadcast:\t[").append(getBroadcastAddress()).append("]\n").append("First Address:\t[").append(getLowAddress()).append("]\n").append("Last Address:\t[").append(getHighAddress()).append("]\n").append("# Addresses:\t[").append(getAddressCount()).append("]\n").     return buf.toString(). }
true;public,final;0;3;/**  * Return a {@link SubnetInfo} instance that contains subnet-specific statistics  * @return new instance  */ ;/**  * Return a {@link SubnetInfo} instance that contains subnet-specific statistics  * @return new instance  */ public final SubnetInfo getInfo() {     return new SubnetInfo(). }
true;private;1;21;/*      * Initialize the internal fields from the supplied CIDR mask      */ ;/*      * Initialize the internal fields from the supplied CIDR mask      */ private void calculate(String mask) {     Matcher matcher = CIDR_PATTERN.matcher(mask).     if (matcher.matches()) {         address = matchAddress(matcher).         /* Create a binary netmask from the number of bits specification /x */         int cidrPart = rangeCheck(Integer.parseInt(matcher.group(5)), 0, NBITS).         for (int j = 0. j < cidrPart. ++j) {             netmask |= 1 << 31 - j.         }         /* Calculate base network address */         network = address & netmask.         /* Calculate broadcast address */         broadcast = network | ~netmask.     } else {         throw new IllegalArgumentException("Could not parse [" + mask + "]").     } }
true;private;1;8;/*      * Convert a dotted decimal format address to a packed integer format      */ ;/*      * Convert a dotted decimal format address to a packed integer format      */ private int toInteger(String address) {     Matcher matcher = ADDRESS_PATTERN.matcher(address).     if (matcher.matches()) {         return matchAddress(matcher).     } else {         throw new IllegalArgumentException("Could not parse [" + address + "]").     } }
true;private;1;8;/*      * Convenience method to extract the components of a dotted decimal address and      * pack into an integer using a regex match      */ ;/*      * Convenience method to extract the components of a dotted decimal address and      * pack into an integer using a regex match      */ private int matchAddress(Matcher matcher) {     int addr = 0.     for (int i = 1. i <= 4. ++i) {         int n = rangeCheck(Integer.parseInt(matcher.group(i)), 0, 255).         addr |= (n & 0xff) << 8 * (4 - i).     }     return addr. }
true;private;1;7;/*      * Convert a packed integer address into a 4-element array      */ ;/*      * Convert a packed integer address into a 4-element array      */ private int[] toArray(int val) {     int[] ret = new int[4].     for (int j = 3. j >= 0. --j) {         ret[j] |= (val >>> 8 * (3 - j)) & 0xff.     }     return ret. }
true;private;1;10;/*      * Convert a 4-element array into dotted decimal format      */ ;/*      * Convert a 4-element array into dotted decimal format      */ private String format(int[] octets) {     StringBuilder str = new StringBuilder().     for (int i = 0. i < octets.length. ++i) {         str.append(octets[i]).         if (i != octets.length - 1) {             str.append(".").         }     }     return str.toString(). }
true;private;3;7;/*      * Convenience function to check integer boundaries.      * Checks if a value x is in the range [begin,end].      * Returns x if it is in range, throws an exception otherwise.      */ ;/*      * Convenience function to check integer boundaries.      * Checks if a value x is in the range [begin,end].      * Returns x if it is in range, throws an exception otherwise.      */ private int rangeCheck(int value, int begin, int end) {     if (value >= begin && value <= end) {         // (begin,end]         return value.     }     throw new IllegalArgumentException("Value [" + value + "] not in range [" + begin + "," + end + "]"). }
true;;1;8;/*      * Count the number of 1-bits in a 32-bit integer using a divide-and-conquer strategy      * see Hacker's Delight section 5.1      */ ;/*      * Count the number of 1-bits in a 32-bit integer using a divide-and-conquer strategy      * see Hacker's Delight section 5.1      */ int pop(int x) {     x = x - ((x >>> 1) & 0x55555555).     x = (x & 0x33333333) + ((x >>> 2) & 0x33333333).     x = (x + (x >>> 4)) & 0x0F0F0F0F.     x = x + (x >>> 8).     x = x + (x >>> 16).     return x & 0x0000003F. }
true;private;2;3;/* Convert two dotted decimal addresses to a single xxx.xxx.xxx.xxx/yy format      * by counting the 1-bit population in the mask address. (It may be better to count      * NBITS-#trailing zeroes for this case)      */ ;/* Convert two dotted decimal addresses to a single xxx.xxx.xxx.xxx/yy format      * by counting the 1-bit population in the mask address. (It may be better to count      * NBITS-#trailing zeroes for this case)      */ private String toCidrNotation(String addr, String mask) {     return addr + "/" + pop(toInteger(mask)). }
