# id;timestamp;commentText;codeText;commentWords;codeWords
NettyHelper -> public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException;1375883136;Gets the string body to be used when sending with the textline codec.__@param body                 the current body_@param exchange             the exchange_@param delimiter            the textline delimiter_@param autoAppendDelimiter  whether absent delimiter should be auto appended_@return the string body to send_@throws NoTypeConversionAvailableException is thrown if the current body could not be converted to a String type;public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException {_        String s = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body)___        _        if (autoAppendDelimiter) {_            if (TextLineDelimiter.LINE.equals(delimiter)) {_                _                if (!s.endsWith("\n")) {_                    LOG.trace("Auto appending missing newline delimiter to body")__                    s = s + "\n"__                }_            } else {_                _                if (!s.endsWith("\u0000")) {_                    LOG.trace("Auto appending missing null delimiter to body")__                    s = s + "\u0000"__                }_            }_        }__        return s__    };gets,the,string,body,to,be,used,when,sending,with,the,textline,codec,param,body,the,current,body,param,exchange,the,exchange,param,delimiter,the,textline,delimiter,param,auto,append,delimiter,whether,absent,delimiter,should,be,auto,appended,return,the,string,body,to,send,throws,no,type,conversion,available,exception,is,thrown,if,the,current,body,could,not,be,converted,to,a,string,type;public,static,string,get,textline,body,object,body,exchange,exchange,text,line,delimiter,delimiter,boolean,auto,append,delimiter,throws,no,type,conversion,available,exception,string,s,exchange,get,context,get,type,converter,mandatory,convert,to,string,class,exchange,body,if,auto,append,delimiter,if,text,line,delimiter,line,equals,delimiter,if,s,ends,with,n,log,trace,auto,appending,missing,newline,delimiter,to,body,s,s,n,else,if,s,ends,with,u0000,log,trace,auto,appending,missing,null,delimiter,to,body,s,s,u0000,return,s
NettyHelper -> public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException;1415211488;Gets the string body to be used when sending with the textline codec.__@param body                 the current body_@param exchange             the exchange_@param delimiter            the textline delimiter_@param autoAppendDelimiter  whether absent delimiter should be auto appended_@return the string body to send_@throws NoTypeConversionAvailableException is thrown if the current body could not be converted to a String type;public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException {_        String s = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body)___        _        if (autoAppendDelimiter) {_            if (TextLineDelimiter.LINE.equals(delimiter)) {_                _                if (!s.endsWith("\n")) {_                    LOG.trace("Auto appending missing newline delimiter to body")__                    s = s + "\n"__                }_            } else {_                _                if (!s.endsWith("\u0000")) {_                    LOG.trace("Auto appending missing null delimiter to body")__                    s = s + "\u0000"__                }_            }_        }__        return s__    };gets,the,string,body,to,be,used,when,sending,with,the,textline,codec,param,body,the,current,body,param,exchange,the,exchange,param,delimiter,the,textline,delimiter,param,auto,append,delimiter,whether,absent,delimiter,should,be,auto,appended,return,the,string,body,to,send,throws,no,type,conversion,available,exception,is,thrown,if,the,current,body,could,not,be,converted,to,a,string,type;public,static,string,get,textline,body,object,body,exchange,exchange,text,line,delimiter,delimiter,boolean,auto,append,delimiter,throws,no,type,conversion,available,exception,string,s,exchange,get,context,get,type,converter,mandatory,convert,to,string,class,exchange,body,if,auto,append,delimiter,if,text,line,delimiter,line,equals,delimiter,if,s,ends,with,n,log,trace,auto,appending,missing,newline,delimiter,to,body,s,s,n,else,if,s,ends,with,u0000,log,trace,auto,appending,missing,null,delimiter,to,body,s,s,u0000,return,s
NettyHelper -> public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException;1420335605;Gets the string body to be used when sending with the textline codec.__@param body                 the current body_@param exchange             the exchange_@param delimiter            the textline delimiter_@param autoAppendDelimiter  whether absent delimiter should be auto appended_@return the string body to send_@throws NoTypeConversionAvailableException is thrown if the current body could not be converted to a String type;public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException {_        String s = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body)___        _        if (autoAppendDelimiter) {_            if (TextLineDelimiter.LINE.equals(delimiter)) {_                _                if (!s.endsWith("\n")) {_                    LOG.trace("Auto appending missing newline delimiter to body")__                    s = s + "\n"__                }_            } else {_                _                if (!s.endsWith("\u0000")) {_                    LOG.trace("Auto appending missing null delimiter to body")__                    s = s + "\u0000"__                }_            }_        }__        return s__    };gets,the,string,body,to,be,used,when,sending,with,the,textline,codec,param,body,the,current,body,param,exchange,the,exchange,param,delimiter,the,textline,delimiter,param,auto,append,delimiter,whether,absent,delimiter,should,be,auto,appended,return,the,string,body,to,send,throws,no,type,conversion,available,exception,is,thrown,if,the,current,body,could,not,be,converted,to,a,string,type;public,static,string,get,textline,body,object,body,exchange,exchange,text,line,delimiter,delimiter,boolean,auto,append,delimiter,throws,no,type,conversion,available,exception,string,s,exchange,get,context,get,type,converter,mandatory,convert,to,string,class,exchange,body,if,auto,append,delimiter,if,text,line,delimiter,line,equals,delimiter,if,s,ends,with,n,log,trace,auto,appending,missing,newline,delimiter,to,body,s,s,n,else,if,s,ends,with,u0000,log,trace,auto,appending,missing,null,delimiter,to,body,s,s,u0000,return,s
NettyHelper -> public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException;1524063141;Gets the string body to be used when sending with the textline codec.__@param body                 the current body_@param exchange             the exchange_@param delimiter            the textline delimiter_@param autoAppendDelimiter  whether absent delimiter should be auto appended_@return the string body to send_@throws NoTypeConversionAvailableException is thrown if the current body could not be converted to a String type;public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException {_        String s = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body)___        _        if (autoAppendDelimiter) {_            if (TextLineDelimiter.LINE.equals(delimiter)) {_                _                if (!s.endsWith("\n")) {_                    LOG.trace("Auto appending missing newline delimiter to body")__                    s = s + "\n"__                }_            } else {_                _                if (!s.endsWith("\u0000")) {_                    LOG.trace("Auto appending missing null delimiter to body")__                    s = s + "\u0000"__                }_            }_        }__        return s__    };gets,the,string,body,to,be,used,when,sending,with,the,textline,codec,param,body,the,current,body,param,exchange,the,exchange,param,delimiter,the,textline,delimiter,param,auto,append,delimiter,whether,absent,delimiter,should,be,auto,appended,return,the,string,body,to,send,throws,no,type,conversion,available,exception,is,thrown,if,the,current,body,could,not,be,converted,to,a,string,type;public,static,string,get,textline,body,object,body,exchange,exchange,text,line,delimiter,delimiter,boolean,auto,append,delimiter,throws,no,type,conversion,available,exception,string,s,exchange,get,context,get,type,converter,mandatory,convert,to,string,class,exchange,body,if,auto,append,delimiter,if,text,line,delimiter,line,equals,delimiter,if,s,ends,with,n,log,trace,auto,appending,missing,newline,delimiter,to,body,s,s,n,else,if,s,ends,with,u0000,log,trace,auto,appending,missing,null,delimiter,to,body,s,s,u0000,return,s
NettyHelper -> public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException;1536517284;Gets the string body to be used when sending with the textline codec.__@param body                 the current body_@param exchange             the exchange_@param delimiter            the textline delimiter_@param autoAppendDelimiter  whether absent delimiter should be auto appended_@return the string body to send_@throws NoTypeConversionAvailableException is thrown if the current body could not be converted to a String type;public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException {_        String s = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body)___        _        if (autoAppendDelimiter) {_            if (TextLineDelimiter.LINE.equals(delimiter)) {_                _                if (!s.endsWith("\n")) {_                    LOG.trace("Auto appending missing newline delimiter to body")__                    s = s + "\n"__                }_            } else {_                _                if (!s.endsWith("\u0000")) {_                    LOG.trace("Auto appending missing null delimiter to body")__                    s = s + "\u0000"__                }_            }_        }__        return s__    };gets,the,string,body,to,be,used,when,sending,with,the,textline,codec,param,body,the,current,body,param,exchange,the,exchange,param,delimiter,the,textline,delimiter,param,auto,append,delimiter,whether,absent,delimiter,should,be,auto,appended,return,the,string,body,to,send,throws,no,type,conversion,available,exception,is,thrown,if,the,current,body,could,not,be,converted,to,a,string,type;public,static,string,get,textline,body,object,body,exchange,exchange,text,line,delimiter,delimiter,boolean,auto,append,delimiter,throws,no,type,conversion,available,exception,string,s,exchange,get,context,get,type,converter,mandatory,convert,to,string,class,exchange,body,if,auto,append,delimiter,if,text,line,delimiter,line,equals,delimiter,if,s,ends,with,n,log,trace,auto,appending,missing,newline,delimiter,to,body,s,s,n,else,if,s,ends,with,u0000,log,trace,auto,appending,missing,null,delimiter,to,body,s,s,u0000,return,s
NettyHelper -> public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException;1537290824;Gets the string body to be used when sending with the textline codec.__@param body                 the current body_@param exchange             the exchange_@param delimiter            the textline delimiter_@param autoAppendDelimiter  whether absent delimiter should be auto appended_@return the string body to send_@throws NoTypeConversionAvailableException is thrown if the current body could not be converted to a String type;public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException {_        String s = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body)___        _        if (autoAppendDelimiter) {_            if (TextLineDelimiter.LINE.equals(delimiter)) {_                _                if (!s.endsWith("\n")) {_                    LOG.trace("Auto appending missing newline delimiter to body")__                    s = s + "\n"__                }_            } else {_                _                if (!s.endsWith("\u0000")) {_                    LOG.trace("Auto appending missing null delimiter to body")__                    s = s + "\u0000"__                }_            }_        }__        return s__    };gets,the,string,body,to,be,used,when,sending,with,the,textline,codec,param,body,the,current,body,param,exchange,the,exchange,param,delimiter,the,textline,delimiter,param,auto,append,delimiter,whether,absent,delimiter,should,be,auto,appended,return,the,string,body,to,send,throws,no,type,conversion,available,exception,is,thrown,if,the,current,body,could,not,be,converted,to,a,string,type;public,static,string,get,textline,body,object,body,exchange,exchange,text,line,delimiter,delimiter,boolean,auto,append,delimiter,throws,no,type,conversion,available,exception,string,s,exchange,get,context,get,type,converter,mandatory,convert,to,string,class,exchange,body,if,auto,append,delimiter,if,text,line,delimiter,line,equals,delimiter,if,s,ends,with,n,log,trace,auto,appending,missing,newline,delimiter,to,body,s,s,n,else,if,s,ends,with,u0000,log,trace,auto,appending,missing,null,delimiter,to,body,s,s,u0000,return,s
NettyHelper -> public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException;1540108161;Gets the string body to be used when sending with the textline codec.__@param body                 the current body_@param exchange             the exchange_@param delimiter            the textline delimiter_@param autoAppendDelimiter  whether absent delimiter should be auto appended_@return the string body to send_@throws NoTypeConversionAvailableException is thrown if the current body could not be converted to a String type;public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException {_        String s = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body)___        _        if (autoAppendDelimiter) {_            if (TextLineDelimiter.LINE.equals(delimiter)) {_                _                if (!s.endsWith("\n")) {_                    LOG.trace("Auto appending missing newline delimiter to body")__                    s = s + "\n"__                }_            } else {_                _                if (!s.endsWith("\u0000")) {_                    LOG.trace("Auto appending missing null delimiter to body")__                    s = s + "\u0000"__                }_            }_        }__        return s__    };gets,the,string,body,to,be,used,when,sending,with,the,textline,codec,param,body,the,current,body,param,exchange,the,exchange,param,delimiter,the,textline,delimiter,param,auto,append,delimiter,whether,absent,delimiter,should,be,auto,appended,return,the,string,body,to,send,throws,no,type,conversion,available,exception,is,thrown,if,the,current,body,could,not,be,converted,to,a,string,type;public,static,string,get,textline,body,object,body,exchange,exchange,text,line,delimiter,delimiter,boolean,auto,append,delimiter,throws,no,type,conversion,available,exception,string,s,exchange,get,context,get,type,converter,mandatory,convert,to,string,class,exchange,body,if,auto,append,delimiter,if,text,line,delimiter,line,equals,delimiter,if,s,ends,with,n,log,trace,auto,appending,missing,newline,delimiter,to,body,s,s,n,else,if,s,ends,with,u0000,log,trace,auto,appending,missing,null,delimiter,to,body,s,s,u0000,return,s
NettyHelper -> public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,                                       Exchange exchange, ChannelFutureListener listener);1375883136;Writes the given body to Netty channel. Will <b>not</b >wait until the body has been written.__@param log             logger to use_@param channel         the Netty channel_@param remoteAddress   the remote address when using UDP_@param body            the body to write (send)_@param exchange        the exchange_@param listener        listener with work to be executed when the operation is complete;public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,_                                      Exchange exchange, ChannelFutureListener listener) {_        ChannelFuture future__        if (remoteAddress != null) {_            if (log.isDebugEnabled()) {_                log.debug("Channel: {} remote address: {} writing body: {}", new Object[]{channel, remoteAddress, body})__            }_            future = channel.write(body, remoteAddress)__        } else {_            if (log.isDebugEnabled()) {_                log.debug("Channel: {} writing body: {}", new Object[]{channel, body})__            }_            future = channel.write(body)__        }__        if (listener != null) {_            future.addListener(listener)__        }_    };writes,the,given,body,to,netty,channel,will,b,not,b,wait,until,the,body,has,been,written,param,log,logger,to,use,param,channel,the,netty,channel,param,remote,address,the,remote,address,when,using,udp,param,body,the,body,to,write,send,param,exchange,the,exchange,param,listener,listener,with,work,to,be,executed,when,the,operation,is,complete;public,static,void,write,body,async,logger,log,channel,channel,socket,address,remote,address,object,body,exchange,exchange,channel,future,listener,listener,channel,future,future,if,remote,address,null,if,log,is,debug,enabled,log,debug,channel,remote,address,writing,body,new,object,channel,remote,address,body,future,channel,write,body,remote,address,else,if,log,is,debug,enabled,log,debug,channel,writing,body,new,object,channel,body,future,channel,write,body,if,listener,null,future,add,listener,listener
NettyHelper -> public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,                                       Exchange exchange, ChannelFutureListener listener);1415211488;Writes the given body to Netty channel. Will <b>not</b >wait until the body has been written.__@param log             logger to use_@param channel         the Netty channel_@param remoteAddress   the remote address when using UDP_@param body            the body to write (send)_@param exchange        the exchange_@param listener        listener with work to be executed when the operation is complete;public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,_                                      Exchange exchange, ChannelFutureListener listener) {_        ChannelFuture future__        if (remoteAddress != null) {_            if (log.isDebugEnabled()) {_                log.debug("Channel: {} remote address: {} writing body: {}", new Object[]{channel, remoteAddress, body})__            }_            _            DefaultAddressedEnvelope<Object, InetSocketAddress> ae =_                new DefaultAddressedEnvelope<Object, InetSocketAddress>(body, (InetSocketAddress)remoteAddress)__            future = channel.writeAndFlush(ae)__        } else {_            if (log.isDebugEnabled()) {_                log.debug("Channel: {} writing body: {}", new Object[]{channel, body})__            }_            _            future = channel.writeAndFlush(body)__        }__        if (listener != null) {_            future.addListener(listener)__        }_    };writes,the,given,body,to,netty,channel,will,b,not,b,wait,until,the,body,has,been,written,param,log,logger,to,use,param,channel,the,netty,channel,param,remote,address,the,remote,address,when,using,udp,param,body,the,body,to,write,send,param,exchange,the,exchange,param,listener,listener,with,work,to,be,executed,when,the,operation,is,complete;public,static,void,write,body,async,logger,log,channel,channel,socket,address,remote,address,object,body,exchange,exchange,channel,future,listener,listener,channel,future,future,if,remote,address,null,if,log,is,debug,enabled,log,debug,channel,remote,address,writing,body,new,object,channel,remote,address,body,default,addressed,envelope,object,inet,socket,address,ae,new,default,addressed,envelope,object,inet,socket,address,body,inet,socket,address,remote,address,future,channel,write,and,flush,ae,else,if,log,is,debug,enabled,log,debug,channel,writing,body,new,object,channel,body,future,channel,write,and,flush,body,if,listener,null,future,add,listener,listener
NettyHelper -> public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,                                       Exchange exchange, ChannelFutureListener listener);1420335605;Writes the given body to Netty channel. Will <b>not</b >wait until the body has been written.__@param log             logger to use_@param channel         the Netty channel_@param remoteAddress   the remote address when using UDP_@param body            the body to write (send)_@param exchange        the exchange_@param listener        listener with work to be executed when the operation is complete;public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,_                                      Exchange exchange, ChannelFutureListener listener) {_        ChannelFuture future__        if (remoteAddress != null) {_            if (log.isDebugEnabled()) {_                log.debug("Channel: {} remote address: {} writing body: {}", new Object[]{channel, remoteAddress, body})__            }_            _            DefaultAddressedEnvelope<Object, InetSocketAddress> ae =_                new DefaultAddressedEnvelope<Object, InetSocketAddress>(body, (InetSocketAddress)remoteAddress)__            future = channel.writeAndFlush(ae)__        } else {_            if (log.isDebugEnabled()) {_                log.debug("Channel: {} writing body: {}", new Object[]{channel, body})__            }_            _            future = channel.writeAndFlush(body)__        }__        if (listener != null) {_            future.addListener(listener)__        }_    };writes,the,given,body,to,netty,channel,will,b,not,b,wait,until,the,body,has,been,written,param,log,logger,to,use,param,channel,the,netty,channel,param,remote,address,the,remote,address,when,using,udp,param,body,the,body,to,write,send,param,exchange,the,exchange,param,listener,listener,with,work,to,be,executed,when,the,operation,is,complete;public,static,void,write,body,async,logger,log,channel,channel,socket,address,remote,address,object,body,exchange,exchange,channel,future,listener,listener,channel,future,future,if,remote,address,null,if,log,is,debug,enabled,log,debug,channel,remote,address,writing,body,new,object,channel,remote,address,body,default,addressed,envelope,object,inet,socket,address,ae,new,default,addressed,envelope,object,inet,socket,address,body,inet,socket,address,remote,address,future,channel,write,and,flush,ae,else,if,log,is,debug,enabled,log,debug,channel,writing,body,new,object,channel,body,future,channel,write,and,flush,body,if,listener,null,future,add,listener,listener
NettyHelper -> public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,                                       Exchange exchange, ChannelFutureListener listener);1524063141;Writes the given body to Netty channel. Will <b>not</b >wait until the body has been written.__@param log             logger to use_@param channel         the Netty channel_@param remoteAddress   the remote address when using UDP_@param body            the body to write (send)_@param exchange        the exchange_@param listener        listener with work to be executed when the operation is complete;public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,_                                      Exchange exchange, ChannelFutureListener listener) {_        ChannelFuture future__        if (remoteAddress != null) {_            if (log.isDebugEnabled()) {_                log.debug("Channel: {} remote address: {} writing body: {}", new Object[]{channel, remoteAddress, body})__            }_            _            DefaultAddressedEnvelope<Object, InetSocketAddress> ae =_                new DefaultAddressedEnvelope<>(body, (InetSocketAddress)remoteAddress)__            future = channel.writeAndFlush(ae)__        } else {_            if (log.isDebugEnabled()) {_                log.debug("Channel: {} writing body: {}", new Object[]{channel, body})__            }_            _            future = channel.writeAndFlush(body)__        }__        if (listener != null) {_            future.addListener(listener)__        }_    };writes,the,given,body,to,netty,channel,will,b,not,b,wait,until,the,body,has,been,written,param,log,logger,to,use,param,channel,the,netty,channel,param,remote,address,the,remote,address,when,using,udp,param,body,the,body,to,write,send,param,exchange,the,exchange,param,listener,listener,with,work,to,be,executed,when,the,operation,is,complete;public,static,void,write,body,async,logger,log,channel,channel,socket,address,remote,address,object,body,exchange,exchange,channel,future,listener,listener,channel,future,future,if,remote,address,null,if,log,is,debug,enabled,log,debug,channel,remote,address,writing,body,new,object,channel,remote,address,body,default,addressed,envelope,object,inet,socket,address,ae,new,default,addressed,envelope,body,inet,socket,address,remote,address,future,channel,write,and,flush,ae,else,if,log,is,debug,enabled,log,debug,channel,writing,body,new,object,channel,body,future,channel,write,and,flush,body,if,listener,null,future,add,listener,listener
NettyHelper -> public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,                                       Exchange exchange, ChannelFutureListener listener);1536517284;Writes the given body to Netty channel. Will <b>not</b >wait until the body has been written.__@param log             logger to use_@param channel         the Netty channel_@param remoteAddress   the remote address when using UDP_@param body            the body to write (send)_@param exchange        the exchange_@param listener        listener with work to be executed when the operation is complete;public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,_                                      Exchange exchange, ChannelFutureListener listener) {_        ChannelFuture future__        if (remoteAddress != null) {_            if (log.isDebugEnabled()) {_                log.debug("Channel: {} remote address: {} writing body: {}", channel, remoteAddress, body)__            }_            _            DefaultAddressedEnvelope<Object, InetSocketAddress> ae =_                new DefaultAddressedEnvelope<>(body, (InetSocketAddress)remoteAddress)__            future = channel.writeAndFlush(ae)__        } else {_            if (log.isDebugEnabled()) {_                log.debug("Channel: {} writing body: {}", channel, body)__            }_            _            future = channel.writeAndFlush(body)__        }__        if (listener != null) {_            future.addListener(listener)__        }_    };writes,the,given,body,to,netty,channel,will,b,not,b,wait,until,the,body,has,been,written,param,log,logger,to,use,param,channel,the,netty,channel,param,remote,address,the,remote,address,when,using,udp,param,body,the,body,to,write,send,param,exchange,the,exchange,param,listener,listener,with,work,to,be,executed,when,the,operation,is,complete;public,static,void,write,body,async,logger,log,channel,channel,socket,address,remote,address,object,body,exchange,exchange,channel,future,listener,listener,channel,future,future,if,remote,address,null,if,log,is,debug,enabled,log,debug,channel,remote,address,writing,body,channel,remote,address,body,default,addressed,envelope,object,inet,socket,address,ae,new,default,addressed,envelope,body,inet,socket,address,remote,address,future,channel,write,and,flush,ae,else,if,log,is,debug,enabled,log,debug,channel,writing,body,channel,body,future,channel,write,and,flush,body,if,listener,null,future,add,listener,listener
NettyHelper -> public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,                                       Exchange exchange, ChannelFutureListener listener);1537290824;Writes the given body to Netty channel. Will <b>not</b >wait until the body has been written.__@param log             logger to use_@param channel         the Netty channel_@param remoteAddress   the remote address when using UDP_@param body            the body to write (send)_@param exchange        the exchange_@param listener        listener with work to be executed when the operation is complete;public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,_                                      Exchange exchange, ChannelFutureListener listener) {_        ChannelFuture future__        if (remoteAddress != null) {_            if (log.isDebugEnabled()) {_                log.debug("Channel: {} remote address: {} writing body: {}", channel, remoteAddress, body)__            }_            _            DefaultAddressedEnvelope<Object, InetSocketAddress> ae =_                new DefaultAddressedEnvelope<>(body, (InetSocketAddress)remoteAddress)__            future = channel.writeAndFlush(ae)__        } else {_            if (log.isDebugEnabled()) {_                log.debug("Channel: {} writing body: {}", channel, body)__            }_            _            future = channel.writeAndFlush(body)__        }__        if (listener != null) {_            future.addListener(listener)__        }_    };writes,the,given,body,to,netty,channel,will,b,not,b,wait,until,the,body,has,been,written,param,log,logger,to,use,param,channel,the,netty,channel,param,remote,address,the,remote,address,when,using,udp,param,body,the,body,to,write,send,param,exchange,the,exchange,param,listener,listener,with,work,to,be,executed,when,the,operation,is,complete;public,static,void,write,body,async,logger,log,channel,channel,socket,address,remote,address,object,body,exchange,exchange,channel,future,listener,listener,channel,future,future,if,remote,address,null,if,log,is,debug,enabled,log,debug,channel,remote,address,writing,body,channel,remote,address,body,default,addressed,envelope,object,inet,socket,address,ae,new,default,addressed,envelope,body,inet,socket,address,remote,address,future,channel,write,and,flush,ae,else,if,log,is,debug,enabled,log,debug,channel,writing,body,channel,body,future,channel,write,and,flush,body,if,listener,null,future,add,listener,listener
NettyHelper -> public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,                                       Exchange exchange, ChannelFutureListener listener);1540108161;Writes the given body to Netty channel. Will <b>not</b >wait until the body has been written.__@param log             logger to use_@param channel         the Netty channel_@param remoteAddress   the remote address when using UDP_@param body            the body to write (send)_@param exchange        the exchange_@param listener        listener with work to be executed when the operation is complete;public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body,_                                      Exchange exchange, ChannelFutureListener listener) {_        ChannelFuture future__        if (remoteAddress != null) {_            if (log.isDebugEnabled()) {_                log.debug("Channel: {} remote address: {} writing body: {}", channel, remoteAddress, body)__            }_            _            DefaultAddressedEnvelope<Object, InetSocketAddress> ae =_                new DefaultAddressedEnvelope<>(body, (InetSocketAddress)remoteAddress)__            future = channel.writeAndFlush(ae)__        } else {_            if (log.isDebugEnabled()) {_                log.debug("Channel: {} writing body: {}", channel, body)__            }_            _            future = channel.writeAndFlush(body)__        }__        if (listener != null) {_            future.addListener(listener)__        }_    };writes,the,given,body,to,netty,channel,will,b,not,b,wait,until,the,body,has,been,written,param,log,logger,to,use,param,channel,the,netty,channel,param,remote,address,the,remote,address,when,using,udp,param,body,the,body,to,write,send,param,exchange,the,exchange,param,listener,listener,with,work,to,be,executed,when,the,operation,is,complete;public,static,void,write,body,async,logger,log,channel,channel,socket,address,remote,address,object,body,exchange,exchange,channel,future,listener,listener,channel,future,future,if,remote,address,null,if,log,is,debug,enabled,log,debug,channel,remote,address,writing,body,channel,remote,address,body,default,addressed,envelope,object,inet,socket,address,ae,new,default,addressed,envelope,body,inet,socket,address,remote,address,future,channel,write,and,flush,ae,else,if,log,is,debug,enabled,log,debug,channel,writing,body,channel,body,future,channel,write,and,flush,body,if,listener,null,future,add,listener,listener
NettyHelper -> public static void close(Channel channel);1375883136;Closes the given channel asynchronously__@param channel the channel to close;public static void close(Channel channel) {_        if (channel != null) {_            LOG.trace("Closing channel: {}", channel)__            channel.close()__        }_    };closes,the,given,channel,asynchronously,param,channel,the,channel,to,close;public,static,void,close,channel,channel,if,channel,null,log,trace,closing,channel,channel,channel,close
NettyHelper -> public static void close(Channel channel);1415211488;Closes the given channel asynchronously__@param channel the channel to close;public static void close(Channel channel) {_        if (channel != null) {_            LOG.trace("Closing channel: {}", channel)__            channel.close().syncUninterruptibly()__        }_    };closes,the,given,channel,asynchronously,param,channel,the,channel,to,close;public,static,void,close,channel,channel,if,channel,null,log,trace,closing,channel,channel,channel,close,sync,uninterruptibly
NettyHelper -> public static void close(Channel channel);1420335605;Closes the given channel asynchronously__@param channel the channel to close;public static void close(Channel channel) {_        if (channel != null) {_            channel.close().addListener(new ChannelFutureListener() {_                public void operationComplete(ChannelFuture future) {_                    LOG.trace("Channel closed: {}", future.channel())__                }_            })__        }_    };closes,the,given,channel,asynchronously,param,channel,the,channel,to,close;public,static,void,close,channel,channel,if,channel,null,channel,close,add,listener,new,channel,future,listener,public,void,operation,complete,channel,future,future,log,trace,channel,closed,future,channel
NettyHelper -> public static void close(Channel channel);1524063141;Closes the given channel asynchronously__@param channel the channel to close;public static void close(Channel channel) {_        if (channel != null) {_            channel.close().addListener(new ChannelFutureListener() {_                public void operationComplete(ChannelFuture future) {_                    LOG.trace("Channel closed: {}", future.channel())__                }_            })__        }_    };closes,the,given,channel,asynchronously,param,channel,the,channel,to,close;public,static,void,close,channel,channel,if,channel,null,channel,close,add,listener,new,channel,future,listener,public,void,operation,complete,channel,future,future,log,trace,channel,closed,future,channel
NettyHelper -> public static void close(Channel channel);1536517284;Closes the given channel asynchronously__@param channel the channel to close;public static void close(Channel channel) {_        if (channel != null) {_            channel.close().addListener(new ChannelFutureListener() {_                public void operationComplete(ChannelFuture future) {_                    LOG.trace("Channel closed: {}", future.channel())__                }_            })__        }_    };closes,the,given,channel,asynchronously,param,channel,the,channel,to,close;public,static,void,close,channel,channel,if,channel,null,channel,close,add,listener,new,channel,future,listener,public,void,operation,complete,channel,future,future,log,trace,channel,closed,future,channel
NettyHelper -> public static void close(Channel channel);1537290824;Closes the given channel asynchronously__@param channel the channel to close;public static void close(Channel channel) {_        if (channel != null) {_            channel.close().addListener(new ChannelFutureListener() {_                public void operationComplete(ChannelFuture future) {_                    LOG.trace("Channel closed: {}", future.channel())__                }_            })__        }_    };closes,the,given,channel,asynchronously,param,channel,the,channel,to,close;public,static,void,close,channel,channel,if,channel,null,channel,close,add,listener,new,channel,future,listener,public,void,operation,complete,channel,future,future,log,trace,channel,closed,future,channel
NettyHelper -> public static void close(Channel channel);1540108161;Closes the given channel asynchronously__@param channel the channel to close;public static void close(Channel channel) {_        if (channel != null) {_            channel.close().addListener(new ChannelFutureListener() {_                public void operationComplete(ChannelFuture future) {_                    LOG.trace("Channel closed: {}", future.channel())__                }_            })__        }_    };closes,the,given,channel,asynchronously,param,channel,the,channel,to,close;public,static,void,close,channel,channel,if,channel,null,channel,close,add,listener,new,channel,future,listener,public,void,operation,complete,channel,future,future,log,trace,channel,closed,future,channel
