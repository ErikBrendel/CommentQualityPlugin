commented;modifiers;parameterAmount;loc;comment;code
true;public,static;4;22;/**  * Gets the string body to be used when sending with the textline codec.  *  * @param body                 the current body  * @param exchange             the exchange  * @param delimiter            the textline delimiter  * @param autoAppendDelimiter  whether absent delimiter should be auto appended  * @return the string body to send  * @throws NoTypeConversionAvailableException is thrown if the current body could not be converted to a String type  */ ;/**  * Gets the string body to be used when sending with the textline codec.  *  * @param body                 the current body  * @param exchange             the exchange  * @param delimiter            the textline delimiter  * @param autoAppendDelimiter  whether absent delimiter should be auto appended  * @return the string body to send  * @throws NoTypeConversionAvailableException is thrown if the current body could not be converted to a String type  */ public static String getTextlineBody(Object body, Exchange exchange, TextLineDelimiter delimiter, boolean autoAppendDelimiter) throws NoTypeConversionAvailableException {     String s = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, body).     // auto append delimiter if missing?     if (autoAppendDelimiter) {         if (TextLineDelimiter.LINE.equals(delimiter)) {             // line delimiter so ensure it ends with newline             if (!s.endsWith("\n")) {                 LOG.trace("Auto appending missing newline delimiter to body").                 s = s + "\n".             }         } else {             // null delimiter so ensure it ends with null             if (!s.endsWith("\u0000")) {                 LOG.trace("Auto appending missing null delimiter to body").                 s = s + "\u0000".             }         }     }     return s. }
true;public,static;6;23;/**  * Writes the given body to Netty channel. Will <b>not</b >wait until the body has been written.  *  * @param log             logger to use  * @param channel         the Netty channel  * @param remoteAddress   the remote address when using UDP  * @param body            the body to write (send)  * @param exchange        the exchange  * @param listener        listener with work to be executed when the operation is complete  */ ;/**  * Writes the given body to Netty channel. Will <b>not</b >wait until the body has been written.  *  * @param log             logger to use  * @param channel         the Netty channel  * @param remoteAddress   the remote address when using UDP  * @param body            the body to write (send)  * @param exchange        the exchange  * @param listener        listener with work to be executed when the operation is complete  */ public static void writeBodyAsync(Logger log, Channel channel, SocketAddress remoteAddress, Object body, Exchange exchange, ChannelFutureListener listener) {     ChannelFuture future.     if (remoteAddress != null) {         if (log.isDebugEnabled()) {             log.debug("Channel: {} remote address: {} writing body: {}", channel, remoteAddress, body).         }         // Need to create AddressedEnvelope to setup the address information here         DefaultAddressedEnvelope<Object, InetSocketAddress> ae = new DefaultAddressedEnvelope<>(body, (InetSocketAddress) remoteAddress).         future = channel.writeAndFlush(ae).     } else {         if (log.isDebugEnabled()) {             log.debug("Channel: {} writing body: {}", channel, body).         }         // In netty4 we need to call channel flush to send out the message         future = channel.writeAndFlush(body).     }     if (listener != null) {         future.addListener(listener).     } }
false;public;1;3;;public void operationComplete(ChannelFuture future) {     LOG.trace("Channel closed: {}", future.channel()). }
true;public,static;1;9;/**  * Closes the given channel asynchronously  *  * @param channel the channel to close  */ ;/**  * Closes the given channel asynchronously  *  * @param channel the channel to close  */ public static void close(Channel channel) {     if (channel != null) {         channel.close().addListener(new ChannelFutureListener() {              public void operationComplete(ChannelFuture future) {                 LOG.trace("Channel closed: {}", future.channel()).             }         }).     } }
