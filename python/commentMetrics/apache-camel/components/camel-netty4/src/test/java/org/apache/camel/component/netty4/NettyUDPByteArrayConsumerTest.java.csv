commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Test public void testUDPInOnlyWithNettyConsumer() throws Exception {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMessageCount(1).     mock.message(0).body().isEqualTo("***Camel rocks ?=)".getBytes()).     template.sendBody("netty4:udp://localhost:{{port}}?sync=false&udpByteArrayCodec=true", "***Camel rocks ?=)".getBytes()).     mock.assertIsSatisfied(). }
false;public;0;19;;@Test public void testSendingRawByteMessage() throws Exception {     MockEndpoint endpoint = getMockEndpoint("mock:result").     endpoint.expectedMessageCount(1).     String toSend = "ef3e00559f5faf0262f5ff0962d9008daa91001cd46b0fa9330ef0f3030fff250e46f72444d1cc501678c351e04b8004c" + "4000002080000fe850bbe011030000008031b031bfe9251305441593830354720020800050440ff".     byte[] in = fromHexString(toSend).     template.sendBody("netty4:udp://localhost:{{port}}?sync=false&udpByteArrayCodec=true", in).     assertMockEndpointsSatisfied().     List<Exchange> list = endpoint.getReceivedExchanges().     byte[] out = list.get(0).getIn().getBody(byte[].class).     for (int i = 0. i < in.length. i++) {         assertEquals("The bytes should be the same", in[i], out[i]).     }     assertEquals("The strings should be the same", toSend, byteArrayToHex(out)). }
false;public;0;5;;@Override public void configure() throws Exception {     from("netty4:udp://localhost:{{port}}?sync=false&udpByteArrayCodec=true").to("mock:result"). }
false;protected;0;10;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             from("netty4:udp://localhost:{{port}}?sync=false&udpByteArrayCodec=true").to("mock:result").         }     }. }
