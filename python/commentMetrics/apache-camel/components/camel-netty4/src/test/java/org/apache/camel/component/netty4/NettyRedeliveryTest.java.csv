commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;@Override protected void doPreSetup() throws Exception {     // Create a server to attempt to connect to     port = createServerSocket(0). }
false;public;0;18;;@Override public void configure() throws Exception {     onException(Exception.class).maximumRedeliveries(REDELIVERY_COUNT).retryAttemptedLogLevel(LoggingLevel.INFO).retriesExhaustedLogLevel(LoggingLevel.ERROR).redeliveryDelay(10).asyncDelayedRedelivery().to("mock:exception").handled(true).     from("direct:start").routeId("start").to("netty4:tcp://localhost:" + port).to("log:downstream").to("mock:downstream"). }
false;protected;0;23;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             onException(Exception.class).maximumRedeliveries(REDELIVERY_COUNT).retryAttemptedLogLevel(LoggingLevel.INFO).retriesExhaustedLogLevel(LoggingLevel.ERROR).redeliveryDelay(10).asyncDelayedRedelivery().to("mock:exception").handled(true).             from("direct:start").routeId("start").to("netty4:tcp://localhost:" + port).to("log:downstream").to("mock:downstream").         }     }. }
false;public;0;7;;@Override @After public void tearDown() throws Exception {     super.tearDown().     alive = false.     listener.shutdown(). }
false;public;0;27;;@Test public void testExceptionHandler() throws Exception {     /*          * We should have 0 for this as it should never be successful however it is usual that this actually returns 1.          *          * This is because two or more threads run concurrently and will setException(null) which is checked during          * redelivery to ascertain whether the delivery was successful, this leads to multiple downstream invocations being          * possible.          */     downstream.setExpectedMessageCount(0).     downstream.setAssertPeriod(1000).     exception.setExpectedMessageCount(1).     sendBody("direct:start", LARGE_BUFFER_BODY).     exception.assertIsSatisfied().     // given 100 retries usually yields somewhere around -95     // assertEquals(0, context.getInflightRepository().size("start")).     // Verify the number of tasks submitted - sometimes both callbacks add a task     assertEquals(REDELIVERY_COUNT, tasks.size()).     // Verify the downstream completed messages - othertimes one callback gets treated as done     downstream.assertIsSatisfied(). }
false;public;0;4;;@Override public ScheduledExecutorService getErrorHandlerExecutorService() {     return getScheduledExecutorService(). }
false;protected;0;11;;@Override protected CamelContext createCamelContext() throws Exception {     // Override the error handler executor service such that we can track the tasks created     CamelContext context = new DefaultCamelContext(createRegistry()) {          @Override         public ScheduledExecutorService getErrorHandlerExecutorService() {             return getScheduledExecutorService().         }     }.     return context. }
false;public;3;7;;@Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     if ("submit".equals(method.getName()) || "schedule".equals(method.getName())) {         tasks.add(args[0]).     }     return method.invoke(delegate, args). }
false;private;0;12;;private ScheduledExecutorService getScheduledExecutorService() {     final ScheduledExecutorService delegate = Executors.newScheduledThreadPool(10).     return newProxy(ScheduledExecutorService.class, new InvocationHandler() {          @Override         public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {             if ("submit".equals(method.getName()) || "schedule".equals(method.getName())) {                 tasks.add(args[0]).             }             return method.invoke(delegate, args).         }     }). }
false;public;0;19;;@Override public void run() {     try {         while (alive) {             try {                 pool.execute(new ClosingClientRunnable(listen.accept())).             } catch (SocketTimeoutException ignored) {             // Allow the server socket to terminate in a timely fashion             }         }     } catch (IOException e) {         throw new RuntimeException(e).     } finally {         try {             listen.close().         } catch (IOException ignored) {         }     } }
false;private;1;29;;private int createServerSocket(int port) throws IOException {     final ServerSocket listen = new ServerSocket(port).     listen.setSoTimeout(100).     listener.execute(new Runnable() {          private ExecutorService pool = Executors.newCachedThreadPool().          @Override         public void run() {             try {                 while (alive) {                     try {                         pool.execute(new ClosingClientRunnable(listen.accept())).                     } catch (SocketTimeoutException ignored) {                     // Allow the server socket to terminate in a timely fashion                     }                 }             } catch (IOException e) {                 throw new RuntimeException(e).             } finally {                 try {                     listen.close().                 } catch (IOException ignored) {                 }             }         }     }).     return listen.getLocalPort(). }
false;private,static;2;4;;private static <T> T newProxy(Class<T> interfaceType, InvocationHandler handler) {     Object object = Proxy.newProxyInstance(interfaceType.getClassLoader(), new Class<?>[] { interfaceType }, handler).     return interfaceType.cast(object). }
false;public;0;14;;@Override public void run() {     try {         Thread.sleep(10).         socket.close().     } catch (Throwable e) {         throw new RuntimeException(e).     } finally {         try {             socket.close().         } catch (IOException ignored) {         }     } }
