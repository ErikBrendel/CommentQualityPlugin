commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;public void startNettyServer() throws Exception {     server = new MyServer(getPort()).     server.start(). }
false;public;0;5;;public void shutdownServer() {     if (server != null) {         server.shutdown().     } }
false;public;0;15;;@Test public void testNettyRoute() throws Exception {     try {         startNettyServer().         MockEndpoint receive = context.getEndpoint("mock:receive", MockEndpoint.class).         receive.expectedBodiesReceived("Bye Willem").         context.getRouteController().startRoute("client").         receive.assertIsSatisfied().     } finally {         shutdownServer().     }     assertEquals(1, channels.size()). }
false;public;1;8;;public void process(final Exchange exchange) {     final Channel channel = exchange.getProperty(NettyConstants.NETTY_CHANNEL, Channel.class).     channels.add(channel).     assertTrue("Should be active", channel.isActive()).     String body = exchange.getIn().getBody(String.class).     exchange.getOut().setBody("Bye " + body). }
false;public;0;16;;@Override public void configure() throws Exception {     from("netty4:tcp://localhost:{{port}}?textline=true&clientMode=true&reuseChannel=true").id("client").process(new Processor() {          public void process(final Exchange exchange) {             final Channel channel = exchange.getProperty(NettyConstants.NETTY_CHANNEL, Channel.class).             channels.add(channel).             assertTrue("Should be active", channel.isActive()).             String body = exchange.getIn().getBody(String.class).             exchange.getOut().setBody("Bye " + body).         }     }).to("mock:receive").noAutoStartup(). }
false;protected;0;21;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             from("netty4:tcp://localhost:{{port}}?textline=true&clientMode=true&reuseChannel=true").id("client").process(new Processor() {                  public void process(final Exchange exchange) {                     final Channel channel = exchange.getProperty(NettyConstants.NETTY_CHANNEL, Channel.class).                     channels.add(channel).                     assertTrue("Should be active", channel.isActive()).                     String body = exchange.getIn().getBody(String.class).                     exchange.getOut().setBody("Bye " + body).                 }             }).to("mock:receive").noAutoStartup().         }     }. }
false;public;0;11;;public void start() throws Exception {     bossGroup = new NioEventLoopGroup(1).     workerGroup = new NioEventLoopGroup().     bootstrap = new ServerBootstrap().     bootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(new ServerInitializer()).     ChannelFuture cf = bootstrap.bind(port).sync().     channel = cf.channel(). }
false;public;0;5;;public void shutdown() {     channel.disconnect().     bossGroup.shutdownGracefully().     workerGroup.shutdownGracefully(). }
false;public;1;4;;public void channelActive(ChannelHandlerContext ctx) throws Exception {     ctx.write("Willem\r\n").     ctx.flush(). }
false;public;2;5;;@Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {     cause.printStackTrace().     ctx.close(). }
false;protected;2;4;;@Override protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception { // noop }
false;public;1;3;;public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {     ctx.flush(). }
false;public;1;14;;@Override public void initChannel(SocketChannel ch) throws Exception {     ChannelPipeline pipeline = ch.pipeline().     // Add the text line codec combination first,     pipeline.addLast("framer", new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter())).     // the encoder and decoder are static as these are sharable     pipeline.addLast("decoder", DECODER).     pipeline.addLast("encoder", ENCODER).     // and then business logic.     pipeline.addLast("handler", SERVERHANDLER). }
