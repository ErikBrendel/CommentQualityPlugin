commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;31;;@Override protected int poll() throws Exception {     GetRecordsRequest req = new GetRecordsRequest().withShardIterator(getShardItertor()).withLimit(getEndpoint().getConfiguration().getMaxResultsPerRequest()).     GetRecordsResult result = getClient().getRecords(req).     Queue<Exchange> exchanges = createExchanges(result.getRecords()).     int processedExchangeCount = processBatch(CastUtils.cast(exchanges)).     // May cache the last successful sequence number, and pass it to the     // getRecords request. That way, on the next poll, we start from where     // we left off, however, I don't know what happens to subsequent     // exchanges when an earlier echangee fails.     currentShardIterator = result.getNextShardIterator().     if (isShardClosed) {         switch(getEndpoint().getConfiguration().getShardClosed()) {             case ignore:                 log.warn("The shard {} is in closed state").                 break.             case silent:                 break.             case fail:                 log.info("Shard Iterator reaches CLOSE status:", getEndpoint().getConfiguration().getStreamName(), getEndpoint().getConfiguration().getShardId()).                 throw new ReachedClosedStatusException(getEndpoint().getConfiguration().getStreamName(), getEndpoint().getConfiguration().getShardId()).             default:                 throw new IllegalArgumentException("Unsupported shard closed strategy").         }     }     return processedExchangeCount. }
false;public;1;4;;@Override public void done(boolean doneSync) {     log.trace("Processing exchange [{}] done.", exchange). }
false;public;1;17;;@Override public int processBatch(Queue<Object> exchanges) throws Exception {     int processedExchanges = 0.     while (!exchanges.isEmpty()) {         final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll()).         log.trace("Processing exchange [{}] started.", exchange).         getAsyncProcessor().process(exchange, new AsyncCallback() {              @Override             public void done(boolean doneSync) {                 log.trace("Processing exchange [{}] done.", exchange).             }         }).         processedExchanges++.     }     return processedExchanges. }
false;private;0;3;;private AmazonKinesis getClient() {     return getEndpoint().getClient(). }
false;public;0;4;;@Override public KinesisEndpoint getEndpoint() {     return (KinesisEndpoint) super.getEndpoint(). }
false;private;0;48;;private String getShardItertor() {     // request.     if (currentShardIterator == null) {         String shardId.         // If ShardId supplied use it, else choose first one         if (!getEndpoint().getConfiguration().getShardId().isEmpty()) {             shardId = getEndpoint().getConfiguration().getShardId().             DescribeStreamRequest req1 = new DescribeStreamRequest().withStreamName(getEndpoint().getConfiguration().getStreamName()).             DescribeStreamResult res1 = getClient().describeStream(req1).             Iterator it = res1.getStreamDescription().getShards().iterator().             while (it.hasNext()) {                 Shard shard = (Shard) it.next().                 if (shard.getShardId().equalsIgnoreCase(getEndpoint().getConfiguration().getShardId())) {                     if (shard.getSequenceNumberRange().getEndingSequenceNumber() == null) {                         isShardClosed = false.                     } else {                         isShardClosed = true.                     }                 }             }         } else {             DescribeStreamRequest req1 = new DescribeStreamRequest().withStreamName(getEndpoint().getConfiguration().getStreamName()).             DescribeStreamResult res1 = getClient().describeStream(req1).             shardId = res1.getStreamDescription().getShards().get(0).getShardId().             if (res1.getStreamDescription().getShards().get(0).getSequenceNumberRange().getEndingSequenceNumber() == null) {                 isShardClosed = false.             } else {                 isShardClosed = true.             }         }         log.debug("ShardId is: {}", shardId).         GetShardIteratorRequest req = new GetShardIteratorRequest().withStreamName(getEndpoint().getConfiguration().getStreamName()).withShardId(shardId).withShardIteratorType(getEndpoint().getConfiguration().getIteratorType()).         if (hasSequenceNumber()) {             req.withStartingSequenceNumber(getEndpoint().getConfiguration().getSequenceNumber()).         }         GetShardIteratorResult result = getClient().getShardIterator(req).         currentShardIterator = result.getShardIterator().     }     log.debug("Shard Iterator is: {}", currentShardIterator).     return currentShardIterator. }
false;private;1;7;;private Queue<Exchange> createExchanges(List<Record> records) {     Queue<Exchange> exchanges = new ArrayDeque<>().     for (Record record : records) {         exchanges.add(getEndpoint().createExchange(record)).     }     return exchanges. }
false;private;0;5;;private boolean hasSequenceNumber() {     return !getEndpoint().getConfiguration().getSequenceNumber().isEmpty() && (getEndpoint().getConfiguration().getIteratorType().equals(ShardIteratorType.AFTER_SEQUENCE_NUMBER) || getEndpoint().getConfiguration().getIteratorType().equals(ShardIteratorType.AT_SEQUENCE_NUMBER)). }
