commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;11;/**  * Resolve the query by loading the query from the classpath or file  * resource if needed.  */ ;/**  * Resolve the query by loading the query from the classpath or file  * resource if needed.  */ public static String resolveQuery(CamelContext camelContext, String query, String placeholder) throws NoTypeConversionAvailableException, IOException {     String answer = query.     if (ResourceHelper.hasScheme(query)) {         InputStream is = ResourceHelper.resolveMandatoryResourceAsInputStream(camelContext, query).         answer = camelContext.getTypeConverter().mandatoryConvertTo(String.class, is).         if (placeholder != null) {             answer = answer.replaceAll(placeholder, "@").         }     }     return answer. }
true;public,static;2;21;/**  * Replaces pattern in query in form of "${param}" with values from message  * header Raises an error if param value not found in headers  *  * @param exchange  * @return Translated query text  */ ;/**  * Replaces pattern in query in form of "${param}" with values from message  * header Raises an error if param value not found in headers  *  * @param exchange  * @return Translated query text  */ public static String translateQuery(String query, Exchange exchange) {     Message message = exchange.getMessage().     Matcher matcher = pattern.matcher(query).     StringBuffer stringBuffer = new StringBuffer().     while (matcher.find()) {         String paramKey = matcher.group(1).         String value = message.getHeader(paramKey, String.class).         if (value == null) {             value = exchange.getProperty(paramKey, String.class).             if (value == null) {                 throw new RuntimeExchangeException("SQL pattern with name '" + paramKey + "' not found in the message headers", exchange).             }         }         String replacement = Matcher.quoteReplacement(value).         matcher.appendReplacement(stringBuffer, replacement).     }     matcher.appendTail(stringBuffer).     return stringBuffer.toString(). }
true;public,static;1;9;/**  * Extracts list of parameters in form "@name" from query text  *  * @param query  * @return list of parameter names  */ ;/**  * Extracts list of parameters in form "@name" from query text  *  * @param query  * @return list of parameter names  */ public static Set<String> extractParameterNames(String query) {     Matcher matcher = parameterPattern.matcher(query).     Set<String> result = new HashSet<>().     while (matcher.find()) {         String paramName = matcher.group(1).         result.add(paramName).     }     return result. }
