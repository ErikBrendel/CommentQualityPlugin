commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void connect(HttpConsumer consumer) throws Exception {     component.connect(consumer). }
false;public;1;3;;public void disconnect(HttpConsumer consumer) throws Exception {     component.disconnect(consumer). }
false;public;1;3;;public boolean canConnect(HttpConsumer consumer) throws Exception {     return component.canConnect(consumer). }
false;public;0;4;;@Override public HttpCommonComponent getComponent() {     return (HttpCommonComponent) super.getComponent(). }
false;public;0;4;;public boolean isLenientProperties() {     // true to allow dynamic URI options to be configured and passed to external system for eg. the HttpProducer     return true. }
false;public;0;3;;public boolean isSingleton() {     return true. }
false;public;0;8;;// Service Registration // ------------------------------------------------------------------------- @Override public Map<String, String> getServiceProperties() {     return CollectionHelper.immutableMapOf(ServiceDefinition.SERVICE_META_PORT, Integer.toString(getPort()), ServiceDefinition.SERVICE_META_PATH, getPath(), ServiceDefinition.SERVICE_META_PROTOCOL, getProtocol()). }
true;public;0;4;/**  * @deprecated use {@link #getHttpBinding()}  */ ;// Properties // ------------------------------------------------------------------------- /**  * @deprecated use {@link #getHttpBinding()}  */ @Deprecated public HttpBinding getBinding() {     return httpBinding. }
true;public;1;4;/**  * @deprecated use {@link #setHttpBinding(HttpBinding)}  */ ;/**  * @deprecated use {@link #setHttpBinding(HttpBinding)}  */ @Deprecated public void setBinding(HttpBinding httpBinding) {     setHttpBinding(httpBinding). }
false;public;0;16;;public HttpBinding getHttpBinding() {     if (httpBinding == null) {         // create a new binding and use the options from this endpoint         httpBinding = new DefaultHttpBinding().         httpBinding.setHeaderFilterStrategy(getHeaderFilterStrategy()).         httpBinding.setTransferException(isTransferException()).         if (getComponent() != null) {             httpBinding.setAllowJavaSerializedObject(getComponent().isAllowJavaSerializedObject()).         }         httpBinding.setEagerCheckContentAvailable(isEagerCheckContentAvailable()).         httpBinding.setMapHttpMessageBody(isMapHttpMessageBody()).         httpBinding.setMapHttpMessageHeaders(isMapHttpMessageHeaders()).         httpBinding.setMapHttpMessageFormUrlEncodedBody(isMapHttpMessageFormUrlEncodedBody()).     }     return httpBinding. }
true;public;1;3;/**  * To use a custom HttpBinding to control the mapping between Camel message and HttpClient.  */ ;/**  * To use a custom HttpBinding to control the mapping between Camel message and HttpClient.  */ public void setHttpBinding(HttpBinding httpBinding) {     this.httpBinding = httpBinding. }
false;public;0;4;;public String getPath() {     // if the path is empty, we just return the default path here     return httpUri.getPath().length() == 0 ? "/" : httpUri.getPath(). }
false;public;0;10;;public int getPort() {     if (httpUri.getPort() == -1) {         if ("https".equals(getProtocol())) {             return 443.         } else {             return 80.         }     }     return httpUri.getPort(). }
false;public;0;3;;public String getProtocol() {     return httpUri.getScheme(). }
false;public;0;3;;public URI getHttpUri() {     return httpUri. }
true;public;1;3;/**  * The url of the HTTP endpoint to call.  */ ;/**  * The url of the HTTP endpoint to call.  */ public void setHttpUri(URI httpUri) {     this.httpUri = httpUri. }
false;public;0;3;;public HeaderFilterStrategy getHeaderFilterStrategy() {     return headerFilterStrategy. }
true;public;1;3;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ ;/**  * To use a custom HeaderFilterStrategy to filter header to and from Camel message.  */ public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {     this.headerFilterStrategy = headerFilterStrategy. }
false;public;0;3;;public boolean isThrowExceptionOnFailure() {     return throwExceptionOnFailure. }
true;public;1;3;/**  * Option to disable throwing the HttpOperationFailedException in case of failed responses from the remote server.  * This allows you to get all responses regardless of the HTTP status code.  */ ;/**  * Option to disable throwing the HttpOperationFailedException in case of failed responses from the remote server.  * This allows you to get all responses regardless of the HTTP status code.  */ public void setThrowExceptionOnFailure(boolean throwExceptionOnFailure) {     this.throwExceptionOnFailure = throwExceptionOnFailure. }
false;public;0;3;;public boolean isBridgeEndpoint() {     return bridgeEndpoint. }
true;public;1;3;/**  * If the option is true, HttpProducer will ignore the Exchange.HTTP_URI header, and use the endpoint's URI for request.  * You may also set the option throwExceptionOnFailure to be false to let the HttpProducer send all the fault response back.  */ ;/**  * If the option is true, HttpProducer will ignore the Exchange.HTTP_URI header, and use the endpoint's URI for request.  * You may also set the option throwExceptionOnFailure to be false to let the HttpProducer send all the fault response back.  */ public void setBridgeEndpoint(boolean bridge) {     this.bridgeEndpoint = bridge. }
false;public;0;3;;public boolean isPreserveHostHeader() {     return preserveHostHeader. }
true;public;1;3;/**  * If the option is true, HttpProducer will set the Host header to the value contained in the current exchange Host header,  * useful in reverse proxy applications where you want the Host header received by the downstream server to reflect the URL called by the upstream client,  * this allows applications which use the Host header to generate accurate URL's for a proxied service  */ ;/**  * If the option is true, HttpProducer will set the Host header to the value contained in the current exchange Host header,  * useful in reverse proxy applications where you want the Host header received by the downstream server to reflect the URL called by the upstream client,  * this allows applications which use the Host header to generate accurate URL's for a proxied service  */ public void setPreserveHostHeader(boolean preserveHostHeader) {     this.preserveHostHeader = preserveHostHeader. }
false;public;0;3;;public boolean isMatchOnUriPrefix() {     return matchOnUriPrefix. }
true;public;1;3;/**  * Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.  * <p/>  * See more details at: http://camel.apache.org/how-do-i-let-jetty-match-wildcards.html  */ ;/**  * Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.  * <p/>  * See more details at: http://camel.apache.org/how-do-i-let-jetty-match-wildcards.html  */ public void setMatchOnUriPrefix(boolean match) {     this.matchOnUriPrefix = match. }
false;public;0;3;;public boolean isDisableStreamCache() {     return this.disableStreamCache. }
true;public;1;3;/**  * Determines whether or not the raw input stream from Servlet is cached or not  * (Camel will read the stream into a in memory/overflow to file, Stream caching) cache.  * By default Camel will cache the Servlet input stream to support reading it multiple times to ensure it Camel  * can retrieve all data from the stream. However you can set this option to true when you for example need  * to access the raw stream, such as streaming it directly to a file or other persistent store.  * DefaultHttpBinding will copy the request input stream into a stream cache and put it into message body  * if this option is false to support reading the stream multiple times.  * If you use Servlet to bridge/proxy an endpoint then consider enabling this option to improve performance,  * in case you do not need to read the message payload multiple times.  *     + The http/http4 producer will by default cache the response body stream. If setting this option to true,  *     + then the producers will not cache the response body stream but use the response stream as-is as the message body.  */ ;/**  * Determines whether or not the raw input stream from Servlet is cached or not  * (Camel will read the stream into a in memory/overflow to file, Stream caching) cache.  * By default Camel will cache the Servlet input stream to support reading it multiple times to ensure it Camel  * can retrieve all data from the stream. However you can set this option to true when you for example need  * to access the raw stream, such as streaming it directly to a file or other persistent store.  * DefaultHttpBinding will copy the request input stream into a stream cache and put it into message body  * if this option is false to support reading the stream multiple times.  * If you use Servlet to bridge/proxy an endpoint then consider enabling this option to improve performance,  * in case you do not need to read the message payload multiple times.  *     + The http/http4 producer will by default cache the response body stream. If setting this option to true,  *     + then the producers will not cache the response body stream but use the response stream as-is as the message body.  */ public void setDisableStreamCache(boolean disable) {     this.disableStreamCache = disable. }
false;public;0;3;;public boolean isChunked() {     return this.chunked. }
true;public;1;3;/**  * If this option is false Servlet will disable the HTTP streaming and set the content-length header on the response  */ ;/**  * If this option is false Servlet will disable the HTTP streaming and set the content-length header on the response  */ public void setChunked(boolean chunked) {     this.chunked = chunked. }
false;public;0;3;;public boolean isTransferException() {     return transferException. }
false;public;0;3;;public boolean isConnectionClose() {     return connectionClose. }
true;public;1;3;/**  * If this option is true, the producer will add a Connection Close header to HTTP Request  */ ;/**  * If this option is true, the producer will add a Connection Close header to HTTP Request  */ public void setConnectionClose(boolean connectionClose) {     this.connectionClose = connectionClose. }
true;public;1;3;/**  * If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized  * in the response as a application/x-java-serialized-object content type.  * On the producer side the exception will be deserialized and thrown as is, instead of the HttpOperationFailedException.  * The caused exception is required to be serialized.  * <p/>  * This is by default turned off. If you enable this then be aware that Java will deserialize the incoming  * data from the request to Java and that can be a potential security risk.  */ ;/**  * If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized  * in the response as a application/x-java-serialized-object content type.  * On the producer side the exception will be deserialized and thrown as is, instead of the HttpOperationFailedException.  * The caused exception is required to be serialized.  * <p/>  * This is by default turned off. If you enable this then be aware that Java will deserialize the incoming  * data from the request to Java and that can be a potential security risk.  */ public void setTransferException(boolean transferException) {     this.transferException = transferException. }
false;public;0;3;;public boolean isTraceEnabled() {     return this.traceEnabled. }
true;public;1;3;/**  * Specifies whether to enable HTTP TRACE for this Servlet consumer. By default TRACE is turned off.  */ ;/**  * Specifies whether to enable HTTP TRACE for this Servlet consumer. By default TRACE is turned off.  */ public void setTraceEnabled(boolean traceEnabled) {     this.traceEnabled = traceEnabled. }
false;public;0;3;;public boolean isOptionsEnabled() {     return optionsEnabled. }
true;public;1;3;/**  * Specifies whether to enable HTTP OPTIONS for this Servlet consumer. By default OPTIONS is turned off.  */ ;/**  * Specifies whether to enable HTTP OPTIONS for this Servlet consumer. By default OPTIONS is turned off.  */ public void setOptionsEnabled(boolean optionsEnabled) {     this.optionsEnabled = optionsEnabled. }
false;public;0;3;;public String getHttpMethodRestrict() {     return httpMethodRestrict. }
true;public;1;3;/**  * Used to only allow consuming if the HttpMethod matches, such as GET/POST/PUT etc.  * Multiple methods can be specified separated by comma.  */ ;/**  * Used to only allow consuming if the HttpMethod matches, such as GET/POST/PUT etc.  * Multiple methods can be specified separated by comma.  */ public void setHttpMethodRestrict(String httpMethodRestrict) {     this.httpMethodRestrict = httpMethodRestrict. }
false;public;0;4;;@Deprecated public UrlRewrite getUrlRewrite() {     return urlRewrite. }
true;public;1;4;/**  * Refers to a custom org.apache.camel.component.http.UrlRewrite which allows you to rewrite urls when you bridge/proxy endpoints.  * See more details at http://camel.apache.org/urlrewrite.html  */ ;/**  * Refers to a custom org.apache.camel.component.http.UrlRewrite which allows you to rewrite urls when you bridge/proxy endpoints.  * See more details at http://camel.apache.org/urlrewrite.html  */ @Deprecated public void setUrlRewrite(UrlRewrite urlRewrite) {     this.urlRewrite = urlRewrite. }
false;public;0;3;;public Integer getResponseBufferSize() {     return responseBufferSize. }
true;public;1;3;/**  * To use a custom buffer size on the javax.servlet.ServletResponse.  */ ;/**  * To use a custom buffer size on the javax.servlet.ServletResponse.  */ public void setResponseBufferSize(Integer responseBufferSize) {     this.responseBufferSize = responseBufferSize. }
false;public;0;3;;public boolean isIgnoreResponseBody() {     return ignoreResponseBody. }
true;public;1;3;/**  * If this option is true, The http producer won't read response body and cache the input stream.  */ ;/**  * If this option is true, The http producer won't read response body and cache the input stream.  */ public void setIgnoreResponseBody(boolean ignoreResponseBody) {     this.ignoreResponseBody = ignoreResponseBody. }
true;public;0;3;/**  * If this option is true then IN exchange headers will be copied to OUT exchange headers according to copy strategy.  * Setting this to false, allows to only include the headers from the HTTP response (not propagating IN headers).  */ ;/**  * If this option is true then IN exchange headers will be copied to OUT exchange headers according to copy strategy.  * Setting this to false, allows to only include the headers from the HTTP response (not propagating IN headers).  */ public boolean isCopyHeaders() {     return copyHeaders. }
false;public;1;3;;public void setCopyHeaders(boolean copyHeaders) {     this.copyHeaders = copyHeaders. }
false;public;0;3;;public boolean isEagerCheckContentAvailable() {     return eagerCheckContentAvailable. }
true;public;1;3;/**  * Whether to eager check whether the HTTP requests has content if the content-length header is 0 or not present.  * This can be turned on in case HTTP clients do not send streamed data.  */ ;/**  * Whether to eager check whether the HTTP requests has content if the content-length header is 0 or not present.  * This can be turned on in case HTTP clients do not send streamed data.  */ public void setEagerCheckContentAvailable(boolean eagerCheckContentAvailable) {     this.eagerCheckContentAvailable = eagerCheckContentAvailable. }
false;public;0;3;;public String getOkStatusCodeRange() {     return okStatusCodeRange. }
true;public;1;3;/**  * The status codes which are considered a success response. The values are inclusive. Multiple ranges can be  * defined, separated by comma, e.g. <tt>200-204,209,301-304</tt>. Each range must be a single number or from-to with the  * dash included.  * <p/>  * The default range is <tt>200-299</tt>  */ ;/**  * The status codes which are considered a success response. The values are inclusive. Multiple ranges can be  * defined, separated by comma, e.g. <tt>200-204,209,301-304</tt>. Each range must be a single number or from-to with the  * dash included.  * <p/>  * The default range is <tt>200-299</tt>  */ public void setOkStatusCodeRange(String okStatusCodeRange) {     this.okStatusCodeRange = okStatusCodeRange. }
false;public;0;3;;public boolean isMapHttpMessageBody() {     return mapHttpMessageBody. }
true;public;1;3;/**  * If this option is true, the IN exchange body will be mapped to HTTP  */ ;/**  * If this option is true, the IN exchange body will be mapped to HTTP  */ public void setMapHttpMessageBody(boolean mapHttpMessageBody) {     this.mapHttpMessageBody = mapHttpMessageBody. }
false;public;0;3;;public boolean isMapHttpMessageHeaders() {     return mapHttpMessageHeaders. }
true;public;1;3;/**  * If this option is true, the IN exchange headers will be mapped to HTTP Headers  */ ;/**  * If this option is true, the IN exchange headers will be mapped to HTTP Headers  */ public void setMapHttpMessageHeaders(boolean mapHttpMessageHeaders) {     this.mapHttpMessageHeaders = mapHttpMessageHeaders. }
false;public;0;3;;public boolean isMapHttpMessageFormUrlEncodedBody() {     return mapHttpMessageFormUrlEncodedBody. }
true;public;1;3;/**  * If this option is true then IN exchange Form Encoded body will be mapped to HTTP  */ ;/**  * If this option is true then IN exchange Form Encoded body will be mapped to HTTP  */ public void setMapHttpMessageFormUrlEncodedBody(boolean mapHttpMessageFormUrlEncodedBody) {     this.mapHttpMessageFormUrlEncodedBody = mapHttpMessageFormUrlEncodedBody. }
false;public;0;3;;public boolean isAsync() {     return async. }
true;public;1;3;/**  * If this option is true, the consumer will work in async mode  */ ;/**  * If this option is true, the consumer will work in async mode  */ public void setAsync(boolean async) {     this.async = async. }
false;public;0;3;;public CookieHandler getCookieHandler() {     return cookieHandler. }
true;public;1;3;/**  * Configure a cookie handler to maintain a HTTP session  */ ;/**  * Configure a cookie handler to maintain a HTTP session  */ public void setCookieHandler(CookieHandler cookieHandler) {     this.cookieHandler = cookieHandler. }
false;public;0;3;;public HttpMethods getHttpMethod() {     return httpMethod. }
true;public;1;3;/**  * Configure the HTTP method to use. The HttpMethod header cannot override this option if set.  */ ;/**  * Configure the HTTP method to use. The HttpMethod header cannot override this option if set.  */ public void setHttpMethod(HttpMethods httpMethod) {     this.httpMethod = httpMethod. }
false;public;0;3;;public String getAuthMethod() {     return authMethod. }
true;public;1;3;/**  * Authentication methods allowed to use as a comma separated list of values Basic, Digest or NTLM.  */ ;/**  * Authentication methods allowed to use as a comma separated list of values Basic, Digest or NTLM.  */ public void setAuthMethod(String authMethod) {     this.authMethod = authMethod. }
false;public;0;3;;public String getAuthMethodPriority() {     return authMethodPriority. }
true;public;1;3;/**  * Which authentication method to prioritize to use, either as Basic, Digest or NTLM.  */ ;/**  * Which authentication method to prioritize to use, either as Basic, Digest or NTLM.  */ public void setAuthMethodPriority(String authMethodPriority) {     this.authMethodPriority = authMethodPriority. }
false;public;0;3;;public String getAuthUsername() {     return authUsername. }
true;public;1;3;/**  * Authentication username  */ ;/**  * Authentication username  */ public void setAuthUsername(String authUsername) {     this.authUsername = authUsername. }
false;public;0;3;;public String getAuthPassword() {     return authPassword. }
true;public;1;3;/**  * Authentication password  */ ;/**  * Authentication password  */ public void setAuthPassword(String authPassword) {     this.authPassword = authPassword. }
false;public;0;3;;public String getAuthDomain() {     return authDomain. }
true;public;1;3;/**  * Authentication domain to use with NTML  */ ;/**  * Authentication domain to use with NTML  */ public void setAuthDomain(String authDomain) {     this.authDomain = authDomain. }
false;public;0;3;;public String getAuthHost() {     return authHost. }
true;public;1;3;/**  * Authentication host to use with NTML  */ ;/**  * Authentication host to use with NTML  */ public void setAuthHost(String authHost) {     this.authHost = authHost. }
false;public;0;3;;public String getProxyAuthScheme() {     return proxyAuthScheme. }
true;public;1;3;/**  * Proxy authentication scheme to use  */ ;/**  * Proxy authentication scheme to use  */ public void setProxyAuthScheme(String proxyAuthScheme) {     this.proxyAuthScheme = proxyAuthScheme. }
false;public;0;3;;public String getProxyAuthMethod() {     return proxyAuthMethod. }
true;public;1;3;/**  * Proxy authentication method to use  */ ;/**  * Proxy authentication method to use  */ public void setProxyAuthMethod(String proxyAuthMethod) {     this.proxyAuthMethod = proxyAuthMethod. }
false;public;0;3;;public String getProxyAuthUsername() {     return proxyAuthUsername. }
true;public;1;3;/**  * Proxy authentication username  */ ;/**  * Proxy authentication username  */ public void setProxyAuthUsername(String proxyAuthUsername) {     this.proxyAuthUsername = proxyAuthUsername. }
false;public;0;3;;public String getProxyAuthPassword() {     return proxyAuthPassword. }
true;public;1;3;/**  * Proxy authentication password  */ ;/**  * Proxy authentication password  */ public void setProxyAuthPassword(String proxyAuthPassword) {     this.proxyAuthPassword = proxyAuthPassword. }
false;public;0;3;;public String getProxyAuthDomain() {     return proxyAuthDomain. }
true;public;1;3;/**  * Proxy authentication domain to use with NTML  */ ;/**  * Proxy authentication domain to use with NTML  */ public void setProxyAuthDomain(String proxyAuthDomain) {     this.proxyAuthDomain = proxyAuthDomain. }
false;public;0;3;;public String getProxyAuthHost() {     return proxyAuthHost. }
true;public;1;3;/**  * Proxy authentication host to use with NTML  */ ;/**  * Proxy authentication host to use with NTML  */ public void setProxyAuthHost(String proxyAuthHost) {     this.proxyAuthHost = proxyAuthHost. }
false;public;0;3;;public int getProxyAuthPort() {     return proxyAuthPort. }
true;public;1;3;/**  * Proxy authentication port  */ ;/**  * Proxy authentication port  */ public void setProxyAuthPort(int proxyAuthPort) {     this.proxyAuthPort = proxyAuthPort. }
false;public;0;3;;public String getProxyHost() {     return proxyHost. }
true;public;1;3;/**  * Proxy hostname to use  */ ;/**  * Proxy hostname to use  */ public void setProxyHost(String proxyHost) {     this.proxyHost = proxyHost. }
false;public;0;3;;public int getProxyPort() {     return proxyPort. }
true;public;1;3;/**  * Proxy port to use  */ ;/**  * Proxy port to use  */ public void setProxyPort(int proxyPort) {     this.proxyPort = proxyPort. }
