commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;@Override public void init(ServletConfig config) throws ServletException {     super.init(config).     this.servletName = config.getServletName().     final String asyncParam = config.getInitParameter(ASYNC_PARAM).     this.async = asyncParam == null ? false : ObjectHelper.toBoolean(asyncParam).     log.trace("servlet '{}' initialized with: async={}", servletName, async). }
false;protected;2;10;;@Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {     if (isAsync()) {         final AsyncContext context = req.startAsync().         // run async         context.start(() -> doServiceAsync(context)).     } else {         doService(req, resp).     } }
true;protected;1;19;/**  * This is used to handle request asynchronously  * @param context the {@link AsyncContext}  */ ;/**  * This is used to handle request asynchronously  * @param context the {@link AsyncContext}  */ protected void doServiceAsync(AsyncContext context) {     final HttpServletRequest request = (HttpServletRequest) context.getRequest().     final HttpServletResponse response = (HttpServletResponse) context.getResponse().     try {         doService(request, response).     } catch (Exception e) {         // An error shouldn't occur as we should handle most of error in doService         log.error("Error processing request", e).         try {             response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR).         } catch (Exception e1) {             log.debug("Cannot send reply to client!", e1).         }         // Need to wrap it in RuntimeException as it occurs in a Runnable         throw new RuntimeCamelException(e).     } finally {         context.complete().     } }
true;protected;2;124;/**  * This is the logical implementation to handle request with {@link CamelServlet}  * This is where most exceptions should be handled  *  * @param request the {@link HttpServletRequest}  * @param response the {@link HttpServletResponse}  * @throws ServletException  * @throws IOException  */ ;/**  * This is the logical implementation to handle request with {@link CamelServlet}  * This is where most exceptions should be handled  *  * @param request the {@link HttpServletRequest}  * @param response the {@link HttpServletResponse}  * @throws ServletException  * @throws IOException  */ protected void doService(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {     log.trace("Service: {}", request).     // Is there a consumer registered for the request.     HttpConsumer consumer = resolve(request).     if (consumer == null) {         // okay we cannot process this requires so return either 404 or 405.         // to know if its 405 then we need to check if any other HTTP method would have a consumer for the "same" request         boolean hasAnyMethod = METHODS.stream().anyMatch(m -> getServletResolveConsumerStrategy().isHttpMethodAllowed(request, m, getConsumers())).         if (hasAnyMethod) {             log.debug("No consumer to service request {} as method {} is not allowed", request, request.getMethod()).             response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED).             return.         } else {             log.debug("No consumer to service request {} as resource is not found", request).             response.sendError(HttpServletResponse.SC_NOT_FOUND).             return.         }     }     // are we suspended?     if (consumer.isSuspended()) {         log.debug("Consumer suspended, cannot service request {}", request).         response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE).         return.     }     // if its an OPTIONS request then return which method is allowed     if ("OPTIONS".equals(request.getMethod()) && !consumer.isOptionsEnabled()) {         String allowedMethods = METHODS.stream().filter(m -> getServletResolveConsumerStrategy().isHttpMethodAllowed(request, m, getConsumers())).collect(Collectors.joining(",")).         if (allowedMethods == null && consumer.getEndpoint().getHttpMethodRestrict() != null) {             allowedMethods = consumer.getEndpoint().getHttpMethodRestrict().         }         if (allowedMethods == null) {             // allow them all             allowedMethods = "GET,HEAD,POST,PUT,DELETE,TRACE,OPTIONS,CONNECT,PATCH".         }         if (!allowedMethods.contains("OPTIONS")) {             allowedMethods = allowedMethods + ",OPTIONS".         }         response.addHeader("Allow", allowedMethods).         response.setStatus(HttpServletResponse.SC_OK).         return.     }     if (consumer.getEndpoint().getHttpMethodRestrict() != null && !consumer.getEndpoint().getHttpMethodRestrict().contains(request.getMethod())) {         response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED).         return.     }     if ("TRACE".equals(request.getMethod()) && !consumer.isTraceEnabled()) {         response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED).         return.     }     // create exchange and set data on it     Exchange exchange = consumer.getEndpoint().createExchange(ExchangePattern.InOut).     if (consumer.getEndpoint().isBridgeEndpoint()) {         exchange.setProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.TRUE).         exchange.setProperty(Exchange.SKIP_WWW_FORM_URLENCODED, Boolean.TRUE).     }     if (consumer.getEndpoint().isDisableStreamCache()) {         exchange.setProperty(Exchange.DISABLE_HTTP_STREAM_CACHE, Boolean.TRUE).     }     // we override the classloader before building the HttpMessage just in case the binding     // does some class resolution     ClassLoader oldTccl = overrideTccl(exchange).     HttpHelper.setCharsetFromContentType(request.getContentType(), exchange).     exchange.setIn(new HttpMessage(exchange, consumer.getEndpoint(), request, response)).     // set context path as header     String contextPath = consumer.getEndpoint().getPath().     exchange.getIn().setHeader("CamelServletContextPath", contextPath).     String httpPath = (String) exchange.getIn().getHeader(Exchange.HTTP_PATH).     // here we just remove the CamelServletContextPath part from the HTTP_PATH     if (contextPath != null && httpPath.startsWith(contextPath)) {         exchange.getIn().setHeader(Exchange.HTTP_PATH, httpPath.substring(contextPath.length())).     }     // we want to handle the UoW     try {         consumer.createUoW(exchange).     } catch (Exception e) {         log.error("Error processing request", e).         throw new ServletException(e).     }     try {         if (log.isTraceEnabled()) {             log.trace("Processing request for exchangeId: {}", exchange.getExchangeId()).         }         // process the exchange         consumer.getProcessor().process(exchange).     } catch (Exception e) {         exchange.setException(e).     }     try {         // now lets output to the response         if (log.isTraceEnabled()) {             log.trace("Writing response for exchangeId: {}", exchange.getExchangeId()).         }         Integer bs = consumer.getEndpoint().getResponseBufferSize().         if (bs != null) {             log.trace("Using response buffer size: {}", bs).             response.setBufferSize(bs).         }         consumer.getBinding().writeResponse(exchange, response).     } catch (IOException e) {         log.error("Error processing request", e).         throw e.     } catch (Exception e) {         log.error("Error processing request", e).         throw new ServletException(e).     } finally {         consumer.doneUoW(exchange).         restoreTccl(exchange, oldTccl).     } }
true;protected;1;4;/**  * @deprecated use {@link ServletResolveConsumerStrategy#resolve(javax.servlet.http.HttpServletRequest, java.util.Map)}  */ ;/**  * @deprecated use {@link ServletResolveConsumerStrategy#resolve(javax.servlet.http.HttpServletRequest, java.util.Map)}  */ @Deprecated protected HttpConsumer resolve(HttpServletRequest request) {     return getServletResolveConsumerStrategy().resolve(request, getConsumers()). }
false;public;1;4;;public void connect(HttpConsumer consumer) {     log.debug("Connecting consumer: {}", consumer).     consumers.put(consumer.getEndpoint().getEndpointUri(), consumer). }
false;public;1;4;;public void disconnect(HttpConsumer consumer) {     log.debug("Disconnecting consumer: {}", consumer).     consumers.remove(consumer.getEndpoint().getEndpointUri()). }
false;public;0;3;;public String getServletName() {     return servletName. }
false;public;1;3;;public void setServletName(String servletName) {     this.servletName = servletName. }
false;public;0;3;;public ServletResolveConsumerStrategy getServletResolveConsumerStrategy() {     return servletResolveConsumerStrategy. }
false;public;1;3;;public void setServletResolveConsumerStrategy(ServletResolveConsumerStrategy servletResolveConsumerStrategy) {     this.servletResolveConsumerStrategy = servletResolveConsumerStrategy. }
false;public;0;3;;public boolean isAsync() {     return async. }
false;public;1;3;;public void setAsync(boolean async) {     this.async = async. }
false;public;0;3;;public Map<String, HttpConsumer> getConsumers() {     return Collections.unmodifiableMap(consumers). }
true;protected;1;17;/**  * Override the Thread Context ClassLoader if need be.  * @return old classloader if overridden. otherwise returns null  */ ;/**  * Override the Thread Context ClassLoader if need be.  * @return old classloader if overridden. otherwise returns null  */ protected ClassLoader overrideTccl(final Exchange exchange) {     ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader().     ClassLoader appCtxCl = exchange.getContext().getApplicationContextClassLoader().     if (oldClassLoader == null || appCtxCl == null) {         return null.     }     if (!oldClassLoader.equals(appCtxCl)) {         Thread.currentThread().setContextClassLoader(appCtxCl).         if (log.isTraceEnabled()) {             log.trace("Overrode TCCL for exchangeId {} to {} on thread {}", new Object[] { exchange.getExchangeId(), appCtxCl, Thread.currentThread().getName() }).         }         return oldClassLoader.     }     return null. }
true;protected;2;10;/**  * Restore the Thread Context ClassLoader if the old TCCL is not null.  */ ;/**  * Restore the Thread Context ClassLoader if the old TCCL is not null.  */ protected void restoreTccl(final Exchange exchange, ClassLoader oldTccl) {     if (oldTccl == null) {         return.     }     Thread.currentThread().setContextClassLoader(oldTccl).     if (log.isTraceEnabled()) {         log.trace("Restored TCCL for exchangeId {} to {} on thread {}", new String[] { exchange.getExchangeId(), oldTccl.toString(), Thread.currentThread().getName() }).     } }
