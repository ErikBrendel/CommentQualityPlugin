commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Class<SpringCamelContext> getObjectType() {     return SpringCamelContext.class. }
false;protected;1;17;;protected <S> S getBeanForType(Class<S> clazz) {     S bean = null.     String[] names = getApplicationContext().getBeanNamesForType(clazz, true, true).     if (names.length == 1) {         bean = getApplicationContext().getBean(names[0], clazz).     }     if (bean == null) {         ApplicationContext parentContext = getApplicationContext().getParent().         if (parentContext != null) {             names = parentContext.getBeanNamesForType(clazz, true, true).             if (names.length == 1) {                 bean = parentContext.getBean(names[0], clazz).             }         }     }     return bean. }
false;protected;3;12;;@Override protected void findRouteBuildersByPackageScan(String[] packages, PackageScanFilter filter, List<RoutesBuilder> builders) throws Exception {     // add filter to class resolver which then will filter     getContext().getPackageScanClassResolver().addFilter(filter).     PackageScanRouteBuilderFinder finder = new PackageScanRouteBuilderFinder(getContext(), packages, getContextClassLoaderOnStart(), getBeanPostProcessor(), getContext().getPackageScanClassResolver()).     finder.appendBuilders(builders).     // and remove the filter     getContext().getPackageScanClassResolver().removeFilter(filter). }
false;protected;3;5;;@Override protected void findRouteBuildersByContextScan(PackageScanFilter filter, boolean includeNonSingletons, List<RoutesBuilder> builders) throws Exception {     ContextScanRouteBuilderFinder finder = new ContextScanRouteBuilderFinder(getContext(), filter, includeNonSingletons).     finder.appendBuilders(builders). }
false;protected;1;10;;protected void initBeanPostProcessor(SpringCamelContext context) {     if (beanPostProcessor != null) {         if (beanPostProcessor instanceof ApplicationContextAware) {             ((ApplicationContextAware) beanPostProcessor).setApplicationContext(applicationContext).         }         if (beanPostProcessor instanceof CamelBeanPostProcessor) {             ((CamelBeanPostProcessor) beanPostProcessor).setCamelContext(getContext()).         }     } }
false;protected;1;6;;protected void postProcessBeforeInit(RouteBuilder builder) {     if (beanPostProcessor != null) {         // Inject the annotated resource         beanPostProcessor.postProcessBeforeInitialization(builder, builder.toString()).     } }
false;public;0;14;;@Override public void afterPropertiesSet() throws Exception {     StopWatch watch = new StopWatch().     super.afterPropertiesSet().     Boolean shutdownEager = CamelContextHelper.parseBoolean(getContext(), getShutdownEager()).     if (shutdownEager != null) {         LOG.debug("Using shutdownEager: {}", shutdownEager).         getContext().setShutdownEager(shutdownEager).     }     LOG.debug("afterPropertiesSet() took {} millis", watch.taken()). }
false;protected;1;7;;protected void initCustomRegistry(SpringCamelContext context) {     Registry registry = getBeanForType(Registry.class).     if (registry != null) {         LOG.info("Using custom Registry: {}", registry).         context.setRegistry(registry).     } }
false;protected;0;37;;@Override protected void initPropertyPlaceholder() throws Exception {     super.initPropertyPlaceholder().     Map<String, BridgePropertyPlaceholderConfigurer> beans = applicationContext.getBeansOfType(BridgePropertyPlaceholderConfigurer.class).     if (beans.size() == 1) {         // setup properties component that uses this beans         BridgePropertyPlaceholderConfigurer configurer = beans.values().iterator().next().         String id = beans.keySet().iterator().next().         LOG.info("Bridging Camel and Spring property placeholder configurer with id: {}", id).         // get properties component         PropertiesComponent pc = (PropertiesComponent) getContext().getComponent("properties", false).         if (pc == null) {             // do not auto create the component as spring autowrire by constructor causes a side effect when using bridge             pc = new PropertiesComponent().             getContext().addComponent("properties", pc).         }         // use the spring system properties mode which has a different value than Camel may have         pc.setSystemPropertiesMode(configurer.getSystemPropertiesMode()).         // replace existing resolver with us         configurer.setResolver(pc.getPropertiesResolver()).         configurer.setParser(pc.getPropertiesParser()).         // use the bridge to handle the resolve and parsing         pc.setPropertiesResolver(configurer).         pc.setPropertiesParser(configurer).         // and update locations to have our as ref first         List<PropertiesLocation> locations = new ArrayList<>(pc.getLocations()).         locations.add(0, new PropertiesLocation("ref", id)).         pc.setLocations(locations).     } else if (beans.size() > 1) {         LOG.warn("Cannot bridge Camel and Spring property placeholders, as exact only 1 bean of type BridgePropertyPlaceholderConfigurer" + " must be defined, was {} beans defined.", beans.size()).     } }
false;public;0;11;;@Override public void start() {     try {         setupRoutes().     } catch (Exception e) {         throw wrapRuntimeCamelException(e).     }     // when the routes are setup we need to start the Camel context     context.start(). }
false;public;0;6;;@Override public void stop() {     if (context != null) {         context.stop().     } }
false;public;0;4;;@Override public boolean isRunning() {     return context != null && context.isRunning(). }
false;public;0;13;;@Override public int getPhase() {     // only when stopping and then in reversed order     return LOWEST_PRECEDENCE - 1. }
false;public;0;10;;@Override public int getOrder() {     // org.apache.camel.spring.boot.RoutesCollector)     return LOWEST_PRECEDENCE - 1. }
false;public;1;9;;@Override public void onApplicationEvent(final ContextRefreshedEvent event) {     // start the CamelContext when the Spring ApplicationContext is     // done initializing, as the last step in ApplicationContext     // being started/refreshed, there could be a race condition with     // other ApplicationListeners that react to     // ContextRefreshedEvent but this is the best that we can do     start(). }
false;public;0;6;;// Properties // ------------------------------------------------------------------------- public ApplicationContext getApplicationContext() {     if (applicationContext == null) {         throw new IllegalArgumentException("No applicationContext has been injected!").     }     return applicationContext. }
false;public;1;4;;@Override public void setApplicationContext(ApplicationContext applicationContext) {     this.applicationContext = applicationContext. }
false;public;1;3;;public void setBeanPostProcessor(BeanPostProcessor postProcessor) {     this.beanPostProcessor = postProcessor. }
false;public;0;3;;public BeanPostProcessor getBeanPostProcessor() {     return beanPostProcessor. }
true;protected;0;6;/**  * Create the context  */ ;// Implementation methods // ------------------------------------------------------------------------- /**  * Create the context  */ protected SpringCamelContext createContext() {     SpringCamelContext ctx = newCamelContext().     ctx.setName(getId()).     return ctx. }
true;protected;1;14;/**  * Apply additional configuration to the context  */ ;/**  * Apply additional configuration to the context  */ protected void configure(SpringCamelContext ctx) {     try {         // allow any custom configuration, such as when running in camel-spring-boot         if (applicationContext.containsBean("xmlCamelContextConfigurer")) {             XmlCamelContextConfigurer configurer = applicationContext.getBean("xmlCamelContextConfigurer", XmlCamelContextConfigurer.class).             if (configurer != null) {                 configurer.configure(applicationContext, ctx).             }         }     } catch (Exception e) {         // error during configuration         throw RuntimeCamelException.wrapRuntimeCamelException(e).     } }
false;protected;0;3;;protected SpringCamelContext newCamelContext() {     return new SpringCamelContext(getApplicationContext()). }
false;public;1;8;;public SpringCamelContext getContext(boolean create) {     if (context == null && create) {         context = createContext().         configure(context).         context.init().     }     return context. }
false;public;1;3;;public void setContext(SpringCamelContext context) {     this.context = context. }
false;public;0;3;;public List<RouteDefinition> getRoutes() {     return routes. }
true;public;1;3;/**  * Contains the Camel routes  */ ;/**  * Contains the Camel routes  */ public void setRoutes(List<RouteDefinition> routes) {     this.routes = routes. }
false;public;0;3;;public List<RestDefinition> getRests() {     return rests. }
true;public;1;3;/**  * Contains the rest services defined using the rest-dsl  */ ;/**  * Contains the rest services defined using the rest-dsl  */ public void setRests(List<RestDefinition> rests) {     this.rests = rests. }
false;public;0;3;;public RestConfigurationDefinition getRestConfiguration() {     return restConfiguration. }
true;public;1;3;/**  * Configuration for rest-dsl  */ ;/**  * Configuration for rest-dsl  */ public void setRestConfiguration(RestConfigurationDefinition restConfiguration) {     this.restConfiguration = restConfiguration. }
false;public;0;3;;public List<CamelEndpointFactoryBean> getEndpoints() {     return endpoints. }
true;public;1;3;/**  * Configuration of endpoints  */ ;/**  * Configuration of endpoints  */ public void setEndpoints(List<CamelEndpointFactoryBean> endpoints) {     this.endpoints = endpoints. }
false;public;0;3;;public List<CamelRedeliveryPolicyFactoryBean> getRedeliveryPolicies() {     return redeliveryPolicies. }
false;public;0;3;;public List<InterceptDefinition> getIntercepts() {     return intercepts. }
true;public;1;3;/**  * Configuration of interceptors.  */ ;/**  * Configuration of interceptors.  */ public void setIntercepts(List<InterceptDefinition> intercepts) {     this.intercepts = intercepts. }
false;public;0;3;;public List<InterceptFromDefinition> getInterceptFroms() {     return interceptFroms. }
true;public;1;3;/**  * Configuration of interceptors that triggers from the beginning of routes.  */ ;/**  * Configuration of interceptors that triggers from the beginning of routes.  */ public void setInterceptFroms(List<InterceptFromDefinition> interceptFroms) {     this.interceptFroms = interceptFroms. }
false;public;0;3;;public List<InterceptSendToEndpointDefinition> getInterceptSendToEndpoints() {     return interceptSendToEndpoints. }
true;public;1;3;/**  * Configuration of interceptors that triggers sending messages to endpoints.  */ ;/**  * Configuration of interceptors that triggers sending messages to endpoints.  */ public void setInterceptSendToEndpoints(List<InterceptSendToEndpointDefinition> interceptSendToEndpoints) {     this.interceptSendToEndpoints = interceptSendToEndpoints. }
false;public;0;4;;@Override public GlobalOptionsDefinition getGlobalOptions() {     return globalOptions. }
true;public;1;3;/**  * Configuration of CamelContext properties such as limit of debug logging  * and other general options.  */ ;/**  * Configuration of CamelContext properties such as limit of debug logging  * and other general options.  */ public void setGlobalOptions(GlobalOptionsDefinition globalOptions) {     this.globalOptions = globalOptions. }
false;public;0;3;;public String[] getPackages() {     return packages. }
true;public;1;3;/**  * Sets the package names to be recursively searched for Java classes which  * extend {@link org.apache.camel.builder.RouteBuilder} to be auto-wired up to the  * {@link CamelContext} as a route. Note that classes are excluded if  * they are specifically configured in the spring.xml  * <p/>  * A more advanced configuration can be done using {@link #setPackageScan(org.apache.camel.model.PackageScanDefinition)}  *  * @param packages the package names which are recursively searched  * @see #setPackageScan(org.apache.camel.model.PackageScanDefinition)  */ ;/**  * Sets the package names to be recursively searched for Java classes which  * extend {@link org.apache.camel.builder.RouteBuilder} to be auto-wired up to the  * {@link CamelContext} as a route. Note that classes are excluded if  * they are specifically configured in the spring.xml  * <p/>  * A more advanced configuration can be done using {@link #setPackageScan(org.apache.camel.model.PackageScanDefinition)}  *  * @param packages the package names which are recursively searched  * @see #setPackageScan(org.apache.camel.model.PackageScanDefinition)  */ public void setPackages(String[] packages) {     this.packages = packages. }
false;public;0;3;;public PackageScanDefinition getPackageScan() {     return packageScan. }
true;public;1;3;/**  * Sets the package scanning information. Package scanning allows for the  * automatic discovery of certain camel classes at runtime for inclusion  * e.g. {@link org.apache.camel.builder.RouteBuilder} implementations  *  * @param packageScan the package scan  */ ;/**  * Sets the package scanning information. Package scanning allows for the  * automatic discovery of certain camel classes at runtime for inclusion  * e.g. {@link org.apache.camel.builder.RouteBuilder} implementations  *  * @param packageScan the package scan  */ public void setPackageScan(PackageScanDefinition packageScan) {     this.packageScan = packageScan. }
false;public;0;3;;public ContextScanDefinition getContextScan() {     return contextScan. }
true;public;1;3;/**  * Sets the context scanning (eg Spring's ApplicationContext) information.  * Context scanning allows for the automatic discovery of Camel routes runtime for inclusion  * e.g. {@link org.apache.camel.builder.RouteBuilder} implementations  *  * @param contextScan the context scan  */ ;/**  * Sets the context scanning (eg Spring's ApplicationContext) information.  * Context scanning allows for the automatic discovery of Camel routes runtime for inclusion  * e.g. {@link org.apache.camel.builder.RouteBuilder} implementations  *  * @param contextScan the context scan  */ public void setContextScan(ContextScanDefinition contextScan) {     this.contextScan = contextScan. }
false;public;0;3;;public CamelPropertyPlaceholderDefinition getCamelPropertyPlaceholder() {     return camelPropertyPlaceholder. }
true;public;1;3;/**  * Configuration of property placeholder  */ ;/**  * Configuration of property placeholder  */ public void setCamelPropertyPlaceholder(CamelPropertyPlaceholderDefinition camelPropertyPlaceholder) {     this.camelPropertyPlaceholder = camelPropertyPlaceholder. }
false;public;0;3;;public CamelStreamCachingStrategyDefinition getCamelStreamCachingStrategy() {     return camelStreamCachingStrategy. }
true;public;1;3;/**  * Configuration of stream caching.  */ ;/**  * Configuration of stream caching.  */ public void setCamelStreamCachingStrategy(CamelStreamCachingStrategyDefinition camelStreamCachingStrategy) {     this.camelStreamCachingStrategy = camelStreamCachingStrategy. }
true;public;1;3;/**  * Configuration of JMX.  */ ;/**  * Configuration of JMX.  */ public void setCamelJMXAgent(CamelJMXAgentDefinition agent) {     camelJMXAgent = agent. }
false;public;0;3;;public String getTrace() {     return trace. }
true;public;1;3;/**  * Sets whether tracing is enabled or not.  */ ;/**  * Sets whether tracing is enabled or not.  */ public void setTrace(String trace) {     this.trace = trace. }
false;public;0;3;;public String getMessageHistory() {     return messageHistory. }
true;public;1;3;/**  * Sets whether message history is enabled or not.  */ ;/**  * Sets whether message history is enabled or not.  */ public void setMessageHistory(String messageHistory) {     this.messageHistory = messageHistory. }
false;public;0;3;;public String getLogMask() {     return logMask. }
true;public;1;3;/**  * Sets whether security mask for Logging is enabled or not.  */ ;/**  * Sets whether security mask for Logging is enabled or not.  */ public void setLogMask(String logMask) {     this.logMask = logMask. }
false;public;0;3;;public String getLogExhaustedMessageBody() {     return logExhaustedMessageBody. }
true;public;1;3;/**  * Sets whether to log exhausted message body with message history.  */ ;/**  * Sets whether to log exhausted message body with message history.  */ public void setLogExhaustedMessageBody(String logExhaustedMessageBody) {     this.logExhaustedMessageBody = logExhaustedMessageBody. }
false;public;0;3;;public String getStreamCache() {     return streamCache. }
true;public;1;3;/**  * Sets whether stream caching is enabled or not.  */ ;/**  * Sets whether stream caching is enabled or not.  */ public void setStreamCache(String streamCache) {     this.streamCache = streamCache. }
false;public;0;3;;public String getDelayer() {     return delayer. }
true;public;1;3;/**  * Sets a delay value in millis that a message is delayed at every step it takes in the route path,  * slowing the process down to better observe what is occurring  */ ;/**  * Sets a delay value in millis that a message is delayed at every step it takes in the route path,  * slowing the process down to better observe what is occurring  */ public void setDelayer(String delayer) {     this.delayer = delayer. }
false;public;0;3;;public String getHandleFault() {     return handleFault. }
true;public;1;3;/**  * Sets whether fault handling is enabled or not (default is disabled).  */ ;/**  * Sets whether fault handling is enabled or not (default is disabled).  */ public void setHandleFault(String handleFault) {     this.handleFault = handleFault. }
false;public;0;3;;public String getAutoStartup() {     return autoStartup. }
true;public;1;3;/**  * Sets whether the object should automatically start when Camel starts.  * <p/>  * <b>Important:</b> Currently only routes can be disabled, as {@link CamelContext}s are always started.  * <br/>  * <b>Note:</b> When setting auto startup <tt>false</tt> on {@link CamelContext} then that takes precedence  * and <i>no</i> routes is started. You would need to start {@link CamelContext} explicit using  * the {@link org.apache.camel.CamelContext#start()} method, to start the context, and then  * you would need to start the routes manually using {@link org.apache.camel.spi.RouteController#startRoute(String)}.  */ ;/**  * Sets whether the object should automatically start when Camel starts.  * <p/>  * <b>Important:</b> Currently only routes can be disabled, as {@link CamelContext}s are always started.  * <br/>  * <b>Note:</b> When setting auto startup <tt>false</tt> on {@link CamelContext} then that takes precedence  * and <i>no</i> routes is started. You would need to start {@link CamelContext} explicit using  * the {@link org.apache.camel.CamelContext#start()} method, to start the context, and then  * you would need to start the routes manually using {@link org.apache.camel.spi.RouteController#startRoute(String)}.  */ public void setAutoStartup(String autoStartup) {     this.autoStartup = autoStartup. }
false;public;0;3;;public String getShutdownEager() {     return shutdownEager. }
true;public;1;3;/**  * Whether to shutdown CamelContext eager when Spring is shutting down.  * This ensure a cleaner shutdown of Camel, as dependent bean's are not shutdown at this moment.  * The bean's will then be shutdown after camelContext.  */ ;/**  * Whether to shutdown CamelContext eager when Spring is shutting down.  * This ensure a cleaner shutdown of Camel, as dependent bean's are not shutdown at this moment.  * The bean's will then be shutdown after camelContext.  */ public void setShutdownEager(String shutdownEager) {     this.shutdownEager = shutdownEager. }
false;public;0;3;;public String getUseMDCLogging() {     return useMDCLogging. }
true;public;1;3;/**  * Set whether <a href="http://www.slf4j.org/api/org/slf4j/MDC.html">MDC</a> is enabled.  */ ;/**  * Set whether <a href="http://www.slf4j.org/api/org/slf4j/MDC.html">MDC</a> is enabled.  */ public void setUseMDCLogging(String useMDCLogging) {     this.useMDCLogging = useMDCLogging. }
false;public;0;3;;public String getUseDataType() {     return useDataType. }
true;public;1;3;/**  * Whether to enable using data type on Camel messages.  * <p/>  * Data type are automatic turned on if:  * <ul>  *   <li>one ore more routes has been explicit configured with input and output types</li>  *   <li>when using rest-dsl with binding turned on</li>  * </ul>  * Otherwise data type is default off.  */ ;/**  * Whether to enable using data type on Camel messages.  * <p/>  * Data type are automatic turned on if:  * <ul>  *   <li>one ore more routes has been explicit configured with input and output types</li>  *   <li>when using rest-dsl with binding turned on</li>  * </ul>  * Otherwise data type is default off.  */ public void setUseDataType(String useDataType) {     this.useDataType = useDataType. }
false;public;0;3;;public String getUseBreadcrumb() {     return useBreadcrumb. }
true;public;1;3;/**  * Set whether breadcrumb is enabled.  */ ;/**  * Set whether breadcrumb is enabled.  */ public void setUseBreadcrumb(String useBreadcrumb) {     this.useBreadcrumb = useBreadcrumb. }
false;public;0;3;;public String getAllowUseOriginalMessage() {     return allowUseOriginalMessage. }
true;public;1;3;/**  * Sets whether to allow access to the original message from Camel's error handler,  * or from {@link org.apache.camel.spi.UnitOfWork#getOriginalInMessage()}.  * <p/>  * Turning this off can optimize performance, as defensive copy of the original message is not needed.  */ ;/**  * Sets whether to allow access to the original message from Camel's error handler,  * or from {@link org.apache.camel.spi.UnitOfWork#getOriginalInMessage()}.  * <p/>  * Turning this off can optimize performance, as defensive copy of the original message is not needed.  */ public void setAllowUseOriginalMessage(String allowUseOriginalMessage) {     this.allowUseOriginalMessage = allowUseOriginalMessage. }
false;public;0;3;;public String getRuntimeEndpointRegistryEnabled() {     return runtimeEndpointRegistryEnabled. }
true;public;1;3;/**  * Sets whether {@link org.apache.camel.spi.RuntimeEndpointRegistry} is enabled.  */ ;/**  * Sets whether {@link org.apache.camel.spi.RuntimeEndpointRegistry} is enabled.  */ public void setRuntimeEndpointRegistryEnabled(String runtimeEndpointRegistryEnabled) {     this.runtimeEndpointRegistryEnabled = runtimeEndpointRegistryEnabled. }
false;public;0;3;;public String getManagementNamePattern() {     return managementNamePattern. }
true;public;1;3;/**  * The naming pattern for creating the CamelContext management name.  */ ;/**  * The naming pattern for creating the CamelContext management name.  */ public void setManagementNamePattern(String managementNamePattern) {     this.managementNamePattern = managementNamePattern. }
false;public;0;3;;public String getThreadNamePattern() {     return threadNamePattern. }
true;public;1;3;/**  * Sets the thread name pattern used for creating the full thread name.  * <p/>  * The default pattern is: <tt>Camel (#camelId#) thread ##counter# - #name#</tt>  * <p/>  * Where <tt>#camelId#</tt> is the name of the {@link org.apache.camel.CamelContext}  * <br/>and <tt>#counter#</tt> is a unique incrementing counter.  * <br/>and <tt>#name#</tt> is the regular thread name.  * <br/>You can also use <tt>#longName#</tt> is the long thread name which can includes endpoint parameters etc.  */ ;/**  * Sets the thread name pattern used for creating the full thread name.  * <p/>  * The default pattern is: <tt>Camel (#camelId#) thread ##counter# - #name#</tt>  * <p/>  * Where <tt>#camelId#</tt> is the name of the {@link org.apache.camel.CamelContext}  * <br/>and <tt>#counter#</tt> is a unique incrementing counter.  * <br/>and <tt>#name#</tt> is the regular thread name.  * <br/>You can also use <tt>#longName#</tt> is the long thread name which can includes endpoint parameters etc.  */ public void setThreadNamePattern(String threadNamePattern) {     this.threadNamePattern = threadNamePattern. }
false;public;0;4;;@Override public Boolean getLoadTypeConverters() {     return loadTypeConverters. }
true;public;1;3;/**  * Sets whether to load custom type converters by scanning classpath.  * This can be turned off if you are only using Camel components  * that does not provide type converters which is needed at runtime.  * In such situations setting this option to false, can speedup starting  * Camel.  *  * @param loadTypeConverters whether to load custom type converters.  */ ;/**  * Sets whether to load custom type converters by scanning classpath.  * This can be turned off if you are only using Camel components  * that does not provide type converters which is needed at runtime.  * In such situations setting this option to false, can speedup starting  * Camel.  *  * @param loadTypeConverters whether to load custom type converters.  */ public void setLoadTypeConverters(Boolean loadTypeConverters) {     this.loadTypeConverters = loadTypeConverters. }
false;public;0;3;;public Boolean getTypeConverterStatisticsEnabled() {     return typeConverterStatisticsEnabled. }
true;public;1;3;/**  * Sets whether or not type converter statistics is enabled.  * <p/>  * By default the type converter utilization statistics is disabled.  * <b>Notice:</b> If enabled then there is a slight performance impact under very heavy load.  * <p/>  * You can enable/disable the statistics at runtime using the  * {@link org.apache.camel.spi.TypeConverterRegistry#getStatistics()#setTypeConverterStatisticsEnabled(Boolean)} method,  * or from JMX on the {@link org.apache.camel.api.management.mbean.ManagedTypeConverterRegistryMBean} mbean.  */ ;/**  * Sets whether or not type converter statistics is enabled.  * <p/>  * By default the type converter utilization statistics is disabled.  * <b>Notice:</b> If enabled then there is a slight performance impact under very heavy load.  * <p/>  * You can enable/disable the statistics at runtime using the  * {@link org.apache.camel.spi.TypeConverterRegistry#getStatistics()#setTypeConverterStatisticsEnabled(Boolean)} method,  * or from JMX on the {@link org.apache.camel.api.management.mbean.ManagedTypeConverterRegistryMBean} mbean.  */ public void setTypeConverterStatisticsEnabled(Boolean typeConverterStatisticsEnabled) {     this.typeConverterStatisticsEnabled = typeConverterStatisticsEnabled. }
false;public;0;3;;public TypeConverterExists getTypeConverterExists() {     return typeConverterExists. }
true;public;1;3;/**  * What should happen when attempting to add a duplicate type converter.  * <p/>  * The default behavior is to override the existing.  */ ;/**  * What should happen when attempting to add a duplicate type converter.  * <p/>  * The default behavior is to override the existing.  */ public void setTypeConverterExists(TypeConverterExists typeConverterExists) {     this.typeConverterExists = typeConverterExists. }
false;public;0;3;;public LoggingLevel getTypeConverterExistsLoggingLevel() {     return typeConverterExistsLoggingLevel. }
true;public;1;3;/**  * The logging level to use when logging that a type converter already exists when attempting to add a duplicate type converter.  * <p/>  * The default logging level is <tt>WARN</tt>  */ ;/**  * The logging level to use when logging that a type converter already exists when attempting to add a duplicate type converter.  * <p/>  * The default logging level is <tt>WARN</tt>  */ public void setTypeConverterExistsLoggingLevel(LoggingLevel typeConverterExistsLoggingLevel) {     this.typeConverterExistsLoggingLevel = typeConverterExistsLoggingLevel. }
false;public;0;3;;public CamelJMXAgentDefinition getCamelJMXAgent() {     return camelJMXAgent. }
false;public;0;3;;public List<RouteBuilderDefinition> getBuilderRefs() {     return builderRefs. }
true;public;1;3;/**  * Refers to Java {@link RouteBuilder} instances to include as routes in this CamelContext.  */ ;/**  * Refers to Java {@link RouteBuilder} instances to include as routes in this CamelContext.  */ public void setBuilderRefs(List<RouteBuilderDefinition> builderRefs) {     this.builderRefs = builderRefs. }
false;public;0;3;;public List<RouteContextRefDefinition> getRouteRefs() {     return routeRefs. }
true;public;1;3;/**  * Refers to XML routes to include as routes in this CamelContext.  */ ;/**  * Refers to XML routes to include as routes in this CamelContext.  */ public void setRouteRefs(List<RouteContextRefDefinition> routeRefs) {     this.routeRefs = routeRefs. }
false;public;0;3;;public List<RestContextRefDefinition> getRestRefs() {     return restRefs. }
true;public;1;3;/**  * Refers to XML rest-dsl to include as REST services in this CamelContext.  */ ;/**  * Refers to XML rest-dsl to include as REST services in this CamelContext.  */ public void setRestRefs(List<RestContextRefDefinition> restRefs) {     this.restRefs = restRefs. }
false;public;0;3;;public String getErrorHandlerRef() {     return errorHandlerRef. }
true;public;1;3;/**  * Sets the name of the error handler object used to default the error handling strategy  */ ;/**  * Sets the name of the error handler object used to default the error handling strategy  */ public void setErrorHandlerRef(String errorHandlerRef) {     this.errorHandlerRef = errorHandlerRef. }
true;public;1;3;/**  * Configuration of data formats.  */ ;/**  * Configuration of data formats.  */ public void setDataFormats(DataFormatsDefinition dataFormats) {     this.dataFormats = dataFormats. }
false;public;0;3;;public DataFormatsDefinition getDataFormats() {     return dataFormats. }
true;public;1;3;/**  * Configuration of transformers.  */ ;/**  * Configuration of transformers.  */ public void setTransformers(TransformersDefinition transformers) {     this.transformers = transformers. }
false;public;0;3;;public TransformersDefinition getTransformers() {     return transformers. }
true;public;1;3;/**  * Configuration of validators.  */ ;/**  * Configuration of validators.  */ public void setValidators(ValidatorsDefinition validators) {     this.validators = validators. }
false;public;0;3;;public ValidatorsDefinition getValidators() {     return validators. }
true;public;1;3;/**  * Configuration of redelivery settings.  */ ;/**  * Configuration of redelivery settings.  */ public void setRedeliveryPolicies(List<CamelRedeliveryPolicyFactoryBean> redeliveryPolicies) {     this.redeliveryPolicies = redeliveryPolicies. }
false;public;0;4;;@Override public List<AbstractCamelFactoryBean<?>> getBeansFactory() {     return beansFactory. }
true;public;1;3;/**  * Miscellaneous configurations  */ ;/**  * Miscellaneous configurations  */ public void setBeansFactory(List<AbstractCamelFactoryBean<?>> beansFactory) {     this.beansFactory = beansFactory. }
false;public;0;4;;@Override public List<?> getBeans() {     return beans. }
true;public;1;3;/**  * Miscellaneous configurations  */ ;/**  * Miscellaneous configurations  */ public void setBeans(List<?> beans) {     this.beans = beans. }
false;public;0;4;;@Override public ServiceCallConfigurationDefinition getDefaultServiceCallConfiguration() {     return defaultServiceCallConfiguration. }
true;public;1;3;/**  * ServiceCall EIP default configuration  */ ;/**  * ServiceCall EIP default configuration  */ public void setDefaultServiceCallConfiguration(ServiceCallConfigurationDefinition defaultServiceCallConfiguration) {     this.defaultServiceCallConfiguration = defaultServiceCallConfiguration. }
false;public;0;4;;@Override public List<ServiceCallConfigurationDefinition> getServiceCallConfigurations() {     return serviceCallConfigurations. }
true;public;1;3;/**  * ServiceCall EIP configurations  */ ;/**  * ServiceCall EIP configurations  */ public void setServiceCallConfigurations(List<ServiceCallConfigurationDefinition> serviceCallConfigurations) {     this.serviceCallConfigurations = serviceCallConfigurations. }
false;public;0;4;;@Override public List<HystrixConfigurationDefinition> getHystrixConfigurations() {     return hystrixConfigurations. }
false;public;0;4;;@Override public HystrixConfigurationDefinition getDefaultHystrixConfiguration() {     return defaultHystrixConfiguration. }
true;public;1;3;/**  * Hystrix EIP default configuration  */ ;/**  * Hystrix EIP default configuration  */ public void setDefaultHystrixConfiguration(HystrixConfigurationDefinition defaultHystrixConfiguration) {     this.defaultHystrixConfiguration = defaultHystrixConfiguration. }
true;public;1;3;/**  * Hystrix EIP configurations  */ ;/**  * Hystrix EIP configurations  */ public void setHystrixConfigurations(List<HystrixConfigurationDefinition> hystrixConfigurations) {     this.hystrixConfigurations = hystrixConfigurations. }
true;public;1;3;/**  * Configuration of error handlers that triggers on exceptions thrown.  */ ;/**  * Configuration of error handlers that triggers on exceptions thrown.  */ public void setOnExceptions(List<OnExceptionDefinition> onExceptions) {     this.onExceptions = onExceptions. }
false;public;0;3;;public List<OnExceptionDefinition> getOnExceptions() {     return onExceptions. }
false;public;0;3;;public List<OnCompletionDefinition> getOnCompletions() {     return onCompletions. }
true;public;1;3;/**  * Configuration of sub routes to run at the completion of routing.  */ ;/**  * Configuration of sub routes to run at the completion of routing.  */ public void setOnCompletions(List<OnCompletionDefinition> onCompletions) {     this.onCompletions = onCompletions. }
false;public;0;3;;public ShutdownRoute getShutdownRoute() {     return shutdownRoute. }
true;public;1;3;/**  * Sets the ShutdownRoute option for routes.  */ ;/**  * Sets the ShutdownRoute option for routes.  */ public void setShutdownRoute(ShutdownRoute shutdownRoute) {     this.shutdownRoute = shutdownRoute. }
false;public;0;3;;public ShutdownRunningTask getShutdownRunningTask() {     return shutdownRunningTask. }
true;public;1;3;/**  * Sets the ShutdownRunningTask option to use when shutting down a route.  */ ;/**  * Sets the ShutdownRunningTask option to use when shutting down a route.  */ public void setShutdownRunningTask(ShutdownRunningTask shutdownRunningTask) {     this.shutdownRunningTask = shutdownRunningTask. }
false;public;0;3;;public List<ThreadPoolProfileDefinition> getThreadPoolProfiles() {     return threadPoolProfiles. }
true;public;1;3;/**  * Configuration of thread pool profiles.  */ ;/**  * Configuration of thread pool profiles.  */ public void setThreadPoolProfiles(List<ThreadPoolProfileDefinition> threadPoolProfiles) {     this.threadPoolProfiles = threadPoolProfiles. }
false;public;0;3;;public List<CamelThreadPoolFactoryBean> getThreadPools() {     return threadPools. }
true;public;1;3;/**  * Configuration of thread pool  */ ;/**  * Configuration of thread pool  */ public void setThreadPools(List<CamelThreadPoolFactoryBean> threadPools) {     this.threadPools = threadPools. }
false;public;0;3;;public String getDependsOn() {     return dependsOn. }
true;public;1;3;/**  * List of other bean id's this CamelContext depends up. Multiple bean id's can be separated by comma.  */ ;/**  * List of other bean id's this CamelContext depends up. Multiple bean id's can be separated by comma.  */ public void setDependsOn(String dependsOn) {     this.dependsOn = dependsOn. }
false;public;0;3;;public boolean isImplicitId() {     return implicitId. }
false;public;1;3;;public void setImplicitId(boolean flag) {     implicitId = flag. }
