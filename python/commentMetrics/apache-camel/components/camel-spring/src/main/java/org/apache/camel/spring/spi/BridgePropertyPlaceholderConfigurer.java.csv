commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public int getSystemPropertiesMode() {     return systemPropertiesMode. }
false;protected;2;12;;@Override protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props) throws BeansException {     super.processProperties(beanFactoryToProcess, props).     // store all the spring properties so we can refer to them later     properties.putAll(props).     // create helper     helper = new PropertyPlaceholderHelper(configuredPlaceholderPrefix != null ? configuredPlaceholderPrefix : DEFAULT_PLACEHOLDER_PREFIX, configuredPlaceholderSuffix != null ? configuredPlaceholderSuffix : DEFAULT_PLACEHOLDER_SUFFIX, configuredValueSeparator != null ? configuredValueSeparator : DEFAULT_VALUE_SEPARATOR, configuredIgnoreUnresolvablePlaceholders != null ? configuredIgnoreUnresolvablePlaceholders : false). }
false;public;1;5;;@Override public void setBeanName(String beanName) {     this.id = beanName.     super.setBeanName(beanName). }
false;public;1;6;;@Override public void setSystemPropertiesModeName(String constantName) throws IllegalArgumentException {     super.setSystemPropertiesModeName(constantName).     Constants constants = new Constants(PropertyPlaceholderConfigurer.class).     this.systemPropertiesMode = constants.asNumber(constantName).intValue(). }
false;public;1;5;;@Override public void setSystemPropertiesMode(int systemPropertiesMode) {     super.setSystemPropertiesMode(systemPropertiesMode).     this.systemPropertiesMode = systemPropertiesMode. }
false;public;1;5;;@Override public void setPlaceholderPrefix(String placeholderPrefix) {     super.setPlaceholderPrefix(placeholderPrefix).     this.configuredPlaceholderPrefix = placeholderPrefix. }
false;public;1;5;;@Override public void setPlaceholderSuffix(String placeholderSuffix) {     super.setPlaceholderSuffix(placeholderSuffix).     this.configuredPlaceholderSuffix = placeholderSuffix. }
false;public;1;5;;@Override public void setValueSeparator(String valueSeparator) {     super.setValueSeparator(valueSeparator).     this.configuredValueSeparator = valueSeparator. }
false;public;1;5;;@Override public void setIgnoreUnresolvablePlaceholders(boolean ignoreUnresolvablePlaceholders) {     super.setIgnoreUnresolvablePlaceholders(ignoreUnresolvablePlaceholders).     this.configuredIgnoreUnresolvablePlaceholders = ignoreUnresolvablePlaceholders. }
false;public;1;5;;@Override public void setIgnoreResourceNotFound(boolean ignoreResourceNotFound) {     super.setIgnoreResourceNotFound(ignoreResourceNotFound).     this.ignoreResourceNotFound = ignoreResourceNotFound. }
false;protected;2;10;;@Override protected String resolvePlaceholder(String placeholder, Properties props) {     String value = props.getProperty(placeholder).     if (parser != null) {         // Just apply the parser to the place holder value to avoid configuring the other placeholder configure twice for the inside and outside camel context         return parser.parseProperty(placeholder, value, props).     } else {         return value.     } }
false;public;3;22;;@Override public Properties resolveProperties(CamelContext context, boolean ignoreMissingLocation, List<PropertiesLocation> locations) throws Exception {     // return the spring properties, if it     Properties answer = new Properties().     for (PropertiesLocation location : locations) {         if ("ref".equals(location.getResolver()) && id.equals(location.getPath())) {             answer.putAll(properties).         } else if (resolver != null) {             boolean flag = ignoreMissingLocation.             // Override the setting by using ignoreResourceNotFound             if (ignoreResourceNotFound != null) {                 flag = ignoreResourceNotFound.             }             Properties p = resolver.resolveProperties(context, flag, Collections.singletonList(location)).             if (p != null) {                 answer.putAll(p).             }         }     }     // must not return null     return answer. }
false;public;8;21;;@Override public String parseUri(String text, Properties properties, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty, boolean defaultFallbackEnabled) throws IllegalArgumentException {     // first let Camel parse the text as it may contain Camel placeholders     String answer.     if (parser instanceof AugmentedPropertyNameAwarePropertiesParser) {         answer = ((AugmentedPropertyNameAwarePropertiesParser) parser).parseUri(text, properties, prefixToken, suffixToken, propertyPrefix, propertySuffix, fallbackToUnaugmentedProperty, defaultFallbackEnabled).     } else {         answer = parser.parseUri(text, properties, prefixToken, suffixToken).     }     // then let Spring parse it to resolve any Spring placeholders     if (answer != null) {         answer = springResolvePlaceholders(answer, properties).     } else {         answer = springResolvePlaceholders(text, properties).     }     return answer. }
false;public;4;10;;@Override public String parseUri(String text, Properties properties, String prefixToken, String suffixToken) throws IllegalArgumentException {     String answer = parser.parseUri(text, properties, prefixToken, suffixToken).     if (answer != null) {         answer = springResolvePlaceholders(answer, properties).     } else {         answer = springResolvePlaceholders(text, properties).     }     return answer. }
false;public;3;10;;@Override public String parseProperty(String key, String value, Properties properties) {     String answer = parser.parseProperty(key, value, properties).     if (answer != null) {         answer = springResolvePlaceholders(answer, properties).     } else {         answer = springResolvePlaceholders(value, properties).     }     return answer. }
true;protected;2;3;/**  * Resolves the placeholders using Spring's property placeholder functionality.  *  * @param text   the text which may contain spring placeholders  * @param properties the properties  * @return the parsed text with replaced placeholders, or the original text as is  */ ;/**  * Resolves the placeholders using Spring's property placeholder functionality.  *  * @param text   the text which may contain spring placeholders  * @param properties the properties  * @return the parsed text with replaced placeholders, or the original text as is  */ protected String springResolvePlaceholders(String text, Properties properties) {     return helper.replacePlaceholders(text, new BridgePropertyPlaceholderResolver(properties)). }
false;public;1;3;;public void setResolver(PropertiesResolver resolver) {     this.resolver = resolver. }
false;public;1;8;;public void setParser(PropertiesParser parser) {     if (this.parser != null) {         // use a bridge if there is already a parser configured         this.parser = new BridgePropertiesParser(this.parser, parser).     } else {         this.parser = parser.     } }
false;public;1;13;;public String resolvePlaceholder(String placeholderName) {     String propVal = null.     if (systemPropertiesMode == SYSTEM_PROPERTIES_MODE_OVERRIDE) {         propVal = resolveSystemProperty(placeholderName).     }     if (propVal == null) {         propVal = (String) properties.get(placeholderName).     }     if (propVal == null && systemPropertiesMode == SYSTEM_PROPERTIES_MODE_FALLBACK) {         propVal = resolveSystemProperty(placeholderName).     }     return propVal. }
false;public;8;23;;@Override public String parseUri(String text, Properties properties, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty, boolean defaultFallbackEnabled) throws IllegalArgumentException {     String answer = null.     if (delegate != null) {         if (delegate instanceof AugmentedPropertyNameAwarePropertiesParser) {             answer = ((AugmentedPropertyNameAwarePropertiesParser) this.delegate).parseUri(text, properties, prefixToken, suffixToken, propertyPrefix, propertySuffix, fallbackToUnaugmentedProperty, defaultFallbackEnabled).         } else {             answer = delegate.parseUri(text, properties, prefixToken, suffixToken).         }     }     if (answer != null) {         text = answer.     }     if (parser instanceof AugmentedPropertyNameAwarePropertiesParser) {         answer = ((AugmentedPropertyNameAwarePropertiesParser) this.parser).parseUri(text, properties, prefixToken, suffixToken, propertyPrefix, propertySuffix, fallbackToUnaugmentedProperty, defaultFallbackEnabled).     } else {         answer = parser.parseUri(text, properties, prefixToken, suffixToken).     }     return answer. }
false;public;4;11;;@Override public String parseUri(String text, Properties properties, String prefixToken, String suffixToken) throws IllegalArgumentException {     String answer = null.     if (delegate != null) {         answer = delegate.parseUri(text, properties, prefixToken, suffixToken).     }     if (answer != null) {         text = answer.     }     return parser.parseUri(text, properties, prefixToken, suffixToken). }
false;public;3;11;;@Override public String parseProperty(String key, String value, Properties properties) {     String answer = null.     if (delegate != null) {         answer = delegate.parseProperty(key, value, properties).     }     if (answer != null) {         value = answer.     }     return parser.parseProperty(key, value, properties). }
