commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;7;;public static void setNoStart(boolean b) {     if (b) {         NO_START.set(true).     } else {         NO_START.set(null).     } }
true;public,static;2;17;/**  * @deprecated its better to create and boot Spring the standard Spring way and to get hold of CamelContext  * using the Spring API.  */ ;/**  * @deprecated its better to create and boot Spring the standard Spring way and to get hold of CamelContext  * using the Spring API.  */ @Deprecated public static SpringCamelContext springCamelContext(ApplicationContext applicationContext, boolean maybeStart) throws Exception {     if (applicationContext != null) {         // lets try and look up a configured camel context in the context         String[] names = applicationContext.getBeanNamesForType(SpringCamelContext.class).         if (names.length == 1) {             return applicationContext.getBean(names[0], SpringCamelContext.class).         }     }     SpringCamelContext answer = new SpringCamelContext().     answer.setApplicationContext(applicationContext).     answer.init().     if (maybeStart) {         answer.start().     }     return answer. }
false;public;0;21;;@Override public void start() {     // for example from unit testing we want to start Camel later (manually)     if (Boolean.TRUE.equals(NO_START.get())) {         LOG.trace("Ignoring start() as NO_START is false").         return.     }     if (!isStarted() && !isStarting()) {         try {             StopWatch watch = new StopWatch().             super.start().             LOG.debug("start() took {} millis", watch.taken()).         } catch (Exception e) {             throw wrapRuntimeCamelException(e).         }     } else {         // ignore as Camel is already started         LOG.trace("Ignoring start() as Camel is already started").     } }
false;public;0;8;;@Override public void stop() {     try {         super.stop().     } catch (Exception e) {         throw wrapRuntimeCamelException(e).     } }
false;public;1;23;;@Override public void onApplicationEvent(ApplicationEvent event) {     LOG.debug("onApplicationEvent: {}", event).     if (event instanceof ContextRefreshedEvent && ((ContextRefreshedEvent) event).getApplicationContext() == this.applicationContext) {         // nominally we would prefer to use Lifecycle interface that         // would invoke start() method, but in order to do that         // SpringCamelContext needs to implement SmartLifecycle         // (look at DefaultLifecycleProcessor::startBeans), but it         // cannot implement it as it already implements         // RuntimeConfiguration, and both SmartLifecycle and         // RuntimeConfiguration declare isAutoStartup method but         // with boolean and Boolean return types, and covariant         // methods with primitive types are not allowed by the JLS         // so we need to listen for ContextRefreshedEvent and start         // on its reception         start().     }     if (eventComponent != null) {         eventComponent.onApplicationEvent(event).     } }
false;public;0;10;;@Override public int getOrder() {     // and we need to be after CamelContextFactoryBean     return LOWEST_PRECEDENCE. }
false;public;0;3;;// Properties // ----------------------------------------------------------------------- public ApplicationContext getApplicationContext() {     return applicationContext. }
false;public;1;23;;@Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {     this.applicationContext = applicationContext.     ClassLoader cl.     // set the application context classloader     if (applicationContext != null && applicationContext.getClassLoader() != null) {         cl = applicationContext.getClassLoader().     } else {         LOG.warn("Cannot find the class loader from application context, using the thread context class loader instead").         cl = Thread.currentThread().getContextClassLoader().     }     LOG.debug("Set the application context classloader to: {}", cl).     this.setApplicationContextClassLoader(cl).     if (applicationContext instanceof ConfigurableApplicationContext) {         // only add if not already added         if (hasComponent("spring-event") == null) {             eventComponent = new EventComponent(applicationContext).             addComponent("spring-event", eventComponent).         }     } }
true;public;0;3;/**  * Whether to shutdown this {@link org.apache.camel.spring.SpringCamelContext} eager (first)  * when Spring {@link org.springframework.context.ApplicationContext} is being stopped.  * <p/>  * <b>Important:</b> This option is default <tt>true</tt> which ensures we shutdown Camel  * before other beans. Setting this to <tt>false</tt> restores old behavior in earlier  * Camel releases, which can be used for special cases to behave as before.  *  * @return <tt>true</tt> to shutdown eager (first), <tt>false</tt> to shutdown last  */ ;/**  * Whether to shutdown this {@link org.apache.camel.spring.SpringCamelContext} eager (first)  * when Spring {@link org.springframework.context.ApplicationContext} is being stopped.  * <p/>  * <b>Important:</b> This option is default <tt>true</tt> which ensures we shutdown Camel  * before other beans. Setting this to <tt>false</tt> restores old behavior in earlier  * Camel releases, which can be used for special cases to behave as before.  *  * @return <tt>true</tt> to shutdown eager (first), <tt>false</tt> to shutdown last  */ public boolean isShutdownEager() {     return shutdownEager. }
true;public;1;3;/**  * @see #isShutdownEager()  */ ;/**  * @see #isShutdownEager()  */ public void setShutdownEager(boolean shutdownEager) {     this.shutdownEager = shutdownEager. }
false;protected;0;10;;// Implementation methods // ----------------------------------------------------------------------- @Override protected Injector createInjector() {     if (applicationContext instanceof ConfigurableApplicationContext) {         return new SpringInjector((ConfigurableApplicationContext) applicationContext).     } else {         LOG.warn("Cannot use SpringInjector as applicationContext is not a ConfigurableApplicationContext as its: " + applicationContext).         return super.createInjector().     } }
false;protected;0;3;;protected EventEndpoint createEventEndpoint() {     return getEndpoint("spring-event:default", EventEndpoint.class). }
false;protected;2;11;;@Override protected Endpoint convertBeanToEndpoint(String uri, Object bean) {     // We will use the type convert to build the endpoint first     Endpoint endpoint = getTypeConverter().convertTo(Endpoint.class, bean).     if (endpoint != null) {         endpoint.setCamelContext(this).         return endpoint.     }     return new ProcessorEndpoint(uri, this, new BeanProcessor(bean, this)). }
false;protected;0;5;;@Override protected Registry createRegistry() {     BeanRepository repository = new ApplicationContextBeanRepository(getApplicationContext()).     return new DefaultRegistry(repository). }
false;protected;0;4;;@Override protected ModelJAXBContextFactory createModelJAXBContextFactory() {     return new SpringModelJAXBContextFactory(). }
false;public;0;9;;@Override public String toString() {     StringBuilder sb = new StringBuilder().     sb.append("SpringCamelContext(").append(getName()).append(")").     if (applicationContext != null) {         sb.append(" with spring id ").append(applicationContext.getId()).     }     return sb.toString(). }
false;public;0;14;;@Override public int getPhase() {     // only when stopping and then in reversed order     return LOWEST_PRECEDENCE. }
false;public;0;4;;@Override public boolean isRunning() {     return !isStopping() && !isStopped(). }
