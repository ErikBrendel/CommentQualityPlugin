commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public TransactionTemplate getTransactionTemplate() {     return transactionTemplate. }
false;public;0;3;;public boolean supportTransacted() {     return true. }
false;public;2;58;;public Processor createErrorHandler(RouteContext routeContext, Processor processor) throws Exception {     if (transactionTemplate == null) {         // lookup in context if no transaction template has been configured         LOG.debug("No TransactionTemplate configured on TransactionErrorHandlerBuilder. Will try find it in the registry.").         Map<String, TransactedPolicy> mapPolicy = routeContext.lookupByType(TransactedPolicy.class).         if (mapPolicy != null && mapPolicy.size() == 1) {             TransactedPolicy policy = mapPolicy.values().iterator().next().             if (policy instanceof SpringTransactionPolicy) {                 transactionTemplate = ((SpringTransactionPolicy) policy).getTransactionTemplate().             }         }         if (transactionTemplate == null) {             TransactedPolicy policy = routeContext.lookup(PROPAGATION_REQUIRED, TransactedPolicy.class).             if (policy instanceof SpringTransactionPolicy) {                 transactionTemplate = ((SpringTransactionPolicy) policy).getTransactionTemplate().             }         }         if (transactionTemplate == null) {             Map<String, TransactionTemplate> mapTemplate = routeContext.lookupByType(TransactionTemplate.class).             if (mapTemplate == null || mapTemplate.isEmpty()) {                 LOG.trace("No TransactionTemplate found in registry.").             } else if (mapTemplate.size() == 1) {                 transactionTemplate = mapTemplate.values().iterator().next().             } else {                 LOG.debug("Found {} TransactionTemplate in registry. Cannot determine which one to use. " + "Please configure a TransactionTemplate on the TransactionErrorHandlerBuilder", mapTemplate.size()).             }         }         if (transactionTemplate == null) {             Map<String, PlatformTransactionManager> mapManager = routeContext.lookupByType(PlatformTransactionManager.class).             if (mapManager == null || mapManager.isEmpty()) {                 LOG.trace("No PlatformTransactionManager found in registry.").             } else if (mapManager.size() == 1) {                 transactionTemplate = new TransactionTemplate(mapManager.values().iterator().next()).             } else {                 LOG.debug("Found {} PlatformTransactionManager in registry. Cannot determine which one to use for TransactionTemplate. " + "Please configure a TransactionTemplate on the TransactionErrorHandlerBuilder", mapManager.size()).             }         }         if (transactionTemplate != null) {             LOG.debug("Found TransactionTemplate in registry to use: {}", transactionTemplate).         }     }     ObjectHelper.notNull(transactionTemplate, "transactionTemplate", this).     TransactionErrorHandler answer = new TransactionErrorHandler(routeContext.getCamelContext(), processor, getLogger(), getOnRedelivery(), getRedeliveryPolicy(), getExceptionPolicyStrategy(), transactionTemplate, getRetryWhilePolicy(routeContext.getCamelContext()), getExecutorService(routeContext.getCamelContext()), getRollbackLoggingLevel(), getOnExceptionOccurred()).     // configure error handler before we can use it     configure(routeContext, answer).     return answer. }
false;public;1;3;;public void setTransactionTemplate(TransactionTemplate transactionTemplate) {     this.transactionTemplate = transactionTemplate. }
false;public;1;3;;public void setSpringTransactionPolicy(SpringTransactionPolicy policy) {     this.transactionTemplate = policy.getTransactionTemplate(). }
false;public;1;3;;public void setTransactionManager(PlatformTransactionManager transactionManager) {     this.transactionTemplate = new TransactionTemplate(transactionManager). }
false;public;0;3;;public LoggingLevel getRollbackLoggingLevel() {     return rollbackLoggingLevel. }
true;public;1;3;/**  * Sets the logging level to use for logging transactional rollback.  * <p/>  * This option is default WARN.  *  * @param rollbackLoggingLevel the logging level  */ ;/**  * Sets the logging level to use for logging transactional rollback.  * <p/>  * This option is default WARN.  *  * @param rollbackLoggingLevel the logging level  */ public void setRollbackLoggingLevel(LoggingLevel rollbackLoggingLevel) {     this.rollbackLoggingLevel = rollbackLoggingLevel. }
true;public;1;4;/**  * Sets the logging level to use for logging transactional rollback.  * <p/>  * This option is default WARN.  *  * @param rollbackLoggingLevel the logging level  */ ;// Builder methods // ------------------------------------------------------------------------- /**  * Sets the logging level to use for logging transactional rollback.  * <p/>  * This option is default WARN.  *  * @param rollbackLoggingLevel the logging level  */ public TransactionErrorHandlerBuilder rollbackLoggingLevel(LoggingLevel rollbackLoggingLevel) {     setRollbackLoggingLevel(rollbackLoggingLevel).     return this. }
false;protected;0;3;;// Implementation // ------------------------------------------------------------------------- protected CamelLogger createLogger() {     return new CamelLogger(LoggerFactory.getLogger(TransactionErrorHandler.class), LoggingLevel.ERROR). }
false;public;0;4;;@Override public String toString() {     return "TransactionErrorHandlerBuilder". }
