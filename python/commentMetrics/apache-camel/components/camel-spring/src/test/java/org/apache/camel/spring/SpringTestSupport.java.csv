commented;modifiers;parameterAmount;loc;comment;code
false;protected,abstract;0;1;;protected abstract AbstractXmlApplicationContext createApplicationContext().
false;public;0;11;;@Before @Override public void setUp() throws Exception {     // we want SpringTestSupport to startup faster and not use JMX by default and should stop seda quicker     System.setProperty("CamelSedaPollTimeout", "10").     System.setProperty("org.apache.camel.jmx.disabled", Boolean.toString(!useJmx())).     applicationContext = createApplicationContext().     assertNotNull("Should have created a valid spring context", applicationContext).     super.setUp(). }
false;public;0;6;;@After @Override public void tearDown() throws Exception {     super.tearDown().     IOHelper.close(applicationContext). }
false;public;1;6;;public void setExcludedClasses(Set<Class<?>> excludedClasses) {     if (excludedClasses == null) {         excludedClasses = Collections.emptySet().     }     addFilter(new InvertingPackageScanFilter(new AssignableToPackageScanFilter(excludedClasses))). }
true;protected;0;11;/**  * Create a parent context that initializes a  * {@link org.apache.camel.spi.PackageScanClassResolver} to exclude a set of given classes from  * being resolved. Typically this is used at test time to exclude certain routes,  * which might otherwise be just noisy, from being discovered and initialized.  * <p/>  * To use this filtering mechanism it is necessary to provide the  * {@link ApplicationContext} returned from here as the parent context to  * your test context e.g.  *  * <pre>  * protected AbstractXmlApplicationContext createApplicationContext() {  *     return new ClassPathXmlApplicationContext(new String[] {&quot.test-context.xml&quot.}, getRouteExcludingApplicationContext()).  * }  * </pre>  *  * This will, in turn, call the template methods <code>excludedRoutes</code>  * and <code>excludedRoute</code> to determine the classes to be excluded from scanning.  *  * @see org.apache.camel.spring.config.scan.SpringComponentScanTest for an example.  * @return ApplicationContext a parent {@link ApplicationContext} configured  *         to exclude certain classes from package scanning  */ ;/**  * Create a parent context that initializes a  * {@link org.apache.camel.spi.PackageScanClassResolver} to exclude a set of given classes from  * being resolved. Typically this is used at test time to exclude certain routes,  * which might otherwise be just noisy, from being discovered and initialized.  * <p/>  * To use this filtering mechanism it is necessary to provide the  * {@link ApplicationContext} returned from here as the parent context to  * your test context e.g.  *  * <pre>  * protected AbstractXmlApplicationContext createApplicationContext() {  *     return new ClassPathXmlApplicationContext(new String[] {&quot.test-context.xml&quot.}, getRouteExcludingApplicationContext()).  * }  * </pre>  *  * This will, in turn, call the template methods <code>excludedRoutes</code>  * and <code>excludedRoute</code> to determine the classes to be excluded from scanning.  *  * @see org.apache.camel.spring.config.scan.SpringComponentScanTest for an example.  * @return ApplicationContext a parent {@link ApplicationContext} configured  *         to exclude certain classes from package scanning  */ protected ApplicationContext getRouteExcludingApplicationContext() {     GenericApplicationContext routeExcludingContext = new GenericApplicationContext().     routeExcludingContext.registerBeanDefinition("excludingResolver", new RootBeanDefinition(ExcludingPackageScanClassResolver.class)).     routeExcludingContext.refresh().     ExcludingPackageScanClassResolver excludingResolver = routeExcludingContext.getBean("excludingResolver", ExcludingPackageScanClassResolver.class).     List<Class<?>> excluded = Arrays.asList(excludeRoutes()).     excludingResolver.setExcludedClasses(new HashSet<>(excluded)).     return routeExcludingContext. }
true;protected;0;4;/**  * Template method used to exclude {@link org.apache.camel.Route} from the test time context  * route scanning  *  * @return Class[] the classes to be excluded from test time context route scanning  */ ;/**  * Template method used to exclude {@link org.apache.camel.Route} from the test time context  * route scanning  *  * @return Class[] the classes to be excluded from test time context route scanning  */ protected Class<?>[] excludeRoutes() {     Class<?> excludedRoute = excludeRoute().     return excludedRoute != null ? new Class[] { excludedRoute } : new Class[0]. }
true;protected;0;3;/**  * Template method used to exclude a {@link org.apache.camel.Route} from the test camel context  */ ;/**  * Template method used to exclude a {@link org.apache.camel.Route} from the test camel context  */ protected Class<?> excludeRoute() {     return null. }
true;public;2;5;/**  * Looks up the mandatory spring bean of the given name and type, failing if  * it is not present or the correct type  */ ;/**  * Looks up the mandatory spring bean of the given name and type, failing if  * it is not present or the correct type  */ public <T> T getMandatoryBean(Class<T> type, String name) {     T value = applicationContext.getBean(name, type).     assertNotNull("No spring bean found for name <" + name + ">", value).     return value. }
false;protected;0;6;;@SuppressWarnings("deprecation") @Override protected CamelContext createCamelContext() throws Exception {     CamelContext context = SpringCamelContext.springCamelContext(applicationContext, true).     return context. }
