commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public void setUp() throws Exception {     filter = new PatternBasedPackageScanFilter(). }
false;protected;2;7;;protected void validateMatchingSetContains(Set<Class<?>> scannedClasses, Class<?>... matchingClasses) {     HashSet<Class<?>> expectedSet = new HashSet<>().     for (Class<?> expected : matchingClasses) {         expectedSet.add(expected).     }     validateMatchingSetContains(scannedClasses, expectedSet). }
false;protected;2;8;;protected void validateMatchingSetContains(Set<Class<?>> scannedClasses, Set<Class<?>> matchingClasses) {     Set<Class<?>> matching = getMatchingClasses(scannedClasses, filter).     assertEquals("Incorrect number of classes matched", matchingClasses.size(), matching.size()).     for (Class<?> expected : matchingClasses) {         assertTrue("Expected matching class '" + expected + "' is not present", matching.contains(expected)).     } }
false;protected;1;5;;protected void addIncludePatterns(String... patterns) {     for (String pattern : patterns) {         filter.addIncludePattern(pattern).     } }
false;protected;1;5;;protected void addExcludePatterns(String... patterns) {     for (String pattern : patterns) {         filter.addExcludePattern(pattern).     } }
false;public;2;11;;public Set<Class<?>> getMatchingClasses(Set<Class<?>> scannedClasses, PatternBasedPackageScanFilter filter) {     Set<Class<?>> matching = new HashSet<>().     for (Class<?> candidate : scannedClasses) {         if (filter.matches(candidate)) {             matching.add(candidate).         }     }     return matching. }
