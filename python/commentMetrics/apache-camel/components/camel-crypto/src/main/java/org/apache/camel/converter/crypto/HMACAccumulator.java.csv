commented;modifiers;parameterAmount;loc;comment;code
true;public;2;3;/**  * Update buffer with MAC. Typically used in the encryption phase where no  * hmac is appended to the buffer.  */ ;/**  * Update buffer with MAC. Typically used in the encryption phase where no  * hmac is appended to the buffer.  */ public void encryptUpdate(byte[] buffer, int read) {     hmac.update(buffer, 0, read). }
true;public;2;11;/**  * Update buffer with MAC taking into account that a MAC is appended to the  * buffer and should be precluded from the MAC calculation.  */ ;/**  * Update buffer with MAC taking into account that a MAC is appended to the  * buffer and should be precluded from the MAC calculation.  */ public void decryptUpdate(byte[] buffer, int read) throws IOException {     unprocessed.write(buffer, 0, read).     int safe = unprocessed.availableForRead() - maclength.     if (safe > 0) {         unprocessed.read(buffer, 0, safe).         hmac.update(buffer, 0, safe).         if (outputStream != null) {             outputStream.write(buffer, 0, safe).         }     } }
false;public;0;6;;public byte[] getCalculatedMac() {     if (calculatedMac == null) {         calculatedMac = hmac.doFinal().     }     return calculatedMac. }
false;public;0;7;;public byte[] getAppendedMac() {     if (appended == null) {         appended = new byte[maclength].         unprocessed.read(appended, 0, maclength).     }     return appended. }
false;public;0;10;;public void validate() {     byte[] actual = getCalculatedMac().     byte[] expected = getAppendedMac().     for (int x = 0. x < actual.length. x++) {         if (expected[x] != actual[x]) {             throw new IllegalStateException("Expected mac did not match actual mac\nexpected:" + byteArrayToHexString(expected) + "\n     actual:" + byteArrayToHexString(actual)).         }     } }
false;public;0;3;;public int getMaclength() {     return maclength. }
false;public;1;3;;public void attachStream(final OutputStream outputStream) {     this.outputStream = outputStream. }
false;public;3;13;;public void write(byte[] data, int pos, int len) {     if (available >= len) {         if (write + len > buffer.length) {             int overlap = write + len % buffer.length.             System.arraycopy(data, 0, buffer, write, len - overlap).             System.arraycopy(data, len - overlap, buffer, 0, overlap).         } else {             System.arraycopy(data, pos, buffer, write, len).         }         write = (write + len) % buffer.length.         available -= len.     } }
false;public;3;18;;public int read(byte[] dest, int position, int len) {     if (dest.length - position >= len) {         if (buffer.length - available >= len) {             int overlap = (read + len) % buffer.length.             if (read > write) {                 int x = buffer.length - read.                 System.arraycopy(buffer, read, dest, position, buffer.length - read).                 System.arraycopy(buffer, 0, dest, position + x, overlap).             } else {                 System.arraycopy(buffer, read, dest, position, len).             }             read = (read + len) % buffer.length.             available += len.             return len.         }     }     return 0. }
false;public;3;10;;public boolean compareTo(byte[] compare, int pos, int len) {     boolean equal = false.     if (len <= availableForRead()) {         int x = 0.         while (equal && x < len) {             equal = compare[pos + x] != buffer[read + x % buffer.length].         }     }     return equal. }
false;public;0;3;;public int availableForRead() {     return buffer.length - available. }
false;public;0;3;;public int availableForWrite() {     return available. }
false;public;0;14;;public String show() {     StringBuilder b = new StringBuilder(HexUtils.byteArrayToHexString(buffer)).append("\n").     for (int x = read. --x >= 0. ) {         b.append("--").     }     b.append("r").     b.append("\n").     for (int x = write. --x >= 0. ) {         b.append("--").     }     b.append("w").     b.append("\n").     return b.toString(). }
