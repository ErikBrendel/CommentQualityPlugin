commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;3;;protected String findKeyFileName(Exchange exchange) {     return exchange.getIn().getHeader(KEY_FILE_NAME, getKeyFileName(), String.class). }
false;protected;1;3;;protected byte[] findEncryptionKeyRing(Exchange exchange) {     return exchange.getIn().getHeader(ENCRYPTION_KEY_RING, getEncryptionKeyRing(), byte[].class). }
false;protected;1;9;;protected String findKeyPassword(Exchange exchange) {     return exchange.getIn().getHeader(KEY_PASSWORD, getPassword(), String.class). // the following lines are not needed because the passphrase accessor is taken into account later in the decryption case // if (passphraseAccessor != null) { // return passphraseAccessor.getPassphrase(findKeyUserid(exchange)). // } else { // return null. // } }
false;protected;1;3;;protected String findSignatureKeyFileName(Exchange exchange) {     return exchange.getIn().getHeader(SIGNATURE_KEY_FILE_NAME, getSignatureKeyFileName(), String.class). }
false;protected;1;3;;protected byte[] findSignatureKeyRing(Exchange exchange) {     return exchange.getIn().getHeader(SIGNATURE_KEY_RING, getSignatureKeyRing(), byte[].class). }
false;protected;1;11;;protected String findSignatureKeyPassword(Exchange exchange) {     String sigPassword = exchange.getIn().getHeader(SIGNATURE_KEY_PASSWORD, getSignaturePassword(), String.class).     if (sigPassword != null) {         return sigPassword.     }     if (passphraseAccessor != null) {         return passphraseAccessor.getPassphrase(findSignatureKeyUserid(exchange)).     } else {         return null.     } }
false;public;5;17;;public List<PGPSecretKeyAndPrivateKeyAndUserId> determineSecretKeysWithPrivateKeyAndUserId(Exchange exchange, String sigKeyFileName, List<String> sigKeyUserids, String sigKeyPassword, byte[] sigKeyRing) throws IOException, PGPException, NoSuchProviderException {     Map<String, String> sigKeyUserId2Password = determineSignatureKeyUserId2Password(sigKeyUserids, sigKeyPassword).     List<PGPSecretKeyAndPrivateKeyAndUserId> sigSecretKeysWithPrivateKeyAndUserId = PGPDataFormatUtil.findSecretKeysWithPrivateKeyAndUserId(exchange.getContext(), sigKeyFileName, sigKeyRing, sigKeyUserId2Password, getProvider()).     if (sigSecretKeysWithPrivateKeyAndUserId.isEmpty()) {         throw new IllegalArgumentException(String.format("Cannot PGP sign message. No secret key found for User IDs %s. Either add keys with this User IDs to the secret keyring or change the configured User IDs.", sigKeyUserids)).     }     return sigSecretKeysWithPrivateKeyAndUserId. }
false;public;2;17;;public Map<String, String> determineSignatureKeyUserId2Password(List<String> sigKeyUserids, String sigKeyPassword) {     // we want to keep the order of the entries, therefore we use LinkedHashMap     Map<String, String> sigKeyUserId2Password = new LinkedHashMap<>(sigKeyUserids.size()).     for (String sigKeyUserid : sigKeyUserids) {         if (sigKeyPassword == null) {             sigKeyPassword = passphraseAccessor.getPassphrase(sigKeyUserid).         }         if (sigKeyPassword == null) {             throw new IllegalArgumentException(String.format("No passphrase specified for signature key user ID %s. Either specify a passphrase or remove this user ID from the configuration.", sigKeyUserid)).         }         sigKeyUserId2Password.put(sigKeyUserid, sigKeyPassword).     }     return sigKeyUserId2Password. }
true;public;1;3;/**  * Filename of the keyring that will be used for the encryption/decryption,  * classpathResource. Alternatively you can provide the keyring also as byte  * array. see method {@link #setEncryptionKeyRing(byte[])}.  */ ;/**  * Filename of the keyring that will be used for the encryption/decryption,  * classpathResource. Alternatively you can provide the keyring also as byte  * array. see method {@link #setEncryptionKeyRing(byte[])}.  */ public void setKeyFileName(String keyFileName) {     this.keyFileName = keyFileName. }
false;public;0;3;;public String getKeyFileName() {     return keyFileName. }
true;public;1;3;/**  * Password used to open the private key in secret keyring for decryption  * (unmarshaling). See also  * {@link #setPassphraseAccessor(PGPPassphraseAccessor)}.  */ ;/**  * Password used to open the private key in secret keyring for decryption  * (unmarshaling). See also  * {@link #setPassphraseAccessor(PGPPassphraseAccessor)}.  */ public void setPassword(String password) {     this.password = password. }
false;public;0;3;;public String getPassword() {     return password. }
true;public;1;3;/**  * Filename of the signature keyring that will be used, classpathResource.  */ ;/**  * Filename of the signature keyring that will be used, classpathResource.  */ public void setSignatureKeyFileName(String signatureKeyFileName) {     this.signatureKeyFileName = signatureKeyFileName. }
false;public;0;3;;public String getSignatureKeyFileName() {     return signatureKeyFileName. }
true;public;1;3;/**  * Password used to open the signature private key during marshaling.  */ ;/**  * Password used to open the signature private key during marshaling.  */ public void setSignaturePassword(String signaturePassword) {     this.signaturePassword = signaturePassword. }
false;public;0;3;;public String getSignaturePassword() {     return signaturePassword. }
false;public;0;3;;public byte[] getEncryptionKeyRing() {     return encryptionKeyRing. }
true;public;1;3;/**  * Keyring used for encryption/decryption as byte array. Alternatively you  * can also provide the keyring as a file. see method  * {@link #setKeyFileName(String)}.  */ ;/**  * Keyring used for encryption/decryption as byte array. Alternatively you  * can also provide the keyring as a file. see method  * {@link #setKeyFileName(String)}.  */ public void setEncryptionKeyRing(byte[] encryptionKeyRing) {     this.encryptionKeyRing = encryptionKeyRing. }
false;public;0;3;;public byte[] getSignatureKeyRing() {     return signatureKeyRing. }
true;public;1;3;/**  * Keyring used for signing/verifying as byte array. Alternatively you can  * also provide the keyring as a file. see method  * {@link #setSignatureKeyFileName(String)}.  */ ;/**  * Keyring used for signing/verifying as byte array. Alternatively you can  * also provide the keyring as a file. see method  * {@link #setSignatureKeyFileName(String)}.  */ public void setSignatureKeyRing(byte[] signatureKeyRing) {     this.signatureKeyRing = signatureKeyRing. }
false;public;0;3;;public PGPPassphraseAccessor getPassphraseAccessor() {     return passphraseAccessor. }
true;public;1;3;/**  * Alternative way to provide the passphrases. Especially useful for the  * unmarshal (decryption) case . If no passphrase can be found from the  * parameter <tt>password</tt> or <tt>signaturePassword</tt> or from the  * header {@link #SIGNATURE_KEY_PASSWORD} or {@link #KEY_PASSWORD} then we  * try to get the password from the passphrase accessor. This is especially  * useful in the decrypt case, where we chose the private key according to  * the key Id stored in the encrypted data.  */ ;/**  * Alternative way to provide the passphrases. Especially useful for the  * unmarshal (decryption) case . If no passphrase can be found from the  * parameter <tt>password</tt> or <tt>signaturePassword</tt> or from the  * header {@link #SIGNATURE_KEY_PASSWORD} or {@link #KEY_PASSWORD} then we  * try to get the password from the passphrase accessor. This is especially  * useful in the decrypt case, where we chose the private key according to  * the key Id stored in the encrypted data.  */ public void setPassphraseAccessor(PGPPassphraseAccessor passphraseAccessor) {     this.passphraseAccessor = passphraseAccessor. }
false;public;2;5;;@Override public List<PGPPublicKey> getEncryptionKeys(Exchange exchange, List<String> useridParts) throws Exception {     return PGPDataFormatUtil.findPublicKeys(exchange.getContext(), findKeyFileName(exchange), findEncryptionKeyRing(exchange), useridParts, true). }
false;public;2;13;;@Override public List<PGPSecretKeyAndPrivateKeyAndUserId> getSignerKeys(Exchange exchange, List<String> useridParts) throws Exception {     String sigKeyFileName = findSignatureKeyFileName(exchange).     String sigKeyPassword = findSignatureKeyPassword(exchange).     byte[] sigKeyRing = findSignatureKeyRing(exchange).     if ((sigKeyFileName == null && sigKeyRing == null) || useridParts == null || useridParts.isEmpty() || (sigKeyPassword == null && passphraseAccessor == null)) {         return Collections.emptyList().     }     return determineSecretKeysWithPrivateKeyAndUserId(exchange, sigKeyFileName, useridParts, sigKeyPassword, sigKeyRing). }
false;public;2;5;;@Override public PGPPrivateKey getPrivateKey(Exchange exchange, long keyId) throws Exception {     return PGPDataFormatUtil.findPrivateKeyWithKeyId(exchange.getContext(), findKeyFileName(exchange), findEncryptionKeyRing(exchange), keyId, findKeyPassword(exchange), getPassphraseAccessor(), getProvider()). }
false;public;3;6;;@Override public PGPPublicKey getPublicKey(Exchange exchange, long keyId, List<String> userIdParts) throws Exception {     PGPPublicKeyRingCollection publicKeyringCollection = PGPDataFormatUtil.getPublicKeyRingCollection(exchange.getContext(), findSignatureKeyFileName(exchange), findSignatureKeyRing(exchange), false).     return PGPDataFormatUtil.getPublicKeyWithKeyIdAndUserID(keyId, userIdParts, publicKeyringCollection). }
false;public;1;4;;@Override public void setPublicKeyAccessor(PGPPublicKeyAccessor publicKeyAccessor) {     throw new UnsupportedOperationException("Use PGPKeyAccessDataFormat if you want to set the public key access"). }
false;public;1;4;;@Override public void setSecretKeyAccessor(PGPSecretKeyAccessor secretKeyAccessor) {     throw new UnsupportedOperationException("Use PGPKeyAccessDataFormat if you want to set the secret key access"). }
