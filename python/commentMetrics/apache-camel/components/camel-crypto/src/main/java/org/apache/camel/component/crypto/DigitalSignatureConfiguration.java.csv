commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;public DigitalSignatureConfiguration copy() {     try {         return (DigitalSignatureConfiguration) clone().     } catch (CloneNotSupportedException e) {         throw new RuntimeCamelException(e).     } }
false;public;0;3;;public CamelContext getCamelContext() {     return context. }
false;public;1;10;;public void setCamelContext(CamelContext camelContext) {     // TODO: this is wrong a configuration should not have CamelContext     this.context = camelContext.     // try to retrieve the references once the context is available.     setKeystoreName(keystoreName).     setPublicKeyName(publicKeyName).     setPrivateKeyName(privateKeyName).     setCertificateName(certificateName).     setSecureRandomName(secureRandomName). }
false;public;0;3;;public String getName() {     return name. }
true;public;1;3;/**  * The logical name of this operation.  */ ;/**  * The logical name of this operation.  */ public void setName(String name) {     this.name = name. }
true;public;0;3;/**  * Gets the JCE name of the Algorithm that should be used for the signer.  */ ;/**  * Gets the JCE name of the Algorithm that should be used for the signer.  */ public String getAlgorithm() {     return algorithm. }
true;public;1;3;/**  * Sets the JCE name of the Algorithm that should be used for the signer.  */ ;/**  * Sets the JCE name of the Algorithm that should be used for the signer.  */ public void setAlgorithm(String algorithm) {     this.algorithm = algorithm. }
true;public;0;3;/**  * Gets the alias used to query the KeyStore for keys and {@link java.security.cert.Certificate Certificates}  * to be used in signing and verifying exchanges. This value can be provided at runtime via the message header  * {@link org.apache.camel.component.crypto.DigitalSignatureConstants#KEYSTORE_ALIAS}  */ ;/**  * Gets the alias used to query the KeyStore for keys and {@link java.security.cert.Certificate Certificates}  * to be used in signing and verifying exchanges. This value can be provided at runtime via the message header  * {@link org.apache.camel.component.crypto.DigitalSignatureConstants#KEYSTORE_ALIAS}  */ public String getAlias() {     return alias. }
true;public;1;3;/**  * Sets the alias used to query the KeyStore for keys and {@link java.security.cert.Certificate Certificates}  * to be used in signing and verifying exchanges. This value can be provided at runtime via the message header  * {@link org.apache.camel.component.crypto.DigitalSignatureConstants#KEYSTORE_ALIAS}  */ ;/**  * Sets the alias used to query the KeyStore for keys and {@link java.security.cert.Certificate Certificates}  * to be used in signing and verifying exchanges. This value can be provided at runtime via the message header  * {@link org.apache.camel.component.crypto.DigitalSignatureConstants#KEYSTORE_ALIAS}  */ public void setAlias(String alias) {     this.alias = alias. }
true;public;0;3;/**  * Get the PrivateKey that should be used to sign the exchange  */ ;/**  * Get the PrivateKey that should be used to sign the exchange  */ public PrivateKey getPrivateKey() throws Exception {     return getPrivateKey(alias, password). }
true;public;1;3;/**  * Get the PrivateKey that should be used to sign the signature in the  * exchange using the supplied alias.  *  * @param alias the alias used to retrieve the Certificate from the keystore.  */ ;/**  * Get the PrivateKey that should be used to sign the signature in the  * exchange using the supplied alias.  *  * @param alias the alias used to retrieve the Certificate from the keystore.  */ public PrivateKey getPrivateKey(String alias) throws Exception {     return getPrivateKey(alias, password). }
true;public;2;10;/**  * Get the PrivateKey that should be used to sign the signature in the  * exchange using the supplied alias.  *  * @param alias the alias used to retrieve the Certificate from the keystore.  */ ;/**  * Get the PrivateKey that should be used to sign the signature in the  * exchange using the supplied alias.  *  * @param alias the alias used to retrieve the Certificate from the keystore.  */ public PrivateKey getPrivateKey(String alias, char[] password) throws Exception {     PrivateKey pk = null.     if (alias != null && keystore != null) {         pk = (PrivateKey) keystore.getKey(alias, password).     }     if (pk == null) {         pk = privateKey.     }     return pk. }
true;public;1;3;/**  * Set the PrivateKey that should be used to sign the exchange  *  * @param privateKey the key with with to sign the exchange.  */ ;/**  * Set the PrivateKey that should be used to sign the exchange  *  * @param privateKey the key with with to sign the exchange.  */ public void setPrivateKey(PrivateKey privateKey) {     this.privateKey = privateKey. }
true;public;1;11;/**  * Sets the reference name for a PrivateKey that can be found in the registry.  */ ;/**  * Sets the reference name for a PrivateKey that can be found in the registry.  */ public void setPrivateKeyName(String privateKeyName) {     if (context != null && privateKeyName != null) {         PrivateKey pk = context.getRegistry().lookupByNameAndType(privateKeyName, PrivateKey.class).         if (pk != null) {             setPrivateKey(pk).         }     }     if (privateKeyName != null) {         this.privateKeyName = privateKeyName.     } }
true;public;1;3;/**  * Set the PublicKey that should be used to verify the signature in the exchange.  */ ;/**  * Set the PublicKey that should be used to verify the signature in the exchange.  */ public void setPublicKey(PublicKey publicKey) {     this.publicKey = publicKey. }
true;public;1;11;/**  * Sets the reference name for a publicKey that can be found in the registry.  */ ;/**  * Sets the reference name for a publicKey that can be found in the registry.  */ public void setPublicKeyName(String publicKeyName) {     if (context != null && publicKeyName != null) {         PublicKey pk = context.getRegistry().lookupByNameAndType(publicKeyName, PublicKey.class).         if (pk != null) {             setPublicKey(pk).         }     }     if (publicKeyName != null) {         this.publicKeyName = publicKeyName.     } }
true;public;0;3;/**  * get the PublicKey that should be used to verify the signature in the exchange.  */ ;/**  * get the PublicKey that should be used to verify the signature in the exchange.  */ public PublicKey getPublicKey() {     return publicKey. }
true;public;1;10;/**  * Set the Certificate that should be used to verify the signature in the  * exchange. If a {@link KeyStore} has been configured then this will  * attempt to retrieve the {@link Certificate}from it using hte supplied  * alias. If either the alias or the Keystore is invalid then the configured  * certificate will be returned  *  * @param alias the alias used to retrieve the Certificate from the keystore.  */ ;/**  * Set the Certificate that should be used to verify the signature in the  * exchange. If a {@link KeyStore} has been configured then this will  * attempt to retrieve the {@link Certificate}from it using hte supplied  * alias. If either the alias or the Keystore is invalid then the configured  * certificate will be returned  *  * @param alias the alias used to retrieve the Certificate from the keystore.  */ public Certificate getCertificate(String alias) throws Exception {     Certificate cert = null.     if (alias != null && keystore != null) {         cert = keystore.getCertificate(alias).     }     if (cert == null) {         cert = certificate.     }     return cert. }
true;public;0;3;/**  * Get the explicitly configured {@link Certificate} that should be used to  * verify the signature in the exchange.  */ ;/**  * Get the explicitly configured {@link Certificate} that should be used to  * verify the signature in the exchange.  */ public Certificate getCertificate() throws Exception {     return certificate. }
true;public;1;3;/**  * Set the Certificate that should be used to verify the signature in the  * exchange based on its payload.  */ ;/**  * Set the Certificate that should be used to verify the signature in the  * exchange based on its payload.  */ public void setCertificate(Certificate certificate) {     this.certificate = certificate. }
true;public;1;11;/**  * Sets the reference name for a PrivateKey that can be found in the registry.  */ ;/**  * Sets the reference name for a PrivateKey that can be found in the registry.  */ public void setCertificateName(String certificateName) {     if (context != null && certificateName != null) {         Certificate certificate = context.getRegistry().lookupByNameAndType(certificateName, Certificate.class).         if (certificate != null) {             setCertificate(certificate).         }     }     if (certificateName != null) {         this.certificateName = certificateName.     } }
true;public;0;3;/**  * Gets the KeyStore that can contain keys and Certficates for use in  * signing and verifying exchanges. A {@link KeyStore} is typically used  * with an alias, either one supplied in the Route definition or dynamically  * via the message header "CamelSignatureKeyStoreAlias". If no alias is  * supplied and there is only a single entry in the Keystore, then this  * single entry will be used.  */ ;/**  * Gets the KeyStore that can contain keys and Certficates for use in  * signing and verifying exchanges. A {@link KeyStore} is typically used  * with an alias, either one supplied in the Route definition or dynamically  * via the message header "CamelSignatureKeyStoreAlias". If no alias is  * supplied and there is only a single entry in the Keystore, then this  * single entry will be used.  */ public KeyStore getKeystore() {     return keystore. }
true;public;1;3;/**  * Sets the KeyStore that can contain keys and Certficates for use in  * signing and verifying exchanges. A {@link KeyStore} is typically used  * with an alias, either one supplied in the Route definition or dynamically  * via the message header "CamelSignatureKeyStoreAlias". If no alias is  * supplied and there is only a single entry in the Keystore, then this  * single entry will be used.  */ ;/**  * Sets the KeyStore that can contain keys and Certficates for use in  * signing and verifying exchanges. A {@link KeyStore} is typically used  * with an alias, either one supplied in the Route definition or dynamically  * via the message header "CamelSignatureKeyStoreAlias". If no alias is  * supplied and there is only a single entry in the Keystore, then this  * single entry will be used.  */ public void setKeystore(KeyStore keystore) {     this.keystore = keystore. }
true;public;1;11;/**  * Sets the reference name for a Keystore that can be found in the registry.  */ ;/**  * Sets the reference name for a Keystore that can be found in the registry.  */ public void setKeystoreName(String keystoreName) {     if (context != null && keystoreName != null) {         KeyStore keystore = context.getRegistry().lookupByNameAndType(keystoreName, KeyStore.class).         if (keystore != null) {             setKeystore(keystore).         }     }     if (keystoreName != null) {         this.keystoreName = keystoreName.     } }
true;public;0;3;/**  * Gets the password used to access an aliased {@link PrivateKey} in the KeyStore.  */ ;/**  * Gets the password used to access an aliased {@link PrivateKey} in the KeyStore.  */ public char[] getPassword() {     return password. }
true;public;1;3;/**  * Sets the password used to access an aliased {@link PrivateKey} in the KeyStore.  */ ;/**  * Sets the password used to access an aliased {@link PrivateKey} in the KeyStore.  */ public void setPassword(char[] password) {     this.password = password. }
false;public;0;3;;public KeyStoreParameters getKeyStoreParameters() {     return keyStoreParameters. }
true;public;1;6;/**  * Sets the KeyStore that can contain keys and Certficates for use in  * signing and verifying exchanges based on the given KeyStoreParameters.  * A {@link KeyStore} is typically used  * with an alias, either one supplied in the Route definition or dynamically  * via the message header "CamelSignatureKeyStoreAlias". If no alias is  * supplied and there is only a single entry in the Keystore, then this  * single entry will be used.  */ ;/**  * Sets the KeyStore that can contain keys and Certficates for use in  * signing and verifying exchanges based on the given KeyStoreParameters.  * A {@link KeyStore} is typically used  * with an alias, either one supplied in the Route definition or dynamically  * via the message header "CamelSignatureKeyStoreAlias". If no alias is  * supplied and there is only a single entry in the Keystore, then this  * single entry will be used.  */ public void setKeyStoreParameters(KeyStoreParameters keyStoreParameters) throws Exception {     this.keyStoreParameters = keyStoreParameters.     if (keyStoreParameters != null) {         this.keystore = keyStoreParameters.createKeyStore().     } }
true;public;0;3;/**  * Get the SecureRandom used to initialize the Signature service  */ ;/**  * Get the SecureRandom used to initialize the Signature service  */ public SecureRandom getSecureRandom() {     return secureRandom. }
true;public;1;11;/**  * Sets the reference name for a SecureRandom that can be found in the registry.  */ ;/**  * Sets the reference name for a SecureRandom that can be found in the registry.  */ public void setSecureRandomName(String randomName) {     if (context != null && randomName != null) {         SecureRandom random = context.getRegistry().lookupByNameAndType(randomName, SecureRandom.class).         if (keystore != null) {             setSecureRandom(random).         }     }     if (randomName != null) {         this.secureRandomName = randomName.     } }
true;public;1;3;/**  * Set the SecureRandom used to initialize the Signature service  *  * @param secureRandom the random used to init the Signature service  */ ;/**  * Set the SecureRandom used to initialize the Signature service  *  * @param secureRandom the random used to init the Signature service  */ public void setSecureRandom(SecureRandom secureRandom) {     this.secureRandom = secureRandom. }
true;public;0;3;/**  * Get the size of the buffer used to read in the Exchange payload data.  */ ;/**  * Get the size of the buffer used to read in the Exchange payload data.  */ public Integer getBufferSize() {     return bufferSize. }
true;public;1;3;/**  * Set the size of the buffer used to read in the Exchange payload data.  */ ;/**  * Set the size of the buffer used to read in the Exchange payload data.  */ public void setBufferSize(Integer bufferSize) {     this.bufferSize = bufferSize. }
true;public;0;3;/**  * Get the id of the security provider that provides the configured  * {@link Signature} algorithm.  */ ;/**  * Get the id of the security provider that provides the configured  * {@link Signature} algorithm.  */ public String getProvider() {     return provider. }
true;public;1;3;/**  * Set the id of the security provider that provides the configured  * {@link Signature} algorithm.  *  * @param provider the id of the security provider  */ ;/**  * Set the id of the security provider that provides the configured  * {@link Signature} algorithm.  *  * @param provider the id of the security provider  */ public void setProvider(String provider) {     this.provider = provider. }
true;public;0;3;/**  * Get the name of the message header that should be used to store the  * base64 encoded signature. This defaults to 'CamelDigitalSignature'  */ ;/**  * Get the name of the message header that should be used to store the  * base64 encoded signature. This defaults to 'CamelDigitalSignature'  */ public String getSignatureHeaderName() {     return signatureHeaderName != null ? signatureHeaderName : DigitalSignatureConstants.SIGNATURE. }
true;public;1;3;/**  * Set the name of the message header that should be used to store the  * base64 encoded signature. This defaults to 'CamelDigitalSignature'  */ ;/**  * Set the name of the message header that should be used to store the  * base64 encoded signature. This defaults to 'CamelDigitalSignature'  */ public void setSignatureHeaderName(String signatureHeaderName) {     this.signatureHeaderName = signatureHeaderName. }
true;public;0;3;/**  * Determines if the Signature specific headers be cleared after signing and  * verification. Defaults to true, and should only be made otherwise at your  * extreme peril as vital private information such as Keys and passwords may  * escape if unset.  *  * @return true if the Signature headers should be unset, false otherwise  */ ;/**  * Determines if the Signature specific headers be cleared after signing and  * verification. Defaults to true, and should only be made otherwise at your  * extreme peril as vital private information such as Keys and passwords may  * escape if unset.  *  * @return true if the Signature headers should be unset, false otherwise  */ public boolean isClearHeaders() {     return clearHeaders. }
true;public;1;3;/**  * Determines if the Signature specific headers be cleared after signing and  * verification. Defaults to true, and should only be made otherwise at your  * extreme peril as vital private information such as Keys and passwords may  * escape if unset.  */ ;/**  * Determines if the Signature specific headers be cleared after signing and  * verification. Defaults to true, and should only be made otherwise at your  * extreme peril as vital private information such as Keys and passwords may  * escape if unset.  */ public void setClearHeaders(boolean clearHeaders) {     this.clearHeaders = clearHeaders. }
true;public;1;3;/**  * Set the Crypto operation from that supplied after the crypto scheme in the  * endpoint uri e.g. crypto:sign sets sign as the operation.  *  * @param operation the operation supplied after the crypto scheme  */ ;/**  * Set the Crypto operation from that supplied after the crypto scheme in the  * endpoint uri e.g. crypto:sign sets sign as the operation.  *  * @param operation the operation supplied after the crypto scheme  */ public void setCryptoOperation(String operation) {     this.cryptoOperation = CryptoOperation.valueOf(operation). }
false;public;1;3;;public void setCryptoOperation(CryptoOperation operation) {     this.cryptoOperation = operation. }
true;public;0;3;/**  * Gets the Crypto operation that was supplied in the crypto scheme in the endpoint uri  */ ;/**  * Gets the Crypto operation that was supplied in the crypto scheme in the endpoint uri  */ public CryptoOperation getCryptoOperation() {     return cryptoOperation. }
