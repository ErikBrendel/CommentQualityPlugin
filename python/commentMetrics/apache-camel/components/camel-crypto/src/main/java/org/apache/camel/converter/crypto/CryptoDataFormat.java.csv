commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getDataFormatName() {     return "crypto". }
false;private;3;19;;private Cipher initializeCipher(int mode, Key key, byte[] iv) throws Exception {     Cipher cipher = cryptoProvider == null ? Cipher.getInstance(algorithm) : Cipher.getInstance(algorithm, cryptoProvider).     if (key == null) {         throw new IllegalStateException("A valid encryption key is required. Either configure the CryptoDataFormat " + "with a key or provide one in a header using the header name 'CamelCryptoKey'").     }     if (mode == ENCRYPT_MODE || mode == DECRYPT_MODE) {         if (iv != null) {             cipher.init(mode, key, new IvParameterSpec(iv)).         } else if (parameterSpec != null) {             cipher.init(mode, key, parameterSpec).         } else {             cipher.init(mode, key).         }     }     return cipher. }
false;public;3;29;;public void marshal(Exchange exchange, Object graph, OutputStream outputStream) throws Exception {     byte[] iv = getInitializationVector(exchange).     Key key = getKey(exchange).     InputStream plaintextStream = ExchangeHelper.convertToMandatoryType(exchange, InputStream.class, graph).     HMACAccumulator hmac = getMessageAuthenticationCode(key).     if (plaintextStream != null) {         inlineInitVector(outputStream, iv).         byte[] buffer = new byte[bufferSize].         int read.         CipherOutputStream cipherStream = null.         try {             cipherStream = new CipherOutputStream(outputStream, initializeCipher(ENCRYPT_MODE, key, iv)).             while ((read = plaintextStream.read(buffer)) > 0) {                 cipherStream.write(buffer, 0, read).                 cipherStream.flush().                 hmac.encryptUpdate(buffer, read).             }             // only write if there is data to write (IBM JDK throws exception if no data)             byte[] mac = hmac.getCalculatedMac().             if (mac != null && mac.length > 0) {                 cipherStream.write(mac).             }         } finally {             IOHelper.close(cipherStream, "cipher", LOG).             IOHelper.close(plaintextStream, "plaintext", LOG).         }     } }
false;public;2;25;;public Object unmarshal(final Exchange exchange, final InputStream encryptedStream) throws Exception {     if (encryptedStream != null) {         byte[] iv = getInlinedInitializationVector(exchange, encryptedStream).         Key key = getKey(exchange).         CipherInputStream cipherStream = null.         OutputStreamBuilder osb = null.         try {             cipherStream = new CipherInputStream(encryptedStream, initializeCipher(DECRYPT_MODE, key, iv)).             osb = OutputStreamBuilder.withExchange(exchange).             HMACAccumulator hmac = getMessageAuthenticationCode(key).             byte[] buffer = new byte[bufferSize].             hmac.attachStream(osb).             int read.             while ((read = cipherStream.read(buffer)) >= 0) {                 hmac.decryptUpdate(buffer, read).             }             hmac.validate().             return osb.build().         } finally {             IOHelper.close(cipherStream, "cipher", LOG).             IOHelper.close(osb, "plaintext", LOG).         }     }     return null. }
false;protected;0;4;;@Override protected void doStart() throws Exception { // noop }
false;protected;0;4;;@Override protected void doStop() throws Exception { // noop }
false;private;2;12;;private void inlineInitVector(OutputStream outputStream, byte[] iv) throws IOException {     if (inline) {         if (iv == null) {             throw new IllegalStateException("Inlining cannot be performed, as no initialization vector was specified").         }         DataOutputStream dout = new DataOutputStream(outputStream).         dout.writeInt(iv.length).         outputStream.write(iv).         outputStream.flush().     } }
false;private;2;17;;private byte[] getInlinedInitializationVector(Exchange exchange, InputStream encryptedStream) throws IOException {     byte[] iv = getInitializationVector(exchange).     if (inline) {         try {             int ivLength = new DataInputStream(encryptedStream).readInt().             iv = new byte[ivLength].             int read = encryptedStream.read(iv).             if (read != ivLength) {                 throw new IOException(String.format("Attempted to read a '%d' byte initialization vector from inputStream but only" + " '%d' bytes were retrieved", ivLength, read)).             }         } catch (IOException e) {             throw new IOException("Error reading initialization vector from encrypted stream", e).         }     }     return iv. }
false;public;2;2;;public void encryptUpdate(byte[] buffer, int read) { }
false;public;2;3;;public void decryptUpdate(byte[] buffer, int read) throws IOException {     outputStream.write(buffer, 0, read). }
false;public;0;2;;public void validate() { }
false;public;0;3;;public byte[] getCalculatedMac() {     return empty. }
false;private;1;20;;private HMACAccumulator getMessageAuthenticationCode(Key key) throws Exception {     // return an actual Hmac Calculator or a 'Null' noop version.     return shouldAppendHMAC ? new HMACAccumulator(key, macAlgorithm, cryptoProvider, bufferSize) : new HMACAccumulator() {          byte[] empty = new byte[0].          public void encryptUpdate(byte[] buffer, int read) {         }          public void decryptUpdate(byte[] buffer, int read) throws IOException {             outputStream.write(buffer, 0, read).         }          public void validate() {         }          public byte[] getCalculatedMac() {             return empty.         }     }. }
false;private;1;7;;private byte[] getInitializationVector(Exchange exchange) {     byte[] iv = exchange.getIn().getHeader(INIT_VECTOR, byte[].class).     if (iv == null) {         iv = initializationVector.     }     return iv. }
false;private;1;9;;private Key getKey(Exchange exchange) {     Key key = exchange.getIn().getHeader(KEY, Key.class).     if (key != null) {         exchange.getIn().setHeader(KEY, null).     } else {         key = configuredkey.     }     return key. }
false;public;1;5;;public void setInitializationVector(byte[] initializationVector) {     if (initializationVector != null) {         this.initializationVector = initializationVector.     } }
true;public;1;3;/**  * Meant for use with a Symmetric block Cipher and specifies that the  * initialization vector should be written to the cipher stream ahead of the  * encrypted ciphertext. When the payload is to be decrypted this  * initialization vector will need to be read from the stream. Requires that  * the formatter has been configured with an init vector that is valid for  * the given algorithm.  *  * @param inline true if the initialization vector should be inlined in the stream.  */ ;/**  * Meant for use with a Symmetric block Cipher and specifies that the  * initialization vector should be written to the cipher stream ahead of the  * encrypted ciphertext. When the payload is to be decrypted this  * initialization vector will need to be read from the stream. Requires that  * the formatter has been configured with an init vector that is valid for  * the given algorithm.  *  * @param inline true if the initialization vector should be inlined in the stream.  */ public void setShouldInlineInitializationVector(boolean inline) {     this.inline = inline. }
true;public;1;3;/**  * Sets the JCE name of the Encryption Algorithm that should be used  */ ;/**  * Sets the JCE name of the Encryption Algorithm that should be used  */ public void setAlgorithm(String algorithm) {     this.algorithm = algorithm. }
true;public;1;3;/**  * Sets a custom {@link AlgorithmParameterSpec} that should be used to  * configure the Cipher. Note that if an Initalization vector is provided  * then the IvParameterSpec will be used and any value set here will be  * ignored  */ ;/**  * Sets a custom {@link AlgorithmParameterSpec} that should be used to  * configure the Cipher. Note that if an Initalization vector is provided  * then the IvParameterSpec will be used and any value set here will be  * ignored  */ public void setAlgorithmParameterSpec(AlgorithmParameterSpec parameterSpec) {     this.parameterSpec = parameterSpec. }
true;public;1;3;/**  * Sets the name of the JCE provider e.g. SUN or BC for Bouncy  */ ;/**  * Sets the name of the JCE provider e.g. SUN or BC for Bouncy  */ public void setCryptoProvider(String cryptoProvider) {     this.cryptoProvider = cryptoProvider. }
true;public;1;3;/**  * Sets the algorithm used to create the Hash-based Message Authentication  * Code (HMAC) appended to the stream.  */ ;/**  * Sets the algorithm used to create the Hash-based Message Authentication  * Code (HMAC) appended to the stream.  */ public void setMacAlgorithm(String macAlgorithm) {     this.macAlgorithm = macAlgorithm. }
true;public;1;3;/**  * Whether a Hash-based Message Authentication Code (HMAC) should be  * calculated and appended to the stream.  */ ;/**  * Whether a Hash-based Message Authentication Code (HMAC) should be  * calculated and appended to the stream.  */ public void setShouldAppendHMAC(boolean shouldAppendHMAC) {     this.shouldAppendHMAC = shouldAppendHMAC. }
true;public;1;3;/**  * Set the key that should be used to encrypt or decrypt incoming encrypted exchanges.  */ ;/**  * Set the key that should be used to encrypt or decrypt incoming encrypted exchanges.  */ public void setKey(Key key) {     this.configuredkey = key. }
true;public;1;3;/**  * Set the size of the buffer used to  */ ;/**  * Set the size of the buffer used to  */ public void setBufferSize(int bufferSize) {     this.bufferSize = bufferSize. }
