commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;@Before public void setUpEncryptorAndDecryptor() {     // the following keyring contains a primary key with KeyFlag "Certify" and a subkey for signing and a subkey for encryption     encryptor.setKeyFileName(PUB_KEY_RING_SUBKEYS_FILE_NAME).     encryptor.setSignatureKeyFileName("org/apache/camel/component/crypto/secringSubKeys.gpg").     encryptor.setSignaturePassword("Abcd1234").     encryptor.setKeyUserid("keyflag").     encryptor.setSignatureKeyUserid("keyflag").     encryptor.setIntegrity(false).     encryptor.setFileName("fileNameABC").     // the following keyring contains a primary key with KeyFlag "Certify" and a subkey for signing and a subkey for encryption     decryptor.setKeyFileName("org/apache/camel/component/crypto/secringSubKeys.gpg").     decryptor.setSignatureKeyFileName(PUB_KEY_RING_SUBKEYS_FILE_NAME).     decryptor.setPassword("Abcd1234").     decryptor.setSignatureKeyUserid("keyflag"). }
false;protected;0;3;;protected String getKeyFileName() {     return PUB_KEY_RING_FILE_NAME. }
false;protected;0;3;;protected String getKeyFileNameSec() {     return SEC_KEY_RING_FILE_NAME. }
false;protected;0;3;;protected String getKeyUserId() {     return "sdude@nowhere.net". }
false;protected;0;6;;protected List<String> getKeyUserIds() {     List<String> userids = new ArrayList<>(2).     userids.add("second").     userids.add(getKeyUserId()).     return userids. }
false;protected;0;6;;protected List<String> getSignatureKeyUserIds() {     List<String> userids = new ArrayList<>(2).     userids.add("second").     userids.add(getKeyUserId()).     return userids. }
false;protected;0;3;;protected String getKeyPassword() {     return "sdude". }
false;protected;0;3;;protected String getProvider() {     return "BC". }
false;protected;0;3;;protected int getAlgorithm() {     return SymmetricKeyAlgorithmTags.TRIPLE_DES. }
false;protected;0;3;;protected int getHashAlgorithm() {     return HashAlgorithmTags.SHA256. }
false;protected;0;3;;protected int getCompressionAlgorithm() {     return CompressionAlgorithmTags.BZIP2. }
false;public;0;4;;@Test public void testEncryption() throws Exception {     doRoundTripEncryptionTests("direct:inline"). }
false;public;0;4;;@Test public void testEncryption2() throws Exception {     doRoundTripEncryptionTests("direct:inline2"). }
false;public;0;4;;@Test public void testEncryptionArmor() throws Exception {     doRoundTripEncryptionTests("direct:inline-armor"). }
false;public;0;4;;@Test public void testEncryptionSigned() throws Exception {     doRoundTripEncryptionTests("direct:inline-sign"). }
false;public;0;4;;@Test public void testEncryptionKeyRingByteArray() throws Exception {     doRoundTripEncryptionTests("direct:key-ring-byte-array"). }
false;public;0;4;;@Test public void testEncryptionSignedKeyRingByteArray() throws Exception {     doRoundTripEncryptionTests("direct:sign-key-ring-byte-array"). }
false;public;0;4;;@Test public void testSeveralSignerKeys() throws Exception {     doRoundTripEncryptionTests("direct:several-signer-keys"). }
false;public;0;4;;@Test public void testOneUserIdWithServeralKeys() throws Exception {     doRoundTripEncryptionTests("direct:one-userid-several-keys"). }
false;public;0;4;;@Test public void testKeyAccess() throws Exception {     doRoundTripEncryptionTests("direct:key_access"). }
false;public;0;13;;@Test public void testVerifyExceptionNoPublicKeyFoundCorrespondingToSignatureUserIds() throws Exception {     setupExpectations(context, 1, "mock:encrypted").     MockEndpoint exception = setupExpectations(context, 1, "mock:exception").     String payload = "Hi Alice, Be careful Eve is listening, signed Bob".     Map<String, Object> headers = getHeaders().     template.sendBodyAndHeaders("direct:verify_exception_sig_userids", payload, headers).     assertMockEndpointsSatisfied().     checkThrownException(exception, IllegalArgumentException.class, null, "No public key found for the key ID(s)"). }
false;public;0;15;;@Test public void testVerifyExceptionNoPassphraseSpecifiedForSignatureKeyUserId() throws Exception {     MockEndpoint exception = setupExpectations(context, 1, "mock:exception").     String payload = "Hi Alice, Be careful Eve is listening, signed Bob".     Map<String, Object> headers = new HashMap<>().     // add signature user id which does not have a passphrase     headers.put(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERID, "userIDWithNoPassphrase").     // the following entry is necessary for the dynamic test     headers.put(PGPKeyAccessDataFormat.KEY_USERID, "second").     template.sendBodyAndHeaders("direct:several-signer-keys", payload, headers).     assertMockEndpointsSatisfied().     checkThrownException(exception, IllegalArgumentException.class, null, "No passphrase specified for signature key user ID"). }
true;public;0;16;/**  * You get three keys with the UserId "keyflag", a primary key and its two  * sub-keys. The sub-key with KeyFlag {@link KeyFlags#SIGN_DATA} should be  * used for signing and the sub-key with KeyFlag  * {@link KeyFlags#ENCRYPT_COMMS} or {@link KeyFlags#ENCRYPT_COMMS} or  * {@link KeyFlags#ENCRYPT_STORAGE} should be used for decryption.  *  * @throws Exception  */ ;/**  * You get three keys with the UserId "keyflag", a primary key and its two  * sub-keys. The sub-key with KeyFlag {@link KeyFlags#SIGN_DATA} should be  * used for signing and the sub-key with KeyFlag  * {@link KeyFlags#ENCRYPT_COMMS} or {@link KeyFlags#ENCRYPT_COMMS} or  * {@link KeyFlags#ENCRYPT_STORAGE} should be used for decryption.  *  * @throws Exception  */ @Test public void testKeyFlagSelectsCorrectKey() throws Exception {     MockEndpoint mockKeyFlag = getMockEndpoint("mock:encrypted_keyflag").     mockKeyFlag.setExpectedMessageCount(1).     template.sendBody("direct:keyflag", "Test Message").     assertMockEndpointsSatisfied().     List<Exchange> exchanges = mockKeyFlag.getExchanges().     assertEquals(1, exchanges.size()).     Exchange exchange = exchanges.get(0).     Message inMess = exchange.getIn().     assertNotNull(inMess).     // must contain exactly one encryption key and one signature     assertEquals(1, inMess.getHeader(PGPKeyAccessDataFormat.NUMBER_OF_ENCRYPTION_KEYS)).     assertEquals(1, inMess.getHeader(PGPKeyAccessDataFormat.NUMBER_OF_SIGNING_KEYS)). }
true;public;0;9;/**  * You get three keys with the UserId "keyflag", a primary key and its two  * sub-keys. The sub-key with KeyFlag {@link KeyFlags#SIGN_DATA} should be  * used for signing and the sub-key with KeyFlag  * {@link KeyFlags#ENCRYPT_COMMS} or {@link KeyFlags#ENCRYPT_COMMS} or  * {@link KeyFlags#ENCRYPT_STORAGE} should be used for decryption.  * <p>  * Tests also the decryption and verifying part with the subkeys.  *  * @throws Exception  */ ;/**  * You get three keys with the UserId "keyflag", a primary key and its two  * sub-keys. The sub-key with KeyFlag {@link KeyFlags#SIGN_DATA} should be  * used for signing and the sub-key with KeyFlag  * {@link KeyFlags#ENCRYPT_COMMS} or {@link KeyFlags#ENCRYPT_COMMS} or  * {@link KeyFlags#ENCRYPT_STORAGE} should be used for decryption.  * <p>  * Tests also the decryption and verifying part with the subkeys.  *  * @throws Exception  */ @Test public void testDecryptVerifyWithSubkey() throws Exception {     // do not use doRoundTripEncryptionTests("direct:subkey"). because otherwise you get an error in the dynamic test     String payload = "Test Message".     MockEndpoint mockSubkey = getMockEndpoint("mock:unencrypted").     mockSubkey.expectedBodiesReceived(payload).     template.sendBody("direct:subkey", payload).     assertMockEndpointsSatisfied(). }
false;public;0;8;;@Test public void testEmptyBody() throws Exception {     String payload = "".     MockEndpoint mockSubkey = getMockEndpoint("mock:unencrypted").     mockSubkey.expectedBodiesReceived(payload).     template.sendBody("direct:subkey", payload).     assertMockEndpointsSatisfied(). }
false;public;0;10;;@Test public void testExceptionDecryptorIncorrectInputFormatNoPGPMessage() throws Exception {     String payload = "Not Correct Format".     MockEndpoint mock = getMockEndpoint("mock:exception").     mock.expectedMessageCount(1).     template.sendBody("direct:subkeyUnmarshal", payload).     assertMockEndpointsSatisfied().     checkThrownException(mock, IllegalArgumentException.class, null, "The input message body has an invalid format."). }
false;public;0;12;;@Test public void testExceptionDecryptorIncorrectInputFormatPGPSignedData() throws Exception {     ByteArrayOutputStream bos = new ByteArrayOutputStream().     createSignature(bos).     MockEndpoint mock = getMockEndpoint("mock:exception").     mock.expectedMessageCount(1).     template.sendBody("direct:subkeyUnmarshal", bos.toByteArray()).     assertMockEndpointsSatisfied().     checkThrownException(mock, IllegalArgumentException.class, null, "The input message body has an invalid format."). }
false;public;0;15;;@Test public void testEncryptSignWithoutCompressedDataPacket() throws Exception {     doRoundTripEncryptionTests("direct:encrypt-sign-without-compressed-data-packet"). // ByteArrayOutputStream bos = new ByteArrayOutputStream(). //  // //        createEncryptedNonCompressedData(bos, PUB_KEY_RING_SUBKEYS_FILE_NAME). //  // MockEndpoint mock = getMockEndpoint("mock:exception"). // mock.expectedMessageCount(1). // template.sendBody("direct:encrypt-sign-without-compressed-data-packet", bos.toByteArray()). // assertMockEndpointsSatisfied(). //  // //checkThrownException(mock, IllegalArgumentException.class, null, "The input message body has an invalid format."). }
false;public;0;14;;@Test public void testExceptionDecryptorNoKeyFound() throws Exception {     ByteArrayOutputStream bos = new ByteArrayOutputStream().     createEncryptedNonCompressedData(bos, PUB_KEY_RING_FILE_NAME).     MockEndpoint mock = getMockEndpoint("mock:exception").     mock.expectedMessageCount(1).     template.sendBody("direct:subkeyUnmarshal", bos.toByteArray()).     assertMockEndpointsSatisfied().     checkThrownException(mock, PGPException.class, null, "PGP message is encrypted with a key which could not be found in the Secret Keyring"). }
false;;2;17;;void createEncryptedNonCompressedData(ByteArrayOutputStream bos, String keyringPath) throws Exception, IOException, PGPException, UnsupportedEncodingException {     PGPEncryptedDataGenerator encGen = new PGPEncryptedDataGenerator(new JcePGPDataEncryptorBuilder(SymmetricKeyAlgorithmTags.CAST5).setSecureRandom(new SecureRandom()).setProvider(getProvider())).     encGen.addMethod(new JcePublicKeyKeyEncryptionMethodGenerator(readPublicKey(keyringPath))).     OutputStream encOut = encGen.open(bos, new byte[512]).     PGPLiteralDataGenerator litData = new PGPLiteralDataGenerator().     OutputStream litOut = litData.open(encOut, PGPLiteralData.BINARY, PGPLiteralData.CONSOLE, new Date(), new byte[512]).     try {         litOut.write("Test Message Without Compression".getBytes("UTF-8")).         litOut.flush().     } finally {         IOHelper.close(litOut).         IOHelper.close(encOut, bos).     } }
false;private;1;23;;private void createSignature(OutputStream out) throws Exception {     PGPSecretKey pgpSec = readSecretKey().     PGPPrivateKey pgpPrivKey = pgpSec.extractPrivateKey(new JcePBESecretKeyDecryptorBuilder().setProvider(getProvider()).build("sdude".toCharArray())).     PGPSignatureGenerator sGen = new PGPSignatureGenerator(new JcaPGPContentSignerBuilder(pgpSec.getPublicKey().getAlgorithm(), HashAlgorithmTags.SHA1).setProvider(getProvider())).     sGen.init(PGPSignature.BINARY_DOCUMENT, pgpPrivKey).     BCPGOutputStream bOut = new BCPGOutputStream(out).     InputStream fIn = new ByteArrayInputStream("Test Signature".getBytes("UTF-8")).     int ch.     while ((ch = fIn.read()) >= 0) {         sGen.update((byte) ch).     }     fIn.close().     sGen.generate().encode(bOut). }
false;static;0;23;;static PGPSecretKey readSecretKey() throws Exception {     InputStream input = new ByteArrayInputStream(getSecKeyRing()).     PGPSecretKeyRingCollection pgpSec = new PGPSecretKeyRingCollection(PGPUtil.getDecoderStream(input), new BcKeyFingerprintCalculator()).     @SuppressWarnings("rawtypes")     Iterator keyRingIter = pgpSec.getKeyRings().     while (keyRingIter.hasNext()) {         PGPSecretKeyRing keyRing = (PGPSecretKeyRing) keyRingIter.next().         @SuppressWarnings("rawtypes")         Iterator keyIter = keyRing.getSecretKeys().         while (keyIter.hasNext()) {             PGPSecretKey key = (PGPSecretKey) keyIter.next().             if (key.isSigningKey()) {                 return key.             }         }     }     throw new IllegalArgumentException("Can't find signing key in key ring."). }
false;static;1;23;;static PGPPublicKey readPublicKey(String keyringPath) throws Exception {     InputStream input = new ByteArrayInputStream(getKeyRing(keyringPath)).     PGPPublicKeyRingCollection pgpPub = new PGPPublicKeyRingCollection(PGPUtil.getDecoderStream(input), new BcKeyFingerprintCalculator()).     @SuppressWarnings("rawtypes")     Iterator keyRingIter = pgpPub.getKeyRings().     while (keyRingIter.hasNext()) {         PGPPublicKeyRing keyRing = (PGPPublicKeyRing) keyRingIter.next().         @SuppressWarnings("rawtypes")         Iterator keyIter = keyRing.getPublicKeys().         while (keyIter.hasNext()) {             PGPPublicKey key = (PGPPublicKey) keyIter.next().             if (key.isEncryptionKey()) {                 return key.             }         }     }     throw new IllegalArgumentException("Can't find encryption key in key ring."). }
false;public;0;28;;@Test public void testExceptionDecryptorIncorrectInputFormatSymmetricEncryptedData() throws Exception {     byte[] payload = "Not Correct Format".getBytes("UTF-8").     ByteArrayOutputStream bos = new ByteArrayOutputStream().     PGPEncryptedDataGenerator encGen = new PGPEncryptedDataGenerator(new JcePGPDataEncryptorBuilder(SymmetricKeyAlgorithmTags.CAST5).setSecureRandom(new SecureRandom()).setProvider(getProvider())).     encGen.addMethod(new JcePBEKeyEncryptionMethodGenerator("pw".toCharArray())).     OutputStream encOut = encGen.open(bos, new byte[1024]).     PGPCompressedDataGenerator comData = new PGPCompressedDataGenerator(CompressionAlgorithmTags.ZIP).     OutputStream comOut = new BufferedOutputStream(comData.open(encOut)).     PGPLiteralDataGenerator litData = new PGPLiteralDataGenerator().     OutputStream litOut = litData.open(comOut, PGPLiteralData.BINARY, PGPLiteralData.CONSOLE, new Date(), new byte[1024]).     litOut.write(payload).     litOut.flush().     litOut.close().     comOut.close().     encOut.close().     MockEndpoint mock = getMockEndpoint("mock:exception").     mock.expectedMessageCount(1).     template.sendBody("direct:subkeyUnmarshal", bos.toByteArray()).     assertMockEndpointsSatisfied().     checkThrownException(mock, IllegalArgumentException.class, null, "The input message body has an invalid format."). }
false;public;0;12;;@Test public void testExceptionForSignatureVerificationOptionNoSignatureAllowed() throws Exception {     decryptor.setSignatureVerificationOption(PGPKeyAccessDataFormat.SIGNATURE_VERIFICATION_OPTION_NO_SIGNATURE_ALLOWED).     MockEndpoint mock = getMockEndpoint("mock:exception").     mock.expectedMessageCount(1).     template.sendBody("direct:subkey", "Test Message").     assertMockEndpointsSatisfied().     checkThrownException(mock, PGPException.class, null, "PGP message contains a signature although a signature is not expected"). }
false;public;0;13;;@Test public void testExceptionForSignatureVerificationOptionRequired() throws Exception {     // no signature     encryptor.setSignatureKeyUserid(null).     decryptor.setSignatureVerificationOption(PGPKeyAccessDataFormat.SIGNATURE_VERIFICATION_OPTION_REQUIRED).     MockEndpoint mock = getMockEndpoint("mock:exception").     mock.expectedMessageCount(1).     template.sendBody("direct:subkey", "Test Message").     assertMockEndpointsSatisfied().     checkThrownException(mock, PGPException.class, null, "PGP message does not contain any signatures although a signature is expected"). }
false;public;0;15;;@Test public void testSignatureVerificationOptionIgnore() throws Exception {     // encryptor is sending a PGP message with signature! Decryptor is ignoreing the signature     decryptor.setSignatureVerificationOption(PGPKeyAccessDataFormat.SIGNATURE_VERIFICATION_OPTION_IGNORE).     decryptor.setSignatureKeyUserids(null).     // no public keyring! --> no signature validation possible     decryptor.setSignatureKeyFileName(null).     String payload = "Test Message".     MockEndpoint mock = getMockEndpoint("mock:unencrypted").     mock.expectedBodiesReceived(payload).     template.sendBody("direct:subkey", payload).     assertMockEndpointsSatisfied(). }
false;public;0;185;;public void configure() throws Exception {     onException(Exception.class).handled(true).to("mock:exception").     // START SNIPPET: pgp-format     // Public Key FileName     String keyFileName = getKeyFileName().     // Private Key FileName     String keyFileNameSec = getKeyFileNameSec().     // Keyring Userid Used to Encrypt     String keyUserid = getKeyUserId().     // Private key password     String keyPassword = getKeyPassword().     from("direct:inline").marshal().pgp(keyFileName, keyUserid).to("mock:encrypted").unmarshal().pgp(keyFileNameSec, null, keyPassword).to("mock:unencrypted").     // END SNIPPET: pgp-format     // START SNIPPET: pgp-format-header     PGPDataFormat pgpEncrypt = new PGPDataFormat().     pgpEncrypt.setKeyFileName(keyFileName).     pgpEncrypt.setKeyUserid(keyUserid).     pgpEncrypt.setProvider(getProvider()).     pgpEncrypt.setAlgorithm(getAlgorithm()).     pgpEncrypt.setCompressionAlgorithm(getCompressionAlgorithm()).     PGPDataFormat pgpDecrypt = new PGPDataFormat().     pgpDecrypt.setKeyFileName(keyFileNameSec).     pgpDecrypt.setPassword(keyPassword).     pgpDecrypt.setProvider(getProvider()).     pgpDecrypt.setSignatureVerificationOption(PGPKeyAccessDataFormat.SIGNATURE_VERIFICATION_OPTION_NO_SIGNATURE_ALLOWED).     from("direct:inline2").marshal(pgpEncrypt).to("mock:encrypted").unmarshal(pgpDecrypt).to("mock:unencrypted").     from("direct:inline-armor").marshal().pgp(keyFileName, keyUserid, null, true, true).to("mock:encrypted").unmarshal().pgp(keyFileNameSec, null, keyPassword, true, true).to("mock:unencrypted").     // END SNIPPET: pgp-format-header     // START SNIPPET: pgp-format-signature     PGPDataFormat pgpSignAndEncrypt = new PGPDataFormat().     pgpSignAndEncrypt.setKeyFileName(keyFileName).     pgpSignAndEncrypt.setKeyUserid(keyUserid).     pgpSignAndEncrypt.setSignatureKeyFileName(keyFileNameSec).     PGPPassphraseAccessor passphraseAccessor = getPassphraseAccessor().     // must be the exact user Id because passphrase is searched in accessor     pgpSignAndEncrypt.setSignatureKeyUserid("Super <sdude@nowhere.net>").     pgpSignAndEncrypt.setPassphraseAccessor(passphraseAccessor).     pgpSignAndEncrypt.setProvider(getProvider()).     pgpSignAndEncrypt.setAlgorithm(getAlgorithm()).     pgpSignAndEncrypt.setHashAlgorithm(getHashAlgorithm()).     pgpSignAndEncrypt.setCompressionAlgorithm(getCompressionAlgorithm()).     PGPDataFormat pgpVerifyAndDecrypt = new PGPDataFormat().     pgpVerifyAndDecrypt.setKeyFileName(keyFileNameSec).     pgpVerifyAndDecrypt.setPassword(keyPassword).     pgpVerifyAndDecrypt.setSignatureKeyFileName(keyFileName).     pgpVerifyAndDecrypt.setProvider(getProvider()).     // restrict verification to public keys with certain User ID     pgpVerifyAndDecrypt.setSignatureKeyUserid(keyUserid).     from("direct:inline-sign").marshal(pgpSignAndEncrypt).to("mock:encrypted").unmarshal(pgpVerifyAndDecrypt).to("mock:unencrypted").     // END SNIPPET: pgp-format-signature     // test verifying exception, no public key found corresponding to signature key userIds     from("direct:verify_exception_sig_userids").marshal(pgpSignAndEncrypt).to("mock:encrypted").setHeader(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERIDS).constant(Arrays.asList(new String[] { "wrong1", "wrong2" })).setHeader(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERID).constant("wrongUserID").unmarshal(pgpVerifyAndDecrypt).to("mock:unencrypted").     /* ---- key ring as byte array -- */     // START SNIPPET: pgp-format-key-ring-byte-array     PGPDataFormat pgpEncryptByteArray = new PGPDataFormat().     pgpEncryptByteArray.setEncryptionKeyRing(getPublicKeyRing()).     pgpEncryptByteArray.setKeyUserids(getKeyUserIds()).     pgpEncryptByteArray.setProvider(getProvider()).     pgpEncryptByteArray.setAlgorithm(SymmetricKeyAlgorithmTags.DES).     pgpEncryptByteArray.setCompressionAlgorithm(CompressionAlgorithmTags.UNCOMPRESSED).     PGPDataFormat pgpDecryptByteArray = new PGPDataFormat().     pgpDecryptByteArray.setEncryptionKeyRing(getSecKeyRing()).     pgpDecryptByteArray.setPassphraseAccessor(passphraseAccessor).     pgpDecryptByteArray.setProvider(getProvider()).     from("direct:key-ring-byte-array").streamCaching().marshal(pgpEncryptByteArray).to("mock:encrypted").unmarshal(pgpDecryptByteArray).to("mock:unencrypted").     // END SNIPPET: pgp-format-key-ring-byte-array     // START SNIPPET: pgp-format-signature-key-ring-byte-array     PGPDataFormat pgpSignAndEncryptByteArray = new PGPDataFormat().     pgpSignAndEncryptByteArray.setKeyUserid(keyUserid).     pgpSignAndEncryptByteArray.setSignatureKeyRing(getSecKeyRing()).     pgpSignAndEncryptByteArray.setSignatureKeyUserid(keyUserid).     pgpSignAndEncryptByteArray.setSignaturePassword(keyPassword).     pgpSignAndEncryptByteArray.setProvider(getProvider()).     pgpSignAndEncryptByteArray.setAlgorithm(SymmetricKeyAlgorithmTags.BLOWFISH).     pgpSignAndEncryptByteArray.setHashAlgorithm(HashAlgorithmTags.RIPEMD160).     pgpSignAndEncryptByteArray.setCompressionAlgorithm(CompressionAlgorithmTags.ZLIB).     PGPDataFormat pgpVerifyAndDecryptByteArray = new PGPDataFormat().     pgpVerifyAndDecryptByteArray.setPassphraseAccessor(passphraseAccessor).     pgpVerifyAndDecryptByteArray.setEncryptionKeyRing(getSecKeyRing()).     pgpVerifyAndDecryptByteArray.setProvider(getProvider()).     // restrict verification to public keys with certain User ID     pgpVerifyAndDecryptByteArray.setSignatureKeyUserids(getSignatureKeyUserIds()).     pgpVerifyAndDecryptByteArray.setSignatureVerificationOption(PGPKeyAccessDataFormat.SIGNATURE_VERIFICATION_OPTION_REQUIRED).     from("direct:sign-key-ring-byte-array").streamCaching().setHeader(PGPDataFormat.ENCRYPTION_KEY_RING).constant(getPublicKeyRing()).marshal(pgpSignAndEncryptByteArray).removeHeader(PGPDataFormat.ENCRYPTION_KEY_RING).to("mock:encrypted").setHeader(PGPDataFormat.SIGNATURE_KEY_RING).constant(getPublicKeyRing()).unmarshal(pgpVerifyAndDecryptByteArray).removeHeader(PGPDataFormat.SIGNATURE_KEY_RING).to("mock:unencrypted").     // END SNIPPET: pgp-format-signature-key-ring-byte-array     // START SNIPPET: pgp-format-several-signer-keys     PGPDataFormat pgpSignAndEncryptSeveralSignerKeys = new PGPDataFormat().     pgpSignAndEncryptSeveralSignerKeys.setKeyUserid(keyUserid).     pgpSignAndEncryptSeveralSignerKeys.setEncryptionKeyRing(getPublicKeyRing()).     pgpSignAndEncryptSeveralSignerKeys.setSignatureKeyRing(getSecKeyRing()).     List<String> signerUserIds = new ArrayList<>().     signerUserIds.add("Third (comment third) <email@third.com>").     signerUserIds.add("Second <email@second.com>").     pgpSignAndEncryptSeveralSignerKeys.setSignatureKeyUserids(signerUserIds).     Map<String, String> userId2Passphrase = new HashMap<>().     userId2Passphrase.put("Third (comment third) <email@third.com>", "sdude").     userId2Passphrase.put("Second <email@second.com>", "sdude").     PGPPassphraseAccessor passphraseAccessorSeveralKeys = new DefaultPGPPassphraseAccessor(userId2Passphrase).     pgpSignAndEncryptSeveralSignerKeys.setPassphraseAccessor(passphraseAccessorSeveralKeys).     PGPDataFormat pgpVerifyAndDecryptSeveralSignerKeys = new PGPDataFormat().     pgpVerifyAndDecryptSeveralSignerKeys.setPassphraseAccessor(passphraseAccessor).     pgpVerifyAndDecryptSeveralSignerKeys.setEncryptionKeyRing(getSecKeyRing()).     pgpVerifyAndDecryptSeveralSignerKeys.setSignatureKeyRing(getPublicKeyRing()).     pgpVerifyAndDecryptSeveralSignerKeys.setProvider(getProvider()).     // only specify one expected signature     List<String> expectedSigUserIds = new ArrayList<>().     expectedSigUserIds.add("Second <email@second.com>").     pgpVerifyAndDecryptSeveralSignerKeys.setSignatureKeyUserids(expectedSigUserIds).     from("direct:several-signer-keys").streamCaching().marshal(pgpSignAndEncryptSeveralSignerKeys).to("mock:encrypted").unmarshal(pgpVerifyAndDecryptSeveralSignerKeys).to("mock:unencrypted").     // END SNIPPET: pgp-format-several-signer-keys     // test encryption by several key and signing by serveral keys where the keys are specified by one User ID part     PGPDataFormat pgpSignAndEncryptOneUserIdWithServeralKeys = new PGPDataFormat().     pgpSignAndEncryptOneUserIdWithServeralKeys.setEncryptionKeyRing(getPublicKeyRing()).     pgpSignAndEncryptOneUserIdWithServeralKeys.setSignatureKeyRing(getSecKeyRing()).     // the two private keys have the same password therefore we do not need a passphrase accessor     pgpSignAndEncryptOneUserIdWithServeralKeys.setPassword(getKeyPassword()).     PGPDataFormat pgpVerifyAndDecryptOneUserIdWithServeralKeys = new PGPDataFormat().     pgpVerifyAndDecryptOneUserIdWithServeralKeys.setPassword(getKeyPassword()).     pgpVerifyAndDecryptOneUserIdWithServeralKeys.setEncryptionKeyRing(getSecKeyRing()).     pgpVerifyAndDecryptOneUserIdWithServeralKeys.setSignatureKeyRing(getPublicKeyRing()).     pgpVerifyAndDecryptOneUserIdWithServeralKeys.setProvider(getProvider()).     pgpVerifyAndDecryptOneUserIdWithServeralKeys.setSignatureKeyUserids(expectedSigUserIds).     from("direct:one-userid-several-keys").setHeader(PGPKeyAccessDataFormat.KEY_USERID).constant("econd").setHeader(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERID).constant("econd").marshal(pgpSignAndEncryptOneUserIdWithServeralKeys).removeHeader(PGPKeyAccessDataFormat.KEY_USERID).removeHeader(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERID).to("mock:encrypted").setHeader(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERID).constant("Second <email@second.com>").unmarshal(pgpVerifyAndDecryptOneUserIdWithServeralKeys).setHeader(PGPKeyAccessDataFormat.KEY_USERID).constant("econd").setHeader(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERID).constant("econd").marshal(pgpSignAndEncryptOneUserIdWithServeralKeys).removeHeader(PGPKeyAccessDataFormat.KEY_USERID).removeHeader(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERID).setHeader(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERID).constant("Third (comment third) <email@third.com>").unmarshal(pgpVerifyAndDecryptOneUserIdWithServeralKeys).to("mock:unencrypted"). }
false;public;0;11;;public void configure() throws Exception {     onException(Exception.class).handled(true).to("mock:exception").     from("direct:keyflag").marshal(encryptor).to("mock:encrypted_keyflag").     // test that the correct subkey is selected during decrypt and verify     from("direct:subkey").marshal(encryptor).to("mock:encrypted").unmarshal(decryptor).to("mock:unencrypted").     from("direct:subkeyUnmarshal").unmarshal(decryptor).to("mock:unencrypted"). }
false;public;0;21;;public void configure() throws Exception {     PGPPublicKeyAccessor publicKeyAccessor = new DefaultPGPPublicKeyAccessor(getPublicKeyRing()).     // password cannot be set dynamically!     PGPSecretKeyAccessor secretKeyAccessor = new DefaultPGPSecretKeyAccessor(getSecKeyRing(), "sdude", getProvider()).     PGPKeyAccessDataFormat dfEncryptSignKeyAccess = new PGPKeyAccessDataFormat().     dfEncryptSignKeyAccess.setPublicKeyAccessor(publicKeyAccessor).     dfEncryptSignKeyAccess.setSecretKeyAccessor(secretKeyAccessor).     dfEncryptSignKeyAccess.setKeyUserid(getKeyUserId()).     dfEncryptSignKeyAccess.setSignatureKeyUserid(getKeyUserId()).     PGPKeyAccessDataFormat dfDecryptVerifyKeyAccess = new PGPKeyAccessDataFormat().     dfDecryptVerifyKeyAccess.setPublicKeyAccessor(publicKeyAccessor).     dfDecryptVerifyKeyAccess.setSecretKeyAccessor(secretKeyAccessor).     dfDecryptVerifyKeyAccess.setSignatureKeyUserid(getKeyUserId()).     from("direct:key_access").marshal(dfEncryptSignKeyAccess).to("mock:encrypted").unmarshal(dfDecryptVerifyKeyAccess).to("mock:unencrypted"). }
false;public;0;33;;public void configure() throws Exception {     // START SNIPPET: pgp-encrypt-sign-without-compressed-data-packet     PGPDataFormat pgpEncryptSign = new PGPDataFormat().     pgpEncryptSign.setKeyUserid(getKeyUserId()).     pgpEncryptSign.setSignatureKeyRing(getSecKeyRing()).     pgpEncryptSign.setSignatureKeyUserid(getKeyUserId()).     pgpEncryptSign.setSignaturePassword(getKeyPassword()).     pgpEncryptSign.setProvider(getProvider()).     pgpEncryptSign.setAlgorithm(SymmetricKeyAlgorithmTags.BLOWFISH).     pgpEncryptSign.setHashAlgorithm(HashAlgorithmTags.RIPEMD160).     // without compressed data packet     pgpEncryptSign.setWithCompressedDataPacket(false).     PGPDataFormat pgpVerifyAndDecryptByteArray = new PGPDataFormat().     pgpVerifyAndDecryptByteArray.setPassphraseAccessor(getPassphraseAccessor()).     pgpVerifyAndDecryptByteArray.setEncryptionKeyRing(getSecKeyRing()).     pgpVerifyAndDecryptByteArray.setProvider(getProvider()).     // restrict verification to public keys with certain User ID     pgpVerifyAndDecryptByteArray.setSignatureKeyUserids(getSignatureKeyUserIds()).     pgpVerifyAndDecryptByteArray.setSignatureVerificationOption(PGPKeyAccessDataFormat.SIGNATURE_VERIFICATION_OPTION_REQUIRED).     from("direct:encrypt-sign-without-compressed-data-packet").streamCaching().setHeader(PGPDataFormat.ENCRYPTION_KEY_RING).constant(getPublicKeyRing()).marshal(pgpEncryptSign).removeHeader(PGPDataFormat.ENCRYPTION_KEY_RING).to("mock:encrypted").setHeader(PGPDataFormat.SIGNATURE_KEY_RING).constant(getPublicKeyRing()).unmarshal(pgpVerifyAndDecryptByteArray).removeHeader(PGPDataFormat.SIGNATURE_KEY_RING).to("mock:unencrypted"). // END SNIPPET: pgp-encrypt-sign-without-compressed-data-packet }
false;protected;0;258;;protected RouteBuilder[] createRouteBuilders() {     return new RouteBuilder[] { new RouteBuilder() {          public void configure() throws Exception {             onException(Exception.class).handled(true).to("mock:exception").             // START SNIPPET: pgp-format             // Public Key FileName             String keyFileName = getKeyFileName().             // Private Key FileName             String keyFileNameSec = getKeyFileNameSec().             // Keyring Userid Used to Encrypt             String keyUserid = getKeyUserId().             // Private key password             String keyPassword = getKeyPassword().             from("direct:inline").marshal().pgp(keyFileName, keyUserid).to("mock:encrypted").unmarshal().pgp(keyFileNameSec, null, keyPassword).to("mock:unencrypted").             // END SNIPPET: pgp-format             // START SNIPPET: pgp-format-header             PGPDataFormat pgpEncrypt = new PGPDataFormat().             pgpEncrypt.setKeyFileName(keyFileName).             pgpEncrypt.setKeyUserid(keyUserid).             pgpEncrypt.setProvider(getProvider()).             pgpEncrypt.setAlgorithm(getAlgorithm()).             pgpEncrypt.setCompressionAlgorithm(getCompressionAlgorithm()).             PGPDataFormat pgpDecrypt = new PGPDataFormat().             pgpDecrypt.setKeyFileName(keyFileNameSec).             pgpDecrypt.setPassword(keyPassword).             pgpDecrypt.setProvider(getProvider()).             pgpDecrypt.setSignatureVerificationOption(PGPKeyAccessDataFormat.SIGNATURE_VERIFICATION_OPTION_NO_SIGNATURE_ALLOWED).             from("direct:inline2").marshal(pgpEncrypt).to("mock:encrypted").unmarshal(pgpDecrypt).to("mock:unencrypted").             from("direct:inline-armor").marshal().pgp(keyFileName, keyUserid, null, true, true).to("mock:encrypted").unmarshal().pgp(keyFileNameSec, null, keyPassword, true, true).to("mock:unencrypted").             // END SNIPPET: pgp-format-header             // START SNIPPET: pgp-format-signature             PGPDataFormat pgpSignAndEncrypt = new PGPDataFormat().             pgpSignAndEncrypt.setKeyFileName(keyFileName).             pgpSignAndEncrypt.setKeyUserid(keyUserid).             pgpSignAndEncrypt.setSignatureKeyFileName(keyFileNameSec).             PGPPassphraseAccessor passphraseAccessor = getPassphraseAccessor().             // must be the exact user Id because passphrase is searched in accessor             pgpSignAndEncrypt.setSignatureKeyUserid("Super <sdude@nowhere.net>").             pgpSignAndEncrypt.setPassphraseAccessor(passphraseAccessor).             pgpSignAndEncrypt.setProvider(getProvider()).             pgpSignAndEncrypt.setAlgorithm(getAlgorithm()).             pgpSignAndEncrypt.setHashAlgorithm(getHashAlgorithm()).             pgpSignAndEncrypt.setCompressionAlgorithm(getCompressionAlgorithm()).             PGPDataFormat pgpVerifyAndDecrypt = new PGPDataFormat().             pgpVerifyAndDecrypt.setKeyFileName(keyFileNameSec).             pgpVerifyAndDecrypt.setPassword(keyPassword).             pgpVerifyAndDecrypt.setSignatureKeyFileName(keyFileName).             pgpVerifyAndDecrypt.setProvider(getProvider()).             // restrict verification to public keys with certain User ID             pgpVerifyAndDecrypt.setSignatureKeyUserid(keyUserid).             from("direct:inline-sign").marshal(pgpSignAndEncrypt).to("mock:encrypted").unmarshal(pgpVerifyAndDecrypt).to("mock:unencrypted").             // END SNIPPET: pgp-format-signature             // test verifying exception, no public key found corresponding to signature key userIds             from("direct:verify_exception_sig_userids").marshal(pgpSignAndEncrypt).to("mock:encrypted").setHeader(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERIDS).constant(Arrays.asList(new String[] { "wrong1", "wrong2" })).setHeader(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERID).constant("wrongUserID").unmarshal(pgpVerifyAndDecrypt).to("mock:unencrypted").             /* ---- key ring as byte array -- */             // START SNIPPET: pgp-format-key-ring-byte-array             PGPDataFormat pgpEncryptByteArray = new PGPDataFormat().             pgpEncryptByteArray.setEncryptionKeyRing(getPublicKeyRing()).             pgpEncryptByteArray.setKeyUserids(getKeyUserIds()).             pgpEncryptByteArray.setProvider(getProvider()).             pgpEncryptByteArray.setAlgorithm(SymmetricKeyAlgorithmTags.DES).             pgpEncryptByteArray.setCompressionAlgorithm(CompressionAlgorithmTags.UNCOMPRESSED).             PGPDataFormat pgpDecryptByteArray = new PGPDataFormat().             pgpDecryptByteArray.setEncryptionKeyRing(getSecKeyRing()).             pgpDecryptByteArray.setPassphraseAccessor(passphraseAccessor).             pgpDecryptByteArray.setProvider(getProvider()).             from("direct:key-ring-byte-array").streamCaching().marshal(pgpEncryptByteArray).to("mock:encrypted").unmarshal(pgpDecryptByteArray).to("mock:unencrypted").             // END SNIPPET: pgp-format-key-ring-byte-array             // START SNIPPET: pgp-format-signature-key-ring-byte-array             PGPDataFormat pgpSignAndEncryptByteArray = new PGPDataFormat().             pgpSignAndEncryptByteArray.setKeyUserid(keyUserid).             pgpSignAndEncryptByteArray.setSignatureKeyRing(getSecKeyRing()).             pgpSignAndEncryptByteArray.setSignatureKeyUserid(keyUserid).             pgpSignAndEncryptByteArray.setSignaturePassword(keyPassword).             pgpSignAndEncryptByteArray.setProvider(getProvider()).             pgpSignAndEncryptByteArray.setAlgorithm(SymmetricKeyAlgorithmTags.BLOWFISH).             pgpSignAndEncryptByteArray.setHashAlgorithm(HashAlgorithmTags.RIPEMD160).             pgpSignAndEncryptByteArray.setCompressionAlgorithm(CompressionAlgorithmTags.ZLIB).             PGPDataFormat pgpVerifyAndDecryptByteArray = new PGPDataFormat().             pgpVerifyAndDecryptByteArray.setPassphraseAccessor(passphraseAccessor).             pgpVerifyAndDecryptByteArray.setEncryptionKeyRing(getSecKeyRing()).             pgpVerifyAndDecryptByteArray.setProvider(getProvider()).             // restrict verification to public keys with certain User ID             pgpVerifyAndDecryptByteArray.setSignatureKeyUserids(getSignatureKeyUserIds()).             pgpVerifyAndDecryptByteArray.setSignatureVerificationOption(PGPKeyAccessDataFormat.SIGNATURE_VERIFICATION_OPTION_REQUIRED).             from("direct:sign-key-ring-byte-array").streamCaching().setHeader(PGPDataFormat.ENCRYPTION_KEY_RING).constant(getPublicKeyRing()).marshal(pgpSignAndEncryptByteArray).removeHeader(PGPDataFormat.ENCRYPTION_KEY_RING).to("mock:encrypted").setHeader(PGPDataFormat.SIGNATURE_KEY_RING).constant(getPublicKeyRing()).unmarshal(pgpVerifyAndDecryptByteArray).removeHeader(PGPDataFormat.SIGNATURE_KEY_RING).to("mock:unencrypted").             // END SNIPPET: pgp-format-signature-key-ring-byte-array             // START SNIPPET: pgp-format-several-signer-keys             PGPDataFormat pgpSignAndEncryptSeveralSignerKeys = new PGPDataFormat().             pgpSignAndEncryptSeveralSignerKeys.setKeyUserid(keyUserid).             pgpSignAndEncryptSeveralSignerKeys.setEncryptionKeyRing(getPublicKeyRing()).             pgpSignAndEncryptSeveralSignerKeys.setSignatureKeyRing(getSecKeyRing()).             List<String> signerUserIds = new ArrayList<>().             signerUserIds.add("Third (comment third) <email@third.com>").             signerUserIds.add("Second <email@second.com>").             pgpSignAndEncryptSeveralSignerKeys.setSignatureKeyUserids(signerUserIds).             Map<String, String> userId2Passphrase = new HashMap<>().             userId2Passphrase.put("Third (comment third) <email@third.com>", "sdude").             userId2Passphrase.put("Second <email@second.com>", "sdude").             PGPPassphraseAccessor passphraseAccessorSeveralKeys = new DefaultPGPPassphraseAccessor(userId2Passphrase).             pgpSignAndEncryptSeveralSignerKeys.setPassphraseAccessor(passphraseAccessorSeveralKeys).             PGPDataFormat pgpVerifyAndDecryptSeveralSignerKeys = new PGPDataFormat().             pgpVerifyAndDecryptSeveralSignerKeys.setPassphraseAccessor(passphraseAccessor).             pgpVerifyAndDecryptSeveralSignerKeys.setEncryptionKeyRing(getSecKeyRing()).             pgpVerifyAndDecryptSeveralSignerKeys.setSignatureKeyRing(getPublicKeyRing()).             pgpVerifyAndDecryptSeveralSignerKeys.setProvider(getProvider()).             // only specify one expected signature             List<String> expectedSigUserIds = new ArrayList<>().             expectedSigUserIds.add("Second <email@second.com>").             pgpVerifyAndDecryptSeveralSignerKeys.setSignatureKeyUserids(expectedSigUserIds).             from("direct:several-signer-keys").streamCaching().marshal(pgpSignAndEncryptSeveralSignerKeys).to("mock:encrypted").unmarshal(pgpVerifyAndDecryptSeveralSignerKeys).to("mock:unencrypted").             // END SNIPPET: pgp-format-several-signer-keys             // test encryption by several key and signing by serveral keys where the keys are specified by one User ID part             PGPDataFormat pgpSignAndEncryptOneUserIdWithServeralKeys = new PGPDataFormat().             pgpSignAndEncryptOneUserIdWithServeralKeys.setEncryptionKeyRing(getPublicKeyRing()).             pgpSignAndEncryptOneUserIdWithServeralKeys.setSignatureKeyRing(getSecKeyRing()).             // the two private keys have the same password therefore we do not need a passphrase accessor             pgpSignAndEncryptOneUserIdWithServeralKeys.setPassword(getKeyPassword()).             PGPDataFormat pgpVerifyAndDecryptOneUserIdWithServeralKeys = new PGPDataFormat().             pgpVerifyAndDecryptOneUserIdWithServeralKeys.setPassword(getKeyPassword()).             pgpVerifyAndDecryptOneUserIdWithServeralKeys.setEncryptionKeyRing(getSecKeyRing()).             pgpVerifyAndDecryptOneUserIdWithServeralKeys.setSignatureKeyRing(getPublicKeyRing()).             pgpVerifyAndDecryptOneUserIdWithServeralKeys.setProvider(getProvider()).             pgpVerifyAndDecryptOneUserIdWithServeralKeys.setSignatureKeyUserids(expectedSigUserIds).             from("direct:one-userid-several-keys").setHeader(PGPKeyAccessDataFormat.KEY_USERID).constant("econd").setHeader(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERID).constant("econd").marshal(pgpSignAndEncryptOneUserIdWithServeralKeys).removeHeader(PGPKeyAccessDataFormat.KEY_USERID).removeHeader(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERID).to("mock:encrypted").setHeader(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERID).constant("Second <email@second.com>").unmarshal(pgpVerifyAndDecryptOneUserIdWithServeralKeys).setHeader(PGPKeyAccessDataFormat.KEY_USERID).constant("econd").setHeader(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERID).constant("econd").marshal(pgpSignAndEncryptOneUserIdWithServeralKeys).removeHeader(PGPKeyAccessDataFormat.KEY_USERID).removeHeader(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERID).setHeader(PGPKeyAccessDataFormat.SIGNATURE_KEY_USERID).constant("Third (comment third) <email@third.com>").unmarshal(pgpVerifyAndDecryptOneUserIdWithServeralKeys).to("mock:unencrypted").         }     }, new RouteBuilder() {          public void configure() throws Exception {             onException(Exception.class).handled(true).to("mock:exception").             from("direct:keyflag").marshal(encryptor).to("mock:encrypted_keyflag").             // test that the correct subkey is selected during decrypt and verify             from("direct:subkey").marshal(encryptor).to("mock:encrypted").unmarshal(decryptor).to("mock:unencrypted").             from("direct:subkeyUnmarshal").unmarshal(decryptor).to("mock:unencrypted").         }     }, new RouteBuilder() {          public void configure() throws Exception {             PGPPublicKeyAccessor publicKeyAccessor = new DefaultPGPPublicKeyAccessor(getPublicKeyRing()).             // password cannot be set dynamically!             PGPSecretKeyAccessor secretKeyAccessor = new DefaultPGPSecretKeyAccessor(getSecKeyRing(), "sdude", getProvider()).             PGPKeyAccessDataFormat dfEncryptSignKeyAccess = new PGPKeyAccessDataFormat().             dfEncryptSignKeyAccess.setPublicKeyAccessor(publicKeyAccessor).             dfEncryptSignKeyAccess.setSecretKeyAccessor(secretKeyAccessor).             dfEncryptSignKeyAccess.setKeyUserid(getKeyUserId()).             dfEncryptSignKeyAccess.setSignatureKeyUserid(getKeyUserId()).             PGPKeyAccessDataFormat dfDecryptVerifyKeyAccess = new PGPKeyAccessDataFormat().             dfDecryptVerifyKeyAccess.setPublicKeyAccessor(publicKeyAccessor).             dfDecryptVerifyKeyAccess.setSecretKeyAccessor(secretKeyAccessor).             dfDecryptVerifyKeyAccess.setSignatureKeyUserid(getKeyUserId()).             from("direct:key_access").marshal(dfEncryptSignKeyAccess).to("mock:encrypted").unmarshal(dfDecryptVerifyKeyAccess).to("mock:unencrypted").         }     }, new RouteBuilder() {          public void configure() throws Exception {             // START SNIPPET: pgp-encrypt-sign-without-compressed-data-packet             PGPDataFormat pgpEncryptSign = new PGPDataFormat().             pgpEncryptSign.setKeyUserid(getKeyUserId()).             pgpEncryptSign.setSignatureKeyRing(getSecKeyRing()).             pgpEncryptSign.setSignatureKeyUserid(getKeyUserId()).             pgpEncryptSign.setSignaturePassword(getKeyPassword()).             pgpEncryptSign.setProvider(getProvider()).             pgpEncryptSign.setAlgorithm(SymmetricKeyAlgorithmTags.BLOWFISH).             pgpEncryptSign.setHashAlgorithm(HashAlgorithmTags.RIPEMD160).             // without compressed data packet             pgpEncryptSign.setWithCompressedDataPacket(false).             PGPDataFormat pgpVerifyAndDecryptByteArray = new PGPDataFormat().             pgpVerifyAndDecryptByteArray.setPassphraseAccessor(getPassphraseAccessor()).             pgpVerifyAndDecryptByteArray.setEncryptionKeyRing(getSecKeyRing()).             pgpVerifyAndDecryptByteArray.setProvider(getProvider()).             // restrict verification to public keys with certain User ID             pgpVerifyAndDecryptByteArray.setSignatureKeyUserids(getSignatureKeyUserIds()).             pgpVerifyAndDecryptByteArray.setSignatureVerificationOption(PGPKeyAccessDataFormat.SIGNATURE_VERIFICATION_OPTION_REQUIRED).             from("direct:encrypt-sign-without-compressed-data-packet").streamCaching().setHeader(PGPDataFormat.ENCRYPTION_KEY_RING).constant(getPublicKeyRing()).marshal(pgpEncryptSign).removeHeader(PGPDataFormat.ENCRYPTION_KEY_RING).to("mock:encrypted").setHeader(PGPDataFormat.SIGNATURE_KEY_RING).constant(getPublicKeyRing()).unmarshal(pgpVerifyAndDecryptByteArray).removeHeader(PGPDataFormat.SIGNATURE_KEY_RING).to("mock:unencrypted").         // END SNIPPET: pgp-encrypt-sign-without-compressed-data-packet         }     } }. }
false;public,static;0;3;;public static byte[] getPublicKeyRing() throws Exception {     return getKeyRing(PUB_KEY_RING_FILE_NAME). }
false;public,static;0;3;;public static byte[] getSecKeyRing() throws Exception {     return getKeyRing(SEC_KEY_RING_FILE_NAME). }
false;private,static;1;7;;private static byte[] getKeyRing(String fileName) throws IOException {     InputStream is = PGPDataFormatTest.class.getClassLoader().getResourceAsStream(fileName).     ByteArrayOutputStream output = new ByteArrayOutputStream().     IOHelper.copyAndCloseInput(is, output).     output.close().     return output.toByteArray(). }
false;public,static;0;5;;public static PGPPassphraseAccessor getPassphraseAccessor() {     Map<String, String> userId2Passphrase = Collections.singletonMap("Super <sdude@nowhere.net>", "sdude").     PGPPassphraseAccessor passphraseAccessor = new DefaultPGPPassphraseAccessor(userId2Passphrase).     return passphraseAccessor. }
false;public,static;4;27;;public static void checkThrownException(MockEndpoint mock, Class<? extends Exception> cl, Class<? extends Exception> expectedCauseClass, String expectedMessagePart) throws Exception {     Exception e = (Exception) mock.getExchanges().get(0).getProperty(Exchange.EXCEPTION_CAUGHT).     assertNotNull("Expected excpetion " + cl.getName() + " missing", e).     if (e.getClass() != cl) {         String stackTrace = getStrackTrace(e).         fail("Exception  " + cl.getName() + " excpected, but was " + e.getClass().getName() + ": " + stackTrace).     }     if (expectedMessagePart != null) {         if (e.getMessage() == null) {             fail("Expected excption does not contain a message. Stack trace: " + getStrackTrace(e)).         } else {             if (!e.getMessage().contains(expectedMessagePart)) {                 fail("Expected excption message does not contain a expected message part " + expectedMessagePart + ".  Stack trace: " + getStrackTrace(e)).             }         }     }     if (expectedCauseClass != null) {         Throwable cause = e.getCause().         assertNotNull("Expected cause exception" + expectedCauseClass.getName() + " missing", cause).         if (expectedCauseClass != cause.getClass()) {             fail("Cause exception " + expectedCauseClass.getName() + " expected, but was " + cause.getClass().getName() + ": " + getStrackTrace(e)).         }     } }
false;public,static;1;8;;public static String getStrackTrace(Exception e) throws UnsupportedEncodingException {     ByteArrayOutputStream os = new ByteArrayOutputStream().     PrintWriter w = new PrintWriter(os).     e.printStackTrace(w).     w.close().     String stackTrace = new String(os.toByteArray(), "UTF-8").     return stackTrace. }
