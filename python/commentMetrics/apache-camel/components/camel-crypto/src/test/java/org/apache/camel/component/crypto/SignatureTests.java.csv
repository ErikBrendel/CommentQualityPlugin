commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;15;;@Override protected JndiRegistry createRegistry() throws Exception {     JndiRegistry registry = super.createRegistry().     KeyStore keystore = loadKeystore().     Certificate cert = keystore.getCertificate("bob").     KeyStoreParameters keystoreParameters = new KeyStoreParameters().     keystoreParameters.setPassword("letmein").     keystoreParameters.setResource("./ks.keystore").     registry.bind("signatureParams", keystoreParameters).     registry.bind("keystore", keystore).     registry.bind("myPublicKey", cert.getPublicKey()).     registry.bind("myCert", cert).     registry.bind("myPrivateKey", keystore.getKey("bob", "letmein".toCharArray())).     return registry. }
false;public;0;5;;public void configure() throws Exception {     // START SNIPPET: basic     from("direct:keypair").to("crypto:sign:basic?privateKey=#myPrivateKey", "crypto:verify:basic?publicKey=#myPublicKey", "mock:result"). // END SNIPPET: basic }
false;public;0;12;;public void configure() throws Exception {     // START SNIPPET: algorithm     keyPair = getKeyPair("RSA").     PrivateKey privateKey = keyPair.getPrivate().     PublicKey publicKey = keyPair.getPublic().     // we can set the keys explicitly on the endpoint instances.     context.getEndpoint("crypto:sign:rsa?algorithm=MD5withRSA", DigitalSignatureEndpoint.class).setPrivateKey(privateKey).     context.getEndpoint("crypto:verify:rsa?algorithm=MD5withRSA", DigitalSignatureEndpoint.class).setPublicKey(publicKey).     from("direct:algorithm").to("crypto:sign:rsa?algorithm=MD5withRSA", "crypto:verify:rsa?algorithm=MD5withRSA", "mock:result"). // END SNIPPET: algorithm }
false;public;0;12;;public void configure() throws Exception {     // START SNIPPET: rsa-sha1     keyPair = getKeyPair("RSA").     PrivateKey privateKey = keyPair.getPrivate().     PublicKey publicKey = keyPair.getPublic().     // we can set the keys explicitly on the endpoint instances.     context.getEndpoint("crypto:sign:rsa?algorithm=SHA1withRSA", DigitalSignatureEndpoint.class).setPrivateKey(privateKey).     context.getEndpoint("crypto:verify:rsa?algorithm=SHA1withRSA", DigitalSignatureEndpoint.class).setPublicKey(publicKey).     from("direct:rsa-sha1").to("crypto:sign:rsa?algorithm=SHA1withRSA", "crypto:verify:rsa?algorithm=SHA1withRSA", "mock:result"). // END SNIPPET: rsa-sha1 }
false;public;0;12;;public void configure() throws Exception {     // START SNIPPET: rsa-sha256     keyPair = getKeyPair("RSA").     PrivateKey privateKey = keyPair.getPrivate().     PublicKey publicKey = keyPair.getPublic().     // we can set the keys explicitly on the endpoint instances.     context.getEndpoint("crypto:sign:rsa?algorithm=SHA256withRSA", DigitalSignatureEndpoint.class).setPrivateKey(privateKey).     context.getEndpoint("crypto:verify:rsa?algorithm=SHA256withRSA", DigitalSignatureEndpoint.class).setPublicKey(publicKey).     from("direct:rsa-sha256").to("crypto:sign:rsa?algorithm=SHA256withRSA", "crypto:verify:rsa?algorithm=SHA256withRSA", "mock:result"). // END SNIPPET: rsa-sha256 }
false;public;0;5;;public void configure() throws Exception {     // START SNIPPET: buffersize     from("direct:buffersize").to("crypto:sign:buffer?privateKey=#myPrivateKey&buffersize=1024", "crypto:verify:buffer?publicKey=#myPublicKey&buffersize=1024", "mock:result"). // END SNIPPET: buffersize }
false;public;0;5;;public void configure() throws Exception {     // START SNIPPET: provider     from("direct:provider").to("crypto:sign:provider?privateKey=#myPrivateKey&provider=SUN", "crypto:verify:provider?publicKey=#myPublicKey&provider=SUN", "mock:result"). // END SNIPPET: provider }
false;public;0;5;;public void configure() throws Exception {     // START SNIPPET: certificate     from("direct:certificate").to("crypto:sign:withcert?privateKey=#myPrivateKey", "crypto:verify:withcert?certificate=#myCert", "mock:result"). // END SNIPPET: certificate }
false;public;0;5;;public void configure() throws Exception {     // START SNIPPET: keystore     from("direct:keystore").to("crypto:sign:keystore?keystore=#keystore&alias=bob&password=letmein", "crypto:verify:keystore?keystore=#keystore&alias=bob", "mock:result"). // END SNIPPET: keystore }
false;public;0;6;;public void configure() throws Exception {     // START SNIPPET: keystore     from("direct:keystoreParameters").to("crypto:sign:keyStoreParameters?keyStoreParameters=#signatureParams&alias=bob&password=letmein", "crypto:verify:keyStoreParameters?keyStoreParameters=#signatureParams&alias=bob", "mock:result"). // END SNIPPET: keystore }
false;public;0;6;;public void configure() throws Exception {     // START SNIPPET: signature-header     from("direct:signature-header").to("crypto:sign:another?privateKey=#myPrivateKey&signatureHeader=AnotherDigitalSignature", "crypto:verify:another?publicKey=#myPublicKey&signatureHeader=AnotherDigitalSignature", "mock:result"). // END SNIPPET: signature-header }
false;public;0;6;;public void configure() throws Exception {     // START SNIPPET: random     from("direct:random").to("crypto:sign:another?privateKey=#myPrivateKey&secureRandom=#someRandom", "crypto:verify:another?publicKey=#myPublicKey&secureRandom=#someRandom", "mock:result"). // END SNIPPET: random }
false;public;0;6;;public void configure() throws Exception {     // START SNIPPET: alias     from("direct:alias-sign").to("crypto:sign:alias?keystore=#keystore").     from("direct:alias-verify").to("crypto:verify:alias?keystore=#keystore", "mock:result"). // END SNIPPET: alias }
false;public;0;6;;public void configure() throws Exception {     // START SNIPPET: headerkey     from("direct:headerkey-sign").to("crypto:sign:alias").     from("direct:headerkey-verify").to("crypto:verify:alias", "mock:result"). // END SNIPPET: headerkey }
false;public;0;5;;public void configure() throws Exception {     // START SNIPPET: clearheaders     from("direct:headers").to("crypto:sign:headers?privateKey=#myPrivateKey", "crypto:verify:headers?publicKey=#myPublicKey&clearHeaders=false", "mock:result"). // END SNIPPET: clearheaders }
false;protected;0;114;;@Override protected RouteBuilder[] createRouteBuilders() throws Exception {     return new RouteBuilder[] { new RouteBuilder() {          public void configure() throws Exception {             // START SNIPPET: basic             from("direct:keypair").to("crypto:sign:basic?privateKey=#myPrivateKey", "crypto:verify:basic?publicKey=#myPublicKey", "mock:result").         // END SNIPPET: basic         }     }, new RouteBuilder() {          public void configure() throws Exception {             // START SNIPPET: algorithm             keyPair = getKeyPair("RSA").             PrivateKey privateKey = keyPair.getPrivate().             PublicKey publicKey = keyPair.getPublic().             // we can set the keys explicitly on the endpoint instances.             context.getEndpoint("crypto:sign:rsa?algorithm=MD5withRSA", DigitalSignatureEndpoint.class).setPrivateKey(privateKey).             context.getEndpoint("crypto:verify:rsa?algorithm=MD5withRSA", DigitalSignatureEndpoint.class).setPublicKey(publicKey).             from("direct:algorithm").to("crypto:sign:rsa?algorithm=MD5withRSA", "crypto:verify:rsa?algorithm=MD5withRSA", "mock:result").         // END SNIPPET: algorithm         }     }, new RouteBuilder() {          public void configure() throws Exception {             // START SNIPPET: rsa-sha1             keyPair = getKeyPair("RSA").             PrivateKey privateKey = keyPair.getPrivate().             PublicKey publicKey = keyPair.getPublic().             // we can set the keys explicitly on the endpoint instances.             context.getEndpoint("crypto:sign:rsa?algorithm=SHA1withRSA", DigitalSignatureEndpoint.class).setPrivateKey(privateKey).             context.getEndpoint("crypto:verify:rsa?algorithm=SHA1withRSA", DigitalSignatureEndpoint.class).setPublicKey(publicKey).             from("direct:rsa-sha1").to("crypto:sign:rsa?algorithm=SHA1withRSA", "crypto:verify:rsa?algorithm=SHA1withRSA", "mock:result").         // END SNIPPET: rsa-sha1         }     }, new RouteBuilder() {          public void configure() throws Exception {             // START SNIPPET: rsa-sha256             keyPair = getKeyPair("RSA").             PrivateKey privateKey = keyPair.getPrivate().             PublicKey publicKey = keyPair.getPublic().             // we can set the keys explicitly on the endpoint instances.             context.getEndpoint("crypto:sign:rsa?algorithm=SHA256withRSA", DigitalSignatureEndpoint.class).setPrivateKey(privateKey).             context.getEndpoint("crypto:verify:rsa?algorithm=SHA256withRSA", DigitalSignatureEndpoint.class).setPublicKey(publicKey).             from("direct:rsa-sha256").to("crypto:sign:rsa?algorithm=SHA256withRSA", "crypto:verify:rsa?algorithm=SHA256withRSA", "mock:result").         // END SNIPPET: rsa-sha256         }     }, new RouteBuilder() {          public void configure() throws Exception {             // START SNIPPET: buffersize             from("direct:buffersize").to("crypto:sign:buffer?privateKey=#myPrivateKey&buffersize=1024", "crypto:verify:buffer?publicKey=#myPublicKey&buffersize=1024", "mock:result").         // END SNIPPET: buffersize         }     }, new RouteBuilder() {          public void configure() throws Exception {             // START SNIPPET: provider             from("direct:provider").to("crypto:sign:provider?privateKey=#myPrivateKey&provider=SUN", "crypto:verify:provider?publicKey=#myPublicKey&provider=SUN", "mock:result").         // END SNIPPET: provider         }     }, new RouteBuilder() {          public void configure() throws Exception {             // START SNIPPET: certificate             from("direct:certificate").to("crypto:sign:withcert?privateKey=#myPrivateKey", "crypto:verify:withcert?certificate=#myCert", "mock:result").         // END SNIPPET: certificate         }     }, new RouteBuilder() {          public void configure() throws Exception {             // START SNIPPET: keystore             from("direct:keystore").to("crypto:sign:keystore?keystore=#keystore&alias=bob&password=letmein", "crypto:verify:keystore?keystore=#keystore&alias=bob", "mock:result").         // END SNIPPET: keystore         }     }, new RouteBuilder() {          public void configure() throws Exception {             // START SNIPPET: keystore             from("direct:keystoreParameters").to("crypto:sign:keyStoreParameters?keyStoreParameters=#signatureParams&alias=bob&password=letmein", "crypto:verify:keyStoreParameters?keyStoreParameters=#signatureParams&alias=bob", "mock:result").         // END SNIPPET: keystore         }     }, new RouteBuilder() {          public void configure() throws Exception {             // START SNIPPET: signature-header             from("direct:signature-header").to("crypto:sign:another?privateKey=#myPrivateKey&signatureHeader=AnotherDigitalSignature", "crypto:verify:another?publicKey=#myPublicKey&signatureHeader=AnotherDigitalSignature", "mock:result").         // END SNIPPET: signature-header         }     }, new RouteBuilder() {          public void configure() throws Exception {             // START SNIPPET: random             from("direct:random").to("crypto:sign:another?privateKey=#myPrivateKey&secureRandom=#someRandom", "crypto:verify:another?publicKey=#myPublicKey&secureRandom=#someRandom", "mock:result").         // END SNIPPET: random         }     }, new RouteBuilder() {          public void configure() throws Exception {             // START SNIPPET: alias             from("direct:alias-sign").to("crypto:sign:alias?keystore=#keystore").             from("direct:alias-verify").to("crypto:verify:alias?keystore=#keystore", "mock:result").         // END SNIPPET: alias         }     }, new RouteBuilder() {          public void configure() throws Exception {             // START SNIPPET: headerkey             from("direct:headerkey-sign").to("crypto:sign:alias").             from("direct:headerkey-verify").to("crypto:verify:alias", "mock:result").         // END SNIPPET: headerkey         }     }, new RouteBuilder() {          public void configure() throws Exception {             // START SNIPPET: clearheaders             from("direct:headers").to("crypto:sign:headers?privateKey=#myPrivateKey", "crypto:verify:headers?publicKey=#myPublicKey&clearHeaders=false", "mock:result").         // END SNIPPET: clearheaders         }     } }. }
false;public;0;11;;@Test public void testBasicSignatureRoute() throws Exception {     setupMock().     sendBody("direct:keypair", payload).     assertMockEndpointsSatisfied().     MockEndpoint mock = getMockEndpoint("mock:result").     Exchange e = mock.getExchanges().get(0).     Message result = e == null ? null : e.hasOut() ? e.getOut() : e.getIn().     assertNull(result.getHeader(DigitalSignatureConstants.SIGNATURE)). }
false;public;0;6;;@Test public void testSetAlgorithmInRouteDefinition() throws Exception {     setupMock().     sendBody("direct:algorithm", payload).     assertMockEndpointsSatisfied(). }
false;public;0;6;;@Test public void testRSASHA1() throws Exception {     setupMock().     sendBody("direct:rsa-sha1", payload).     assertMockEndpointsSatisfied(). }
false;public;0;6;;@Test public void testRSASHA256() throws Exception {     setupMock().     sendBody("direct:rsa-sha256", payload).     assertMockEndpointsSatisfied(). }
false;public;0;6;;@Test public void testSetBufferInRouteDefinition() throws Exception {     setupMock().     sendBody("direct:buffersize", payload).     assertMockEndpointsSatisfied(). }
false;public;0;6;;@Test public void testSetRandomInRouteDefinition() throws Exception {     setupMock().     sendBody("direct:random", payload).     assertMockEndpointsSatisfied(). }
false;public;0;10;;@Test public void testSetProviderInRouteDefinition() throws Exception {     if (isJavaVendor("ibm")) {         return.     }     // can only be run on SUN JDK     setupMock().     sendBody("direct:provider", payload).     assertMockEndpointsSatisfied(). }
false;public;0;6;;@Test public void testSetCertificateInRouteDefinition() throws Exception {     setupMock().     sendBody("direct:certificate", payload).     assertMockEndpointsSatisfied(). }
false;public;0;6;;@Test public void testSetKeystoreInRouteDefinition() throws Exception {     setupMock().     sendBody("direct:keystore", payload).     assertMockEndpointsSatisfied(). }
false;public;0;6;;@Test public void testSetKeystoreParametersInRouteDefinition() throws Exception {     setupMock().     sendBody("direct:keystoreParameters", payload).     assertMockEndpointsSatisfied(). }
false;public;0;10;;@Test public void testSignatureHeaderInRouteDefinition() throws Exception {     setupMock().     Exchange signed = getMandatoryEndpoint("direct:signature-header").createExchange().     signed.getIn().setBody(payload).     template.send("direct:signature-header", signed).     assertNotNull(signed.getIn().getHeader("AnotherDigitalSignature")).     assertMockEndpointsSatisfied(). }
false;public;0;19;;@Test public void testProvideAliasInHeader() throws Exception {     setupMock().     // START SNIPPET: alias-send     Exchange unsigned = getMandatoryEndpoint("direct:alias-sign").createExchange().     unsigned.getIn().setBody(payload).     unsigned.getIn().setHeader(DigitalSignatureConstants.KEYSTORE_ALIAS, "bob").     unsigned.getIn().setHeader(DigitalSignatureConstants.KEYSTORE_PASSWORD, "letmein".toCharArray()).     template.send("direct:alias-sign", unsigned).     Exchange signed = getMandatoryEndpoint("direct:alias-sign").createExchange().     signed.getIn().copyFrom(unsigned.getOut()).     signed.getIn().setHeader(KEYSTORE_ALIAS, "bob").     template.send("direct:alias-verify", signed).     // START SNIPPET: alias-send     assertMockEndpointsSatisfied(). }
false;public;0;21;;@Test public void testProvideKeysInHeader() throws Exception {     setupMock().     Exchange unsigned = getMandatoryEndpoint("direct:headerkey-sign").createExchange().     unsigned.getIn().setBody(payload).     // create a keypair     KeyPair pair = getKeyPair("DSA").     // sign with the private key     unsigned.getIn().setHeader(SIGNATURE_PRIVATE_KEY, pair.getPrivate()).     template.send("direct:headerkey-sign", unsigned).     // verify with the public key     Exchange signed = getMandatoryEndpoint("direct:alias-sign").createExchange().     signed.getIn().copyFrom(unsigned.getOut()).     signed.getIn().setHeader(SIGNATURE_PUBLIC_KEY_OR_CERT, pair.getPublic()).     template.send("direct:headerkey-verify", signed).     assertMockEndpointsSatisfied(). }
false;public;0;23;;@Test public void testProvideCertificateInHeader() throws Exception {     setupMock().     Exchange unsigned = getMandatoryEndpoint("direct:signature-property").createExchange().     unsigned.getIn().setBody(payload).     // create a keypair     KeyStore keystore = loadKeystore().     Certificate certificate = keystore.getCertificate("bob").     PrivateKey pk = (PrivateKey) keystore.getKey("bob", "letmein".toCharArray()).     // sign with the private key     unsigned.getIn().setHeader(SIGNATURE_PRIVATE_KEY, pk).     template.send("direct:headerkey-sign", unsigned).     // verify with the public key     Exchange signed = getMandatoryEndpoint("direct:alias-sign").createExchange().     signed.getIn().copyFrom(unsigned.getOut()).     signed.getIn().setHeader(SIGNATURE_PUBLIC_KEY_OR_CERT, certificate).     template.send("direct:headerkey-verify", signed).     assertMockEndpointsSatisfied(). }
false;public;0;12;;@Test public void testVerifyHeadersNotCleared() throws Exception {     setupMock().     template.requestBody("direct:headers", payload).     assertMockEndpointsSatisfied().     assertMockEndpointsSatisfied().     MockEndpoint mock = getMockEndpoint("mock:result").     Exchange e = mock.getExchanges().get(0).     Message result = e == null ? null : e.hasOut() ? e.getOut() : e.getIn().     assertNotNull(result.getHeader(DigitalSignatureConstants.SIGNATURE)). }
false;private;0;5;;private MockEndpoint setupMock() {     MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedBodiesReceived(payload).     return mock. }
false;public;1;3;;public Exchange doTestSignatureRoute(RouteBuilder builder) throws Exception {     return doSignatureRouteTest(builder, null, Collections.<String, Object>emptyMap()). }
false;public;3;21;;public Exchange doSignatureRouteTest(RouteBuilder builder, Exchange e, Map<String, Object> headers) throws Exception {     CamelContext context = new DefaultCamelContext().     try {         context.addRoutes(builder).         context.start().         MockEndpoint mock = context.getEndpoint("mock:result", MockEndpoint.class).         mock.setExpectedMessageCount(1).         ProducerTemplate template = context.createProducerTemplate().         if (e != null) {             template.send("direct:in", e).         } else {             template.sendBodyAndHeaders("direct:in", payload, headers).         }         assertMockEndpointsSatisfied().         return mock.getReceivedExchanges().get(0).     } finally {         context.stop().     } }
false;public;0;6;;@Before public void setUp() throws Exception {     setUpKeys("DSA").     disableJMX().     super.setUp(). }
false;public;1;3;;public void setUpKeys(String algorithm) throws Exception {     keyPair = getKeyPair(algorithm). }
false;public;1;5;;public KeyPair getKeyPair(String algorithm) throws NoSuchAlgorithmException {     KeyPairGenerator keyGen = KeyPairGenerator.getInstance(algorithm).     keyGen.initialize(512, new SecureRandom()).     return keyGen.generateKeyPair(). }
false;public,static;0;6;;public static KeyStore loadKeystore() throws Exception {     KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType()).     InputStream in = SignatureTests.class.getResourceAsStream("/ks.keystore").     keystore.load(in, "letmein".toCharArray()).     return keystore. }
false;public;0;4;;public Certificate getCertificateFromKeyStore() throws Exception {     Certificate c = loadKeystore().getCertificate("bob").     return c. }
false;public;0;3;;public PrivateKey getKeyFromKeystore() throws Exception {     return (PrivateKey) loadKeystore().getKey("bob", "letmein".toCharArray()). }
