commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;6;;@Override protected void doStart() throws Exception {     super.doStart().     client = new MqttClient(getBrokerUrl(), getClientId(), resolvePersistence()).     client.connect(resolveMqttConnectOptions()). }
false;protected;0;7;;@Override protected void doStop() throws Exception {     if (getClient().isConnected()) {         getClient().disconnect().     }     super.doStop(). }
false;public;0;4;;@Override public Producer createProducer() throws Exception {     return new PahoProducer(this). }
false;public;1;4;;@Override public Consumer createConsumer(Processor processor) throws Exception {     return new PahoConsumer(this, processor). }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;public;0;4;;@Override public PahoComponent getComponent() {     return (PahoComponent) super.getComponent(). }
true;protected;0;11;// Resolvers ;// Resolvers protected MqttClientPersistence resolvePersistence() {     if (persistence == PahoPersistence.MEMORY) {         return new MemoryPersistence().     } else {         if (filePersistenceDirectory != null) {             return new MqttDefaultFilePersistence(filePersistenceDirectory).         } else {             return new MqttDefaultFilePersistence().         }     } }
false;protected;0;25;;protected MqttConnectOptions resolveMqttConnectOptions() {     if (connectOptions != null) {         return connectOptions.     }     if (resolveMqttConnectOptions) {         Set<MqttConnectOptions> connectOptions = getCamelContext().getRegistry().findByType(MqttConnectOptions.class).         if (connectOptions.size() == 1) {             log.info("Single MqttConnectOptions instance found in the registry. It will be used by the endpoint.").             return connectOptions.iterator().next().         } else if (connectOptions.size() > 1) {             log.warn("Found {} instances of the MqttConnectOptions in the registry. None of these will be used by the endpoint. " + "Please use 'connectOptions' endpoint option to select one.", connectOptions.size()).         }     }     MqttConnectOptions options = new MqttConnectOptions().     options.setAutomaticReconnect(autoReconnect).     if (ObjectHelper.isNotEmpty(userName) && ObjectHelper.isNotEmpty(password)) {         options.setUserName(userName).         options.setPassword(password.toCharArray()).     }     return options. }
false;public;2;10;;public Exchange createExchange(MqttMessage mqttMessage, String topic) {     Exchange exchange = createExchange().     PahoMessage paho = new PahoMessage(exchange.getContext(), mqttMessage).     paho.setBody(mqttMessage.getPayload()).     paho.setHeader(PahoConstants.MQTT_TOPIC, topic).     exchange.setIn(paho).     return exchange. }
false;public;0;3;;// Configuration getters & setters public String getClientId() {     return clientId. }
true;public;1;3;/**  * MQTT client identifier.  */ ;/**  * MQTT client identifier.  */ public void setClientId(String clientId) {     this.clientId = clientId. }
false;public;0;3;;public String getBrokerUrl() {     return brokerUrl. }
true;public;1;3;/**  * The URL of the MQTT broker.  */ ;/**  * The URL of the MQTT broker.  */ public void setBrokerUrl(String brokerUrl) {     this.brokerUrl = brokerUrl. }
false;public;0;3;;public String getTopic() {     return topic. }
true;public;1;3;/**  * Name of the topic  */ ;/**  * Name of the topic  */ public void setTopic(String topic) {     this.topic = topic. }
false;public;0;3;;public int getQos() {     return qos. }
true;public;1;3;/**  * Client quality of service level (0-2).  */ ;/**  * Client quality of service level (0-2).  */ public void setQos(int qos) {     this.qos = qos. }
false;public;0;3;;public boolean isRetained() {     return retained. }
true;public;1;3;/**  * Retain option  *  * @param retained true/false  */ ;/**  * Retain option  *  * @param retained true/false  */ public void setRetained(boolean retained) {     this.retained = retained. }
false;public;0;3;;// Auto-configuration getters & setters public PahoPersistence getPersistence() {     return persistence. }
true;public;1;3;/**  * Client persistence to be used - memory or file.  */ ;/**  * Client persistence to be used - memory or file.  */ public void setPersistence(PahoPersistence persistence) {     this.persistence = persistence. }
false;public;0;3;;public String getFilePersistenceDirectory() {     return filePersistenceDirectory. }
true;public;1;3;/**  * Base directory used by the file persistence provider.  */ ;/**  * Base directory used by the file persistence provider.  */ public void setFilePersistenceDirectory(String filePersistenceDirectory) {     this.filePersistenceDirectory = filePersistenceDirectory. }
false;public;0;3;;public MqttClient getClient() {     return client. }
true;public;1;3;/**  * To use the existing MqttClient instance as client.  */ ;/**  * To use the existing MqttClient instance as client.  */ public void setClient(MqttClient client) {     this.client = client. }
false;public;0;3;;public MqttConnectOptions getConnectOptions() {     return connectOptions. }
true;public;1;3;/**  * Client connection options  */ ;/**  * Client connection options  */ public void setConnectOptions(MqttConnectOptions connOpts) {     this.connectOptions = connOpts. }
false;public,synchronized;0;3;;public synchronized boolean isAutoReconnect() {     return autoReconnect. }
true;public,synchronized;1;3;/**  * Client will automatically attempt to reconnect to the server if the connection is lost  * @param autoReconnect  */ ;/**  * Client will automatically attempt to reconnect to the server if the connection is lost  * @param autoReconnect  */ public synchronized void setAutoReconnect(boolean autoReconnect) {     this.autoReconnect = autoReconnect. }
false;public;0;3;;public String getUserName() {     return userName. }
true;public;1;3;/**  * Username to be used for authentication against the MQTT broker  * @param userName  */ ;/**  * Username to be used for authentication against the MQTT broker  * @param userName  */ public void setUserName(String userName) {     this.userName = userName. }
false;public;0;3;;public String getPassword() {     return password. }
true;public;1;3;/**  * Password to be used for authentication against the MQTT broker  * @param password  */ ;/**  * Password to be used for authentication against the MQTT broker  * @param password  */ public void setPassword(String password) {     this.password = password. }
false;public,synchronized;0;3;;public synchronized boolean isResolveMqttConnectOptions() {     return resolveMqttConnectOptions. }
true;public,synchronized;1;3;/**  * Define if you don't want to resolve the MQTT Connect Options from registry  * @param resolveMqttConnectOptions  */ ;/**  * Define if you don't want to resolve the MQTT Connect Options from registry  * @param resolveMqttConnectOptions  */ public synchronized void setResolveMqttConnectOptions(boolean resolveMqttConnectOptions) {     this.resolveMqttConnectOptions = resolveMqttConnectOptions. }
