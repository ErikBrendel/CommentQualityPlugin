commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected AbstractApplicationContext createApplicationContext() {     return new ClassPathXmlApplicationContext("org/apache/camel/component/jcache/policy/SpringJCachePolicyTest.xml"). }
false;public,static;0;4;;@BeforeClass public static void beforeAll() {     System.setProperty("hazelcast.config", "classpath:org/apache/camel/component/jcache/policy/hazelcast-spring.xml"). }
false;public,static;0;4;;@AfterClass public static void afterAll() {     System.clearProperty("hazelcast.config"). }
false;public;0;8;;@Before public void before() {     // reset mock     MockEndpoint mock = getMockEndpoint("mock:spring").     mock.reset().     mock.whenAnyExchangeReceived((e) -> e.getMessage().setBody(generateValue(e.getMessage().getBody(String.class)))). }
true;public;0;22;// Verify value gets cached and route is not executed for the second time ;// Verify value gets cached and route is not executed for the second time @Test public void testXmlDslValueGetsCached() throws Exception {     final String key = randomString().     MockEndpoint mock = getMockEndpoint("mock:spring").     // Send first, key is not in cache     Object responseBody = this.template().requestBody("direct:spring", key).     // We got back the value, mock was called once, value got cached.     Cache cache = lookupCache("spring").     assertEquals(generateValue(key), cache.get(key)).     assertEquals(generateValue(key), responseBody).     assertEquals(1, mock.getExchanges().size()).     // Send again, key is already in cache     responseBody = this.template().requestBody("direct:spring", key).     // We got back the stored value, but the mock was not called again     assertEquals(generateValue(key), cache.get(key)).     assertEquals(generateValue(key), responseBody).     assertEquals(1, mock.getExchanges().size()). }
true;public;0;23;// Verify if we call the route with different keys, both gets cached ;// Verify if we call the route with different keys, both gets cached @Test public void testXmlDslDifferent() throws Exception {     final String key1 = randomString().     MockEndpoint mock = getMockEndpoint("mock:spring").     // Send first, key is not in cache     Object responseBody = this.template().requestBody("direct:spring", key1).     // We got back the value, mock was called once, value got cached.     Cache cache = lookupCache("spring").     assertEquals(generateValue(key1), cache.get(key1)).     assertEquals(generateValue(key1), responseBody).     assertEquals(1, mock.getExchanges().size()).     // Send again, different key     final String key2 = randomString().     responseBody = this.template().requestBody("direct:spring", key2).     // We got back the stored value, mock was called again, value got cached.     assertEquals(generateValue(key2), cache.get(key2)).     assertEquals(generateValue(key2), responseBody).     assertEquals(2, mock.getExchanges().size()). }
true;public;0;25;// Verify policy applies only on the section of the route wrapped ;// Verify policy applies only on the section of the route wrapped @Test public void testXmlDslPartial() throws Exception {     final String key = randomString().     MockEndpoint mock = getMockEndpoint("mock:spring").     MockEndpoint mockUnwrapped = getMockEndpoint("mock:unwrapped").     // Send first, key is not in cache     Object responseBody = this.template().requestBody("direct:spring-partial", key).     // We got back the value, mock was called once, value got cached.     Cache cache = lookupCache("spring").     assertEquals(generateValue(key), cache.get(key)).     assertEquals(generateValue(key), responseBody).     assertEquals(1, mock.getExchanges().size()).     assertEquals(1, mockUnwrapped.getExchanges().size()).     // Send again, key is already in cache     responseBody = this.template().requestBody("direct:spring-partial", key).     // We got back the stored value, but the mock was not called again     assertEquals(generateValue(key), cache.get(key)).     assertEquals(generateValue(key), responseBody).     assertEquals(1, mock.getExchanges().size()).     assertEquals(2, mockUnwrapped.getExchanges().size()). }
true;public;0;24;// Use a key expression ${header.mykey} ;// Use a key expression ${header.mykey} @Test public void testXmlDslKeyExpression() throws Exception {     final String key = randomString().     final String body = randomString().     MockEndpoint mock = getMockEndpoint("mock:spring").     // Send first, key is not in cache     Object responseBody = this.template().requestBodyAndHeader("direct:spring-byheader", body, "mykey", key).     // We got back the value, mock was called once, value got cached.     Cache cache = lookupCache("spring").     assertEquals(generateValue(body), cache.get(key)).     assertEquals(generateValue(body), responseBody).     assertEquals(1, mock.getExchanges().size()).     // Send again, use another body, but the same key     responseBody = this.template().requestBodyAndHeader("direct:spring-byheader", randomString(), "mykey", key).     // We got back the stored value, and the mock was not called again     assertEquals(generateValue(body), cache.get(key)).     assertEquals(generateValue(body), responseBody).     assertEquals(1, mock.getExchanges().size()). }
