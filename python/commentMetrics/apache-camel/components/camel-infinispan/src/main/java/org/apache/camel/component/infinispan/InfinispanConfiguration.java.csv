commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getCommand() {     return operation.toString(). }
true;public;1;8;/**  * The operation to perform.  *  * @deprecated replaced by @{link setOperation}  */ ;/**  * The operation to perform.  *  * @deprecated replaced by @{link setOperation}  */ @Deprecated public void setCommand(String command) {     if (command.startsWith(InfinispanConstants.OPERATION)) {         command = command.substring(InfinispanConstants.OPERATION.length()).toUpperCase().     }     setOperation(InfinispanOperation.valueOf(command)). }
false;public;0;3;;public InfinispanOperation getOperation() {     return operation. }
true;public;1;3;/**  * The operation to perform.  */ ;/**  * The operation to perform.  */ public void setOperation(InfinispanOperation operation) {     this.operation = operation. }
false;public;0;3;;public InfinispanOperation getOperationOrDefault() {     return this.operation != null ? operation : InfinispanOperation.PUT. }
true;public;0;3;/**  * Specifies the host of the cache on Infinispan instance  */ ;/**  * Specifies the host of the cache on Infinispan instance  */ public String getHosts() {     return hosts. }
false;public;1;3;;public void setHosts(String hosts) {     this.hosts = hosts. }
true;public;0;3;/**  * Specifies the cache Container to connect  */ ;/**  * Specifies the cache Container to connect  */ public BasicCacheContainer getCacheContainer() {     return cacheContainer. }
false;public;1;3;;public void setCacheContainer(BasicCacheContainer cacheContainer) {     this.cacheContainer = cacheContainer. }
true;public;0;3;/**  * If true, the consumer will receive notifications synchronously  */ ;/**  * If true, the consumer will receive notifications synchronously  */ public boolean isSync() {     return sync. }
false;public;1;3;;public void setSync(boolean sync) {     this.sync = sync. }
true;public;0;3;/**  * If true, the listener will be installed for the entire cluster  */ ;/**  * If true, the listener will be installed for the entire cluster  */ public boolean isClusteredListener() {     return clusteredListener. }
false;public;1;3;;public void setClusteredListener(boolean clusteredListener) {     this.clusteredListener = clusteredListener. }
false;public;0;3;;public Set<String> getEventTypes() {     return eventTypes. }
true;public;1;3;/**  * Specifies the set of event types to register by the consumer. Multiple event can be separated by comma.  * <p/>  * The possible event types are: CACHE_ENTRY_ACTIVATED, CACHE_ENTRY_PASSIVATED, CACHE_ENTRY_VISITED, CACHE_ENTRY_LOADED,  * CACHE_ENTRY_EVICTED, CACHE_ENTRY_CREATED, CACHE_ENTRY_REMOVED, CACHE_ENTRY_MODIFIED, TRANSACTION_COMPLETED,  * TRANSACTION_REGISTERED, CACHE_ENTRY_INVALIDATED, DATA_REHASHED, TOPOLOGY_CHANGED, PARTITION_STATUS_CHANGED  */ ;/**  * Specifies the set of event types to register by the consumer. Multiple event can be separated by comma.  * <p/>  * The possible event types are: CACHE_ENTRY_ACTIVATED, CACHE_ENTRY_PASSIVATED, CACHE_ENTRY_VISITED, CACHE_ENTRY_LOADED,  * CACHE_ENTRY_EVICTED, CACHE_ENTRY_CREATED, CACHE_ENTRY_REMOVED, CACHE_ENTRY_MODIFIED, TRANSACTION_COMPLETED,  * TRANSACTION_REGISTERED, CACHE_ENTRY_INVALIDATED, DATA_REHASHED, TOPOLOGY_CHANGED, PARTITION_STATUS_CHANGED  */ public void setEventTypes(Set<String> eventTypes) {     this.eventTypes = eventTypes. }
true;public;1;3;/**  * Specifies the set of event types to register by the consumer. Multiple event can be separated by comma.  * <p/>  * The possible event types are: CACHE_ENTRY_ACTIVATED, CACHE_ENTRY_PASSIVATED, CACHE_ENTRY_VISITED, CACHE_ENTRY_LOADED,  * CACHE_ENTRY_EVICTED, CACHE_ENTRY_CREATED, CACHE_ENTRY_REMOVED, CACHE_ENTRY_MODIFIED, TRANSACTION_COMPLETED,  * TRANSACTION_REGISTERED, CACHE_ENTRY_INVALIDATED, DATA_REHASHED, TOPOLOGY_CHANGED, PARTITION_STATUS_CHANGED  */ ;/**  * Specifies the set of event types to register by the consumer. Multiple event can be separated by comma.  * <p/>  * The possible event types are: CACHE_ENTRY_ACTIVATED, CACHE_ENTRY_PASSIVATED, CACHE_ENTRY_VISITED, CACHE_ENTRY_LOADED,  * CACHE_ENTRY_EVICTED, CACHE_ENTRY_CREATED, CACHE_ENTRY_REMOVED, CACHE_ENTRY_MODIFIED, TRANSACTION_COMPLETED,  * TRANSACTION_REGISTERED, CACHE_ENTRY_INVALIDATED, DATA_REHASHED, TOPOLOGY_CHANGED, PARTITION_STATUS_CHANGED  */ public void setEventTypes(String eventTypes) {     this.eventTypes = new HashSet<>(Arrays.asList(eventTypes.split(","))). }
true;public;0;3;/**  * Returns the custom listener in use, if provided  */ ;/**  * Returns the custom listener in use, if provided  */ public InfinispanCustomListener getCustomListener() {     return customListener. }
false;public;1;3;;public void setCustomListener(InfinispanCustomListener customListener) {     this.customListener = customListener. }
false;public;0;3;;public boolean hasCustomListener() {     return customListener != null. }
false;public;0;3;;public InfinispanQueryBuilder getQueryBuilder() {     return queryBuilder. }
true;public;1;3;/**  * Specifies the query builder.  */ ;/**  * Specifies the query builder.  */ public void setQueryBuilder(InfinispanQueryBuilder queryBuilder) {     this.queryBuilder = queryBuilder. }
false;public;0;3;;public boolean hasQueryBuilder() {     return queryBuilder != null. }
false;public;0;3;;public Flag[] getFlags() {     return flags. }
true;public;1;8;/**  * A comma separated list of Flag to be applied by default on each cache  * invocation, not applicable to remote caches.  */ ;/**  * A comma separated list of Flag to be applied by default on each cache  * invocation, not applicable to remote caches.  */ public void setFlags(String flagsAsString) {     String[] flagsArray = flagsAsString.split(",").     this.flags = new Flag[flagsArray.length].     for (int i = 0. i < flagsArray.length. i++) {         this.flags[i] = Flag.valueOf(flagsArray[i]).     } }
false;public;1;3;;public void setFlags(Flag... flags) {     this.flags = flags. }
false;public;0;3;;public boolean hasFlags() {     return flags != null && flags.length > 0. }
true;public;0;3;/**  * An implementation specific URI for the CacheManager  */ ;/**  * An implementation specific URI for the CacheManager  */ public String getConfigurationUri() {     return configurationUri. }
false;public;1;3;;public void setConfigurationUri(String configurationUri) {     this.configurationUri = configurationUri. }
false;public;0;3;;public Map<String, String> getConfigurationProperties() {     return configurationProperties. }
true;public;1;3;/**  * Implementation specific properties for the CacheManager  */ ;/**  * Implementation specific properties for the CacheManager  */ public void setConfigurationProperties(Map<String, String> configurationProperties) {     this.configurationProperties = configurationProperties. }
true;public;2;7;/**  * Adds an implementation specific property for the CacheManager  */ ;/**  * Adds an implementation specific property for the CacheManager  */ public void addConfigurationProperty(String key, String value) {     if (this.configurationProperties == null) {         this.configurationProperties = new HashMap<>().     }     this.configurationProperties.put(key, value). }
false;public;0;3;;public Object getCacheContainerConfiguration() {     return cacheContainerConfiguration. }
true;public;1;3;/**  * The CacheContainer configuration. Uses if the cacheContainer is not defined.  * Must be the following types:  * org.infinispan.client.hotrod.configuration.Configuration - for remote cache interaction configuration.  * org.infinispan.configuration.cache.Configuration - for embedded cache interaction configuration.  */ ;/**  * The CacheContainer configuration. Uses if the cacheContainer is not defined.  * Must be the following types:  * org.infinispan.client.hotrod.configuration.Configuration - for remote cache interaction configuration.  * org.infinispan.configuration.cache.Configuration - for embedded cache interaction configuration.  */ public void setCacheContainerConfiguration(Object cacheContainerConfiguration) {     this.cacheContainerConfiguration = cacheContainerConfiguration. }
false;public;0;7;;public InfinispanConfiguration copy() {     try {         return (InfinispanConfiguration) super.clone().     } catch (CloneNotSupportedException e) {         throw new RuntimeCamelException(e).     } }
false;public;0;3;;public Object getResultHeader() {     return resultHeader. }
true;public;1;3;/**  * Store the operation result in a header instead of the message body.  *  * By default, resultHeader == null and the query result is stored in the  * message body, any existing content in the message body is discarded. If  * resultHeader is set, the value is used as the name of the header to store  * the query result and the original message body is preserved.  *  * This value can be overridden by an in message header named:  *  *     CamelInfinispanOperationResultHeader  */ ;/**  * Store the operation result in a header instead of the message body.  *  * By default, resultHeader == null and the query result is stored in the  * message body, any existing content in the message body is discarded. If  * resultHeader is set, the value is used as the name of the header to store  * the query result and the original message body is preserved.  *  * This value can be overridden by an in message header named:  *  *     CamelInfinispanOperationResultHeader  */ public void setResultHeader(Object resultHeader) {     this.resultHeader = resultHeader. }
