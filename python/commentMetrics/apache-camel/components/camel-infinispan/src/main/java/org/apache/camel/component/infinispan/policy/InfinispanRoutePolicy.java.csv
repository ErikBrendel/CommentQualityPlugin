commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public CamelContext getCamelContext() {     return camelContext. }
false;public;1;4;;@Override public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;public,synchronized;1;14;;@Override public synchronized void onInit(Route route) {     super.onInit(route).     LOGGER.info("Route managed by {}. Setting route {} AutoStartup flag to false.", getClass(), route.getId()).     RouteDefinition definition = (RouteDefinition) route.getRouteContext().getRoute().     definition.setAutoStartup("false").     stoppeddRoutes.add(route).     this.refCount.retain().     startManagedRoutes(). }
false;public,synchronized;0;4;;@Override public synchronized void doShutdown() {     this.refCount.release(). }
false;private;0;30;;// **************************************** // Helpers // **************************************** private void startService() {     // validate     StringHelper.notEmpty(lockMapName, "lockMapName", this).     StringHelper.notEmpty(lockKey, "lockKey", this).     StringHelper.notEmpty(lockValue, "lockValue", this).     ObjectHelper.notNull(camelContext, "camelContext", this).     try {         this.manager.start().         this.executorService = getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(this, "InfinispanRoutePolicy").         if (lifespanTimeUnit.convert(lifespan, TimeUnit.SECONDS) < 2) {             throw new IllegalArgumentException("Lock lifespan can not be less that 2 seconds").         }         if (manager.isCacheContainerEmbedded()) {             BasicCache<String, String> cache = manager.getCache(lockMapName).             this.service = new EmbeddedCacheService(InfinispanUtil.asEmbedded(cache)).         } else {             // By default, previously existing values for java.util.Map operations             // are not returned for remote caches but policy needs it so force it.             BasicCache<String, String> cache = manager.getCache(lockMapName, true).             this.service = new RemoteCacheService(InfinispanUtil.asRemote(cache)).         }         service.start().     } catch (Exception e) {         throw new RuntimeCamelException(e).     } }
false;private;0;20;;private void stopService() {     leader.set(false).     try {         if (future != null) {             future.cancel(true).             future = null.         }         manager.stop().         if (this.service != null) {             this.service.stop().         }         getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService).     } catch (Exception e) {         throw new RuntimeCamelException(e).     } }
false;private;1;9;;private void setLeader(boolean isLeader) {     if (isLeader && leader.compareAndSet(false, isLeader)) {         LOGGER.info("Leadership taken (map={}, key={}, val={})", lockMapName, lockKey, lockValue).         startManagedRoutes().     } else if (!isLeader && leader.getAndSet(isLeader)) {         LOGGER.info("Leadership lost (map={}, key={} val={})", lockMapName, lockKey, lockValue).         stopManagedRoutes().     } }
false;private,synchronized;0;17;;private synchronized void startManagedRoutes() {     if (!isLeader()) {         return.     }     try {         for (Route route : stoppeddRoutes) {             LOGGER.debug("Starting route {}", route.getId()).             startRoute(route).             startedRoutes.add(route).         }         stoppeddRoutes.removeAll(startedRoutes).     } catch (Exception e) {         handleException(e).     } }
false;private,synchronized;0;17;;private synchronized void stopManagedRoutes() {     if (isLeader()) {         return.     }     try {         for (Route route : startedRoutes) {             LOGGER.debug("Stopping route {}", route.getId()).             stopRoute(route).             stoppeddRoutes.add(route).         }         startedRoutes.removeAll(stoppeddRoutes).     } catch (Exception e) {         handleException(e).     } }
false;public;0;4;;// ************************************************************************* // Getter/Setters // ************************************************************************* @ManagedAttribute(description = "Whether to stop route when starting up and failed to become master") public boolean isShouldStopRoute() {     return shouldStopRoute. }
false;public;1;3;;public void setShouldStopRoute(boolean shouldStopRoute) {     this.shouldStopRoute = shouldStopRoute. }
false;public;0;4;;@ManagedAttribute(description = "The lock map name") public String getLockMapName() {     return lockMapName. }
false;public;1;3;;public void setLockMapName(String lockMapName) {     this.lockMapName = lockMapName. }
false;public;0;4;;@ManagedAttribute(description = "The lock key") public String getLockKey() {     return lockKey. }
false;public;1;3;;public void setLockKey(String lockKey) {     this.lockKey = lockKey. }
false;public;0;4;;@ManagedAttribute(description = "The lock value") public String getLockValue() {     return lockValue. }
false;public;1;3;;public void setLockValue(String lockValue) {     this.lockValue = lockValue. }
false;public;0;4;;@ManagedAttribute(description = "The key lifespan for the lock") public long getLifespan() {     return lifespan. }
false;public;1;3;;public void setLifespan(long lifespan) {     this.lifespan = lifespan. }
false;public;2;4;;public void setLifespan(long lifespan, TimeUnit lifespanTimeUnit) {     this.lifespan = lifespan.     this.lifespanTimeUnit = lifespanTimeUnit. }
false;public;0;4;;@ManagedAttribute(description = "The key lifespan time unit for the lock") public TimeUnit getLifespanTimeUnit() {     return lifespanTimeUnit. }
false;public;1;3;;public void setLifespanTimeUnit(TimeUnit lifespanTimeUnit) {     this.lifespanTimeUnit = lifespanTimeUnit. }
false;public;0;4;;@ManagedAttribute(description = "Is this route the master or a slave") public boolean isLeader() {     return leader.get(). }
false;protected;0;5;;@Override protected void doStart() throws Exception {     this.future = executorService.scheduleAtFixedRate(this::run, 0, lifespan / 2, lifespanTimeUnit).     this.cache.addListener(this). }
false;protected;0;10;;@Override protected void doStop() throws Exception {     this.cache.removeListener(this).     this.cache.remove(lockKey, lockValue).     if (future != null) {         future.cancel(true).         future = null.     } }
false;public;0;28;;@Override public void run() {     if (!isRunAllowed()) {         return.     }     if (isLeader()) {         // I'm still the leader, so refresh the key so it does not expire.         if (!cache.replace(lockKey, lockValue, lockValue, lifespan, lifespanTimeUnit)) {             // Looks like I've lost the leadership.             setLeader(false).         }     }     if (!isLeader()) {         Object result = cache.putIfAbsent(lockKey, lockValue, lifespan, lifespanTimeUnit).         if (result == null) {             // Acquired the key so I'm the leader.             setLeader(true).         } else if (ObjectHelper.equal(lockValue, result) && !isLeader()) {             // Hey, I may have recovered from failure (or reboot was really             // fast) and my key was still there so yeah, I'm the leader again!             setLeader(true).         } else {             setLeader(false).         }     } }
false;public;1;6;;@CacheEntryRemoved public void onCacheEntryRemoved(CacheEntryEvent<Object, Object> event) {     if (ObjectHelper.equal(lockKey, event.getKey())) {         run().     } }
false;public;1;6;;@CacheEntryExpired public void onCacheEntryExpired(CacheEntryEvent<Object, Object> event) {     if (ObjectHelper.equal(lockKey, event.getKey())) {         run().     } }
false;protected;0;5;;@Override protected void doStart() throws Exception {     this.future = executorService.scheduleAtFixedRate(this::run, 0, lifespan / 2, lifespanTimeUnit).     this.cache.addClientListener(this). }
false;protected;0;13;;@Override protected void doStop() throws Exception {     this.cache.removeClientListener(this).     if (this.version != null) {         this.cache.removeWithVersion(lockKey, this.version).     }     if (future != null) {         future.cancel(true).         future = null.     } }
false;public;0;42;;@Override public void run() {     if (!isRunAllowed()) {         return.     }     if (isLeader() && version != null) {         LOGGER.debug("Lock refresh key={} with version={}", lockKey, version).         // I'm still the leader, so refresh the key so it does not expire.         if (!cache.replaceWithVersion(lockKey, lockValue, version, (int) lifespanTimeUnit.toSeconds(lifespan))) {             setLeader(false).         } else {             version = cache.getWithMetadata(lockKey).getVersion().             LOGGER.debug("Lock refreshed key={} with new version={}", lockKey, version).         }     }     if (!isLeader()) {         Object result = cache.putIfAbsent(lockKey, lockValue, lifespan, lifespanTimeUnit).         if (result == null) {             // Acquired the key so I'm the leader.             setLeader(true).             // Get the version             version = cache.getWithMetadata(lockKey).getVersion().             LOGGER.debug("Lock acquired key={} with version={}", lockKey, version).         } else if (ObjectHelper.equal(lockValue, result) && !isLeader()) {             // Hey, I may have recovered from failure (or reboot was really             // fast) and my key was still there so yeah, I'm the leader again!             setLeader(true).             // Get the version             version = cache.getWithMetadata(lockKey).getVersion().             LOGGER.debug("Lock resumed key={} with version={}", lockKey, version).         } else {             setLeader(false).         }     } }
false;public;1;6;;@ClientCacheEntryRemoved public void onCacheEntryRemoved(ClientCacheEntryRemovedEvent<String> event) {     if (ObjectHelper.equal(lockKey, event.getKey())) {         run().     } }
false;public;1;6;;@ClientCacheEntryExpired public void onCacheEntryExpired(ClientCacheEntryExpiredEvent<String> event) {     if (ObjectHelper.equal(lockKey, event.getKey())) {         run().     } }
false;public,static;1;6;;// ************************************************************************* // Helpers // ************************************************************************* public static InfinispanRoutePolicy withManager(BasicCacheContainer cacheContainer) {     InfinispanConfiguration conf = new InfinispanConfiguration().     conf.setCacheContainer(cacheContainer).     return new InfinispanRoutePolicy(conf). }
