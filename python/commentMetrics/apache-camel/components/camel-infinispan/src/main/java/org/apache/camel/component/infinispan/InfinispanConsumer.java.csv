commented;modifiers;parameterAmount;loc;comment;code
false;public;4;3;;public void processEvent(String eventType, boolean isPre, String cacheName, Object key) {     processEvent(eventType, isPre, cacheName, key, null). }
false;public;5;16;;public void processEvent(String eventType, boolean isPre, String cacheName, Object key, Object eventData) {     Exchange exchange = getEndpoint().createExchange().     exchange.getOut().setHeader(InfinispanConstants.EVENT_TYPE, eventType).     exchange.getOut().setHeader(InfinispanConstants.IS_PRE, isPre).     exchange.getOut().setHeader(InfinispanConstants.CACHE_NAME, cacheName).     exchange.getOut().setHeader(InfinispanConstants.KEY, key).     if (eventData != null) {         exchange.getOut().setHeader(InfinispanConstants.EVENT_DATA, eventData).     }     try {         getProcessor().process(exchange).     } catch (Exception e) {         LOGGER.error("Error processing event ", e).     } }
false;protected;0;30;;@Override protected void doStart() throws Exception {     super.doStart().     manager.start().     cache = manager.getCache(cacheName).     if (configuration.hasQueryBuilder()) {         if (InfinispanUtil.isRemote(cache)) {             RemoteCache<Object, Object> remoteCache = InfinispanUtil.asRemote(cache).             Query query = InfinispanRemoteOperation.buildQuery(configuration.getQueryBuilder(), remoteCache).             continuousQuery = Search.getContinuousQuery(remoteCache).             continuousQuery.addContinuousQueryListener(query, new ContinuousQueryEventListener(cache.getName())).         } else {             throw new IllegalArgumentException("Can't run continuous queries against embedded cache (" + cache.getName() + ")").         }     } else {         if (manager.isCacheContainerEmbedded()) {             consumerHandler = InfinispanConsumerEmbeddedHandler.INSTANCE.         } else if (manager.isCacheContainerRemote()) {             consumerHandler = InfinispanConsumerRemoteHandler.INSTANCE.         } else {             throw new UnsupportedOperationException("Unsupported CacheContainer type " + manager.getCacheContainer().getClass().getName()).         }         listener = consumerHandler.start(this).     } }
false;protected;0;13;;@Override protected void doStop() throws Exception {     if (continuousQuery != null) {         continuousQuery.removeAllListeners().     }     if (consumerHandler != null) {         consumerHandler.stop(this).     }     manager.stop().     super.doStop(). }
false;public;0;3;;public BasicCache<Object, Object> getCache() {     return cache. }
false;public;0;3;;public InfinispanEventListener getListener() {     return listener. }
false;public;0;3;;public InfinispanConfiguration getConfiguration() {     return configuration. }
false;public;2;4;;@Override public void resultJoining(Object key, Object value) {     processEvent(InfinispanConstants.CACHE_ENTRY_JOINING, false, cacheName, key, value). }
false;public;2;4;;@Override public void resultUpdated(Object key, Object value) {     processEvent(InfinispanConstants.CACHE_ENTRY_UPDATED, false, cacheName, key, value). }
false;public;1;4;;@Override public void resultLeaving(Object key) {     processEvent(InfinispanConstants.CACHE_ENTRY_LEAVING, false, cacheName, key). }
