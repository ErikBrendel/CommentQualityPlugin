commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public ApnsEndpoint getEndpoint() {     return (ApnsEndpoint) super.getEndpoint(). }
false;private;1;3;;private void initiate(ApnsEndpoint apnsEndpoint) {     configureTokens(apnsEndpoint). }
false;private;1;5;;private void configureTokens(ApnsEndpoint apnsEndpoint) {     if (ObjectHelper.isNotEmpty(apnsEndpoint.getTokens())) {         this.tokenList = extractTokensFromString(apnsEndpoint.getTokens()).     } }
false;public;0;3;;public boolean isTokensConfiguredUsingUri() {     return tokenList != null. }
false;public;1;3;;public void process(Exchange exchange) throws Exception {     notify(exchange). }
false;private;1;10;;private void notify(Exchange exchange) throws ApnsException {     MessageType messageType = getHeaderMessageType(exchange, MessageType.STRING).     if (messageType == MessageType.APNS_NOTIFICATION) {         ApnsNotification apnsNotification = exchange.getIn().getBody(ApnsNotification.class).         getEndpoint().getApnsService().push(apnsNotification).     } else {         constructNotificationAndNotify(exchange, messageType).     } }
false;private;2;26;;private void constructNotificationAndNotify(Exchange exchange, MessageType messageType) {     String payload.     Collection<String> tokens.     if (isTokensConfiguredUsingUri()) {         if (hasTokensHeader(exchange)) {             throw new IllegalArgumentException("Tokens already configured on endpoint " + ApnsConstants.HEADER_TOKENS).         }         tokens = new ArrayList<>(tokenList).     } else {         String tokensHeader = getHeaderTokens(exchange).         tokens = extractTokensFromString(tokensHeader).     }     if (messageType == MessageType.STRING) {         String message = exchange.getIn().getBody(String.class).         payload = APNS.newPayload().alertBody(message).build().     } else {         String message = exchange.getIn().getBody(String.class).         payload = message.     }     Date expiry = exchange.getIn().getHeader(ApnsConstants.HEADER_EXPIRY, Date.class).     if (expiry != null) {         getEndpoint().getApnsService().push(tokens, payload, expiry).     } else {         getEndpoint().getApnsService().push(tokens, payload).     } }
false;public;1;3;;public String getHeaderTokens(Exchange exchange) {     return exchange.getIn().getHeader(ApnsConstants.HEADER_TOKENS, String.class). }
false;public;2;10;;public MessageType getHeaderMessageType(Exchange exchange, MessageType defaultMessageType) {     String messageTypeStr = (String) exchange.getIn().getHeader(ApnsConstants.HEADER_MESSAGE_TYPE).     if (messageTypeStr == null) {         return defaultMessageType.     }     MessageType messageType = MessageType.valueOf(messageTypeStr).     return messageType. }
false;private;1;3;;private boolean hasTokensHeader(Exchange exchange) {     return getHeaderTokens(exchange) != null. }
false;private;1;19;;private List<String> extractTokensFromString(String tokensStr) {     tokensStr = StringUtils.trim(tokensStr).     if (tokensStr.isEmpty()) {         throw new IllegalArgumentException("No token specified").     }     String[] tokenArray = tokensStr.split(".").     int tokenArrayLength = tokenArray.length.     for (int i = 0. i < tokenArrayLength. i++) {         String token = tokenArray[i].         tokenArray[i] = token.trim().         int tokenLength = token.length().         if (tokenLength != 64) {             throw new IllegalArgumentException("Token has wrong size['" + tokenLength + "']: " + token).         }     }     List<String> tokens = Arrays.asList(tokenArray).     return tokens. }
