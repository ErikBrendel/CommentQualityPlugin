commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;public Producer createProducer() throws Exception {     ObjectHelper.notNull(component, "component").     CometdProducer producer = new CometdProducer(this).     return producer. }
false;public;1;6;;public Consumer createConsumer(Processor processor) throws Exception {     ObjectHelper.notNull(component, "component").     CometdConsumer consumer = new CometdConsumer(this, processor).     configureConsumer(consumer).     return consumer. }
false;public;1;3;;public void connect(CometdProducerConsumer prodcons) throws Exception {     component.connect(prodcons). }
false;public;1;3;;public void disconnect(CometdProducerConsumer prodcons) throws Exception {     component.disconnect(prodcons). }
false;public;0;3;;public CometdComponent getComponent() {     return component. }
false;public;0;3;;public boolean isSingleton() {     return true. }
false;public;0;3;;public String getPath() {     return uri.getPath(). }
false;public;0;10;;public int getPort() {     if (uri.getPort() == -1) {         if ("cometds".equals(getProtocol())) {             return 443.         } else {             return 80.         }     }     return uri.getPort(). }
false;public;0;3;;public String getProtocol() {     return uri.getScheme(). }
false;public;0;3;;public URI getUri() {     return uri. }
false;public;0;3;;public String getBaseResource() {     return baseResource. }
true;public;1;3;/**  * The root directory for the web resources or classpath. Use the protocol file: or classpath: depending  * if you want that the component loads the resource from file system or classpath.  * Classpath is required for OSGI deployment where the resources are packaged in the jar  */ ;/**  * The root directory for the web resources or classpath. Use the protocol file: or classpath: depending  * if you want that the component loads the resource from file system or classpath.  * Classpath is required for OSGI deployment where the resources are packaged in the jar  */ public void setBaseResource(String baseResource) {     this.baseResource = baseResource. }
false;public;0;3;;public int getTimeout() {     return timeout. }
true;public;1;3;/**  * The server side poll timeout in milliseconds. This is how long the server will hold a reconnect request before responding.  */ ;/**  * The server side poll timeout in milliseconds. This is how long the server will hold a reconnect request before responding.  */ public void setTimeout(int timeout) {     this.timeout = timeout. }
false;public;0;3;;public int getInterval() {     return interval. }
true;public;1;3;/**  * The client side poll timeout in milliseconds. How long a client will wait between reconnects  */ ;/**  * The client side poll timeout in milliseconds. How long a client will wait between reconnects  */ public void setInterval(int interval) {     this.interval = interval. }
false;public;0;3;;public int getMaxInterval() {     return maxInterval. }
true;public;1;3;/**  * The max client side poll timeout in milliseconds. A client will be removed if a connection is not received in this time.  */ ;/**  * The max client side poll timeout in milliseconds. A client will be removed if a connection is not received in this time.  */ public void setMaxInterval(int maxInterval) {     this.maxInterval = maxInterval. }
false;public;0;3;;public int getMultiFrameInterval() {     return multiFrameInterval. }
true;public;1;3;/**  * The client side poll timeout, if multiple connections are detected from the same browser.  */ ;/**  * The client side poll timeout, if multiple connections are detected from the same browser.  */ public void setMultiFrameInterval(int multiFrameInterval) {     this.multiFrameInterval = multiFrameInterval. }
false;public;0;3;;public boolean isJsonCommented() {     return jsonCommented. }
true;public;1;3;/**  * If true, the server will accept JSON wrapped in a comment and will generate JSON wrapped in a comment. This is a defence against Ajax Hijacking.  */ ;/**  * If true, the server will accept JSON wrapped in a comment and will generate JSON wrapped in a comment. This is a defence against Ajax Hijacking.  */ public void setJsonCommented(boolean commented) {     jsonCommented = commented. }
true;public;1;3;/**  * Whether to include the server session headers in the Camel message when creating a Camel Message for incoming requests.  */ ;/**  * Whether to include the server session headers in the Camel message when creating a Camel Message for incoming requests.  */ public void setSessionHeadersEnabled(boolean enable) {     this.sessionHeadersEnabled = enable. }
false;public;0;3;;public boolean isSessionHeadersEnabled() {     return sessionHeadersEnabled. }
false;public;0;3;;public int getLogLevel() {     return logLevel. }
true;public;1;3;/**  * Logging level. 0=none, 1=info, 2=debug.  */ ;/**  * Logging level. 0=none, 1=info, 2=debug.  */ public void setLogLevel(int logLevel) {     this.logLevel = logLevel. }
false;public;0;3;;public String getAllowedOrigins() {     return allowedOrigins. }
true;public;1;3;/**  * The origins domain that support to cross, if the crosssOriginFilterOn is true  */ ;/**  * The origins domain that support to cross, if the crosssOriginFilterOn is true  */ public void setAllowedOrigins(String allowedOrigins) {     this.allowedOrigins = allowedOrigins. }
false;public;0;3;;public boolean isCrossOriginFilterOn() {     return crossOriginFilterOn. }
true;public;1;3;/**  * If true, the server will support for cross-domain filtering  */ ;/**  * If true, the server will support for cross-domain filtering  */ public void setCrossOriginFilterOn(boolean crossOriginFilterOn) {     this.crossOriginFilterOn = crossOriginFilterOn. }
false;public;0;3;;public String getFilterPath() {     return filterPath. }
true;public;1;3;/**  * The filterPath will be used by the CrossOriginFilter, if the crosssOriginFilterOn is true  */ ;/**  * The filterPath will be used by the CrossOriginFilter, if the crosssOriginFilterOn is true  */ public void setFilterPath(String filterPath) {     this.filterPath = filterPath. }
false;public;0;3;;public boolean isDisconnectLocalSession() {     return disconnectLocalSession. }
true;public;1;3;/**  * Whether to disconnect local sessions after publishing a message to its channel.  * Disconnecting local session is needed as they are not swept by default by CometD, and therefore you can run out of memory.  */ ;/**  * Whether to disconnect local sessions after publishing a message to its channel.  * Disconnecting local session is needed as they are not swept by default by CometD, and therefore you can run out of memory.  */ public void setDisconnectLocalSession(boolean disconnectLocalSession) {     this.disconnectLocalSession = disconnectLocalSession. }
