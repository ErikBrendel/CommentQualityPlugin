commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String current() {     return stack.peek(). }
false;public;2;3;;public String enumTypeName(final String sObjectName, final String name) {     return sObjectName + "_" + (name.endsWith("__c") ? name.substring(0, name.length() - 3) : name) + "Enum". }
false;public;1;3;;public List<SObjectField> externalIdsOf(final String name) {     return descriptions.externalIdsOf(name). }
false;public;1;21;;public String getEnumConstant(final String value) {     // TODO add support for supplementary characters     final StringBuilder result = new StringBuilder().     boolean changed = false.     if (!Character.isJavaIdentifierStart(value.charAt(0))) {         result.append("_").         changed = true.     }     for (final char c : value.toCharArray()) {         if (Character.isJavaIdentifierPart(c)) {             result.append(c).         } else {             // replace non Java identifier character with '_'             result.append('_').             changed = true.         }     }     return changed ? result.toString().toUpperCase() : value.toUpperCase(). }
false;public;2;46;;public String getFieldType(final SObjectDescription description, final SObjectField field) {     // check if this is a picklist     if (isPicklist(field)) {         if (Boolean.TRUE.equals(useStringsForPicklists)) {             if (picklistsEnumToSObject.containsKey(description.getName()) && picklistsEnumToSObject.get(description.getName()).contains(field.getName())) {                 return enumTypeName(description.getName(), field.getName()).             }             return String.class.getName().         } else if (picklistsStringToSObject.containsKey(description.getName()) && picklistsStringToSObject.get(description.getName()).contains(field.getName())) {             return String.class.getName().         }         // the SObject class         return enumTypeName(description.getName(), field.getName()).     } else if (isMultiSelectPicklist(field)) {         if (Boolean.TRUE.equals(useStringsForPicklists)) {             if (picklistsEnumToSObject.containsKey(description.getName()) && picklistsEnumToSObject.get(description.getName()).contains(field.getName())) {                 return enumTypeName(description.getName(), field.getName()) + "[]".             }             return String.class.getName() + "[]".         } else if (picklistsStringToSObject.containsKey(description.getName()) && picklistsStringToSObject.get(description.getName()).contains(field.getName())) {             return String.class.getName() + "[]".         }         // generating the SObject class         return enumTypeName(description.getName(), field.getName()) + "[]".     } else {         // map field to Java type         final String soapType = field.getSoapType().         final String lookupType = soapType.substring(soapType.indexOf(':') + 1).         final String type = types.get(lookupType).         if (type == null) {             getLog().warn(String.format("Unsupported field type `%s` in field `%s` of object `%s`", soapType, field.getName(), description.getName())).             getLog().debug("Currently known types:\n " + types.entrySet().stream().map(e -> e.getKey() + "=" + e.getValue()).collect(Collectors.joining("\n"))).         }         return type.     } }
false;public;1;3;;public String getLookupRelationshipName(final SObjectField field) {     return StringHelper.notEmpty(field.getRelationshipName(), "relationshipName", field.getName()). }
false;public;1;17;;public List<PickListValue> getUniqueValues(final SObjectField field) {     if (field.getPicklistValues().isEmpty()) {         return field.getPicklistValues().     }     final List<PickListValue> result = new ArrayList<>().     final Set<String> literals = new HashSet<>().     for (final PickListValue listValue : field.getPicklistValues()) {         final String value = listValue.getValue().         if (!literals.contains(value)) {             literals.add(value).             result.add(listValue).         }     }     literals.clear().     Collections.sort(result, (o1, o2) -> o1.getValue().compareTo(o2.getValue())).     return result. }
false;public;1;3;;public boolean hasExternalIds(final String name) {     return descriptions.hasExternalIds(name). }
false;public;1;8;;public boolean hasMultiSelectPicklists(final SObjectDescription desc) {     for (final SObjectField field : desc.getFields()) {         if (isMultiSelectPicklist(field)) {             return true.         }     }     return false. }
false;public;1;8;;public boolean hasPicklists(final SObjectDescription desc) {     for (final SObjectField field : desc.getFields()) {         if (isPicklist(field)) {             return true.         }     }     return false. }
false;public;2;3;;public boolean includeList(final List<?> list, final String propertyName) {     return !list.isEmpty() && !BLACKLISTED_PROPERTIES.contains(propertyName). }
false;public;1;4;;public boolean isBlobField(final SObjectField field) {     final String soapType = field.getSoapType().     return BASE64BINARY.equals(soapType.substring(soapType.indexOf(':') + 1)). }
false;public;1;3;;public boolean isExternalId(final SObjectField field) {     return field.isExternalId(). }
false;public;1;3;;public boolean isLookup(final SObjectField field) {     return "reference".equals(field.getType()). }
false;public;1;3;;public boolean isMultiSelectPicklist(final SObjectField field) {     return MULTIPICKLIST.equals(field.getType()). }
false;public;1;3;;public boolean isPicklist(final SObjectField field) {     return PICKLIST.equals(field.getType()). }
false;public;1;15;;public boolean isPrimitiveOrBoxed(final Object object) {     final Class<?> clazz = object.getClass().     final boolean isWholeNumberWrapper = Byte.class.equals(clazz) || Short.class.equals(clazz) || Integer.class.equals(clazz) || Long.class.equals(clazz).     final boolean isFloatingPointWrapper = Double.class.equals(clazz) || Float.class.equals(clazz).     final boolean isWrapper = isWholeNumberWrapper || isFloatingPointWrapper || Boolean.class.equals(clazz) || Character.class.equals(clazz).     final boolean isPrimitive = clazz.isPrimitive().     return isPrimitive || isWrapper. }
false;public;1;3;;public boolean notBaseField(final String name) {     return !BASE_FIELDS.contains(name). }
false;public;1;3;;public boolean notNull(final Object val) {     return val != null. }
false;public;0;3;;public void pop() {     stack.pop(). }
false;public;1;13;;public Set<Map.Entry<String, Object>> propertiesOf(final Object object) {     final Map<String, Object> properties = new TreeMap<>().     IntrospectionSupport.getProperties(object, properties, null, false).     final Function<Map.Entry<String, Object>, String> keyMapper = e -> StringUtils.capitalize(e.getKey()).     final Function<Map.Entry<String, Object>, Object> valueMapper = Map.Entry::getValue.     final BinaryOperator<Object> mergeFunction = (u, v) -> {         throw new IllegalStateException(String.format("Duplicate key %s", u)).     }.     final Supplier<Map<String, Object>> mapSupplier = LinkedHashMap::new.     return properties.entrySet().stream().collect(Collectors.toMap(keyMapper, valueMapper, mergeFunction, mapSupplier)).entrySet(). }
false;public;1;3;;public void push(final String additional) {     stack.push(additional). }
false;public;1;5;;public void start(final String initial) {     stack = new Stack<>().     stack.push(initial).     varNames.clear(). }
false;public;1;11;;public String variableName(final String given) {     final String base = StringUtils.uncapitalize(given).     AtomicInteger counter = varNames.get(base).     if (counter == null) {         counter = new AtomicInteger(0).         varNames.put(base, counter).     }     return base + counter.incrementAndGet(). }
false;;0;3;;void parsePicklistToEnums() {     parsePicklistOverrideArgs(picklistToEnums, picklistsEnumToSObject). }
false;;0;3;;void parsePicklistToStrings() {     parsePicklistOverrideArgs(picklistToStrings, picklistsStringToSObject). }
false;;3;107;;void processDescription(final File pkgDir, final SObjectDescription description, final GeneratorUtility utility) throws IOException {     useStringsForPicklists = useStringsForPicklists == null ? Boolean.FALSE : useStringsForPicklists.     parsePicklistToEnums().     parsePicklistToStrings().     // generate a source file for SObject     final VelocityContext context = new VelocityContext().     context.put("packageName", packageName).     context.put("utility", utility).     context.put("esc", StringEscapeUtils.class).     context.put("desc", description).     context.put("useStringsForPicklists", useStringsForPicklists).     final String pojoFileName = description.getName() + JAVA_EXT.     final File pojoFile = new File(pkgDir, pojoFileName).     context.put("descriptions", descriptions).     try (final Writer writer = new OutputStreamWriter(new FileOutputStream(pojoFile), StandardCharsets.UTF_8)) {         final Template pojoTemplate = engine.getTemplate(SOBJECT_POJO_VM, UTF_8).         pojoTemplate.merge(context, writer).     }     if (useOptionals) {         final String optionalFileName = description.getName() + "Optional" + JAVA_EXT.         final File optionalFile = new File(pkgDir, optionalFileName).         try (final Writer writer = new OutputStreamWriter(new FileOutputStream(optionalFile), StandardCharsets.UTF_8)) {             final Template optionalTemplate = engine.getTemplate(SOBJECT_POJO_OPTIONAL_VM, UTF_8).             optionalTemplate.merge(context, writer).         }     }     // generate ExternalIds Lookup class for all lookup fields that point to     // an Object that has at least one externalId     final Set<String> generatedLookupObjects = new HashSet<>().     for (final SObjectField field : description.getFields()) {         if (!utility.isLookup(field)) {             continue.         }         for (final String reference : field.getReferenceTo()) {             final List<SObjectField> externalIds = descriptions.externalIdsOf(reference).             final String lookupClassName = reference + "_Lookup".             if (generatedLookupObjects.contains(lookupClassName)) {                 continue.             }             for (final SObjectField externalId : externalIds) {                 generatedLookupObjects.add(lookupClassName).                 final String lookupClassFileName = lookupClassName + JAVA_EXT.                 final File lookupClassFile = new File(pkgDir, lookupClassFileName).                 context.put("field", externalId).                 context.put("lookupRelationshipName", field.getRelationshipName()).                 context.put("lookupType", lookupClassName).                 context.put("externalIdsList", externalIds).                 context.put("lookupClassName", lookupClassName).                 try (final Writer writer = new OutputStreamWriter(new FileOutputStream(lookupClassFile), StandardCharsets.UTF_8)) {                     final Template lookupClassTemplate = engine.getTemplate(SOBJECT_LOOKUP_VM, UTF_8).                     lookupClassTemplate.merge(context, writer).                 }             }         }     }     // write required Enumerations for any picklists     for (final SObjectField field : description.getFields()) {         if (utility.isPicklist(field) || utility.isMultiSelectPicklist(field)) {             final String enumName = utility.enumTypeName(description.getName(), field.getName()).             final String enumFileName = enumName + JAVA_EXT.             final File enumFile = new File(pkgDir, enumFileName).             context.put("field", field).             context.put("enumName", enumName).             final Template enumTemplate = engine.getTemplate(SOBJECT_PICKLIST_VM, UTF_8).             try (final Writer writer = new OutputStreamWriter(new FileOutputStream(enumFile), StandardCharsets.UTF_8)) {                 enumTemplate.merge(context, writer).             }         }     }     // write the QueryRecords class     final String queryRecordsFileName = "QueryRecords" + description.getName() + JAVA_EXT.     final File queryRecordsFile = new File(pkgDir, queryRecordsFileName).     final Template queryTemplate = engine.getTemplate(SOBJECT_QUERY_RECORDS_VM, UTF_8).     try (final Writer writer = new OutputStreamWriter(new FileOutputStream(queryRecordsFile), StandardCharsets.UTF_8)) {         queryTemplate.merge(context, writer).     }     if (useOptionals) {         // write the QueryRecords Optional class         final String queryRecordsOptionalFileName = "QueryRecords" + description.getName() + "Optional" + JAVA_EXT.         final File queryRecordsOptionalFile = new File(pkgDir, queryRecordsOptionalFileName).         final Template queryRecordsOptionalTemplate = engine.getTemplate(SOBJECT_QUERY_RECORDS_OPTIONAL_VM, UTF_8).         try (final Writer writer = new OutputStreamWriter(new FileOutputStream(queryRecordsOptionalFile), StandardCharsets.UTF_8)) {             queryRecordsOptionalTemplate.merge(context, writer).         }     } }
false;protected;1;45;;@Override protected void executeWithClient(final RestClient client) throws MojoExecutionException {     descriptions = new ObjectDescriptions(client, getResponseTimeout(), includes, includePattern, excludes, excludePattern, getLog()).     engine = createVelocityEngine().     // make sure we can load both templates     if (!engine.resourceExists(SOBJECT_POJO_VM) || !engine.resourceExists(SOBJECT_QUERY_RECORDS_VM) || !engine.resourceExists(SOBJECT_POJO_OPTIONAL_VM) || !engine.resourceExists(SOBJECT_QUERY_RECORDS_OPTIONAL_VM)) {         throw new MojoExecutionException("Velocity templates not found").     }     // validate package name     if (!packageName.matches(PACKAGE_NAME_PATTERN)) {         throw new MojoExecutionException("Invalid package name " + packageName).     }     if (outputDirectory.getAbsolutePath().contains("$")) {         outputDirectory = new File("generated-sources/camel-salesforce").     }     final File pkgDir = new File(outputDirectory, packageName.trim().replace('.', File.separatorChar)).     if (!pkgDir.exists()) {         if (!pkgDir.mkdirs()) {             throw new MojoExecutionException("Unable to create " + pkgDir).         }     }     getLog().info("Generating Java Classes...").     // generate POJOs for every object description     final GeneratorUtility utility = new GeneratorUtility().     for (final SObjectDescription description : descriptions.fetched()) {         if (Defaults.IGNORED_OBJECTS.contains(description.getName())) {             continue.         }         try {             processDescription(pkgDir, description, utility).         } catch (final IOException e) {             throw new MojoExecutionException("Unable to generate source files for: " + description.getName(), e).         }     }     getLog().info(String.format("Successfully generated %s Java Classes", descriptions.count() * 2)). }
false;protected;0;6;;@Override protected void setup() {     if (customTypes != null) {         types.putAll(customTypes).     } }
false;static;0;10;;static VelocityEngine createVelocityEngine() {     // initialize velocity to load resources from class loader and use Log4J     final Properties velocityProperties = new Properties().     velocityProperties.setProperty(RuntimeConstants.RESOURCE_LOADER, "cloader").     velocityProperties.setProperty("cloader.resource.loader.class", ClasspathResourceLoader.class.getName()).     velocityProperties.setProperty(RuntimeConstants.RUNTIME_LOG_NAME, LOG.getName()).     final VelocityEngine engine = new VelocityEngine(velocityProperties).     return engine. }
false;private,static;0;8;;private static Set<String> defineBaseFields() {     final Set<String> baseFields = new HashSet<>().     for (final Field field : AbstractSObjectBase.class.getDeclaredFields()) {         baseFields.add(field.getName()).     }     return baseFields. }
false;private,static;0;41;;private static Map<String, String> defineLookupMap() {     // create a type map     // using JAXB mapping, for the most part     // mapping for tns:ID SOAPtype     final String[][] typeMap = new String[][] { //      { "ID", "String" }, //      { "string", "String" }, //      { "integer", "java.math.BigInteger" }, //      { "int", "Integer" }, //      { "long", "Long" }, //      { "short", "Short" }, //      { "decimal", "java.math.BigDecimal" }, //      { "float", "Float" }, //      { "double", "Double" }, //      { "boolean", "Boolean" }, //      { "byte", "Byte" }, //      { "base64Binary", "String" }, //      { "unsignedInt", "Long" }, //      { "unsignedShort", "Integer" }, //      { "unsignedByte", "Short" }, //      { "dateTime", "java.time.ZonedDateTime" }, //      { "time", "java.time.OffsetTime" }, //      { "date", "java.time.LocalDate" }, //      { "g", "java.time.ZonedDateTime" }, //      { "anyType", "String" }, //      { "address", "org.apache.camel.component.salesforce.api.dto.Address" }, //      { "location", "org.apache.camel.component.salesforce.api.dto.GeoLocation" }, //      { "RelationshipReferenceTo", "String" } }.     final Map<String, String> lookupMap = new HashMap<>().     for (final String[] entry : typeMap) {         lookupMap.put(entry[0], entry[1]).     }     return Collections.unmodifiableMap(lookupMap). }
false;private,static;2;15;;private static void parsePicklistOverrideArgs(final String[] picklists, final Map<String, Set<String>> picklistsToSObject) {     if (picklists != null && picklists.length > 0) {         String[] strings.         for (final String picklist : picklists) {             if (!FIELD_DEFINITION_PATTERN.matcher(picklist).matches()) {                 throw new IllegalArgumentException("Invalid format provided for picklistFieldToEnum value - allowed format SObjectName.FieldName").             }             strings = picklist.split("\\.").             picklistsToSObject.putIfAbsent(strings[0], new HashSet<>()).             picklistsToSObject.get(strings[0]).add(strings[1]).         }     } }
