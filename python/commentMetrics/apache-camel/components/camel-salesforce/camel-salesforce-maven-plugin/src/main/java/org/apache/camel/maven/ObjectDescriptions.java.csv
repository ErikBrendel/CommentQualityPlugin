commented;modifiers;parameterAmount;loc;comment;code
false;;0;3;;int count() {     return descriptions.size(). }
false;;1;3;;SObjectDescription descriptionOf(final String name) {     return descriptions.computeIfAbsent(name, this::fetchDescriptionOf). }
false;;1;3;;List<SObjectField> externalIdsOf(final String name) {     return descriptionOf(name).getFields().stream().filter(SObjectField::isExternalId).collect(Collectors.toList()). }
false;;1;3;;boolean hasExternalIds(final String name) {     return descriptionOf(name).getFields().stream().anyMatch(SObjectField::isExternalId). }
false;;0;3;;Iterable<SObjectDescription> fetched() {     return descriptions.values(). }
false;private;1;24;;private SObjectDescription fetchDescriptionOf(final String name) {     try {         final ObjectMapper mapper = JsonUtils.createObjectMapper().         final SyncResponseCallback callback = new SyncResponseCallback().         client.getDescription(name, Collections.emptyMap(), callback).         if (!callback.await(responseTimeout, TimeUnit.MILLISECONDS)) {             throw new MojoExecutionException("Timeout waiting for getDescription for sObject " + name).         }         final SalesforceException ex = callback.getException().         if (ex != null) {             throw ex.         }         final SObjectDescription description = mapper.readValue(callback.getResponse(), SObjectDescription.class).         // for CAMEL-11310         return description.prune().     } catch (final Exception e) {         throw new IllegalStateException("Error getting SObject description for '" + name + "': " + e.getMessage(), e).     } }
false;private;5;44;;private void fetchSpecifiedDescriptions(final String[] includes, final String includePattern, final String[] excludes, final String excludePattern, final Log log) throws MojoExecutionException {     // use Jackson json     final ObjectMapper mapper = JsonUtils.createObjectMapper().     // call getGlobalObjects to get all SObjects     final Set<String> objectNames = new TreeSet<>().     final SyncResponseCallback callback = new SyncResponseCallback().     try {         log.info("Getting Salesforce Objects...").         client.getGlobalObjects(Collections.emptyMap(), callback).         if (!callback.await(responseTimeout, TimeUnit.MILLISECONDS)) {             throw new MojoExecutionException("Timeout waiting for getGlobalObjects!").         }         final SalesforceException ex = callback.getException().         if (ex != null) {             throw ex.         }         final GlobalObjects globalObjects = mapper.readValue(callback.getResponse(), GlobalObjects.class).         // create a list of object names         for (final SObject sObject : globalObjects.getSobjects()) {             objectNames.add(sObject.getName()).         }     } catch (final Exception e) {         throw new MojoExecutionException("Error getting global Objects: " + e.getMessage(), e).     }     // check if we are generating POJOs for all objects or not     if (includes != null && includes.length > 0 || excludes != null && excludes.length > 0 || ObjectHelper.isNotEmpty(includePattern) || ObjectHelper.isNotEmpty(excludePattern)) {         filterObjectNames(objectNames, includes, includePattern, excludes, excludePattern, log).     } else {         log.warn(String.format("Generating Java classes for all %s Objects, this may take a while...", objectNames.size())).     }     log.info("Retrieving Object descriptions...").     for (final String name : objectNames) {         descriptionOf(name).     } }
false;private,static;6;62;;private static void filterObjectNames(final Set<String> objectNames, final String[] includes, final String includePattern, final String[] excludes, final String excludePattern, final Log log) throws MojoExecutionException {     log.info("Looking for matching Object names...").     // create a list of accepted names     final Set<String> includedNames = new HashSet<>().     if (includes != null && includes.length > 0) {         for (String name : includes) {             name = name.trim().             if (name.isEmpty()) {                 throw new MojoExecutionException("Invalid empty name in includes").             }             includedNames.add(name).         }     }     final Set<String> excludedNames = new HashSet<>().     if (excludes != null && excludes.length > 0) {         for (String name : excludes) {             name = name.trim().             if (name.isEmpty()) {                 throw new MojoExecutionException("Invalid empty name in excludes").             }             excludedNames.add(name).         }     }     // check whether a pattern is in effect     Pattern incPattern.     if (includePattern != null && !includePattern.trim().isEmpty()) {         incPattern = Pattern.compile(includePattern.trim()).     } else if (includedNames.isEmpty()) {         // include everything by default if no include names are set         incPattern = Defaults.MATCH_EVERYTHING_PATTERN.     } else {         // include nothing by default if include names are set         incPattern = Defaults.MATCH_NOTHING_PATTERN.     }     // check whether a pattern is in effect     Pattern excPattern.     if (excludePattern != null && !excludePattern.trim().isEmpty()) {         excPattern = Pattern.compile(excludePattern.trim()).     } else {         // exclude nothing by default         excPattern = Defaults.MATCH_NOTHING_PATTERN.     }     final Set<String> acceptedNames = new HashSet<>().     for (final String name : objectNames) {         // and is not excluded and does not match exclude pattern         if ((includedNames.contains(name) || incPattern.matcher(name).matches()) && !excludedNames.contains(name) && !excPattern.matcher(name).matches()) {             acceptedNames.add(name).         }     }     objectNames.clear().     objectNames.addAll(acceptedNames).     log.info(String.format("Found %s matching Objects", objectNames.size())). }
