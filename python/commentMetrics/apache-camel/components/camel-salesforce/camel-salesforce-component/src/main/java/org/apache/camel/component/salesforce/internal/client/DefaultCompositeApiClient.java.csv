commented;modifiers;parameterAmount;loc;comment;code
false;public;3;16;;@Override public void submitComposite(final SObjectComposite composite, final Map<String, List<String>> headers, final ResponseCallback<SObjectCompositeResponse> callback) throws SalesforceException {     // composite interface supports only json payload     checkCompositeFormat(format, SObjectComposite.REQUIRED_PAYLOAD_FORMAT).     final String url = versionUrl() + "composite".     final Request post = createRequest(HttpMethod.POST, url, headers).     final ContentProvider content = serialize(NO_XSTREAM, composite, composite.objectTypes()).     post.content(content).     doHttpRequest(post, (response, responseHeaders, exception) -> callback.onResponse(tryToReadResponse(NO_XSTREAM, SObjectCompositeResponse.class, response), responseHeaders, exception)). }
false;public;3;17;;@Override public void submitCompositeBatch(final SObjectBatch batch, final Map<String, List<String>> headers, final ResponseCallback<SObjectBatchResponse> callback) throws SalesforceException {     checkCompositeBatchVersion(version, batch.getVersion()).     final String url = versionUrl() + "composite/batch".     final Request post = createRequest(HttpMethod.POST, url, headers).     final ContentProvider content = serialize(xStreamCompositeBatch, batch, batch.objectTypes()).     post.content(content).     doHttpRequest(post, (response, responseHeaders, exception) -> callback.onResponse(tryToReadResponse(xStreamCompositeBatch, SObjectBatchResponse.class, response), responseHeaders, exception)). }
false;public;3;15;;@Override public void submitCompositeTree(final SObjectTree tree, final Map<String, List<String>> headers, final ResponseCallback<SObjectTreeResponse> callback) throws SalesforceException {     final String url = versionUrl() + "composite/tree/" + tree.getObjectType().     final Request post = createRequest(HttpMethod.POST, url, headers).     final ContentProvider content = serialize(xStreamCompositeTree, tree, tree.objectTypes()).     post.content(content).     doHttpRequest(post, (response, responseHeaders, exception) -> callback.onResponse(tryToReadResponse(xStreamCompositeTree, SObjectTreeResponse.class, response), responseHeaders, exception)). }
false;;3;19;;Request createRequest(final HttpMethod method, final String url, final Map<String, List<String>> headers) {     final Request request = getRequest(method, url, headers).     // setup authorization     setAccessToken(request).     if (format == PayloadFormat.JSON) {         request.header(HttpHeader.CONTENT_TYPE, APPLICATION_JSON_UTF8).         request.header(HttpHeader.ACCEPT, APPLICATION_JSON_UTF8).     } else {         // must be XML         request.header(HttpHeader.CONTENT_TYPE, APPLICATION_XML_UTF8).         request.header(HttpHeader.ACCEPT, APPLICATION_XML_UTF8).     }     request.header(HttpHeader.ACCEPT_CHARSET, StringUtil.__UTF8).     return request. }
false;;2;3;;<T> T fromJson(final Class<T> expectedType, final InputStream responseStream) throws IOException {     return jsonReaderFor(expectedType).readValue(responseStream). }
false;;1;3;;ObjectReader jsonReaderFor(final Class<?> type) {     return Optional.ofNullable(readers.get(type)).orElseGet(() -> mapper.readerFor(type)). }
false;;1;5;;ObjectWriter jsonWriterFor(final Object obj) {     final Class<?> type = obj.getClass().     return Optional.ofNullable(writers.get(type)).orElseGet(() -> mapper.writerFor(type)). }
false;;3;11;;ContentProvider serialize(final XStream xstream, final Object body, final Class<?>... additionalTypes) throws SalesforceException {     // input stream as entity content is needed for authentication retries     if (format == PayloadFormat.JSON) {         return new InputStreamContentProvider(toJson(body)).     }     // must be XML     xstream.processAnnotations(additionalTypes).     return new InputStreamContentProvider(toXml(xstream, body)). }
false;;0;3;;String servicesDataUrl() {     return instanceUrl + "/services/data/". }
false;;1;10;;InputStream toJson(final Object obj) throws SalesforceException {     byte[] jsonBytes.     try {         jsonBytes = jsonWriterFor(obj).writeValueAsBytes(obj).     } catch (final JsonProcessingException e) {         throw new SalesforceException("Unable to serialize given SObjectTree to JSON", e).     }     return new ByteArrayInputStream(jsonBytes). }
false;;3;19;;<T> Optional<T> tryToReadResponse(final XStream xstream, final Class<T> expectedType, final InputStream responseStream) {     if (responseStream == null) {         return Optional.empty().     }     try {         if (format == PayloadFormat.JSON) {             return Optional.of(fromJson(expectedType, responseStream)).         }         // must be XML         return Optional.of(fromXml(xstream, responseStream)).     } catch (XStreamException | IOException e) {         log.warn("Unable to read response from the Composite API", e).         return Optional.empty().     } finally {         IOHelper.close(responseStream).     } }
false;;0;5;;String versionUrl() {     ObjectHelper.notNull(version, "version").     return servicesDataUrl() + "v" + version + "/". }
false;protected;2;18;;@Override protected SalesforceException createRestException(final Response response, final InputStream responseContent) {     final List<RestError> errors.     try {         errors = readErrorsFrom(responseContent, format, mapper, xStreamCompositeTree).     } catch (final IOException e) {         return new SalesforceException("Unable to read error response", e).     }     final int status = response.getStatus().     if (status == HttpStatus.NOT_FOUND_404) {         return new NoSuchSObjectException(errors).     }     final String reason = response.getReason().     return new SalesforceException("Unexpected error: " + reason, status). }
false;protected;1;4;;@Override protected void setAccessToken(final Request request) {     request.getHeaders().put("Authorization", "Bearer " + accessToken). }
false;static;2;7;;static void checkCompositeBatchVersion(final String configuredVersion, final Version batchVersion) throws SalesforceException {     if (Version.create(configuredVersion).compareTo(batchVersion) < 0) {         throw new SalesforceException("Component is configured with Salesforce API version " + configuredVersion + ", but the payload of the Composite API batch operation requires at least " + batchVersion, 0).     } }
false;static;2;9;;static void checkCompositeFormat(final PayloadFormat configuredFormat, final PayloadFormat requiredFormat) throws SalesforceException {     if (configuredFormat != requiredFormat) {         throw new SalesforceException("Component is configured with Salesforce Composite API format " + configuredFormat + ", but the payload of the Composite API operation requires format " + requiredFormat, 0).     } }
false;static;2;6;;static <T> T fromXml(final XStream xstream, final InputStream responseStream) {     @SuppressWarnings("unchecked")     final T read = (T) xstream.fromXML(responseStream).     return read. }
false;static;2;6;;static InputStream toXml(final XStream xstream, final Object obj) {     final ByteArrayOutputStream out = new ByteArrayOutputStream().     xstream.toXML(obj, out).     return new ByteArrayInputStream(out.toByteArray()). }
