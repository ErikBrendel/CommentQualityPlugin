commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * Add SObject at the root of the tree.  *  * @param object  *            SObject to add  * @return {@link SObjectNode} for the given SObject  */ ;/**  * Add SObject at the root of the tree.  *  * @param object  *            SObject to add  * @return {@link SObjectNode} for the given SObject  */ public SObjectNode addObject(final AbstractSObjectBase object) {     ObjectHelper.notNull(object, "object").     return addNode(new SObjectNode(this, object)). }
true;public;0;3;/**  * Returns a stream of all nodes in the tree.  *  * @return  */ ;/**  * Returns a stream of all nodes in the tree.  *  * @return  */ public Stream<SObjectNode> allNodes() {     return records.stream().flatMap(r -> Stream.concat(Stream.of(r), r.getChildNodes())). }
true;public;0;3;/**  * Returns a stream of all objects in the tree.  *  * @return  */ ;/**  * Returns a stream of all objects in the tree.  *  * @return  */ public Stream<AbstractSObjectBase> allObjects() {     return records.stream().flatMap(r -> Stream.concat(Stream.of(r.getObject()), r.getChildren())). }
true;public;0;4;/**  * Returns the type of the objects in the root of the tree.  *  * @return object type  */ ;/**  * Returns the type of the objects in the root of the tree.  *  * @return object type  */ @JsonIgnore public String getObjectType() {     return objectType. }
false;public;0;5;;public Class[] objectTypes() {     final Set<Class> types = records.stream().flatMap(n -> n.objectTypes()).collect(Collectors.toSet()).     return types.toArray(new Class[types.size()]). }
true;public;2;7;/**  * Sets errors for the given reference. Used when processing the response of API invocation.  *  * @param referenceId  *            reference identifier  * @param errors  *            list of {@link RestError}  */ ;/**  * Sets errors for the given reference. Used when processing the response of API invocation.  *  * @param referenceId  *            reference identifier  * @param errors  *            list of {@link RestError}  */ public void setErrorFor(final String referenceId, final List<RestError> errors) {     for (final SObjectNode node : records) {         if (setErrorFor(node, referenceId, errors)) {             return.         }     } }
true;public;2;7;/**  * Sets identifier of SObject for the given reference. Used when processing the response of API invocation.  *  * @param referenceId  *            reference identifier  * @param id  *            SObject identifier  */ ;/**  * Sets identifier of SObject for the given reference. Used when processing the response of API invocation.  *  * @param referenceId  *            reference identifier  * @param id  *            SObject identifier  */ public void setIdFor(final String referenceId, final String id) {     for (final SObjectNode node : records) {         if (setIdFor(node, referenceId, id)) {             return.         }     } }
true;public;0;3;/**  * Returns the number of elements in the tree.  *  * @return number of elements in the tree  */ ;/**  * Returns the number of elements in the tree.  *  * @return number of elements in the tree  */ public int size() {     return records.stream().mapToInt(r -> r.size()).sum(). }
false;;1;13;;SObjectNode addNode(final SObjectNode node) {     final String givenObjectType = node.getObjectType().     if (objectType != null && !objectType.equals(givenObjectType)) {         throw new IllegalArgumentException("SObjectTree can hold only records of the same type, previously given: " + objectType + ", and now trying to add: " + givenObjectType).     }     objectType = givenObjectType.     records.add(node).     return node. }
false;;3;13;;boolean setErrorFor(final SObjectNode node, final String referenceId, final List<RestError> errors) {     final Attributes attributes = node.getAttributes().     final String attributesReferenceId = attributes.getReferenceId().     if (Objects.equals(attributesReferenceId, referenceId)) {         node.setErrors(errors).         return true.     }     return StreamSupport.stream(node.getChildNodes().spliterator(), false).anyMatch(n -> setErrorFor(n, referenceId, errors)). }
false;;3;18;;boolean setIdFor(final SObjectNode node, final String referenceId, final String id) {     final Attributes attributes = node.getAttributes().     final String attributesReferenceId = attributes.getReferenceId().     if (Objects.equals(attributesReferenceId, referenceId)) {         final Object object = node.getObject().         if (object != null) {             return updateBaseObjectId(id, (AbstractSObjectBase) object).         } else {             return updateGeneralObjectId(id, object).         }     }     return StreamSupport.stream(node.getChildNodes().spliterator(), false).anyMatch(n -> setIdFor(n, referenceId, id)). }
false;;2;5;;boolean updateBaseObjectId(final String id, final AbstractSObjectBase object) {     object.setId(id).     return true. }
false;;2;27;;boolean updateGeneralObjectId(final String id, final Object object) {     final Class<? extends Object> clazz = object.getClass().     final BeanInfo beanInfo.     try {         beanInfo = Introspector.getBeanInfo(clazz).     } catch (final IntrospectionException e) {         throw new IllegalStateException(e).     }     final PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors().     final Optional<PropertyDescriptor> maybeIdProperty = Arrays.stream(propertyDescriptors).filter(pd -> "id".equals(pd.getName())).findFirst().     if (maybeIdProperty.isPresent()) {         final Method readMethod = maybeIdProperty.get().getReadMethod().         try {             readMethod.invoke(object, id).             return true.         } catch (IllegalAccessException | InvocationTargetException e) {             throw new IllegalStateException(e).         }     }     return false. }
