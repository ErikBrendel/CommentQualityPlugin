commented;modifiers;parameterAmount;loc;comment;code
false;public;2;68;;@Override public boolean process(final Exchange exchange, final AsyncCallback callback) {     boolean done = false.     try {         switch(operationName) {             case CREATE_JOB:                 processCreateJob(exchange, callback).                 break.             case GET_JOB:                 processGetJob(exchange, callback).                 break.             case CLOSE_JOB:                 processCloseJob(exchange, callback).                 break.             case ABORT_JOB:                 processAbortJob(exchange, callback).                 break.             case CREATE_BATCH:                 processCreateBatch(exchange, callback).                 break.             case GET_BATCH:                 processGetBatch(exchange, callback).                 break.             case GET_ALL_BATCHES:                 processGetAllBatches(exchange, callback).                 break.             case GET_REQUEST:                 processGetRequest(exchange, callback).                 break.             case GET_RESULTS:                 processGetResults(exchange, callback).                 break.             case CREATE_BATCH_QUERY:                 processCreateBatchQuery(exchange, callback).                 break.             case GET_QUERY_RESULT_IDS:                 processGetQueryResultIds(exchange, callback).                 break.             case GET_QUERY_RESULT:                 processGetQueryResult(exchange, callback).                 break.             default:                 throw new SalesforceException("Unknown operation name: " + operationName.value(), null).         }     } catch (SalesforceException e) {         exchange.setException(new SalesforceException(String.format("Error processing %s: [%s] \"%s\"", operationName.value(), e.getStatusCode(), e.getMessage()), e)).         callback.done(true).         done = true.     } catch (InvalidPayloadException e) {         exchange.setException(new SalesforceException(String.format("Unexpected Error processing %s: \"%s\"", operationName.value(), e.getMessage()), e)).         callback.done(true).         done = true.     } catch (RuntimeException e) {         exchange.setException(new SalesforceException(String.format("Unexpected Error processing %s: \"%s\"", operationName.value(), e.getMessage()), e)).         callback.done(true).         done = true.     }     // continue routing asynchronously if false     return done. }
false;public;3;4;;@Override public void onResponse(JobInfo jobInfo, Map<String, String> headers, SalesforceException ex) {     processResponse(exchange, jobInfo, headers, ex, callback). }
false;private;2;9;;private void processCreateJob(final Exchange exchange, final AsyncCallback callback) throws InvalidPayloadException {     JobInfo jobBody = exchange.getIn().getMandatoryBody(JobInfo.class).     bulkClient.createJob(jobBody, determineHeaders(exchange), new BulkApiClient.JobInfoResponseCallback() {          @Override         public void onResponse(JobInfo jobInfo, Map<String, String> headers, SalesforceException ex) {             processResponse(exchange, jobInfo, headers, ex, callback).         }     }). }
false;public;3;4;;@Override public void onResponse(JobInfo jobInfo, Map<String, String> headers, SalesforceException ex) {     processResponse(exchange, jobInfo, headers, ex, callback). }
false;private;2;16;;private void processGetJob(final Exchange exchange, final AsyncCallback callback) throws SalesforceException {     JobInfo jobBody.     jobBody = exchange.getIn().getBody(JobInfo.class).     String jobId.     if (jobBody != null) {         jobId = jobBody.getId().     } else {         jobId = getParameter(JOB_ID, exchange, USE_BODY, NOT_OPTIONAL).     }     bulkClient.getJob(jobId, determineHeaders(exchange), new BulkApiClient.JobInfoResponseCallback() {          @Override         public void onResponse(JobInfo jobInfo, Map<String, String> headers, SalesforceException ex) {             processResponse(exchange, jobInfo, headers, ex, callback).         }     }). }
false;public;3;4;;@Override public void onResponse(JobInfo jobInfo, Map<String, String> headers, SalesforceException ex) {     processResponse(exchange, jobInfo, headers, ex, callback). }
false;private;2;16;;private void processCloseJob(final Exchange exchange, final AsyncCallback callback) throws SalesforceException {     JobInfo jobBody.     String jobId.     jobBody = exchange.getIn().getBody(JobInfo.class).     if (jobBody != null) {         jobId = jobBody.getId().     } else {         jobId = getParameter(JOB_ID, exchange, USE_BODY, NOT_OPTIONAL).     }     bulkClient.closeJob(jobId, determineHeaders(exchange), new BulkApiClient.JobInfoResponseCallback() {          @Override         public void onResponse(JobInfo jobInfo, Map<String, String> headers, SalesforceException ex) {             processResponse(exchange, jobInfo, headers, ex, callback).         }     }). }
false;public;3;4;;@Override public void onResponse(JobInfo jobInfo, Map<String, String> headers, SalesforceException ex) {     processResponse(exchange, jobInfo, headers, ex, callback). }
false;private;2;16;;private void processAbortJob(final Exchange exchange, final AsyncCallback callback) throws SalesforceException {     JobInfo jobBody.     String jobId.     jobBody = exchange.getIn().getBody(JobInfo.class).     if (jobBody != null) {         jobId = jobBody.getId().     } else {         jobId = getParameter(JOB_ID, exchange, USE_BODY, NOT_OPTIONAL).     }     bulkClient.abortJob(jobId, determineHeaders(exchange), new BulkApiClient.JobInfoResponseCallback() {          @Override         public void onResponse(JobInfo jobInfo, Map<String, String> headers, SalesforceException ex) {             processResponse(exchange, jobInfo, headers, ex, callback).         }     }). }
false;public;3;4;;@Override public void onResponse(BatchInfo batchInfo, Map<String, String> headers, SalesforceException ex) {     processResponse(exchange, batchInfo, headers, ex, callback). }
false;private;2;23;;private void processCreateBatch(final Exchange exchange, final AsyncCallback callback) throws SalesforceException {     String jobId.     // since request is in the body, use headers or endpoint params     ContentType contentType = ContentType.fromValue(getParameter(CONTENT_TYPE, exchange, IGNORE_BODY, NOT_OPTIONAL)).     jobId = getParameter(JOB_ID, exchange, IGNORE_BODY, NOT_OPTIONAL).     InputStream request.     try {         request = exchange.getIn().getMandatoryBody(InputStream.class).     } catch (CamelException e) {         String msg = "Error preparing batch request: " + e.getMessage().         throw new SalesforceException(msg, e).     }     bulkClient.createBatch(request, jobId, contentType, determineHeaders(exchange), new BulkApiClient.BatchInfoResponseCallback() {          @Override         public void onResponse(BatchInfo batchInfo, Map<String, String> headers, SalesforceException ex) {             processResponse(exchange, batchInfo, headers, ex, callback).         }     }). }
false;public;3;4;;@Override public void onResponse(BatchInfo batchInfo, Map<String, String> headers, SalesforceException ex) {     processResponse(exchange, batchInfo, headers, ex, callback). }
false;private;2;19;;private void processGetBatch(final Exchange exchange, final AsyncCallback callback) throws SalesforceException {     String jobId.     BatchInfo batchBody = exchange.getIn().getBody(BatchInfo.class).     String batchId.     if (batchBody != null) {         jobId = batchBody.getJobId().         batchId = batchBody.getId().     } else {         jobId = getParameter(JOB_ID, exchange, IGNORE_BODY, NOT_OPTIONAL).         batchId = getParameter(BATCH_ID, exchange, USE_BODY, NOT_OPTIONAL).     }     bulkClient.getBatch(jobId, batchId, determineHeaders(exchange), new BulkApiClient.BatchInfoResponseCallback() {          @Override         public void onResponse(BatchInfo batchInfo, Map<String, String> headers, SalesforceException ex) {             processResponse(exchange, batchInfo, headers, ex, callback).         }     }). }
false;public;3;4;;@Override public void onResponse(List<BatchInfo> batchInfoList, Map<String, String> headers, SalesforceException ex) {     processResponse(exchange, batchInfoList, headers, ex, callback). }
false;private;2;17;;private void processGetAllBatches(final Exchange exchange, final AsyncCallback callback) throws SalesforceException {     JobInfo jobBody.     String jobId.     jobBody = exchange.getIn().getBody(JobInfo.class).     if (jobBody != null) {         jobId = jobBody.getId().     } else {         jobId = getParameter(JOB_ID, exchange, USE_BODY, NOT_OPTIONAL).     }     bulkClient.getAllBatches(jobId, determineHeaders(exchange), new BulkApiClient.BatchInfoListResponseCallback() {          @Override         public void onResponse(List<BatchInfo> batchInfoList, Map<String, String> headers, SalesforceException ex) {             processResponse(exchange, batchInfoList, headers, ex, callback).         }     }). }
false;public;3;21;;@Override public void onResponse(InputStream inputStream, Map<String, String> headers, SalesforceException ex) {     // read the request stream into a StreamCache temp file     // ensures the connection is read     StreamCache body = null.     if (inputStream != null) {         try {             body = StreamCacheConverter.convertToStreamCache(inputStream, exchange).         } catch (IOException e) {             String msg = "Error retrieving batch request: " + e.getMessage().             ex = new SalesforceException(msg, e).         } finally {             // close the input stream to release the Http connection             try {                 inputStream.close().             } catch (IOException ignore) {             }         }     }     processResponse(exchange, body, headers, ex, callback). }
false;private;2;38;;private void processGetRequest(final Exchange exchange, final AsyncCallback callback) throws SalesforceException {     String jobId.     BatchInfo batchBody.     String batchId.     batchBody = exchange.getIn().getBody(BatchInfo.class).     if (batchBody != null) {         jobId = batchBody.getJobId().         batchId = batchBody.getId().     } else {         jobId = getParameter(JOB_ID, exchange, IGNORE_BODY, NOT_OPTIONAL).         batchId = getParameter(BATCH_ID, exchange, USE_BODY, NOT_OPTIONAL).     }     bulkClient.getRequest(jobId, batchId, determineHeaders(exchange), new BulkApiClient.StreamResponseCallback() {          @Override         public void onResponse(InputStream inputStream, Map<String, String> headers, SalesforceException ex) {             // read the request stream into a StreamCache temp file             // ensures the connection is read             StreamCache body = null.             if (inputStream != null) {                 try {                     body = StreamCacheConverter.convertToStreamCache(inputStream, exchange).                 } catch (IOException e) {                     String msg = "Error retrieving batch request: " + e.getMessage().                     ex = new SalesforceException(msg, e).                 } finally {                     // close the input stream to release the Http connection                     try {                         inputStream.close().                     } catch (IOException ignore) {                     }                 }             }             processResponse(exchange, body, headers, ex, callback).         }     }). }
false;public;3;21;;@Override public void onResponse(InputStream inputStream, Map<String, String> headers, SalesforceException ex) {     // read the result stream into a StreamCache temp file     // ensures the connection is read     StreamCache body = null.     if (inputStream != null) {         try {             body = StreamCacheConverter.convertToStreamCache(inputStream, exchange).         } catch (IOException e) {             String msg = "Error retrieving batch results: " + e.getMessage().             ex = new SalesforceException(msg, e).         } finally {             // close the input stream to release the Http connection             try {                 inputStream.close().             } catch (IOException ignore) {             }         }     }     processResponse(exchange, body, headers, ex, callback). }
false;private;2;37;;private void processGetResults(final Exchange exchange, final AsyncCallback callback) throws SalesforceException {     String jobId.     BatchInfo batchBody.     String batchId.     batchBody = exchange.getIn().getBody(BatchInfo.class).     if (batchBody != null) {         jobId = batchBody.getJobId().         batchId = batchBody.getId().     } else {         jobId = getParameter(JOB_ID, exchange, IGNORE_BODY, NOT_OPTIONAL).         batchId = getParameter(BATCH_ID, exchange, USE_BODY, NOT_OPTIONAL).     }     bulkClient.getResults(jobId, batchId, determineHeaders(exchange), new BulkApiClient.StreamResponseCallback() {          @Override         public void onResponse(InputStream inputStream, Map<String, String> headers, SalesforceException ex) {             // read the result stream into a StreamCache temp file             // ensures the connection is read             StreamCache body = null.             if (inputStream != null) {                 try {                     body = StreamCacheConverter.convertToStreamCache(inputStream, exchange).                 } catch (IOException e) {                     String msg = "Error retrieving batch results: " + e.getMessage().                     ex = new SalesforceException(msg, e).                 } finally {                     // close the input stream to release the Http connection                     try {                         inputStream.close().                     } catch (IOException ignore) {                     }                 }             }             processResponse(exchange, body, headers, ex, callback).         }     }). }
false;public;3;4;;@Override public void onResponse(BatchInfo batchInfo, Map<String, String> headers, SalesforceException ex) {     processResponse(exchange, batchInfo, headers, ex, callback). }
false;private;2;26;;private void processCreateBatchQuery(final Exchange exchange, final AsyncCallback callback) throws SalesforceException {     JobInfo jobBody.     String jobId.     ContentType contentType.     jobBody = exchange.getIn().getBody(JobInfo.class).     String soqlQuery.     if (jobBody != null) {         jobId = jobBody.getId().         contentType = jobBody.getContentType().         // use SOQL query from header or endpoint config         soqlQuery = getParameter(SOBJECT_QUERY, exchange, IGNORE_BODY, NOT_OPTIONAL).     } else {         jobId = getParameter(JOB_ID, exchange, IGNORE_BODY, NOT_OPTIONAL).         contentType = ContentType.fromValue(getParameter(CONTENT_TYPE, exchange, IGNORE_BODY, NOT_OPTIONAL)).         // reuse SOBJECT_QUERY property         soqlQuery = getParameter(SOBJECT_QUERY, exchange, USE_BODY, NOT_OPTIONAL).     }     bulkClient.createBatchQuery(jobId, soqlQuery, contentType, determineHeaders(exchange), new BulkApiClient.BatchInfoResponseCallback() {          @Override         public void onResponse(BatchInfo batchInfo, Map<String, String> headers, SalesforceException ex) {             processResponse(exchange, batchInfo, headers, ex, callback).         }     }). }
false;public;3;4;;@Override public void onResponse(List<String> ids, Map<String, String> headers, SalesforceException ex) {     processResponse(exchange, ids, headers, ex, callback). }
false;private;2;20;;private void processGetQueryResultIds(final Exchange exchange, final AsyncCallback callback) throws SalesforceException {     String jobId.     BatchInfo batchBody.     String batchId.     batchBody = exchange.getIn().getBody(BatchInfo.class).     if (batchBody != null) {         jobId = batchBody.getJobId().         batchId = batchBody.getId().     } else {         jobId = getParameter(JOB_ID, exchange, IGNORE_BODY, NOT_OPTIONAL).         batchId = getParameter(BATCH_ID, exchange, USE_BODY, NOT_OPTIONAL).     }     bulkClient.getQueryResultIds(jobId, batchId, determineHeaders(exchange), new BulkApiClient.QueryResultIdsCallback() {          @Override         public void onResponse(List<String> ids, Map<String, String> headers, SalesforceException ex) {             processResponse(exchange, ids, headers, ex, callback).         }     }). }
false;public;3;22;;@Override public void onResponse(InputStream inputStream, Map<String, String> headers, SalesforceException ex) {     StreamCache body = null.     if (inputStream != null) {         // ensures the connection is read         try {             body = StreamCacheConverter.convertToStreamCache(inputStream, exchange).         } catch (IOException e) {             String msg = "Error retrieving query result: " + e.getMessage().             ex = new SalesforceException(msg, e).         } finally {             // close the input stream to release the Http connection             try {                 inputStream.close().             } catch (IOException e) {             // ignore             }         }     }     processResponse(exchange, body, headers, ex, callback). }
false;private;2;41;;private void processGetQueryResult(final Exchange exchange, final AsyncCallback callback) throws SalesforceException {     String jobId.     BatchInfo batchBody.     String batchId.     batchBody = exchange.getIn().getBody(BatchInfo.class).     String resultId.     if (batchBody != null) {         jobId = batchBody.getJobId().         batchId = batchBody.getId().         resultId = getParameter(RESULT_ID, exchange, IGNORE_BODY, NOT_OPTIONAL).     } else {         jobId = getParameter(JOB_ID, exchange, IGNORE_BODY, NOT_OPTIONAL).         batchId = getParameter(BATCH_ID, exchange, IGNORE_BODY, NOT_OPTIONAL).         resultId = getParameter(RESULT_ID, exchange, USE_BODY, NOT_OPTIONAL).     }     bulkClient.getQueryResult(jobId, batchId, resultId, determineHeaders(exchange), new BulkApiClient.StreamResponseCallback() {          @Override         public void onResponse(InputStream inputStream, Map<String, String> headers, SalesforceException ex) {             StreamCache body = null.             if (inputStream != null) {                 // ensures the connection is read                 try {                     body = StreamCacheConverter.convertToStreamCache(inputStream, exchange).                 } catch (IOException e) {                     String msg = "Error retrieving query result: " + e.getMessage().                     ex = new SalesforceException(msg, e).                 } finally {                     // close the input stream to release the Http connection                     try {                         inputStream.close().                     } catch (IOException e) {                     // ignore                     }                 }             }             processResponse(exchange, body, headers, ex, callback).         }     }). }
false;private;5;18;;private void processResponse(Exchange exchange, Object body, Map<String, String> headers, SalesforceException ex, AsyncCallback callback) {     final Message out = exchange.getOut().     if (ex != null) {         exchange.setException(ex).     } else {         out.setBody(body).     }     // copy headers and attachments     Message inboundMessage = exchange.getIn().     Map<String, Object> outboundHeaders = out.getHeaders().     outboundHeaders.putAll(inboundMessage.getHeaders()).     outboundHeaders.putAll(headers).     out.copyAttachments(inboundMessage).     // signal exchange completion     callback.done(false). }
false;public;0;4;;@Override public void start() throws Exception {     ServiceHelper.startService(bulkClient). }
false;public;0;5;;@Override public void stop() throws Exception {     // stop the client     ServiceHelper.stopService(bulkClient). }
