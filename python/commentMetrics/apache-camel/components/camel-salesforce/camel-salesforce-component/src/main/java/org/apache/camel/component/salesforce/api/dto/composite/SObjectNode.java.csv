commented;modifiers;parameterAmount;loc;comment;code
false;static;1;5;;static String pluralOf(final AbstractDescribedSObjectBase object) {     final SObjectDescription description = object.description().     return description.getLabelPlural(). }
false;static;1;4;;static String typeOf(final AbstractDescribedSObjectBase object) {     final SObjectDescription description = object.description().     return description.getName(). }
false;static;1;3;;static String typeOf(final AbstractSObjectBase object) {     return object.getClass().getSimpleName(). }
true;public;1;5;/**  * Add a described child with the metadata needed already present within it to the this node.  *  * @param child  *            to add  * @return the newly created node, used in builder fashion to add more child objects to it (on the next level)  */ ;/**  * Add a described child with the metadata needed already present within it to the this node.  *  * @param child  *            to add  * @return the newly created node, used in builder fashion to add more child objects to it (on the next level)  */ public SObjectNode addChild(final AbstractDescribedSObjectBase child) {     ObjectHelper.notNull(child, CHILD_PARAM).     return addChild(pluralOf(child), child). }
true;public;2;8;/**  * Add a child that does not contain the required metadata to the this node. You need to specify the plural form of  * the child (e.g. `Account` its `Accounts`).  *  * @param labelPlural  *            plural form  * @param child  *            to add  * @return the newly created node, used in builder fashion to add more child objects to it (on the next level)  */ ;/**  * Add a child that does not contain the required metadata to the this node. You need to specify the plural form of  * the child (e.g. `Account` its `Accounts`).  *  * @param labelPlural  *            plural form  * @param child  *            to add  * @return the newly created node, used in builder fashion to add more child objects to it (on the next level)  */ public SObjectNode addChild(final String labelPlural, final AbstractSObjectBase child) {     ObjectHelper.notNull(labelPlural, "labelPlural").     ObjectHelper.notNull(child, CHILD_PARAM).     final SObjectNode node = new SObjectNode(referenceGenerator, typeOf(child), child).     return addChild(labelPlural, node). }
true;public;2;8;/**  * Add multiple described children with the metadata needed already present within them to the this node..  *  * @param first  *            first child to add  * @param others  *            any other children to add  */ ;/**  * Add multiple described children with the metadata needed already present within them to the this node..  *  * @param first  *            first child to add  * @param others  *            any other children to add  */ public void addChildren(final AbstractDescribedSObjectBase first, final AbstractDescribedSObjectBase... others) {     ObjectHelper.notNull(first, "first").     ObjectHelper.notNull(others, "others").     addChild(pluralOf(first), first).     Arrays.stream(others).forEach(this::addChild). }
true;public;3;10;/**  * Add a child that does not contain the required metadata to the this node. You need to specify the plural form of  * the child (e.g. `Account` its `Accounts`).  *  * @param labelPlural  *            plural form  * @param first  *            first child to add  * @param others  *            any other children to add  */ ;/**  * Add a child that does not contain the required metadata to the this node. You need to specify the plural form of  * the child (e.g. `Account` its `Accounts`).  *  * @param labelPlural  *            plural form  * @param first  *            first child to add  * @param others  *            any other children to add  */ public void addChildren(final String labelPlural, final AbstractSObjectBase first, final AbstractSObjectBase... others) {     ObjectHelper.notNull(labelPlural, "labelPlural").     ObjectHelper.notNull(first, "first").     ObjectHelper.notNull(others, "others").     addChild(labelPlural, first).     Arrays.stream(others).forEach(c -> addChild(labelPlural, c)). }
true;public;0;4;/**  * Returns all children of this node (one level deep).  *  * @return children of this node  */ ;/**  * Returns all children of this node (one level deep).  *  * @return children of this node  */ @JsonIgnore public Stream<SObjectNode> getChildNodes() {     return records.values().stream().flatMap(List::stream). }
true;public;1;5;/**  * Returns all children of this node (one level deep) of certain type (in plural form).  *  * @param type  *            type of child requested in plural form (e.g for `Account` is `Accounts`)  * @return children of this node of specified type  */ ;/**  * Returns all children of this node (one level deep) of certain type (in plural form).  *  * @param type  *            type of child requested in plural form (e.g for `Account` is `Accounts`)  * @return children of this node of specified type  */ public Stream<SObjectNode> getChildNodesOfType(final String type) {     ObjectHelper.notNull(type, SOBJECT_TYPE_PARAM).     return records.getOrDefault(type, Collections.emptyList()).stream(). }
true;public;0;4;/**  * Returns child SObjects of this node (one level deep).  *  * @return child SObjects of this node  */ ;/**  * Returns child SObjects of this node (one level deep).  *  * @return child SObjects of this node  */ @JsonIgnore public Stream<AbstractSObjectBase> getChildren() {     return records.values().stream().flatMap(List::stream).map(SObjectNode::getObject). }
true;public;1;5;/**  * Returns child SObjects of this node (one level deep) of certain type (in plural form)  *  * @param type  *            type of child requested in plural form (e.g for `Account` is `Accounts`)  * @return child SObjects of this node  */ ;/**  * Returns child SObjects of this node (one level deep) of certain type (in plural form)  *  * @param type  *            type of child requested in plural form (e.g for `Account` is `Accounts`)  * @return child SObjects of this node  */ public Stream<AbstractSObjectBase> getChildrenOfType(final String type) {     ObjectHelper.notNull(type, SOBJECT_TYPE_PARAM).     return records.getOrDefault(type, Collections.emptyList()).stream().map(SObjectNode::getObject). }
true;public;0;4;/**  * Errors reported against this this node received in response to the SObject tree being submitted.  *  * @return errors for this node  */ ;/**  * Errors reported against this this node received in response to the SObject tree being submitted.  *  * @return errors for this node  */ @JsonIgnore public List<RestError> getErrors() {     return Optional.ofNullable(errors).orElse(Collections.emptyList()). }
true;public;0;4;/**  * SObject at this node.  *  * @return SObject  */ ;/**  * SObject at this node.  *  * @return SObject  */ @JsonIgnore public AbstractSObjectBase getObject() {     return object. }
true;public;0;3;/**  * Are there any errors resulted from the submission on this node?  *  * @return true if there are errors  */ ;/**  * Are there any errors resulted from the submission on this node?  *  * @return true if there are errors  */ public boolean hasErrors() {     return errors != null && !errors.isEmpty(). }
true;public;0;3;/**  * Size of the branch beginning with this node (number of SObjects in it).  *  * @return number of objects within this branch  */ ;/**  * Size of the branch beginning with this node (number of SObjects in it).  *  * @return number of objects within this branch  */ public int size() {     return 1 + records.values().stream().flatMapToInt(r -> r.stream().mapToInt(SObjectNode::size)).sum(). }
false;public;0;4;;@Override public String toString() {     return "Node<" + getObjectType() + ">". }
false;;2;11;;SObjectNode addChild(final String labelPlural, final SObjectNode node) {     List<SObjectNode> children = records.get(labelPlural).     if (children == null) {         children = new ArrayList<>().         records.put(labelPlural, children).     }     children.add(node).     return node. }
false;;0;5;;@JsonAnyGetter Map<String, Map<String, List<SObjectNode>>> children() {     return records.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> Collections.singletonMap("records", e.getValue()))). }
false;;0;3;;Attributes getAttributes() {     return attributes. }
false;;0;4;;@JsonIgnore String getObjectType() {     return attributes.type. }
false;;0;3;;Stream<Class> objectTypes() {     return Stream.concat(Stream.of((Class) object.getClass()), getChildNodes().flatMap(SObjectNode::objectTypes)). }
false;;1;3;;void setErrors(final List<RestError> errors) {     this.errors = errors. }
