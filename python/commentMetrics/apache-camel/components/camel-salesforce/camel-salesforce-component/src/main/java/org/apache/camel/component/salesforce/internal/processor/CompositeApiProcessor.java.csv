commented;modifiers;parameterAmount;loc;comment;code
false;;5;2;;void handleResponse(Exchange exchange, Optional<T> body, Map<String, String> headers, SalesforceException exception, AsyncCallback callback).
false;public;2;24;;@Override public boolean process(final Exchange exchange, final AsyncCallback callback) {     try {         switch(operationName) {             case COMPOSITE_TREE:                 return processInternal(SObjectTree.class, exchange, compositeClient::submitCompositeTree, this::processCompositeTreeResponse, callback).             case COMPOSITE_BATCH:                 return processInternal(SObjectBatch.class, exchange, compositeClient::submitCompositeBatch, this::processCompositeBatchResponse, callback).             case COMPOSITE:                 return processInternal(SObjectComposite.class, exchange, compositeClient::submitComposite, this::processCompositeResponse, callback).             default:                 throw new SalesforceException("Unknown operation name: " + operationName.value(), null).         }     } catch (final SalesforceException e) {         return processException(exchange, callback, e).     } catch (final RuntimeException e) {         final SalesforceException exception = new SalesforceException(String.format("Unexpected Error processing %s: \"%s\"", operationName.value(), e.getMessage()), e).         return processException(exchange, callback, exception).     } }
false;public;0;4;;@Override public void start() throws Exception {     ServiceHelper.startService(compositeClient). }
false;public;0;4;;@Override public void stop() throws Exception {     ServiceHelper.stopService(compositeClient). }
false;;5;19;;void processCompositeBatchResponse(final Exchange exchange, final Optional<SObjectBatchResponse> responseBody, final Map<String, String> headers, final SalesforceException exception, final AsyncCallback callback) {     try {         if (!responseBody.isPresent()) {             exchange.setException(exception).         } else {             final Message in = exchange.getIn().             final Message out = exchange.getOut().             final SObjectBatchResponse response = responseBody.get().             out.copyFromWithNewBody(in, response).             out.getHeaders().putAll(headers).         }     } finally {         // notify callback that exchange is done         callback.done(false).     } }
false;;5;19;;void processCompositeResponse(final Exchange exchange, final Optional<SObjectCompositeResponse> responseBody, final Map<String, String> headers, final SalesforceException exception, final AsyncCallback callback) {     try {         if (!responseBody.isPresent()) {             exchange.setException(exception).         } else {             final Message in = exchange.getIn().             final Message out = exchange.getOut().             final SObjectCompositeResponse response = responseBody.get().             out.copyFromWithNewBody(in, response).             out.getHeaders().putAll(headers).         }     } finally {         // notify callback that exchange is done         callback.done(false).     } }
false;;5;39;;void processCompositeTreeResponse(final Exchange exchange, final Optional<SObjectTreeResponse> responseBody, final Map<String, String> headers, final SalesforceException exception, final AsyncCallback callback) {     try {         if (!responseBody.isPresent()) {             exchange.setException(exception).         } else {             final Message in = exchange.getIn().             final Message out = exchange.getOut().             final SObjectTree tree = in.getBody(SObjectTree.class).             final SObjectTreeResponse response = responseBody.get().             final boolean hasErrors = response.hasErrors().             for (final ReferenceId referenceId : response.getResults()) {                 tree.setIdFor(referenceId.getReferenceId(), referenceId.getId()).                 if (hasErrors) {                     tree.setErrorFor(referenceId.getReferenceId(), referenceId.getErrors()).                 }             }             if (hasErrors) {                 final SalesforceException withErrors = new SalesforceException(response.getAllErrors(), exception.getStatusCode(), exception).                 exchange.setException(withErrors).             }             out.copyFromWithNewBody(in, tree).             out.getHeaders().putAll(headers).         }     } finally {         // notify callback that exchange is done         callback.done(false).     } }
false;;5;18;;<T, R> boolean processInternal(final Class<T> bodyType, final Exchange exchange, final CompositeApiClient.Operation<T, R> clientOperation, final ResponseHandler<R> responseHandler, final AsyncCallback callback) throws SalesforceException {     final T body.     final Message in = exchange.getIn().     try {         body = in.getMandatoryBody(bodyType).     } catch (final InvalidPayloadException e) {         throw new SalesforceException(e).     }     clientOperation.submit(body, determineHeaders(exchange), (response, responseHeaders, exception) -> responseHandler.handleResponse(exchange, response, responseHeaders, exception, callback)).     return false. }
false;static;3;6;;static boolean processException(final Exchange exchange, final AsyncCallback callback, final Exception e) {     exchange.setException(e).     callback.done(true).     return true. }
