commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getInstanceUrl() {     return instanceUrl. }
false;public;1;3;;public void setInstanceUrl(final String instanceUrl) {     this.instanceUrl = instanceUrl. }
false;public;0;3;;public String getLoginUrl() {     return loginUrl. }
true;public;1;3;/**  * Salesforce login URL, defaults to https://login.salesforce.com  */ ;/**  * Salesforce login URL, defaults to https://login.salesforce.com  */ public void setLoginUrl(String loginUrl) {     this.loginUrl = loginUrl. }
false;public;0;3;;public String getClientId() {     return clientId. }
true;public;1;3;/**  * Salesforce connected application Consumer Key  */ ;/**  * Salesforce connected application Consumer Key  */ public void setClientId(String clientId) {     this.clientId = clientId. }
false;public;0;3;;public String getClientSecret() {     return clientSecret. }
true;public;1;3;/**  * Salesforce connected application Consumer Secret  */ ;/**  * Salesforce connected application Consumer Secret  */ public void setClientSecret(String clientSecret) {     this.clientSecret = clientSecret. }
true;public;1;3;/**  * Keystore parameters for keystore containing certificate and private key needed for OAuth 2.0 JWT Bearer Token  * Flow.  */ ;/**  * Keystore parameters for keystore containing certificate and private key needed for OAuth 2.0 JWT Bearer Token  * Flow.  */ public void setKeystore(final KeyStoreParameters keystore) {     this.keystore = keystore. }
false;public;0;3;;public KeyStoreParameters getKeystore() {     return keystore. }
false;public;0;3;;public String getRefreshToken() {     return refreshToken. }
true;public;1;3;/**  * Salesforce connected application Consumer token  */ ;/**  * Salesforce connected application Consumer token  */ public void setRefreshToken(String refreshToken) {     this.refreshToken = refreshToken. }
false;public;0;35;;public AuthenticationType getType() {     if (type != null) {         // use the user provided type         return type.     }     final boolean hasPassword = ObjectHelper.isNotEmpty(password).     final boolean hasRefreshToken = ObjectHelper.isNotEmpty(refreshToken).     final boolean hasKeystore = keystore != null && ObjectHelper.isNotEmpty(keystore.getResource()).     if (hasPassword && !hasRefreshToken && !hasKeystore) {         return AuthenticationType.USERNAME_PASSWORD.     }     if (!hasPassword && hasRefreshToken && !hasKeystore) {         return AuthenticationType.REFRESH_TOKEN.     }     if (!hasPassword && !hasRefreshToken && hasKeystore) {         return AuthenticationType.JWT.     }     if (hasPassword && hasRefreshToken || hasPassword && hasKeystore || hasRefreshToken && hasKeystore) {         throw new IllegalArgumentException("The provided authentication configuration can be used in multiple ways" + " for instance both with username/password and refresh_token. Either remove some of the configuration" + " options, so that authentication method can be auto-determined or explicitly set the authentication" + " type.").     }     throw new IllegalArgumentException("You must specify parameters aligned with one of the supported authentication methods:" + " for username and password authentication: userName, password, clientSecret." + " for refresh token authentication: refreshToken, clientSecret." + " for JWT: userName, keystore. And for every one of those loginUrl and clientId must be specified also."). }
false;public;1;3;;public void setType(AuthenticationType type) {     this.type = type. }
false;public;0;3;;public String getUserName() {     return userName. }
true;public;1;3;/**  * Salesforce account user name  */ ;/**  * Salesforce account user name  */ public void setUserName(String userName) {     this.userName = userName. }
false;public;0;3;;public String getPassword() {     return password. }
true;public;1;3;/**  * Salesforce account password  */ ;/**  * Salesforce account password  */ public void setPassword(String password) {     this.password = password. }
false;public;0;3;;public boolean isLazyLogin() {     return lazyLogin. }
true;public;1;3;/**  * Flag to enable/disable lazy OAuth, default is false. When enabled, OAuth token retrieval or generation is not  * done until the first API call  */ ;/**  * Flag to enable/disable lazy OAuth, default is false. When enabled, OAuth token retrieval or generation is not  * done until the first API call  */ public void setLazyLogin(boolean lazyLogin) {     this.lazyLogin = lazyLogin. }
false;public;0;24;;public void validate() {     ObjectHelper.notNull(loginUrl, "loginUrl").     ObjectHelper.notNull(clientId, "clientId").     final AuthenticationType type = getType().     switch(type) {         case USERNAME_PASSWORD:             ObjectHelper.notNull(userName, "userName (username/password authentication)").             ObjectHelper.notNull(password, "password (username/password authentication)").             ObjectHelper.notNull(clientSecret, "clientSecret (username/password authentication)").             break.         case REFRESH_TOKEN:             ObjectHelper.notNull(refreshToken, "refreshToken (authentication with refresh token)").             ObjectHelper.notNull(clientSecret, "clientSecret (authentication with refresh token)").             break.         case JWT:             ObjectHelper.notNull(userName, "userName (JWT authentication)").             ObjectHelper.notNull(keystore, "keystore (JWT authentication)").             break.         default:             throw new IllegalArgumentException("Unknown authentication type: " + type).     } }
false;public;0;7;;@Override public String toString() {     return "SalesforceLoginConfig[" + "instanceUrl= '" + instanceUrl + "', loginUrl='" + loginUrl + '\'' + "," + "clientId='" + clientId + '\'' + ", clientSecret='********'" + ", refreshToken='" + refreshToken + '\'' + ", userName='" + userName + '\'' + ", password=********'" + password + '\'' + ", keystore=********'" + keystore + '\'' + ", lazyLogin=" + lazyLogin + ']'. }
