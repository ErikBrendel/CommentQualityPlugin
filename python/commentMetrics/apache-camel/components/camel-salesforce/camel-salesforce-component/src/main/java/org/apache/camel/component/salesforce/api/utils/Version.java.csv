commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;12;;public static Version create(final String version) {     final Matcher matcher = VERSION_PATTERN.matcher(version).     if (!matcher.matches()) {         throw new IllegalArgumentException("API version needs to be in <number>.<number> format, given: " + version).     }     final int major = Integer.parseInt(matcher.group(1)).     final int minor = Integer.parseInt(matcher.group(2)).     return new Version(major, minor). }
false;public;1;10;;@Override public int compareTo(final Version other) {     final int majorCompare = Integer.compare(major, other.major).     if (majorCompare == 0) {         return Integer.compare(minor, other.minor).     } else {         return majorCompare.     } }
false;public;1;14;;@Override public boolean equals(final Object obj) {     if (obj == this) {         return true.     }     if (!(obj instanceof Version)) {         return false.     }     final Version other = (Version) obj.     return compareTo(other) == 0. }
false;public;0;3;;public int getMajor() {     return major. }
false;public;0;3;;public int getMinor() {     return minor. }
false;public;0;4;;@Override public int hashCode() {     return 1 + 31 * (1 + 31 * major) + minor. }
false;public;0;4;;@Override public String toString() {     return "v" + major + "." + minor. }
false;public;2;8;;public void requireAtLeast(final int requiredMajor, final int requiredMinor) {     final Version required = new Version(requiredMajor, requiredMinor).     if (this.compareTo(required) < 0) {         throw new UnsupportedOperationException("This operation requires API version at least " + requiredMajor + "." + requiredMinor + ", currently configured for " + major + "." + minor).     } }
