commented;modifiers;parameterAmount;loc;comment;code
false;public;0;14;;@Before public void createAccounts() {     final List<Account> accountsToCreate = IntStream.range(0, accountCount + 1).mapToObj(idx -> {         final String name = "test-account-" + idx.         final Account account = new Account().         account.setName(name).         return account.     }).collect(Collectors.toList()).     accountIds = accountsToCreate.stream().map(account -> template.requestBody("salesforce:createSObject?sObjectName=Account", account, CreateSObjectResult.class)).map(CreateSObjectResult::getId).collect(Collectors.toList()). }
false;public;0;4;;@After public void deleteAccounts() {     accountIds.forEach(id -> template.sendBody("salesforce:deleteSObject?sObjectName=Account", id)). }
false;public;0;20;;@Before public void setupUserId() throws IOException {     final SalesforceLoginConfig loginConfig = LoginConfigHelper.getLoginConfig().     final String userName = loginConfig.getUserName().     // I happen to have a username (e-mail address) with '+' sign in it,     // DefaultRestClient#urlEncode would encode '+' as '%20' and the query     // would not return any result, so replacing '+' with '%' and '=' with     // 'LIKE' makes sense in my case. It should also work for every other     // case where '+' is not used as a part of the username.     final String wildcardUsername = userName.replace('+', '%').     final QueryRecordsReport results = template.requestBody(//      "salesforce:query?sObjectClass=" + QueryRecordsReport.class.getName() + "&sObjectQuery=SELECT Id FROM User WHERE Username LIKE '" + wildcardUsername + "'", NOT_USED, QueryRecordsReport.class).     userId = results.getRecords().get(0).getId(). }
