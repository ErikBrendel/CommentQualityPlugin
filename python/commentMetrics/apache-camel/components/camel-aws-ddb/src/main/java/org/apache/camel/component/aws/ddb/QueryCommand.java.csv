commented;modifiers;parameterAmount;loc;comment;code
false;public;0;26;;@Override public void execute() {     QueryRequest query = new QueryRequest().withTableName(determineTableName()).withAttributesToGet(determineAttributeNames()).withConsistentRead(determineConsistentRead()).withExclusiveStartKey(determineStartKey()).withKeyConditions(determineKeyConditions()).withExclusiveStartKey(determineStartKey()).withLimit(determineLimit()).withScanIndexForward(determineScanIndexForward()).     // Check if we have set an Index Name     if (exchange.getIn().getHeader(DdbConstants.INDEX_NAME, String.class) != null) {         query.withIndexName(exchange.getIn().getHeader(DdbConstants.INDEX_NAME, String.class)).     }     QueryResult result = ddbClient.query(query).     Map tmp = new HashMap<>().     tmp.put(DdbConstants.ITEMS, result.getItems()).     tmp.put(DdbConstants.LAST_EVALUATED_KEY, result.getLastEvaluatedKey()).     tmp.put(DdbConstants.CONSUMED_CAPACITY, result.getConsumedCapacity()).     tmp.put(DdbConstants.COUNT, result.getCount()).     addToResults(tmp). }
false;private;0;3;;private Map<String, AttributeValue> determineStartKey() {     return exchange.getIn().getHeader(DdbConstants.START_KEY, Map.class). }
false;private;0;3;;private Boolean determineScanIndexForward() {     return exchange.getIn().getHeader(DdbConstants.SCAN_INDEX_FORWARD, Boolean.class). }
false;private;0;3;;private Map determineKeyConditions() {     return exchange.getIn().getHeader(DdbConstants.KEY_CONDITIONS, Map.class). }
false;private;0;3;;private Integer determineLimit() {     return exchange.getIn().getHeader(DdbConstants.LIMIT, Integer.class). }
