commented;modifiers;parameterAmount;loc;comment;code
false;;1;5;;void addAll(Collection<Shard> shards) {     for (Shard shard : shards) {         add(shard).     } }
false;;1;3;;void add(Shard shard) {     shards.put(shard.getShardId(), shard). }
false;;1;8;;Shard nextAfter(Shard previous) {     for (Shard shard : shards.values()) {         if (previous.getShardId().equals(shard.getParentShardId())) {             return shard.         }     }     throw new IllegalStateException("Unable to find the next shard for " + previous + " in " + shards). }
false;;0;10;;Shard first() {     // same then we can skip the shard entirely. Need to confirm this with AWS.     for (Shard shard : shards.values()) {         if (!shards.containsKey(shard.getParentShardId())) {             return shard.         }     }     throw new IllegalStateException("Unable to find an unparented shard in " + shards). }
false;;0;12;;Shard last() {     Map<String, Shard> shardsByParent = new HashMap<>().     for (Shard shard : shards.values()) {         shardsByParent.put(shard.getParentShardId(), shard).     }     for (Shard shard : shards.values()) {         if (!shardsByParent.containsKey(shard.getShardId())) {             return shard.         }     }     throw new IllegalStateException("Unable to find a shard with no children " + shards). }
false;;1;3;;Shard afterSeq(String sequenceNumber) {     return atAfterSeq(sequenceNumber, BigIntComparisons.Conditions.LT). }
false;;1;3;;Shard atSeq(String sequenceNumber) {     return atAfterSeq(sequenceNumber, BigIntComparisons.Conditions.LTEQ). }
false;;2;20;;Shard atAfterSeq(String sequenceNumber, BigIntComparisons condition) {     BigInteger atAfter = new BigInteger(sequenceNumber).     List<Shard> sorted = new ArrayList<>().     sorted.addAll(shards.values()).     Collections.sort(sorted, StartingSequenceNumberComparator.INSTANCE).     for (Shard shard : sorted) {         if (shard.getSequenceNumberRange().getEndingSequenceNumber() != null) {             BigInteger end = new BigInteger(shard.getSequenceNumberRange().getEndingSequenceNumber()).             // essentially: after < end or after <= end             if (condition.matches(atAfter, end)) {                 return shard.             }         }     }     if (shards.size() > 0) {         return sorted.get(sorted.size() - 1).     }     throw new IllegalStateException("Unable to find a shard with appropriate sequence numbers for " + sequenceNumber + " in " + shards). }
true;;1;15;/**  * Removes shards that are older than the provided shard. Does not remove  * the provided shard.  *  * @param removeBefore  */ ;/**  * Removes shards that are older than the provided shard. Does not remove  * the provided shard.  *  * @param removeBefore  */ void removeOlderThan(Shard removeBefore) {     String current = removeBefore.getParentShardId().     int removedShards = 0.     while (current != null) {         Shard s = shards.remove(current).         if (s == null) {             current = null.         } else {             removedShards++.             current = s.getParentShardId().         }     }     log.trace("removed {} shards from the store, new size is {}", removedShards, shards.size()). }
false;public;0;4;;@Override public String toString() {     return "ShardList{" + "shards=" + shards + '}'. }
false;public;2;6;;@Override public int compare(Shard o1, Shard o2) {     BigInteger i1 = new BigInteger(o1.getSequenceNumberRange().getStartingSequenceNumber()).     BigInteger i2 = new BigInteger(o2.getSequenceNumberRange().getStartingSequenceNumber()).     return i1.compareTo(i2). }
