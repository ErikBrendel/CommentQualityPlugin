commented;modifiers;parameterAmount;loc;comment;code
false;public;0;14;;@Test public void testDisruptorConcurrentInOnly() throws Exception {     final MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMessageCount(20).     // should at least take 3 sec     mock.setResultMinimumWaitTime(3000).     for (int i = 0. i < 20. i++) {         template.sendBody("disruptor:foo", "Message " + i).     }     assertMockEndpointsSatisfied(). }
false;public;0;14;;@Test public void testDisruptorConcurrentInOnlyWithAsync() throws Exception {     final MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMessageCount(20).     // should at least take 3 sec     mock.setResultMinimumWaitTime(3000).     for (int i = 0. i < 20. i++) {         template.asyncSendBody("disruptor:foo", "Message " + i).     }     assertMockEndpointsSatisfied(). }
false;public;0;4;;@Override public Object call() throws Exception {     return template.requestBody("disruptor:bar", "Message " + num). }
false;public;0;27;;@Test public void testDisruptorConcurrentInOut() throws Exception {     final MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMessageCount(20).     mock.allMessages().body().startsWith("Bye").     // should at least take 3 sec     mock.setResultMinimumWaitTime(3000).     final ExecutorService executors = Executors.newFixedThreadPool(10).     final List<Object> replies = new ArrayList<>(20).     for (int i = 0. i < 20. i++) {         final int num = i.         final Object out = executors.submit(new Callable<Object>() {              @Override             public Object call() throws Exception {                 return template.requestBody("disruptor:bar", "Message " + num).             }         }).         replies.add(out).     }     assertMockEndpointsSatisfied().     assertEquals(20, replies.size()).     executors.shutdownNow(). }
false;public;0;31;;@Test public void testDisruptorConcurrentInOutWithAsync() throws Exception {     final MockEndpoint mock = getMockEndpoint("mock:result").     mock.expectedMessageCount(20).     mock.allMessages().body().startsWith("Bye").     // should at least take 3 sec     mock.setResultMinimumWaitTime(3000).     // use our own template that has a higher thread pool than default camel that uses 5     final ExecutorService executor = Executors.newFixedThreadPool(10).     final ProducerTemplate pt = new DefaultProducerTemplate(context, executor).     // must start the template     pt.start().     final List<Future<Object>> replies = new ArrayList<>(20).     for (int i = 0. i < 20. i++) {         final Future<Object> out = pt.asyncRequestBody("disruptor:bar", "Message " + i).         replies.add(out).     }     assertMockEndpointsSatisfied().     assertEquals(20, replies.size()).     for (int i = 0. i < 20. i++) {         final String out = (String) replies.get(i).get().         assertTrue(out.startsWith("Bye")).     }     pt.stop().     executor.shutdownNow(). }
false;public;0;7;;@Override public void configure() throws Exception {     from("disruptor:foo?concurrentConsumers=10").to("mock:before").delay(2000).syncDelayed().to("mock:result").     from("disruptor:bar?concurrentConsumers=10").to("mock:before").delay(2000).syncDelayed().transform(body().prepend("Bye ")).to("mock:result"). }
false;protected;0;12;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             from("disruptor:foo?concurrentConsumers=10").to("mock:before").delay(2000).syncDelayed().to("mock:result").             from("disruptor:bar?concurrentConsumers=10").to("mock:before").delay(2000).syncDelayed().transform(body().prepend("Bye ")).to("mock:result").         }     }. }
