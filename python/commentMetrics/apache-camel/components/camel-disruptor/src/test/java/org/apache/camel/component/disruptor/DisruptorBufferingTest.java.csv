commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public void configure() throws Exception {     from("disruptor:foo").routeId("bar").to("mock:bar"). }
false;public;0;25;;@Test public void testDisruptorBufferingWhileWaitingOnFirstConsumer() throws Exception {     template.sendBody("disruptor:foo", "A").     template.sendBody("disruptor:foo", "B").     template.sendBody("disruptor:foo", "C").     final DisruptorEndpoint disruptorEndpoint = getMandatoryEndpoint("disruptor:foo", DisruptorEndpoint.class).     assertEquals(5, disruptorEndpoint.getDisruptor().getRemainingCapacity()).     // Add a first consumer on the endpoint     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             from("disruptor:foo").routeId("bar").to("mock:bar").         }     }).     // Now that we have a consumer, the disruptor should send the buffered     // events downstream. Expect to receive the 3 original exchanges.     final MockEndpoint mockEndpoint = getMockEndpoint("mock:bar").     mockEndpoint.expectedMessageCount(3).     mockEndpoint.assertIsSatisfied(200). }
false;public;0;4;;@Override public void configure() throws Exception {     from("disruptor:foo").routeId("bar1").delay(200).to("mock:bar"). }
false;public;0;4;;@Override public void configure() throws Exception {     from("disruptor:foo").routeId("bar2").to("mock:bar"). }
false;public;0;51;;@Test public void testDisruptorBufferingWhileWaitingOnNextConsumer() throws Exception {     template.sendBody("disruptor:foo", "A").     template.sendBody("disruptor:foo", "B").     template.sendBody("disruptor:foo", "C").     final DisruptorEndpoint disruptorEndpoint = getMandatoryEndpoint("disruptor:foo", DisruptorEndpoint.class).     assertEquals(5, disruptorEndpoint.getDisruptor().getRemainingCapacity()).     // Add a first consumer on the endpoint     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             from("disruptor:foo").routeId("bar1").delay(200).to("mock:bar").         }     }).     // Now that we have a consumer, the disruptor should send the buffered     // events downstream. Wait until we have processed at least one     // exchange.     MockEndpoint mockEndpoint = getMockEndpoint("mock:bar").     mockEndpoint.expectedMinimumMessageCount(1).     mockEndpoint.assertIsSatisfied(200).     // Stop route and make sure all exchanges have been flushed.     context.getRouteController().stopRoute("bar1").     mockEndpoint.expectedMessageCount(3).     mockEndpoint.assertIsSatisfied().     resetMocks().     template.sendBody("disruptor:foo", "D").     template.sendBody("disruptor:foo", "E").     template.sendBody("disruptor:foo", "F").     // Add a new consumer on the endpoint     context.addRoutes(new RouteBuilder() {          @Override         public void configure() throws Exception {             from("disruptor:foo").routeId("bar2").to("mock:bar").         }     }).     template.sendBody("disruptor:foo", "G").     // Make sure we have received the 3 buffered exchanges plus the one     // added late.     mockEndpoint = getMockEndpoint("mock:bar").     mockEndpoint.expectedMessageCount(4).     mockEndpoint.assertIsSatisfied(100). }
false;public;0;4;;@Override public void configure() throws Exception {     from("direct:start").routeId("foo").to("disruptor:foo?size=8"). }
false;protected;0;10;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             from("direct:start").routeId("foo").to("disruptor:foo?size=8").         }     }. }
