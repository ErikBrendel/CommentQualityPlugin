commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;17;;@BeforeClass public static void legend() {     System.out.println("-----------------------").     System.out.println("- Tests output legend -").     System.out.println("-----------------------").     System.out.println("P: Number of concurrent Producer(s) sharing the load for publishing exchanges to the disruptor.").     System.out.println("C: Number of Consumer(s) receiving a copy of each exchange from the disruptor (pub/sub).").     System.out.println("CCT: Number of ConcurrentConsumerThreads sharing the load for consuming exchanges from the disruptor.").     System.out.println("SIZE: Maximum number of elements a SEDA or disruptor endpoint can have in memory before blocking the Producer thread(s).").     System.out.println("      0 means default value, so unbounded for SEDA and 1024 for disruptor.").     System.out.println("Each test is creating " + SPEED_TEST_EXCHANGE_COUNT + " exchanges.").     System.out.println(). }
false;private,static;2;8;;private static long[] generateLinearHistogramBounds(final int maxValue, final int nbSlots) {     final long slotSize = maxValue / nbSlots.     final long[] bounds = new long[nbSlots].     for (int i = 0. i < nbSlots. i++) {         bounds[i] = slotSize * (i + 1).     }     return bounds. }
false;private,static;0;3;;private static int singleProducer() {     return 1. }
false;private,static;0;3;;private static int multipleProducers() {     return 4. }
false;private,static;0;3;;private static int singleConsumer() {     return 1. }
false;private,static;0;3;;private static int multipleConsumers() {     return 4. }
false;private,static;0;3;;private static int singleConcurrentConsumerThread() {     return 1. }
false;private,static;0;3;;private static int multipleConcurrentConsumerThreads() {     return 2. }
false;public,static;0;36;;@Parameterized.Parameters(name = "{index}: {0}") public static Collection<Object[]> parameters() {     final List<Object[]> parameters = new ArrayList<>().     // before the debug() call to only evaluate the args when required: if(log.isDebugEnabled())...     if (SIZE_PARAMETER_VALUE == 0) {         parameters.add(new Object[] { "SEDA LONG {P=1, C=1, CCT=1, SIZE=0}", "seda:speedtest?concurrentConsumers=1&waitForTaskToComplete=IfReplyExpected&timeout=30000&multipleConsumers=false&limitConcurrentConsumers=true&blockWhenFull=false", singleProducer(), singleConsumer(), singleConcurrentConsumerThread(), SEDA_SIZE_HISTOGRAM_BOUNDS }).     } else {         parameters.add(new Object[] { "SEDA LONG {P=1, C=1, CCT=1, SIZE=" + SIZE_PARAMETER_VALUE + "}", "seda:speedtest?concurrentConsumers=1&waitForTaskToComplete=IfReplyExpected&timeout=30000&multipleConsumers=false&limitConcurrentConsumers=true&blockWhenFull=true&size=" + SIZE_PARAMETER_VALUE, singleProducer(), singleConsumer(), singleConcurrentConsumerThread(), SEDA_SIZE_HISTOGRAM_BOUNDS }).     }     addParameterPair(parameters, singleProducer(), singleConsumer(), singleConcurrentConsumerThread()).     addParameterPair(parameters, singleProducer(), singleConsumer(), multipleConcurrentConsumerThreads()).     addParameterPair(parameters, singleProducer(), multipleConsumers(), singleConcurrentConsumerThread()).     addParameterPair(parameters, singleProducer(), multipleConsumers(), multipleConcurrentConsumerThreads()).     addParameterPair(parameters, multipleProducers(), singleConsumer(), singleConcurrentConsumerThread()).     addParameterPair(parameters, multipleProducers(), singleConsumer(), multipleConcurrentConsumerThreads()).     addParameterPair(parameters, multipleProducers(), multipleConsumers(), singleConcurrentConsumerThread()).     addParameterPair(parameters, multipleProducers(), multipleConsumers(), multipleConcurrentConsumerThreads()).     return parameters. }
false;private,static;4;40;;private static void addParameterPair(final List<Object[]> parameters, final int producers, final int consumers, final int parallelConsumerThreads) {     final String multipleConsumerOption = consumers > 1 ? "multipleConsumers=true" : "".     final String concurrentConsumerOptions = parallelConsumerThreads > 1 ? "concurrentConsumers=" + parallelConsumerThreads : "".     final String sizeOption = SIZE_PARAMETER_VALUE > 0 ? "size=" + SIZE_PARAMETER_VALUE : "".     final String sizeOptionSeda = SIZE_PARAMETER_VALUE > 0 ? "&blockWhenFull=true" : "".     String options = "".     if (!multipleConsumerOption.isEmpty()) {         if (!options.isEmpty()) {             options += "&".         }         options += multipleConsumerOption.     }     if (!concurrentConsumerOptions.isEmpty()) {         if (!options.isEmpty()) {             options += "&".         }         options += concurrentConsumerOptions.     }     if (!sizeOption.isEmpty()) {         if (!options.isEmpty()) {             options += "&".         }         options += sizeOption.     }     if (!options.isEmpty()) {         options = "?" + options.     }     final String sedaOptions = sizeOptionSeda.isEmpty() ? options : options + sizeOptionSeda.     // Using { ... } because there is a bug in JUnit 4.11 and Eclipse: https://bugs.eclipse.org/bugs/show_bug.cgi?id=102512     final String testDescription = " { P=" + producers + ", C=" + consumers + ", CCT=" + parallelConsumerThreads + ", SIZE=" + SIZE_PARAMETER_VALUE + " }".     parameters.add(new Object[] { "SEDA" + testDescription, "seda:speedtest" + sedaOptions, producers, consumers, parallelConsumerThreads, SEDA_SIZE_HISTOGRAM_BOUNDS }).     parameters.add(new Object[] { "Disruptor" + testDescription, "disruptor:speedtest" + options, producers, consumers, parallelConsumerThreads, DISRUPTOR_SIZE_HISTOGRAM_BOUNDS }). }
false;public;0;13;;@Test public void speedTestDisruptor() throws InterruptedException {     System.out.println("Warming up for test of: " + componentName).     performTest(true).     System.out.println("Starting real test of: " + componentName).     forceGC().     Thread.sleep(1000).     performTest(false). }
false;private;0;6;;private void forceGC() {     // unfortunately there is no nice API that forces the Garbage collector to run, but it may consider our request     // more seriously if we ask it twice :)     System.gc().     System.gc(). }
false;private;0;5;;private void resetExchangeAwaiters() {     for (final ExchangeAwaiter exchangeAwaiter : exchangeAwaiters) {         exchangeAwaiter.reset().     } }
false;private;0;9;;private void awaitExchangeAwaiters() throws InterruptedException {     for (final ExchangeAwaiter exchangeAwaiter : exchangeAwaiters) {         while (!exchangeAwaiter.awaitMessagesReceived(10, TimeUnit.SECONDS)) {             System.err.println("Processing takes longer then expected: " + componentName + " " + exchangeAwaiter.getStatus()).         }     } }
false;private;1;9;;private void outputExchangeAwaitersResult(final long start) throws InterruptedException {     for (final ExchangeAwaiter exchangeAwaiter : exchangeAwaiters) {         final long stop = exchangeAwaiter.getCountDownReachedTime().         final Histogram histogram = exchangeAwaiter.getLatencyHistogram().         System.out.printf("%-45s time spent = %5d ms.%n", componentName, stop - start).         histogram.outputPercentileDistribution(System.out, 1, 1000.0).     } }
false;private;1;25;;private void performTest(final boolean warmup) throws InterruptedException {     resetExchangeAwaiters().     final ProducerThread[] producerThread = new ProducerThread[amountProducers].     for (int i = 0. i < producerThread.length. ++i) {         producerThread[i] = new ProducerThread(SPEED_TEST_EXCHANGE_COUNT / amountProducers).     }     ExecutorService monitoring = null.     if (!warmup) {         monitoring = installSizeMonitoring(context.getEndpoint(endpointUri)).     }     final long start = System.currentTimeMillis().     for (ProducerThread element : producerThread) {         element.start().     }     awaitExchangeAwaiters().     if (!warmup) {         outputExchangeAwaitersResult(start).         uninstallSizeMonitoring(monitoring).     } }
false;public;0;17;;@Override public void run() {     if (endpoint instanceof SedaEndpoint) {         final SedaEndpoint sedaEndpoint = (SedaEndpoint) endpoint.         endpointSizeQueue.offer(sedaEndpoint.getCurrentQueueSize()).     } else if (endpoint instanceof DisruptorEndpoint) {         final DisruptorEndpoint disruptorEndpoint = (DisruptorEndpoint) endpoint.         long remainingCapacity = 0.         try {             remainingCapacity = disruptorEndpoint.getRemainingCapacity().         } catch (DisruptorNotStartedException e) {         // ignore         }         endpointSizeQueue.offer((int) (disruptorEndpoint.getBufferSize() - remainingCapacity)).     } }
false;private;1;26;;private ExecutorService installSizeMonitoring(final Endpoint endpoint) {     final ScheduledExecutorService service = context.getExecutorServiceManager().newScheduledThreadPool(this, "SizeMonitoringThread", 1).     endpointSizeQueue.clear().     final Runnable monitoring = new Runnable() {          @Override         public void run() {             if (endpoint instanceof SedaEndpoint) {                 final SedaEndpoint sedaEndpoint = (SedaEndpoint) endpoint.                 endpointSizeQueue.offer(sedaEndpoint.getCurrentQueueSize()).             } else if (endpoint instanceof DisruptorEndpoint) {                 final DisruptorEndpoint disruptorEndpoint = (DisruptorEndpoint) endpoint.                 long remainingCapacity = 0.                 try {                     remainingCapacity = disruptorEndpoint.getRemainingCapacity().                 } catch (DisruptorNotStartedException e) {                 // ignore                 }                 endpointSizeQueue.offer((int) (disruptorEndpoint.getBufferSize() - remainingCapacity)).             }         }     }.     service.scheduleAtFixedRate(monitoring, 0, 100, TimeUnit.MILLISECONDS).     return service. }
false;private;1;10;;private void uninstallSizeMonitoring(final ExecutorService monitoring) {     if (monitoring != null) {         monitoring.shutdownNow().     }     final Histogram histogram = new Histogram(sizeHistogramBounds[sizeHistogramBounds.length - 1], 4).     for (final int observation : endpointSizeQueue) {         histogram.recordValue(observation).     }     System.out.printf("%82s %s%n", "Endpoint size (# exchanges pending):", histogram.toString()). }
false;public;0;6;;@Override public void configure() throws Exception {     for (final ExchangeAwaiter exchangeAwaiter : exchangeAwaiters) {         from(endpointUri).process(exchangeAwaiter).     } }
false;protected;0;11;;@Override protected RouteBuilder createRouteBuilder() throws Exception {     return new RouteBuilder() {          @Override         public void configure() throws Exception {             for (final ExchangeAwaiter exchangeAwaiter : exchangeAwaiters) {                 from(endpointUri).process(exchangeAwaiter).             }         }     }. }
false;public;0;5;;public void reset() {     latencyQueue = new ConcurrentLinkedQueue<>().     latch = new CountDownLatch(count).     countDownReachedTime = 0. }
false;public;2;3;;public boolean awaitMessagesReceived(final long timeout, final TimeUnit unit) throws InterruptedException {     return latch.await(timeout, unit). }
false;public;0;10;;public String getStatus() {     final StringBuilder sb = new StringBuilder(100).     sb.append("processed ").     sb.append(count - latch.getCount()).     sb.append('/').     sb.append(count).     sb.append(" messages").     return sb.toString(). }
false;public;1;8;;@Override public void process(final Exchange exchange) throws Exception {     final long sentTimeNs = exchange.getIn().getBody(Long.class).     latencyQueue.offer(Long.valueOf(System.nanoTime() - sentTimeNs)).     countDownReachedTime = System.currentTimeMillis().     latch.countDown(). }
false;public;0;9;;public long getCountDownReachedTime() {     // Make sure we wait until all exchanges have been processed. Otherwise the time value doesn't make sense.     try {         latch.await().     } catch (InterruptedException e) {         countDownReachedTime = 0.     }     return countDownReachedTime. }
false;public;0;7;;public Histogram getLatencyHistogram() {     final Histogram histogram = new Histogram(LATENCY_HISTOGRAM_BOUNDS[LATENCY_HISTOGRAM_BOUNDS.length - 1], 4).     for (final Long latencyValue : latencyQueue) {         histogram.recordValue(latencyValue / 1000000).     }     return histogram. }
false;public;0;6;;public void run() {     final Endpoint endpoint = context().getEndpoint(endpointUri).     while (producedMessageCount++ < totalMessageCount) {         producerTemplate.sendBody(endpoint, ExchangePattern.InOnly, System.nanoTime()).     } }
