commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean hasNullReference() {     return disruptor.getReference() == null. }
false;private;0;23;;private Disruptor<ExchangeEvent> getCurrentDisruptor() throws DisruptorNotStartedException {     Disruptor<ExchangeEvent> currentDisruptor = disruptor.getReference().     if (currentDisruptor == null) {         // no current Disruptor reference, we may be reconfiguring or it was not started         // check which by looking at the reference mark...         boolean[] changeIsPending = new boolean[1].         while (currentDisruptor == null) {             currentDisruptor = disruptor.get(changeIsPending).             // Check if we are reconfiguring             if (currentDisruptor == null && !changeIsPending[0]) {                 throw new DisruptorNotStartedException("Disruptor is not yet started or already shut down.").             } else if (currentDisruptor == null && changeIsPending[0]) {                 // We should be back shortly...keep trying but spare CPU resources                 LockSupport.parkNanos(1L).             }         }     }     return currentDisruptor. }
false;public;1;3;;public void tryPublish(final Exchange exchange) throws DisruptorNotStartedException, InsufficientCapacityException {     tryPublishExchangeOnRingBuffer(exchange, getCurrentDisruptor().getRingBuffer()). }
false;public;1;3;;public void publish(final Exchange exchange) throws DisruptorNotStartedException {     publishExchangeOnRingBuffer(exchange, getCurrentDisruptor().getRingBuffer()). }
false;private;2;6;;private void publishExchangeOnRingBuffer(final Exchange exchange, final RingBuffer<ExchangeEvent> ringBuffer) {     final long sequence = ringBuffer.next().     ringBuffer.get(sequence).setExchange(exchange, uniqueConsumerCount).     ringBuffer.publish(sequence). }
false;private;2;5;;private void tryPublishExchangeOnRingBuffer(final Exchange exchange, final RingBuffer<ExchangeEvent> ringBuffer) throws InsufficientCapacityException {     final long sequence = ringBuffer.tryNext().     ringBuffer.get(sequence).setExchange(exchange, uniqueConsumerCount).     ringBuffer.publish(sequence). }
false;public,synchronized;0;6;;public synchronized void reconfigure() throws Exception {     LOGGER.debug("Reconfiguring disruptor {}", this).     shutdownDisruptor(true).     start(). }
false;private;0;36;;private void start() throws Exception {     LOGGER.debug("Starting disruptor {}", this).     Disruptor<ExchangeEvent> newDisruptor = createDisruptor().     newDisruptor.start().     if (executor != null) {         // and use our delayed executor to really really execute the event handlers now         delayedExecutor.executeDelayedCommands(executor).     }     // make sure all event handlers are correctly started before we continue     for (final LifecycleAwareExchangeEventHandler handler : handlers) {         boolean eventHandlerStarted = false.         while (!eventHandlerStarted) {             try {                 // switching a latch and we want to await that latch here to make sure they are started.                 if (!handler.awaitStarted(10, TimeUnit.SECONDS)) {                     // we wait for a relatively long, but limited amount of time to prevent an application using                     // this component from hanging indefinitely                     // Please report a bug if you can reproduce this                     LOGGER.error("Disruptor/event handler failed to start properly, PLEASE REPORT").                 }                 eventHandlerStarted = true.             } catch (InterruptedException e) {             // just retry             }         }     }     publishBufferedExchanges(newDisruptor).     disruptor.set(newDisruptor, false). }
false;private;0;31;;private Disruptor<ExchangeEvent> createDisruptor() throws Exception {     // create a new Disruptor     final Disruptor<ExchangeEvent> newDisruptor = new Disruptor<>(ExchangeEventFactory.INSTANCE, size, delayedExecutor, producerType.getProducerType(), waitStrategy.createWaitStrategyInstance()).     // determine the list of eventhandlers to be associated to the Disruptor     final ArrayList<LifecycleAwareExchangeEventHandler> eventHandlers = new ArrayList<>().     uniqueConsumerCount = 0.     for (final DisruptorEndpoint endpoint : endpoints) {         final Map<DisruptorConsumer, Collection<LifecycleAwareExchangeEventHandler>> consumerEventHandlers = endpoint.createConsumerEventHandlers().         if (consumerEventHandlers != null) {             uniqueConsumerCount += consumerEventHandlers.keySet().size().             for (Collection<LifecycleAwareExchangeEventHandler> lifecycleAwareExchangeEventHandlers : consumerEventHandlers.values()) {                 eventHandlers.addAll(lifecycleAwareExchangeEventHandlers).             }         }     }     LOGGER.debug("Disruptor created with {} event handlers", eventHandlers.size()).     handleEventsWith(newDisruptor, eventHandlers.toArray(new LifecycleAwareExchangeEventHandler[eventHandlers.size()])).     return newDisruptor. }
false;private;2;11;;private void handleEventsWith(Disruptor<ExchangeEvent> newDisruptor, final LifecycleAwareExchangeEventHandler[] newHandlers) {     if (newHandlers == null || newHandlers.length == 0) {         handlers = new LifecycleAwareExchangeEventHandler[1].         handlers[0] = new BlockingExchangeEventHandler().     } else {         handlers = newHandlers.     }     resizeThreadPoolExecutor(handlers.length).     newDisruptor.handleEventsWith(handlers). }
false;private;1;12;;private void publishBufferedExchanges(Disruptor<ExchangeEvent> newDisruptor) {     // now empty out all buffered Exchange if we had any     final List<Exchange> exchanges = new ArrayList<>(temporaryExchangeBuffer.size()).     while (!temporaryExchangeBuffer.isEmpty()) {         exchanges.add(temporaryExchangeBuffer.remove()).     }     RingBuffer<ExchangeEvent> ringBuffer = newDisruptor.getRingBuffer().     // and offer them again to our new ringbuffer     for (final Exchange exchange : exchanges) {         publishExchangeOnRingBuffer(exchange, ringBuffer).     } }
false;private;1;34;;private void resizeThreadPoolExecutor(final int newSize) {     if (executor == null && newSize > 0) {         LOGGER.debug("Creating new executor with {} threads", newSize).         // no thread pool executor yet, create a new one         executor = component.getCamelContext().getExecutorServiceManager().newFixedThreadPool(this, uri, newSize).     } else if (executor != null && newSize <= 0) {         LOGGER.debug("Shutting down executor").         // we need to shut down our executor         component.getCamelContext().getExecutorServiceManager().shutdown(executor).         executor = null.     } else if (executor instanceof ThreadPoolExecutor) {         LOGGER.debug("Resizing existing executor to {} threads", newSize).         // our thread pool executor is of type ThreadPoolExecutor, we know how to resize it         final ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executor.         // for more information         if (newSize <= threadPoolExecutor.getCorePoolSize()) {             threadPoolExecutor.setCorePoolSize(newSize).             threadPoolExecutor.setMaximumPoolSize(newSize).         } else {             threadPoolExecutor.setMaximumPoolSize(newSize).             threadPoolExecutor.setCorePoolSize(newSize).         }     } else if (newSize > 0) {         LOGGER.debug("Shutting down old and creating new executor with {} threads", newSize).         // hmmm...no idea what kind of executor this is...just kill it and start fresh         component.getCamelContext().getExecutorServiceManager().shutdown(executor).         executor = component.getCamelContext().getExecutorServiceManager().newFixedThreadPool(this, uri, newSize).     } }
false;private,synchronized;1;43;;private synchronized void shutdownDisruptor(boolean isReconfiguring) {     LOGGER.debug("Shutting down disruptor {}, reconfiguring: {}", this, isReconfiguring).     Disruptor<ExchangeEvent> currentDisruptor = disruptor.getReference().     disruptor.set(null, isReconfiguring).     if (currentDisruptor != null) {         // check if we had a blocking event handler to keep an empty disruptor 'busy'         if (handlers != null && handlers.length == 1 && handlers[0] instanceof BlockingExchangeEventHandler) {             // yes we did, unblock it so we can get rid of our backlog,             // The eventhandler will empty its pending exchanges in our temporary buffer             final BlockingExchangeEventHandler blockingExchangeEventHandler = (BlockingExchangeEventHandler) handlers[0].             blockingExchangeEventHandler.unblock().         }         currentDisruptor.shutdown().         // we do however want to await their completion before they are scheduled to process events from the new         for (final LifecycleAwareExchangeEventHandler eventHandler : handlers) {             boolean eventHandlerFinished = false.             // the disruptor is now empty and all consumers are either done or busy processing their last exchange             while (!eventHandlerFinished) {                 try {                     // switching a latch and we want to await that latch here to make sure they are done.                     if (!eventHandler.awaitStopped(10, TimeUnit.SECONDS)) {                         // we wait for a relatively long, but limited amount of time to prevent an application using                         // this component from hanging indefinitely                         // Please report a bug if you can repruduce this                         LOGGER.error("Disruptor/event handler failed to shut down properly, PLEASE REPORT").                     }                     eventHandlerFinished = true.                 } catch (InterruptedException e) {                 // just retry                 }             }         }         handlers = new LifecycleAwareExchangeEventHandler[0].     } }
false;private,synchronized;0;3;;private synchronized void shutdownExecutor() {     resizeThreadPoolExecutor(0). }
false;public;0;3;;public String getName() {     return name. }
false;public;0;3;;public long getRemainingCapacity() throws DisruptorNotStartedException {     return getCurrentDisruptor().getRingBuffer().remainingCapacity(). }
false;public;0;3;;public DisruptorWaitStrategy getWaitStrategy() {     return waitStrategy. }
false;;0;3;;DisruptorProducerType getProducerType() {     return producerType. }
false;public;0;3;;public int getBufferSize() {     return size. }
false;public;0;10;;public int getPendingExchangeCount() {     try {         if (!hasNullReference()) {             return (int) (getBufferSize() - getRemainingCapacity() + temporaryExchangeBuffer.size()).         }     } catch (DisruptorNotStartedException e) {     // fall through...     }     return temporaryExchangeBuffer.size(). }
false;public,synchronized;1;5;;public synchronized void addEndpoint(final DisruptorEndpoint disruptorEndpoint) {     LOGGER.debug("Adding Endpoint: " + disruptorEndpoint).     endpoints.add(disruptorEndpoint).     LOGGER.debug("Endpoint added: {}, new total endpoints {}", disruptorEndpoint, endpoints.size()). }
false;public,synchronized;1;13;;public synchronized void removeEndpoint(final DisruptorEndpoint disruptorEndpoint) {     LOGGER.debug("Removing Endpoint: " + disruptorEndpoint).     if (getEndpointCount() == 1) {         LOGGER.debug("Last Endpoint removed, shutdown disruptor").         // Shutdown our disruptor         shutdownDisruptor(false).         // As there are no endpoints dependent on this Disruptor, we may also shutdown our executor         shutdownExecutor().     }     endpoints.remove(disruptorEndpoint).     LOGGER.debug("Endpoint removed: {}, new total endpoints {}", disruptorEndpoint, getEndpointCount()). }
false;public,synchronized;0;3;;public synchronized int getEndpointCount() {     return endpoints.size(). }
false;public;0;5;;@Override public String toString() {     return "DisruptorReference{" + "uri='" + uri + '\'' + ", endpoint count=" + endpoints.size() + ", handler count=" + handlers.length + '}'. }
false;public;3;12;;@Override public void onEvent(final ExchangeEvent event, final long sequence, final boolean endOfBatch) throws Exception {     blockingLatch.await().     final Exchange exchange = event.getSynchronizedExchange().cancelAndGetOriginalExchange().     if (exchange.getProperty(DisruptorEndpoint.DISRUPTOR_IGNORE_EXCHANGE, false, boolean.class)) {         // Property was set and it was set to true, so don't process Exchange.         LOGGER.trace("Ignoring exchange {}", exchange).     } else {         temporaryExchangeBuffer.offer(exchange).     } }
false;public;0;3;;public void unblock() {     blockingLatch.countDown(). }
false;public;1;4;;@Override public void execute(final Runnable command) {     delayedCommands.offer(command). }
false;public;1;7;;public void executeDelayedCommands(final Executor actualExecutor) {     Runnable command.     while ((command = delayedCommands.poll()) != null) {         actualExecutor.execute(command).     } }
