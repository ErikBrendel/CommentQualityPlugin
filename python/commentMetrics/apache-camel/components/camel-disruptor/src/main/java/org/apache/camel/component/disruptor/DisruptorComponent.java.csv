commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;45;;@Override protected Endpoint createEndpoint(final String uri, final String remaining, final Map<String, Object> parameters) throws Exception {     final int concurrentConsumers = getAndRemoveParameter(parameters, "concurrentConsumers", Integer.class, defaultConcurrentConsumers).     final boolean limitConcurrentConsumers = getAndRemoveParameter(parameters, "limitConcurrentConsumers", Boolean.class, true).     if (limitConcurrentConsumers && concurrentConsumers > MAX_CONCURRENT_CONSUMERS) {         throw new IllegalArgumentException("The limitConcurrentConsumers flag in set to true. ConcurrentConsumers cannot be set at a value greater than " + MAX_CONCURRENT_CONSUMERS + " was " + concurrentConsumers).     }     if (concurrentConsumers < 0) {         throw new IllegalArgumentException("concurrentConsumers found to be " + concurrentConsumers + ", must be greater than 0").     }     int size = 0.     if (parameters.containsKey("size")) {         size = getAndRemoveParameter(parameters, "size", int.class).         if (size <= 0) {             throw new IllegalArgumentException("size found to be " + size + ", must be greater than 0").         }     }     // replacement for the SEDA component.     if (parameters.containsKey("pollTimeout")) {         throw new IllegalArgumentException("The 'pollTimeout' argument is not supported by the Disruptor component").     }     final DisruptorWaitStrategy waitStrategy = getAndRemoveParameter(parameters, "waitStrategy", DisruptorWaitStrategy.class, defaultWaitStrategy).     final DisruptorProducerType producerType = getAndRemoveParameter(parameters, "producerType", DisruptorProducerType.class, defaultProducerType).     final boolean multipleConsumers = getAndRemoveParameter(parameters, "multipleConsumers", boolean.class, defaultMultipleConsumers).     final boolean blockWhenFull = getAndRemoveParameter(parameters, "blockWhenFull", boolean.class, defaultBlockWhenFull).     final DisruptorReference disruptorReference = getOrCreateDisruptor(uri, remaining, size, producerType, waitStrategy).     final DisruptorEndpoint disruptorEndpoint = new DisruptorEndpoint(uri, this, disruptorReference, concurrentConsumers, multipleConsumers, blockWhenFull).     disruptorEndpoint.setWaitStrategy(waitStrategy).     disruptorEndpoint.setProducerType(producerType).     disruptorEndpoint.configureProperties(parameters).     return disruptorEndpoint. }
false;private;5;37;;private DisruptorReference getOrCreateDisruptor(final String uri, final String name, final int size, final DisruptorProducerType producerType, final DisruptorWaitStrategy waitStrategy) throws Exception {     final String key = getDisruptorKey(uri).     int sizeToUse.     if (size > 0) {         sizeToUse = size.     } else if (bufferSize > 0) {         sizeToUse = bufferSize.     } else if (queueSize > 0) {         sizeToUse = queueSize.     } else {         sizeToUse = DEFAULT_BUFFER_SIZE.     }     sizeToUse = powerOfTwo(sizeToUse).     synchronized (this) {         DisruptorReference ref = getDisruptors().get(key).         if (ref == null) {             LOGGER.debug("Creating new disruptor for key {}", key).             ref = new DisruptorReference(this, uri, name, sizeToUse, producerType, waitStrategy).             getDisruptors().put(key, ref).         } else {             // if size was explicitly requested, the size to use should match the retrieved DisruptorReference             if (size != 0 && ref.getBufferSize() != sizeToUse) {                 // there is already a queue, so make sure the size matches                 throw new IllegalArgumentException("Cannot use existing queue " + key + " as the existing queue size " + ref.getBufferSize() + " does not match given queue size " + sizeToUse).             }             LOGGER.debug("Reusing disruptor {} for key {}", ref, key).         }         return ref.     } }
false;private,static;1;10;;private static int powerOfTwo(int size) {     size--.     size |= size >> 1.     size |= size >> 2.     size |= size >> 4.     size |= size >> 8.     size |= size >> 16.     size++.     return size. }
false;public,static;1;7;;public static String getDisruptorKey(String uri) {     if (uri.contains("?")) {         // strip parameters         uri = uri.substring(0, uri.indexOf('?')).     }     return uri. }
false;protected;0;7;;@Override protected void doStop() throws Exception {     synchronized (this) {         getDisruptors().clear().     }     super.doStop(). }
false;public;0;3;;public Map<String, DisruptorReference> getDisruptors() {     return disruptors. }
false;public;0;3;;public int getDefaultConcurrentConsumers() {     return defaultConcurrentConsumers. }
true;public;1;3;/**  * To configure the default number of concurrent consumers  */ ;/**  * To configure the default number of concurrent consumers  */ public void setDefaultConcurrentConsumers(final int defaultConcurrentConsumers) {     this.defaultConcurrentConsumers = defaultConcurrentConsumers. }
false;public;0;3;;public boolean isDefaultMultipleConsumers() {     return defaultMultipleConsumers. }
true;public;1;3;/**  * To configure the default value for multiple consumers  */ ;/**  * To configure the default value for multiple consumers  */ public void setDefaultMultipleConsumers(final boolean defaultMultipleConsumers) {     this.defaultMultipleConsumers = defaultMultipleConsumers. }
false;public;0;3;;public DisruptorProducerType getDefaultProducerType() {     return defaultProducerType. }
true;public;1;3;/**  * To configure the default value for DisruptorProducerType  * <p/>  * The default value is Multi.  */ ;/**  * To configure the default value for DisruptorProducerType  * <p/>  * The default value is Multi.  */ public void setDefaultProducerType(final DisruptorProducerType defaultProducerType) {     this.defaultProducerType = defaultProducerType. }
false;public;0;3;;public DisruptorWaitStrategy getDefaultWaitStrategy() {     return defaultWaitStrategy. }
true;public;1;3;/**  * To configure the default value for DisruptorWaitStrategy  * <p/>  * The default value is Blocking.  */ ;/**  * To configure the default value for DisruptorWaitStrategy  * <p/>  * The default value is Blocking.  */ public void setDefaultWaitStrategy(final DisruptorWaitStrategy defaultWaitStrategy) {     this.defaultWaitStrategy = defaultWaitStrategy. }
false;public;0;3;;public boolean isDefaultBlockWhenFull() {     return defaultBlockWhenFull. }
true;public;1;3;/**  * To configure the default value for block when full  * <p/>  * The default value is true.  */ ;/**  * To configure the default value for block when full  * <p/>  * The default value is true.  */ public void setDefaultBlockWhenFull(boolean defaultBlockWhenFull) {     this.defaultBlockWhenFull = defaultBlockWhenFull. }
true;public;1;4;/**  * To configure the ring buffer size  */ ;/**  * To configure the ring buffer size  */ @Deprecated public void setQueueSize(final int size) {     queueSize = size. }
false;public;0;4;;@Deprecated public int getQueueSize() {     return queueSize. }
true;public;1;3;/**  * To configure the ring buffer size  */ ;/**  * To configure the ring buffer size  */ public void setBufferSize(final int size) {     bufferSize = size. }
false;public;0;3;;public int getBufferSize() {     return bufferSize. }
false;public;1;9;;public void onShutdownEndpoint(DisruptorEndpoint disruptorEndpoint) {     String disruptorKey = getDisruptorKey(disruptorEndpoint.getEndpointUri()).     DisruptorReference disruptorReference = getDisruptors().get(disruptorKey).     if (disruptorReference.getEndpointCount() == 0) {         // the last disruptor has been removed, we can delete the disruptor         getDisruptors().remove(disruptorKey).     } }
