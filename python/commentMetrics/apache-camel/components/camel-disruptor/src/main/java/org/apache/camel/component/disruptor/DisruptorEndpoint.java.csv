commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@ManagedAttribute(description = "Queue name") public String getName() {     return name. }
false;public;0;4;;@ManagedAttribute(description = "Buffer max capacity") public int getBufferSize() {     return disruptorReference.getBufferSize(). }
false;public;0;4;;@ManagedAttribute(description = "Remaining capacity in ring buffer") public long getRemainingCapacity() throws DisruptorNotStartedException {     return getDisruptor().getRemainingCapacity(). }
false;public;0;4;;@ManagedAttribute(description = "Amount of pending exchanges waiting for consumption in ring buffer") public long getPendingExchangeCount() throws DisruptorNotStartedException {     return getDisruptor().getPendingExchangeCount(). }
true;public;0;4;/**  * Number of concurrent threads processing exchanges.  */ ;/**  * Number of concurrent threads processing exchanges.  */ @ManagedAttribute(description = "Number of concurrent consumers") public int getConcurrentConsumers() {     return concurrentConsumers. }
false;public;0;4;;@ManagedAttribute(description = "Option to specify whether the caller should wait for the async task to complete or not before continuing") public WaitForTaskToComplete getWaitForTaskToComplete() {     return waitForTaskToComplete. }
true;public;1;3;/**  * Option to specify whether the caller should wait for the async task to complete or not before continuing.  * The following three options are supported: Always, Never or IfReplyExpected. The first two values are self-explanatory.  * The last value, IfReplyExpected, will only wait if the message is Request Reply based.  */ ;/**  * Option to specify whether the caller should wait for the async task to complete or not before continuing.  * The following three options are supported: Always, Never or IfReplyExpected. The first two values are self-explanatory.  * The last value, IfReplyExpected, will only wait if the message is Request Reply based.  */ public void setWaitForTaskToComplete(final WaitForTaskToComplete waitForTaskToComplete) {     this.waitForTaskToComplete = waitForTaskToComplete. }
false;public;0;4;;@ManagedAttribute(description = "Timeout (in milliseconds) before a producer will stop waiting for an asynchronous task to complete") public long getTimeout() {     return timeout. }
true;public;1;3;/**  * Timeout (in milliseconds) before a producer will stop waiting for an asynchronous task to complete.  * You can disable timeout by using 0 or a negative value.  */ ;/**  * Timeout (in milliseconds) before a producer will stop waiting for an asynchronous task to complete.  * You can disable timeout by using 0 or a negative value.  */ public void setTimeout(final long timeout) {     this.timeout = timeout. }
false;public;0;4;;@ManagedAttribute(description = "The maximum capacity of the Disruptors ringbuffer") public int getSize() {     return size. }
true;public;1;3;/**  * The maximum capacity of the Disruptors ringbuffer  * Will be effectively increased to the nearest power of two.  * Notice: Mind if you use this option, then its the first endpoint being created with the queue name,  * that determines the size. To make sure all endpoints use same size, then configure the size option  * on all of them, or the first endpoint being created.  */ ;/**  * The maximum capacity of the Disruptors ringbuffer  * Will be effectively increased to the nearest power of two.  * Notice: Mind if you use this option, then its the first endpoint being created with the queue name,  * that determines the size. To make sure all endpoints use same size, then configure the size option  * on all of them, or the first endpoint being created.  */ public void setSize(int size) {     this.size = size. }
false;public;0;5;;@Override @ManagedAttribute(description = "Specifies whether multiple consumers are allowed") public boolean isMultipleConsumersSupported() {     return isMultipleConsumers(). }
true;public;0;3;/**  * Specifies whether multiple consumers are allowed.  * If enabled, you can use Disruptor for Publish-Subscribe messaging.  * That is, you can send a message to the queue and have each consumer receive a copy of the message.  * When enabled, this option should be specified on every consumer endpoint.  */ ;/**  * Specifies whether multiple consumers are allowed.  * If enabled, you can use Disruptor for Publish-Subscribe messaging.  * That is, you can send a message to the queue and have each consumer receive a copy of the message.  * When enabled, this option should be specified on every consumer endpoint.  */ public boolean isMultipleConsumers() {     return multipleConsumers. }
true;public;0;3;/**  * Returns the current active consumers on this endpoint  */ ;/**  * Returns the current active consumers on this endpoint  */ public Set<DisruptorConsumer> getConsumers() {     return Collections.unmodifiableSet(consumers). }
true;public;0;3;/**  * Returns the current active producers on this endpoint  */ ;/**  * Returns the current active producers on this endpoint  */ public Set<DisruptorProducer> getProducers() {     return Collections.unmodifiableSet(producers). }
false;public;0;4;;@ManagedAttribute public boolean isBlockWhenFull() {     return blockWhenFull. }
true;public;1;3;/**  * Whether a thread that sends messages to a full Disruptor will block until the ringbuffer's capacity is no longer exhausted.  * By default, the calling thread will block and wait until the message can be accepted.  * By disabling this option, an exception will be thrown stating that the queue is full.  */ ;/**  * Whether a thread that sends messages to a full Disruptor will block until the ringbuffer's capacity is no longer exhausted.  * By default, the calling thread will block and wait until the message can be accepted.  * By disabling this option, an exception will be thrown stating that the queue is full.  */ public void setBlockWhenFull(boolean blockWhenFull) {     this.blockWhenFull = blockWhenFull. }
false;public;0;4;;@ManagedAttribute(description = "Defines the strategy used by consumer threads to wait on new exchanges to be published") public DisruptorWaitStrategy getWaitStrategy() {     return waitStrategy. }
true;public;1;3;/**  * Defines the strategy used by consumer threads to wait on new exchanges to be published.  * The options allowed are:Blocking, Sleeping, BusySpin and Yielding.  */ ;/**  * Defines the strategy used by consumer threads to wait on new exchanges to be published.  * The options allowed are:Blocking, Sleeping, BusySpin and Yielding.  */ public void setWaitStrategy(DisruptorWaitStrategy waitStrategy) {     this.waitStrategy = waitStrategy. }
false;public;0;4;;@ManagedAttribute(description = " Defines the producers allowed on the Disruptor") public DisruptorProducerType getProducerType() {     return producerType. }
true;public;1;3;/**  * Defines the producers allowed on the Disruptor.  * The options allowed are: Multi to allow multiple producers and Single to enable certain optimizations only  * allowed when one concurrent producer (on one thread or otherwise synchronized) is active.  */ ;/**  * Defines the producers allowed on the Disruptor.  * The options allowed are: Multi to allow multiple producers and Single to enable certain optimizations only  * allowed when one concurrent producer (on one thread or otherwise synchronized) is active.  */ public void setProducerType(DisruptorProducerType producerType) {     this.producerType = producerType. }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
false;public;0;8;;@Override public Producer createProducer() throws Exception {     if (getProducers().size() == 1 && getDisruptor().getProducerType() == DisruptorProducerType.Single) {         throw new IllegalStateException("Endpoint can't support multiple producers when ProducerType SINGLE is configured").     }     return new DisruptorProducer(this, getWaitForTaskToComplete(), getTimeout(), isBlockWhenFull()). }
false;public;1;4;;@Override public Consumer createConsumer(final Processor processor) throws Exception {     return new DisruptorConsumer(this, processor). }
false;protected;0;6;;@Override protected void doStart() throws Exception {     // notify reference we are shutting down this endpoint     disruptorReference.addEndpoint(this).     super.doStart(). }
false;protected;0;6;;@Override protected void doStop() throws Exception {     // notify reference we are shutting down this endpoint     disruptorReference.removeEndpoint(this).     super.doStop(). }
false;protected;0;9;;@Override protected void doShutdown() throws Exception {     // notify component we are shutting down this endpoint     if (getComponent() != null) {         getComponent().onShutdownEndpoint(this).     }     super.doShutdown(). }
false;public;0;4;;@Override public DisruptorComponent getComponent() {     return (DisruptorComponent) super.getComponent(). }
false;;1;15;;void onStarted(final DisruptorConsumer consumer) throws Exception {     synchronized (this) {         // validate multiple consumers has been enabled is necessary         if (!consumers.isEmpty() && !isMultipleConsumersSupported()) {             throw new IllegalStateException("Multiple consumers for the same endpoint is not allowed: " + this).         }         if (consumers.add(consumer)) {             LOGGER.debug("Starting consumer {} on endpoint {}", consumer, getEndpointUri()).             getDisruptor().reconfigure().         } else {             LOGGER.debug("Tried to start Consumer {} on endpoint {} but it was already started", consumer, getEndpointUri()).         }     } }
false;;1;10;;void onStopped(final DisruptorConsumer consumer) throws Exception {     synchronized (this) {         if (consumers.remove(consumer)) {             LOGGER.debug("Stopping consumer {} on endpoint {}", consumer, getEndpointUri()).             getDisruptor().reconfigure().         } else {             LOGGER.debug("Tried to stop Consumer {} on endpoint {} but it was already stopped", consumer, getEndpointUri()).         }     } }
false;;1;3;;void onStarted(final DisruptorProducer producer) {     producers.add(producer). }
false;;1;3;;void onStopped(final DisruptorProducer producer) {     producers.remove(producer). }
false;;0;9;;Map<DisruptorConsumer, Collection<LifecycleAwareExchangeEventHandler>> createConsumerEventHandlers() {     Map<DisruptorConsumer, Collection<LifecycleAwareExchangeEventHandler>> result = new HashMap<>().     for (final DisruptorConsumer consumer : consumers) {         result.put(consumer, consumer.createEventHandlers(concurrentConsumers)).     }     return result. }
true;;1;3;/**  * Called by DisruptorProducers to publish new exchanges on the RingBuffer, blocking when full  */ ;/**  * Called by DisruptorProducers to publish new exchanges on the RingBuffer, blocking when full  */ void publish(final Exchange exchange) throws DisruptorNotStartedException {     disruptorReference.publish(exchange). }
true;;1;3;/**  * Called by DisruptorProducers to publish new exchanges on the RingBuffer, throwing InsufficientCapacityException  * when full  *  * @throws InsufficientCapacityException when the Ringbuffer is full.  */ ;/**  * Called by DisruptorProducers to publish new exchanges on the RingBuffer, throwing InsufficientCapacityException  * when full  *  * @throws InsufficientCapacityException when the Ringbuffer is full.  */ void tryPublish(final Exchange exchange) throws DisruptorNotStartedException, InsufficientCapacityException {     disruptorReference.tryPublish(exchange). }
false;;0;3;;DisruptorReference getDisruptor() {     return disruptorReference. }
false;public;1;5;;@Override public boolean equals(Object object) {     boolean result = super.equals(object).     return result && getCamelContext().equals(((DisruptorEndpoint) object).getCamelContext()). }
false;public;0;4;;@Override public int hashCode() {     return getEndpointUri().hashCode() * 37 + getCamelContext().hashCode(). }
