commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void done(boolean doneSync) { // Noop }
false;public;0;4;;@Override public AsyncProcessor getProcessor() {     return processor. }
false;public;0;6;;public ExceptionHandler getExceptionHandler() {     if (exceptionHandler == null) {         exceptionHandler = new LoggingExceptionHandler(endpoint.getCamelContext(), getClass()).     }     return exceptionHandler. }
false;public;1;3;;public void setExceptionHandler(final ExceptionHandler exceptionHandler) {     this.exceptionHandler = exceptionHandler. }
false;public;0;4;;@Override public DisruptorEndpoint getEndpoint() {     return endpoint. }
false;protected;0;4;;@Override protected void doStart() throws Exception {     getEndpoint().onStarted(this). }
false;protected;0;4;;@Override protected void doStop() throws Exception {     getEndpoint().onStopped(this). }
false;protected;0;4;;@Override protected void doSuspend() throws Exception {     getEndpoint().onStopped(this). }
false;protected;0;4;;@Override protected void doResume() throws Exception {     getEndpoint().onStarted(this). }
false;;1;9;;Set<LifecycleAwareExchangeEventHandler> createEventHandlers(final int concurrentConsumers) {     final Set<LifecycleAwareExchangeEventHandler> eventHandlers = new HashSet<>().     for (int i = 0. i < concurrentConsumers. ++i) {         eventHandlers.add(new ConsumerEventHandler(i, concurrentConsumers)).     }     return eventHandlers. }
false;public;1;6;;@Override public boolean deferShutdown(final ShutdownRunningTask shutdownRunningTask) {     // depend on this consumer to run, so it can complete its exchanges     return true. }
false;public;2;4;;@Override public void prepareShutdown(boolean suspendOnly, boolean forced) { // nothing }
false;public;0;4;;@Override public int getPendingExchangesSize() {     return getEndpoint().getDisruptor().getPendingExchangeCount(). }
false;public;0;4;;@Override public String toString() {     return "DisruptorConsumer[" + endpoint + "]". }
false;private;1;9;;private Exchange prepareExchange(final Exchange exchange) {     // send a new copied exchange with new camel context     // don't copy handovers as they are handled by the Disruptor Event Handlers     final Exchange newExchange = ExchangeHelper.copyExchangeAndSetCamelContext(exchange, endpoint.getCamelContext(), false).     // set the from endpoint     newExchange.setFromEndpoint(endpoint).     return newExchange. }
false;public;1;4;;@Override public void onComplete(Exchange exchange) {     synchronizedExchange.consumed(result). }
false;public;1;4;;@Override public void onFailure(Exchange exchange) {     synchronizedExchange.consumed(result). }
false;private;1;48;;private void process(final SynchronizedExchange synchronizedExchange) {     try {         Exchange exchange = synchronizedExchange.getExchange().         final boolean ignore = exchange.hasProperties() && exchange.getProperties().containsKey(DisruptorEndpoint.DISRUPTOR_IGNORE_EXCHANGE).         if (ignore) {             // Property was set and it was set to true, so don't process Exchange.             LOGGER.trace("Ignoring exchange {}", exchange).             return.         }         // send a new copied exchange with new camel context         final Exchange result = prepareExchange(exchange).         // We need to be notified when the exchange processing is complete to synchronize the original exchange         // This is however the last part of the processing of this exchange and as such can't be done         // in the AsyncCallback as that is called *AFTER* processing is considered to be done         // (see org.apache.camel.processor.CamelInternalProcessor.InternalCallback#done).         // To solve this problem, a new synchronization is set on the exchange that is to be         // processed         result.addOnCompletion(new Synchronization() {              @Override             public void onComplete(Exchange exchange) {                 synchronizedExchange.consumed(result).             }              @Override             public void onFailure(Exchange exchange) {                 synchronizedExchange.consumed(result).             }         }).         // As the necessary post-processing of the exchange is done by the registered Synchronization,         // we can suffice with a no-op AsyncCallback         processor.process(result, NOOP_ASYNC_CALLBACK).     } catch (Exception e) {         Exchange exchange = synchronizedExchange.getExchange().         if (exchange != null) {             getExceptionHandler().handleException("Error processing exchange", exchange, e).         } else {             getExceptionHandler().handleException(e).         }     } }
false;public;3;12;;@Override public void onEvent(final ExchangeEvent event, final long sequence, final boolean endOfBatch) throws Exception {     // see http://code.google.com/p/disruptor/wiki/FrequentlyAskedQuestions#How_do_you_arrange_a_Disruptor_with_multiple_consumers_so_that_e     if (sequence % concurrentConsumers == ordinal) {         process(event.getSynchronizedExchange()).     } }
