# id;timestamp;commentText;codeText;commentWords;codeWords
MongoDbTailingProcess -> @Override     public void run();1482051156;The heart of the tailing process.;@Override_    public void run() {_        stoppedLatch = new CountDownLatch(1)__        while (keepRunning) {_            doRun()__            _            _            if (keepRunning) {_                cursor.close()__                if (LOG.isDebugEnabled()) {_                    LOG.debug("Regenerating cursor with lastVal: {}, waiting {}ms first", tailTracking.lastVal, cursorRegenerationDelay)__                }__                if (cursorRegenerationDelayEnabled) {_                    try {_                        Thread.sleep(cursorRegenerationDelay)__                    } catch (InterruptedException e) {_                        _                    }_                }__                cursor = initializeCursor()__            }_        }__        stopped = true__        stoppedLatch.countDown()__    };the,heart,of,the,tailing,process;override,public,void,run,stopped,latch,new,count,down,latch,1,while,keep,running,do,run,if,keep,running,cursor,close,if,log,is,debug,enabled,log,debug,regenerating,cursor,with,last,val,waiting,ms,first,tail,tracking,last,val,cursor,regeneration,delay,if,cursor,regeneration,delay,enabled,try,thread,sleep,cursor,regeneration,delay,catch,interrupted,exception,e,cursor,initialize,cursor,stopped,true,stopped,latch,count,down
MongoDbTailingProcess -> @Override     public void run();1537290824;The heart of the tailing process.;@Override_    public void run() {_        stoppedLatch = new CountDownLatch(1)__        while (keepRunning) {_            doRun()__            _            _            if (keepRunning) {_                cursor.close()__                if (LOG.isDebugEnabled()) {_                    LOG.debug("Regenerating cursor with lastVal: {}, waiting {}ms first", tailTracking.lastVal, cursorRegenerationDelay)__                }__                if (cursorRegenerationDelayEnabled) {_                    try {_                        Thread.sleep(cursorRegenerationDelay)__                    } catch (InterruptedException e) {_                        _                    }_                }__                cursor = initializeCursor()__            }_        }__        stopped = true__        stoppedLatch.countDown()__    };the,heart,of,the,tailing,process;override,public,void,run,stopped,latch,new,count,down,latch,1,while,keep,running,do,run,if,keep,running,cursor,close,if,log,is,debug,enabled,log,debug,regenerating,cursor,with,last,val,waiting,ms,first,tail,tracking,last,val,cursor,regeneration,delay,if,cursor,regeneration,delay,enabled,try,thread,sleep,cursor,regeneration,delay,catch,interrupted,exception,e,cursor,initialize,cursor,stopped,true,stopped,latch,count,down
MongoDbTailingProcess -> private void doRun();1482051156;The heart of the tailing process.;private void doRun() {_		_		_		try {_			while (cursor.hasNext() && keepRunning) { _														_				Document dbObj = cursor.next()__				Exchange exchange = endpoint.createMongoDbExchange(dbObj)__				try {_					if (LOG.isTraceEnabled()) {_						LOG.trace("Sending exchange: {}, ObjectId: {}", exchange, dbObj.get(MONGO_ID))__					}_					consumer.getProcessor().process(exchange)__				} catch (Exception e) {_					_				}_				tailTracking.setLastVal(dbObj)__			}_		} catch (MongoCursorNotFoundException e) {_			_			_			_			_			if (keepRunning) {_				LOG.debug(_						"Cursor not found exception from MongoDB, will regenerate cursor. This is normal behaviour with tailable cursors.",_						e)__			}_		}__		_		_		_		tailTracking.persistToStore()__	};the,heart,of,the,tailing,process;private,void,do,run,try,while,cursor,has,next,keep,running,document,db,obj,cursor,next,exchange,exchange,endpoint,create,mongo,db,exchange,db,obj,try,if,log,is,trace,enabled,log,trace,sending,exchange,object,id,exchange,db,obj,get,consumer,get,processor,process,exchange,catch,exception,e,tail,tracking,set,last,val,db,obj,catch,mongo,cursor,not,found,exception,e,if,keep,running,log,debug,cursor,not,found,exception,from,mongo,db,will,regenerate,cursor,this,is,normal,behaviour,with,tailable,cursors,e,tail,tracking,persist,to,store
MongoDbTailingProcess -> private void doRun();1482051156;The heart of the tailing process.;private void doRun() {_        _        _        try {_            while (cursor.hasNext() && keepRunning) { _                                                      _                Document dbObj = cursor.next()__                Exchange exchange = endpoint.createMongoDbExchange(dbObj)__                try {_                    if (LOG.isTraceEnabled()) {_                        LOG.trace("Sending exchange: {}, ObjectId: {}", exchange, dbObj.get(MONGO_ID))__                    }_                    consumer.getProcessor().process(exchange)__                } catch (Exception e) {_                    _                }_                tailTracking.setLastVal(dbObj)__            }_        } catch (MongoCursorNotFoundException e) {_            _            _            _            _            if (keepRunning) {_                LOG.debug("Cursor not found exception from MongoDB, will regenerate cursor. This is normal behaviour with tailable cursors.", e)__            }_        }__        _        _        _        tailTracking.persistToStore()__    };the,heart,of,the,tailing,process;private,void,do,run,try,while,cursor,has,next,keep,running,document,db,obj,cursor,next,exchange,exchange,endpoint,create,mongo,db,exchange,db,obj,try,if,log,is,trace,enabled,log,trace,sending,exchange,object,id,exchange,db,obj,get,consumer,get,processor,process,exchange,catch,exception,e,tail,tracking,set,last,val,db,obj,catch,mongo,cursor,not,found,exception,e,if,keep,running,log,debug,cursor,not,found,exception,from,mongo,db,will,regenerate,cursor,this,is,normal,behaviour,with,tailable,cursors,e,tail,tracking,persist,to,store
MongoDbTailingProcess -> private void doRun();1537290824;The heart of the tailing process.;private void doRun() {_        _        _        try {_            while (cursor.hasNext() && keepRunning) { _                                                      _                Document dbObj = cursor.next()__                Exchange exchange = endpoint.createMongoDbExchange(dbObj)__                try {_                    if (LOG.isTraceEnabled()) {_                        LOG.trace("Sending exchange: {}, ObjectId: {}", exchange, dbObj.get(MONGO_ID))__                    }_                    consumer.getProcessor().process(exchange)__                } catch (Exception e) {_                    _                }_                tailTracking.setLastVal(dbObj)__            }_        } catch (MongoCursorNotFoundException e) {_            _            _            _            _            if (keepRunning) {_                LOG.debug("Cursor not found exception from MongoDB, will regenerate cursor. This is normal behaviour with tailable cursors.", e)__            }_        }__        _        _        _        tailTracking.persistToStore()__    };the,heart,of,the,tailing,process;private,void,do,run,try,while,cursor,has,next,keep,running,document,db,obj,cursor,next,exchange,exchange,endpoint,create,mongo,db,exchange,db,obj,try,if,log,is,trace,enabled,log,trace,sending,exchange,object,id,exchange,db,obj,get,consumer,get,processor,process,exchange,catch,exception,e,tail,tracking,set,last,val,db,obj,catch,mongo,cursor,not,found,exception,e,if,keep,running,log,debug,cursor,not,found,exception,from,mongo,db,will,regenerate,cursor,this,is,normal,behaviour,with,tailable,cursors,e,tail,tracking,persist,to,store
MongoDbTailingProcess -> public void initializeProcess() throws Exception;1482051156;Initialise the tailing process, the cursor and if persistent tail_tracking is enabled, recover the cursor from the persisted point. As part_of the initialisation process, the component will validate that the_collection we are targeting is 'capped'.__@throws Exception;public void initializeProcess() throws Exception {_		if (LOG.isInfoEnabled()) {_			LOG.info("Starting MongoDB Tailable Cursor consumer, binding to collection: {}",_					"db: " + endpoint.getMongoDatabase() + ", col: " + endpoint.getCollection())__		}__		if (!isCollectionCapped()) {_			throw new CamelMongoDbException(_					"Tailable cursors are only compatible with capped collections, and collection "_							+ endpoint.getCollection() + " is not capped")__		}_		try {_			_			tailTracking.recoverFromStore()__			cursor = initializeCursor()__		} catch (Exception e) {_			throw new CamelMongoDbException("Exception occurred while initializing tailable cursor", e)__		}__		if (cursor == null) {_			throw new CamelMongoDbException(_					"Tailable cursor was not initialized, or cursor returned is dead on arrival")__		}__	};initialise,the,tailing,process,the,cursor,and,if,persistent,tail,tracking,is,enabled,recover,the,cursor,from,the,persisted,point,as,part,of,the,initialisation,process,the,component,will,validate,that,the,collection,we,are,targeting,is,capped,throws,exception;public,void,initialize,process,throws,exception,if,log,is,info,enabled,log,info,starting,mongo,db,tailable,cursor,consumer,binding,to,collection,db,endpoint,get,mongo,database,col,endpoint,get,collection,if,is,collection,capped,throw,new,camel,mongo,db,exception,tailable,cursors,are,only,compatible,with,capped,collections,and,collection,endpoint,get,collection,is,not,capped,try,tail,tracking,recover,from,store,cursor,initialize,cursor,catch,exception,e,throw,new,camel,mongo,db,exception,exception,occurred,while,initializing,tailable,cursor,e,if,cursor,null,throw,new,camel,mongo,db,exception,tailable,cursor,was,not,initialized,or,cursor,returned,is,dead,on,arrival
MongoDbTailingProcess -> public void initializeProcess() throws Exception;1482051156;Initialise the tailing process, the cursor and if persistent tail_tracking is enabled, recover the cursor from the persisted point. As part_of the initialisation process, the component will validate that the_collection we are targeting is 'capped'.__@throws Exception;public void initializeProcess() throws Exception {_        if (LOG.isInfoEnabled()) {_            LOG.info("Starting MongoDB Tailable Cursor consumer, binding to collection: {}", "db: " + endpoint.getMongoDatabase() + ", col: " + endpoint.getCollection())__        }__        if (!isCollectionCapped()) {_            throw new CamelMongoDbException("Tailable cursors are only compatible with capped collections, and collection " + endpoint.getCollection() + " is not capped")__        }_        try {_            _            tailTracking.recoverFromStore()__            cursor = initializeCursor()__        } catch (Exception e) {_            throw new CamelMongoDbException("Exception occurred while initializing tailable cursor", e)__        }__        if (cursor == null) {_            throw new CamelMongoDbException("Tailable cursor was not initialized, or cursor returned is dead on arrival")__        }__    };initialise,the,tailing,process,the,cursor,and,if,persistent,tail,tracking,is,enabled,recover,the,cursor,from,the,persisted,point,as,part,of,the,initialisation,process,the,component,will,validate,that,the,collection,we,are,targeting,is,capped,throws,exception;public,void,initialize,process,throws,exception,if,log,is,info,enabled,log,info,starting,mongo,db,tailable,cursor,consumer,binding,to,collection,db,endpoint,get,mongo,database,col,endpoint,get,collection,if,is,collection,capped,throw,new,camel,mongo,db,exception,tailable,cursors,are,only,compatible,with,capped,collections,and,collection,endpoint,get,collection,is,not,capped,try,tail,tracking,recover,from,store,cursor,initialize,cursor,catch,exception,e,throw,new,camel,mongo,db,exception,exception,occurred,while,initializing,tailable,cursor,e,if,cursor,null,throw,new,camel,mongo,db,exception,tailable,cursor,was,not,initialized,or,cursor,returned,is,dead,on,arrival
MongoDbTailingProcess -> public void initializeProcess() throws Exception;1537290824;Initialise the tailing process, the cursor and if persistent tail_tracking is enabled, recover the cursor from the persisted point. As part_of the initialisation process, the component will validate that the_collection we are targeting is 'capped'.__@throws Exception;public void initializeProcess() throws Exception {_        if (LOG.isInfoEnabled()) {_            LOG.info("Starting MongoDB Tailable Cursor consumer, binding to collection: {}", "db: " + endpoint.getMongoDatabase() + ", col: " + endpoint.getCollection())__        }__        if (!isCollectionCapped()) {_            throw new CamelMongoDbException("Tailable cursors are only compatible with capped collections, and collection " + endpoint.getCollection() + " is not capped")__        }_        try {_            _            tailTracking.recoverFromStore()__            cursor = initializeCursor()__        } catch (Exception e) {_            throw new CamelMongoDbException("Exception occurred while initializing tailable cursor", e)__        }__        if (cursor == null) {_            throw new CamelMongoDbException("Tailable cursor was not initialized, or cursor returned is dead on arrival")__        }__    };initialise,the,tailing,process,the,cursor,and,if,persistent,tail,tracking,is,enabled,recover,the,cursor,from,the,persisted,point,as,part,of,the,initialisation,process,the,component,will,validate,that,the,collection,we,are,targeting,is,capped,throws,exception;public,void,initialize,process,throws,exception,if,log,is,info,enabled,log,info,starting,mongo,db,tailable,cursor,consumer,binding,to,collection,db,endpoint,get,mongo,database,col,endpoint,get,collection,if,is,collection,capped,throw,new,camel,mongo,db,exception,tailable,cursors,are,only,compatible,with,capped,collections,and,collection,endpoint,get,collection,is,not,capped,try,tail,tracking,recover,from,store,cursor,initialize,cursor,catch,exception,e,throw,new,camel,mongo,db,exception,exception,occurred,while,initializing,tailable,cursor,e,if,cursor,null,throw,new,camel,mongo,db,exception,tailable,cursor,was,not,initialized,or,cursor,returned,is,dead,on,arrival
