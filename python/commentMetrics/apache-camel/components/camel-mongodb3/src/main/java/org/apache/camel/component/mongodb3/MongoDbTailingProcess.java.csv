commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public MongoCursor<Document> getCursor() {     return cursor. }
true;public;0;21;/**  * Initialise the tailing process, the cursor and if persistent tail  * tracking is enabled, recover the cursor from the persisted point. As part  * of the initialisation process, the component will validate that the  * collection we are targeting is 'capped'.  *  * @throws Exception  */ ;/**  * Initialise the tailing process, the cursor and if persistent tail  * tracking is enabled, recover the cursor from the persisted point. As part  * of the initialisation process, the component will validate that the  * collection we are targeting is 'capped'.  *  * @throws Exception  */ public void initializeProcess() throws Exception {     if (LOG.isInfoEnabled()) {         LOG.info("Starting MongoDB Tailable Cursor consumer, binding to collection: {}", "db: " + endpoint.getMongoDatabase() + ", col: " + endpoint.getCollection()).     }     if (!isCollectionCapped()) {         throw new CamelMongoDbException("Tailable cursors are only compatible with capped collections, and collection " + endpoint.getCollection() + " is not capped").     }     try {         // recover the last value from the store if it exists         tailTracking.recoverFromStore().         cursor = initializeCursor().     } catch (Exception e) {         throw new CamelMongoDbException("Exception occurred while initializing tailable cursor", e).     }     if (cursor == null) {         throw new CamelMongoDbException("Tailable cursor was not initialized, or cursor returned is dead on arrival").     } }
false;private;0;3;;private Boolean isCollectionCapped() {     return endpoint.getMongoDatabase().runCommand(createCollStatsCommand()).getBoolean(CAPPED_KEY). }
false;private;0;3;;private Document createCollStatsCommand() {     return new Document("collStats", endpoint.getCollection()). }
true;public;0;28;/**  * The heart of the tailing process.  */ ;/**  * The heart of the tailing process.  */ @Override public void run() {     stoppedLatch = new CountDownLatch(1).     while (keepRunning) {         doRun().         // running, then regenerate the cursor         if (keepRunning) {             cursor.close().             if (LOG.isDebugEnabled()) {                 LOG.debug("Regenerating cursor with lastVal: {}, waiting {}ms first", tailTracking.lastVal, cursorRegenerationDelay).             }             if (cursorRegenerationDelayEnabled) {                 try {                     Thread.sleep(cursorRegenerationDelay).                 } catch (InterruptedException e) {                 // ignore                 }             }             cursor = initializeCursor().         }     }     stopped = true.     stoppedLatch.countDown(). }
false;protected;0;15;;protected void stop() throws Exception {     if (LOG.isInfoEnabled()) {         LOG.info("Stopping MongoDB Tailable Cursor consumer, bound to collection: {}", "db: " + endpoint.getDatabase() + ", col: " + endpoint.getCollection()).     }     keepRunning = false.     // will return immediately     if (cursor != null) {         cursor.close().     }     awaitStopped().     if (LOG.isInfoEnabled()) {         LOG.info("Stopped MongoDB Tailable Cursor consumer, bound to collection: {}", "db: " + endpoint.getDatabase() + ", col: " + endpoint.getCollection()).     } }
true;private;0;33;/**  * The heart of the tailing process.  */ ;/**  * The heart of the tailing process.  */ private void doRun() {     // cursorId is not 0, which symbolizes that the cursor is dead     try {         while (cursor.hasNext() && keepRunning) {             // cursor.getCursorId() !=             // 0 &&             Document dbObj = cursor.next().             Exchange exchange = endpoint.createMongoDbExchange(dbObj).             try {                 if (LOG.isTraceEnabled()) {                     LOG.trace("Sending exchange: {}, ObjectId: {}", exchange, dbObj.get(MONGO_ID)).                 }                 consumer.getProcessor().process(exchange).             } catch (Exception e) {             // do nothing             }             tailTracking.setLastVal(dbObj).         }     } catch (MongoCursorNotFoundException e) {         // waiting for more data to arrive         if (keepRunning) {             LOG.debug("Cursor not found exception from MongoDB, will regenerate cursor. This is normal behaviour with tailable cursors.", e).         }     }     // the loop finished, persist the lastValue just in case we are shutting     // down     // TODO: perhaps add a functionality to persist every N records     tailTracking.persistToStore(). }
true;private;0;14;// persistent storage) ;// no arguments, will ask DB what the last updated Id was (checking // persistent storage) private MongoCursor<Document> initializeCursor() {     Object lastVal = tailTracking.lastVal.     // lastVal can be null if we are initializing and there is no     // persistence enabled     MongoCursor<Document> answer.     if (lastVal == null) {         answer = dbCol.find().cursorType(CursorType.TailableAwait).iterator().     } else {         try (MongoCursor<Document> iterator = dbCol.find(gt(tailTracking.getIncreasingFieldName(), lastVal)).cursorType(CursorType.TailableAwait).iterator()) {             answer = iterator.         }     }     return answer. }
false;private;0;6;;private void awaitStopped() throws InterruptedException {     if (!stopped) {         LOG.info("Going to wait for stopping").         stoppedLatch.await().     } }
