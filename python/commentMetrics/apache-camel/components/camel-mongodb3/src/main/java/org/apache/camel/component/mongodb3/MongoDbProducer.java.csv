commented;modifiers;parameterAmount;loc;comment;code
false;public;1;24;;public void process(Exchange exchange) throws Exception {     MongoDbOperation operation = endpoint.getOperation().     Object header = exchange.getIn().getHeader(OPERATION_HEADER).     if (header != null) {         log.debug("Overriding default operation with operation specified on header: {}", header).         try {             if (header instanceof MongoDbOperation) {                 operation = ObjectHelper.cast(MongoDbOperation.class, header).             } else {                 // evaluate as a String                 operation = MongoDbOperation.valueOf(exchange.getIn().getHeader(OPERATION_HEADER, String.class)).             }         } catch (Exception e) {             throw new CamelMongoDbException("Operation specified on header is not supported. Value: " + header, e).         }     }     try {         invokeOperation(operation, exchange).     } catch (Exception e) {         throw MongoDbComponent.wrapInCamelMongoDbException(e).     } }
true;protected;2;8;/**  * Entry method that selects the appropriate MongoDB operation and executes it  */ ;/**  * Entry method that selects the appropriate MongoDB operation and executes it  */ protected void invokeOperation(MongoDbOperation operation, Exchange exchange) throws Exception {     Processor processor = operations.get(operation).     if (processor != null) {         processor.process(exchange).     } else {         throw new CamelMongoDbException("Operation not supported. Value: " + operation).     } }
false;private;2;4;;private MongoDbProducer bind(MongoDbOperation operation, Function<Exchange, Object> mongoDbFunction) {     operations.put(operation, wrap(mongoDbFunction, operation)).     return this. }
false;private;0;3;;// ----------- MongoDB operations ---------------- private Document createDbStatsCommand() {     return new Document("dbStats", 1).append("scale", 1). }
false;private;1;3;;private Document createCollStatsCommand(String collectionName) {     return new Document("collStats", collectionName). }
true;private;1;23;// --------- Convenience methods ----------------------- ;// --------- Convenience methods ----------------------- private MongoDatabase calculateDb(Exchange exchange) {     // functionality at all     if (!endpoint.isDynamicity()) {         return endpoint.getMongoDatabase().     }     String dynamicDB = exchange.getIn().getHeader(DATABASE, String.class).     MongoDatabase db.     if (dynamicDB == null) {         db = endpoint.getMongoDatabase().     } else {         db = endpoint.getMongoConnection().getDatabase(dynamicDB).     }     if (log.isDebugEnabled()) {         log.debug("Dynamic database selected: {}", db.getName()).     }     return db. }
false;private;1;10;;private String calculateCollectionName(Exchange exchange) {     if (!endpoint.isDynamicity()) {         return endpoint.getCollection().     }     String dynamicCollection = exchange.getIn().getHeader(COLLECTION, String.class).     if (dynamicCollection == null) {         return endpoint.getCollection().     }     return dynamicCollection. }
false;private;1;41;;private MongoCollection<Document> calculateCollection(Exchange exchange) {     // functionality at all     if (!endpoint.isDynamicity()) {         return endpoint.getMongoCollection().withWriteConcern(endpoint.getWriteConcern()).     }     String dynamicDB = exchange.getIn().getHeader(DATABASE, String.class).     String dynamicCollection = exchange.getIn().getHeader(COLLECTION, String.class).     @SuppressWarnings("unchecked")     List<Bson> dynamicIndex = exchange.getIn().getHeader(COLLECTION_INDEX, List.class).     MongoCollection<Document> dbCol.     if (dynamicDB == null && dynamicCollection == null) {         dbCol = endpoint.getMongoCollection().withWriteConcern(endpoint.getWriteConcern()).     } else {         MongoDatabase db = calculateDb(exchange).         if (dynamicCollection == null) {             dbCol = db.getCollection(endpoint.getCollection(), Document.class).         } else {             dbCol = db.getCollection(dynamicCollection, Document.class).             // on the fly add index             if (dynamicIndex == null) {                 endpoint.ensureIndex(dbCol, endpoint.createIndex()).             } else {                 endpoint.ensureIndex(dbCol, dynamicIndex).             }         }     }     if (log.isDebugEnabled()) {         log.debug("Dynamic database and/or collection selected: {}->{}", endpoint.getDatabase(), endpoint.getCollection()).     }     return dbCol. }
false;private;2;14;;@SuppressWarnings("rawtypes") private List<Document> attemptConvertToList(List insertList, Exchange exchange) throws CamelMongoDbException {     List<Document> documentList = new ArrayList<>(insertList.size()).     TypeConverter converter = exchange.getContext().getTypeConverter().     for (Object item : insertList) {         try {             Document document = converter.mandatoryConvertTo(Document.class, item).             documentList.add(document).         } catch (Exception e) {             throw new CamelMongoDbException("MongoDB operation = insert, Assuming List variant of MongoDB insert operation, but List contains non-Document items", e).         }     }     return documentList. }
false;private;1;3;;private boolean isWriteOperation(MongoDbOperation operation) {     return MongoDbComponent.WRITE_OPERATIONS.contains(operation). }
false;private;2;8;;private Processor wrap(Function<Exchange, Object> supplier, MongoDbOperation operation) {     return exchange -> {         Object result = supplier.apply(exchange).         copyHeaders(exchange).         moveBodyToOutIfResultIsReturnedAsHeader(exchange, operation).         processAndTransferResult(result, exchange, operation).     }. }
false;private;1;3;;private void copyHeaders(Exchange exchange) {     MessageHelper.copyHeaders(exchange.getIn(), exchange.getOut(), false). }
false;private;2;5;;private void moveBodyToOutIfResultIsReturnedAsHeader(Exchange exchange, MongoDbOperation operation) {     if (isWriteOperation(operation) && endpoint.isWriteResultAsHeader()) {         exchange.getOut().setBody(exchange.getIn().getBody()).     } }
false;private;3;9;;private void processAndTransferResult(Object result, Exchange exchange, MongoDbOperation operation) {     // message header     if (isWriteOperation(operation) && endpoint.isWriteResultAsHeader()) {         exchange.getOut().setHeader(WRITERESULT, result).     } else {         exchange.getOut().setBody(result).     } }
false;private;0;3;;private Function<Exchange, Object> createDoGetColStats() {     return exch -> calculateDb(exch).runCommand(createCollStatsCommand(calculateCollectionName(exch))). }
false;private;0;29;;private Function<Exchange, Object> createDoFindOneByQuery() {     return exchange -> {         try {             MongoCollection<Document> dbCol = calculateCollection(exchange).             Bson query = exchange.getIn().getHeader(CRITERIA, Bson.class).             if (null == query) {                 query = exchange.getIn().getMandatoryBody(Bson.class).             }             Bson sortBy = exchange.getIn().getHeader(SORT_BY, Bson.class).             Bson fieldFilter = exchange.getIn().getHeader(FIELDS_PROJECTION, Bson.class).             if (fieldFilter == null) {                 fieldFilter = new Document().             }             if (sortBy == null) {                 sortBy = new Document().             }             Document ret = dbCol.find(query).projection(fieldFilter).sort(sortBy).first().             exchange.getOut().setHeader(RESULT_TOTAL_SIZE, ret == null ? 0 : 1).             return ret.         } catch (InvalidPayloadException e) {             throw new CamelMongoDbException("Payload is no Document", e).         }     }. }
false;private;0;12;;private Function<Exchange, Object> createDoCount() {     return exchange -> {         Bson query = exchange.getIn().getHeader(CRITERIA, Bson.class).         if (query == null) {             query = exchange.getContext().getTypeConverter().tryConvertTo(Bson.class, exchange, exchange.getIn().getBody()).         }         if (query == null) {             query = new Document().         }         return calculateCollection(exchange).count(query).     }. }
false;private;0;24;;private Function<Exchange, Object> createDoDistinct() {     return exchange -> {         Iterable<String> result = new ArrayList<>().         MongoCollection<Document> dbCol = calculateCollection(exchange).         // get the parameters out of the Exchange Header         String distinctFieldName = exchange.getIn().getHeader(MongoDbConstants.DISTINCT_QUERY_FIELD, String.class).         Bson query = exchange.getContext().getTypeConverter().tryConvertTo(Bson.class, exchange, exchange.getIn().getBody()).         DistinctIterable<String> ret.         if (query != null) {             ret = dbCol.distinct(distinctFieldName, query, String.class).         } else {             ret = dbCol.distinct(distinctFieldName, String.class).         }         try {             ret.iterator().forEachRemaining(((List<String>) result)::add).             exchange.getOut().setHeader(MongoDbConstants.RESULT_PAGE_SIZE, ((List<String>) result).size()).         } finally {             ret.iterator().close().         }         return result.     }. }
false;private;0;60;;private Function<Exchange, Object> createDoFindAll() {     return exchange -> {         Iterable<Document> result.         MongoCollection<Document> dbCol = calculateCollection(exchange).         // do not use getMandatoryBody, because if the body is empty we want         // to retrieve all objects in the collection         Bson query = exchange.getIn().getHeader(CRITERIA, Bson.class).         // need for it         if (query == null && exchange.getIn().getBody() != null) {             query = exchange.getContext().getTypeConverter().tryConvertTo(Bson.class, exchange, exchange.getIn().getBody()).         }         Bson fieldFilter = exchange.getIn().getHeader(FIELDS_PROJECTION, Bson.class).         // get the batch size and number to skip         Integer batchSize = exchange.getIn().getHeader(BATCH_SIZE, Integer.class).         Integer numToSkip = exchange.getIn().getHeader(NUM_TO_SKIP, Integer.class).         Integer limit = exchange.getIn().getHeader(LIMIT, Integer.class).         Document sortBy = exchange.getIn().getHeader(SORT_BY, Document.class).         FindIterable<Document> ret.         if (query == null && fieldFilter == null) {             ret = dbCol.find().         } else if (fieldFilter == null) {             ret = dbCol.find(query).         } else if (query != null) {             ret = dbCol.find(query).projection(fieldFilter).         } else {             ret = dbCol.find().projection(fieldFilter).         }         if (sortBy != null) {             ret.sort(sortBy).         }         if (batchSize != null) {             ret.batchSize(batchSize).         }         if (numToSkip != null) {             ret.skip(numToSkip).         }         if (limit != null) {             ret.limit(limit).         }         if (!MongoDbOutputType.MongoIterable.equals(endpoint.getOutputType())) {             try {                 result = new ArrayList<>().                 ret.iterator().forEachRemaining(((List<Document>) result)::add).                 exchange.getOut().setHeader(RESULT_PAGE_SIZE, ((List<Document>) result).size()).             } finally {                 ret.iterator().close().             }         } else {             result = ret.         }         return result.     }. }
false;private;0;35;;private Function<Exchange, Object> createDoInsert() {     return exchange -> {         MongoCollection<Document> dbCol = calculateCollection(exchange).         boolean singleInsert = true.         Object insert = exchange.getContext().getTypeConverter().tryConvertTo(Document.class, exchange, exchange.getIn().getBody()).         // type List<Document>         if (insert == null) {             insert = exchange.getIn().getBody(List.class).             // are of type Document and cast the List to List<Document>             if (insert != null) {                 singleInsert = false.                 insert = attemptConvertToList((List<?>) insert, exchange).             } else {                 throw new CamelMongoDbException("MongoDB operation = insert, Body is not conversible to type Document nor List<Document>").             }         }         if (singleInsert) {             Document insertObject = Document.class.cast(insert).             dbCol.insertOne(insertObject).             exchange.getIn().setHeader(OID, insertObject.get(MONGO_ID)).         } else {             @SuppressWarnings("unchecked")             List<Document> insertObjects = (List<Document>) insert.             dbCol.insertMany(insertObjects).             List<Object> objectIdentification = new ArrayList<>(insertObjects.size()).             objectIdentification.addAll(insertObjects.stream().map(insertObject -> insertObject.get(MONGO_ID)).collect(Collectors.toList())).             exchange.getIn().setHeader(OID, objectIdentification).         }         return insert.     }. }
false;private;0;44;;private Function<Exchange, Object> createDoUpdate() {     return exchange -> {         try {             MongoCollection<Document> dbCol = calculateCollection(exchange).             Bson updateCriteria = exchange.getIn().getHeader(CRITERIA, Bson.class).             Bson objNew.             if (null == updateCriteria) {                 @SuppressWarnings("unchecked")                 List<Bson> saveObj = exchange.getIn().getMandatoryBody((Class<List<Bson>>) Class.class.cast(List.class)).                 if (saveObj.size() != 2) {                     throw new CamelMongoDbException("MongoDB operation = insert, failed because body is not a List of Document objects with size = 2").                 }                 updateCriteria = saveObj.get(0).                 objNew = saveObj.get(1).             } else {                 objNew = exchange.getIn().getMandatoryBody(Bson.class).             }             Boolean multi = exchange.getIn().getHeader(MULTIUPDATE, Boolean.class).             Boolean upsert = exchange.getIn().getHeader(UPSERT, Boolean.class).             UpdateResult result.             UpdateOptions options = new UpdateOptions().             if (upsert != null) {                 options.upsert(upsert).             }             if (multi == null || !multi) {                 result = dbCol.updateOne(updateCriteria, objNew, options).             } else {                 result = dbCol.updateMany(updateCriteria, objNew, options).             }             if (result.isModifiedCountAvailable()) {                 exchange.getOut().setHeader(RECORDS_AFFECTED, result.getModifiedCount()).             }             exchange.getOut().setHeader(RECORDS_MATCHED, result.getMatchedCount()).             return result.         } catch (InvalidPayloadException e) {             throw new CamelMongoDbException("Invalid payload for update", e).         }     }. }
false;private;0;16;;private Function<Exchange, Object> createDoRemove() {     return exchange -> {         try {             MongoCollection<Document> dbCol = calculateCollection(exchange).             Bson removeObj = exchange.getIn().getMandatoryBody(Bson.class).             DeleteResult result = dbCol.deleteMany(removeObj).             if (result.wasAcknowledged()) {                 exchange.getOut().setHeader(RECORDS_AFFECTED, result.getDeletedCount()).             }             return result.         } catch (InvalidPayloadException e) {             throw new CamelMongoDbException("Invalid payload for remove", e).         }     }. }
false;private;0;48;;private Function<Exchange, Object> createDoAggregate() {     return exchange -> {         try {             MongoCollection<Document> dbCol = calculateCollection(exchange).             @SuppressWarnings("unchecked")             List<Bson> query = exchange.getIn().getMandatoryBody((Class<List<Bson>>) Class.class.cast(List.class)).             // Allow body to be a pipeline             // @see http://docs.mongodb.org/manual/core/aggregation/             List<Bson> queryList.             if (query != null) {                 queryList = query.stream().collect(Collectors.toList()).             } else {                 queryList = Arrays.asList(Bson.class.cast(exchange.getIn().getMandatoryBody(Bson.class))).             }             // The number to skip must be in body query             AggregateIterable<Document> aggregationResult = dbCol.aggregate(queryList).             // get the batch size             Integer batchSize = exchange.getIn().getHeader(MongoDbConstants.BATCH_SIZE, Integer.class).             if (batchSize != null) {                 aggregationResult.batchSize(batchSize).             }             Boolean allowDiskUse = exchange.getIn().getHeader(MongoDbConstants.ALLOW_DISK_USE, Boolean.FALSE, Boolean.class).             aggregationResult.allowDiskUse(allowDiskUse).             Iterable<Document> result.             if (!MongoDbOutputType.MongoIterable.equals(endpoint.getOutputType())) {                 try {                     result = new ArrayList<>().                     aggregationResult.iterator().forEachRemaining(((List<Document>) result)::add).                     exchange.getOut().setHeader(MongoDbConstants.RESULT_PAGE_SIZE, ((List<Document>) result).size()).                 } finally {                     aggregationResult.iterator().close().                 }             } else {                 result = aggregationResult.             }             return result.         } catch (InvalidPayloadException e) {             throw new CamelMongoDbException("Invalid payload for aggregate", e).         }     }. }
false;private;0;11;;private Function<Exchange, Object> createDoCommand() {     return exchange -> {         try {             MongoDatabase db = calculateDb(exchange).             Document cmdObj = exchange.getIn().getMandatoryBody(Document.class).             return db.runCommand(cmdObj).         } catch (InvalidPayloadException e) {             throw new CamelMongoDbException("Invalid payload for command", e).         }     }. }
false;private;0;3;;private Function<Exchange, Object> createDoGetDbStats() {     return exchange1 -> calculateDb(exchange1).runCommand(createDbStatsCommand()). }
false;private;0;20;;private Function<Exchange, Object> createDoFindById() {     return exchange -> {         try {             MongoCollection<Document> dbCol = calculateCollection(exchange).             Object id = exchange.getIn().getMandatoryBody().             Bson o = Filters.eq(MONGO_ID, id).             Document ret.             Bson fieldFilter = exchange.getIn().getHeader(FIELDS_PROJECTION, Bson.class).             if (fieldFilter == null) {                 fieldFilter = new Document().             }             ret = dbCol.find(o).projection(fieldFilter).first().             exchange.getOut().setHeader(RESULT_TOTAL_SIZE, ret == null ? 0 : 1).             return ret.         } catch (InvalidPayloadException e) {             throw new CamelMongoDbException("Invalid payload for findById", e).         }     }. }
false;private;0;20;;private Function<Exchange, Object> createDoSave() {     return exchange -> {         try {             MongoCollection<Document> dbCol = calculateCollection(exchange).             Document saveObj = exchange.getIn().getMandatoryBody(Document.class).             UpdateOptions options = new UpdateOptions().upsert(true).             UpdateResult result.             if (null == saveObj.get(MONGO_ID)) {                 result = dbCol.replaceOne(Filters.where("false"), saveObj, options).                 exchange.getIn().setHeader(OID, result.getUpsertedId().asObjectId().getValue()).             } else {                 result = dbCol.replaceOne(eq(MONGO_ID, saveObj.get(MONGO_ID)), saveObj, options).                 exchange.getIn().setHeader(OID, saveObj.get(MONGO_ID)).             }             return result.         } catch (InvalidPayloadException e) {             throw new CamelMongoDbException("Body incorrect type for save", e).         }     }. }
false;private;0;19;;private Function<Exchange, Object> createDoBulkWrite() {     return exchange -> {         try {             MongoCollection<Document> dbCol = calculateCollection(exchange).             Boolean ordered = exchange.getIn().getHeader(MongoDbConstants.BULK_ORDERED, Boolean.TRUE, Boolean.class).             BulkWriteOptions options = new BulkWriteOptions().ordered(ordered).             @SuppressWarnings("unchecked")             List<WriteModel<Document>> requests = exchange.getIn().getMandatoryBody((Class<List<WriteModel<Document>>>) Class.class.cast(List.class)).             BulkWriteResult result = dbCol.bulkWrite(requests, options).             return result.         } catch (InvalidPayloadException e) {             throw new CamelMongoDbException("Invalid payload for bulk write", e).         }     }. }
