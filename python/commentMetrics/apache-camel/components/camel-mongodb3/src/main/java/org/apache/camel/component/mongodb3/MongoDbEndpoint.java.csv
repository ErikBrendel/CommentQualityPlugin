commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;// ======= Implementation methods ===================================== public Producer createProducer() throws Exception {     validateProducerOptions().     initializeConnection().     return new MongoDbProducer(this). }
false;public;1;22;;public Consumer createConsumer(Processor processor) throws Exception {     validateConsumerOptions().     // we never create the collection     createCollection = false.     initializeConnection().     // select right consumer type     if (consumerType == null) {         consumerType = MongoDbConsumerType.tailable.     }     Consumer consumer.     if (consumerType == MongoDbConsumerType.tailable) {         consumer = new MongoDbTailableCursorConsumer(this, processor).     } else {         throw new CamelMongoDbException("Consumer type not supported: " + consumerType).     }     configureConsumer(consumer).     return consumer. }
true;private;0;15;/**  * Check if outputType is compatible with operation. DbCursor and  * DocumentList applies to findAll. Document applies to others.  */ ;/**  * Check if outputType is compatible with operation. DbCursor and  * DocumentList applies to findAll. Document applies to others.  */ // TODO: validate Output on createProducer @SuppressWarnings("unused") private // method. void validateOutputType() {     if (!ObjectHelper.isEmpty(outputType)) {         if (DocumentList.equals(outputType) && !(findAll.equals(operation))) {             throw new IllegalArgumentException("outputType DocumentList is only compatible with operation findAll").         }         if (MongoIterable.equals(outputType) && !(findAll.equals(operation))) {             throw new IllegalArgumentException("outputType MongoIterable is only compatible with operation findAll").         }         if (Document.equals(outputType) && (findAll.equals(operation))) {             throw new IllegalArgumentException("outputType Document is not compatible with operation findAll").         }     } }
false;private;0;9;;private void validateProducerOptions() throws IllegalArgumentException {     // they haven't been explicitly set, but it is enough     if (!ObjectHelper.isEmpty(consumerType) || persistentTailTracking || !ObjectHelper.isEmpty(tailTrackDb) || !ObjectHelper.isEmpty(tailTrackCollection) || !ObjectHelper.isEmpty(tailTrackField) || cursorRegenerationDelay != 1000L) {         throw new IllegalArgumentException("consumerType, tailTracking, cursorRegenerationDelay options cannot appear on a producer endpoint").     } }
false;private;0;16;;private void validateConsumerOptions() throws IllegalArgumentException {     // they haven't been explicitly set, but it is enough     if (!ObjectHelper.isEmpty(operation) || dynamicity || outputType != null) {         throw new IllegalArgumentException("operation, dynamicity, outputType " + "options cannot appear on a consumer endpoint").     }     if (consumerType == MongoDbConsumerType.tailable) {         if (tailTrackIncreasingField == null) {             throw new IllegalArgumentException("tailTrackIncreasingField option must be set for tailable cursor MongoDB consumer endpoint").         }         if (persistentTailTracking && (ObjectHelper.isEmpty(persistentId))) {             throw new IllegalArgumentException("persistentId is compulsory for persistent tail tracking").         }     } }
false;public;0;3;;public boolean isSingleton() {     return true. }
true;public;0;27;/**  * Initialises the MongoDB connection using the Mongo object provided to the  * endpoint  *  * @throws CamelMongoDbException  */ ;/**  * Initialises the MongoDB connection using the Mongo object provided to the  * endpoint  *  * @throws CamelMongoDbException  */ public void initializeConnection() throws CamelMongoDbException {     log.info("Initialising MongoDb endpoint: {}", this).     if (database == null || (collection == null && !(getDbStats.equals(operation) || command.equals(operation)))) {         throw new CamelMongoDbException("Missing required endpoint configuration: database and/or collection").     }     mongoDatabase = mongoConnection.getDatabase(database).     if (mongoDatabase == null) {         throw new CamelMongoDbException("Could not initialise MongoDbComponent. Database " + database + " does not exist.").     }     if (collection != null) {         if (!createCollection && !databaseContainsCollection(collection)) {             throw new CamelMongoDbException("Could not initialise MongoDbComponent. Collection " + collection + " and createCollection is false.").         }         mongoCollection = mongoDatabase.getCollection(collection, Document.class).         log.debug("MongoDb component initialised and endpoint bound to MongoDB collection with the following parameters. Address list: {}, Db: {}, Collection: {}", new Object[] { mongoConnection.getAllAddress().toString(), mongoDatabase.getName(), collection }).         try {             if (ObjectHelper.isNotEmpty(collectionIndex)) {                 ensureIndex(mongoCollection, createIndex()).             }         } catch (Exception e) {             throw new CamelMongoDbException("Error creating index", e).         }     } }
false;private;1;3;;private boolean databaseContainsCollection(String collectionName) {     return StreamSupport.stream(mongoDatabase.listCollectionNames().spliterator(), false).anyMatch(collectionName::equals). }
true;public;2;8;/**  * Add Index  *  * @param aCollection  */ ;/**  * Add Index  *  * @param aCollection  */ public void ensureIndex(MongoCollection<Document> aCollection, List<Bson> dynamicIndex) {     if (dynamicIndex != null && !dynamicIndex.isEmpty()) {         for (Bson index : dynamicIndex) {             log.debug("create Document Index {}", index).             aCollection.createIndex(index).         }     } }
true;public;0;26;/**  * Create technical list index  *  * @return technical list index  */ ;/**  * Create technical list index  *  * @return technical list index  */ @SuppressWarnings("unchecked") public List<Bson> createIndex() {     try {         List<Bson> indexList = new ArrayList<>().         if (ObjectHelper.isNotEmpty(collectionIndex)) {             HashMap<String, String> indexMap = new ObjectMapper().readValue(collectionIndex, HashMap.class).             for (Map.Entry<String, String> set : indexMap.entrySet()) {                 Document index = new Document().                 // MongoDB 2.4 upwards is restrictive about the type of the                 // 'single field index' being                 // in use below (set.getValue())) as only an integer value                 // type is accepted, otherwise                 // server will throw an exception, see more details:                 // http://docs.mongodb.org/manual/release-notes/2.4/#improved-validation-of-index-types                 index.put(set.getKey(), set.getValue()).                 indexList.add(index).             }         }         return indexList.     } catch (IOException e) {         throw new CamelMongoDbException("createIndex failed", e).     } }
false;public;1;9;;public Exchange createMongoDbExchange(Document dbObj) {     Exchange exchange = super.createExchange().     Message message = exchange.getIn().     message.setHeader(MongoDbConstants.DATABASE, database).     message.setHeader(MongoDbConstants.COLLECTION, collection).     message.setHeader(MongoDbConstants.FROM_TAILABLE, true).     message.setBody(dbObj).     return exchange. }
false;protected;0;6;;@Override protected void doStart() throws Exception {     mongoConnection = CamelContextHelper.mandatoryLookup(getCamelContext(), connectionBean, MongoClient.class).     log.debug("Resolved the connection with the name {} as {}", connectionBean, mongoConnection).     super.doStart(). }
false;public;0;3;;// ======= Getters and setters // =============================================== public String getConnectionBean() {     return connectionBean. }
true;public;1;3;/**  * Name of {@link com.mongodb.Mongo} to use.  */ ;/**  * Name of {@link com.mongodb.Mongo} to use.  */ public void setConnectionBean(String connectionBean) {     this.connectionBean = connectionBean. }
true;public;1;3;/**  * Sets the name of the MongoDB collection to bind to this endpoint  *  * @param collection collection name  */ ;/**  * Sets the name of the MongoDB collection to bind to this endpoint  *  * @param collection collection name  */ public void setCollection(String collection) {     this.collection = collection. }
false;public;0;3;;public String getCollection() {     return collection. }
true;public;1;3;/**  * Sets the collection index (JSON FORMAT : { "field1" : order1, "field2" :  * order2})  */ ;/**  * Sets the collection index (JSON FORMAT : { "field1" : order1, "field2" :  * order2})  */ public void setCollectionIndex(String collectionIndex) {     this.collectionIndex = collectionIndex. }
false;public;0;3;;public String getCollectionIndex() {     return collectionIndex. }
true;public;1;7;/**  * Sets the operation this endpoint will execute against MongoDB. For  * possible values, see {@link MongoDbOperation}.  *  * @param operation name of the operation as per catalogued values  * @throws CamelMongoDbException  */ ;/**  * Sets the operation this endpoint will execute against MongoDB. For  * possible values, see {@link MongoDbOperation}.  *  * @param operation name of the operation as per catalogued values  * @throws CamelMongoDbException  */ public void setOperation(String operation) throws CamelMongoDbException {     try {         this.operation = valueOf(operation).     } catch (IllegalArgumentException e) {         throw new CamelMongoDbException("Operation not supported", e).     } }
false;public;0;3;;public MongoDbOperation getOperation() {     return operation. }
true;public;1;3;/**  * Sets the name of the MongoDB database to target  *  * @param database name of the MongoDB database  */ ;/**  * Sets the name of the MongoDB database to target  *  * @param database name of the MongoDB database  */ public void setDatabase(String database) {     this.database = database. }
false;public;0;3;;public String getDatabase() {     return database. }
true;public;1;3;/**  * Create collection during initialisation if it doesn't exist. Default is  * true.  *  * @param createCollection true or false  */ ;/**  * Create collection during initialisation if it doesn't exist. Default is  * true.  *  * @param createCollection true or false  */ public void setCreateCollection(boolean createCollection) {     this.createCollection = createCollection. }
false;public;0;3;;public boolean isCreateCollection() {     return createCollection. }
true;public;1;3;/**  * Sets the Mongo instance that represents the backing connection  *  * @param mongoConnection the connection to the database  */ ;/**  * Sets the Mongo instance that represents the backing connection  *  * @param mongoConnection the connection to the database  */ public void setMongoConnection(MongoClient mongoConnection) {     this.mongoConnection = mongoConnection. }
false;public;0;3;;public MongoClient getMongoConnection() {     return mongoConnection. }
false;public;0;3;;public WriteConcern getWriteConcern() {     return getMongoConnection().getWriteConcern(). }
true;public;1;10;/**  * Set the {@link WriteConcern} for write operations on MongoDB, passing in  * the bean ref to a custom WriteConcern which exists in the Registry. You  * can also use standard WriteConcerns by passing in their key. See the  * {@link #setWriteConcern(String) setWriteConcern} method.  *  * @param writeConcernRef the name of the bean in the registry that  *            represents the WriteConcern to use  */ ;/**  * Set the {@link WriteConcern} for write operations on MongoDB, passing in  * the bean ref to a custom WriteConcern which exists in the Registry. You  * can also use standard WriteConcerns by passing in their key. See the  * {@link #setWriteConcern(String) setWriteConcern} method.  *  * @param writeConcernRef the name of the bean in the registry that  *            represents the WriteConcern to use  */ public void setWriteConcernRef(String writeConcernRef) {     WriteConcern wc = this.getCamelContext().getRegistry().lookupByNameAndType(writeConcernRef, WriteConcern.class).     if (wc == null) {         String msg = "Camel MongoDB component could not find the WriteConcern in the Registry. Verify that the " + "provided bean name (" + writeConcernRef + ")  is correct. Aborting initialization.".         throw new IllegalArgumentException(msg).     }     this.writeConcernRef = wc. }
false;public;0;3;;public WriteConcern getWriteConcernRef() {     return writeConcernRef. }
false;public;0;3;;public ReadPreference getReadPreference() {     return getMongoConnection().getReadPreference(). }
true;public;1;3;/**  * Sets whether this endpoint will attempt to dynamically resolve the target  * database and collection from the incoming Exchange properties. Can be  * used to override at runtime the database and collection specified on the  * otherwise static endpoint URI. It is disabled by default to boost  * performance. Enabling it will take a minimal performance hit.  *  * @see MongoDbConstants#DATABASE  * @see MongoDbConstants#COLLECTION  * @param dynamicity true or false indicated whether target database and  *            collection should be calculated dynamically based on Exchange  *            properties.  */ ;/**  * Sets whether this endpoint will attempt to dynamically resolve the target  * database and collection from the incoming Exchange properties. Can be  * used to override at runtime the database and collection specified on the  * otherwise static endpoint URI. It is disabled by default to boost  * performance. Enabling it will take a minimal performance hit.  *  * @see MongoDbConstants#DATABASE  * @see MongoDbConstants#COLLECTION  * @param dynamicity true or false indicated whether target database and  *            collection should be calculated dynamically based on Exchange  *            properties.  */ public void setDynamicity(boolean dynamicity) {     this.dynamicity = dynamicity. }
false;public;0;3;;public boolean isDynamicity() {     return dynamicity. }
true;public;1;7;/**  * Reserved for future use, when more consumer types are supported.  *  * @param consumerType key of the consumer type  * @throws CamelMongoDbException  */ ;/**  * Reserved for future use, when more consumer types are supported.  *  * @param consumerType key of the consumer type  * @throws CamelMongoDbException  */ public void setConsumerType(String consumerType) throws CamelMongoDbException {     try {         this.consumerType = MongoDbConsumerType.valueOf(consumerType).     } catch (IllegalArgumentException e) {         throw new CamelMongoDbException("Consumer type not supported", e).     } }
false;public;0;3;;public MongoDbConsumerType getConsumerType() {     return consumerType. }
false;public;0;3;;public String getTailTrackDb() {     return tailTrackDb. }
true;public;1;3;/**  * Indicates what database the tail tracking mechanism will persist to. If  * not specified, the current database will be picked by default. Dynamicity  * will not be taken into account even if enabled, i.e. the tail tracking  * database will not vary past endpoint initialisation.  *  * @param tailTrackDb database name  */ ;/**  * Indicates what database the tail tracking mechanism will persist to. If  * not specified, the current database will be picked by default. Dynamicity  * will not be taken into account even if enabled, i.e. the tail tracking  * database will not vary past endpoint initialisation.  *  * @param tailTrackDb database name  */ public void setTailTrackDb(String tailTrackDb) {     this.tailTrackDb = tailTrackDb. }
false;public;0;3;;public String getTailTrackCollection() {     return tailTrackCollection. }
true;public;1;3;/**  * Collection where tail tracking information will be persisted. If not  * specified, {@link MongoDbTailTrackingConfig#DEFAULT_COLLECTION} will be  * used by default.  *  * @param tailTrackCollection collection name  */ ;/**  * Collection where tail tracking information will be persisted. If not  * specified, {@link MongoDbTailTrackingConfig#DEFAULT_COLLECTION} will be  * used by default.  *  * @param tailTrackCollection collection name  */ public void setTailTrackCollection(String tailTrackCollection) {     this.tailTrackCollection = tailTrackCollection. }
false;public;0;3;;public String getTailTrackField() {     return tailTrackField. }
true;public;1;3;/**  * Field where the last tracked value will be placed. If not specified,  * {@link MongoDbTailTrackingConfig#DEFAULT_FIELD} will be used by default.  *  * @param tailTrackField field name  */ ;/**  * Field where the last tracked value will be placed. If not specified,  * {@link MongoDbTailTrackingConfig#DEFAULT_FIELD} will be used by default.  *  * @param tailTrackField field name  */ public void setTailTrackField(String tailTrackField) {     this.tailTrackField = tailTrackField. }
true;public;1;3;/**  * Enable persistent tail tracking, which is a mechanism to keep track of  * the last consumed message across system restarts. The next time the  * system is up, the endpoint will recover the cursor from the point where  * it last stopped slurping records.  *  * @param persistentTailTracking true or false  */ ;/**  * Enable persistent tail tracking, which is a mechanism to keep track of  * the last consumed message across system restarts. The next time the  * system is up, the endpoint will recover the cursor from the point where  * it last stopped slurping records.  *  * @param persistentTailTracking true or false  */ public void setPersistentTailTracking(boolean persistentTailTracking) {     this.persistentTailTracking = persistentTailTracking. }
false;public;0;3;;public boolean isPersistentTailTracking() {     return persistentTailTracking. }
true;public;1;3;/**  * Correlation field in the incoming record which is of increasing nature  * and will be used to position the tailing cursor every time it is  * generated. The cursor will be (re)created with a query of type:  * tailTrackIncreasingField > lastValue (possibly recovered from persistent  * tail tracking). Can be of type Integer, Date, String, etc. NOTE: No  * support for dot notation at the current time, so the field should be at  * the top level of the document.  *  * @param tailTrackIncreasingField  */ ;/**  * Correlation field in the incoming record which is of increasing nature  * and will be used to position the tailing cursor every time it is  * generated. The cursor will be (re)created with a query of type:  * tailTrackIncreasingField > lastValue (possibly recovered from persistent  * tail tracking). Can be of type Integer, Date, String, etc. NOTE: No  * support for dot notation at the current time, so the field should be at  * the top level of the document.  *  * @param tailTrackIncreasingField  */ public void setTailTrackIncreasingField(String tailTrackIncreasingField) {     this.tailTrackIncreasingField = tailTrackIncreasingField. }
false;public;0;3;;public String getTailTrackIncreasingField() {     return tailTrackIncreasingField. }
false;public;0;7;;public MongoDbTailTrackingConfig getTailTrackingConfig() {     if (tailTrackingConfig == null) {         tailTrackingConfig = new MongoDbTailTrackingConfig(persistentTailTracking, tailTrackIncreasingField, tailTrackDb == null ? database : tailTrackDb, tailTrackCollection, tailTrackField, getPersistentId()).     }     return tailTrackingConfig. }
true;public;1;3;/**  * MongoDB tailable cursors will block until new data arrives. If no new  * data is inserted, after some time the cursor will be automatically freed  * and closed by the MongoDB server. The client is expected to regenerate  * the cursor if needed. This value specifies the time to wait before  * attempting to fetch a new cursor, and if the attempt fails, how long  * before the next attempt is made. Default value is 1000ms.  *  * @param cursorRegenerationDelay delay specified in milliseconds  */ ;/**  * MongoDB tailable cursors will block until new data arrives. If no new  * data is inserted, after some time the cursor will be automatically freed  * and closed by the MongoDB server. The client is expected to regenerate  * the cursor if needed. This value specifies the time to wait before  * attempting to fetch a new cursor, and if the attempt fails, how long  * before the next attempt is made. Default value is 1000ms.  *  * @param cursorRegenerationDelay delay specified in milliseconds  */ public void setCursorRegenerationDelay(long cursorRegenerationDelay) {     this.cursorRegenerationDelay = cursorRegenerationDelay. }
false;public;0;3;;public long getCursorRegenerationDelay() {     return cursorRegenerationDelay. }
true;public;1;3;/**  * One tail tracking collection can host many trackers for several tailable  * consumers. To keep them separate, each tracker should have its own unique  * persistentId.  *  * @param persistentId the value of the persistent ID to use for this  *            tailable consumer  */ ;/**  * One tail tracking collection can host many trackers for several tailable  * consumers. To keep them separate, each tracker should have its own unique  * persistentId.  *  * @param persistentId the value of the persistent ID to use for this  *            tailable consumer  */ public void setPersistentId(String persistentId) {     this.persistentId = persistentId. }
false;public;0;3;;public String getPersistentId() {     return persistentId. }
false;public;0;3;;public boolean isWriteResultAsHeader() {     return writeResultAsHeader. }
true;public;1;3;/**  * In write operations, it determines whether instead of returning  * {@link WriteResult} as the body of the OUT message, we transfer the IN  * message to the OUT and attach the WriteResult as a header.  *  * @param writeResultAsHeader flag to indicate if this option is enabled  */ ;/**  * In write operations, it determines whether instead of returning  * {@link WriteResult} as the body of the OUT message, we transfer the IN  * message to the OUT and attach the WriteResult as a header.  *  * @param writeResultAsHeader flag to indicate if this option is enabled  */ public void setWriteResultAsHeader(boolean writeResultAsHeader) {     this.writeResultAsHeader = writeResultAsHeader. }
false;public;0;3;;public MongoDbOutputType getOutputType() {     return outputType. }
true;public;1;3;/**  * Convert the output of the producer to the selected type : DocumentList Document or MongoIterable.  * DocumentList or MongoIterable applies to findAll and aggregate. Document applies to all other operations.  * @param outputType  */ ;/**  * Convert the output of the producer to the selected type : DocumentList Document or MongoIterable.  * DocumentList or MongoIterable applies to findAll and aggregate. Document applies to all other operations.  * @param outputType  */ public void setOutputType(MongoDbOutputType outputType) {     this.outputType = outputType. }
false;public;0;3;;public MongoDatabase getMongoDatabase() {     return mongoDatabase. }
false;public;0;3;;public MongoCollection<Document> getMongoCollection() {     return mongoCollection. }
