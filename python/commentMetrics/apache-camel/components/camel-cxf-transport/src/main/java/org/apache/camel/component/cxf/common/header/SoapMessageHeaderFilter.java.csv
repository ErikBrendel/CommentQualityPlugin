commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public List<String> getActivationNamespaces() {     return ACTIVATION_NS. }
false;public;2;32;;public void filter(Direction direction, List<Header> headers) {     // Treat both in and out direction the same     if (headers == null) {         return.     }     Iterator<Header> iterator = headers.iterator().     while (iterator.hasNext()) {         Header header = iterator.next().         LOG.trace("Processing header: {}", header).         if (!(header instanceof SoapHeader)) {             LOG.trace("Skipped header: {} since it is not a SoapHeader", header).             continue.         }         SoapHeader soapHeader = SoapHeader.class.cast(header).         for (Iterator<SoapVersion> itv = SoapVersionFactory.getInstance().getVersions(). itv.hasNext(). ) {             SoapVersion version = itv.next().             if (soapHeader.getActor() != null && soapHeader.getActor().equals(version.getNextRole())) {                 // dropping headers if actor/role equals to {ns}/role|actor/next                 // cxf SoapHeader needs to have soap:header@relay attribute,                 // then we can check for it here as well                 LOG.trace("Filtered header: {}", header).                 iterator.remove().                 break.             }         }     } }
