commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;3;;protected java.util.logging.Logger getLogger() {     return JUL_LOG. }
false;public;1;3;;public void setCheckException(boolean exception) {     checkException = exception. }
false;public;0;3;;public boolean isCheckException() {     return checkException. }
true;protected;1;4;/**  * @param inMessage the incoming message  * @return the inbuilt backchannel  */ ;/**  * @param inMessage the incoming message  * @return the inbuilt backchannel  */ protected Conduit getInbuiltBackChannel(Message inMessage) {     // we can pass the message back by looking up the camelExchange from inMessage     return new BackChannelConduit(inMessage). }
false;public;0;20;;public void activate() {     LOG.debug("CamelDestination activate().... ").     ObjectHelper.notNull(camelContext, "CamelContext", this).     try {         LOG.debug("establishing Camel connection").         destinationEndpoint = getCamelContext().getEndpoint(camelDestinationUri).         if (destinationEndpoint == null) {             throw new NoSuchEndpointException(camelDestinationUri).         }         consumer = destinationEndpoint.createConsumer(new ConsumerProcessor()).         ServiceHelper.startService(consumer).     } catch (NoSuchEndpointException nex) {         throw nex.     } catch (Exception ex) {         if (destinationEndpoint == null) {             throw new FailedToCreateConsumerException(camelDestinationUri, ex).         }         throw new FailedToCreateConsumerException(destinationEndpoint, ex).     } }
false;public;0;7;;public void deactivate() {     try {         ServiceHelper.stopService(consumer).     } catch (Exception e) {         LOG.warn("Error stopping consumer", e).     } }
false;public;0;4;;public void shutdown() {     LOG.debug("CamelDestination shutdown()").     this.deactivate(). }
false;public;0;3;;public CamelContext getCamelContext() {     return camelContext. }
false;public;1;3;;public void setCamelContext(CamelContext camelContext) {     this.camelContext = camelContext. }
false;protected;1;13;;protected void incoming(org.apache.camel.Exchange camelExchange) {     LOG.debug("server received request: ", camelExchange).     DefaultCxfMessageMapper beanBinding = new DefaultCxfMessageMapper().     org.apache.cxf.message.Message inMessage = beanBinding.createCxfMessageFromCamelExchange(camelExchange, headerFilterStrategy).     inMessage.put(CamelTransportConstants.CAMEL_EXCHANGE, camelExchange).     ((MessageImpl) inMessage).setDestination(this).     // Handling the incoming message     // The response message will be send back by the outgoing chain     incomingObserver.onMessage(inMessage). }
false;public;0;6;;public String getBeanName() {     if (endpointInfo == null || endpointInfo.getName() == null) {         return "default" + BASE_BEAN_NAME_SUFFIX.     }     return endpointInfo.getName().toString() + BASE_BEAN_NAME_SUFFIX. }
false;public;0;3;;public String getCamelDestinationUri() {     return camelDestinationUri. }
false;private;0;9;;private void initConfig() {     // we could configure the camel context here     if (bus != null) {         Configurer configurer = bus.getExtension(Configurer.class).         if (null != configurer) {             configurer.configureBean(this).         }     } }
false;public;1;7;;public void process(Exchange exchange) {     try {         incoming(exchange).     } catch (Throwable ex) {         exchange.setException(ex).     } }
true;public;1;3;/**  * Register a message observer for incoming messages.  *  * @param observer the observer to notify on receipt of incoming  */ ;/**  * Register a message observer for incoming messages.  *  * @param observer the observer to notify on receipt of incoming  */ public void setMessageObserver(MessageObserver observer) { // shouldn't be called for a back channel conduit }
true;public;1;4;/**  * Send an outbound message, assumed to contain all the name-value  * mappings of the corresponding input message (if any).  *  * @param message the message to be sent.  */ ;/**  * Send an outbound message, assumed to contain all the name-value  * mappings of the corresponding input message (if any).  *  * @param message the message to be sent.  */ public void prepare(Message message) throws IOException {     message.put(CamelTransportConstants.CAMEL_EXCHANGE, inMessage.get(CamelTransportConstants.CAMEL_EXCHANGE)).     message.setContent(OutputStream.class, new CamelOutputStream(message)). }
false;protected;0;3;;protected java.util.logging.Logger getLogger() {     return JUL_LOG. }
true;protected;2;4;/**  * Mark message as a partial message.  *  * @param partialResponse the partial response message  * @param decoupledTarget the decoupled target  * @return <tt>true</tt> if partial responses is supported  */ ;/**  * Mark message as a partial message.  *  * @param partialResponse the partial response message  * @param decoupledTarget the decoupled target  * @return <tt>true</tt> if partial responses is supported  */ protected boolean markPartialResponse(Message partialResponse, EndpointReferenceType decoupledTarget) {     return true. }
true;protected;0;3;/**  * @return the associated conduit initiator  */ ;/**  * @return the associated conduit initiator  */ protected ConduitInitiator getConduitInitiator() {     return conduitInitiator. }
false;protected;2;6;;protected void propagateResponseHeadersToCamel(Message outMessage, Exchange camelExchange) {     // copy the camel in message header to the out message     camelExchange.getOut().getHeaders().putAll(camelExchange.getIn().getHeaders()).     CxfHeaderHelper.propagateCxfToCamel(headerFilterStrategy, outMessage, camelExchange.getOut(), camelExchange). }
true;private;0;18;// Prepare the message and get the send out message ;// Prepare the message and get the send out message private void commitOutputMessage() throws IOException {     Exchange camelExchange = (Exchange) outMessage.get(CamelTransportConstants.CAMEL_EXCHANGE).     propagateResponseHeadersToCamel(outMessage, camelExchange).     // check if the outMessage has the exception     Exception exception = outMessage.getContent(Exception.class).     if (checkException && exception != null) {         camelExchange.setException(exception).     }     OutputStream outputStream = outMessage.getContent(OutputStream.class).     if (outputStream instanceof CachedOutputStream) {         camelExchange.getOut().setBody(((CachedOutputStream) outputStream).getInputStream()).     } else {         camelExchange.getOut().setBody(outputStream).     }     LOG.debug("send the response message: {}", outputStream). }
false;protected;0;4;;@Override protected void doFlush() throws IOException { // Do nothing here }
false;protected;0;4;;@Override protected void doClose() throws IOException {     commitOutputMessage(). }
false;protected;0;4;;@Override protected void onWrite() throws IOException { // Do nothing here }
