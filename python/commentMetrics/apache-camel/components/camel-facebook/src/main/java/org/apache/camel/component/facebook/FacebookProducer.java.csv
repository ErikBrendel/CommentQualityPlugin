commented;modifiers;parameterAmount;loc;comment;code
false;public;0;39;;@Override public void run() {     try {         if (LOG.isDebugEnabled()) {             LOG.debug("Invoking method {} with {}", method.getName(), properties.keySet()).         }         // also check whether we need to get Raw JSON         Object result.         String rawJSON = null.         if (endpoint.getConfiguration().getJsonStoreEnabled() == null || !endpoint.getConfiguration().getJsonStoreEnabled()) {             result = FacebookMethodsTypeHelper.invokeMethod(endpoint.getConfiguration().getFacebook(), method, properties).         } else {             final Facebook facebook = endpoint.getConfiguration().getFacebook().             // lock out the underlying Facebook object from other threads             synchronized (facebook) {                 result = FacebookMethodsTypeHelper.invokeMethod(facebook, method, properties).                 rawJSON = DataObjectFactory.getRawJSON(result).             }         }         // producer returns a single response, even for methods with List return types         exchange.getOut().setBody(result).         // copy headers         exchange.getOut().setHeaders(exchange.getIn().getHeaders()).         if (rawJSON != null) {             exchange.getOut().setHeader(FacebookConstants.FACEBOOK_PROPERTY_PREFIX + "rawJSON", rawJSON).         }     } catch (Throwable t) {         exchange.setException(RuntimeCamelException.wrapRuntimeCamelException(t)).     } finally {         callback.done(false).     } }
false;public;2;64;;@Override public boolean process(final Exchange exchange, final AsyncCallback callback) {     // properties for method arguments     final Map<String, Object> properties = new HashMap<>().     getExchangeProperties(exchange, properties).     FacebookPropertiesHelper.configureReadingProperties(endpoint.getConfiguration(), properties).     getEndpointProperties(endpoint.getConfiguration(), properties).     // decide which method to invoke     final FacebookMethodsType method = findMethod(exchange, properties).     if (method == null) {         // synchronous failure         callback.done(true).         return true.     }     // create a runnable invocation task to be submitted on a background thread pool     // this way we avoid blocking the current thread for long running operations     Runnable invocation = new Runnable() {          @Override         public void run() {             try {                 if (LOG.isDebugEnabled()) {                     LOG.debug("Invoking method {} with {}", method.getName(), properties.keySet()).                 }                 // also check whether we need to get Raw JSON                 Object result.                 String rawJSON = null.                 if (endpoint.getConfiguration().getJsonStoreEnabled() == null || !endpoint.getConfiguration().getJsonStoreEnabled()) {                     result = FacebookMethodsTypeHelper.invokeMethod(endpoint.getConfiguration().getFacebook(), method, properties).                 } else {                     final Facebook facebook = endpoint.getConfiguration().getFacebook().                     // lock out the underlying Facebook object from other threads                     synchronized (facebook) {                         result = FacebookMethodsTypeHelper.invokeMethod(facebook, method, properties).                         rawJSON = DataObjectFactory.getRawJSON(result).                     }                 }                 // producer returns a single response, even for methods with List return types                 exchange.getOut().setBody(result).                 // copy headers                 exchange.getOut().setHeaders(exchange.getIn().getHeaders()).                 if (rawJSON != null) {                     exchange.getOut().setHeader(FacebookConstants.FACEBOOK_PROPERTY_PREFIX + "rawJSON", rawJSON).                 }             } catch (Throwable t) {                 exchange.setException(RuntimeCamelException.wrapRuntimeCamelException(t)).             } finally {                 callback.done(false).             }         }     }.     getExecutorService(getEndpoint().getCamelContext()).submit(invocation).     return false. }
false;private;1;8;;private boolean hasReadingParameters(Map<String, Object> properties) {     for (String parameterName : properties.keySet()) {         if (parameterName.startsWith(FacebookConstants.READING_PREFIX)) {             return true.         }     }     return false. }
false;private;2;28;;private FacebookMethodsType findMethod(Exchange exchange, Map<String, Object> properties) {     FacebookMethodsType method = null.     final List<FacebookMethodsType> candidates = endpoint.getCandidates().     if (processInBody(exchange, properties)) {         // filter candidates based on endpoint and exchange properties         final Set<String> argNames = properties.keySet().         final List<FacebookMethodsType> filteredMethods = filterMethods(candidates, MatchType.SUPER_SET, argNames.toArray(new String[argNames.size()])).         // get the method to call         if (filteredMethods.isEmpty()) {             final Set<String> missing = getMissingProperties(endpoint.getMethod(), endpoint.getNameStyle(), argNames).             throw new RuntimeCamelException(String.format("Missing properties for %s, need one or more from %s", endpoint.getMethod(), missing)).         } else if (filteredMethods.size() == 1) {             // found an exact match             method = filteredMethods.get(0).         } else {             method = FacebookMethodsTypeHelper.getHighestPriorityMethod(filteredMethods).             LOG.warn("Calling highest priority method {} from methods {}", method, filteredMethods).         }     }     return method. }
true;private;2;22;// returns false on exception, which is set in exchange ;// returns false on exception, which is set in exchange private boolean processInBody(Exchange exchange, Map<String, Object> properties) {     final String inBodyProperty = endpoint.getInBody().     if (inBodyProperty != null) {         Object value = exchange.getIn().getBody().         try {             value = getEndpoint().getCamelContext().getTypeConverter().mandatoryConvertTo(FacebookEndpointConfiguration.class.getDeclaredField(inBodyProperty).getType(), exchange, value).         } catch (Exception e) {             exchange.setException(new RuntimeCamelException(String.format("Error converting value %s to property %s: %s", value, inBodyProperty, e.getMessage()), e)).             return false.         }         LOG.debug("Property [{}] has message body value {}", inBodyProperty, value).         properties.put(inBodyProperty, value).     }     return true. }
false;protected,static,synchronized;1;22;;protected static synchronized ExecutorService getExecutorService(CamelContext context) {     // re-create it (its a shared static instance)     if (executorService == null || executorService.isTerminated() || executorService.isShutdown()) {         final ExecutorServiceManager manager = context.getExecutorServiceManager().         // try to lookup a pool first based on profile         ThreadPoolProfile poolProfile = manager.getThreadPoolProfile(FacebookConstants.FACEBOOK_THREAD_PROFILE_NAME).         if (poolProfile == null) {             poolProfile = manager.getDefaultThreadPoolProfile().         }         // create a new pool using the custom or default profile         executorService = manager.newScheduledThreadPool(FacebookProducer.class, FacebookConstants.FACEBOOK_THREAD_PROFILE_NAME, poolProfile).     }     return executorService. }
