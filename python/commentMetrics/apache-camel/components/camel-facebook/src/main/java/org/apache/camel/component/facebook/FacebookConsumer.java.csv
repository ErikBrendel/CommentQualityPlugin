commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override public boolean isGreedy() {     // make this consumer not greedy to avoid making too many Facebook calls     return false. }
false;private;0;28;;private FacebookMethodsType findMethod() {     FacebookMethodsType result.     // find one that takes the largest subset of endpoint parameters     final Set<String> argNames = new HashSet<>().     argNames.addAll(FacebookPropertiesHelper.getEndpointPropertyNames(endpoint.getConfiguration())).     // add reading property for polling, if it doesn't already exist!     argNames.add(READING_PROPERTY).     final String[] argNamesArray = argNames.toArray(new String[argNames.size()]).     List<FacebookMethodsType> filteredMethods = filterMethods(endpoint.getCandidates(), MatchType.SUPER_SET, argNamesArray).     if (filteredMethods.isEmpty()) {         throw new IllegalArgumentException(String.format("Missing properties for %s, need one or more from %s", endpoint.getMethod(), getMissingProperties(endpoint.getMethod(), endpoint.getNameStyle(), argNames))).     } else if (filteredMethods.size() == 1) {         // single match         result = filteredMethods.get(0).     } else {         result = getHighestPriorityMethod(filteredMethods).         log.warn("Using highest priority method {} from methods {}", method, filteredMethods).     }     return result. }
false;protected;0;37;;@Override protected int poll() throws Exception {     // invoke the consumer method     final Map<String, Object> args = getMethodArguments().     try {         // also check whether we need to get raw JSON         String rawJSON = null.         Object result.         if (endpoint.getConfiguration().getJsonStoreEnabled() == null || !endpoint.getConfiguration().getJsonStoreEnabled()) {             result = invokeMethod(endpoint.getConfiguration().getFacebook(), method, args).         } else {             final Facebook facebook = endpoint.getConfiguration().getFacebook().             synchronized (facebook) {                 result = invokeMethod(facebook, method, args).                 rawJSON = DataObjectFactory.getRawJSON(result).             }         }         // process result according to type         if (result != null && (result instanceof Collection || result.getClass().isArray())) {             // create an exchange for every element             final Object array = getResultAsArray(result).             final int length = Array.getLength(array).             for (int i = 0. i < length. i++) {                 processResult(Array.get(array, i), rawJSON).             }             return length.         } else {             processResult(result, rawJSON).             // number of messages polled             return 1.         }     } catch (Throwable t) {         throw RuntimeCamelException.wrapRuntimeCamelException(t).     } }
false;private;2;16;;private void processResult(Object result, String rawJSON) throws Exception {     Exchange exchange = endpoint.createExchange().     exchange.getIn().setBody(result).     if (rawJSON != null) {         exchange.getIn().setHeader(FacebookConstants.RAW_JSON_HEADER, rawJSON).     }     try {         // send message to next processor in the route         getProcessor().process(exchange).     } finally {         // log exception if an exception occurred and was not handled         if (exchange.getException() != null) {             getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException()).         }     } }
false;private;1;10;;private Object getResultAsArray(Object result) {     if (result.getClass().isArray()) {         // no conversion needed         return result.     }     // must be a Collection     // TODO add support for Paging using ResponseList     Collection<?> collection = (Collection<?>) result.     return collection.toArray(new Object[collection.size()]). }
false;private;0;42;;private Map<String, Object> getMethodArguments() {     // start by setting the Reading since and until fields,     // these are used to avoid reading duplicate results across polls     Map<String, Object> arguments = new HashMap<>().     arguments.putAll(endpointProperties).     Reading reading = (Reading) arguments.remove(READING_PROPERTY).     if (reading == null) {         reading = new Reading().     } else {         try {             reading = ReadingBuilder.copy(reading, true).         } catch (NoSuchFieldException e) {             throw new IllegalArgumentException(String.format("Error creating property [%s]: %s", READING_PROPERTY, e.getMessage()), e).         } catch (IllegalAccessException e) {             throw new IllegalArgumentException(String.format("Error creating property [%s]: %s", READING_PROPERTY, e.getMessage()), e).         }     }     // now set since and until for this poll     final SimpleDateFormat dateFormat = new SimpleDateFormat(FACEBOOK_DATE_FORMAT).     final long currentMillis = System.currentTimeMillis().     if (this.sinceTime == null) {         // first poll, set this to (current time - initial poll delay)         final Date startTime = new Date(currentMillis - TimeUnit.MILLISECONDS.convert(getInitialDelay(), getTimeUnit())).         this.sinceTime = dateFormat.format(startTime).     } else if (this.untilTime != null) {         // use the last 'until' time         this.sinceTime = this.untilTime.     }     this.untilTime = dateFormat.format(new Date(currentMillis)).     reading.since(this.sinceTime).     reading.until(this.untilTime).     arguments.put(READING_PROPERTY, reading).     return arguments. }
