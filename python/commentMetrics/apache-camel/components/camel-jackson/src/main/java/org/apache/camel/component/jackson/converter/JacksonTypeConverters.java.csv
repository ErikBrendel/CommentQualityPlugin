commented;modifiers;parameterAmount;loc;comment;code
false;public;4;64;;@FallbackConverter public <T> T convertTo(Class<T> type, Exchange exchange, Object value, TypeConverterRegistry registry) throws Exception {     // only do this if enabled (disabled by default)     if (!init && exchange != null) {         // init to see if this is enabled         String text = exchange.getContext().getGlobalOptions().get(JacksonConstants.ENABLE_TYPE_CONVERTER).         if (text != null) {             text = exchange.getContext().resolvePropertyPlaceholders(text).             enabled = "true".equalsIgnoreCase(text).         }         // pojoOnly is enabled by default         text = exchange.getContext().getGlobalOptions().get(JacksonConstants.TYPE_CONVERTER_TO_POJO).         if (text != null) {             text = exchange.getContext().resolvePropertyPlaceholders(text).             toPojo = "true".equalsIgnoreCase(text).         }         init = true.     }     if (!enabled) {         return null.     }     if (!toPojo && isNotPojoType(type)) {         return null.     }     if (exchange != null) {         ObjectMapper mapper = resolveObjectMapper(exchange.getContext().getRegistry()).         // if we want to convert to a String or byte[] then use write operation         if (String.class.isAssignableFrom(type)) {             String out = mapper.writeValueAsString(value).             return type.cast(out).         } else if (byte[].class.isAssignableFrom(type)) {             byte[] out = mapper.writeValueAsBytes(value).             return type.cast(out).         } else if (mapper.canSerialize(type) && !Enum.class.isAssignableFrom(type)) {             // if the source value type is readable by the mapper then use its read operation             if (String.class.isAssignableFrom(value.getClass())) {                 return mapper.readValue((String) value, type).             } else if (byte[].class.isAssignableFrom(value.getClass())) {                 return mapper.readValue((byte[]) value, type).             } else if (File.class.isAssignableFrom(value.getClass())) {                 return mapper.readValue((File) value, type).             } else if (InputStream.class.isAssignableFrom(value.getClass())) {                 return mapper.readValue((InputStream) value, type).             } else if (Reader.class.isAssignableFrom(value.getClass())) {                 return mapper.readValue((Reader) value, type).             } else {                 // fallback to generic convert value                 return mapper.convertValue(value, type).             }         }     }     // Just return null to let other fallback converter to do the job     return null. }
true;private,static;1;8;/**  * Whether the type is NOT a pojo type but only a set of simple types such as String and numbers.  */ ;/**  * Whether the type is NOT a pojo type but only a set of simple types such as String and numbers.  */ private static boolean isNotPojoType(Class<?> type) {     boolean isString = String.class.isAssignableFrom(type).     boolean isNumber = Number.class.isAssignableFrom(type) || int.class.isAssignableFrom(type) || long.class.isAssignableFrom(type) || short.class.isAssignableFrom(type) || char.class.isAssignableFrom(type) || float.class.isAssignableFrom(type) || double.class.isAssignableFrom(type).     return isString || isNumber. }
false;private;1;7;;private ObjectMapper resolveObjectMapper(Registry registry) {     Set<ObjectMapper> mappers = registry.findByType(ObjectMapper.class).     if (mappers.size() == 1) {         return mappers.iterator().next().     }     return defaultMapper. }
