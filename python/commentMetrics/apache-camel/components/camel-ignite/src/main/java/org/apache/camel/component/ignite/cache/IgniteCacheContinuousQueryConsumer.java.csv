commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;10;;@Override protected void doStart() throws Exception {     super.doStart().     launchContinuousQuery().     log.info("Started Ignite Cache Continuous Query consumer for cache {} with query: {}.", cache.getName(), endpoint.getQuery()).     maybeFireExistingQueryResults(). }
false;public;1;4;;@Override public void done(boolean doneSync) { // do nothing }
false;private;0;19;;private void maybeFireExistingQueryResults() {     if (!endpoint.isFireExistingQueryResults()) {         log.info(String.format("Skipping existing cache results for cache name = %s.", endpoint.getCacheName())).         return.     }     log.info(String.format("Processing existing cache results for cache name = %s.", endpoint.getCacheName())).     for (Entry<Object, Object> entry : cursor) {         Exchange exchange = createExchange(entry.getValue()).         exchange.getIn().setHeader(IgniteConstants.IGNITE_CACHE_KEY, entry.getKey()).         getAsyncProcessor().process(createExchange(entry), new AsyncCallback() {              @Override             public void done(boolean doneSync) {             // do nothing             }         }).     } }
false;public;1;15;;@Override public void onUpdated(Iterable<CacheEntryEvent<? extends Object, ? extends Object>> events) throws CacheEntryListenerException {     if (log.isTraceEnabled()) {         log.info("Processing Continuous Query event(s): {}.", events).     }     if (!endpoint.isOneExchangePerUpdate()) {         fireGroupedExchange(events).         return.     }     for (CacheEntryEvent<? extends Object, ? extends Object> entry : events) {         fireSingleExchange(entry).     } }
false;private;0;35;;private void launchContinuousQuery() {     ContinuousQuery<Object, Object> continuousQuery = new ContinuousQuery<>().     if (endpoint.getQuery() != null) {         continuousQuery.setInitialQuery(endpoint.getQuery()).     }     if (endpoint.getRemoteFilter() != null) {         continuousQuery.setRemoteFilter(endpoint.getRemoteFilter()).     }     continuousQuery.setLocalListener(new CacheEntryUpdatedListener<Object, Object>() {          @Override         public void onUpdated(Iterable<CacheEntryEvent<? extends Object, ? extends Object>> events) throws CacheEntryListenerException {             if (log.isTraceEnabled()) {                 log.info("Processing Continuous Query event(s): {}.", events).             }             if (!endpoint.isOneExchangePerUpdate()) {                 fireGroupedExchange(events).                 return.             }             for (CacheEntryEvent<? extends Object, ? extends Object> entry : events) {                 fireSingleExchange(entry).             }         }     }).     continuousQuery.setAutoUnsubscribe(endpoint.isAutoUnsubscribe()).     continuousQuery.setPageSize(endpoint.getPageSize()).     continuousQuery.setTimeInterval(endpoint.getTimeInterval()).     cursor = cache.query(continuousQuery). }
false;protected;0;8;;@Override protected void doStop() throws Exception {     super.doStop().     cursor.close().     log.info("Stopped Ignite Cache Continuous Query consumer for cache {} with query: {}.", cache.getName(), endpoint.getQuery()). }
false;public;1;4;;@Override public void done(boolean doneSync) { // do nothing }
false;private;1;12;;private void fireSingleExchange(CacheEntryEvent<? extends Object, ? extends Object> entry) {     Exchange exchange = createExchange(entry.getValue()).     exchange.getIn().setHeader(IgniteConstants.IGNITE_CACHE_EVENT_TYPE, entry.getEventType()).     exchange.getIn().setHeader(IgniteConstants.IGNITE_CACHE_OLD_VALUE, entry.getOldValue()).     exchange.getIn().setHeader(IgniteConstants.IGNITE_CACHE_KEY, entry.getKey()).     getAsyncProcessor().process(exchange, new AsyncCallback() {          @Override         public void done(boolean doneSync) {         // do nothing         }     }). }
false;public;1;4;;@Override public void done(boolean doneSync) { // do nothing }
false;private;1;9;;private void fireGroupedExchange(Iterable<CacheEntryEvent<? extends Object, ? extends Object>> events) {     Exchange exchange = createExchange(events).     getAsyncProcessor().process(exchange, new AsyncCallback() {          @Override         public void done(boolean doneSync) {         // do nothing         }     }). }
false;private;1;7;;private Exchange createExchange(Object payload) {     Exchange exchange = endpoint.createExchange(ExchangePattern.InOnly).     Message in = exchange.getIn().     in.setBody(payload).     in.setHeader(IgniteConstants.IGNITE_CACHE_NAME, endpoint.getCacheName()).     return exchange. }
