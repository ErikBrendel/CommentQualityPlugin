commented;modifiers;parameterAmount;loc;comment;code
false;public;2;43;;@Override public boolean process(Exchange exchange, AsyncCallback callback) {     Message in = exchange.getIn().     Message out = exchange.getOut().     MessageHelper.copyHeaders(exchange.getIn(), out, true).     switch(cacheOperationFor(exchange)) {         case GET:             doGet(in, out).             break.         case PUT:             doPut(in, out).             break.         case QUERY:             doQuery(in, out, exchange).             break.         case REMOVE:             doRemove(in, out).             break.         case CLEAR:             doClear(in, out).             break.         case SIZE:             doSize(in, out).             break.         case REBALANCE:             doRebalance(in, out).             break.         default:             break.     }     callback.done(false).     return false. }
false;private;2;10;;@SuppressWarnings("unchecked") private void doGet(Message in, Message out) {     Object cacheKey = cacheKey(in).     if (cacheKey instanceof Set && !endpoint.isTreatCollectionsAsCacheObjects()) {         out.setBody(cache.getAll((Set<Object>) cacheKey)).     } else {         out.setBody(cache.get(cacheKey)).     } }
false;private;2;19;;@SuppressWarnings("unchecked") private void doPut(Message in, Message out) {     Map<Object, Object> map = in.getBody(Map.class).     if (map != null) {         cache.putAll(map).         return.     }     Object cacheKey = in.getHeader(IgniteConstants.IGNITE_CACHE_KEY).     if (cacheKey == null) {         throw new RuntimeCamelException("Cache PUT operation requires the cache key in the CamelIgniteCacheKey header, " + "or a payload of type Map.").     }     cache.put(cacheKey, in.getBody()).     IgniteHelper.maybePropagateIncomingBody(endpoint, in, out). }
false;public;1;4;;@Override public void onFailure(Exchange exchange) {     cursor.close(). }
false;public;1;4;;@Override public void onComplete(Exchange exchange) {     cursor.close(). }
false;private;3;30;;@SuppressWarnings("unchecked") private void doQuery(Message in, Message out, Exchange exchange) {     Query<Object> query = in.getHeader(IgniteConstants.IGNITE_CACHE_QUERY, Query.class).     if (query == null) {         try {             query = in.getMandatoryBody(Query.class).         } catch (InvalidPayloadException e) {             exchange.setException(e).             return.         }     }     final QueryCursor<Object> cursor = cache.query(query).     out.setBody(cursor.iterator()).     exchange.addOnCompletion(new Synchronization() {          @Override         public void onFailure(Exchange exchange) {             cursor.close().         }          @Override         public void onComplete(Exchange exchange) {             cursor.close().         }     }). }
false;private;2;12;;@SuppressWarnings("unchecked") private void doRemove(Message in, Message out) {     Object cacheKey = cacheKey(in).     if (cacheKey instanceof Set && !endpoint.isTreatCollectionsAsCacheObjects()) {         cache.removeAll((Set<Object>) cacheKey).     } else {         cache.remove(cacheKey).     }     IgniteHelper.maybePropagateIncomingBody(endpoint, in, out). }
false;private;2;5;;private void doClear(Message in, Message out) {     cache.removeAll().     IgniteHelper.maybePropagateIncomingBody(endpoint, in, out). }
false;private;2;5;;private void doRebalance(Message in, Message out) {     cache.rebalance().get().     IgniteHelper.maybePropagateIncomingBody(endpoint, in, out). }
false;private;2;13;;@SuppressWarnings("unchecked") private void doSize(Message in, Message out) {     Object peekMode = in.getHeader(IgniteConstants.IGNITE_CACHE_PEEK_MODE, endpoint.getCachePeekMode()).     Integer result = null.     if (peekMode instanceof Collection) {         result = cache.size(((Collection<Object>) peekMode).toArray(new CachePeekMode[0])).     } else if (peekMode instanceof CachePeekMode) {         result = cache.size((CachePeekMode) peekMode).     }     out.setBody(result). }
false;private;1;7;;private Object cacheKey(Message msg) {     Object cacheKey = msg.getHeader(IgniteConstants.IGNITE_CACHE_KEY).     if (cacheKey == null) {         cacheKey = msg.getBody().     }     return cacheKey. }
false;private;1;3;;private IgniteCacheOperation cacheOperationFor(Exchange exchange) {     return exchange.getIn().getHeader(IgniteConstants.IGNITE_CACHE_OPERATION, endpoint.getOperation(), IgniteCacheOperation.class). }
