commented;modifiers;parameterAmount;loc;comment;code
false;public;2;50;;@Override public boolean process(Exchange exchange, AsyncCallback callback) {     IgniteCompute compute = endpoint.createIgniteCompute().withAsync().     try {         switch(executionTypeFor(exchange)) {             case CALL:                 doCall(exchange, callback, compute).                 break.             case BROADCAST:                 doBroadcast(exchange, callback, compute).                 break.             case EXECUTE:                 doExecute(exchange, callback, compute).                 break.             case RUN:                 doRun(exchange, callback, compute).                 break.             case APPLY:                 doApply(exchange, callback, compute).                 break.             case AFFINITY_CALL:                 doAffinityCall(exchange, callback, compute).                 break.             case AFFINITY_RUN:                 doAffinityRun(exchange, callback, compute).                 break.             default:                 exchange.setException(new UnsupportedOperationException("Operation not supported by Ignite Compute producer.")).                 callback.done(false).                 return false.         }         compute.future().listen(IgniteInCamelClosure.create(exchange, callback)).         return false.     } catch (Exception e) {         exchange.setException(e).         callback.done(false).         return false.     } }
false;private;3;24;;@SuppressWarnings({ "unchecked", "rawtypes" }) private void doCall(final Exchange exchange, final AsyncCallback callback, IgniteCompute compute) throws Exception {     Object job = exchange.getIn().getBody().     IgniteReducer<Object, Object> reducer = exchange.getIn().getHeader(IgniteConstants.IGNITE_COMPUTE_REDUCER, IgniteReducer.class).     if (Collection.class.isAssignableFrom(job.getClass())) {         Collection<?> col = (Collection<?>) job.         TypeConverter tc = exchange.getContext().getTypeConverter().         Collection<IgniteCallable<?>> callables = new ArrayList<>(col.size()).         for (Object o : col) {             callables.add(tc.mandatoryConvertTo(IgniteCallable.class, o)).         }         if (reducer != null) {             compute.call((Collection) callables, reducer).         } else {             compute.call((Collection) callables).         }     } else if (IgniteCallable.class.isAssignableFrom(job.getClass())) {         compute.call((IgniteCallable<Object>) job).     } else {         throw new RuntimeCamelException(String.format("Ignite Compute endpoint with CALL executionType is only " + "supported for IgniteCallable payloads, or collections of them. The payload type was: %s.", job.getClass().getName())).     } }
false;private;3;16;;@SuppressWarnings("unchecked") private void doBroadcast(final Exchange exchange, final AsyncCallback callback, IgniteCompute compute) throws Exception {     Object job = exchange.getIn().getBody().     if (IgniteCallable.class.isAssignableFrom(job.getClass())) {         compute.broadcast((IgniteCallable<?>) job).     } else if (IgniteRunnable.class.isAssignableFrom(job.getClass())) {         compute.broadcast((IgniteRunnable) job).     } else if (IgniteClosure.class.isAssignableFrom(job.getClass())) {         compute.broadcast((IgniteClosure<Object, Object>) job, exchange.getIn().getHeader(IgniteConstants.IGNITE_COMPUTE_PARAMS)).     } else {         throw new RuntimeCamelException(String.format("Ignite Compute endpoint with BROADCAST executionType is only " + "supported for IgniteCallable, IgniteRunnable or IgniteClosure payloads. The payload type was: %s.", job.getClass().getName())).     } }
false;private;3;20;;@SuppressWarnings("unchecked") private void doExecute(final Exchange exchange, final AsyncCallback callback, IgniteCompute compute) throws Exception {     Object job = exchange.getIn().getBody().     Object params = exchange.getIn().getHeader(IgniteConstants.IGNITE_COMPUTE_PARAMS).     if (job instanceof Class && ComputeTask.class.isAssignableFrom((Class<?>) job)) {         Class<? extends ComputeTask<Object, Object>> task = (Class<? extends ComputeTask<Object, Object>>) job.         compute.execute(task, params).     } else if (ComputeTask.class.isAssignableFrom(job.getClass())) {         compute.execute((ComputeTask<Object, Object>) job, params).     } else if (endpoint.getTaskName() != null) {         if (exchange.getIn().getBody() != null) {             params = exchange.getIn().getBody().         }         compute.execute(endpoint.getTaskName(), params).     } else {         throw new RuntimeCamelException(String.format("Ignite Compute endpoint with EXECUTE executionType is only " + "supported for ComputeTask payloads, Class<ComputeTask> or any payload in conjunction with the " + "task name option. The payload type was: %s.", job.getClass().getName())).     } }
false;private;3;18;;private void doRun(final Exchange exchange, final AsyncCallback callback, IgniteCompute compute) throws Exception {     Object job = exchange.getIn().getBody().     if (Collection.class.isAssignableFrom(job.getClass())) {         Collection<?> col = (Collection<?>) job.         TypeConverter tc = exchange.getContext().getTypeConverter().         Collection<IgniteRunnable> runnables = new ArrayList<>(col.size()).         for (Object o : col) {             runnables.add(tc.mandatoryConvertTo(IgniteRunnable.class, o)).         }         compute.run(runnables).     } else if (IgniteRunnable.class.isAssignableFrom(job.getClass())) {         compute.run((IgniteRunnable) job).     } else {         throw new RuntimeCamelException(String.format("Ignite Compute endpoint with RUN executionType is only " + "supported for IgniteRunnable payloads, or collections of them. The payload type was: %s.", job.getClass().getName())).     } }
false;private;3;24;;@SuppressWarnings("unchecked") private <T, R1, R2> void doApply(final Exchange exchange, final AsyncCallback callback, IgniteCompute compute) throws Exception {     IgniteClosure<T, R1> job = exchange.getIn().getBody(IgniteClosure.class).     T params = (T) exchange.getIn().getHeader(IgniteConstants.IGNITE_COMPUTE_PARAMS).     if (job == null || params == null) {         throw new RuntimeCamelException(String.format("Ignite Compute endpoint with APPLY executionType is only " + "supported for IgniteClosure payloads with parameters. The payload type was: %s.", exchange.getIn().getBody().getClass().getName())).     }     IgniteReducer<R1, R2> reducer = exchange.getIn().getHeader(IgniteConstants.IGNITE_COMPUTE_REDUCER, IgniteReducer.class).     if (Collection.class.isAssignableFrom(params.getClass())) {         Collection<T> colParams = (Collection<T>) params.         if (reducer == null) {             compute.apply(job, colParams).         } else {             compute.apply(job, colParams, reducer).         }     } else {         compute.apply(job, params).     } }
false;private;3;14;;@SuppressWarnings("unchecked") private void doAffinityCall(final Exchange exchange, final AsyncCallback callback, IgniteCompute compute) throws Exception {     IgniteCallable<Object> job = exchange.getIn().getBody(IgniteCallable.class).     String affinityCache = exchange.getIn().getHeader(IgniteConstants.IGNITE_COMPUTE_AFFINITY_CACHE_NAME, String.class).     Object affinityKey = exchange.getIn().getHeader(IgniteConstants.IGNITE_COMPUTE_AFFINITY_KEY, Object.class).     if (job == null || affinityCache == null || affinityKey == null) {         throw new RuntimeCamelException(String.format("Ignite Compute endpoint with AFFINITY_CALL executionType is only " + "supported for IgniteCallable payloads, along with an affinity cache and key. The payload type was: %s.", exchange.getIn().getBody().getClass().getName())).     }     compute.affinityCall(affinityCache, affinityKey, job). }
false;private;3;13;;private void doAffinityRun(final Exchange exchange, final AsyncCallback callback, IgniteCompute compute) throws Exception {     IgniteRunnable job = exchange.getIn().getBody(IgniteRunnable.class).     String affinityCache = exchange.getIn().getHeader(IgniteConstants.IGNITE_COMPUTE_AFFINITY_CACHE_NAME, String.class).     Object affinityKey = exchange.getIn().getHeader(IgniteConstants.IGNITE_COMPUTE_AFFINITY_KEY, Object.class).     if (job == null || affinityCache == null || affinityKey == null) {         throw new RuntimeCamelException(String.format("Ignite Compute endpoint with AFFINITY_RUN executionType is only " + "supported for IgniteRunnable payloads, along with an affinity cache and key. The payload type was: %s.", exchange.getIn().getBody().getClass().getName())).     }     compute.affinityRun(affinityCache, affinityKey, job). }
false;private;1;3;;private IgniteComputeExecutionType executionTypeFor(Exchange exchange) {     return exchange.getIn().getHeader(IgniteConstants.IGNITE_COMPUTE_EXECUTION_TYPE, endpoint.getExecutionType(), IgniteComputeExecutionType.class). }
false;private,static;2;6;;private static IgniteInCamelClosure create(Exchange exchange, AsyncCallback callback) {     IgniteInCamelClosure answer = new IgniteInCamelClosure().     answer.exchange = exchange.     answer.callback = callback.     return answer. }
false;public;1;19;;@Override public void apply(IgniteFuture<Object> future) {     Message in = exchange.getIn().     Message out = exchange.getOut().     MessageHelper.copyHeaders(in, out, true).     Object result = null.     try {         result = future.get().     } catch (Exception e) {         exchange.setException(e).         callback.done(false).         return.     }     exchange.getOut().setBody(result).     callback.done(false). }
