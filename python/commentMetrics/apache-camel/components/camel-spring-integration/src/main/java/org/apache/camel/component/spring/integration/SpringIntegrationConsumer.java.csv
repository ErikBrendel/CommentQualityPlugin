commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public SpringIntegrationEndpoint getEndpoint() {     return (SpringIntegrationEndpoint) super.getEndpoint(). }
false;protected;0;4;;protected void doStop() throws Exception {     inputChannel.unsubscribe(this).     super.doStop(). }
false;protected;0;32;;protected void doStart() throws Exception {     super.doStart().     if (getEndpoint().getMessageChannel() == null) {         String inputChannelName = getEndpoint().getDefaultChannel().         if (ObjectHelper.isEmpty(inputChannelName)) {             inputChannelName = getEndpoint().getInputChannel().         }         StringHelper.notEmpty(inputChannelName, "inputChannelName", getEndpoint()).         inputChannel = (SubscribableChannel) destinationResolver.resolveDestination(inputChannelName).     } else {         inputChannel = (SubscribableChannel) getEndpoint().getMessageChannel().     }     if (inputChannel == null) {         throw new IllegalArgumentException("Cannot resolve InputChannel on " + getEndpoint()).     }     // if we do in-out we need to setup the input channel as well     if (getEndpoint().isInOut()) {         // we need to setup right outputChannel for further processing         StringHelper.notEmpty(getEndpoint().getOutputChannel(), "OutputChannel", getEndpoint()).         outputChannel = destinationResolver.resolveDestination(getEndpoint().getOutputChannel()).         if (outputChannel == null) {             throw new IllegalArgumentException("Cannot resolve OutputChannel on " + getEndpoint()).         }     }     inputChannel.subscribe(this). }
false;public;1;48;;public void handleMessage(org.springframework.messaging.Message<?> siInMessage) {     // we received a message from spring integration     // wrap that in a Camel Exchange and process it     Exchange exchange = getEndpoint().createExchange(getEndpoint().isInOut() ? ExchangePattern.InOut : ExchangePattern.InOnly).     exchange.setIn(new SpringIntegrationMessage(exchange, siInMessage)).     // process the exchange     try {         getProcessor().process(exchange).     } catch (Exception e) {         getExceptionHandler().handleException("Error processing exchange", exchange, e).         return.     }     // reply logic     if (getEndpoint().isInOut()) {         MessageChannel reply = null.         // get the output channel from message header         Object returnAddress = siInMessage.getHeaders().getReplyChannel().         if (returnAddress != null) {             if (returnAddress instanceof String) {                 reply = context.getApplicationContext().getBean((String) returnAddress, MessageChannel.class).             } else if (returnAddress instanceof MessageChannel) {                 reply = (MessageChannel) returnAddress.             }         } else {             reply = outputChannel.             // we want to do in-out so the inputChannel is mandatory (used to receive reply from spring integration)             if (reply == null) {                 throw new IllegalArgumentException("OutputChannel has not been configured on " + getEndpoint()).             }         }         if (reply == null) {             throw new IllegalArgumentException("Cannot resolve ReplyChannel from message: " + siInMessage).         }         // put the message back the outputChannel if we need         org.springframework.messaging.Message<?> siOutMessage = SpringIntegrationBinding.storeToSpringIntegrationMessage(exchange.getOut()).         // send the message to spring integration         log.debug("Sending {} to ReplyChannel: {}", siOutMessage, reply).         reply.send(siOutMessage).     } }
