# id;timestamp;commentText;codeText;commentWords;codeWords
RestClusterClient -> @Override 	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId);1522759723;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;@Override_	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;override,public,completable,future,job,result,request,job,result,nonnull,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> @Override 	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId);1523641106;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;@Override_	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;override,public,completable,future,job,result,request,job,result,nonnull,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> @Override 	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId);1523906273;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;@Override_	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;override,public,completable,future,job,result,request,job,result,nonnull,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> @Override 	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId);1525116069;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;@Override_	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;override,public,completable,future,job,result,request,job,result,nonnull,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> @Override 	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId);1525420604;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;@Override_	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;override,public,completable,future,job,result,request,job,result,nonnull,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> @Override 	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId);1527173115;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;@Override_	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters)__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;override,public,completable,future,job,result,request,job,result,nonnull,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,request,job,execution,result,headers,get,instance,message,parameters
RestClusterClient -> @Override 	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId);1529046538;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;@Override_	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters)__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;override,public,completable,future,job,result,request,job,result,nonnull,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,request,job,execution,result,headers,get,instance,message,parameters
RestClusterClient -> @Override 	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId);1530181266;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;@Override_	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters)__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;override,public,completable,future,job,result,request,job,result,nonnull,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,request,job,execution,result,headers,get,instance,message,parameters
RestClusterClient -> @Override 	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId);1530644925;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;@Override_	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters)__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;override,public,completable,future,job,result,request,job,result,nonnull,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,request,job,execution,result,headers,get,instance,message,parameters
RestClusterClient -> @Override 	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId);1538042094;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;@Override_	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters)__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;override,public,completable,future,job,result,request,job,result,nonnull,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,request,job,execution,result,headers,get,instance,message,parameters
RestClusterClient -> @Override 	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId);1538395078;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;@Override_	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters)__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;override,public,completable,future,job,result,request,job,result,nonnull,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,request,job,execution,result,headers,get,instance,message,parameters
RestClusterClient -> @Override 	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId);1548435402;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;@Override_	public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters)__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;override,public,completable,future,job,result,request,job,result,nonnull,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,request,job,execution,result,headers,get,instance,message,parameters
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1518680657;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1518680718;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1519249745;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1519249749;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1519317159;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1519638690;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1519977151;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1519977154;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1520032169;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1520032992;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1520246439;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1520248329;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1521396720;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1521641443;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1522049586;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1522132482;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph);1522132496;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;public CompletableFuture<JobSubmitResponseBody> submitJob(JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture.exceptionally(_			(Throwable throwable) -> {_				throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__			})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;public,completable,future,job,submit,response,body,submit,job,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> @Override 	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph);1522759723;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;@Override_	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture_			.thenApply(_				(JobSubmitResponseBody jobSubmitResponseBody) -> new JobSubmissionResult(jobGraph.getJobID()))_			.exceptionally(_				(Throwable throwable) -> {_					throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__				})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;override,public,completable,future,job,submission,result,submit,job,nonnull,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,then,apply,job,submit,response,body,job,submit,response,body,new,job,submission,result,job,graph,get,job,id,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> @Override 	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph);1523641106;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;@Override_	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture_			.thenApply(_				(JobSubmitResponseBody jobSubmitResponseBody) -> new JobSubmissionResult(jobGraph.getJobID()))_			.exceptionally(_				(Throwable throwable) -> {_					throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__				})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;override,public,completable,future,job,submission,result,submit,job,nonnull,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,then,apply,job,submit,response,body,job,submit,response,body,new,job,submission,result,job,graph,get,job,id,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> @Override 	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph);1523906273;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;@Override_	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture_			.thenApply(_				(JobSubmitResponseBody jobSubmitResponseBody) -> new JobSubmissionResult(jobGraph.getJobID()))_			.exceptionally(_				(Throwable throwable) -> {_					throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__				})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;override,public,completable,future,job,submission,result,submit,job,nonnull,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,then,apply,job,submit,response,body,job,submit,response,body,new,job,submission,result,job,graph,get,job,id,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> @Override 	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph);1525116069;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;@Override_	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				log.info("Uploading jar files.")__				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					keys = BlobClient.uploadJarFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job jar files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addBlob(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture_			.thenApply(_				(JobSubmitResponseBody jobSubmitResponseBody) -> new JobSubmissionResult(jobGraph.getJobID()))_			.exceptionally(_				(Throwable throwable) -> {_					throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__				})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;override,public,completable,future,job,submission,result,submit,job,nonnull,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,log,info,uploading,jar,files,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,keys,blob,client,upload,jar,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,jar,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,blob,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,then,apply,job,submit,response,body,job,submit,response,body,new,job,submission,result,job,graph,get,job,id,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> @Override 	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph);1525420604;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;@Override_	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(_			BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					log.info("Uploading jar files.")__					keys = BlobClient.uploadFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__					jobGraph.uploadUserArtifacts(address, flinkConfig)__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addUserJarBlobKey(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture_			.thenApply(_				(JobSubmitResponseBody jobSubmitResponseBody) -> new JobSubmissionResult(jobGraph.getJobID()))_			.exceptionally(_				(Throwable throwable) -> {_					throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__				})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;override,public,completable,future,job,submission,result,submit,job,nonnull,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,log,info,uploading,jar,files,keys,blob,client,upload,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,job,graph,upload,user,artifacts,address,flink,config,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,user,jar,blob,key,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,then,apply,job,submit,response,body,job,submit,response,body,new,job,submission,result,job,graph,get,job,id,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> @Override 	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph);1527173115;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;@Override_	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					log.info("Uploading jar files.")__					keys = BlobClient.uploadFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__					jobGraph.uploadUserArtifacts(address, flinkConfig)__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addUserJarBlobKey(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture_			.thenApply(_				(JobSubmitResponseBody jobSubmitResponseBody) -> new JobSubmissionResult(jobGraph.getJobID()))_			.exceptionally(_				(Throwable throwable) -> {_					throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__				})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;override,public,completable,future,job,submission,result,submit,job,nonnull,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,log,info,uploading,jar,files,keys,blob,client,upload,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,job,graph,upload,user,artifacts,address,flink,config,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,user,jar,blob,key,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,then,apply,job,submit,response,body,job,submit,response,body,new,job,submission,result,job,graph,get,job,id,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> @Override 	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph);1529046538;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;@Override_	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)__				final List<PermanentBlobKey> keys__				try {_					log.info("Uploading jar files.")__					keys = BlobClient.uploadFiles(address, flinkConfig, jobGraph.getJobID(), jobGraph.getUserJars())__					jobGraph.uploadUserArtifacts(address, flinkConfig)__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not upload job files.", ioe))__				}__				for (PermanentBlobKey key : keys) {_					jobGraph.addUserJarBlobKey(key)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture_			.thenApply(_				(JobSubmitResponseBody jobSubmitResponseBody) -> new JobSubmissionResult(jobGraph.getJobID()))_			.exceptionally(_				(Throwable throwable) -> {_					throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__				})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;override,public,completable,future,job,submission,result,submit,job,nonnull,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,final,list,permanent,blob,key,keys,try,log,info,uploading,jar,files,keys,blob,client,upload,files,address,flink,config,job,graph,get,job,id,job,graph,get,user,jars,job,graph,upload,user,artifacts,address,flink,config,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,upload,job,files,ioe,for,permanent,blob,key,key,keys,job,graph,add,user,jar,blob,key,key,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,then,apply,job,submit,response,body,job,submit,response,body,new,job,submission,result,job,graph,get,job,id,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> @Override 	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph);1530181266;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;@Override_	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		log.info("Requesting blob server port.")__		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(BlobServerPortHeaders.getInstance())___		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(_			getDispatcherAddress(),_			(BlobServerPortResponseBody response, String dispatcherAddress) -> {_				final int blobServerPort = response.port__				final InetSocketAddress address = new InetSocketAddress(dispatcherAddress, blobServerPort)___				try {_					ClientUtils.uploadJobGraphFiles(jobGraph, () -> new BlobClient(address, flinkConfig))__				} catch (Exception e) {_					throw new CompletionException(e)__				}__				return jobGraph__			})___		CompletableFuture<JobSubmitResponseBody> submissionFuture = jobUploadFuture.thenCompose(_			(JobGraph jobGraphToSubmit) -> {_				log.info("Submitting job graph.")___				try {_					return sendRequest(_						JobSubmitHeaders.getInstance(),_						new JobSubmitRequestBody(jobGraph))__				} catch (IOException ioe) {_					throw new CompletionException(new FlinkException("Could not create JobSubmitRequestBody.", ioe))__				}_			})___		return submissionFuture_			.thenApply(_				(JobSubmitResponseBody jobSubmitResponseBody) -> new JobSubmissionResult(jobGraph.getJobID()))_			.exceptionally(_				(Throwable throwable) -> {_					throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__				})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;override,public,completable,future,job,submission,result,submit,job,nonnull,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,log,info,requesting,blob,server,port,completable,future,blob,server,port,response,body,port,future,send,request,blob,server,port,headers,get,instance,completable,future,job,graph,job,upload,future,port,future,then,combine,get,dispatcher,address,blob,server,port,response,body,response,string,dispatcher,address,final,int,blob,server,port,response,port,final,inet,socket,address,address,new,inet,socket,address,dispatcher,address,blob,server,port,try,client,utils,upload,job,graph,files,job,graph,new,blob,client,address,flink,config,catch,exception,e,throw,new,completion,exception,e,return,job,graph,completable,future,job,submit,response,body,submission,future,job,upload,future,then,compose,job,graph,job,graph,to,submit,log,info,submitting,job,graph,try,return,send,request,job,submit,headers,get,instance,new,job,submit,request,body,job,graph,catch,ioexception,ioe,throw,new,completion,exception,new,flink,exception,could,not,create,job,submit,request,body,ioe,return,submission,future,then,apply,job,submit,response,body,job,submit,response,body,new,job,submission,result,job,graph,get,job,id,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> @Override 	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph);1530644925;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;@Override_	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		CompletableFuture<java.nio.file.Path> jobGraphFileFuture = CompletableFuture.supplyAsync(() -> {_			try {_				final java.nio.file.Path jobGraphFile = Files.createTempFile("flink-jobgraph", ".bin")__				try (ObjectOutputStream objectOut = new ObjectOutputStream(Files.newOutputStream(jobGraphFile))) {_					objectOut.writeObject(jobGraph)__				}_				return jobGraphFile__			} catch (IOException e) {_				throw new CompletionException(new FlinkException("Failed to serialize JobGraph.", e))__			}_		}, executorService)___		CompletableFuture<Tuple2<JobSubmitRequestBody, Collection<FileUpload>>> requestFuture = jobGraphFileFuture.thenApply(jobGraphFile -> {_			List<String> jarFileNames = new ArrayList<>(8)__			List<JobSubmitRequestBody.DistributedCacheFile> artifactFileNames = new ArrayList<>(8)__			Collection<FileUpload> filesToUpload = new ArrayList<>(8)___			filesToUpload.add(new FileUpload(jobGraphFile, RestConstants.CONTENT_TYPE_BINARY))___			for (Path jar : jobGraph.getUserJars()) {_				jarFileNames.add(jar.getName())__				filesToUpload.add(new FileUpload(Paths.get(jar.toUri()), RestConstants.CONTENT_TYPE_JAR))__			}__			for (Map.Entry<String, DistributedCache.DistributedCacheEntry> artifacts : jobGraph.getUserArtifacts().entrySet()) {_				artifactFileNames.add(new JobSubmitRequestBody.DistributedCacheFile(artifacts.getKey(), new Path(artifacts.getValue().filePath).getName()))__				filesToUpload.add(new FileUpload(Paths.get(artifacts.getValue().filePath), RestConstants.CONTENT_TYPE_BINARY))__			}__			final JobSubmitRequestBody requestBody = new JobSubmitRequestBody(_				jobGraphFile.getFileName().toString(),_				jarFileNames,_				artifactFileNames)___			return Tuple2.of(requestBody, Collections.unmodifiableCollection(filesToUpload))__		})___		final CompletableFuture<JobSubmitResponseBody> submissionFuture = requestFuture.thenCompose(_			requestAndFileUploads -> sendRetriableRequest(_				JobSubmitHeaders.getInstance(),_				EmptyMessageParameters.getInstance(),_				requestAndFileUploads.f0,_				requestAndFileUploads.f1,_				isConnectionProblemOrServiceUnavailable())_		)___		submissionFuture_			.thenCombine(jobGraphFileFuture, (ignored, jobGraphFile) -> jobGraphFile)_			.thenAccept(jobGraphFile -> {_			try {_				Files.delete(jobGraphFile)__			} catch (IOException e) {_				log.warn("Could not delete temporary file {}.", jobGraphFile, e)__			}_		})___		return submissionFuture_			.thenApply(_				(JobSubmitResponseBody jobSubmitResponseBody) -> new JobSubmissionResult(jobGraph.getJobID()))_			.exceptionally(_				(Throwable throwable) -> {_					throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__				})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;override,public,completable,future,job,submission,result,submit,job,nonnull,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,completable,future,java,nio,file,path,job,graph,file,future,completable,future,supply,async,try,final,java,nio,file,path,job,graph,file,files,create,temp,file,flink,jobgraph,bin,try,object,output,stream,object,out,new,object,output,stream,files,new,output,stream,job,graph,file,object,out,write,object,job,graph,return,job,graph,file,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,failed,to,serialize,job,graph,e,executor,service,completable,future,tuple2,job,submit,request,body,collection,file,upload,request,future,job,graph,file,future,then,apply,job,graph,file,list,string,jar,file,names,new,array,list,8,list,job,submit,request,body,distributed,cache,file,artifact,file,names,new,array,list,8,collection,file,upload,files,to,upload,new,array,list,8,files,to,upload,add,new,file,upload,job,graph,file,rest,constants,for,path,jar,job,graph,get,user,jars,jar,file,names,add,jar,get,name,files,to,upload,add,new,file,upload,paths,get,jar,to,uri,rest,constants,for,map,entry,string,distributed,cache,distributed,cache,entry,artifacts,job,graph,get,user,artifacts,entry,set,artifact,file,names,add,new,job,submit,request,body,distributed,cache,file,artifacts,get,key,new,path,artifacts,get,value,file,path,get,name,files,to,upload,add,new,file,upload,paths,get,artifacts,get,value,file,path,rest,constants,final,job,submit,request,body,request,body,new,job,submit,request,body,job,graph,file,get,file,name,to,string,jar,file,names,artifact,file,names,return,tuple2,of,request,body,collections,unmodifiable,collection,files,to,upload,final,completable,future,job,submit,response,body,submission,future,request,future,then,compose,request,and,file,uploads,send,retriable,request,job,submit,headers,get,instance,empty,message,parameters,get,instance,request,and,file,uploads,f0,request,and,file,uploads,f1,is,connection,problem,or,service,unavailable,submission,future,then,combine,job,graph,file,future,ignored,job,graph,file,job,graph,file,then,accept,job,graph,file,try,files,delete,job,graph,file,catch,ioexception,e,log,warn,could,not,delete,temporary,file,job,graph,file,e,return,submission,future,then,apply,job,submit,response,body,job,submit,response,body,new,job,submission,result,job,graph,get,job,id,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> @Override 	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph);1538042094;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;@Override_	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		CompletableFuture<java.nio.file.Path> jobGraphFileFuture = CompletableFuture.supplyAsync(() -> {_			try {_				final java.nio.file.Path jobGraphFile = Files.createTempFile("flink-jobgraph", ".bin")__				try (ObjectOutputStream objectOut = new ObjectOutputStream(Files.newOutputStream(jobGraphFile))) {_					objectOut.writeObject(jobGraph)__				}_				return jobGraphFile__			} catch (IOException e) {_				throw new CompletionException(new FlinkException("Failed to serialize JobGraph.", e))__			}_		}, executorService)___		CompletableFuture<Tuple2<JobSubmitRequestBody, Collection<FileUpload>>> requestFuture = jobGraphFileFuture.thenApply(jobGraphFile -> {_			List<String> jarFileNames = new ArrayList<>(8)__			List<JobSubmitRequestBody.DistributedCacheFile> artifactFileNames = new ArrayList<>(8)__			Collection<FileUpload> filesToUpload = new ArrayList<>(8)___			filesToUpload.add(new FileUpload(jobGraphFile, RestConstants.CONTENT_TYPE_BINARY))___			for (Path jar : jobGraph.getUserJars()) {_				jarFileNames.add(jar.getName())__				filesToUpload.add(new FileUpload(Paths.get(jar.toUri()), RestConstants.CONTENT_TYPE_JAR))__			}__			for (Map.Entry<String, DistributedCache.DistributedCacheEntry> artifacts : jobGraph.getUserArtifacts().entrySet()) {_				artifactFileNames.add(new JobSubmitRequestBody.DistributedCacheFile(artifacts.getKey(), new Path(artifacts.getValue().filePath).getName()))__				filesToUpload.add(new FileUpload(Paths.get(artifacts.getValue().filePath), RestConstants.CONTENT_TYPE_BINARY))__			}__			final JobSubmitRequestBody requestBody = new JobSubmitRequestBody(_				jobGraphFile.getFileName().toString(),_				jarFileNames,_				artifactFileNames)___			return Tuple2.of(requestBody, Collections.unmodifiableCollection(filesToUpload))__		})___		final CompletableFuture<JobSubmitResponseBody> submissionFuture = requestFuture.thenCompose(_			requestAndFileUploads -> sendRetriableRequest(_				JobSubmitHeaders.getInstance(),_				EmptyMessageParameters.getInstance(),_				requestAndFileUploads.f0,_				requestAndFileUploads.f1,_				isConnectionProblemOrServiceUnavailable())_		)___		submissionFuture_			.thenCombine(jobGraphFileFuture, (ignored, jobGraphFile) -> jobGraphFile)_			.thenAccept(jobGraphFile -> {_			try {_				Files.delete(jobGraphFile)__			} catch (IOException e) {_				log.warn("Could not delete temporary file {}.", jobGraphFile, e)__			}_		})___		return submissionFuture_			.thenApply(_				(JobSubmitResponseBody jobSubmitResponseBody) -> new JobSubmissionResult(jobGraph.getJobID()))_			.exceptionally(_				(Throwable throwable) -> {_					throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", throwable))__				})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;override,public,completable,future,job,submission,result,submit,job,nonnull,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,completable,future,java,nio,file,path,job,graph,file,future,completable,future,supply,async,try,final,java,nio,file,path,job,graph,file,files,create,temp,file,flink,jobgraph,bin,try,object,output,stream,object,out,new,object,output,stream,files,new,output,stream,job,graph,file,object,out,write,object,job,graph,return,job,graph,file,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,failed,to,serialize,job,graph,e,executor,service,completable,future,tuple2,job,submit,request,body,collection,file,upload,request,future,job,graph,file,future,then,apply,job,graph,file,list,string,jar,file,names,new,array,list,8,list,job,submit,request,body,distributed,cache,file,artifact,file,names,new,array,list,8,collection,file,upload,files,to,upload,new,array,list,8,files,to,upload,add,new,file,upload,job,graph,file,rest,constants,for,path,jar,job,graph,get,user,jars,jar,file,names,add,jar,get,name,files,to,upload,add,new,file,upload,paths,get,jar,to,uri,rest,constants,for,map,entry,string,distributed,cache,distributed,cache,entry,artifacts,job,graph,get,user,artifacts,entry,set,artifact,file,names,add,new,job,submit,request,body,distributed,cache,file,artifacts,get,key,new,path,artifacts,get,value,file,path,get,name,files,to,upload,add,new,file,upload,paths,get,artifacts,get,value,file,path,rest,constants,final,job,submit,request,body,request,body,new,job,submit,request,body,job,graph,file,get,file,name,to,string,jar,file,names,artifact,file,names,return,tuple2,of,request,body,collections,unmodifiable,collection,files,to,upload,final,completable,future,job,submit,response,body,submission,future,request,future,then,compose,request,and,file,uploads,send,retriable,request,job,submit,headers,get,instance,empty,message,parameters,get,instance,request,and,file,uploads,f0,request,and,file,uploads,f1,is,connection,problem,or,service,unavailable,submission,future,then,combine,job,graph,file,future,ignored,job,graph,file,job,graph,file,then,accept,job,graph,file,try,files,delete,job,graph,file,catch,ioexception,e,log,warn,could,not,delete,temporary,file,job,graph,file,e,return,submission,future,then,apply,job,submit,response,body,job,submit,response,body,new,job,submission,result,job,graph,get,job,id,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,throwable
RestClusterClient -> @Override 	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph);1538395078;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;@Override_	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		CompletableFuture<java.nio.file.Path> jobGraphFileFuture = CompletableFuture.supplyAsync(() -> {_			try {_				final java.nio.file.Path jobGraphFile = Files.createTempFile("flink-jobgraph", ".bin")__				try (ObjectOutputStream objectOut = new ObjectOutputStream(Files.newOutputStream(jobGraphFile))) {_					objectOut.writeObject(jobGraph)__				}_				return jobGraphFile__			} catch (IOException e) {_				throw new CompletionException(new FlinkException("Failed to serialize JobGraph.", e))__			}_		}, executorService)___		CompletableFuture<Tuple2<JobSubmitRequestBody, Collection<FileUpload>>> requestFuture = jobGraphFileFuture.thenApply(jobGraphFile -> {_			List<String> jarFileNames = new ArrayList<>(8)__			List<JobSubmitRequestBody.DistributedCacheFile> artifactFileNames = new ArrayList<>(8)__			Collection<FileUpload> filesToUpload = new ArrayList<>(8)___			filesToUpload.add(new FileUpload(jobGraphFile, RestConstants.CONTENT_TYPE_BINARY))___			for (Path jar : jobGraph.getUserJars()) {_				jarFileNames.add(jar.getName())__				filesToUpload.add(new FileUpload(Paths.get(jar.toUri()), RestConstants.CONTENT_TYPE_JAR))__			}__			for (Map.Entry<String, DistributedCache.DistributedCacheEntry> artifacts : jobGraph.getUserArtifacts().entrySet()) {_				artifactFileNames.add(new JobSubmitRequestBody.DistributedCacheFile(artifacts.getKey(), new Path(artifacts.getValue().filePath).getName()))__				filesToUpload.add(new FileUpload(Paths.get(artifacts.getValue().filePath), RestConstants.CONTENT_TYPE_BINARY))__			}__			final JobSubmitRequestBody requestBody = new JobSubmitRequestBody(_				jobGraphFile.getFileName().toString(),_				jarFileNames,_				artifactFileNames)___			return Tuple2.of(requestBody, Collections.unmodifiableCollection(filesToUpload))__		})___		final CompletableFuture<JobSubmitResponseBody> submissionFuture = requestFuture.thenCompose(_			requestAndFileUploads -> sendRetriableRequest(_				JobSubmitHeaders.getInstance(),_				EmptyMessageParameters.getInstance(),_				requestAndFileUploads.f0,_				requestAndFileUploads.f1,_				isConnectionProblemOrServiceUnavailable())_		)___		submissionFuture_			.thenCombine(jobGraphFileFuture, (ignored, jobGraphFile) -> jobGraphFile)_			.thenAccept(jobGraphFile -> {_			try {_				Files.delete(jobGraphFile)__			} catch (IOException e) {_				log.warn("Could not delete temporary file {}.", jobGraphFile, e)__			}_		})___		return submissionFuture_			.thenApply(_				(JobSubmitResponseBody jobSubmitResponseBody) -> new JobSubmissionResult(jobGraph.getJobID()))_			.exceptionally(_				(Throwable throwable) -> {_					throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", ExceptionUtils.stripCompletionException(throwable)))__				})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;override,public,completable,future,job,submission,result,submit,job,nonnull,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,completable,future,java,nio,file,path,job,graph,file,future,completable,future,supply,async,try,final,java,nio,file,path,job,graph,file,files,create,temp,file,flink,jobgraph,bin,try,object,output,stream,object,out,new,object,output,stream,files,new,output,stream,job,graph,file,object,out,write,object,job,graph,return,job,graph,file,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,failed,to,serialize,job,graph,e,executor,service,completable,future,tuple2,job,submit,request,body,collection,file,upload,request,future,job,graph,file,future,then,apply,job,graph,file,list,string,jar,file,names,new,array,list,8,list,job,submit,request,body,distributed,cache,file,artifact,file,names,new,array,list,8,collection,file,upload,files,to,upload,new,array,list,8,files,to,upload,add,new,file,upload,job,graph,file,rest,constants,for,path,jar,job,graph,get,user,jars,jar,file,names,add,jar,get,name,files,to,upload,add,new,file,upload,paths,get,jar,to,uri,rest,constants,for,map,entry,string,distributed,cache,distributed,cache,entry,artifacts,job,graph,get,user,artifacts,entry,set,artifact,file,names,add,new,job,submit,request,body,distributed,cache,file,artifacts,get,key,new,path,artifacts,get,value,file,path,get,name,files,to,upload,add,new,file,upload,paths,get,artifacts,get,value,file,path,rest,constants,final,job,submit,request,body,request,body,new,job,submit,request,body,job,graph,file,get,file,name,to,string,jar,file,names,artifact,file,names,return,tuple2,of,request,body,collections,unmodifiable,collection,files,to,upload,final,completable,future,job,submit,response,body,submission,future,request,future,then,compose,request,and,file,uploads,send,retriable,request,job,submit,headers,get,instance,empty,message,parameters,get,instance,request,and,file,uploads,f0,request,and,file,uploads,f1,is,connection,problem,or,service,unavailable,submission,future,then,combine,job,graph,file,future,ignored,job,graph,file,job,graph,file,then,accept,job,graph,file,try,files,delete,job,graph,file,catch,ioexception,e,log,warn,could,not,delete,temporary,file,job,graph,file,e,return,submission,future,then,apply,job,submit,response,body,job,submit,response,body,new,job,submission,result,job,graph,get,job,id,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,exception,utils,strip,completion,exception,throwable
RestClusterClient -> @Override 	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph);1548435402;Submits the given {@link JobGraph} to the dispatcher.__@param jobGraph to submit_@return Future which is completed with the submission response;@Override_	public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph) {_		_		jobGraph.setAllowQueuedScheduling(true)___		CompletableFuture<java.nio.file.Path> jobGraphFileFuture = CompletableFuture.supplyAsync(() -> {_			try {_				final java.nio.file.Path jobGraphFile = Files.createTempFile("flink-jobgraph", ".bin")__				try (ObjectOutputStream objectOut = new ObjectOutputStream(Files.newOutputStream(jobGraphFile))) {_					objectOut.writeObject(jobGraph)__				}_				return jobGraphFile__			} catch (IOException e) {_				throw new CompletionException(new FlinkException("Failed to serialize JobGraph.", e))__			}_		}, executorService)___		CompletableFuture<Tuple2<JobSubmitRequestBody, Collection<FileUpload>>> requestFuture = jobGraphFileFuture.thenApply(jobGraphFile -> {_			List<String> jarFileNames = new ArrayList<>(8)__			List<JobSubmitRequestBody.DistributedCacheFile> artifactFileNames = new ArrayList<>(8)__			Collection<FileUpload> filesToUpload = new ArrayList<>(8)___			filesToUpload.add(new FileUpload(jobGraphFile, RestConstants.CONTENT_TYPE_BINARY))___			for (Path jar : jobGraph.getUserJars()) {_				jarFileNames.add(jar.getName())__				filesToUpload.add(new FileUpload(Paths.get(jar.toUri()), RestConstants.CONTENT_TYPE_JAR))__			}__			for (Map.Entry<String, DistributedCache.DistributedCacheEntry> artifacts : jobGraph.getUserArtifacts().entrySet()) {_				artifactFileNames.add(new JobSubmitRequestBody.DistributedCacheFile(artifacts.getKey(), new Path(artifacts.getValue().filePath).getName()))__				filesToUpload.add(new FileUpload(Paths.get(artifacts.getValue().filePath), RestConstants.CONTENT_TYPE_BINARY))__			}__			final JobSubmitRequestBody requestBody = new JobSubmitRequestBody(_				jobGraphFile.getFileName().toString(),_				jarFileNames,_				artifactFileNames)___			return Tuple2.of(requestBody, Collections.unmodifiableCollection(filesToUpload))__		})___		final CompletableFuture<JobSubmitResponseBody> submissionFuture = requestFuture.thenCompose(_			requestAndFileUploads -> sendRetriableRequest(_				JobSubmitHeaders.getInstance(),_				EmptyMessageParameters.getInstance(),_				requestAndFileUploads.f0,_				requestAndFileUploads.f1,_				isConnectionProblemOrServiceUnavailable())_		)___		submissionFuture_			.thenCombine(jobGraphFileFuture, (ignored, jobGraphFile) -> jobGraphFile)_			.thenAccept(jobGraphFile -> {_			try {_				Files.delete(jobGraphFile)__			} catch (IOException e) {_				log.warn("Could not delete temporary file {}.", jobGraphFile, e)__			}_		})___		return submissionFuture_			.thenApply(_				(JobSubmitResponseBody jobSubmitResponseBody) -> new JobSubmissionResult(jobGraph.getJobID()))_			.exceptionally(_				(Throwable throwable) -> {_					throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", ExceptionUtils.stripCompletionException(throwable)))__				})__	};submits,the,given,link,job,graph,to,the,dispatcher,param,job,graph,to,submit,return,future,which,is,completed,with,the,submission,response;override,public,completable,future,job,submission,result,submit,job,nonnull,job,graph,job,graph,job,graph,set,allow,queued,scheduling,true,completable,future,java,nio,file,path,job,graph,file,future,completable,future,supply,async,try,final,java,nio,file,path,job,graph,file,files,create,temp,file,flink,jobgraph,bin,try,object,output,stream,object,out,new,object,output,stream,files,new,output,stream,job,graph,file,object,out,write,object,job,graph,return,job,graph,file,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,failed,to,serialize,job,graph,e,executor,service,completable,future,tuple2,job,submit,request,body,collection,file,upload,request,future,job,graph,file,future,then,apply,job,graph,file,list,string,jar,file,names,new,array,list,8,list,job,submit,request,body,distributed,cache,file,artifact,file,names,new,array,list,8,collection,file,upload,files,to,upload,new,array,list,8,files,to,upload,add,new,file,upload,job,graph,file,rest,constants,for,path,jar,job,graph,get,user,jars,jar,file,names,add,jar,get,name,files,to,upload,add,new,file,upload,paths,get,jar,to,uri,rest,constants,for,map,entry,string,distributed,cache,distributed,cache,entry,artifacts,job,graph,get,user,artifacts,entry,set,artifact,file,names,add,new,job,submit,request,body,distributed,cache,file,artifacts,get,key,new,path,artifacts,get,value,file,path,get,name,files,to,upload,add,new,file,upload,paths,get,artifacts,get,value,file,path,rest,constants,final,job,submit,request,body,request,body,new,job,submit,request,body,job,graph,file,get,file,name,to,string,jar,file,names,artifact,file,names,return,tuple2,of,request,body,collections,unmodifiable,collection,files,to,upload,final,completable,future,job,submit,response,body,submission,future,request,future,then,compose,request,and,file,uploads,send,retriable,request,job,submit,headers,get,instance,empty,message,parameters,get,instance,request,and,file,uploads,f0,request,and,file,uploads,f1,is,connection,problem,or,service,unavailable,submission,future,then,combine,job,graph,file,future,ignored,job,graph,file,job,graph,file,then,accept,job,graph,file,try,files,delete,job,graph,file,catch,ioexception,e,log,warn,could,not,delete,temporary,file,job,graph,file,e,return,submission,future,then,apply,job,submit,response,body,job,submit,response,body,new,job,submission,result,job,graph,get,job,id,exceptionally,throwable,throwable,throw,new,completion,exception,new,job,submission,exception,job,graph,get,job,id,failed,to,submit,job,graph,exception,utils,strip,completion,exception,throwable
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1516971025;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1517237717;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1518680657;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1518680718;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1519249745;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1519249749;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1519317159;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1519638690;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1519977151;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1519977154;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1520032169;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1520032992;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1520246439;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1520248329;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1521396720;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1521641443;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1522049586;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1522132482;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1522132496;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1522759723;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1523641106;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1523906273;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1525116069;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1525420604;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1527173115;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1529046538;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1530181266;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1530644925;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1538042094;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1538395078;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync( 			final Supplier<CompletableFuture<A>> resourceFutureSupplier);1548435402;Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until_its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes_{@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of_{@link AsynchronouslyCreatedResource#resource()}.__@param resourceFutureSupplier The operation which polls for the_{@code AsynchronouslyCreatedResource}._@param <R>                    The type of the resource._@param <A>                    The type of the {@code AsynchronouslyCreatedResource}._@return A {@code CompletableFuture} delivering the resource.;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(_			final Supplier<CompletableFuture<A>> resourceFutureSupplier) {_		return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0)__	};creates,a,code,completable,future,that,polls,a,code,asynchronously,created,resource,until,its,link,asynchronously,created,resource,queue,status,queue,status,becomes,link,queue,status,id,completed,completed,the,future,completes,with,the,result,of,link,asynchronously,created,resource,resource,param,resource,future,supplier,the,operation,which,polls,for,the,code,asynchronously,created,resource,param,r,the,type,of,the,resource,param,a,the,type,of,the,code,asynchronously,created,resource,return,a,code,completable,future,delivering,the,resource;private,r,a,extends,asynchronously,created,resource,r,completable,future,r,poll,resource,async,final,supplier,completable,future,a,resource,future,supplier,return,poll,resource,async,resource,future,supplier,new,completable,future,0
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1518680657;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1518680718;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1519249745;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1519249749;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1519317159;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1519638690;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1519977151;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1519977154;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1520032169;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1520032992;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1520246439;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1520248329;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1521396720;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1521641443;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1522049586;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1522132482;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
RestClusterClient -> public CompletableFuture<JobResult> requestJobResult(JobID jobId);1522132496;Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple_times to poll the {@link JobResult} before giving up.__@param jobId specifying the job for which to retrieve the {@link JobResult}_@return Future which is completed with the {@link JobResult} once the job has completed or_with a failure if the {@link JobResult} could not be retrieved.;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {_		return pollResourceAsync(_			() -> {_				final JobMessageParameters messageParameters = new JobMessageParameters()__				messageParameters.jobPathParameter.resolve(jobId)__				return sendRetryableRequest(_					JobExecutionResultHeaders.getInstance(),_					messageParameters,_					EmptyRequestBody.getInstance(),_					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()))__			})__	};requests,the,link,job,result,for,the,given,link,job,id,the,method,retries,multiple,times,to,poll,the,link,job,result,before,giving,up,param,job,id,specifying,the,job,for,which,to,retrieve,the,link,job,result,return,future,which,is,completed,with,the,link,job,result,once,the,job,has,completed,or,with,a,failure,if,the,link,job,result,could,not,be,retrieved;public,completable,future,job,result,request,job,result,job,id,job,id,return,poll,resource,async,final,job,message,parameters,message,parameters,new,job,message,parameters,message,parameters,job,path,parameter,resolve,job,id,return,send,retryable,request,job,execution,result,headers,get,instance,message,parameters,empty,request,body,get,instance,is,connection,problem,exception,or,is,http,status,unsuccessful,exception
