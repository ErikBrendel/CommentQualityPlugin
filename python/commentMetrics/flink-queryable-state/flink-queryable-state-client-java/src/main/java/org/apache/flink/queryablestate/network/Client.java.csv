# id;timestamp;commentText;codeText;commentWords;codeWords
Client -> EstablishedConnection -> private boolean close(Throwable cause);1509037054;Close the channel with a cause.__@param cause The cause to close the channel with._@return Channel close future;private boolean close(Throwable cause) {_			if (failureCause.compareAndSet(null, cause)) {_				channel.close()__				stats.reportInactiveConnection()___				for (long requestId : pendingRequests.keySet()) {_					TimestampedCompletableFuture pending = pendingRequests.remove(requestId)__					if (pending != null && pending.completeExceptionally(cause)) {_						stats.reportFailedRequest()__					}_				}_				return true__			}_			return false__		};close,the,channel,with,a,cause,param,cause,the,cause,to,close,the,channel,with,return,channel,close,future;private,boolean,close,throwable,cause,if,failure,cause,compare,and,set,null,cause,channel,close,stats,report,inactive,connection,for,long,request,id,pending,requests,key,set,timestamped,completable,future,pending,pending,requests,remove,request,id,if,pending,null,pending,complete,exceptionally,cause,stats,report,failed,request,return,true,return,false
Client -> EstablishedConnection -> private boolean close(Throwable cause);1510911969;Close the channel with a cause.__@param cause The cause to close the channel with._@return Channel close future;private boolean close(Throwable cause) {_			if (failureCause.compareAndSet(null, cause)) {_				channel.close()__				stats.reportInactiveConnection()___				for (long requestId : pendingRequests.keySet()) {_					TimestampedCompletableFuture pending = pendingRequests.remove(requestId)__					if (pending != null && pending.completeExceptionally(cause)) {_						stats.reportFailedRequest()__					}_				}_				return true__			}_			return false__		};close,the,channel,with,a,cause,param,cause,the,cause,to,close,the,channel,with,return,channel,close,future;private,boolean,close,throwable,cause,if,failure,cause,compare,and,set,null,cause,channel,close,stats,report,inactive,connection,for,long,request,id,pending,requests,key,set,timestamped,completable,future,pending,pending,requests,remove,request,id,if,pending,null,pending,complete,exceptionally,cause,stats,report,failed,request,return,true,return,false
Client -> EstablishedConnection -> private boolean close(Throwable cause);1510911969;Close the channel with a cause.__@param cause The cause to close the channel with._@return Channel close future;private boolean close(Throwable cause) {_			if (failureCause.compareAndSet(null, cause)) {_				channel.close()__				stats.reportInactiveConnection()___				for (long requestId : pendingRequests.keySet()) {_					TimestampedCompletableFuture pending = pendingRequests.remove(requestId)__					if (pending != null && pending.completeExceptionally(cause)) {_						stats.reportFailedRequest()__					}_				}_				return true__			}_			return false__		};close,the,channel,with,a,cause,param,cause,the,cause,to,close,the,channel,with,return,channel,close,future;private,boolean,close,throwable,cause,if,failure,cause,compare,and,set,null,cause,channel,close,stats,report,inactive,connection,for,long,request,id,pending,requests,key,set,timestamped,completable,future,pending,pending,requests,remove,request,id,if,pending,null,pending,complete,exceptionally,cause,stats,report,failed,request,return,true,return,false
Client -> public CompletableFuture<Void> shutdown();1512567196;Shuts down the client and closes all connections.__<p>After a call to this method, all returned futures will be failed.__@return A {@link CompletableFuture} that will be completed when the shutdown process is done.;public CompletableFuture<Void> shutdown() {_		final CompletableFuture<Void> newShutdownFuture = new CompletableFuture<>()__		if (clientShutdownFuture.compareAndSet(null, newShutdownFuture)) {__			final List<CompletableFuture<Void>> connectionFutures = new ArrayList<>()___			for (Map.Entry<InetSocketAddress, EstablishedConnection> conn : establishedConnections.entrySet()) {_				if (establishedConnections.remove(conn.getKey(), conn.getValue())) {_					connectionFutures.add(conn.getValue().close())__				}_			}__			for (Map.Entry<InetSocketAddress, PendingConnection> conn : pendingConnections.entrySet()) {_				if (pendingConnections.remove(conn.getKey()) != null) {_					connectionFutures.add(conn.getValue().close())__				}_			}__			CompletableFuture.allOf(_					connectionFutures.toArray(new CompletableFuture<?>[connectionFutures.size()])_			).whenComplete((result, throwable) -> {__				if (throwable != null) {_					LOG.warn("Problem while shutting down the connections at the {}: {}", clientName, throwable)__				}__				if (bootstrap != null) {_					EventLoopGroup group = bootstrap.group()__					if (group != null && !group.isShutdown()) {_						group.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS)_								.addListener(finished -> {_									if (finished.isSuccess()) {_										newShutdownFuture.complete(null)__									} else {_										newShutdownFuture.completeExceptionally(finished.cause())__									}_								})__					} else {_						newShutdownFuture.complete(null)__					}_				} else {_					newShutdownFuture.complete(null)__				}_			})___			return newShutdownFuture__		}_		return clientShutdownFuture.get()__	};shuts,down,the,client,and,closes,all,connections,p,after,a,call,to,this,method,all,returned,futures,will,be,failed,return,a,link,completable,future,that,will,be,completed,when,the,shutdown,process,is,done;public,completable,future,void,shutdown,final,completable,future,void,new,shutdown,future,new,completable,future,if,client,shutdown,future,compare,and,set,null,new,shutdown,future,final,list,completable,future,void,connection,futures,new,array,list,for,map,entry,inet,socket,address,established,connection,conn,established,connections,entry,set,if,established,connections,remove,conn,get,key,conn,get,value,connection,futures,add,conn,get,value,close,for,map,entry,inet,socket,address,pending,connection,conn,pending,connections,entry,set,if,pending,connections,remove,conn,get,key,null,connection,futures,add,conn,get,value,close,completable,future,all,of,connection,futures,to,array,new,completable,future,connection,futures,size,when,complete,result,throwable,if,throwable,null,log,warn,problem,while,shutting,down,the,connections,at,the,client,name,throwable,if,bootstrap,null,event,loop,group,group,bootstrap,group,if,group,null,group,is,shutdown,group,shutdown,gracefully,0l,0l,time,unit,milliseconds,add,listener,finished,if,finished,is,success,new,shutdown,future,complete,null,else,new,shutdown,future,complete,exceptionally,finished,cause,else,new,shutdown,future,complete,null,else,new,shutdown,future,complete,null,return,new,shutdown,future,return,client,shutdown,future,get
Client -> public CompletableFuture<Void> shutdown();1522337739;Shuts down the client and closes all connections.__<p>After a call to this method, all returned futures will be failed.__@return A {@link CompletableFuture} that will be completed when the shutdown process is done.;public CompletableFuture<Void> shutdown() {_		final CompletableFuture<Void> newShutdownFuture = new CompletableFuture<>()__		if (clientShutdownFuture.compareAndSet(null, newShutdownFuture)) {__			final List<CompletableFuture<Void>> connectionFutures = new ArrayList<>()___			for (Map.Entry<InetSocketAddress, EstablishedConnection> conn : establishedConnections.entrySet()) {_				if (establishedConnections.remove(conn.getKey(), conn.getValue())) {_					connectionFutures.add(conn.getValue().close())__				}_			}__			for (Map.Entry<InetSocketAddress, PendingConnection> conn : pendingConnections.entrySet()) {_				if (pendingConnections.remove(conn.getKey()) != null) {_					connectionFutures.add(conn.getValue().close())__				}_			}__			CompletableFuture.allOf(_					connectionFutures.toArray(new CompletableFuture<?>[connectionFutures.size()])_			).whenComplete((result, throwable) -> {__				if (throwable != null) {_					LOG.warn("Problem while shutting down the connections at the {}: {}", clientName, throwable)__				}__				if (bootstrap != null) {_					EventLoopGroup group = bootstrap.group()__					if (group != null && !group.isShutdown()) {_						group.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS)_								.addListener(finished -> {_									if (finished.isSuccess()) {_										newShutdownFuture.complete(null)__									} else {_										newShutdownFuture.completeExceptionally(finished.cause())__									}_								})__					} else {_						newShutdownFuture.complete(null)__					}_				} else {_					newShutdownFuture.complete(null)__				}_			})___			return newShutdownFuture__		}_		return clientShutdownFuture.get()__	};shuts,down,the,client,and,closes,all,connections,p,after,a,call,to,this,method,all,returned,futures,will,be,failed,return,a,link,completable,future,that,will,be,completed,when,the,shutdown,process,is,done;public,completable,future,void,shutdown,final,completable,future,void,new,shutdown,future,new,completable,future,if,client,shutdown,future,compare,and,set,null,new,shutdown,future,final,list,completable,future,void,connection,futures,new,array,list,for,map,entry,inet,socket,address,established,connection,conn,established,connections,entry,set,if,established,connections,remove,conn,get,key,conn,get,value,connection,futures,add,conn,get,value,close,for,map,entry,inet,socket,address,pending,connection,conn,pending,connections,entry,set,if,pending,connections,remove,conn,get,key,null,connection,futures,add,conn,get,value,close,completable,future,all,of,connection,futures,to,array,new,completable,future,connection,futures,size,when,complete,result,throwable,if,throwable,null,log,warn,problem,while,shutting,down,the,connections,at,the,client,name,throwable,if,bootstrap,null,event,loop,group,group,bootstrap,group,if,group,null,group,is,shutdown,group,shutdown,gracefully,0l,0l,time,unit,milliseconds,add,listener,finished,if,finished,is,success,new,shutdown,future,complete,null,else,new,shutdown,future,complete,exceptionally,finished,cause,else,new,shutdown,future,complete,null,else,new,shutdown,future,complete,null,return,new,shutdown,future,return,client,shutdown,future,get
Client -> public Client( 			final String clientName, 			final int numEventLoopThreads, 			final MessageSerializer<REQ, RESP> serializer, 			final KvStateRequestStats stats);1509037054;Creates a client with the specified number of event loop threads.__@param clientName the name of the client._@param numEventLoopThreads number of event loop threads (minimum 1)._@param serializer the serializer used to (de-)serialize messages._@param stats the statistics collector.;public Client(_			final String clientName,_			final int numEventLoopThreads,_			final MessageSerializer<REQ, RESP> serializer,_			final KvStateRequestStats stats) {__		Preconditions.checkArgument(numEventLoopThreads >= 1,_				"Non-positive number of event loop threads.")___		this.clientName = Preconditions.checkNotNull(clientName)__		this.messageSerializer = Preconditions.checkNotNull(serializer)__		this.stats = Preconditions.checkNotNull(stats)___		final ThreadFactory threadFactory = new ThreadFactoryBuilder()_				.setDaemon(true)_				.setNameFormat("Flink " + clientName + " Event Loop Thread %d")_				.build()___		final EventLoopGroup nioGroup = new NioEventLoopGroup(numEventLoopThreads, threadFactory)__		final ByteBufAllocator bufferPool = new NettyBufferPool(numEventLoopThreads)___		this.bootstrap = new Bootstrap()_				.group(nioGroup)_				.channel(NioSocketChannel.class)_				.option(ChannelOption.ALLOCATOR, bufferPool)_				.handler(new ChannelInitializer<SocketChannel>() {_					@Override_					protected void initChannel(SocketChannel channel) throws Exception {_						channel.pipeline()_								.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4))_								.addLast(new ChunkedWriteHandler())__					}_				})__	};creates,a,client,with,the,specified,number,of,event,loop,threads,param,client,name,the,name,of,the,client,param,num,event,loop,threads,number,of,event,loop,threads,minimum,1,param,serializer,the,serializer,used,to,de,serialize,messages,param,stats,the,statistics,collector;public,client,final,string,client,name,final,int,num,event,loop,threads,final,message,serializer,req,resp,serializer,final,kv,state,request,stats,stats,preconditions,check,argument,num,event,loop,threads,1,non,positive,number,of,event,loop,threads,this,client,name,preconditions,check,not,null,client,name,this,message,serializer,preconditions,check,not,null,serializer,this,stats,preconditions,check,not,null,stats,final,thread,factory,thread,factory,new,thread,factory,builder,set,daemon,true,set,name,format,flink,client,name,event,loop,thread,d,build,final,event,loop,group,nio,group,new,nio,event,loop,group,num,event,loop,threads,thread,factory,final,byte,buf,allocator,buffer,pool,new,netty,buffer,pool,num,event,loop,threads,this,bootstrap,new,bootstrap,group,nio,group,channel,nio,socket,channel,class,option,channel,option,allocator,buffer,pool,handler,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,channel,throws,exception,channel,pipeline,add,last,new,length,field,based,frame,decoder,integer,0,4,0,4,add,last,new,chunked,write,handler
Client -> public Client( 			final String clientName, 			final int numEventLoopThreads, 			final MessageSerializer<REQ, RESP> serializer, 			final KvStateRequestStats stats);1510911969;Creates a client with the specified number of event loop threads.__@param clientName the name of the client._@param numEventLoopThreads number of event loop threads (minimum 1)._@param serializer the serializer used to (de-)serialize messages._@param stats the statistics collector.;public Client(_			final String clientName,_			final int numEventLoopThreads,_			final MessageSerializer<REQ, RESP> serializer,_			final KvStateRequestStats stats) {__		Preconditions.checkArgument(numEventLoopThreads >= 1,_				"Non-positive number of event loop threads.")___		this.clientName = Preconditions.checkNotNull(clientName)__		this.messageSerializer = Preconditions.checkNotNull(serializer)__		this.stats = Preconditions.checkNotNull(stats)___		final ThreadFactory threadFactory = new ThreadFactoryBuilder()_				.setDaemon(true)_				.setNameFormat("Flink " + clientName + " Event Loop Thread %d")_				.build()___		final EventLoopGroup nioGroup = new NioEventLoopGroup(numEventLoopThreads, threadFactory)__		final ByteBufAllocator bufferPool = new NettyBufferPool(numEventLoopThreads)___		this.bootstrap = new Bootstrap()_				.group(nioGroup)_				.channel(NioSocketChannel.class)_				.option(ChannelOption.ALLOCATOR, bufferPool)_				.handler(new ChannelInitializer<SocketChannel>() {_					@Override_					protected void initChannel(SocketChannel channel) throws Exception {_						channel.pipeline()_								.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4))_								.addLast(new ChunkedWriteHandler())__					}_				})__	};creates,a,client,with,the,specified,number,of,event,loop,threads,param,client,name,the,name,of,the,client,param,num,event,loop,threads,number,of,event,loop,threads,minimum,1,param,serializer,the,serializer,used,to,de,serialize,messages,param,stats,the,statistics,collector;public,client,final,string,client,name,final,int,num,event,loop,threads,final,message,serializer,req,resp,serializer,final,kv,state,request,stats,stats,preconditions,check,argument,num,event,loop,threads,1,non,positive,number,of,event,loop,threads,this,client,name,preconditions,check,not,null,client,name,this,message,serializer,preconditions,check,not,null,serializer,this,stats,preconditions,check,not,null,stats,final,thread,factory,thread,factory,new,thread,factory,builder,set,daemon,true,set,name,format,flink,client,name,event,loop,thread,d,build,final,event,loop,group,nio,group,new,nio,event,loop,group,num,event,loop,threads,thread,factory,final,byte,buf,allocator,buffer,pool,new,netty,buffer,pool,num,event,loop,threads,this,bootstrap,new,bootstrap,group,nio,group,channel,nio,socket,channel,class,option,channel,option,allocator,buffer,pool,handler,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,channel,throws,exception,channel,pipeline,add,last,new,length,field,based,frame,decoder,integer,0,4,0,4,add,last,new,chunked,write,handler
Client -> public Client( 			final String clientName, 			final int numEventLoopThreads, 			final MessageSerializer<REQ, RESP> serializer, 			final KvStateRequestStats stats);1510911969;Creates a client with the specified number of event loop threads.__@param clientName the name of the client._@param numEventLoopThreads number of event loop threads (minimum 1)._@param serializer the serializer used to (de-)serialize messages._@param stats the statistics collector.;public Client(_			final String clientName,_			final int numEventLoopThreads,_			final MessageSerializer<REQ, RESP> serializer,_			final KvStateRequestStats stats) {__		Preconditions.checkArgument(numEventLoopThreads >= 1,_				"Non-positive number of event loop threads.")___		this.clientName = Preconditions.checkNotNull(clientName)__		this.messageSerializer = Preconditions.checkNotNull(serializer)__		this.stats = Preconditions.checkNotNull(stats)___		final ThreadFactory threadFactory = new ThreadFactoryBuilder()_				.setDaemon(true)_				.setNameFormat("Flink " + clientName + " Event Loop Thread %d")_				.build()___		final EventLoopGroup nioGroup = new NioEventLoopGroup(numEventLoopThreads, threadFactory)__		final ByteBufAllocator bufferPool = new NettyBufferPool(numEventLoopThreads)___		this.bootstrap = new Bootstrap()_				.group(nioGroup)_				.channel(NioSocketChannel.class)_				.option(ChannelOption.ALLOCATOR, bufferPool)_				.handler(new ChannelInitializer<SocketChannel>() {_					@Override_					protected void initChannel(SocketChannel channel) throws Exception {_						channel.pipeline()_								.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4))_								.addLast(new ChunkedWriteHandler())__					}_				})__	};creates,a,client,with,the,specified,number,of,event,loop,threads,param,client,name,the,name,of,the,client,param,num,event,loop,threads,number,of,event,loop,threads,minimum,1,param,serializer,the,serializer,used,to,de,serialize,messages,param,stats,the,statistics,collector;public,client,final,string,client,name,final,int,num,event,loop,threads,final,message,serializer,req,resp,serializer,final,kv,state,request,stats,stats,preconditions,check,argument,num,event,loop,threads,1,non,positive,number,of,event,loop,threads,this,client,name,preconditions,check,not,null,client,name,this,message,serializer,preconditions,check,not,null,serializer,this,stats,preconditions,check,not,null,stats,final,thread,factory,thread,factory,new,thread,factory,builder,set,daemon,true,set,name,format,flink,client,name,event,loop,thread,d,build,final,event,loop,group,nio,group,new,nio,event,loop,group,num,event,loop,threads,thread,factory,final,byte,buf,allocator,buffer,pool,new,netty,buffer,pool,num,event,loop,threads,this,bootstrap,new,bootstrap,group,nio,group,channel,nio,socket,channel,class,option,channel,option,allocator,buffer,pool,handler,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,channel,throws,exception,channel,pipeline,add,last,new,length,field,based,frame,decoder,integer,0,4,0,4,add,last,new,chunked,write,handler
Client -> public Client( 			final String clientName, 			final int numEventLoopThreads, 			final MessageSerializer<REQ, RESP> serializer, 			final KvStateRequestStats stats);1512567196;Creates a client with the specified number of event loop threads.__@param clientName the name of the client._@param numEventLoopThreads number of event loop threads (minimum 1)._@param serializer the serializer used to (de-)serialize messages._@param stats the statistics collector.;public Client(_			final String clientName,_			final int numEventLoopThreads,_			final MessageSerializer<REQ, RESP> serializer,_			final KvStateRequestStats stats) {__		Preconditions.checkArgument(numEventLoopThreads >= 1,_				"Non-positive number of event loop threads.")___		this.clientName = Preconditions.checkNotNull(clientName)__		this.messageSerializer = Preconditions.checkNotNull(serializer)__		this.stats = Preconditions.checkNotNull(stats)___		final ThreadFactory threadFactory = new ThreadFactoryBuilder()_				.setDaemon(true)_				.setNameFormat("Flink " + clientName + " Event Loop Thread %d")_				.build()___		final EventLoopGroup nioGroup = new NioEventLoopGroup(numEventLoopThreads, threadFactory)__		final ByteBufAllocator bufferPool = new NettyBufferPool(numEventLoopThreads)___		this.bootstrap = new Bootstrap()_				.group(nioGroup)_				.channel(NioSocketChannel.class)_				.option(ChannelOption.ALLOCATOR, bufferPool)_				.handler(new ChannelInitializer<SocketChannel>() {_					@Override_					protected void initChannel(SocketChannel channel) throws Exception {_						channel.pipeline()_								.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4))_								.addLast(new ChunkedWriteHandler())__					}_				})__	};creates,a,client,with,the,specified,number,of,event,loop,threads,param,client,name,the,name,of,the,client,param,num,event,loop,threads,number,of,event,loop,threads,minimum,1,param,serializer,the,serializer,used,to,de,serialize,messages,param,stats,the,statistics,collector;public,client,final,string,client,name,final,int,num,event,loop,threads,final,message,serializer,req,resp,serializer,final,kv,state,request,stats,stats,preconditions,check,argument,num,event,loop,threads,1,non,positive,number,of,event,loop,threads,this,client,name,preconditions,check,not,null,client,name,this,message,serializer,preconditions,check,not,null,serializer,this,stats,preconditions,check,not,null,stats,final,thread,factory,thread,factory,new,thread,factory,builder,set,daemon,true,set,name,format,flink,client,name,event,loop,thread,d,build,final,event,loop,group,nio,group,new,nio,event,loop,group,num,event,loop,threads,thread,factory,final,byte,buf,allocator,buffer,pool,new,netty,buffer,pool,num,event,loop,threads,this,bootstrap,new,bootstrap,group,nio,group,channel,nio,socket,channel,class,option,channel,option,allocator,buffer,pool,handler,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,channel,throws,exception,channel,pipeline,add,last,new,length,field,based,frame,decoder,integer,0,4,0,4,add,last,new,chunked,write,handler
Client -> public Client( 			final String clientName, 			final int numEventLoopThreads, 			final MessageSerializer<REQ, RESP> serializer, 			final KvStateRequestStats stats);1522337739;Creates a client with the specified number of event loop threads.__@param clientName the name of the client._@param numEventLoopThreads number of event loop threads (minimum 1)._@param serializer the serializer used to (de-)serialize messages._@param stats the statistics collector.;public Client(_			final String clientName,_			final int numEventLoopThreads,_			final MessageSerializer<REQ, RESP> serializer,_			final KvStateRequestStats stats) {__		Preconditions.checkArgument(numEventLoopThreads >= 1,_				"Non-positive number of event loop threads.")___		this.clientName = Preconditions.checkNotNull(clientName)__		this.messageSerializer = Preconditions.checkNotNull(serializer)__		this.stats = Preconditions.checkNotNull(stats)___		final ThreadFactory threadFactory = new ThreadFactoryBuilder()_				.setDaemon(true)_				.setNameFormat("Flink " + clientName + " Event Loop Thread %d")_				.build()___		final EventLoopGroup nioGroup = new NioEventLoopGroup(numEventLoopThreads, threadFactory)__		final ByteBufAllocator bufferPool = new NettyBufferPool(numEventLoopThreads)___		this.bootstrap = new Bootstrap()_				.group(nioGroup)_				.channel(NioSocketChannel.class)_				.option(ChannelOption.ALLOCATOR, bufferPool)_				.handler(new ChannelInitializer<SocketChannel>() {_					@Override_					protected void initChannel(SocketChannel channel) throws Exception {_						channel.pipeline()_								.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4))_								.addLast(new ChunkedWriteHandler())__					}_				})__	};creates,a,client,with,the,specified,number,of,event,loop,threads,param,client,name,the,name,of,the,client,param,num,event,loop,threads,number,of,event,loop,threads,minimum,1,param,serializer,the,serializer,used,to,de,serialize,messages,param,stats,the,statistics,collector;public,client,final,string,client,name,final,int,num,event,loop,threads,final,message,serializer,req,resp,serializer,final,kv,state,request,stats,stats,preconditions,check,argument,num,event,loop,threads,1,non,positive,number,of,event,loop,threads,this,client,name,preconditions,check,not,null,client,name,this,message,serializer,preconditions,check,not,null,serializer,this,stats,preconditions,check,not,null,stats,final,thread,factory,thread,factory,new,thread,factory,builder,set,daemon,true,set,name,format,flink,client,name,event,loop,thread,d,build,final,event,loop,group,nio,group,new,nio,event,loop,group,num,event,loop,threads,thread,factory,final,byte,buf,allocator,buffer,pool,new,netty,buffer,pool,num,event,loop,threads,this,bootstrap,new,bootstrap,group,nio,group,channel,nio,socket,channel,class,option,channel,option,allocator,buffer,pool,handler,new,channel,initializer,socket,channel,override,protected,void,init,channel,socket,channel,channel,throws,exception,channel,pipeline,add,last,new,length,field,based,frame,decoder,integer,0,4,0,4,add,last,new,chunked,write,handler
Client -> PendingConnection -> private PendingConnection( 				final InetSocketAddress serverAddress, 				final MessageSerializer<REQ, RESP> serializer);1509037054;Creates a pending connection to the given server.__@param serverAddress Address of the server to connect to.;private PendingConnection(_				final InetSocketAddress serverAddress,_				final MessageSerializer<REQ, RESP> serializer) {_			this.serverAddress = serverAddress__			this.serializer = serializer__		};creates,a,pending,connection,to,the,given,server,param,server,address,address,of,the,server,to,connect,to;private,pending,connection,final,inet,socket,address,server,address,final,message,serializer,req,resp,serializer,this,server,address,server,address,this,serializer,serializer
Client -> PendingConnection -> private PendingConnection( 				final InetSocketAddress serverAddress, 				final MessageSerializer<REQ, RESP> serializer);1510911969;Creates a pending connection to the given server.__@param serverAddress Address of the server to connect to.;private PendingConnection(_				final InetSocketAddress serverAddress,_				final MessageSerializer<REQ, RESP> serializer) {_			this.serverAddress = serverAddress__			this.serializer = serializer__		};creates,a,pending,connection,to,the,given,server,param,server,address,address,of,the,server,to,connect,to;private,pending,connection,final,inet,socket,address,server,address,final,message,serializer,req,resp,serializer,this,server,address,server,address,this,serializer,serializer
Client -> PendingConnection -> private PendingConnection( 				final InetSocketAddress serverAddress, 				final MessageSerializer<REQ, RESP> serializer);1510911969;Creates a pending connection to the given server.__@param serverAddress Address of the server to connect to.;private PendingConnection(_				final InetSocketAddress serverAddress,_				final MessageSerializer<REQ, RESP> serializer) {_			this.serverAddress = serverAddress__			this.serializer = serializer__		};creates,a,pending,connection,to,the,given,server,param,server,address,address,of,the,server,to,connect,to;private,pending,connection,final,inet,socket,address,server,address,final,message,serializer,req,resp,serializer,this,server,address,server,address,this,serializer,serializer
Client -> PendingConnection -> private PendingConnection( 				final InetSocketAddress serverAddress, 				final MessageSerializer<REQ, RESP> serializer);1512567196;Creates a pending connection to the given server.__@param serverAddress Address of the server to connect to.;private PendingConnection(_				final InetSocketAddress serverAddress,_				final MessageSerializer<REQ, RESP> serializer) {_			this.serverAddress = serverAddress__			this.serializer = serializer__		};creates,a,pending,connection,to,the,given,server,param,server,address,address,of,the,server,to,connect,to;private,pending,connection,final,inet,socket,address,server,address,final,message,serializer,req,resp,serializer,this,server,address,server,address,this,serializer,serializer
Client -> PendingConnection -> private PendingConnection( 				final InetSocketAddress serverAddress, 				final MessageSerializer<REQ, RESP> serializer);1522337739;Creates a pending connection to the given server.__@param serverAddress Address of the server to connect to.;private PendingConnection(_				final InetSocketAddress serverAddress,_				final MessageSerializer<REQ, RESP> serializer) {_			this.serverAddress = serverAddress__			this.serializer = serializer__		};creates,a,pending,connection,to,the,given,server,param,server,address,address,of,the,server,to,connect,to;private,pending,connection,final,inet,socket,address,server,address,final,message,serializer,req,resp,serializer,this,server,address,server,address,this,serializer,serializer
Client -> EstablishedConnection -> EstablishedConnection( 				final InetSocketAddress serverAddress, 				final MessageSerializer<REQ, RESP> serializer, 				final Channel channel);1509037054;Creates an established connection with the given channel.__@param serverAddress Address of the server connected to_@param channel The actual TCP channel;EstablishedConnection(_				final InetSocketAddress serverAddress,_				final MessageSerializer<REQ, RESP> serializer,_				final Channel channel) {__			this.serverAddress = Preconditions.checkNotNull(serverAddress)__			this.channel = Preconditions.checkNotNull(channel)___			_			channel.pipeline().addLast(_					getClientName() + " Handler",_					new ClientHandler<>(clientName, serializer, this)_			)___			stats.reportActiveConnection()__		};creates,an,established,connection,with,the,given,channel,param,server,address,address,of,the,server,connected,to,param,channel,the,actual,tcp,channel;established,connection,final,inet,socket,address,server,address,final,message,serializer,req,resp,serializer,final,channel,channel,this,server,address,preconditions,check,not,null,server,address,this,channel,preconditions,check,not,null,channel,channel,pipeline,add,last,get,client,name,handler,new,client,handler,client,name,serializer,this,stats,report,active,connection
Client -> EstablishedConnection -> EstablishedConnection( 				final InetSocketAddress serverAddress, 				final MessageSerializer<REQ, RESP> serializer, 				final Channel channel);1510911969;Creates an established connection with the given channel.__@param serverAddress Address of the server connected to_@param channel The actual TCP channel;EstablishedConnection(_				final InetSocketAddress serverAddress,_				final MessageSerializer<REQ, RESP> serializer,_				final Channel channel) {__			this.serverAddress = Preconditions.checkNotNull(serverAddress)__			this.channel = Preconditions.checkNotNull(channel)___			_			channel.pipeline().addLast(_					getClientName() + " Handler",_					new ClientHandler<>(clientName, serializer, this)_			)___			stats.reportActiveConnection()__		};creates,an,established,connection,with,the,given,channel,param,server,address,address,of,the,server,connected,to,param,channel,the,actual,tcp,channel;established,connection,final,inet,socket,address,server,address,final,message,serializer,req,resp,serializer,final,channel,channel,this,server,address,preconditions,check,not,null,server,address,this,channel,preconditions,check,not,null,channel,channel,pipeline,add,last,get,client,name,handler,new,client,handler,client,name,serializer,this,stats,report,active,connection
Client -> EstablishedConnection -> EstablishedConnection( 				final InetSocketAddress serverAddress, 				final MessageSerializer<REQ, RESP> serializer, 				final Channel channel);1510911969;Creates an established connection with the given channel.__@param serverAddress Address of the server connected to_@param channel The actual TCP channel;EstablishedConnection(_				final InetSocketAddress serverAddress,_				final MessageSerializer<REQ, RESP> serializer,_				final Channel channel) {__			this.serverAddress = Preconditions.checkNotNull(serverAddress)__			this.channel = Preconditions.checkNotNull(channel)___			_			channel.pipeline().addLast(_					getClientName() + " Handler",_					new ClientHandler<>(clientName, serializer, this)_			)___			stats.reportActiveConnection()__		};creates,an,established,connection,with,the,given,channel,param,server,address,address,of,the,server,connected,to,param,channel,the,actual,tcp,channel;established,connection,final,inet,socket,address,server,address,final,message,serializer,req,resp,serializer,final,channel,channel,this,server,address,preconditions,check,not,null,server,address,this,channel,preconditions,check,not,null,channel,channel,pipeline,add,last,get,client,name,handler,new,client,handler,client,name,serializer,this,stats,report,active,connection
Client -> EstablishedConnection -> EstablishedConnection( 				final InetSocketAddress serverAddress, 				final MessageSerializer<REQ, RESP> serializer, 				final Channel channel);1512567196;Creates an established connection with the given channel.__@param serverAddress Address of the server connected to_@param channel The actual TCP channel;EstablishedConnection(_				final InetSocketAddress serverAddress,_				final MessageSerializer<REQ, RESP> serializer,_				final Channel channel) {__			this.serverAddress = Preconditions.checkNotNull(serverAddress)__			this.channel = Preconditions.checkNotNull(channel)___			_			channel.pipeline().addLast(_					getClientName() + " Handler",_					new ClientHandler<>(clientName, serializer, this)_			)___			stats.reportActiveConnection()__		};creates,an,established,connection,with,the,given,channel,param,server,address,address,of,the,server,connected,to,param,channel,the,actual,tcp,channel;established,connection,final,inet,socket,address,server,address,final,message,serializer,req,resp,serializer,final,channel,channel,this,server,address,preconditions,check,not,null,server,address,this,channel,preconditions,check,not,null,channel,channel,pipeline,add,last,get,client,name,handler,new,client,handler,client,name,serializer,this,stats,report,active,connection
Client -> EstablishedConnection -> EstablishedConnection( 				final InetSocketAddress serverAddress, 				final MessageSerializer<REQ, RESP> serializer, 				final Channel channel);1522337739;Creates an established connection with the given channel.__@param serverAddress Address of the server connected to_@param channel The actual TCP channel;EstablishedConnection(_				final InetSocketAddress serverAddress,_				final MessageSerializer<REQ, RESP> serializer,_				final Channel channel) {__			this.serverAddress = Preconditions.checkNotNull(serverAddress)__			this.channel = Preconditions.checkNotNull(channel)___			_			channel.pipeline().addLast(_					getClientName() + " Handler",_					new ClientHandler<>(clientName, serializer, this)_			)___			stats.reportActiveConnection()__		};creates,an,established,connection,with,the,given,channel,param,server,address,address,of,the,server,connected,to,param,channel,the,actual,tcp,channel;established,connection,final,inet,socket,address,server,address,final,message,serializer,req,resp,serializer,final,channel,channel,this,server,address,preconditions,check,not,null,server,address,this,channel,preconditions,check,not,null,channel,channel,pipeline,add,last,get,client,name,handler,new,client,handler,client,name,serializer,this,stats,report,active,connection
Client -> PendingConnection -> private CompletableFuture<Void> close(Throwable cause);1512567196;Close the connecting channel with an Exception (can be {@code null})_or forward to the established channel.;private CompletableFuture<Void> close(Throwable cause) {_			CompletableFuture<Void> future = new CompletableFuture<>()__			if (connectionShutdownFuture.compareAndSet(null, future)) {_				synchronized (connectLock) {_					if (failureCause == null) {_						failureCause = cause__					}__					if (established != null) {_						established.close().whenComplete((result, throwable) -> {_							if (throwable != null) {_								future.completeExceptionally(throwable)__							} else {_								future.complete(null)__							}_						})__					} else {_						PendingRequest pending__						while ((pending = queuedRequests.poll()) != null) {_							pending.completeExceptionally(cause)__						}_						future.complete(null)__					}_				}_			}_			return connectionShutdownFuture.get()__		};close,the,connecting,channel,with,an,exception,can,be,code,null,or,forward,to,the,established,channel;private,completable,future,void,close,throwable,cause,completable,future,void,future,new,completable,future,if,connection,shutdown,future,compare,and,set,null,future,synchronized,connect,lock,if,failure,cause,null,failure,cause,cause,if,established,null,established,close,when,complete,result,throwable,if,throwable,null,future,complete,exceptionally,throwable,else,future,complete,null,else,pending,request,pending,while,pending,queued,requests,poll,null,pending,complete,exceptionally,cause,future,complete,null,return,connection,shutdown,future,get
Client -> PendingConnection -> private CompletableFuture<Void> close(Throwable cause);1522337739;Close the connecting channel with an Exception (can be {@code null})_or forward to the established channel.;private CompletableFuture<Void> close(Throwable cause) {_			CompletableFuture<Void> future = new CompletableFuture<>()__			if (connectionShutdownFuture.compareAndSet(null, future)) {_				synchronized (connectLock) {_					if (failureCause == null) {_						failureCause = cause__					}__					if (established != null) {_						established.close().whenComplete((result, throwable) -> {_							if (throwable != null) {_								future.completeExceptionally(throwable)__							} else {_								future.complete(null)__							}_						})__					} else {_						PendingRequest pending__						while ((pending = queuedRequests.poll()) != null) {_							pending.completeExceptionally(cause)__						}_						future.complete(null)__					}_				}_			}_			return connectionShutdownFuture.get()__		};close,the,connecting,channel,with,an,exception,can,be,code,null,or,forward,to,the,established,channel;private,completable,future,void,close,throwable,cause,completable,future,void,future,new,completable,future,if,connection,shutdown,future,compare,and,set,null,future,synchronized,connect,lock,if,failure,cause,null,failure,cause,cause,if,established,null,established,close,when,complete,result,throwable,if,throwable,null,future,complete,exceptionally,throwable,else,future,complete,null,else,pending,request,pending,while,pending,queued,requests,poll,null,pending,complete,exceptionally,cause,future,complete,null,return,connection,shutdown,future,get
Client -> EstablishedConnection -> CompletableFuture<Void> close();1512567196;Close the channel with a ClosedChannelException.;CompletableFuture<Void> close() {_			return close(new ClosedChannelException())__		};close,the,channel,with,a,closed,channel,exception;completable,future,void,close,return,close,new,closed,channel,exception
Client -> EstablishedConnection -> CompletableFuture<Void> close();1522337739;Close the channel with a ClosedChannelException.;CompletableFuture<Void> close() {_			return close(new ClosedChannelException())__		};close,the,channel,with,a,closed,channel,exception;completable,future,void,close,return,close,new,closed,channel,exception
Client -> PendingConnection -> public CompletableFuture<RESP> sendRequest(REQ request);1509037054;Returns a future holding the serialized request result.__<p>If the channel has been established, forward the call to the_established channel, otherwise queue it for when the channel is_handed in.__@param request the request to be sent._@return Future holding the serialized result;public CompletableFuture<RESP> sendRequest(REQ request) {_			synchronized (connectLock) {_				if (failureCause != null) {_					return FutureUtils.getFailedFuture(failureCause)__				} else if (closed) {_					return FutureUtils.getFailedFuture(new ClosedChannelException())__				} else {_					if (established != null) {_						return established.sendRequest(request)__					} else {_						_						final PendingRequest pending = new PendingRequest(request)__						queuedRequests.add(pending)__						return pending__					}_				}_			}_		};returns,a,future,holding,the,serialized,request,result,p,if,the,channel,has,been,established,forward,the,call,to,the,established,channel,otherwise,queue,it,for,when,the,channel,is,handed,in,param,request,the,request,to,be,sent,return,future,holding,the,serialized,result;public,completable,future,resp,send,request,req,request,synchronized,connect,lock,if,failure,cause,null,return,future,utils,get,failed,future,failure,cause,else,if,closed,return,future,utils,get,failed,future,new,closed,channel,exception,else,if,established,null,return,established,send,request,request,else,final,pending,request,pending,new,pending,request,request,queued,requests,add,pending,return,pending
Client -> PendingConnection -> public CompletableFuture<RESP> sendRequest(REQ request);1510911969;Returns a future holding the serialized request result.__<p>If the channel has been established, forward the call to the_established channel, otherwise queue it for when the channel is_handed in.__@param request the request to be sent._@return Future holding the serialized result;public CompletableFuture<RESP> sendRequest(REQ request) {_			synchronized (connectLock) {_				if (failureCause != null) {_					return FutureUtils.getFailedFuture(failureCause)__				} else if (closed) {_					return FutureUtils.getFailedFuture(new ClosedChannelException())__				} else {_					if (established != null) {_						return established.sendRequest(request)__					} else {_						_						final PendingRequest pending = new PendingRequest(request)__						queuedRequests.add(pending)__						return pending__					}_				}_			}_		};returns,a,future,holding,the,serialized,request,result,p,if,the,channel,has,been,established,forward,the,call,to,the,established,channel,otherwise,queue,it,for,when,the,channel,is,handed,in,param,request,the,request,to,be,sent,return,future,holding,the,serialized,result;public,completable,future,resp,send,request,req,request,synchronized,connect,lock,if,failure,cause,null,return,future,utils,get,failed,future,failure,cause,else,if,closed,return,future,utils,get,failed,future,new,closed,channel,exception,else,if,established,null,return,established,send,request,request,else,final,pending,request,pending,new,pending,request,request,queued,requests,add,pending,return,pending
Client -> PendingConnection -> public CompletableFuture<RESP> sendRequest(REQ request);1510911969;Returns a future holding the serialized request result.__<p>If the channel has been established, forward the call to the_established channel, otherwise queue it for when the channel is_handed in.__@param request the request to be sent._@return Future holding the serialized result;public CompletableFuture<RESP> sendRequest(REQ request) {_			synchronized (connectLock) {_				if (failureCause != null) {_					return FutureUtils.getFailedFuture(failureCause)__				} else if (closed) {_					return FutureUtils.getFailedFuture(new ClosedChannelException())__				} else {_					if (established != null) {_						return established.sendRequest(request)__					} else {_						_						final PendingRequest pending = new PendingRequest(request)__						queuedRequests.add(pending)__						return pending__					}_				}_			}_		};returns,a,future,holding,the,serialized,request,result,p,if,the,channel,has,been,established,forward,the,call,to,the,established,channel,otherwise,queue,it,for,when,the,channel,is,handed,in,param,request,the,request,to,be,sent,return,future,holding,the,serialized,result;public,completable,future,resp,send,request,req,request,synchronized,connect,lock,if,failure,cause,null,return,future,utils,get,failed,future,failure,cause,else,if,closed,return,future,utils,get,failed,future,new,closed,channel,exception,else,if,established,null,return,established,send,request,request,else,final,pending,request,pending,new,pending,request,request,queued,requests,add,pending,return,pending
Client -> PendingConnection -> public CompletableFuture<RESP> sendRequest(REQ request);1512567196;Returns a future holding the serialized request result.__<p>If the channel has been established, forward the call to the_established channel, otherwise queue it for when the channel is_handed in.__@param request the request to be sent._@return Future holding the serialized result;public CompletableFuture<RESP> sendRequest(REQ request) {_			synchronized (connectLock) {_				if (failureCause != null) {_					return FutureUtils.getFailedFuture(failureCause)__				} else if (connectionShutdownFuture.get() != null) {_					return FutureUtils.getFailedFuture(new ClosedChannelException())__				} else {_					if (established != null) {_						return established.sendRequest(request)__					} else {_						_						final PendingRequest pending = new PendingRequest(request)__						queuedRequests.add(pending)__						return pending__					}_				}_			}_		};returns,a,future,holding,the,serialized,request,result,p,if,the,channel,has,been,established,forward,the,call,to,the,established,channel,otherwise,queue,it,for,when,the,channel,is,handed,in,param,request,the,request,to,be,sent,return,future,holding,the,serialized,result;public,completable,future,resp,send,request,req,request,synchronized,connect,lock,if,failure,cause,null,return,future,utils,get,failed,future,failure,cause,else,if,connection,shutdown,future,get,null,return,future,utils,get,failed,future,new,closed,channel,exception,else,if,established,null,return,established,send,request,request,else,final,pending,request,pending,new,pending,request,request,queued,requests,add,pending,return,pending
Client -> EstablishedConnection -> CompletableFuture<RESP> sendRequest(REQ request);1509037054;Returns a future holding the serialized request result._@param request the request to be sent._@return Future holding the serialized result;CompletableFuture<RESP> sendRequest(REQ request) {_			TimestampedCompletableFuture requestPromiseTs =_					new TimestampedCompletableFuture(System.nanoTime())__			try {_				final long requestId = requestCount.getAndIncrement()__				pendingRequests.put(requestId, requestPromiseTs)___				stats.reportRequest()___				ByteBuf buf = MessageSerializer.serializeRequest(channel.alloc(), requestId, request)___				channel.writeAndFlush(buf).addListener((ChannelFutureListener) future -> {_					if (!future.isSuccess()) {_						_						TimestampedCompletableFuture pending = pendingRequests.remove(requestId)__						if (pending != null && pending.completeExceptionally(future.cause())) {_							stats.reportFailedRequest()__						}_					}_				})___				_				_				_				Throwable failure = failureCause.get()__				if (failure != null) {_					_					_					TimestampedCompletableFuture pending = pendingRequests.remove(requestId)__					if (pending != null && pending.completeExceptionally(failure)) {_						stats.reportFailedRequest()__					}_				}_			} catch (Throwable t) {_				requestPromiseTs.completeExceptionally(t)__			}__			return requestPromiseTs__		};returns,a,future,holding,the,serialized,request,result,param,request,the,request,to,be,sent,return,future,holding,the,serialized,result;completable,future,resp,send,request,req,request,timestamped,completable,future,request,promise,ts,new,timestamped,completable,future,system,nano,time,try,final,long,request,id,request,count,get,and,increment,pending,requests,put,request,id,request,promise,ts,stats,report,request,byte,buf,buf,message,serializer,serialize,request,channel,alloc,request,id,request,channel,write,and,flush,buf,add,listener,channel,future,listener,future,if,future,is,success,timestamped,completable,future,pending,pending,requests,remove,request,id,if,pending,null,pending,complete,exceptionally,future,cause,stats,report,failed,request,throwable,failure,failure,cause,get,if,failure,null,timestamped,completable,future,pending,pending,requests,remove,request,id,if,pending,null,pending,complete,exceptionally,failure,stats,report,failed,request,catch,throwable,t,request,promise,ts,complete,exceptionally,t,return,request,promise,ts
Client -> EstablishedConnection -> CompletableFuture<RESP> sendRequest(REQ request);1510911969;Returns a future holding the serialized request result._@param request the request to be sent._@return Future holding the serialized result;CompletableFuture<RESP> sendRequest(REQ request) {_			TimestampedCompletableFuture requestPromiseTs =_					new TimestampedCompletableFuture(System.nanoTime())__			try {_				final long requestId = requestCount.getAndIncrement()__				pendingRequests.put(requestId, requestPromiseTs)___				stats.reportRequest()___				ByteBuf buf = MessageSerializer.serializeRequest(channel.alloc(), requestId, request)___				channel.writeAndFlush(buf).addListener((ChannelFutureListener) future -> {_					if (!future.isSuccess()) {_						_						TimestampedCompletableFuture pending = pendingRequests.remove(requestId)__						if (pending != null && pending.completeExceptionally(future.cause())) {_							stats.reportFailedRequest()__						}_					}_				})___				_				_				_				Throwable failure = failureCause.get()__				if (failure != null) {_					_					_					TimestampedCompletableFuture pending = pendingRequests.remove(requestId)__					if (pending != null && pending.completeExceptionally(failure)) {_						stats.reportFailedRequest()__					}_				}_			} catch (Throwable t) {_				requestPromiseTs.completeExceptionally(t)__			}__			return requestPromiseTs__		};returns,a,future,holding,the,serialized,request,result,param,request,the,request,to,be,sent,return,future,holding,the,serialized,result;completable,future,resp,send,request,req,request,timestamped,completable,future,request,promise,ts,new,timestamped,completable,future,system,nano,time,try,final,long,request,id,request,count,get,and,increment,pending,requests,put,request,id,request,promise,ts,stats,report,request,byte,buf,buf,message,serializer,serialize,request,channel,alloc,request,id,request,channel,write,and,flush,buf,add,listener,channel,future,listener,future,if,future,is,success,timestamped,completable,future,pending,pending,requests,remove,request,id,if,pending,null,pending,complete,exceptionally,future,cause,stats,report,failed,request,throwable,failure,failure,cause,get,if,failure,null,timestamped,completable,future,pending,pending,requests,remove,request,id,if,pending,null,pending,complete,exceptionally,failure,stats,report,failed,request,catch,throwable,t,request,promise,ts,complete,exceptionally,t,return,request,promise,ts
Client -> EstablishedConnection -> CompletableFuture<RESP> sendRequest(REQ request);1510911969;Returns a future holding the serialized request result._@param request the request to be sent._@return Future holding the serialized result;CompletableFuture<RESP> sendRequest(REQ request) {_			TimestampedCompletableFuture requestPromiseTs =_					new TimestampedCompletableFuture(System.nanoTime())__			try {_				final long requestId = requestCount.getAndIncrement()__				pendingRequests.put(requestId, requestPromiseTs)___				stats.reportRequest()___				ByteBuf buf = MessageSerializer.serializeRequest(channel.alloc(), requestId, request)___				channel.writeAndFlush(buf).addListener((ChannelFutureListener) future -> {_					if (!future.isSuccess()) {_						_						TimestampedCompletableFuture pending = pendingRequests.remove(requestId)__						if (pending != null && pending.completeExceptionally(future.cause())) {_							stats.reportFailedRequest()__						}_					}_				})___				_				_				_				Throwable failure = failureCause.get()__				if (failure != null) {_					_					_					TimestampedCompletableFuture pending = pendingRequests.remove(requestId)__					if (pending != null && pending.completeExceptionally(failure)) {_						stats.reportFailedRequest()__					}_				}_			} catch (Throwable t) {_				requestPromiseTs.completeExceptionally(t)__			}__			return requestPromiseTs__		};returns,a,future,holding,the,serialized,request,result,param,request,the,request,to,be,sent,return,future,holding,the,serialized,result;completable,future,resp,send,request,req,request,timestamped,completable,future,request,promise,ts,new,timestamped,completable,future,system,nano,time,try,final,long,request,id,request,count,get,and,increment,pending,requests,put,request,id,request,promise,ts,stats,report,request,byte,buf,buf,message,serializer,serialize,request,channel,alloc,request,id,request,channel,write,and,flush,buf,add,listener,channel,future,listener,future,if,future,is,success,timestamped,completable,future,pending,pending,requests,remove,request,id,if,pending,null,pending,complete,exceptionally,future,cause,stats,report,failed,request,throwable,failure,failure,cause,get,if,failure,null,timestamped,completable,future,pending,pending,requests,remove,request,id,if,pending,null,pending,complete,exceptionally,failure,stats,report,failed,request,catch,throwable,t,request,promise,ts,complete,exceptionally,t,return,request,promise,ts
Client -> EstablishedConnection -> CompletableFuture<RESP> sendRequest(REQ request);1512567196;Returns a future holding the serialized request result._@param request the request to be sent._@return Future holding the serialized result;CompletableFuture<RESP> sendRequest(REQ request) {_			TimestampedCompletableFuture requestPromiseTs =_					new TimestampedCompletableFuture(System.nanoTime())__			try {_				final long requestId = requestCount.getAndIncrement()__				pendingRequests.put(requestId, requestPromiseTs)___				stats.reportRequest()___				ByteBuf buf = MessageSerializer.serializeRequest(channel.alloc(), requestId, request)___				channel.writeAndFlush(buf).addListener((ChannelFutureListener) future -> {_					if (!future.isSuccess()) {_						_						TimestampedCompletableFuture pending = pendingRequests.remove(requestId)__						if (pending != null && pending.completeExceptionally(future.cause())) {_							stats.reportFailedRequest()__						}_					}_				})___				_				_				_				CompletableFuture<Void> clShutdownFuture = clientShutdownFuture.get()__				if (clShutdownFuture != null) {_					TimestampedCompletableFuture pending = pendingRequests.remove(requestId)__					if (pending != null) {_						clShutdownFuture.whenComplete((ignored, throwable) -> {_							if (throwable != null && pending.completeExceptionally(throwable)) {_								stats.reportFailedRequest()__							} else {_								_								_								pending.completeExceptionally(new ClosedChannelException())__							}_						})__					}_				}_			} catch (Throwable t) {_				requestPromiseTs.completeExceptionally(t)__			}__			return requestPromiseTs__		};returns,a,future,holding,the,serialized,request,result,param,request,the,request,to,be,sent,return,future,holding,the,serialized,result;completable,future,resp,send,request,req,request,timestamped,completable,future,request,promise,ts,new,timestamped,completable,future,system,nano,time,try,final,long,request,id,request,count,get,and,increment,pending,requests,put,request,id,request,promise,ts,stats,report,request,byte,buf,buf,message,serializer,serialize,request,channel,alloc,request,id,request,channel,write,and,flush,buf,add,listener,channel,future,listener,future,if,future,is,success,timestamped,completable,future,pending,pending,requests,remove,request,id,if,pending,null,pending,complete,exceptionally,future,cause,stats,report,failed,request,completable,future,void,cl,shutdown,future,client,shutdown,future,get,if,cl,shutdown,future,null,timestamped,completable,future,pending,pending,requests,remove,request,id,if,pending,null,cl,shutdown,future,when,complete,ignored,throwable,if,throwable,null,pending,complete,exceptionally,throwable,stats,report,failed,request,else,pending,complete,exceptionally,new,closed,channel,exception,catch,throwable,t,request,promise,ts,complete,exceptionally,t,return,request,promise,ts
Client -> EstablishedConnection -> CompletableFuture<RESP> sendRequest(REQ request);1522337739;Returns a future holding the serialized request result._@param request the request to be sent._@return Future holding the serialized result;CompletableFuture<RESP> sendRequest(REQ request) {_			TimestampedCompletableFuture requestPromiseTs =_					new TimestampedCompletableFuture(System.nanoTime())__			try {_				final long requestId = requestCount.getAndIncrement()__				pendingRequests.put(requestId, requestPromiseTs)___				stats.reportRequest()___				ByteBuf buf = MessageSerializer.serializeRequest(channel.alloc(), requestId, request)___				channel.writeAndFlush(buf).addListener((ChannelFutureListener) future -> {_					if (!future.isSuccess()) {_						_						TimestampedCompletableFuture pending = pendingRequests.remove(requestId)__						if (pending != null && pending.completeExceptionally(future.cause())) {_							stats.reportFailedRequest()__						}_					}_				})___				_				_				_				CompletableFuture<Void> clShutdownFuture = clientShutdownFuture.get()__				if (clShutdownFuture != null) {_					TimestampedCompletableFuture pending = pendingRequests.remove(requestId)__					if (pending != null) {_						clShutdownFuture.whenComplete((ignored, throwable) -> {_							if (throwable != null && pending.completeExceptionally(throwable)) {_								stats.reportFailedRequest()__							} else {_								_								_								pending.completeExceptionally(new ClosedChannelException())__							}_						})__					}_				}_			} catch (Throwable t) {_				requestPromiseTs.completeExceptionally(t)__			}__			return requestPromiseTs__		};returns,a,future,holding,the,serialized,request,result,param,request,the,request,to,be,sent,return,future,holding,the,serialized,result;completable,future,resp,send,request,req,request,timestamped,completable,future,request,promise,ts,new,timestamped,completable,future,system,nano,time,try,final,long,request,id,request,count,get,and,increment,pending,requests,put,request,id,request,promise,ts,stats,report,request,byte,buf,buf,message,serializer,serialize,request,channel,alloc,request,id,request,channel,write,and,flush,buf,add,listener,channel,future,listener,future,if,future,is,success,timestamped,completable,future,pending,pending,requests,remove,request,id,if,pending,null,pending,complete,exceptionally,future,cause,stats,report,failed,request,completable,future,void,cl,shutdown,future,client,shutdown,future,get,if,cl,shutdown,future,null,timestamped,completable,future,pending,pending,requests,remove,request,id,if,pending,null,cl,shutdown,future,when,complete,ignored,throwable,if,throwable,null,pending,complete,exceptionally,throwable,stats,report,failed,request,else,pending,complete,exceptionally,new,closed,channel,exception,catch,throwable,t,request,promise,ts,complete,exceptionally,t,return,request,promise,ts
Client -> EstablishedConnection -> void close();1509037054;Close the channel with a ClosedChannelException.;void close() {_			close(new ClosedChannelException())__		};close,the,channel,with,a,closed,channel,exception;void,close,close,new,closed,channel,exception
Client -> EstablishedConnection -> void close();1510911969;Close the channel with a ClosedChannelException.;void close() {_			close(new ClosedChannelException())__		};close,the,channel,with,a,closed,channel,exception;void,close,close,new,closed,channel,exception
Client -> EstablishedConnection -> void close();1510911969;Close the channel with a ClosedChannelException.;void close() {_			close(new ClosedChannelException())__		};close,the,channel,with,a,closed,channel,exception;void,close,close,new,closed,channel,exception
Client -> PendingConnection -> private void close();1509037054;Close the connecting channel with a ClosedChannelException.;private void close() {_			close(new ClosedChannelException())__		};close,the,connecting,channel,with,a,closed,channel,exception;private,void,close,close,new,closed,channel,exception
Client -> PendingConnection -> private void close();1510911969;Close the connecting channel with a ClosedChannelException.;private void close() {_			close(new ClosedChannelException())__		};close,the,connecting,channel,with,a,closed,channel,exception;private,void,close,close,new,closed,channel,exception
Client -> PendingConnection -> private void close();1510911969;Close the connecting channel with a ClosedChannelException.;private void close() {_			close(new ClosedChannelException())__		};close,the,connecting,channel,with,a,closed,channel,exception;private,void,close,close,new,closed,channel,exception
Client -> public void shutdown();1509037054;Shuts down the client and closes all connections.__<p>After a call to this method, all returned futures will be failed.;public void shutdown() {_		if (shutDown.compareAndSet(false, true)) {_			for (Map.Entry<InetSocketAddress, EstablishedConnection> conn : establishedConnections.entrySet()) {_				if (establishedConnections.remove(conn.getKey(), conn.getValue())) {_					conn.getValue().close()__				}_			}__			for (Map.Entry<InetSocketAddress, PendingConnection> conn : pendingConnections.entrySet()) {_				if (pendingConnections.remove(conn.getKey()) != null) {_					conn.getValue().close()__				}_			}__			if (bootstrap != null) {_				EventLoopGroup group = bootstrap.group()__				if (group != null) {_					group.shutdownGracefully(0L, 10L, TimeUnit.SECONDS)__				}_			}_		}_	};shuts,down,the,client,and,closes,all,connections,p,after,a,call,to,this,method,all,returned,futures,will,be,failed;public,void,shutdown,if,shut,down,compare,and,set,false,true,for,map,entry,inet,socket,address,established,connection,conn,established,connections,entry,set,if,established,connections,remove,conn,get,key,conn,get,value,conn,get,value,close,for,map,entry,inet,socket,address,pending,connection,conn,pending,connections,entry,set,if,pending,connections,remove,conn,get,key,null,conn,get,value,close,if,bootstrap,null,event,loop,group,group,bootstrap,group,if,group,null,group,shutdown,gracefully,0l,10l,time,unit,seconds
Client -> public void shutdown();1510911969;Shuts down the client and closes all connections.__<p>After a call to this method, all returned futures will be failed.;public void shutdown() {_		if (shutDown.compareAndSet(false, true)) {_			for (Map.Entry<InetSocketAddress, EstablishedConnection> conn : establishedConnections.entrySet()) {_				if (establishedConnections.remove(conn.getKey(), conn.getValue())) {_					conn.getValue().close()__				}_			}__			for (Map.Entry<InetSocketAddress, PendingConnection> conn : pendingConnections.entrySet()) {_				if (pendingConnections.remove(conn.getKey()) != null) {_					conn.getValue().close()__				}_			}__			if (bootstrap != null) {_				EventLoopGroup group = bootstrap.group()__				if (group != null) {_					group.shutdownGracefully(0L, 10L, TimeUnit.SECONDS)__				}_			}_		}_	};shuts,down,the,client,and,closes,all,connections,p,after,a,call,to,this,method,all,returned,futures,will,be,failed;public,void,shutdown,if,shut,down,compare,and,set,false,true,for,map,entry,inet,socket,address,established,connection,conn,established,connections,entry,set,if,established,connections,remove,conn,get,key,conn,get,value,conn,get,value,close,for,map,entry,inet,socket,address,pending,connection,conn,pending,connections,entry,set,if,pending,connections,remove,conn,get,key,null,conn,get,value,close,if,bootstrap,null,event,loop,group,group,bootstrap,group,if,group,null,group,shutdown,gracefully,0l,10l,time,unit,seconds
Client -> public void shutdown();1510911969;Shuts down the client and closes all connections.__<p>After a call to this method, all returned futures will be failed.;public void shutdown() {_		if (shutDown.compareAndSet(false, true)) {_			for (Map.Entry<InetSocketAddress, EstablishedConnection> conn : establishedConnections.entrySet()) {_				if (establishedConnections.remove(conn.getKey(), conn.getValue())) {_					conn.getValue().close()__				}_			}__			for (Map.Entry<InetSocketAddress, PendingConnection> conn : pendingConnections.entrySet()) {_				if (pendingConnections.remove(conn.getKey()) != null) {_					conn.getValue().close()__				}_			}__			if (bootstrap != null) {_				EventLoopGroup group = bootstrap.group()__				if (group != null) {_					group.shutdownGracefully(0L, 10L, TimeUnit.SECONDS)__				}_			}_		}_	};shuts,down,the,client,and,closes,all,connections,p,after,a,call,to,this,method,all,returned,futures,will,be,failed;public,void,shutdown,if,shut,down,compare,and,set,false,true,for,map,entry,inet,socket,address,established,connection,conn,established,connections,entry,set,if,established,connections,remove,conn,get,key,conn,get,value,conn,get,value,close,for,map,entry,inet,socket,address,pending,connection,conn,pending,connections,entry,set,if,pending,connections,remove,conn,get,key,null,conn,get,value,close,if,bootstrap,null,event,loop,group,group,bootstrap,group,if,group,null,group,shutdown,gracefully,0l,10l,time,unit,seconds
Client -> PendingConnection -> private void close(Throwable cause);1509037054;Close the connecting channel with an Exception (can be {@code null})_or forward to the established channel.;private void close(Throwable cause) {_			synchronized (connectLock) {_				if (!closed) {_					if (failureCause == null) {_						failureCause = cause__					}__					if (established != null) {_						established.close()__					} else {_						PendingRequest pending__						while ((pending = queuedRequests.poll()) != null) {_							pending.completeExceptionally(cause)__						}_					}_					closed = true__				}_			}_		};close,the,connecting,channel,with,an,exception,can,be,code,null,or,forward,to,the,established,channel;private,void,close,throwable,cause,synchronized,connect,lock,if,closed,if,failure,cause,null,failure,cause,cause,if,established,null,established,close,else,pending,request,pending,while,pending,queued,requests,poll,null,pending,complete,exceptionally,cause,closed,true
Client -> PendingConnection -> private void close(Throwable cause);1510911969;Close the connecting channel with an Exception (can be {@code null})_or forward to the established channel.;private void close(Throwable cause) {_			synchronized (connectLock) {_				if (!closed) {_					if (failureCause == null) {_						failureCause = cause__					}__					if (established != null) {_						established.close()__					} else {_						PendingRequest pending__						while ((pending = queuedRequests.poll()) != null) {_							pending.completeExceptionally(cause)__						}_					}_					closed = true__				}_			}_		};close,the,connecting,channel,with,an,exception,can,be,code,null,or,forward,to,the,established,channel;private,void,close,throwable,cause,synchronized,connect,lock,if,closed,if,failure,cause,null,failure,cause,cause,if,established,null,established,close,else,pending,request,pending,while,pending,queued,requests,poll,null,pending,complete,exceptionally,cause,closed,true
Client -> PendingConnection -> private void close(Throwable cause);1510911969;Close the connecting channel with an Exception (can be {@code null})_or forward to the established channel.;private void close(Throwable cause) {_			synchronized (connectLock) {_				if (!closed) {_					if (failureCause == null) {_						failureCause = cause__					}__					if (established != null) {_						established.close()__					} else {_						PendingRequest pending__						while ((pending = queuedRequests.poll()) != null) {_							pending.completeExceptionally(cause)__						}_					}_					closed = true__				}_			}_		};close,the,connecting,channel,with,an,exception,can,be,code,null,or,forward,to,the,established,channel;private,void,close,throwable,cause,synchronized,connect,lock,if,closed,if,failure,cause,null,failure,cause,cause,if,established,null,established,close,else,pending,request,pending,while,pending,queued,requests,poll,null,pending,complete,exceptionally,cause,closed,true
Client -> PendingConnection -> private CompletableFuture<Void> close();1512567196;Close the connecting channel with a ClosedChannelException.;private CompletableFuture<Void> close() {_			return close(new ClosedChannelException())__		};close,the,connecting,channel,with,a,closed,channel,exception;private,completable,future,void,close,return,close,new,closed,channel,exception
Client -> PendingConnection -> private CompletableFuture<Void> close();1522337739;Close the connecting channel with a ClosedChannelException.;private CompletableFuture<Void> close() {_			return close(new ClosedChannelException())__		};close,the,connecting,channel,with,a,closed,channel,exception;private,completable,future,void,close,return,close,new,closed,channel,exception
Client -> EstablishedConnection -> private CompletableFuture<Void> close(final Throwable cause);1512567196;Close the channel with a cause.__@param cause The cause to close the channel with._@return Channel close future;private CompletableFuture<Void> close(final Throwable cause) {_			final CompletableFuture<Void> shutdownFuture = new CompletableFuture<>()___			if (connectionShutdownFuture.compareAndSet(null, shutdownFuture)) {_				channel.close().addListener(finished -> {_					stats.reportInactiveConnection()__					for (long requestId : pendingRequests.keySet()) {_						TimestampedCompletableFuture pending = pendingRequests.remove(requestId)__						if (pending != null && pending.completeExceptionally(cause)) {_							stats.reportFailedRequest()__						}_					}__					_					_					_					if (finished.isSuccess()) {_						shutdownFuture.completeExceptionally(cause)__					} else {_						LOG.warn("Something went wrong when trying to close connection due to : ", cause)__						shutdownFuture.completeExceptionally(finished.cause())__					}_				})__			}__			_			return connectionShutdownFuture.get()__		};close,the,channel,with,a,cause,param,cause,the,cause,to,close,the,channel,with,return,channel,close,future;private,completable,future,void,close,final,throwable,cause,final,completable,future,void,shutdown,future,new,completable,future,if,connection,shutdown,future,compare,and,set,null,shutdown,future,channel,close,add,listener,finished,stats,report,inactive,connection,for,long,request,id,pending,requests,key,set,timestamped,completable,future,pending,pending,requests,remove,request,id,if,pending,null,pending,complete,exceptionally,cause,stats,report,failed,request,if,finished,is,success,shutdown,future,complete,exceptionally,cause,else,log,warn,something,went,wrong,when,trying,to,close,connection,due,to,cause,shutdown,future,complete,exceptionally,finished,cause,return,connection,shutdown,future,get
Client -> EstablishedConnection -> private CompletableFuture<Void> close(final Throwable cause);1522337739;Close the channel with a cause.__@param cause The cause to close the channel with._@return Channel close future;private CompletableFuture<Void> close(final Throwable cause) {_			final CompletableFuture<Void> shutdownFuture = new CompletableFuture<>()___			if (connectionShutdownFuture.compareAndSet(null, shutdownFuture)) {_				channel.close().addListener(finished -> {_					stats.reportInactiveConnection()__					for (long requestId : pendingRequests.keySet()) {_						TimestampedCompletableFuture pending = pendingRequests.remove(requestId)__						if (pending != null && pending.completeExceptionally(cause)) {_							stats.reportFailedRequest()__						}_					}__					_					_					_					if (finished.isSuccess()) {_						shutdownFuture.completeExceptionally(cause)__					} else {_						LOG.warn("Something went wrong when trying to close connection due to : ", cause)__						shutdownFuture.completeExceptionally(finished.cause())__					}_				})__			}__			_			return connectionShutdownFuture.get()__		};close,the,channel,with,a,cause,param,cause,the,cause,to,close,the,channel,with,return,channel,close,future;private,completable,future,void,close,final,throwable,cause,final,completable,future,void,shutdown,future,new,completable,future,if,connection,shutdown,future,compare,and,set,null,shutdown,future,channel,close,add,listener,finished,stats,report,inactive,connection,for,long,request,id,pending,requests,key,set,timestamped,completable,future,pending,pending,requests,remove,request,id,if,pending,null,pending,complete,exceptionally,cause,stats,report,failed,request,if,finished,is,success,shutdown,future,complete,exceptionally,cause,else,log,warn,something,went,wrong,when,trying,to,close,connection,due,to,cause,shutdown,future,complete,exceptionally,finished,cause,return,connection,shutdown,future,get
Client -> PendingConnection -> private void handInChannel(Channel channel);1509037054;Hands in a channel after a successful connection.__@param channel Channel to hand in;private void handInChannel(Channel channel) {_			synchronized (connectLock) {_				if (closed || failureCause != null) {_					_					_					_					channel.close()__				} else {_					established = new EstablishedConnection(serverAddress, serializer, channel)___					while (!queuedRequests.isEmpty()) {_						final PendingRequest pending = queuedRequests.poll()___						established.sendRequest(pending.request)_								.thenAccept(resp -> pending.complete(resp))_								.exceptionally(throwable -> {_									pending.completeExceptionally(throwable)__									return null__						})__					}__					_					establishedConnections.put(serverAddress, established)__					pendingConnections.remove(serverAddress)___					_					_					_					if (shutDown.get()) {_						if (establishedConnections.remove(serverAddress, established)) {_							established.close()__						}_					}_				}_			}_		};hands,in,a,channel,after,a,successful,connection,param,channel,channel,to,hand,in;private,void,hand,in,channel,channel,channel,synchronized,connect,lock,if,closed,failure,cause,null,channel,close,else,established,new,established,connection,server,address,serializer,channel,while,queued,requests,is,empty,final,pending,request,pending,queued,requests,poll,established,send,request,pending,request,then,accept,resp,pending,complete,resp,exceptionally,throwable,pending,complete,exceptionally,throwable,return,null,established,connections,put,server,address,established,pending,connections,remove,server,address,if,shut,down,get,if,established,connections,remove,server,address,established,established,close
Client -> PendingConnection -> private void handInChannel(Channel channel);1510911969;Hands in a channel after a successful connection.__@param channel Channel to hand in;private void handInChannel(Channel channel) {_			synchronized (connectLock) {_				if (closed || failureCause != null) {_					_					_					_					channel.close()__				} else {_					established = new EstablishedConnection(serverAddress, serializer, channel)___					while (!queuedRequests.isEmpty()) {_						final PendingRequest pending = queuedRequests.poll()___						established.sendRequest(pending.request)_								.thenAccept(resp -> pending.complete(resp))_								.exceptionally(throwable -> {_									pending.completeExceptionally(throwable)__									return null__						})__					}__					_					establishedConnections.put(serverAddress, established)__					pendingConnections.remove(serverAddress)___					_					_					_					if (shutDown.get()) {_						if (establishedConnections.remove(serverAddress, established)) {_							established.close()__						}_					}_				}_			}_		};hands,in,a,channel,after,a,successful,connection,param,channel,channel,to,hand,in;private,void,hand,in,channel,channel,channel,synchronized,connect,lock,if,closed,failure,cause,null,channel,close,else,established,new,established,connection,server,address,serializer,channel,while,queued,requests,is,empty,final,pending,request,pending,queued,requests,poll,established,send,request,pending,request,then,accept,resp,pending,complete,resp,exceptionally,throwable,pending,complete,exceptionally,throwable,return,null,established,connections,put,server,address,established,pending,connections,remove,server,address,if,shut,down,get,if,established,connections,remove,server,address,established,established,close
Client -> PendingConnection -> private void handInChannel(Channel channel);1510911969;Hands in a channel after a successful connection.__@param channel Channel to hand in;private void handInChannel(Channel channel) {_			synchronized (connectLock) {_				if (closed || failureCause != null) {_					_					_					_					channel.close()__				} else {_					established = new EstablishedConnection(serverAddress, serializer, channel)___					while (!queuedRequests.isEmpty()) {_						final PendingRequest pending = queuedRequests.poll()___						established.sendRequest(pending.request).whenComplete(_								(response, throwable) -> {_									if (throwable != null) {_										pending.completeExceptionally(throwable)__									} else {_										pending.complete(response)__									}_								})__					}__					_					establishedConnections.put(serverAddress, established)__					pendingConnections.remove(serverAddress)___					_					_					_					if (shutDown.get()) {_						if (establishedConnections.remove(serverAddress, established)) {_							established.close()__						}_					}_				}_			}_		};hands,in,a,channel,after,a,successful,connection,param,channel,channel,to,hand,in;private,void,hand,in,channel,channel,channel,synchronized,connect,lock,if,closed,failure,cause,null,channel,close,else,established,new,established,connection,server,address,serializer,channel,while,queued,requests,is,empty,final,pending,request,pending,queued,requests,poll,established,send,request,pending,request,when,complete,response,throwable,if,throwable,null,pending,complete,exceptionally,throwable,else,pending,complete,response,established,connections,put,server,address,established,pending,connections,remove,server,address,if,shut,down,get,if,established,connections,remove,server,address,established,established,close
Client -> PendingConnection -> private void handInChannel(Channel channel);1512567196;Hands in a channel after a successful connection.__@param channel Channel to hand in;private void handInChannel(Channel channel) {_			synchronized (connectLock) {_				if (connectionShutdownFuture.get() != null || failureCause != null) {_					_					_					_					channel.close()__				} else {_					established = new EstablishedConnection(serverAddress, serializer, channel)___					while (!queuedRequests.isEmpty()) {_						final PendingRequest pending = queuedRequests.poll()___						established.sendRequest(pending.request).whenComplete(_								(response, throwable) -> {_									if (throwable != null) {_										pending.completeExceptionally(throwable)__									} else {_										pending.complete(response)__									}_								})__					}__					_					establishedConnections.put(serverAddress, established)__					pendingConnections.remove(serverAddress)___					_					_					_					if (clientShutdownFuture.get() != null) {_						if (establishedConnections.remove(serverAddress, established)) {_							established.close()__						}_					}_				}_			}_		};hands,in,a,channel,after,a,successful,connection,param,channel,channel,to,hand,in;private,void,hand,in,channel,channel,channel,synchronized,connect,lock,if,connection,shutdown,future,get,null,failure,cause,null,channel,close,else,established,new,established,connection,server,address,serializer,channel,while,queued,requests,is,empty,final,pending,request,pending,queued,requests,poll,established,send,request,pending,request,when,complete,response,throwable,if,throwable,null,pending,complete,exceptionally,throwable,else,pending,complete,response,established,connections,put,server,address,established,pending,connections,remove,server,address,if,client,shutdown,future,get,null,if,established,connections,remove,server,address,established,established,close
Client -> PendingConnection -> private void handInChannel(Channel channel);1522337739;Hands in a channel after a successful connection.__@param channel Channel to hand in;private void handInChannel(Channel channel) {_			synchronized (connectLock) {_				if (connectionShutdownFuture.get() != null || failureCause != null) {_					_					_					_					channel.close()__				} else {_					established = new EstablishedConnection(serverAddress, serializer, channel)___					while (!queuedRequests.isEmpty()) {_						final PendingRequest pending = queuedRequests.poll()___						established.sendRequest(pending.request).whenComplete(_								(response, throwable) -> {_									if (throwable != null) {_										pending.completeExceptionally(throwable)__									} else {_										pending.complete(response)__									}_								})__					}__					_					establishedConnections.put(serverAddress, established)__					pendingConnections.remove(serverAddress)___					_					_					_					if (clientShutdownFuture.get() != null) {_						if (establishedConnections.remove(serverAddress, established)) {_							established.close()__						}_					}_				}_			}_		};hands,in,a,channel,after,a,successful,connection,param,channel,channel,to,hand,in;private,void,hand,in,channel,channel,channel,synchronized,connect,lock,if,connection,shutdown,future,get,null,failure,cause,null,channel,close,else,established,new,established,connection,server,address,serializer,channel,while,queued,requests,is,empty,final,pending,request,pending,queued,requests,poll,established,send,request,pending,request,when,complete,response,throwable,if,throwable,null,pending,complete,exceptionally,throwable,else,pending,complete,response,established,connections,put,server,address,established,pending,connections,remove,server,address,if,client,shutdown,future,get,null,if,established,connections,remove,server,address,established,established,close
