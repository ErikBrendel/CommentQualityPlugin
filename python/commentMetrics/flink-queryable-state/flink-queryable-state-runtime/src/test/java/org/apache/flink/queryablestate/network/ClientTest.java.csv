# id;timestamp;commentText;codeText;commentWords;codeWords
ClientTest -> @Test 	public void testRequestUnavailableHost() throws Exception;1509037054;Tests that a request to an unavailable host is failed with ConnectException.;@Test_	public void testRequestUnavailableHost() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null___		try {_			client = new Client<>("Test Client", 1, serializer, stats)___			int availablePort = NetUtils.getAvailablePort()___			InetSocketAddress serverAddress = new InetSocketAddress(_					InetAddress.getLocalHost(),_					availablePort)___			KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])__			CompletableFuture<KvStateResponse> future = client.sendRequest(serverAddress, request)___			try {_				future.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				fail("Did not throw expected ConnectException")__			} catch (ExecutionException e) {_				if (!(e.getCause() instanceof ConnectException)) {_					fail("Did not throw expected ConnectException")__				}_				_			}_		} finally {_			if (client != null) {_				client.shutdown()__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};tests,that,a,request,to,an,unavailable,host,is,failed,with,connect,exception;test,public,void,test,request,unavailable,host,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,try,client,new,client,test,client,1,serializer,stats,int,available,port,net,utils,get,available,port,inet,socket,address,server,address,new,inet,socket,address,inet,address,get,local,host,available,port,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,completable,future,kv,state,response,future,client,send,request,server,address,request,try,future,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,connect,exception,catch,execution,exception,e,if,e,get,cause,instanceof,connect,exception,fail,did,not,throw,expected,connect,exception,finally,if,client,null,client,shutdown,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testRequestUnavailableHost() throws Exception;1512567196;Tests that a request to an unavailable host is failed with ConnectException.;@Test_	public void testRequestUnavailableHost() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null___		try {_			client = new Client<>("Test Client", 1, serializer, stats)___			int availablePort = NetUtils.getAvailablePort()___			InetSocketAddress serverAddress = new InetSocketAddress(_					InetAddress.getLocalHost(),_					availablePort)___			KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])__			CompletableFuture<KvStateResponse> future = client.sendRequest(serverAddress, request)___			try {_				future.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				fail("Did not throw expected ConnectException")__			} catch (ExecutionException e) {_				if (!(e.getCause() instanceof ConnectException)) {_					fail("Did not throw expected ConnectException")__				}_				_			}_		} finally {_			if (client != null) {_				try {_					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					e.printStackTrace()__				}_				Assert.assertTrue(client.isEventGroupShutdown())__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};tests,that,a,request,to,an,unavailable,host,is,failed,with,connect,exception;test,public,void,test,request,unavailable,host,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,try,client,new,client,test,client,1,serializer,stats,int,available,port,net,utils,get,available,port,inet,socket,address,server,address,new,inet,socket,address,inet,address,get,local,host,available,port,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,completable,future,kv,state,response,future,client,send,request,server,address,request,try,future,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,connect,exception,catch,execution,exception,e,if,e,get,cause,instanceof,connect,exception,fail,did,not,throw,expected,connect,exception,finally,if,client,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testRequestUnavailableHost() throws Exception;1519897473;Tests that a request to an unavailable host is failed with ConnectException.;@Test_	public void testRequestUnavailableHost() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null___		try {_			client = new Client<>("Test Client", 1, serializer, stats)___			int availablePort = NetUtils.getAvailablePort()___			InetSocketAddress serverAddress = new InetSocketAddress(_					InetAddress.getLocalHost(),_					availablePort)___			KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])__			CompletableFuture<KvStateResponse> future = client.sendRequest(serverAddress, request)___			try {_				future.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				fail("Did not throw expected ConnectException")__			} catch (ExecutionException e) {_				if (!(e.getCause() instanceof ConnectException)) {_					fail("Did not throw expected ConnectException")__				}_				_			}_		} finally {_			if (client != null) {_				try {_					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					e.printStackTrace()__				}_				Assert.assertTrue(client.isEventGroupShutdown())__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};tests,that,a,request,to,an,unavailable,host,is,failed,with,connect,exception;test,public,void,test,request,unavailable,host,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,try,client,new,client,test,client,1,serializer,stats,int,available,port,net,utils,get,available,port,inet,socket,address,server,address,new,inet,socket,address,inet,address,get,local,host,available,port,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,completable,future,kv,state,response,future,client,send,request,server,address,request,try,future,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,connect,exception,catch,execution,exception,e,if,e,get,cause,instanceof,connect,exception,fail,did,not,throw,expected,connect,exception,finally,if,client,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testRequestUnavailableHost() throws Exception;1522337739;Tests that a request to an unavailable host is failed with ConnectException.;@Test_	public void testRequestUnavailableHost() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null___		try {_			client = new Client<>("Test Client", 1, serializer, stats)___			int availablePort = NetUtils.getAvailablePort()___			InetSocketAddress serverAddress = new InetSocketAddress(_					InetAddress.getLocalHost(),_					availablePort)___			KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])__			CompletableFuture<KvStateResponse> future = client.sendRequest(serverAddress, request)___			try {_				future.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				fail("Did not throw expected ConnectException")__			} catch (ExecutionException e) {_				if (!(e.getCause() instanceof ConnectException)) {_					fail("Did not throw expected ConnectException")__				}_				_			}_		} finally {_			if (client != null) {_				try {_					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					e.printStackTrace()__				}_				Assert.assertTrue(client.isEventGroupShutdown())__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};tests,that,a,request,to,an,unavailable,host,is,failed,with,connect,exception;test,public,void,test,request,unavailable,host,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,try,client,new,client,test,client,1,serializer,stats,int,available,port,net,utils,get,available,port,inet,socket,address,server,address,new,inet,socket,address,inet,address,get,local,host,available,port,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,completable,future,kv,state,response,future,client,send,request,server,address,request,try,future,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,connect,exception,catch,execution,exception,e,if,e,get,cause,instanceof,connect,exception,fail,did,not,throw,expected,connect,exception,finally,if,client,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testFailureClosesChannel() throws Exception;1509037054;Tests that a server failure closes the connection and removes it from_the established connections.;@Test_	public void testFailureClosesChannel() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null__		Channel serverChannel = null___		try {_			client = new Client<>("Test Client", 1, serializer, stats)___			final LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>()__			final AtomicReference<Channel> channel = new AtomicReference<>()___			serverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {_				@Override_				public void channelActive(ChannelHandlerContext ctx) throws Exception {_					channel.set(ctx.channel())__				}__				@Override_				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {_					received.add((ByteBuf) msg)__				}_			})___			InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel)___			_			List<Future<KvStateResponse>> futures = new ArrayList<>()__			KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])___			futures.add(client.sendRequest(serverAddress, request))__			futures.add(client.sendRequest(serverAddress, request))___			ByteBuf buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__			assertNotNull("Receive timed out", buf)__			buf.release()___			buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__			assertNotNull("Receive timed out", buf)__			buf.release()___			assertEquals(1L, stats.getNumConnections())___			Channel ch = channel.get()__			assertNotNull("Channel not active", ch)___			_			ch.writeAndFlush(MessageSerializer.serializeServerFailure(_					serverChannel.alloc(),_					new RuntimeException("Expected test server failure")))___			try {_				futures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				fail("Did not throw expected server failure")__			} catch (ExecutionException e) {__				if (!(e.getCause() instanceof RuntimeException)) {_					fail("Did not throw expected Exception")__				}_				_			}__			try {_				futures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				fail("Did not throw expected server failure")__			} catch (ExecutionException e) {__				if (!(e.getCause() instanceof RuntimeException)) {_					fail("Did not throw expected Exception")__				}_				_			}__			assertEquals(0L, stats.getNumConnections())___			_			while (deadline.hasTimeLeft() && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 2L)) {_				Thread.sleep(100L)__			}__			assertEquals(2L, stats.getNumRequests())__			assertEquals(0L, stats.getNumSuccessful())__			assertEquals(2L, stats.getNumFailed())__		} finally {_			if (client != null) {_				client.shutdown()__			}__			if (serverChannel != null) {_				serverChannel.close()__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};tests,that,a,server,failure,closes,the,connection,and,removes,it,from,the,established,connections;test,public,void,test,failure,closes,channel,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,final,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,channel,server,channel,null,try,client,new,client,test,client,1,serializer,stats,final,linked,blocking,queue,byte,buf,received,new,linked,blocking,queue,final,atomic,reference,channel,channel,new,atomic,reference,server,channel,create,server,channel,new,channel,inbound,handler,adapter,override,public,void,channel,active,channel,handler,context,ctx,throws,exception,channel,set,ctx,channel,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,received,add,byte,buf,msg,inet,socket,address,server,address,get,kv,state,server,address,server,channel,list,future,kv,state,response,futures,new,array,list,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,futures,add,client,send,request,server,address,request,futures,add,client,send,request,server,address,request,byte,buf,buf,received,poll,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,receive,timed,out,buf,buf,release,buf,received,poll,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,receive,timed,out,buf,buf,release,assert,equals,1l,stats,get,num,connections,channel,ch,channel,get,assert,not,null,channel,not,active,ch,ch,write,and,flush,message,serializer,serialize,server,failure,server,channel,alloc,new,runtime,exception,expected,test,server,failure,try,futures,remove,0,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,server,failure,catch,execution,exception,e,if,e,get,cause,instanceof,runtime,exception,fail,did,not,throw,expected,exception,try,futures,remove,0,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,server,failure,catch,execution,exception,e,if,e,get,cause,instanceof,runtime,exception,fail,did,not,throw,expected,exception,assert,equals,0l,stats,get,num,connections,while,deadline,has,time,left,stats,get,num,successful,0l,stats,get,num,failed,2l,thread,sleep,100l,assert,equals,2l,stats,get,num,requests,assert,equals,0l,stats,get,num,successful,assert,equals,2l,stats,get,num,failed,finally,if,client,null,client,shutdown,if,server,channel,null,server,channel,close,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testFailureClosesChannel() throws Exception;1512567196;Tests that a server failure closes the connection and removes it from_the established connections.;@Test_	public void testFailureClosesChannel() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null__		Channel serverChannel = null___		try {_			client = new Client<>("Test Client", 1, serializer, stats)___			final LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>()__			final AtomicReference<Channel> channel = new AtomicReference<>()___			serverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {_				@Override_				public void channelActive(ChannelHandlerContext ctx) throws Exception {_					channel.set(ctx.channel())__				}__				@Override_				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {_					received.add((ByteBuf) msg)__				}_			})___			InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel)___			_			List<Future<KvStateResponse>> futures = new ArrayList<>()__			KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])___			futures.add(client.sendRequest(serverAddress, request))__			futures.add(client.sendRequest(serverAddress, request))___			ByteBuf buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__			assertNotNull("Receive timed out", buf)__			buf.release()___			buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__			assertNotNull("Receive timed out", buf)__			buf.release()___			assertEquals(1L, stats.getNumConnections())___			Channel ch = channel.get()__			assertNotNull("Channel not active", ch)___			_			ch.writeAndFlush(MessageSerializer.serializeServerFailure(_					serverChannel.alloc(),_					new RuntimeException("Expected test server failure")))___			try {_				futures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				fail("Did not throw expected server failure")__			} catch (ExecutionException e) {__				if (!(e.getCause() instanceof RuntimeException)) {_					fail("Did not throw expected Exception")__				}_				_			}__			try {_				futures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				fail("Did not throw expected server failure")__			} catch (ExecutionException e) {__				if (!(e.getCause() instanceof RuntimeException)) {_					fail("Did not throw expected Exception")__				}_				_			}__			assertEquals(0L, stats.getNumConnections())___			_			while (deadline.hasTimeLeft() && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 2L)) {_				Thread.sleep(100L)__			}__			assertEquals(2L, stats.getNumRequests())__			assertEquals(0L, stats.getNumSuccessful())__			assertEquals(2L, stats.getNumFailed())__		} finally {_			if (client != null) {_				try {_					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					e.printStackTrace()__				}_				Assert.assertTrue(client.isEventGroupShutdown())__			}__			if (serverChannel != null) {_				serverChannel.close()__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};tests,that,a,server,failure,closes,the,connection,and,removes,it,from,the,established,connections;test,public,void,test,failure,closes,channel,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,final,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,channel,server,channel,null,try,client,new,client,test,client,1,serializer,stats,final,linked,blocking,queue,byte,buf,received,new,linked,blocking,queue,final,atomic,reference,channel,channel,new,atomic,reference,server,channel,create,server,channel,new,channel,inbound,handler,adapter,override,public,void,channel,active,channel,handler,context,ctx,throws,exception,channel,set,ctx,channel,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,received,add,byte,buf,msg,inet,socket,address,server,address,get,kv,state,server,address,server,channel,list,future,kv,state,response,futures,new,array,list,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,futures,add,client,send,request,server,address,request,futures,add,client,send,request,server,address,request,byte,buf,buf,received,poll,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,receive,timed,out,buf,buf,release,buf,received,poll,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,receive,timed,out,buf,buf,release,assert,equals,1l,stats,get,num,connections,channel,ch,channel,get,assert,not,null,channel,not,active,ch,ch,write,and,flush,message,serializer,serialize,server,failure,server,channel,alloc,new,runtime,exception,expected,test,server,failure,try,futures,remove,0,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,server,failure,catch,execution,exception,e,if,e,get,cause,instanceof,runtime,exception,fail,did,not,throw,expected,exception,try,futures,remove,0,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,server,failure,catch,execution,exception,e,if,e,get,cause,instanceof,runtime,exception,fail,did,not,throw,expected,exception,assert,equals,0l,stats,get,num,connections,while,deadline,has,time,left,stats,get,num,successful,0l,stats,get,num,failed,2l,thread,sleep,100l,assert,equals,2l,stats,get,num,requests,assert,equals,0l,stats,get,num,successful,assert,equals,2l,stats,get,num,failed,finally,if,client,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,if,server,channel,null,server,channel,close,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testFailureClosesChannel() throws Exception;1519897473;Tests that a server failure closes the connection and removes it from_the established connections.;@Test_	public void testFailureClosesChannel() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null__		Channel serverChannel = null___		try {_			client = new Client<>("Test Client", 1, serializer, stats)___			final LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>()__			final AtomicReference<Channel> channel = new AtomicReference<>()___			serverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {_				@Override_				public void channelActive(ChannelHandlerContext ctx) throws Exception {_					channel.set(ctx.channel())__				}__				@Override_				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {_					received.add((ByteBuf) msg)__				}_			})___			InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel)___			_			List<Future<KvStateResponse>> futures = new ArrayList<>()__			KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])___			futures.add(client.sendRequest(serverAddress, request))__			futures.add(client.sendRequest(serverAddress, request))___			ByteBuf buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__			assertNotNull("Receive timed out", buf)__			buf.release()___			buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__			assertNotNull("Receive timed out", buf)__			buf.release()___			assertEquals(1L, stats.getNumConnections())___			Channel ch = channel.get()__			assertNotNull("Channel not active", ch)___			_			ch.writeAndFlush(MessageSerializer.serializeServerFailure(_					serverChannel.alloc(),_					new RuntimeException("Expected test server failure")))___			try {_				futures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				fail("Did not throw expected server failure")__			} catch (ExecutionException e) {__				if (!(e.getCause() instanceof RuntimeException)) {_					fail("Did not throw expected Exception")__				}_				_			}__			try {_				futures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				fail("Did not throw expected server failure")__			} catch (ExecutionException e) {__				if (!(e.getCause() instanceof RuntimeException)) {_					fail("Did not throw expected Exception")__				}_				_			}__			assertEquals(0L, stats.getNumConnections())___			_			while (deadline.hasTimeLeft() && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 2L)) {_				Thread.sleep(100L)__			}__			assertEquals(2L, stats.getNumRequests())__			assertEquals(0L, stats.getNumSuccessful())__			assertEquals(2L, stats.getNumFailed())__		} finally {_			if (client != null) {_				try {_					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					e.printStackTrace()__				}_				Assert.assertTrue(client.isEventGroupShutdown())__			}__			if (serverChannel != null) {_				serverChannel.close()__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};tests,that,a,server,failure,closes,the,connection,and,removes,it,from,the,established,connections;test,public,void,test,failure,closes,channel,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,final,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,channel,server,channel,null,try,client,new,client,test,client,1,serializer,stats,final,linked,blocking,queue,byte,buf,received,new,linked,blocking,queue,final,atomic,reference,channel,channel,new,atomic,reference,server,channel,create,server,channel,new,channel,inbound,handler,adapter,override,public,void,channel,active,channel,handler,context,ctx,throws,exception,channel,set,ctx,channel,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,received,add,byte,buf,msg,inet,socket,address,server,address,get,kv,state,server,address,server,channel,list,future,kv,state,response,futures,new,array,list,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,futures,add,client,send,request,server,address,request,futures,add,client,send,request,server,address,request,byte,buf,buf,received,poll,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,receive,timed,out,buf,buf,release,buf,received,poll,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,receive,timed,out,buf,buf,release,assert,equals,1l,stats,get,num,connections,channel,ch,channel,get,assert,not,null,channel,not,active,ch,ch,write,and,flush,message,serializer,serialize,server,failure,server,channel,alloc,new,runtime,exception,expected,test,server,failure,try,futures,remove,0,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,server,failure,catch,execution,exception,e,if,e,get,cause,instanceof,runtime,exception,fail,did,not,throw,expected,exception,try,futures,remove,0,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,server,failure,catch,execution,exception,e,if,e,get,cause,instanceof,runtime,exception,fail,did,not,throw,expected,exception,assert,equals,0l,stats,get,num,connections,while,deadline,has,time,left,stats,get,num,successful,0l,stats,get,num,failed,2l,thread,sleep,100l,assert,equals,2l,stats,get,num,requests,assert,equals,0l,stats,get,num,successful,assert,equals,2l,stats,get,num,failed,finally,if,client,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,if,server,channel,null,server,channel,close,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testFailureClosesChannel() throws Exception;1522337739;Tests that a server failure closes the connection and removes it from_the established connections.;@Test_	public void testFailureClosesChannel() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null__		Channel serverChannel = null___		try {_			client = new Client<>("Test Client", 1, serializer, stats)___			final LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>()__			final AtomicReference<Channel> channel = new AtomicReference<>()___			serverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {_				@Override_				public void channelActive(ChannelHandlerContext ctx) throws Exception {_					channel.set(ctx.channel())__				}__				@Override_				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {_					received.add((ByteBuf) msg)__				}_			})___			InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel)___			_			List<Future<KvStateResponse>> futures = new ArrayList<>()__			KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])___			futures.add(client.sendRequest(serverAddress, request))__			futures.add(client.sendRequest(serverAddress, request))___			ByteBuf buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__			assertNotNull("Receive timed out", buf)__			buf.release()___			buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__			assertNotNull("Receive timed out", buf)__			buf.release()___			assertEquals(1L, stats.getNumConnections())___			Channel ch = channel.get()__			assertNotNull("Channel not active", ch)___			_			ch.writeAndFlush(MessageSerializer.serializeServerFailure(_					serverChannel.alloc(),_					new RuntimeException("Expected test server failure")))___			try {_				futures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				fail("Did not throw expected server failure")__			} catch (ExecutionException e) {__				if (!(e.getCause() instanceof RuntimeException)) {_					fail("Did not throw expected Exception")__				}_				_			}__			try {_				futures.remove(0).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				fail("Did not throw expected server failure")__			} catch (ExecutionException e) {__				if (!(e.getCause() instanceof RuntimeException)) {_					fail("Did not throw expected Exception")__				}_				_			}__			assertEquals(0L, stats.getNumConnections())___			_			while (deadline.hasTimeLeft() && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 2L)) {_				Thread.sleep(100L)__			}__			assertEquals(2L, stats.getNumRequests())__			assertEquals(0L, stats.getNumSuccessful())__			assertEquals(2L, stats.getNumFailed())__		} finally {_			if (client != null) {_				try {_					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					e.printStackTrace()__				}_				Assert.assertTrue(client.isEventGroupShutdown())__			}__			if (serverChannel != null) {_				serverChannel.close()__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};tests,that,a,server,failure,closes,the,connection,and,removes,it,from,the,established,connections;test,public,void,test,failure,closes,channel,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,final,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,channel,server,channel,null,try,client,new,client,test,client,1,serializer,stats,final,linked,blocking,queue,byte,buf,received,new,linked,blocking,queue,final,atomic,reference,channel,channel,new,atomic,reference,server,channel,create,server,channel,new,channel,inbound,handler,adapter,override,public,void,channel,active,channel,handler,context,ctx,throws,exception,channel,set,ctx,channel,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,received,add,byte,buf,msg,inet,socket,address,server,address,get,kv,state,server,address,server,channel,list,future,kv,state,response,futures,new,array,list,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,futures,add,client,send,request,server,address,request,futures,add,client,send,request,server,address,request,byte,buf,buf,received,poll,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,receive,timed,out,buf,buf,release,buf,received,poll,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,receive,timed,out,buf,buf,release,assert,equals,1l,stats,get,num,connections,channel,ch,channel,get,assert,not,null,channel,not,active,ch,ch,write,and,flush,message,serializer,serialize,server,failure,server,channel,alloc,new,runtime,exception,expected,test,server,failure,try,futures,remove,0,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,server,failure,catch,execution,exception,e,if,e,get,cause,instanceof,runtime,exception,fail,did,not,throw,expected,exception,try,futures,remove,0,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,server,failure,catch,execution,exception,e,if,e,get,cause,instanceof,runtime,exception,fail,did,not,throw,expected,exception,assert,equals,0l,stats,get,num,connections,while,deadline,has,time,left,stats,get,num,successful,0l,stats,get,num,failed,2l,thread,sleep,100l,assert,equals,2l,stats,get,num,requests,assert,equals,0l,stats,get,num,successful,assert,equals,2l,stats,get,num,failed,finally,if,client,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,if,server,channel,null,server,channel,close,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testServerClosesChannel() throws Exception;1509037054;Tests that a server channel close, closes the connection and removes it_from the established connections.;@Test_	public void testServerClosesChannel() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null__		Channel serverChannel = null___		try {_			client = new Client<>("Test Client", 1, serializer, stats)___			final AtomicBoolean received = new AtomicBoolean()__			final AtomicReference<Channel> channel = new AtomicReference<>()___			serverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {_				@Override_				public void channelActive(ChannelHandlerContext ctx) throws Exception {_					channel.set(ctx.channel())__				}__				@Override_				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {_					received.set(true)__				}_			})___			InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel)___			_			KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])__			Future<KvStateResponse> future = client.sendRequest(serverAddress, request)___			while (!received.get() && deadline.hasTimeLeft()) {_				Thread.sleep(50L)__			}_			assertTrue("Receive timed out", received.get())___			assertEquals(1, stats.getNumConnections())___			channel.get().close().await(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___			try {_				future.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				fail("Did not throw expected server failure")__			} catch (ExecutionException e) {_				if (!(e.getCause() instanceof ClosedChannelException)) {_					fail("Did not throw expected Exception")__				}_				_			}__			assertEquals(0L, stats.getNumConnections())___			_			while (deadline.hasTimeLeft() && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 1L)) {_				Thread.sleep(100L)__			}__			assertEquals(1L, stats.getNumRequests())__			assertEquals(0L, stats.getNumSuccessful())__			assertEquals(1L, stats.getNumFailed())__		} finally {_			if (client != null) {_				client.shutdown()__			}__			if (serverChannel != null) {_				serverChannel.close()__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};tests,that,a,server,channel,close,closes,the,connection,and,removes,it,from,the,established,connections;test,public,void,test,server,closes,channel,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,final,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,channel,server,channel,null,try,client,new,client,test,client,1,serializer,stats,final,atomic,boolean,received,new,atomic,boolean,final,atomic,reference,channel,channel,new,atomic,reference,server,channel,create,server,channel,new,channel,inbound,handler,adapter,override,public,void,channel,active,channel,handler,context,ctx,throws,exception,channel,set,ctx,channel,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,received,set,true,inet,socket,address,server,address,get,kv,state,server,address,server,channel,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,future,kv,state,response,future,client,send,request,server,address,request,while,received,get,deadline,has,time,left,thread,sleep,50l,assert,true,receive,timed,out,received,get,assert,equals,1,stats,get,num,connections,channel,get,close,await,deadline,time,left,to,millis,time,unit,milliseconds,try,future,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,server,failure,catch,execution,exception,e,if,e,get,cause,instanceof,closed,channel,exception,fail,did,not,throw,expected,exception,assert,equals,0l,stats,get,num,connections,while,deadline,has,time,left,stats,get,num,successful,0l,stats,get,num,failed,1l,thread,sleep,100l,assert,equals,1l,stats,get,num,requests,assert,equals,0l,stats,get,num,successful,assert,equals,1l,stats,get,num,failed,finally,if,client,null,client,shutdown,if,server,channel,null,server,channel,close,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testServerClosesChannel() throws Exception;1512567196;Tests that a server channel close, closes the connection and removes it_from the established connections.;@Test_	public void testServerClosesChannel() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null__		Channel serverChannel = null___		try {_			client = new Client<>("Test Client", 1, serializer, stats)___			final AtomicBoolean received = new AtomicBoolean()__			final AtomicReference<Channel> channel = new AtomicReference<>()___			serverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {_				@Override_				public void channelActive(ChannelHandlerContext ctx) throws Exception {_					channel.set(ctx.channel())__				}__				@Override_				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {_					received.set(true)__				}_			})___			InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel)___			_			KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])__			Future<KvStateResponse> future = client.sendRequest(serverAddress, request)___			while (!received.get() && deadline.hasTimeLeft()) {_				Thread.sleep(50L)__			}_			assertTrue("Receive timed out", received.get())___			assertEquals(1, stats.getNumConnections())___			channel.get().close().await(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___			try {_				future.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				fail("Did not throw expected server failure")__			} catch (ExecutionException e) {_				if (!(e.getCause() instanceof ClosedChannelException)) {_					fail("Did not throw expected Exception")__				}_				_			}__			assertEquals(0L, stats.getNumConnections())___			_			while (deadline.hasTimeLeft() && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 1L)) {_				Thread.sleep(100L)__			}__			assertEquals(1L, stats.getNumRequests())__			assertEquals(0L, stats.getNumSuccessful())__			assertEquals(1L, stats.getNumFailed())__		} finally {_			if (client != null) {_				try {_					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					e.printStackTrace()__				}_				Assert.assertTrue(client.isEventGroupShutdown())__			}__			if (serverChannel != null) {_				serverChannel.close()__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};tests,that,a,server,channel,close,closes,the,connection,and,removes,it,from,the,established,connections;test,public,void,test,server,closes,channel,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,final,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,channel,server,channel,null,try,client,new,client,test,client,1,serializer,stats,final,atomic,boolean,received,new,atomic,boolean,final,atomic,reference,channel,channel,new,atomic,reference,server,channel,create,server,channel,new,channel,inbound,handler,adapter,override,public,void,channel,active,channel,handler,context,ctx,throws,exception,channel,set,ctx,channel,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,received,set,true,inet,socket,address,server,address,get,kv,state,server,address,server,channel,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,future,kv,state,response,future,client,send,request,server,address,request,while,received,get,deadline,has,time,left,thread,sleep,50l,assert,true,receive,timed,out,received,get,assert,equals,1,stats,get,num,connections,channel,get,close,await,deadline,time,left,to,millis,time,unit,milliseconds,try,future,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,server,failure,catch,execution,exception,e,if,e,get,cause,instanceof,closed,channel,exception,fail,did,not,throw,expected,exception,assert,equals,0l,stats,get,num,connections,while,deadline,has,time,left,stats,get,num,successful,0l,stats,get,num,failed,1l,thread,sleep,100l,assert,equals,1l,stats,get,num,requests,assert,equals,0l,stats,get,num,successful,assert,equals,1l,stats,get,num,failed,finally,if,client,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,if,server,channel,null,server,channel,close,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testServerClosesChannel() throws Exception;1519897473;Tests that a server channel close, closes the connection and removes it_from the established connections.;@Test_	public void testServerClosesChannel() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null__		Channel serverChannel = null___		try {_			client = new Client<>("Test Client", 1, serializer, stats)___			final AtomicBoolean received = new AtomicBoolean()__			final AtomicReference<Channel> channel = new AtomicReference<>()___			serverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {_				@Override_				public void channelActive(ChannelHandlerContext ctx) throws Exception {_					channel.set(ctx.channel())__				}__				@Override_				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {_					received.set(true)__				}_			})___			InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel)___			_			KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])__			Future<KvStateResponse> future = client.sendRequest(serverAddress, request)___			while (!received.get() && deadline.hasTimeLeft()) {_				Thread.sleep(50L)__			}_			assertTrue("Receive timed out", received.get())___			assertEquals(1, stats.getNumConnections())___			channel.get().close().await(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___			try {_				future.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				fail("Did not throw expected server failure")__			} catch (ExecutionException e) {_				if (!(e.getCause() instanceof ClosedChannelException)) {_					fail("Did not throw expected Exception")__				}_				_			}__			assertEquals(0L, stats.getNumConnections())___			_			while (deadline.hasTimeLeft() && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 1L)) {_				Thread.sleep(100L)__			}__			assertEquals(1L, stats.getNumRequests())__			assertEquals(0L, stats.getNumSuccessful())__			assertEquals(1L, stats.getNumFailed())__		} finally {_			if (client != null) {_				try {_					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					e.printStackTrace()__				}_				Assert.assertTrue(client.isEventGroupShutdown())__			}__			if (serverChannel != null) {_				serverChannel.close()__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};tests,that,a,server,channel,close,closes,the,connection,and,removes,it,from,the,established,connections;test,public,void,test,server,closes,channel,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,final,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,channel,server,channel,null,try,client,new,client,test,client,1,serializer,stats,final,atomic,boolean,received,new,atomic,boolean,final,atomic,reference,channel,channel,new,atomic,reference,server,channel,create,server,channel,new,channel,inbound,handler,adapter,override,public,void,channel,active,channel,handler,context,ctx,throws,exception,channel,set,ctx,channel,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,received,set,true,inet,socket,address,server,address,get,kv,state,server,address,server,channel,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,future,kv,state,response,future,client,send,request,server,address,request,while,received,get,deadline,has,time,left,thread,sleep,50l,assert,true,receive,timed,out,received,get,assert,equals,1,stats,get,num,connections,channel,get,close,await,deadline,time,left,to,millis,time,unit,milliseconds,try,future,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,server,failure,catch,execution,exception,e,if,e,get,cause,instanceof,closed,channel,exception,fail,did,not,throw,expected,exception,assert,equals,0l,stats,get,num,connections,while,deadline,has,time,left,stats,get,num,successful,0l,stats,get,num,failed,1l,thread,sleep,100l,assert,equals,1l,stats,get,num,requests,assert,equals,0l,stats,get,num,successful,assert,equals,1l,stats,get,num,failed,finally,if,client,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,if,server,channel,null,server,channel,close,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testServerClosesChannel() throws Exception;1522337739;Tests that a server channel close, closes the connection and removes it_from the established connections.;@Test_	public void testServerClosesChannel() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null__		Channel serverChannel = null___		try {_			client = new Client<>("Test Client", 1, serializer, stats)___			final AtomicBoolean received = new AtomicBoolean()__			final AtomicReference<Channel> channel = new AtomicReference<>()___			serverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {_				@Override_				public void channelActive(ChannelHandlerContext ctx) throws Exception {_					channel.set(ctx.channel())__				}__				@Override_				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {_					received.set(true)__				}_			})___			InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel)___			_			KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])__			Future<KvStateResponse> future = client.sendRequest(serverAddress, request)___			while (!received.get() && deadline.hasTimeLeft()) {_				Thread.sleep(50L)__			}_			assertTrue("Receive timed out", received.get())___			assertEquals(1, stats.getNumConnections())___			channel.get().close().await(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___			try {_				future.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				fail("Did not throw expected server failure")__			} catch (ExecutionException e) {_				if (!(e.getCause() instanceof ClosedChannelException)) {_					fail("Did not throw expected Exception")__				}_				_			}__			assertEquals(0L, stats.getNumConnections())___			_			while (deadline.hasTimeLeft() && (stats.getNumSuccessful() != 0L || stats.getNumFailed() != 1L)) {_				Thread.sleep(100L)__			}__			assertEquals(1L, stats.getNumRequests())__			assertEquals(0L, stats.getNumSuccessful())__			assertEquals(1L, stats.getNumFailed())__		} finally {_			if (client != null) {_				try {_					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					e.printStackTrace()__				}_				Assert.assertTrue(client.isEventGroupShutdown())__			}__			if (serverChannel != null) {_				serverChannel.close()__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};tests,that,a,server,channel,close,closes,the,connection,and,removes,it,from,the,established,connections;test,public,void,test,server,closes,channel,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,final,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,channel,server,channel,null,try,client,new,client,test,client,1,serializer,stats,final,atomic,boolean,received,new,atomic,boolean,final,atomic,reference,channel,channel,new,atomic,reference,server,channel,create,server,channel,new,channel,inbound,handler,adapter,override,public,void,channel,active,channel,handler,context,ctx,throws,exception,channel,set,ctx,channel,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,received,set,true,inet,socket,address,server,address,get,kv,state,server,address,server,channel,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,future,kv,state,response,future,client,send,request,server,address,request,while,received,get,deadline,has,time,left,thread,sleep,50l,assert,true,receive,timed,out,received,get,assert,equals,1,stats,get,num,connections,channel,get,close,await,deadline,time,left,to,millis,time,unit,milliseconds,try,future,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,server,failure,catch,execution,exception,e,if,e,get,cause,instanceof,closed,channel,exception,fail,did,not,throw,expected,exception,assert,equals,0l,stats,get,num,connections,while,deadline,has,time,left,stats,get,num,successful,0l,stats,get,num,failed,1l,thread,sleep,100l,assert,equals,1l,stats,get,num,requests,assert,equals,0l,stats,get,num,successful,assert,equals,1l,stats,get,num,failed,finally,if,client,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,if,server,channel,null,server,channel,close,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testSimpleRequests() throws Exception;1509037054;Tests simple queries, of which half succeed and half fail.;@Test_	public void testSimpleRequests() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null__		Channel serverChannel = null___		try {_			client = new Client<>("Test Client", 1, serializer, stats)___			_			final byte[] expected = new byte[1024]__			ThreadLocalRandom.current().nextBytes(expected)___			final LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>()__			final AtomicReference<Channel> channel = new AtomicReference<>()___			serverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {_				@Override_				public void channelActive(ChannelHandlerContext ctx) throws Exception {_					channel.set(ctx.channel())__				}__				@Override_				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {_					received.add((ByteBuf) msg)__				}_			})___			InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel)___			long numQueries = 1024L___			List<CompletableFuture<KvStateResponse>> futures = new ArrayList<>()__			for (long i = 0L_ i < numQueries_ i++) {_				KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])__				futures.add(client.sendRequest(serverAddress, request))__			}__			_			Exception testException = new RuntimeException("Expected test Exception")___			for (long i = 0L_ i < numQueries_ i++) {_				ByteBuf buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				assertNotNull("Receive timed out", buf)___				Channel ch = channel.get()__				assertNotNull("Channel not active", ch)___				assertEquals(MessageType.REQUEST, MessageSerializer.deserializeHeader(buf))__				long requestId = MessageSerializer.getRequestId(buf)__				KvStateInternalRequest deserRequest = serializer.deserializeRequest(buf)___				buf.release()___				if (i % 2L == 0L) {_					ByteBuf response = MessageSerializer.serializeResponse(_							serverChannel.alloc(),_							requestId,_							new KvStateResponse(expected))___					ch.writeAndFlush(response)__				} else {_					ByteBuf response = MessageSerializer.serializeRequestFailure(_							serverChannel.alloc(),_							requestId,_							testException)___					ch.writeAndFlush(response)__				}_			}__			for (long i = 0L_ i < numQueries_ i++) {__				if (i % 2L == 0L) {_					KvStateResponse serializedResult = futures.get((int) i).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__					assertArrayEquals(expected, serializedResult.getContent())__				} else {_					try {_						futures.get((int) i).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__						fail("Did not throw expected Exception")__					} catch (ExecutionException e) {__						if (!(e.getCause() instanceof RuntimeException)) {_							fail("Did not throw expected Exception")__						}_						_					}_				}_			}__			assertEquals(numQueries, stats.getNumRequests())__			long expectedRequests = numQueries / 2L___			_			while (deadline.hasTimeLeft() && (stats.getNumSuccessful() != expectedRequests ||_					stats.getNumFailed() != expectedRequests)) {_				Thread.sleep(100L)__			}__			assertEquals(expectedRequests, stats.getNumSuccessful())__			assertEquals(expectedRequests, stats.getNumFailed())__		} finally {_			if (client != null) {_				client.shutdown()__			}__			if (serverChannel != null) {_				serverChannel.close()__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};tests,simple,queries,of,which,half,succeed,and,half,fail;test,public,void,test,simple,requests,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,channel,server,channel,null,try,client,new,client,test,client,1,serializer,stats,final,byte,expected,new,byte,1024,thread,local,random,current,next,bytes,expected,final,linked,blocking,queue,byte,buf,received,new,linked,blocking,queue,final,atomic,reference,channel,channel,new,atomic,reference,server,channel,create,server,channel,new,channel,inbound,handler,adapter,override,public,void,channel,active,channel,handler,context,ctx,throws,exception,channel,set,ctx,channel,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,received,add,byte,buf,msg,inet,socket,address,server,address,get,kv,state,server,address,server,channel,long,num,queries,1024l,list,completable,future,kv,state,response,futures,new,array,list,for,long,i,0l,i,num,queries,i,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,futures,add,client,send,request,server,address,request,exception,test,exception,new,runtime,exception,expected,test,exception,for,long,i,0l,i,num,queries,i,byte,buf,buf,received,poll,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,receive,timed,out,buf,channel,ch,channel,get,assert,not,null,channel,not,active,ch,assert,equals,message,type,request,message,serializer,deserialize,header,buf,long,request,id,message,serializer,get,request,id,buf,kv,state,internal,request,deser,request,serializer,deserialize,request,buf,buf,release,if,i,2l,0l,byte,buf,response,message,serializer,serialize,response,server,channel,alloc,request,id,new,kv,state,response,expected,ch,write,and,flush,response,else,byte,buf,response,message,serializer,serialize,request,failure,server,channel,alloc,request,id,test,exception,ch,write,and,flush,response,for,long,i,0l,i,num,queries,i,if,i,2l,0l,kv,state,response,serialized,result,futures,get,int,i,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,array,equals,expected,serialized,result,get,content,else,try,futures,get,int,i,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,exception,catch,execution,exception,e,if,e,get,cause,instanceof,runtime,exception,fail,did,not,throw,expected,exception,assert,equals,num,queries,stats,get,num,requests,long,expected,requests,num,queries,2l,while,deadline,has,time,left,stats,get,num,successful,expected,requests,stats,get,num,failed,expected,requests,thread,sleep,100l,assert,equals,expected,requests,stats,get,num,successful,assert,equals,expected,requests,stats,get,num,failed,finally,if,client,null,client,shutdown,if,server,channel,null,server,channel,close,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testSimpleRequests() throws Exception;1512567196;Tests simple queries, of which half succeed and half fail.;@Test_	public void testSimpleRequests() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null__		Channel serverChannel = null___		try {_			client = new Client<>("Test Client", 1, serializer, stats)___			_			final byte[] expected = new byte[1024]__			ThreadLocalRandom.current().nextBytes(expected)___			final LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>()__			final AtomicReference<Channel> channel = new AtomicReference<>()___			serverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {_				@Override_				public void channelActive(ChannelHandlerContext ctx) throws Exception {_					channel.set(ctx.channel())__				}__				@Override_				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {_					received.add((ByteBuf) msg)__				}_			})___			InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel)___			long numQueries = 1024L___			List<CompletableFuture<KvStateResponse>> futures = new ArrayList<>()__			for (long i = 0L_ i < numQueries_ i++) {_				KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])__				futures.add(client.sendRequest(serverAddress, request))__			}__			_			Exception testException = new RuntimeException("Expected test Exception")___			for (long i = 0L_ i < numQueries_ i++) {_				ByteBuf buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				assertNotNull("Receive timed out", buf)___				Channel ch = channel.get()__				assertNotNull("Channel not active", ch)___				assertEquals(MessageType.REQUEST, MessageSerializer.deserializeHeader(buf))__				long requestId = MessageSerializer.getRequestId(buf)__				KvStateInternalRequest deserRequest = serializer.deserializeRequest(buf)___				buf.release()___				if (i % 2L == 0L) {_					ByteBuf response = MessageSerializer.serializeResponse(_							serverChannel.alloc(),_							requestId,_							new KvStateResponse(expected))___					ch.writeAndFlush(response)__				} else {_					ByteBuf response = MessageSerializer.serializeRequestFailure(_							serverChannel.alloc(),_							requestId,_							testException)___					ch.writeAndFlush(response)__				}_			}__			for (long i = 0L_ i < numQueries_ i++) {__				if (i % 2L == 0L) {_					KvStateResponse serializedResult = futures.get((int) i).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__					assertArrayEquals(expected, serializedResult.getContent())__				} else {_					try {_						futures.get((int) i).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__						fail("Did not throw expected Exception")__					} catch (ExecutionException e) {__						if (!(e.getCause() instanceof RuntimeException)) {_							fail("Did not throw expected Exception")__						}_						_					}_				}_			}__			assertEquals(numQueries, stats.getNumRequests())__			long expectedRequests = numQueries / 2L___			_			while (deadline.hasTimeLeft() && (stats.getNumSuccessful() != expectedRequests ||_					stats.getNumFailed() != expectedRequests)) {_				Thread.sleep(100L)__			}__			assertEquals(expectedRequests, stats.getNumSuccessful())__			assertEquals(expectedRequests, stats.getNumFailed())__		} finally {_			if (client != null) {_				Exception exc = null__				try {__					_					_					_					__					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					exc = e__					LOG.error("An exception occurred while shutting down netty.", e)__				}__				Assert.assertTrue(_						ExceptionUtils.stringifyException(exc),_						client.isEventGroupShutdown()_				)__			}__			if (serverChannel != null) {_				serverChannel.close()__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};tests,simple,queries,of,which,half,succeed,and,half,fail;test,public,void,test,simple,requests,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,channel,server,channel,null,try,client,new,client,test,client,1,serializer,stats,final,byte,expected,new,byte,1024,thread,local,random,current,next,bytes,expected,final,linked,blocking,queue,byte,buf,received,new,linked,blocking,queue,final,atomic,reference,channel,channel,new,atomic,reference,server,channel,create,server,channel,new,channel,inbound,handler,adapter,override,public,void,channel,active,channel,handler,context,ctx,throws,exception,channel,set,ctx,channel,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,received,add,byte,buf,msg,inet,socket,address,server,address,get,kv,state,server,address,server,channel,long,num,queries,1024l,list,completable,future,kv,state,response,futures,new,array,list,for,long,i,0l,i,num,queries,i,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,futures,add,client,send,request,server,address,request,exception,test,exception,new,runtime,exception,expected,test,exception,for,long,i,0l,i,num,queries,i,byte,buf,buf,received,poll,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,receive,timed,out,buf,channel,ch,channel,get,assert,not,null,channel,not,active,ch,assert,equals,message,type,request,message,serializer,deserialize,header,buf,long,request,id,message,serializer,get,request,id,buf,kv,state,internal,request,deser,request,serializer,deserialize,request,buf,buf,release,if,i,2l,0l,byte,buf,response,message,serializer,serialize,response,server,channel,alloc,request,id,new,kv,state,response,expected,ch,write,and,flush,response,else,byte,buf,response,message,serializer,serialize,request,failure,server,channel,alloc,request,id,test,exception,ch,write,and,flush,response,for,long,i,0l,i,num,queries,i,if,i,2l,0l,kv,state,response,serialized,result,futures,get,int,i,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,array,equals,expected,serialized,result,get,content,else,try,futures,get,int,i,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,exception,catch,execution,exception,e,if,e,get,cause,instanceof,runtime,exception,fail,did,not,throw,expected,exception,assert,equals,num,queries,stats,get,num,requests,long,expected,requests,num,queries,2l,while,deadline,has,time,left,stats,get,num,successful,expected,requests,stats,get,num,failed,expected,requests,thread,sleep,100l,assert,equals,expected,requests,stats,get,num,successful,assert,equals,expected,requests,stats,get,num,failed,finally,if,client,null,exception,exc,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,exc,e,log,error,an,exception,occurred,while,shutting,down,netty,e,assert,assert,true,exception,utils,stringify,exception,exc,client,is,event,group,shutdown,if,server,channel,null,server,channel,close,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testSimpleRequests() throws Exception;1519897473;Tests simple queries, of which half succeed and half fail.;@Test_	public void testSimpleRequests() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null__		Channel serverChannel = null___		try {_			client = new Client<>("Test Client", 1, serializer, stats)___			_			final byte[] expected = new byte[1024]__			ThreadLocalRandom.current().nextBytes(expected)___			final LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>()__			final AtomicReference<Channel> channel = new AtomicReference<>()___			serverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {_				@Override_				public void channelActive(ChannelHandlerContext ctx) throws Exception {_					channel.set(ctx.channel())__				}__				@Override_				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {_					received.add((ByteBuf) msg)__				}_			})___			InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel)___			long numQueries = 1024L___			List<CompletableFuture<KvStateResponse>> futures = new ArrayList<>()__			for (long i = 0L_ i < numQueries_ i++) {_				KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])__				futures.add(client.sendRequest(serverAddress, request))__			}__			_			Exception testException = new RuntimeException("Expected test Exception")___			for (long i = 0L_ i < numQueries_ i++) {_				ByteBuf buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				assertNotNull("Receive timed out", buf)___				Channel ch = channel.get()__				assertNotNull("Channel not active", ch)___				assertEquals(MessageType.REQUEST, MessageSerializer.deserializeHeader(buf))__				long requestId = MessageSerializer.getRequestId(buf)__				KvStateInternalRequest deserRequest = serializer.deserializeRequest(buf)___				buf.release()___				if (i % 2L == 0L) {_					ByteBuf response = MessageSerializer.serializeResponse(_							serverChannel.alloc(),_							requestId,_							new KvStateResponse(expected))___					ch.writeAndFlush(response)__				} else {_					ByteBuf response = MessageSerializer.serializeRequestFailure(_							serverChannel.alloc(),_							requestId,_							testException)___					ch.writeAndFlush(response)__				}_			}__			for (long i = 0L_ i < numQueries_ i++) {__				if (i % 2L == 0L) {_					KvStateResponse serializedResult = futures.get((int) i).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__					assertArrayEquals(expected, serializedResult.getContent())__				} else {_					try {_						futures.get((int) i).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__						fail("Did not throw expected Exception")__					} catch (ExecutionException e) {__						if (!(e.getCause() instanceof RuntimeException)) {_							fail("Did not throw expected Exception")__						}_						_					}_				}_			}__			assertEquals(numQueries, stats.getNumRequests())__			long expectedRequests = numQueries / 2L___			_			while (deadline.hasTimeLeft() && (stats.getNumSuccessful() != expectedRequests ||_					stats.getNumFailed() != expectedRequests)) {_				Thread.sleep(100L)__			}__			assertEquals(expectedRequests, stats.getNumSuccessful())__			assertEquals(expectedRequests, stats.getNumFailed())__		} finally {_			if (client != null) {_				Exception exc = null__				try {__					_					_					_					__					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					exc = e__					LOG.error("An exception occurred while shutting down netty.", e)__				}__				Assert.assertTrue(_						ExceptionUtils.stringifyException(exc),_						client.isEventGroupShutdown()_				)__			}__			if (serverChannel != null) {_				serverChannel.close()__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};tests,simple,queries,of,which,half,succeed,and,half,fail;test,public,void,test,simple,requests,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,channel,server,channel,null,try,client,new,client,test,client,1,serializer,stats,final,byte,expected,new,byte,1024,thread,local,random,current,next,bytes,expected,final,linked,blocking,queue,byte,buf,received,new,linked,blocking,queue,final,atomic,reference,channel,channel,new,atomic,reference,server,channel,create,server,channel,new,channel,inbound,handler,adapter,override,public,void,channel,active,channel,handler,context,ctx,throws,exception,channel,set,ctx,channel,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,received,add,byte,buf,msg,inet,socket,address,server,address,get,kv,state,server,address,server,channel,long,num,queries,1024l,list,completable,future,kv,state,response,futures,new,array,list,for,long,i,0l,i,num,queries,i,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,futures,add,client,send,request,server,address,request,exception,test,exception,new,runtime,exception,expected,test,exception,for,long,i,0l,i,num,queries,i,byte,buf,buf,received,poll,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,receive,timed,out,buf,channel,ch,channel,get,assert,not,null,channel,not,active,ch,assert,equals,message,type,request,message,serializer,deserialize,header,buf,long,request,id,message,serializer,get,request,id,buf,kv,state,internal,request,deser,request,serializer,deserialize,request,buf,buf,release,if,i,2l,0l,byte,buf,response,message,serializer,serialize,response,server,channel,alloc,request,id,new,kv,state,response,expected,ch,write,and,flush,response,else,byte,buf,response,message,serializer,serialize,request,failure,server,channel,alloc,request,id,test,exception,ch,write,and,flush,response,for,long,i,0l,i,num,queries,i,if,i,2l,0l,kv,state,response,serialized,result,futures,get,int,i,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,array,equals,expected,serialized,result,get,content,else,try,futures,get,int,i,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,exception,catch,execution,exception,e,if,e,get,cause,instanceof,runtime,exception,fail,did,not,throw,expected,exception,assert,equals,num,queries,stats,get,num,requests,long,expected,requests,num,queries,2l,while,deadline,has,time,left,stats,get,num,successful,expected,requests,stats,get,num,failed,expected,requests,thread,sleep,100l,assert,equals,expected,requests,stats,get,num,successful,assert,equals,expected,requests,stats,get,num,failed,finally,if,client,null,exception,exc,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,exc,e,log,error,an,exception,occurred,while,shutting,down,netty,e,assert,assert,true,exception,utils,stringify,exception,exc,client,is,event,group,shutdown,if,server,channel,null,server,channel,close,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testSimpleRequests() throws Exception;1522337739;Tests simple queries, of which half succeed and half fail.;@Test_	public void testSimpleRequests() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null__		Channel serverChannel = null___		try {_			client = new Client<>("Test Client", 1, serializer, stats)___			_			final byte[] expected = new byte[1024]__			ThreadLocalRandom.current().nextBytes(expected)___			final LinkedBlockingQueue<ByteBuf> received = new LinkedBlockingQueue<>()__			final AtomicReference<Channel> channel = new AtomicReference<>()___			serverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {_				@Override_				public void channelActive(ChannelHandlerContext ctx) throws Exception {_					channel.set(ctx.channel())__				}__				@Override_				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {_					received.add((ByteBuf) msg)__				}_			})___			InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel)___			long numQueries = 1024L___			List<CompletableFuture<KvStateResponse>> futures = new ArrayList<>()__			for (long i = 0L_ i < numQueries_ i++) {_				KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])__				futures.add(client.sendRequest(serverAddress, request))__			}__			_			Exception testException = new RuntimeException("Expected test Exception")___			for (long i = 0L_ i < numQueries_ i++) {_				ByteBuf buf = received.poll(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				assertNotNull("Receive timed out", buf)___				Channel ch = channel.get()__				assertNotNull("Channel not active", ch)___				assertEquals(MessageType.REQUEST, MessageSerializer.deserializeHeader(buf))__				long requestId = MessageSerializer.getRequestId(buf)__				KvStateInternalRequest deserRequest = serializer.deserializeRequest(buf)___				buf.release()___				if (i % 2L == 0L) {_					ByteBuf response = MessageSerializer.serializeResponse(_							serverChannel.alloc(),_							requestId,_							new KvStateResponse(expected))___					ch.writeAndFlush(response)__				} else {_					ByteBuf response = MessageSerializer.serializeRequestFailure(_							serverChannel.alloc(),_							requestId,_							testException)___					ch.writeAndFlush(response)__				}_			}__			for (long i = 0L_ i < numQueries_ i++) {__				if (i % 2L == 0L) {_					KvStateResponse serializedResult = futures.get((int) i).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__					assertArrayEquals(expected, serializedResult.getContent())__				} else {_					try {_						futures.get((int) i).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__						fail("Did not throw expected Exception")__					} catch (ExecutionException e) {__						if (!(e.getCause() instanceof RuntimeException)) {_							fail("Did not throw expected Exception")__						}_						_					}_				}_			}__			assertEquals(numQueries, stats.getNumRequests())__			long expectedRequests = numQueries / 2L___			_			while (deadline.hasTimeLeft() && (stats.getNumSuccessful() != expectedRequests ||_					stats.getNumFailed() != expectedRequests)) {_				Thread.sleep(100L)__			}__			assertEquals(expectedRequests, stats.getNumSuccessful())__			assertEquals(expectedRequests, stats.getNumFailed())__		} finally {_			if (client != null) {_				Exception exc = null__				try {__					_					_					_					__					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					exc = e__					LOG.error("An exception occurred while shutting down netty.", e)__				}__				Assert.assertTrue(_						ExceptionUtils.stringifyException(exc),_						client.isEventGroupShutdown()_				)__			}__			if (serverChannel != null) {_				serverChannel.close()__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};tests,simple,queries,of,which,half,succeed,and,half,fail;test,public,void,test,simple,requests,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,channel,server,channel,null,try,client,new,client,test,client,1,serializer,stats,final,byte,expected,new,byte,1024,thread,local,random,current,next,bytes,expected,final,linked,blocking,queue,byte,buf,received,new,linked,blocking,queue,final,atomic,reference,channel,channel,new,atomic,reference,server,channel,create,server,channel,new,channel,inbound,handler,adapter,override,public,void,channel,active,channel,handler,context,ctx,throws,exception,channel,set,ctx,channel,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,received,add,byte,buf,msg,inet,socket,address,server,address,get,kv,state,server,address,server,channel,long,num,queries,1024l,list,completable,future,kv,state,response,futures,new,array,list,for,long,i,0l,i,num,queries,i,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,futures,add,client,send,request,server,address,request,exception,test,exception,new,runtime,exception,expected,test,exception,for,long,i,0l,i,num,queries,i,byte,buf,buf,received,poll,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,receive,timed,out,buf,channel,ch,channel,get,assert,not,null,channel,not,active,ch,assert,equals,message,type,request,message,serializer,deserialize,header,buf,long,request,id,message,serializer,get,request,id,buf,kv,state,internal,request,deser,request,serializer,deserialize,request,buf,buf,release,if,i,2l,0l,byte,buf,response,message,serializer,serialize,response,server,channel,alloc,request,id,new,kv,state,response,expected,ch,write,and,flush,response,else,byte,buf,response,message,serializer,serialize,request,failure,server,channel,alloc,request,id,test,exception,ch,write,and,flush,response,for,long,i,0l,i,num,queries,i,if,i,2l,0l,kv,state,response,serialized,result,futures,get,int,i,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,array,equals,expected,serialized,result,get,content,else,try,futures,get,int,i,get,deadline,time,left,to,millis,time,unit,milliseconds,fail,did,not,throw,expected,exception,catch,execution,exception,e,if,e,get,cause,instanceof,runtime,exception,fail,did,not,throw,expected,exception,assert,equals,num,queries,stats,get,num,requests,long,expected,requests,num,queries,2l,while,deadline,has,time,left,stats,get,num,successful,expected,requests,stats,get,num,failed,expected,requests,thread,sleep,100l,assert,equals,expected,requests,stats,get,num,successful,assert,equals,expected,requests,stats,get,num,failed,finally,if,client,null,exception,exc,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,exc,e,log,error,an,exception,occurred,while,shutting,down,netty,e,assert,assert,true,exception,utils,stringify,exception,exc,client,is,event,group,shutdown,if,server,channel,null,server,channel,close,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testConcurrentQueries() throws Exception;1509037054;Multiple threads concurrently fire queries.;@Test_	public void testConcurrentQueries() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		ExecutorService executor = null__		Client<KvStateInternalRequest, KvStateResponse> client = null__		Channel serverChannel = null___		final byte[] serializedResult = new byte[1024]__		ThreadLocalRandom.current().nextBytes(serializedResult)___		try {_			int numQueryTasks = 4__			final int numQueriesPerTask = 1024___			executor = Executors.newFixedThreadPool(numQueryTasks)___			client = new Client<>("Test Client", 1, serializer, stats)___			serverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {_				@Override_				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {_					ByteBuf buf = (ByteBuf) msg__					assertEquals(MessageType.REQUEST, MessageSerializer.deserializeHeader(buf))__					long requestId = MessageSerializer.getRequestId(buf)__					KvStateInternalRequest request = serializer.deserializeRequest(buf)___					buf.release()___					KvStateResponse response = new KvStateResponse(serializedResult)__					ByteBuf serResponse = MessageSerializer.serializeResponse(_							ctx.alloc(),_							requestId,_							response)___					ctx.channel().writeAndFlush(serResponse)__				}_			})___			final InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel)___			final Client<KvStateInternalRequest, KvStateResponse> finalClient = client__			Callable<List<CompletableFuture<KvStateResponse>>> queryTask = () -> {_				List<CompletableFuture<KvStateResponse>> results = new ArrayList<>(numQueriesPerTask)___				for (int i = 0_ i < numQueriesPerTask_ i++) {_					KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])__					results.add(finalClient.sendRequest(serverAddress, request))__				}__				return results__			}___			_			List<Future<List<CompletableFuture<KvStateResponse>>>> futures = new ArrayList<>()__			for (int i = 0_ i < numQueryTasks_ i++) {_				futures.add(executor.submit(queryTask))__			}__			_			for (Future<List<CompletableFuture<KvStateResponse>>> future : futures) {_				List<CompletableFuture<KvStateResponse>> results = future.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				for (CompletableFuture<KvStateResponse> result : results) {_					KvStateResponse actual = result.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__					assertArrayEquals(serializedResult, actual.getContent())__				}_			}__			int totalQueries = numQueryTasks * numQueriesPerTask___			_			while (deadline.hasTimeLeft() && stats.getNumSuccessful() != totalQueries) {_				Thread.sleep(100L)__			}__			assertEquals(totalQueries, stats.getNumRequests())__			assertEquals(totalQueries, stats.getNumSuccessful())__		} finally {_			if (executor != null) {_				executor.shutdown()__			}__			if (serverChannel != null) {_				serverChannel.close()__			}__			if (client != null) {_				client.shutdown()__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};multiple,threads,concurrently,fire,queries;test,public,void,test,concurrent,queries,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,final,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,executor,service,executor,null,client,kv,state,internal,request,kv,state,response,client,null,channel,server,channel,null,final,byte,serialized,result,new,byte,1024,thread,local,random,current,next,bytes,serialized,result,try,int,num,query,tasks,4,final,int,num,queries,per,task,1024,executor,executors,new,fixed,thread,pool,num,query,tasks,client,new,client,test,client,1,serializer,stats,server,channel,create,server,channel,new,channel,inbound,handler,adapter,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,byte,buf,buf,byte,buf,msg,assert,equals,message,type,request,message,serializer,deserialize,header,buf,long,request,id,message,serializer,get,request,id,buf,kv,state,internal,request,request,serializer,deserialize,request,buf,buf,release,kv,state,response,response,new,kv,state,response,serialized,result,byte,buf,ser,response,message,serializer,serialize,response,ctx,alloc,request,id,response,ctx,channel,write,and,flush,ser,response,final,inet,socket,address,server,address,get,kv,state,server,address,server,channel,final,client,kv,state,internal,request,kv,state,response,final,client,client,callable,list,completable,future,kv,state,response,query,task,list,completable,future,kv,state,response,results,new,array,list,num,queries,per,task,for,int,i,0,i,num,queries,per,task,i,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,results,add,final,client,send,request,server,address,request,return,results,list,future,list,completable,future,kv,state,response,futures,new,array,list,for,int,i,0,i,num,query,tasks,i,futures,add,executor,submit,query,task,for,future,list,completable,future,kv,state,response,future,futures,list,completable,future,kv,state,response,results,future,get,deadline,time,left,to,millis,time,unit,milliseconds,for,completable,future,kv,state,response,result,results,kv,state,response,actual,result,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,array,equals,serialized,result,actual,get,content,int,total,queries,num,query,tasks,num,queries,per,task,while,deadline,has,time,left,stats,get,num,successful,total,queries,thread,sleep,100l,assert,equals,total,queries,stats,get,num,requests,assert,equals,total,queries,stats,get,num,successful,finally,if,executor,null,executor,shutdown,if,server,channel,null,server,channel,close,if,client,null,client,shutdown,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testConcurrentQueries() throws Exception;1512567196;Multiple threads concurrently fire queries.;@Test_	public void testConcurrentQueries() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		ExecutorService executor = null__		Client<KvStateInternalRequest, KvStateResponse> client = null__		Channel serverChannel = null___		final byte[] serializedResult = new byte[1024]__		ThreadLocalRandom.current().nextBytes(serializedResult)___		try {_			int numQueryTasks = 4__			final int numQueriesPerTask = 1024___			executor = Executors.newFixedThreadPool(numQueryTasks)___			client = new Client<>("Test Client", 1, serializer, stats)___			serverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {_				@Override_				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {_					ByteBuf buf = (ByteBuf) msg__					assertEquals(MessageType.REQUEST, MessageSerializer.deserializeHeader(buf))__					long requestId = MessageSerializer.getRequestId(buf)__					KvStateInternalRequest request = serializer.deserializeRequest(buf)___					buf.release()___					KvStateResponse response = new KvStateResponse(serializedResult)__					ByteBuf serResponse = MessageSerializer.serializeResponse(_							ctx.alloc(),_							requestId,_							response)___					ctx.channel().writeAndFlush(serResponse)__				}_			})___			final InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel)___			final Client<KvStateInternalRequest, KvStateResponse> finalClient = client__			Callable<List<CompletableFuture<KvStateResponse>>> queryTask = () -> {_				List<CompletableFuture<KvStateResponse>> results = new ArrayList<>(numQueriesPerTask)___				for (int i = 0_ i < numQueriesPerTask_ i++) {_					KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])__					results.add(finalClient.sendRequest(serverAddress, request))__				}__				return results__			}___			_			List<Future<List<CompletableFuture<KvStateResponse>>>> futures = new ArrayList<>()__			for (int i = 0_ i < numQueryTasks_ i++) {_				futures.add(executor.submit(queryTask))__			}__			_			for (Future<List<CompletableFuture<KvStateResponse>>> future : futures) {_				List<CompletableFuture<KvStateResponse>> results = future.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				for (CompletableFuture<KvStateResponse> result : results) {_					KvStateResponse actual = result.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__					assertArrayEquals(serializedResult, actual.getContent())__				}_			}__			int totalQueries = numQueryTasks * numQueriesPerTask___			_			while (deadline.hasTimeLeft() && stats.getNumSuccessful() != totalQueries) {_				Thread.sleep(100L)__			}__			assertEquals(totalQueries, stats.getNumRequests())__			assertEquals(totalQueries, stats.getNumSuccessful())__		} finally {_			if (executor != null) {_				executor.shutdown()__			}__			if (serverChannel != null) {_				serverChannel.close()__			}__			if (client != null) {_				try {_					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					e.printStackTrace()__				}_				Assert.assertTrue(client.isEventGroupShutdown())__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};multiple,threads,concurrently,fire,queries;test,public,void,test,concurrent,queries,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,final,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,executor,service,executor,null,client,kv,state,internal,request,kv,state,response,client,null,channel,server,channel,null,final,byte,serialized,result,new,byte,1024,thread,local,random,current,next,bytes,serialized,result,try,int,num,query,tasks,4,final,int,num,queries,per,task,1024,executor,executors,new,fixed,thread,pool,num,query,tasks,client,new,client,test,client,1,serializer,stats,server,channel,create,server,channel,new,channel,inbound,handler,adapter,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,byte,buf,buf,byte,buf,msg,assert,equals,message,type,request,message,serializer,deserialize,header,buf,long,request,id,message,serializer,get,request,id,buf,kv,state,internal,request,request,serializer,deserialize,request,buf,buf,release,kv,state,response,response,new,kv,state,response,serialized,result,byte,buf,ser,response,message,serializer,serialize,response,ctx,alloc,request,id,response,ctx,channel,write,and,flush,ser,response,final,inet,socket,address,server,address,get,kv,state,server,address,server,channel,final,client,kv,state,internal,request,kv,state,response,final,client,client,callable,list,completable,future,kv,state,response,query,task,list,completable,future,kv,state,response,results,new,array,list,num,queries,per,task,for,int,i,0,i,num,queries,per,task,i,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,results,add,final,client,send,request,server,address,request,return,results,list,future,list,completable,future,kv,state,response,futures,new,array,list,for,int,i,0,i,num,query,tasks,i,futures,add,executor,submit,query,task,for,future,list,completable,future,kv,state,response,future,futures,list,completable,future,kv,state,response,results,future,get,deadline,time,left,to,millis,time,unit,milliseconds,for,completable,future,kv,state,response,result,results,kv,state,response,actual,result,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,array,equals,serialized,result,actual,get,content,int,total,queries,num,query,tasks,num,queries,per,task,while,deadline,has,time,left,stats,get,num,successful,total,queries,thread,sleep,100l,assert,equals,total,queries,stats,get,num,requests,assert,equals,total,queries,stats,get,num,successful,finally,if,executor,null,executor,shutdown,if,server,channel,null,server,channel,close,if,client,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testConcurrentQueries() throws Exception;1519897473;Multiple threads concurrently fire queries.;@Test_	public void testConcurrentQueries() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		ExecutorService executor = null__		Client<KvStateInternalRequest, KvStateResponse> client = null__		Channel serverChannel = null___		final byte[] serializedResult = new byte[1024]__		ThreadLocalRandom.current().nextBytes(serializedResult)___		try {_			int numQueryTasks = 4__			final int numQueriesPerTask = 1024___			executor = Executors.newFixedThreadPool(numQueryTasks)___			client = new Client<>("Test Client", 1, serializer, stats)___			serverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {_				@Override_				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {_					ByteBuf buf = (ByteBuf) msg__					assertEquals(MessageType.REQUEST, MessageSerializer.deserializeHeader(buf))__					long requestId = MessageSerializer.getRequestId(buf)__					KvStateInternalRequest request = serializer.deserializeRequest(buf)___					buf.release()___					KvStateResponse response = new KvStateResponse(serializedResult)__					ByteBuf serResponse = MessageSerializer.serializeResponse(_							ctx.alloc(),_							requestId,_							response)___					ctx.channel().writeAndFlush(serResponse)__				}_			})___			final InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel)___			final Client<KvStateInternalRequest, KvStateResponse> finalClient = client__			Callable<List<CompletableFuture<KvStateResponse>>> queryTask = () -> {_				List<CompletableFuture<KvStateResponse>> results = new ArrayList<>(numQueriesPerTask)___				for (int i = 0_ i < numQueriesPerTask_ i++) {_					KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])__					results.add(finalClient.sendRequest(serverAddress, request))__				}__				return results__			}___			_			List<Future<List<CompletableFuture<KvStateResponse>>>> futures = new ArrayList<>()__			for (int i = 0_ i < numQueryTasks_ i++) {_				futures.add(executor.submit(queryTask))__			}__			_			for (Future<List<CompletableFuture<KvStateResponse>>> future : futures) {_				List<CompletableFuture<KvStateResponse>> results = future.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				for (CompletableFuture<KvStateResponse> result : results) {_					KvStateResponse actual = result.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__					assertArrayEquals(serializedResult, actual.getContent())__				}_			}__			int totalQueries = numQueryTasks * numQueriesPerTask___			_			while (deadline.hasTimeLeft() && stats.getNumSuccessful() != totalQueries) {_				Thread.sleep(100L)__			}__			assertEquals(totalQueries, stats.getNumRequests())__			assertEquals(totalQueries, stats.getNumSuccessful())__		} finally {_			if (executor != null) {_				executor.shutdown()__			}__			if (serverChannel != null) {_				serverChannel.close()__			}__			if (client != null) {_				try {_					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					e.printStackTrace()__				}_				Assert.assertTrue(client.isEventGroupShutdown())__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};multiple,threads,concurrently,fire,queries;test,public,void,test,concurrent,queries,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,final,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,executor,service,executor,null,client,kv,state,internal,request,kv,state,response,client,null,channel,server,channel,null,final,byte,serialized,result,new,byte,1024,thread,local,random,current,next,bytes,serialized,result,try,int,num,query,tasks,4,final,int,num,queries,per,task,1024,executor,executors,new,fixed,thread,pool,num,query,tasks,client,new,client,test,client,1,serializer,stats,server,channel,create,server,channel,new,channel,inbound,handler,adapter,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,byte,buf,buf,byte,buf,msg,assert,equals,message,type,request,message,serializer,deserialize,header,buf,long,request,id,message,serializer,get,request,id,buf,kv,state,internal,request,request,serializer,deserialize,request,buf,buf,release,kv,state,response,response,new,kv,state,response,serialized,result,byte,buf,ser,response,message,serializer,serialize,response,ctx,alloc,request,id,response,ctx,channel,write,and,flush,ser,response,final,inet,socket,address,server,address,get,kv,state,server,address,server,channel,final,client,kv,state,internal,request,kv,state,response,final,client,client,callable,list,completable,future,kv,state,response,query,task,list,completable,future,kv,state,response,results,new,array,list,num,queries,per,task,for,int,i,0,i,num,queries,per,task,i,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,results,add,final,client,send,request,server,address,request,return,results,list,future,list,completable,future,kv,state,response,futures,new,array,list,for,int,i,0,i,num,query,tasks,i,futures,add,executor,submit,query,task,for,future,list,completable,future,kv,state,response,future,futures,list,completable,future,kv,state,response,results,future,get,deadline,time,left,to,millis,time,unit,milliseconds,for,completable,future,kv,state,response,result,results,kv,state,response,actual,result,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,array,equals,serialized,result,actual,get,content,int,total,queries,num,query,tasks,num,queries,per,task,while,deadline,has,time,left,stats,get,num,successful,total,queries,thread,sleep,100l,assert,equals,total,queries,stats,get,num,requests,assert,equals,total,queries,stats,get,num,successful,finally,if,executor,null,executor,shutdown,if,server,channel,null,server,channel,close,if,client,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testConcurrentQueries() throws Exception;1522337739;Multiple threads concurrently fire queries.;@Test_	public void testConcurrentQueries() throws Exception {_		Deadline deadline = TEST_TIMEOUT.fromNow()__		AtomicKvStateRequestStats stats = new AtomicKvStateRequestStats()___		final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		ExecutorService executor = null__		Client<KvStateInternalRequest, KvStateResponse> client = null__		Channel serverChannel = null___		final byte[] serializedResult = new byte[1024]__		ThreadLocalRandom.current().nextBytes(serializedResult)___		try {_			int numQueryTasks = 4__			final int numQueriesPerTask = 1024___			executor = Executors.newFixedThreadPool(numQueryTasks)___			client = new Client<>("Test Client", 1, serializer, stats)___			serverChannel = createServerChannel(new ChannelInboundHandlerAdapter() {_				@Override_				public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {_					ByteBuf buf = (ByteBuf) msg__					assertEquals(MessageType.REQUEST, MessageSerializer.deserializeHeader(buf))__					long requestId = MessageSerializer.getRequestId(buf)__					KvStateInternalRequest request = serializer.deserializeRequest(buf)___					buf.release()___					KvStateResponse response = new KvStateResponse(serializedResult)__					ByteBuf serResponse = MessageSerializer.serializeResponse(_							ctx.alloc(),_							requestId,_							response)___					ctx.channel().writeAndFlush(serResponse)__				}_			})___			final InetSocketAddress serverAddress = getKvStateServerAddress(serverChannel)___			final Client<KvStateInternalRequest, KvStateResponse> finalClient = client__			Callable<List<CompletableFuture<KvStateResponse>>> queryTask = () -> {_				List<CompletableFuture<KvStateResponse>> results = new ArrayList<>(numQueriesPerTask)___				for (int i = 0_ i < numQueriesPerTask_ i++) {_					KvStateInternalRequest request = new KvStateInternalRequest(new KvStateID(), new byte[0])__					results.add(finalClient.sendRequest(serverAddress, request))__				}__				return results__			}___			_			List<Future<List<CompletableFuture<KvStateResponse>>>> futures = new ArrayList<>()__			for (int i = 0_ i < numQueryTasks_ i++) {_				futures.add(executor.submit(queryTask))__			}__			_			for (Future<List<CompletableFuture<KvStateResponse>>> future : futures) {_				List<CompletableFuture<KvStateResponse>> results = future.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__				for (CompletableFuture<KvStateResponse> result : results) {_					KvStateResponse actual = result.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)__					assertArrayEquals(serializedResult, actual.getContent())__				}_			}__			int totalQueries = numQueryTasks * numQueriesPerTask___			_			while (deadline.hasTimeLeft() && stats.getNumSuccessful() != totalQueries) {_				Thread.sleep(100L)__			}__			assertEquals(totalQueries, stats.getNumRequests())__			assertEquals(totalQueries, stats.getNumSuccessful())__		} finally {_			if (executor != null) {_				executor.shutdown()__			}__			if (serverChannel != null) {_				serverChannel.close()__			}__			if (client != null) {_				try {_					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					e.printStackTrace()__				}_				Assert.assertTrue(client.isEventGroupShutdown())__			}__			assertEquals("Channel leak", 0L, stats.getNumConnections())__		}_	};multiple,threads,concurrently,fire,queries;test,public,void,test,concurrent,queries,throws,exception,deadline,deadline,from,now,atomic,kv,state,request,stats,stats,new,atomic,kv,state,request,stats,final,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,executor,service,executor,null,client,kv,state,internal,request,kv,state,response,client,null,channel,server,channel,null,final,byte,serialized,result,new,byte,1024,thread,local,random,current,next,bytes,serialized,result,try,int,num,query,tasks,4,final,int,num,queries,per,task,1024,executor,executors,new,fixed,thread,pool,num,query,tasks,client,new,client,test,client,1,serializer,stats,server,channel,create,server,channel,new,channel,inbound,handler,adapter,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,byte,buf,buf,byte,buf,msg,assert,equals,message,type,request,message,serializer,deserialize,header,buf,long,request,id,message,serializer,get,request,id,buf,kv,state,internal,request,request,serializer,deserialize,request,buf,buf,release,kv,state,response,response,new,kv,state,response,serialized,result,byte,buf,ser,response,message,serializer,serialize,response,ctx,alloc,request,id,response,ctx,channel,write,and,flush,ser,response,final,inet,socket,address,server,address,get,kv,state,server,address,server,channel,final,client,kv,state,internal,request,kv,state,response,final,client,client,callable,list,completable,future,kv,state,response,query,task,list,completable,future,kv,state,response,results,new,array,list,num,queries,per,task,for,int,i,0,i,num,queries,per,task,i,kv,state,internal,request,request,new,kv,state,internal,request,new,kv,state,id,new,byte,0,results,add,final,client,send,request,server,address,request,return,results,list,future,list,completable,future,kv,state,response,futures,new,array,list,for,int,i,0,i,num,query,tasks,i,futures,add,executor,submit,query,task,for,future,list,completable,future,kv,state,response,future,futures,list,completable,future,kv,state,response,results,future,get,deadline,time,left,to,millis,time,unit,milliseconds,for,completable,future,kv,state,response,result,results,kv,state,response,actual,result,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,array,equals,serialized,result,actual,get,content,int,total,queries,num,query,tasks,num,queries,per,task,while,deadline,has,time,left,stats,get,num,successful,total,queries,thread,sleep,100l,assert,equals,total,queries,stats,get,num,requests,assert,equals,total,queries,stats,get,num,successful,finally,if,executor,null,executor,shutdown,if,server,channel,null,server,channel,close,if,client,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,assert,equals,channel,leak,0l,stats,get,num,connections
ClientTest -> @Test 	public void testClientServerIntegration() throws Throwable;1509037054;Tests multiple clients querying multiple servers until 100k queries have_been processed. At this point, the client is shut down and its verified_that all ongoing requests are failed.;@Test_	public void testClientServerIntegration() throws Throwable {_		_		final int numServers = 2__		final int numServerEventLoopThreads = 2__		final int numServerQueryThreads = 2___		final int numClientEventLoopThreads = 4__		final int numClientsTasks = 8___		final int batchSize = 16___		final int numKeyGroups = 1___		AbstractStateBackend abstractBackend = new MemoryStateBackend()__		KvStateRegistry dummyRegistry = new KvStateRegistry()__		DummyEnvironment dummyEnv = new DummyEnvironment("test", 1, 0)__		dummyEnv.setKvStateRegistry(dummyRegistry)___		AbstractKeyedStateBackend<Integer> backend = abstractBackend.createKeyedStateBackend(_				dummyEnv,_				new JobID(),_				"test_op",_				IntSerializer.INSTANCE,_				numKeyGroups,_				new KeyGroupRange(0, 0),_				dummyRegistry.createTaskRegistry(new JobID(), new JobVertexID()))___		final FiniteDuration timeout = new FiniteDuration(10, TimeUnit.SECONDS)___		AtomicKvStateRequestStats clientStats = new AtomicKvStateRequestStats()___		final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null__		ExecutorService clientTaskExecutor = null__		final KvStateServerImpl[] server = new KvStateServerImpl[numServers]___		try {_			client = new Client<>("Test Client", numClientEventLoopThreads, serializer, clientStats)__			clientTaskExecutor = Executors.newFixedThreadPool(numClientsTasks)___			_			ValueStateDescriptor<Integer> desc = new ValueStateDescriptor<>("any", IntSerializer.INSTANCE)__			desc.setQueryable("any")___			_			KvStateRegistry[] registry = new KvStateRegistry[numServers]__			AtomicKvStateRequestStats[] serverStats = new AtomicKvStateRequestStats[numServers]__			final KvStateID[] ids = new KvStateID[numServers]___			for (int i = 0_ i < numServers_ i++) {_				registry[i] = new KvStateRegistry()__				serverStats[i] = new AtomicKvStateRequestStats()__				server[i] = new KvStateServerImpl(_						InetAddress.getLocalHost(),_						Collections.singletonList(0).iterator(),_						numServerEventLoopThreads,_						numServerQueryThreads,_						registry[i],_						serverStats[i])___				server[i].start()___				backend.setCurrentKey(1010 + i)___				_				ValueState<Integer> state = backend.getPartitionedState(_						VoidNamespace.INSTANCE,_						VoidNamespaceSerializer.INSTANCE,_						desc)___				state.update(201 + i)___				_				InternalKvState<?> kvState = (InternalKvState<?>) state___				_				ids[i] = registry[i].registerKvState(new JobID(), new JobVertexID(), new KeyGroupRange(0, 0), "any", kvState)__			}__			final Client<KvStateInternalRequest, KvStateResponse> finalClient = client__			Callable<Void> queryTask = () -> {_				while (true) {_					if (Thread.interrupted()) {_						throw new InterruptedException()__					}__					_					List<Integer> random = new ArrayList<>()__					for (int j = 0_ j < batchSize_ j++) {_						random.add(j)__					}_					Collections.shuffle(random)___					_					List<Future<KvStateResponse>> futures = new ArrayList<>(batchSize)___					for (int j = 0_ j < batchSize_ j++) {_						int targetServer = random.get(j) % numServers___						byte[] serializedKeyAndNamespace = KvStateSerializer.serializeKeyAndNamespace(_								1010 + targetServer,_								IntSerializer.INSTANCE,_								VoidNamespace.INSTANCE,_								VoidNamespaceSerializer.INSTANCE)___						KvStateInternalRequest request = new KvStateInternalRequest(ids[targetServer], serializedKeyAndNamespace)__						futures.add(finalClient.sendRequest(server[targetServer].getServerAddress(), request))__					}__					_					for (int j = 0_ j < batchSize_ j++) {_						int targetServer = random.get(j) % numServers___						Future<KvStateResponse> future = futures.get(j)__						byte[] buf = future.get(timeout.toMillis(), TimeUnit.MILLISECONDS).getContent()__						int value = KvStateSerializer.deserializeValue(buf, IntSerializer.INSTANCE)__						assertEquals(201L + targetServer, value)__					}_				}_			}___			_			List<Future<Void>> taskFutures = new ArrayList<>()__			for (int i = 0_ i < numClientsTasks_ i++) {_				taskFutures.add(clientTaskExecutor.submit(queryTask))__			}__			long numRequests__			while ((numRequests = clientStats.getNumRequests()) < 100_000L) {_				Thread.sleep(100L)__				LOG.info("Number of requests {}/100_000", numRequests)__			}__			_			client.shutdown()___			for (Future<Void> future : taskFutures) {_				try {_					future.get()__					fail("Did not throw expected Exception after shut down")__				} catch (ExecutionException t) {_					if (t.getCause().getCause() instanceof ClosedChannelException ||_							t.getCause().getCause() instanceof IllegalStateException) {_						_					} else {_						t.printStackTrace()__						fail("Failed with unexpected Exception type: " + t.getClass().getName())__					}_				}_			}__			assertEquals("Connection leak (client)", 0L, clientStats.getNumConnections())__			for (int i = 0_ i < numServers_ i++) {_				boolean success = false__				int numRetries = 0__				while (!success) {_					try {_						assertEquals("Connection leak (server)", 0L, serverStats[i].getNumConnections())__						success = true__					} catch (Throwable t) {_						if (numRetries < 10) {_							LOG.info("Retrying connection leak check (server)")__							Thread.sleep((numRetries + 1) * 50L)__							numRetries++__						} else {_							throw t__						}_					}_				}_			}_		} finally {_			if (client != null) {_				client.shutdown()__			}__			for (int i = 0_ i < numServers_ i++) {_				if (server[i] != null) {_					server[i].shutdown()__				}_			}__			if (clientTaskExecutor != null) {_				clientTaskExecutor.shutdown()__			}_		}_	};tests,multiple,clients,querying,multiple,servers,until,100k,queries,have,been,processed,at,this,point,the,client,is,shut,down,and,its,verified,that,all,ongoing,requests,are,failed;test,public,void,test,client,server,integration,throws,throwable,final,int,num,servers,2,final,int,num,server,event,loop,threads,2,final,int,num,server,query,threads,2,final,int,num,client,event,loop,threads,4,final,int,num,clients,tasks,8,final,int,batch,size,16,final,int,num,key,groups,1,abstract,state,backend,abstract,backend,new,memory,state,backend,kv,state,registry,dummy,registry,new,kv,state,registry,dummy,environment,dummy,env,new,dummy,environment,test,1,0,dummy,env,set,kv,state,registry,dummy,registry,abstract,keyed,state,backend,integer,backend,abstract,backend,create,keyed,state,backend,dummy,env,new,job,id,int,serializer,instance,num,key,groups,new,key,group,range,0,0,dummy,registry,create,task,registry,new,job,id,new,job,vertex,id,final,finite,duration,timeout,new,finite,duration,10,time,unit,seconds,atomic,kv,state,request,stats,client,stats,new,atomic,kv,state,request,stats,final,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,executor,service,client,task,executor,null,final,kv,state,server,impl,server,new,kv,state,server,impl,num,servers,try,client,new,client,test,client,num,client,event,loop,threads,serializer,client,stats,client,task,executor,executors,new,fixed,thread,pool,num,clients,tasks,value,state,descriptor,integer,desc,new,value,state,descriptor,any,int,serializer,instance,desc,set,queryable,any,kv,state,registry,registry,new,kv,state,registry,num,servers,atomic,kv,state,request,stats,server,stats,new,atomic,kv,state,request,stats,num,servers,final,kv,state,id,ids,new,kv,state,id,num,servers,for,int,i,0,i,num,servers,i,registry,i,new,kv,state,registry,server,stats,i,new,atomic,kv,state,request,stats,server,i,new,kv,state,server,impl,inet,address,get,local,host,collections,singleton,list,0,iterator,num,server,event,loop,threads,num,server,query,threads,registry,i,server,stats,i,server,i,start,backend,set,current,key,1010,i,value,state,integer,state,backend,get,partitioned,state,void,namespace,instance,void,namespace,serializer,instance,desc,state,update,201,i,internal,kv,state,kv,state,internal,kv,state,state,ids,i,registry,i,register,kv,state,new,job,id,new,job,vertex,id,new,key,group,range,0,0,any,kv,state,final,client,kv,state,internal,request,kv,state,response,final,client,client,callable,void,query,task,while,true,if,thread,interrupted,throw,new,interrupted,exception,list,integer,random,new,array,list,for,int,j,0,j,batch,size,j,random,add,j,collections,shuffle,random,list,future,kv,state,response,futures,new,array,list,batch,size,for,int,j,0,j,batch,size,j,int,target,server,random,get,j,num,servers,byte,serialized,key,and,namespace,kv,state,serializer,serialize,key,and,namespace,1010,target,server,int,serializer,instance,void,namespace,instance,void,namespace,serializer,instance,kv,state,internal,request,request,new,kv,state,internal,request,ids,target,server,serialized,key,and,namespace,futures,add,final,client,send,request,server,target,server,get,server,address,request,for,int,j,0,j,batch,size,j,int,target,server,random,get,j,num,servers,future,kv,state,response,future,futures,get,j,byte,buf,future,get,timeout,to,millis,time,unit,milliseconds,get,content,int,value,kv,state,serializer,deserialize,value,buf,int,serializer,instance,assert,equals,201l,target,server,value,list,future,void,task,futures,new,array,list,for,int,i,0,i,num,clients,tasks,i,task,futures,add,client,task,executor,submit,query,task,long,num,requests,while,num,requests,client,stats,get,num,requests,thread,sleep,100l,log,info,number,of,requests,num,requests,client,shutdown,for,future,void,future,task,futures,try,future,get,fail,did,not,throw,expected,exception,after,shut,down,catch,execution,exception,t,if,t,get,cause,get,cause,instanceof,closed,channel,exception,t,get,cause,get,cause,instanceof,illegal,state,exception,else,t,print,stack,trace,fail,failed,with,unexpected,exception,type,t,get,class,get,name,assert,equals,connection,leak,client,0l,client,stats,get,num,connections,for,int,i,0,i,num,servers,i,boolean,success,false,int,num,retries,0,while,success,try,assert,equals,connection,leak,server,0l,server,stats,i,get,num,connections,success,true,catch,throwable,t,if,num,retries,10,log,info,retrying,connection,leak,check,server,thread,sleep,num,retries,1,50l,num,retries,else,throw,t,finally,if,client,null,client,shutdown,for,int,i,0,i,num,servers,i,if,server,i,null,server,i,shutdown,if,client,task,executor,null,client,task,executor,shutdown
ClientTest -> @Test 	public void testClientServerIntegration() throws Throwable;1512567196;Tests multiple clients querying multiple servers until 100k queries have_been processed. At this point, the client is shut down and its verified_that all ongoing requests are failed.;@Test_	public void testClientServerIntegration() throws Throwable {_		_		final int numServers = 2__		final int numServerEventLoopThreads = 2__		final int numServerQueryThreads = 2___		final int numClientEventLoopThreads = 4__		final int numClientsTasks = 8___		final int batchSize = 16___		final int numKeyGroups = 1___		AbstractStateBackend abstractBackend = new MemoryStateBackend()__		KvStateRegistry dummyRegistry = new KvStateRegistry()__		DummyEnvironment dummyEnv = new DummyEnvironment("test", 1, 0)__		dummyEnv.setKvStateRegistry(dummyRegistry)___		AbstractKeyedStateBackend<Integer> backend = abstractBackend.createKeyedStateBackend(_				dummyEnv,_				new JobID(),_				"test_op",_				IntSerializer.INSTANCE,_				numKeyGroups,_				new KeyGroupRange(0, 0),_				dummyRegistry.createTaskRegistry(new JobID(), new JobVertexID()))___		final FiniteDuration timeout = new FiniteDuration(10, TimeUnit.SECONDS)___		AtomicKvStateRequestStats clientStats = new AtomicKvStateRequestStats()___		final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null__		ExecutorService clientTaskExecutor = null__		final KvStateServerImpl[] server = new KvStateServerImpl[numServers]___		try {_			client = new Client<>("Test Client", numClientEventLoopThreads, serializer, clientStats)__			clientTaskExecutor = Executors.newFixedThreadPool(numClientsTasks)___			_			ValueStateDescriptor<Integer> desc = new ValueStateDescriptor<>("any", IntSerializer.INSTANCE)__			desc.setQueryable("any")___			_			KvStateRegistry[] registry = new KvStateRegistry[numServers]__			AtomicKvStateRequestStats[] serverStats = new AtomicKvStateRequestStats[numServers]__			final KvStateID[] ids = new KvStateID[numServers]___			for (int i = 0_ i < numServers_ i++) {_				registry[i] = new KvStateRegistry()__				serverStats[i] = new AtomicKvStateRequestStats()__				server[i] = new KvStateServerImpl(_						InetAddress.getLocalHost(),_						Collections.singletonList(0).iterator(),_						numServerEventLoopThreads,_						numServerQueryThreads,_						registry[i],_						serverStats[i])___				server[i].start()___				backend.setCurrentKey(1010 + i)___				_				ValueState<Integer> state = backend.getPartitionedState(_						VoidNamespace.INSTANCE,_						VoidNamespaceSerializer.INSTANCE,_						desc)___				state.update(201 + i)___				_				InternalKvState<?> kvState = (InternalKvState<?>) state___				_				ids[i] = registry[i].registerKvState(new JobID(), new JobVertexID(), new KeyGroupRange(0, 0), "any", kvState)__			}__			final Client<KvStateInternalRequest, KvStateResponse> finalClient = client__			Callable<Void> queryTask = () -> {_				while (true) {_					if (Thread.interrupted()) {_						throw new InterruptedException()__					}__					_					List<Integer> random = new ArrayList<>()__					for (int j = 0_ j < batchSize_ j++) {_						random.add(j)__					}_					Collections.shuffle(random)___					_					List<CompletableFuture<KvStateResponse>> futures = new ArrayList<>(batchSize)___					for (int j = 0_ j < batchSize_ j++) {_						int targetServer = random.get(j) % numServers___						byte[] serializedKeyAndNamespace = KvStateSerializer.serializeKeyAndNamespace(_								1010 + targetServer,_								IntSerializer.INSTANCE,_								VoidNamespace.INSTANCE,_								VoidNamespaceSerializer.INSTANCE)___						KvStateInternalRequest request = new KvStateInternalRequest(ids[targetServer], serializedKeyAndNamespace)__						futures.add(finalClient.sendRequest(server[targetServer].getServerAddress(), request))__					}__					_					for (int j = 0_ j < batchSize_ j++) {_						int targetServer = random.get(j) % numServers___						Future<KvStateResponse> future = futures.get(j)__						byte[] buf = future.get(timeout.toMillis(), TimeUnit.MILLISECONDS).getContent()__						int value = KvStateSerializer.deserializeValue(buf, IntSerializer.INSTANCE)__						assertEquals(201L + targetServer, value)__					}_				}_			}___			_			List<Future<Void>> taskFutures = new ArrayList<>()__			for (int i = 0_ i < numClientsTasks_ i++) {_				taskFutures.add(clientTaskExecutor.submit(queryTask))__			}__			long numRequests__			while ((numRequests = clientStats.getNumRequests()) < 100_000L) {_				Thread.sleep(100L)__				LOG.info("Number of requests {}/100_000", numRequests)__			}__			try {_				client.shutdown().get(10L, TimeUnit.SECONDS)__			} catch (Exception e) {_				e.printStackTrace()__			}_			Assert.assertTrue(client.isEventGroupShutdown())___			for (Future<Void> future : taskFutures) {_				try {_					future.get()__					fail("Did not throw expected Exception after shut down")__				} catch (ExecutionException t) {_					if (t.getCause().getCause() instanceof ClosedChannelException ||_							t.getCause().getCause() instanceof IllegalStateException) {_						_					} else {_						t.printStackTrace()__						fail("Failed with unexpected Exception type: " + t.getClass().getName())__					}_				}_			}__			assertEquals("Connection leak (client)", 0L, clientStats.getNumConnections())__			for (int i = 0_ i < numServers_ i++) {_				boolean success = false__				int numRetries = 0__				while (!success) {_					try {_						assertEquals("Connection leak (server)", 0L, serverStats[i].getNumConnections())__						success = true__					} catch (Throwable t) {_						if (numRetries < 10) {_							LOG.info("Retrying connection leak check (server)")__							Thread.sleep((numRetries + 1) * 50L)__							numRetries++__						} else {_							throw t__						}_					}_				}_			}_		} finally {_			if (client != null) {_				try {_					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					e.printStackTrace()__				}_				Assert.assertTrue(client.isEventGroupShutdown())__			}__			for (int i = 0_ i < numServers_ i++) {_				if (server[i] != null) {_					server[i].shutdown()__				}_			}__			if (clientTaskExecutor != null) {_				clientTaskExecutor.shutdown()__			}_		}_	};tests,multiple,clients,querying,multiple,servers,until,100k,queries,have,been,processed,at,this,point,the,client,is,shut,down,and,its,verified,that,all,ongoing,requests,are,failed;test,public,void,test,client,server,integration,throws,throwable,final,int,num,servers,2,final,int,num,server,event,loop,threads,2,final,int,num,server,query,threads,2,final,int,num,client,event,loop,threads,4,final,int,num,clients,tasks,8,final,int,batch,size,16,final,int,num,key,groups,1,abstract,state,backend,abstract,backend,new,memory,state,backend,kv,state,registry,dummy,registry,new,kv,state,registry,dummy,environment,dummy,env,new,dummy,environment,test,1,0,dummy,env,set,kv,state,registry,dummy,registry,abstract,keyed,state,backend,integer,backend,abstract,backend,create,keyed,state,backend,dummy,env,new,job,id,int,serializer,instance,num,key,groups,new,key,group,range,0,0,dummy,registry,create,task,registry,new,job,id,new,job,vertex,id,final,finite,duration,timeout,new,finite,duration,10,time,unit,seconds,atomic,kv,state,request,stats,client,stats,new,atomic,kv,state,request,stats,final,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,executor,service,client,task,executor,null,final,kv,state,server,impl,server,new,kv,state,server,impl,num,servers,try,client,new,client,test,client,num,client,event,loop,threads,serializer,client,stats,client,task,executor,executors,new,fixed,thread,pool,num,clients,tasks,value,state,descriptor,integer,desc,new,value,state,descriptor,any,int,serializer,instance,desc,set,queryable,any,kv,state,registry,registry,new,kv,state,registry,num,servers,atomic,kv,state,request,stats,server,stats,new,atomic,kv,state,request,stats,num,servers,final,kv,state,id,ids,new,kv,state,id,num,servers,for,int,i,0,i,num,servers,i,registry,i,new,kv,state,registry,server,stats,i,new,atomic,kv,state,request,stats,server,i,new,kv,state,server,impl,inet,address,get,local,host,collections,singleton,list,0,iterator,num,server,event,loop,threads,num,server,query,threads,registry,i,server,stats,i,server,i,start,backend,set,current,key,1010,i,value,state,integer,state,backend,get,partitioned,state,void,namespace,instance,void,namespace,serializer,instance,desc,state,update,201,i,internal,kv,state,kv,state,internal,kv,state,state,ids,i,registry,i,register,kv,state,new,job,id,new,job,vertex,id,new,key,group,range,0,0,any,kv,state,final,client,kv,state,internal,request,kv,state,response,final,client,client,callable,void,query,task,while,true,if,thread,interrupted,throw,new,interrupted,exception,list,integer,random,new,array,list,for,int,j,0,j,batch,size,j,random,add,j,collections,shuffle,random,list,completable,future,kv,state,response,futures,new,array,list,batch,size,for,int,j,0,j,batch,size,j,int,target,server,random,get,j,num,servers,byte,serialized,key,and,namespace,kv,state,serializer,serialize,key,and,namespace,1010,target,server,int,serializer,instance,void,namespace,instance,void,namespace,serializer,instance,kv,state,internal,request,request,new,kv,state,internal,request,ids,target,server,serialized,key,and,namespace,futures,add,final,client,send,request,server,target,server,get,server,address,request,for,int,j,0,j,batch,size,j,int,target,server,random,get,j,num,servers,future,kv,state,response,future,futures,get,j,byte,buf,future,get,timeout,to,millis,time,unit,milliseconds,get,content,int,value,kv,state,serializer,deserialize,value,buf,int,serializer,instance,assert,equals,201l,target,server,value,list,future,void,task,futures,new,array,list,for,int,i,0,i,num,clients,tasks,i,task,futures,add,client,task,executor,submit,query,task,long,num,requests,while,num,requests,client,stats,get,num,requests,thread,sleep,100l,log,info,number,of,requests,num,requests,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,for,future,void,future,task,futures,try,future,get,fail,did,not,throw,expected,exception,after,shut,down,catch,execution,exception,t,if,t,get,cause,get,cause,instanceof,closed,channel,exception,t,get,cause,get,cause,instanceof,illegal,state,exception,else,t,print,stack,trace,fail,failed,with,unexpected,exception,type,t,get,class,get,name,assert,equals,connection,leak,client,0l,client,stats,get,num,connections,for,int,i,0,i,num,servers,i,boolean,success,false,int,num,retries,0,while,success,try,assert,equals,connection,leak,server,0l,server,stats,i,get,num,connections,success,true,catch,throwable,t,if,num,retries,10,log,info,retrying,connection,leak,check,server,thread,sleep,num,retries,1,50l,num,retries,else,throw,t,finally,if,client,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,for,int,i,0,i,num,servers,i,if,server,i,null,server,i,shutdown,if,client,task,executor,null,client,task,executor,shutdown
ClientTest -> @Test 	public void testClientServerIntegration() throws Throwable;1519897473;Tests multiple clients querying multiple servers until 100k queries have_been processed. At this point, the client is shut down and its verified_that all ongoing requests are failed.;@Test_	public void testClientServerIntegration() throws Throwable {_		_		final int numServers = 2__		final int numServerEventLoopThreads = 2__		final int numServerQueryThreads = 2___		final int numClientEventLoopThreads = 4__		final int numClientsTasks = 8___		final int batchSize = 16___		final int numKeyGroups = 1___		AbstractStateBackend abstractBackend = new MemoryStateBackend()__		KvStateRegistry dummyRegistry = new KvStateRegistry()__		DummyEnvironment dummyEnv = new DummyEnvironment("test", 1, 0)__		dummyEnv.setKvStateRegistry(dummyRegistry)___		AbstractKeyedStateBackend<Integer> backend = abstractBackend.createKeyedStateBackend(_				dummyEnv,_				new JobID(),_				"test_op",_				IntSerializer.INSTANCE,_				numKeyGroups,_				new KeyGroupRange(0, 0),_				dummyRegistry.createTaskRegistry(new JobID(), new JobVertexID()))___		final FiniteDuration timeout = new FiniteDuration(10, TimeUnit.SECONDS)___		AtomicKvStateRequestStats clientStats = new AtomicKvStateRequestStats()___		final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null__		ExecutorService clientTaskExecutor = null__		final KvStateServerImpl[] server = new KvStateServerImpl[numServers]___		try {_			client = new Client<>("Test Client", numClientEventLoopThreads, serializer, clientStats)__			clientTaskExecutor = Executors.newFixedThreadPool(numClientsTasks)___			_			ValueStateDescriptor<Integer> desc = new ValueStateDescriptor<>("any", IntSerializer.INSTANCE)__			desc.setQueryable("any")___			_			KvStateRegistry[] registry = new KvStateRegistry[numServers]__			AtomicKvStateRequestStats[] serverStats = new AtomicKvStateRequestStats[numServers]__			final KvStateID[] ids = new KvStateID[numServers]___			for (int i = 0_ i < numServers_ i++) {_				registry[i] = new KvStateRegistry()__				serverStats[i] = new AtomicKvStateRequestStats()__				server[i] = new KvStateServerImpl(_						InetAddress.getLocalHost(),_						Collections.singletonList(0).iterator(),_						numServerEventLoopThreads,_						numServerQueryThreads,_						registry[i],_						serverStats[i])___				server[i].start()___				backend.setCurrentKey(1010 + i)___				_				ValueState<Integer> state = backend.getPartitionedState(_						VoidNamespace.INSTANCE,_						VoidNamespaceSerializer.INSTANCE,_						desc)___				state.update(201 + i)___				_				InternalKvState<?> kvState = (InternalKvState<?>) state___				_				ids[i] = registry[i].registerKvState(new JobID(), new JobVertexID(), new KeyGroupRange(0, 0), "any", kvState)__			}__			final Client<KvStateInternalRequest, KvStateResponse> finalClient = client__			Callable<Void> queryTask = () -> {_				while (true) {_					if (Thread.interrupted()) {_						throw new InterruptedException()__					}__					_					List<Integer> random = new ArrayList<>()__					for (int j = 0_ j < batchSize_ j++) {_						random.add(j)__					}_					Collections.shuffle(random)___					_					List<CompletableFuture<KvStateResponse>> futures = new ArrayList<>(batchSize)___					for (int j = 0_ j < batchSize_ j++) {_						int targetServer = random.get(j) % numServers___						byte[] serializedKeyAndNamespace = KvStateSerializer.serializeKeyAndNamespace(_								1010 + targetServer,_								IntSerializer.INSTANCE,_								VoidNamespace.INSTANCE,_								VoidNamespaceSerializer.INSTANCE)___						KvStateInternalRequest request = new KvStateInternalRequest(ids[targetServer], serializedKeyAndNamespace)__						futures.add(finalClient.sendRequest(server[targetServer].getServerAddress(), request))__					}__					_					for (int j = 0_ j < batchSize_ j++) {_						int targetServer = random.get(j) % numServers___						Future<KvStateResponse> future = futures.get(j)__						byte[] buf = future.get(timeout.toMillis(), TimeUnit.MILLISECONDS).getContent()__						int value = KvStateSerializer.deserializeValue(buf, IntSerializer.INSTANCE)__						assertEquals(201L + targetServer, value)__					}_				}_			}___			_			List<Future<Void>> taskFutures = new ArrayList<>()__			for (int i = 0_ i < numClientsTasks_ i++) {_				taskFutures.add(clientTaskExecutor.submit(queryTask))__			}__			long numRequests__			while ((numRequests = clientStats.getNumRequests()) < 100_000L) {_				Thread.sleep(100L)__				LOG.info("Number of requests {}/100_000", numRequests)__			}__			try {_				client.shutdown().get(10L, TimeUnit.SECONDS)__			} catch (Exception e) {_				e.printStackTrace()__			}_			Assert.assertTrue(client.isEventGroupShutdown())___			for (Future<Void> future : taskFutures) {_				try {_					future.get()__					fail("Did not throw expected Exception after shut down")__				} catch (ExecutionException t) {_					if (t.getCause().getCause() instanceof ClosedChannelException ||_							t.getCause().getCause() instanceof IllegalStateException) {_						_					} else {_						t.printStackTrace()__						fail("Failed with unexpected Exception type: " + t.getClass().getName())__					}_				}_			}__			assertEquals("Connection leak (client)", 0L, clientStats.getNumConnections())__			for (int i = 0_ i < numServers_ i++) {_				boolean success = false__				int numRetries = 0__				while (!success) {_					try {_						assertEquals("Connection leak (server)", 0L, serverStats[i].getNumConnections())__						success = true__					} catch (Throwable t) {_						if (numRetries < 10) {_							LOG.info("Retrying connection leak check (server)")__							Thread.sleep((numRetries + 1) * 50L)__							numRetries++__						} else {_							throw t__						}_					}_				}_			}_		} finally {_			if (client != null) {_				try {_					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					e.printStackTrace()__				}_				Assert.assertTrue(client.isEventGroupShutdown())__			}__			for (int i = 0_ i < numServers_ i++) {_				if (server[i] != null) {_					server[i].shutdown()__				}_			}__			if (clientTaskExecutor != null) {_				clientTaskExecutor.shutdown()__			}_		}_	};tests,multiple,clients,querying,multiple,servers,until,100k,queries,have,been,processed,at,this,point,the,client,is,shut,down,and,its,verified,that,all,ongoing,requests,are,failed;test,public,void,test,client,server,integration,throws,throwable,final,int,num,servers,2,final,int,num,server,event,loop,threads,2,final,int,num,server,query,threads,2,final,int,num,client,event,loop,threads,4,final,int,num,clients,tasks,8,final,int,batch,size,16,final,int,num,key,groups,1,abstract,state,backend,abstract,backend,new,memory,state,backend,kv,state,registry,dummy,registry,new,kv,state,registry,dummy,environment,dummy,env,new,dummy,environment,test,1,0,dummy,env,set,kv,state,registry,dummy,registry,abstract,keyed,state,backend,integer,backend,abstract,backend,create,keyed,state,backend,dummy,env,new,job,id,int,serializer,instance,num,key,groups,new,key,group,range,0,0,dummy,registry,create,task,registry,new,job,id,new,job,vertex,id,final,finite,duration,timeout,new,finite,duration,10,time,unit,seconds,atomic,kv,state,request,stats,client,stats,new,atomic,kv,state,request,stats,final,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,executor,service,client,task,executor,null,final,kv,state,server,impl,server,new,kv,state,server,impl,num,servers,try,client,new,client,test,client,num,client,event,loop,threads,serializer,client,stats,client,task,executor,executors,new,fixed,thread,pool,num,clients,tasks,value,state,descriptor,integer,desc,new,value,state,descriptor,any,int,serializer,instance,desc,set,queryable,any,kv,state,registry,registry,new,kv,state,registry,num,servers,atomic,kv,state,request,stats,server,stats,new,atomic,kv,state,request,stats,num,servers,final,kv,state,id,ids,new,kv,state,id,num,servers,for,int,i,0,i,num,servers,i,registry,i,new,kv,state,registry,server,stats,i,new,atomic,kv,state,request,stats,server,i,new,kv,state,server,impl,inet,address,get,local,host,collections,singleton,list,0,iterator,num,server,event,loop,threads,num,server,query,threads,registry,i,server,stats,i,server,i,start,backend,set,current,key,1010,i,value,state,integer,state,backend,get,partitioned,state,void,namespace,instance,void,namespace,serializer,instance,desc,state,update,201,i,internal,kv,state,kv,state,internal,kv,state,state,ids,i,registry,i,register,kv,state,new,job,id,new,job,vertex,id,new,key,group,range,0,0,any,kv,state,final,client,kv,state,internal,request,kv,state,response,final,client,client,callable,void,query,task,while,true,if,thread,interrupted,throw,new,interrupted,exception,list,integer,random,new,array,list,for,int,j,0,j,batch,size,j,random,add,j,collections,shuffle,random,list,completable,future,kv,state,response,futures,new,array,list,batch,size,for,int,j,0,j,batch,size,j,int,target,server,random,get,j,num,servers,byte,serialized,key,and,namespace,kv,state,serializer,serialize,key,and,namespace,1010,target,server,int,serializer,instance,void,namespace,instance,void,namespace,serializer,instance,kv,state,internal,request,request,new,kv,state,internal,request,ids,target,server,serialized,key,and,namespace,futures,add,final,client,send,request,server,target,server,get,server,address,request,for,int,j,0,j,batch,size,j,int,target,server,random,get,j,num,servers,future,kv,state,response,future,futures,get,j,byte,buf,future,get,timeout,to,millis,time,unit,milliseconds,get,content,int,value,kv,state,serializer,deserialize,value,buf,int,serializer,instance,assert,equals,201l,target,server,value,list,future,void,task,futures,new,array,list,for,int,i,0,i,num,clients,tasks,i,task,futures,add,client,task,executor,submit,query,task,long,num,requests,while,num,requests,client,stats,get,num,requests,thread,sleep,100l,log,info,number,of,requests,num,requests,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,for,future,void,future,task,futures,try,future,get,fail,did,not,throw,expected,exception,after,shut,down,catch,execution,exception,t,if,t,get,cause,get,cause,instanceof,closed,channel,exception,t,get,cause,get,cause,instanceof,illegal,state,exception,else,t,print,stack,trace,fail,failed,with,unexpected,exception,type,t,get,class,get,name,assert,equals,connection,leak,client,0l,client,stats,get,num,connections,for,int,i,0,i,num,servers,i,boolean,success,false,int,num,retries,0,while,success,try,assert,equals,connection,leak,server,0l,server,stats,i,get,num,connections,success,true,catch,throwable,t,if,num,retries,10,log,info,retrying,connection,leak,check,server,thread,sleep,num,retries,1,50l,num,retries,else,throw,t,finally,if,client,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,for,int,i,0,i,num,servers,i,if,server,i,null,server,i,shutdown,if,client,task,executor,null,client,task,executor,shutdown
ClientTest -> @Test 	public void testClientServerIntegration() throws Throwable;1522337739;Tests multiple clients querying multiple servers until 100k queries have_been processed. At this point, the client is shut down and its verified_that all ongoing requests are failed.;@Test_	public void testClientServerIntegration() throws Throwable {_		_		final int numServers = 2__		final int numServerEventLoopThreads = 2__		final int numServerQueryThreads = 2___		final int numClientEventLoopThreads = 4__		final int numClientsTasks = 8___		final int batchSize = 16___		final int numKeyGroups = 1___		AbstractStateBackend abstractBackend = new MemoryStateBackend()__		KvStateRegistry dummyRegistry = new KvStateRegistry()__		DummyEnvironment dummyEnv = new DummyEnvironment("test", 1, 0)__		dummyEnv.setKvStateRegistry(dummyRegistry)___		AbstractKeyedStateBackend<Integer> backend = abstractBackend.createKeyedStateBackend(_				dummyEnv,_				new JobID(),_				"test_op",_				IntSerializer.INSTANCE,_				numKeyGroups,_				new KeyGroupRange(0, 0),_				dummyRegistry.createTaskRegistry(new JobID(), new JobVertexID()))___		final FiniteDuration timeout = new FiniteDuration(10, TimeUnit.SECONDS)___		AtomicKvStateRequestStats clientStats = new AtomicKvStateRequestStats()___		final MessageSerializer<KvStateInternalRequest, KvStateResponse> serializer =_				new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer())___		Client<KvStateInternalRequest, KvStateResponse> client = null__		ExecutorService clientTaskExecutor = null__		final KvStateServerImpl[] server = new KvStateServerImpl[numServers]___		try {_			client = new Client<>("Test Client", numClientEventLoopThreads, serializer, clientStats)__			clientTaskExecutor = Executors.newFixedThreadPool(numClientsTasks)___			_			ValueStateDescriptor<Integer> desc = new ValueStateDescriptor<>("any", IntSerializer.INSTANCE)__			desc.setQueryable("any")___			_			KvStateRegistry[] registry = new KvStateRegistry[numServers]__			AtomicKvStateRequestStats[] serverStats = new AtomicKvStateRequestStats[numServers]__			final KvStateID[] ids = new KvStateID[numServers]___			for (int i = 0_ i < numServers_ i++) {_				registry[i] = new KvStateRegistry()__				serverStats[i] = new AtomicKvStateRequestStats()__				server[i] = new KvStateServerImpl(_						InetAddress.getLocalHost(),_						Collections.singletonList(0).iterator(),_						numServerEventLoopThreads,_						numServerQueryThreads,_						registry[i],_						serverStats[i])___				server[i].start()___				backend.setCurrentKey(1010 + i)___				_				ValueState<Integer> state = backend.getPartitionedState(_						VoidNamespace.INSTANCE,_						VoidNamespaceSerializer.INSTANCE,_						desc)___				state.update(201 + i)___				_				InternalKvState<Integer, ?, Integer> kvState = (InternalKvState<Integer, ?, Integer>) state___				_				ids[i] = registry[i].registerKvState(new JobID(), new JobVertexID(), new KeyGroupRange(0, 0), "any", kvState)__			}__			final Client<KvStateInternalRequest, KvStateResponse> finalClient = client__			Callable<Void> queryTask = () -> {_				while (true) {_					if (Thread.interrupted()) {_						throw new InterruptedException()__					}__					_					List<Integer> random = new ArrayList<>()__					for (int j = 0_ j < batchSize_ j++) {_						random.add(j)__					}_					Collections.shuffle(random)___					_					List<CompletableFuture<KvStateResponse>> futures = new ArrayList<>(batchSize)___					for (int j = 0_ j < batchSize_ j++) {_						int targetServer = random.get(j) % numServers___						byte[] serializedKeyAndNamespace = KvStateSerializer.serializeKeyAndNamespace(_								1010 + targetServer,_								IntSerializer.INSTANCE,_								VoidNamespace.INSTANCE,_								VoidNamespaceSerializer.INSTANCE)___						KvStateInternalRequest request = new KvStateInternalRequest(ids[targetServer], serializedKeyAndNamespace)__						futures.add(finalClient.sendRequest(server[targetServer].getServerAddress(), request))__					}__					_					for (int j = 0_ j < batchSize_ j++) {_						int targetServer = random.get(j) % numServers___						Future<KvStateResponse> future = futures.get(j)__						byte[] buf = future.get(timeout.toMillis(), TimeUnit.MILLISECONDS).getContent()__						int value = KvStateSerializer.deserializeValue(buf, IntSerializer.INSTANCE)__						assertEquals(201L + targetServer, value)__					}_				}_			}___			_			List<Future<Void>> taskFutures = new ArrayList<>()__			for (int i = 0_ i < numClientsTasks_ i++) {_				taskFutures.add(clientTaskExecutor.submit(queryTask))__			}__			long numRequests__			while ((numRequests = clientStats.getNumRequests()) < 100_000L) {_				Thread.sleep(100L)__				LOG.info("Number of requests {}/100_000", numRequests)__			}__			try {_				client.shutdown().get(10L, TimeUnit.SECONDS)__			} catch (Exception e) {_				e.printStackTrace()__			}_			Assert.assertTrue(client.isEventGroupShutdown())___			for (Future<Void> future : taskFutures) {_				try {_					future.get()__					fail("Did not throw expected Exception after shut down")__				} catch (ExecutionException t) {_					if (t.getCause().getCause() instanceof ClosedChannelException ||_							t.getCause().getCause() instanceof IllegalStateException) {_						_					} else {_						t.printStackTrace()__						fail("Failed with unexpected Exception type: " + t.getClass().getName())__					}_				}_			}__			assertEquals("Connection leak (client)", 0L, clientStats.getNumConnections())__			for (int i = 0_ i < numServers_ i++) {_				boolean success = false__				int numRetries = 0__				while (!success) {_					try {_						assertEquals("Connection leak (server)", 0L, serverStats[i].getNumConnections())__						success = true__					} catch (Throwable t) {_						if (numRetries < 10) {_							LOG.info("Retrying connection leak check (server)")__							Thread.sleep((numRetries + 1) * 50L)__							numRetries++__						} else {_							throw t__						}_					}_				}_			}_		} finally {_			if (client != null) {_				try {_					client.shutdown().get(10L, TimeUnit.SECONDS)__				} catch (Exception e) {_					e.printStackTrace()__				}_				Assert.assertTrue(client.isEventGroupShutdown())__			}__			for (int i = 0_ i < numServers_ i++) {_				if (server[i] != null) {_					server[i].shutdown()__				}_			}__			if (clientTaskExecutor != null) {_				clientTaskExecutor.shutdown()__			}_		}_	};tests,multiple,clients,querying,multiple,servers,until,100k,queries,have,been,processed,at,this,point,the,client,is,shut,down,and,its,verified,that,all,ongoing,requests,are,failed;test,public,void,test,client,server,integration,throws,throwable,final,int,num,servers,2,final,int,num,server,event,loop,threads,2,final,int,num,server,query,threads,2,final,int,num,client,event,loop,threads,4,final,int,num,clients,tasks,8,final,int,batch,size,16,final,int,num,key,groups,1,abstract,state,backend,abstract,backend,new,memory,state,backend,kv,state,registry,dummy,registry,new,kv,state,registry,dummy,environment,dummy,env,new,dummy,environment,test,1,0,dummy,env,set,kv,state,registry,dummy,registry,abstract,keyed,state,backend,integer,backend,abstract,backend,create,keyed,state,backend,dummy,env,new,job,id,int,serializer,instance,num,key,groups,new,key,group,range,0,0,dummy,registry,create,task,registry,new,job,id,new,job,vertex,id,final,finite,duration,timeout,new,finite,duration,10,time,unit,seconds,atomic,kv,state,request,stats,client,stats,new,atomic,kv,state,request,stats,final,message,serializer,kv,state,internal,request,kv,state,response,serializer,new,message,serializer,new,kv,state,internal,request,kv,state,internal,request,deserializer,new,kv,state,response,kv,state,response,deserializer,client,kv,state,internal,request,kv,state,response,client,null,executor,service,client,task,executor,null,final,kv,state,server,impl,server,new,kv,state,server,impl,num,servers,try,client,new,client,test,client,num,client,event,loop,threads,serializer,client,stats,client,task,executor,executors,new,fixed,thread,pool,num,clients,tasks,value,state,descriptor,integer,desc,new,value,state,descriptor,any,int,serializer,instance,desc,set,queryable,any,kv,state,registry,registry,new,kv,state,registry,num,servers,atomic,kv,state,request,stats,server,stats,new,atomic,kv,state,request,stats,num,servers,final,kv,state,id,ids,new,kv,state,id,num,servers,for,int,i,0,i,num,servers,i,registry,i,new,kv,state,registry,server,stats,i,new,atomic,kv,state,request,stats,server,i,new,kv,state,server,impl,inet,address,get,local,host,collections,singleton,list,0,iterator,num,server,event,loop,threads,num,server,query,threads,registry,i,server,stats,i,server,i,start,backend,set,current,key,1010,i,value,state,integer,state,backend,get,partitioned,state,void,namespace,instance,void,namespace,serializer,instance,desc,state,update,201,i,internal,kv,state,integer,integer,kv,state,internal,kv,state,integer,integer,state,ids,i,registry,i,register,kv,state,new,job,id,new,job,vertex,id,new,key,group,range,0,0,any,kv,state,final,client,kv,state,internal,request,kv,state,response,final,client,client,callable,void,query,task,while,true,if,thread,interrupted,throw,new,interrupted,exception,list,integer,random,new,array,list,for,int,j,0,j,batch,size,j,random,add,j,collections,shuffle,random,list,completable,future,kv,state,response,futures,new,array,list,batch,size,for,int,j,0,j,batch,size,j,int,target,server,random,get,j,num,servers,byte,serialized,key,and,namespace,kv,state,serializer,serialize,key,and,namespace,1010,target,server,int,serializer,instance,void,namespace,instance,void,namespace,serializer,instance,kv,state,internal,request,request,new,kv,state,internal,request,ids,target,server,serialized,key,and,namespace,futures,add,final,client,send,request,server,target,server,get,server,address,request,for,int,j,0,j,batch,size,j,int,target,server,random,get,j,num,servers,future,kv,state,response,future,futures,get,j,byte,buf,future,get,timeout,to,millis,time,unit,milliseconds,get,content,int,value,kv,state,serializer,deserialize,value,buf,int,serializer,instance,assert,equals,201l,target,server,value,list,future,void,task,futures,new,array,list,for,int,i,0,i,num,clients,tasks,i,task,futures,add,client,task,executor,submit,query,task,long,num,requests,while,num,requests,client,stats,get,num,requests,thread,sleep,100l,log,info,number,of,requests,num,requests,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,for,future,void,future,task,futures,try,future,get,fail,did,not,throw,expected,exception,after,shut,down,catch,execution,exception,t,if,t,get,cause,get,cause,instanceof,closed,channel,exception,t,get,cause,get,cause,instanceof,illegal,state,exception,else,t,print,stack,trace,fail,failed,with,unexpected,exception,type,t,get,class,get,name,assert,equals,connection,leak,client,0l,client,stats,get,num,connections,for,int,i,0,i,num,servers,i,boolean,success,false,int,num,retries,0,while,success,try,assert,equals,connection,leak,server,0l,server,stats,i,get,num,connections,success,true,catch,throwable,t,if,num,retries,10,log,info,retrying,connection,leak,check,server,thread,sleep,num,retries,1,50l,num,retries,else,throw,t,finally,if,client,null,try,client,shutdown,get,10l,time,unit,seconds,catch,exception,e,e,print,stack,trace,assert,assert,true,client,is,event,group,shutdown,for,int,i,0,i,num,servers,i,if,server,i,null,server,i,shutdown,if,client,task,executor,null,client,task,executor,shutdown
