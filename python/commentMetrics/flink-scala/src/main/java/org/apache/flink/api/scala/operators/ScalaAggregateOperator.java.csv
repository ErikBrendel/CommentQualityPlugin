# id;timestamp;commentText;codeText;commentWords;codeWords
ScalaAggregateOperator -> public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field);1411372797;<p>_Non grouped aggregation;public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())___		Validate.notNull(function)___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,scala,aggregate,operator,org,apache,flink,api,java,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
ScalaAggregateOperator -> public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field);1411473593;<p>_Non grouped aggregation;public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())___		Validate.notNull(function)___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,scala,aggregate,operator,org,apache,flink,api,java,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
ScalaAggregateOperator -> public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field);1412007326;<p>_Non grouped aggregation;public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())___		Validate.notNull(function)___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,scala,aggregate,operator,org,apache,flink,api,java,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
ScalaAggregateOperator -> public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field);1412761141;<p>_Non grouped aggregation;public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())___		Validate.notNull(function)___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,scala,aggregate,operator,org,apache,flink,api,java,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
ScalaAggregateOperator -> public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field);1416309577;<p>_Non grouped aggregation;public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())___		Validate.notNull(function)___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,scala,aggregate,operator,org,apache,flink,api,java,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
ScalaAggregateOperator -> public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field);1416482279;<p>_Non grouped aggregation;public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())___		Validate.notNull(function)___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,scala,aggregate,operator,org,apache,flink,api,java,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
ScalaAggregateOperator -> public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field);1418569795;<p>_Non grouped aggregation;public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())___		Validate.notNull(function)___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,scala,aggregate,operator,org,apache,flink,api,java,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
ScalaAggregateOperator -> public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field);1423570503;<p>_Non grouped aggregation;public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())___		Validate.notNull(function)___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,scala,aggregate,operator,org,apache,flink,api,java,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
ScalaAggregateOperator -> public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field);1427097830;<p>_Non grouped aggregation;public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())___		Validate.notNull(function)___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,scala,aggregate,operator,org,apache,flink,api,java,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
ScalaAggregateOperator -> public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field);1431696388;<p>_Non grouped aggregation;public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field) {_		super(Preconditions.checkNotNull(input), input.getType())___		Preconditions.checkNotNull(function)___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,scala,aggregate,operator,org,apache,flink,api,java,data,set,in,input,aggregations,function,int,field,super,preconditions,check,not,null,input,input,get,type,preconditions,check,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
ScalaAggregateOperator -> public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field);1453803444;<p>_Non grouped aggregation;public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field) {_		super(Preconditions.checkNotNull(input), input.getType())___		Preconditions.checkNotNull(function)___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,scala,aggregate,operator,org,apache,flink,api,java,data,set,in,input,aggregations,function,int,field,super,preconditions,check,not,null,input,input,get,type,preconditions,check,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
ScalaAggregateOperator -> public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field);1453803455;<p>_Non grouped aggregation;public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field) {_		super(Preconditions.checkNotNull(input), input.getType())___		Preconditions.checkNotNull(function)___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,scala,aggregate,operator,org,apache,flink,api,java,data,set,in,input,aggregations,function,int,field,super,preconditions,check,not,null,input,input,get,type,preconditions,check,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
ScalaAggregateOperator -> public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field);1454428544;<p>_Non grouped aggregation;public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field) {_		super(Preconditions.checkNotNull(input), input.getType())___		Preconditions.checkNotNull(function)___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,scala,aggregate,operator,org,apache,flink,api,java,data,set,in,input,aggregations,function,int,field,super,preconditions,check,not,null,input,input,get,type,preconditions,check,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
ScalaAggregateOperator -> public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field);1454679829;<p>_Non grouped aggregation;public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field) {_		super(Preconditions.checkNotNull(input), input.getType())___		Preconditions.checkNotNull(function)___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,scala,aggregate,operator,org,apache,flink,api,java,data,set,in,input,aggregations,function,int,field,super,preconditions,check,not,null,input,input,get,type,preconditions,check,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
ScalaAggregateOperator -> public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field);1465991918;<p>_Non grouped aggregation;public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field) {_		super(Preconditions.checkNotNull(input), input.getType())___		Preconditions.checkNotNull(function)___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,scala,aggregate,operator,org,apache,flink,api,java,data,set,in,input,aggregations,function,int,field,super,preconditions,check,not,null,input,input,get,type,preconditions,check,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
ScalaAggregateOperator -> public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field);1496260727;Non grouped aggregation.;public ScalaAggregateOperator(org.apache.flink.api.java.DataSet<IN> input, Aggregations function, int field) {_		super(Preconditions.checkNotNull(input), input.getType())___		Preconditions.checkNotNull(function)___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};non,grouped,aggregation;public,scala,aggregate,operator,org,apache,flink,api,java,data,set,in,input,aggregations,function,int,field,super,preconditions,check,not,null,input,input,get,type,preconditions,check,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
ScalaAggregateOperator -> public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field);1411372797;Grouped aggregation__@param input_@param function_@param field;public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())___		Validate.notNull(function)___		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,scala,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
ScalaAggregateOperator -> public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field);1411473593;Grouped aggregation__@param input_@param function_@param field;public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())___		Validate.notNull(function)___		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,scala,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
ScalaAggregateOperator -> public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field);1412007326;Grouped aggregation__@param input_@param function_@param field;public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())___		Validate.notNull(function)___		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,scala,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
ScalaAggregateOperator -> public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field);1412761141;Grouped aggregation__@param input_@param function_@param field;public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())___		Validate.notNull(function)___		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,scala,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
ScalaAggregateOperator -> public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field);1416309577;Grouped aggregation__@param input_@param function_@param field;public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())___		Validate.notNull(function)___		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,scala,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
ScalaAggregateOperator -> public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field);1416482279;Grouped aggregation__@param input_@param function_@param field;public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())___		Validate.notNull(function)___		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,scala,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
ScalaAggregateOperator -> public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field);1418569795;Grouped aggregation__@param input_@param function_@param field;public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())___		Validate.notNull(function)___		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,scala,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
ScalaAggregateOperator -> public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field);1423570503;Grouped aggregation__@param input_@param function_@param field;public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())___		Validate.notNull(function)___		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,scala,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
ScalaAggregateOperator -> public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field);1427097830;Grouped aggregation__@param input_@param function_@param field;public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())___		Validate.notNull(function)___		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,scala,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
ScalaAggregateOperator -> public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field);1431696388;Grouped aggregation__@param input_@param function_@param field;public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Preconditions.checkNotNull(input).getDataSet(), input.getDataSet().getType())___		Preconditions.checkNotNull(function)___		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,scala,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,preconditions,check,not,null,input,get,data,set,input,get,data,set,get,type,preconditions,check,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
ScalaAggregateOperator -> public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field);1453803444;Grouped aggregation__@param input_@param function_@param field;public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Preconditions.checkNotNull(input).getDataSet(), input.getDataSet().getType())___		Preconditions.checkNotNull(function)___		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,scala,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,preconditions,check,not,null,input,get,data,set,input,get,data,set,get,type,preconditions,check,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
ScalaAggregateOperator -> public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field);1453803455;Grouped aggregation__@param input_@param function_@param field;public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Preconditions.checkNotNull(input).getInputDataSet(), input.getInputDataSet().getType())___		Preconditions.checkNotNull(function)___		if (!input.getInputDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getInputDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,scala,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,preconditions,check,not,null,input,get,input,data,set,input,get,input,data,set,get,type,preconditions,check,not,null,function,if,input,get,input,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,input,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
ScalaAggregateOperator -> public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field);1454428544;Grouped aggregation__@param input_@param function_@param field;public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Preconditions.checkNotNull(input).getInputDataSet(), input.getInputDataSet().getType())___		Preconditions.checkNotNull(function)___		if (!input.getInputDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getInputDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,scala,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,preconditions,check,not,null,input,get,input,data,set,input,get,input,data,set,get,type,preconditions,check,not,null,function,if,input,get,input,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,input,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
ScalaAggregateOperator -> public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field);1454679829;Grouped aggregation__@param input_@param function_@param field;public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Preconditions.checkNotNull(input).getInputDataSet(), input.getInputDataSet().getType())___		Preconditions.checkNotNull(function)___		if (!input.getInputDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getInputDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,scala,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,preconditions,check,not,null,input,get,input,data,set,input,get,input,data,set,get,type,preconditions,check,not,null,function,if,input,get,input,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,input,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
ScalaAggregateOperator -> public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field);1465991918;Grouped aggregation__@param input_@param function_@param field;public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Preconditions.checkNotNull(input).getInputDataSet(), input.getInputDataSet().getType())___		Preconditions.checkNotNull(function)___		if (!input.getInputDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getInputDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,scala,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,preconditions,check,not,null,input,get,input,data,set,input,get,input,data,set,get,type,preconditions,check,not,null,function,if,input,get,input,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,input,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
ScalaAggregateOperator -> public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field);1496260727;Grouped aggregation.__@param input_@param function_@param field;public ScalaAggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Preconditions.checkNotNull(input).getInputDataSet(), input.getInputDataSet().getType())___		Preconditions.checkNotNull(function)___		if (!input.getInputDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getInputDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,scala,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,preconditions,check,not,null,input,get,input,data,set,input,get,input,data,set,get,type,preconditions,check,not,null,function,if,input,get,input,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,input,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
